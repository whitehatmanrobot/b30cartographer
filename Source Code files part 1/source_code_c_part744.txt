**********/
HRESULT wiauRegGetStrW(HKEY hkKey, PCWSTR pwszValueName, PWSTR pwszValue, DWORD *pdwLength)
{
    DBG_FN("wiauRegGetStrW");

    HRESULT hr = S_OK;
    
    //
    // Locals
    //
    LONG lReturn = 0;
    DWORD dwType = 0;

    REQUIRE_ARGS(!hkKey || !pwszValueName || !pwszValue || !pdwLength, hr, "wiauRegGetStrW");

    lReturn = ::RegQueryValueExW(hkKey, pwszValueName, NULL, &dwType, (BYTE *) pwszValue, pdwLength);
    REQUIRE_WIN32(lReturn, hr, "wiauRegGetStrW", "RegQueryValueExW failed");

    if ((dwType != REG_SZ) &&
        (dwType != REG_EXPAND_SZ) &&
        (dwType != REG_MULTI_SZ)) {

        wiauDbgError("wiauRegGetStrW", "ReqQueryValueEx returned wrong type for key, %d", dwType);
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    return hr;
}

/**************************************************************************\
* wiauRegGetStrA
\**************************************************************************/
HRESULT wiauRegGetStrA(HKEY hkKey, PCSTR pszValueName, PSTR pszValue, DWORD *pdwLength)
{
    DBG_FN("wiauRegGetStrA");

    HRESULT hr = S_OK;
    
    //
    // Locals
    //
    LONG lReturn = 0;
    DWORD dwType = 0;

    REQUIRE_ARGS(!hkKey || !pszValueName || !pszValue || !pdwLength, hr, "wiauRegGetStrA");

    lReturn = ::RegQueryValueExA(hkKey, pszValueName, NULL, &dwType, (BYTE *) pszValue, pdwLength);
    REQUIRE_WIN32(lReturn, hr, "wiauRegGetStrA", "RegQueryValueExA failed");

    if ((dwType != REG_SZ) &&
        (dwType != REG_EXPAND_SZ) &&
        (dwType != REG_MULTI_SZ)) {

        wiauDbgError("wiauRegGetStrA", "ReqQueryValueEx returned wrong type for key, %d", dwType);
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    return hr;
}

/**************************************************************************\
* wiauRegGetDwordW
\**************************************************************************/
HRESULT wiauRegGetDwordW(HKEY hkKey, PCTSTR pwszValueName, DWORD *pdwValue)
{
    DBG_FN("wiauRegGetDwordW");

    HRESULT hr = S_OK;
    
    REQUIRE_ARGS(!hkKey || !pwszValueName || !pdwValue, hr, "wiauRegGetDwordW");

    //
    // Locals
    //
    LONG lReturn = 0;
    DWORD dwType = 0;
    DWORD dwLength = sizeof(*pdwValue);


    lReturn = ::RegQueryValueExW(hkKey, pwszValueName, NULL, &dwType, (BYTE *) pdwValue, &dwLength);
    REQUIRE_WIN32(lReturn, hr, "wiauRegGetDwordW", "RegQueryValueExW failed");

    if (dwType != REG_DWORD) {

        wiauDbgError("wiauRegGetDwordW", "ReqQueryValueEx returned wrong type for key, %d", dwType);
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:    
    return hr;
}

/**************************************************************************\
* wiauRegGetDwordA
\**************************************************************************/
HRESULT wiauRegGetDwordA(HKEY hkKey, PCSTR pszValueName, DWORD *pdwValue)
{
    DBG_FN("wiauRegGetDwordA");

    HRESULT hr = S_OK;
    
    REQUIRE_ARGS(!hkKey || !pszValueName || !pdwValue, hr, "wiauRegGetDword");

    //
    // Locals
    //
    LONG lReturn = 0;
    DWORD dwType = 0;
    DWORD dwLength = sizeof(*pdwValue);


    lReturn = ::RegQueryValueExA(hkKey, pszValueName, NULL, &dwType, (BYTE *) pdwValue, &dwLength);
    REQUIRE_WIN32(lReturn, hr, "wiauRegGetDwordA", "RegQueryValueExA failed");

    if (dwType != REG_DWORD) {

        wiauDbgError("wiauRegGetDwordA", "ReqQueryValueExA returned wrong type for key, %d", dwType);
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:    
    return hr;
}

/**************************************************************************\
* wiauStrW2C
\**************************************************************************/

HRESULT wiauStrW2C(WCHAR *pwszSrc, CHAR *pszDst, INT iSize)
{
    HRESULT hr = S_OK;
    INT iWritten = 0;

    REQUIRE_ARGS(!pwszSrc || !pszDst || iSize < 1, hr, "wiauStrW2C");

    iWritten = WideCharToMultiByte(CP_ACP, 0, pwszSrc, -1, pszDst, iSize, NULL, NULL);
    REQUIRE_FILEIO(iWritten != 0, hr, "wiauStrW2C", "WideCharToMultiByte failed");

Cleanup:
    return hr;
}

/**************************************************************************\
* wiauStrC2W
\**************************************************************************/

HRESULT wiauStrC2W(CHAR *pszSrc, WCHAR *pwszDst, INT iSize)
{
    HRESULT hr = S_OK;
    INT iWritten = 0;

    REQUIRE_ARGS(!pszSrc || !pwszDst || iSize < 1, hr, "wiauStrC2W");

    iWritten = MultiByteToWideChar(CP_ACP, 0, pszSrc, -1, pwszDst, iSize / sizeof(*pwszDst));
    REQUIRE_FILEIO(iWritten != 0, hr, "wiauStrC2W", "MultiByteToWideChar failed");

Cleanup:
    return hr;
}

/**************************************************************************\
* wiauStrW2W
\**************************************************************************/

HRESULT wiauStrW2W(WCHAR *pwszSrc, WCHAR *pwszDst, INT iSize)
{
    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pwszSrc || !pwszDst || iSize < 1, hr, "wiauStrW2W");

    if ((lstrlenW(pwszSrc) + 1) > (iSize / (INT) sizeof(*pwszDst))) {
        hr = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    lstrcpyW(pwszDst, pwszSrc);

Cleanup:
    return hr;
}

/**************************************************************************\
* wiauStrC2C
\**************************************************************************/

HRESULT wiauStrC2C(CHAR *pszSrc, CHAR *pszDst, INT iSize)
{
    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pszSrc || !pszDst || iSize < 1, hr, "wiauStrC2C");

    if ((lstrlenA(pszSrc) + 1) > iSize) {
        hr = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    lstrcpyA(pszDst, pszSrc);

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\util\sources.inc ===
#############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   DavePar
#
#Date:
#    3-Nov-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     WIA driver utility library
#
#############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=wiautil
TARGETTYPE=LIBRARY
TARGETPATH=$(OBJ_DIR)

PASS1_PUBLISH= \
        {$(O)\wiautil.lib=$(DDK_LIB_PATH)\wiautil.lib}

INCLUDES= \
        $(INCLUDES); \
        $(DDK_INC_PATH)

SOURCES= \
        ..\wiaprop.cpp \
        ..\gdipconv.cpp \
        ..\CImageStream.cpp \
        ..\wiaudbg.cpp \
        ..\other.cpp

#TARGETLIBS= $(TARGETLIBS) \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\util\cimagestream.cpp ===
/****************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        CImageStream.cpp
*
*  VERSION:     1.0
*
*  DATE:        11/8/2000
*
*  AUTHOR:      Dave Parsons
*
*  DESCRIPTION:
*    Implements a special IStream, which can be used with GDI+ image
*    format conversions.
*
*****************************************************************************/

#include "pch.h"

CImageStream::CImageStream() :
    m_pBuffer(NULL),
    m_iSize(0),
    m_iPosition(0),
    m_iOffset(0),

    m_cRef(1)
{
}

CImageStream::~CImageStream()
{
}

STDMETHODIMP CImageStream::SetBuffer(BYTE *pBuffer, INT iSize, SKIP_AMOUNT iSkipAmt)
{
    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pBuffer, hr, "SetBuffer");

    // wiauDbgDump("SetBuffer", "Buffer set to size %d bytes", iSize);

    m_pBuffer = pBuffer;
    m_iSize = iSize;
    m_iPosition = 0;
    switch (iSkipAmt) {
    case SKIP_OFF:
        m_iOffset = 0;
        break;
    case SKIP_FILEHDR:
        m_iOffset = sizeof(BITMAPFILEHEADER);
        break;
    case SKIP_BOTHHDR:
        m_iOffset = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
        break;
    default:
        m_iOffset = 0;
        break;
    }
    memset(&m_Header, 0, sizeof(m_Header));

Cleanup:
    return hr;
}

STDMETHODIMP CImageStream::QueryInterface(REFIID riid, void **ppvObject)
{
    if (ppvObject == 0)
    {
	    return E_POINTER;
    }

    if (riid == IID_IUnknown)
    {
	    AddRef();
	    *ppvObject = (IUnknown*) this;
	    return S_OK;
    }

    if (riid == IID_IStream)
    {
	    AddRef();
	    *ppvObject = (IStream *) this;
	    return S_OK;
    }

    *ppvObject = 0;
    return E_NOINTERFACE;
}

ULONG CImageStream::AddRef(VOID)
{
	return InterlockedIncrement(&m_cRef);
}

ULONG CImageStream::Release(VOID)
{
	ULONG result;

	result = InterlockedDecrement(&m_cRef);

	if(result == 0) {
		delete this;
	}

	return result;
}

STDMETHODIMP CImageStream::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT hr = S_OK;

    // wiauDbgDump("Read", "Reading %d bytes from buffer", cb);

    if (pcbRead)
    {
        *pcbRead = 0;
    }

    if (cb > 0)
    {
        if (m_iPosition >= m_iOffset + m_iSize)
        {
            wiauDbgError("Read", "Attempting to read past end of buffer");
            hr = S_FALSE;
            goto Cleanup;
        }
        
        if ((INT) cb > m_iOffset + m_iSize - m_iPosition)
        {
            hr = S_FALSE;
            cb = m_iOffset + m_iSize - m_iPosition;
        }

        if (m_iPosition < m_iOffset)
        {
            INT iBytesToReadInHeader = min((INT) cb, m_iOffset - m_iPosition);

            memcpy(pv, &m_Header + m_iPosition, iBytesToReadInHeader);
            pv = (PBYTE) pv + iBytesToReadInHeader;
            cb -= iBytesToReadInHeader;
            m_iPosition += iBytesToReadInHeader;

            if (pcbRead)
            {
                *pcbRead += iBytesToReadInHeader;
            }
        }

        if (cb > 0)
        {
            memcpy(pv, m_pBuffer + m_iPosition - m_iOffset, cb);
            m_iPosition += cb;

            if (pcbRead)
            {
                *pcbRead += cb;
            }
        }
    }

Cleanup:
    return hr;
}
    
STDMETHODIMP CImageStream::Write(const void *pv, ULONG cb, ULONG *pcbWritten)
{
    HRESULT hr = S_OK;

    // wiauDbgDump("Write", "Writing %d bytes into buffer", cb);

    if (pcbWritten)
    {
        *pcbWritten = 0;
    }

    if (cb > 0)
    {
        if (m_iPosition >= m_iOffset + m_iSize)
        {
            wiauDbgError("Write", "Attempting to write past end of buffer");
            hr = S_FALSE;
            goto Cleanup;
        }
        
        if ((INT) cb > m_iOffset + m_iSize - m_iPosition)
        {
            hr = S_FALSE;
            cb = m_iOffset + m_iSize - m_iPosition;
        }

        if (m_iPosition < m_iOffset)
        {
            INT iBytesToWriteInHeader = min((INT) cb, m_iOffset - m_iPosition);

            memcpy((PBYTE) &m_Header + m_iPosition, pv, iBytesToWriteInHeader);
            pv = (PBYTE) pv + iBytesToWriteInHeader;
            cb -= iBytesToWriteInHeader;
            m_iPosition += iBytesToWriteInHeader;

            if (pcbWritten)
            {
                *pcbWritten += iBytesToWriteInHeader;
            }
        }

        if (cb > 0)
        {
            memcpy(m_pBuffer + m_iPosition - m_iOffset, pv, cb);
            m_iPosition += cb;

            if (pcbWritten)
            {
                *pcbWritten += cb;
            }
        }
    }

Cleanup:
    return hr;
}

STDMETHODIMP CImageStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    HRESULT hr = S_OK;

    switch (dwOrigin)
    { 
        case STREAM_SEEK_SET: 
            m_iPosition = dlibMove.LowPart; 
            break;

        case STREAM_SEEK_CUR: 
            m_iPosition += (LONG) dlibMove.LowPart; 
            break;

        case STREAM_SEEK_END: 
            m_iPosition = m_iSize - (LONG) dlibMove.LowPart; 
            break;

        default:
            hr = E_INVALIDARG;
            goto Cleanup;
    }

    if (plibNewPosition)
    {
        plibNewPosition->HighPart = 0;
        plibNewPosition->LowPart = m_iPosition;
    }

    // wiauDbgDump("Seek", "Position set to %d in the buffer", m_iPosition);

Cleanup:
    return hr;
}

STDMETHODIMP CImageStream::SetSize(ULARGE_INTEGER libNewSize)
{
    HRESULT hr = S_OK;

    if (libNewSize.HighPart != 0 ||
        (LONG) libNewSize.LowPart > (m_iSize + m_iOffset)) {
        hr = STG_E_INVALIDFUNCTION;
    }

    return hr;
}

STDMETHODIMP CImageStream::CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
	return E_NOTIMPL;
}

STDMETHODIMP CImageStream::Commit(DWORD grfCommitFlags)
{
	return E_NOTIMPL;
}

STDMETHODIMP CImageStream::Revert( void)
{
	return E_NOTIMPL;
}

STDMETHODIMP CImageStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
	return E_NOTIMPL;
}

STDMETHODIMP CImageStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
	return E_NOTIMPL;
}

STDMETHODIMP CImageStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{     
    ZeroMemory(pstatstg, sizeof(STATSTG));

    pstatstg->type = STGTY_STREAM;
    pstatstg->cbSize.QuadPart = m_iSize;
    pstatstg->grfMode = STGM_READ;

    if (!(grfStatFlag & STATFLAG_NONAME))
    {
        pstatstg->pwcsName = NULL;
    }

    return S_OK;
}

STDMETHODIMP CImageStream::Clone(IStream **ppstm)
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\util\gdipconv.cpp ===
/****************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        gdipconv.cpp
*
*  VERSION:     1.0
*
*  DATE:        11/10/2000
*
*  AUTHOR:      Dave Parsons
*
*  DESCRIPTION:
*    Helper functions for using GDI+ to convert image formats.
*
*****************************************************************************/

#include "pch.h"

using namespace Gdiplus;

CWiauFormatConverter::CWiauFormatConverter() :
    m_Token(NULL),
    m_EncoderCount(0),
    m_pEncoderInfo(NULL)
{
    memset(&m_guidCodecBmp, 0, sizeof(m_guidCodecBmp));
}

CWiauFormatConverter::~CWiauFormatConverter()
{
    if (m_pEncoderInfo)
    {
        delete []m_pEncoderInfo;
        m_pEncoderInfo = NULL;
    }
    
    if (m_Token)
    {
        GdiplusShutdown(m_Token);
        m_Token = NULL;
    }
}

HRESULT CWiauFormatConverter::Init()
{
    HRESULT hr = S_OK;
    GpStatus Status = Ok;

    //
    // Locals
    //
    GdiplusStartupInput gsi;
    ImageCodecInfo *pEncoderInfo = NULL;

    if (m_pEncoderInfo != NULL) {
        wiauDbgError("Init", "Init has already been called");
        goto Cleanup;
    }

    //
    // Start up GDI+
    //
    Status = GdiplusStartup(&m_Token, &gsi, NULL);
    if (Status != Ok)
    {
        wiauDbgError("Init", "GdiplusStartup failed");
        hr = E_FAIL;
        goto Cleanup;
    }

    UINT cbCodecs = 0;

    Status = GetImageEncodersSize(&m_EncoderCount, &cbCodecs);
    if (Status != Ok)
    {
        wiauDbgError("Init", "GetImageEncodersSize failed");
        hr = E_FAIL;
        goto Cleanup;
    }

    m_pEncoderInfo = new BYTE[cbCodecs];
    REQUIRE_ALLOC(m_pEncoderInfo, hr, "Init");

    pEncoderInfo = (ImageCodecInfo *) m_pEncoderInfo;
    
    Status = GetImageEncoders(m_EncoderCount, cbCodecs, pEncoderInfo);
    if (Ok != Status)
    {
        wiauDbgError("Init", "GetImageEncoders failed");
        hr = E_FAIL;
        goto Cleanup;
    }

    for (UINT count = 0; count < m_EncoderCount; count++)
    {
        if (pEncoderInfo[count].FormatID == ImageFormatBMP)
        {
            m_guidCodecBmp = pEncoderInfo[count].Clsid;
            break;
        }
    }

Cleanup:
    if (FAILED(hr)) {
        if (m_pEncoderInfo)
            delete []m_pEncoderInfo;
        m_pEncoderInfo = NULL;
    }
    return hr;
}

BOOL CWiauFormatConverter::IsFormatSupported(const GUID *pguidFormat)
{
    BOOL result = FALSE;

    ImageCodecInfo *pEncoderInfo = (ImageCodecInfo *) m_pEncoderInfo;
    
    for (UINT count = 0; count < m_EncoderCount; count++)
    {
        if (pEncoderInfo[count].FormatID == *pguidFormat)
        {
            result = TRUE;
            break;
        }
    }

    return result;
}

HRESULT CWiauFormatConverter::ConvertToBmp(BYTE *pSource, INT iSourceSize,
                                           BYTE **ppDest, INT *piDestSize,
                                           BMP_IMAGE_INFO *pBmpImageInfo, SKIP_AMOUNT iSkipAmt)
{
    HRESULT hr = S_OK;

    //
    // Locals
    //
    GpStatus Status = Ok;
    CImageStream *pInStream = NULL;
    CImageStream *pOutStream = NULL;
    Image *pSourceImage = NULL;
    BYTE *pTempBuf = NULL;
    SizeF gdipSize;

    //
    // Check args
    //
    REQUIRE_ARGS(!pSource || !ppDest || !piDestSize || !pBmpImageInfo, hr, "ConvertToBmp");

    memset(pBmpImageInfo, 0, sizeof(BMP_IMAGE_INFO));

    //
    // Create a CImageStream from the source memory
    //
    pInStream = new CImageStream;
    REQUIRE_ALLOC(pInStream, hr, "ConvertToBmp");

    hr = pInStream->SetBuffer(pSource, iSourceSize);
    REQUIRE_SUCCESS(hr, "ConvertToBmp", "SetBuffer failed");

    //
    // Create a GDI+ Image object from the IStream
    //
    pSourceImage = new Image(pInStream);
    REQUIRE_ALLOC(pSourceImage, hr, "ConvertToBmp");
    
    if (pSourceImage->GetLastStatus() != Ok)
    {
        wiauDbgError("ConvertToBmp", "Image constructor failed");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Ask GDI+ for the image dimensions, and fill in the
    // passed structure
    //
    Status = pSourceImage->GetPhysicalDimension(&gdipSize);
    if (Status != Ok)
    {
        wiauDbgError("ConvertToBmp", "GetPhysicalDimension failed");
        hr = E_FAIL;
        goto Cleanup;
    }

    pBmpImageInfo->Width = (INT) gdipSize.Width;
    pBmpImageInfo->Height = (INT) gdipSize.Height;
    
    PixelFormat PixFmt = pSourceImage->GetPixelFormat();
    DWORD PixDepth = (PixFmt & 0xFFFF) >> 8;   // Cannot assume image is always 24bits/pixel
    if( PixDepth < 24 ) 
        PixDepth = 24; 
    pBmpImageInfo->ByteWidth = ((pBmpImageInfo->Width * PixDepth + 31) & ~31) / 8;
    pBmpImageInfo->Size = pBmpImageInfo->ByteWidth * pBmpImageInfo->Height;

    switch (iSkipAmt) {
    case SKIP_OFF:
        pBmpImageInfo->Size += sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
        break;
    case SKIP_FILEHDR:
        pBmpImageInfo->Size += sizeof(BITMAPINFOHEADER);
        break;
    case SKIP_BOTHHDR:
        break;
    default:
        break;
    }
    
    if (pBmpImageInfo->Size == 0)
    {
        wiauDbgError("ConvertToBmp", "Size of image is zero");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // See if the caller passed in a destination buffer, and make sure
    // it is big enough.
    //
    if (*ppDest) {
        if (*piDestSize < pBmpImageInfo->Size) {
            wiauDbgError("ConvertToBmp", "Passed buffer is too small");
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    //
    // Otherwise allocate memory for a buffer
    //
    else
    {
        pTempBuf = new BYTE[pBmpImageInfo->Size];
        REQUIRE_ALLOC(pTempBuf, hr, "ConvertToBmp");

        *ppDest = pTempBuf;
        *piDestSize = pBmpImageInfo->Size;
    }

    //
    // Create output IStream
    //
    pOutStream = new CImageStream;
    REQUIRE_ALLOC(pOutStream, hr, "ConvertToBmp");

    hr = pOutStream->SetBuffer(*ppDest, pBmpImageInfo->Size, iSkipAmt);
    REQUIRE_SUCCESS(hr, "ConvertToBmp", "SetBuffer failed");

    //
    // Write the Image to the output IStream in BMP format
    //
    pSourceImage->Save(pOutStream, &m_guidCodecBmp, NULL);
    if (pSourceImage->GetLastStatus() != Ok)
    {
        wiauDbgError("ConvertToBmp", "GDI+ Save failed");
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    if (FAILED(hr)) {
        if (pTempBuf) {
            delete []pTempBuf;
            pTempBuf = NULL;
            *ppDest = NULL;
            *piDestSize = 0;
        }
    }
    if (pInStream) {
        pInStream->Release();
    }
    if (pOutStream) {
        pOutStream->Release();
    }
    if (pSourceImage) {
        delete pSourceImage;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\util\rwspy\detours.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  File:       detours.h
//  Module:     detours.lib
//
//  Detours for binary functions.  Version 1.3. (Build 43)
//
//  Copyright 1995-1999, Microsoft Corporation
//
//  http://research.microsoft.com/sn/detours
//

#pragma once
#ifndef _DETOURS_H_
#define _DETOURS_H_

#pragma comment(lib, "detours")

//////////////////////////////////////////////////////////////////////////////
//
#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct  _GUID
{
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
} GUID;
#endif // !GUID_DEFINED

#if defined(__cplusplus)
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID &
#endif // !_REFGUID_DEFINED
#else // !__cplusplus
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED
#endif // !__cplusplus
//
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/////////////////////////////////////////////////// Instruction Target Macros.
//
#define DETOUR_INSTRUCTION_TARGET_NONE          ((PBYTE)0)
#define DETOUR_INSTRUCTION_TARGET_DYNAMIC       ((PBYTE)~0ul)

/////////////////////////////////////////////////////////// Trampoline Macros.
//
// DETOUR_TRAMPOLINE(trampoline_prototype, target_name)
//
// The naked trampoline must be at least DETOUR_TRAMPOLINE_SIZE bytes.
//
#define DETOUR_TRAMPOLINE_SIZE          32
#define DETOUR_SECTION_HEADER_SIGNATURE 0x00727444   // "Dtr\0"

#define DETOUR_TRAMPOLINE(trampoline,target) \
static PVOID __fastcall _Detours_GetVA_##target(VOID) \
{ \
    return &target; \
} \
\
__declspec(naked) trampoline \
{ \
    __asm { nop };\
    __asm { nop };\
    __asm { call _Detours_GetVA_##target };\
    __asm { jmp eax };\
    __asm { ret };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
}

#define DETOUR_TRAMPOLINE_EMPTY(trampoline) \
__declspec(naked) trampoline \
{ \
    __asm { nop };\
    __asm { nop };\
    __asm { xor eax, eax };\
    __asm { mov eax, [eax] };\
    __asm { ret };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
}

/////////////////////////////////////////////////////////// Binary Structures.
//
#pragma pack(push, 8)
typedef struct _DETOUR_SECTION_HEADER
{
    DWORD       cbHeaderSize;
    DWORD       nSignature;
    DWORD       nDataOffset;
    DWORD       cbDataSize;
    
    DWORD       nOriginalImportVirtualAddress;
    DWORD       nOriginalImportSize;
    DWORD       nOriginalBoundImportVirtualAddress;
    DWORD       nOriginalBoundImportSize;
    
    DWORD       nOriginalIatVirtualAddress;
    DWORD       nOriginalIatSize;
    DWORD       nOriginalSizeOfImage;
    DWORD       nReserve;
} DETOUR_SECTION_HEADER, *PDETOUR_SECTION_HEADER;

typedef struct _DETOUR_SECTION_RECORD
{
    DWORD       cbBytes;
    DWORD       nReserved;
    GUID        guid;
} DETOUR_SECTION_RECORD, *PDETOUR_SECTION_RECORD;
#pragma pack(pop)

#define DETOUR_SECTION_HEADER_DECLARE(cbSectionSize) \
{ \
      sizeof(DETOUR_SECTION_HEADER),\
      DETOUR_SECTION_HEADER_SIGNATURE,\
      sizeof(DETOUR_SECTION_HEADER),\
      (cbSectionSize),\
      \
      0,\
      0,\
      0,\
      0,\
      \
      0,\
      0,\
      0,\
      0,\
}

///////////////////////////////////////////////////////////// Binary Typedefs.
//
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_BYWAY_CALLBACK)(PVOID pContext,
                                                         PCHAR pszFile,
                                                         PCHAR *ppszOutFile);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FILE_CALLBACK)(PVOID pContext,
                                                        PCHAR pszOrigFile,
                                                        PCHAR pszFile,
                                                        PCHAR *ppszOutFile);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_SYMBOL_CALLBACK)(PVOID pContext,
                                                          DWORD nOrdinal,
                                                          PCHAR pszOrigSymbol,
                                                          PCHAR pszSymbol,
                                                          PCHAR *ppszOutSymbol);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FINAL_CALLBACK)(PVOID pContext);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_EXPORT_CALLBACK)(PVOID pContext,
                                                          DWORD nOrdinal,
                                                          PCHAR pszName,
                                                          PBYTE pbCode);

typedef VOID * PDETOUR_BINARY;
typedef VOID * PDETOUR_LOADED_BINARY;

//////////////////////////////////////////////////////// Trampoline Functions.
//
PBYTE WINAPI DetourFunction(PBYTE pbTargetFunction,
                            PBYTE pbDetourFunction);

BOOL WINAPI DetourFunctionWithEmptyTrampoline(PBYTE pbTrampoline,
                                              PBYTE pbTarget,
                                              PBYTE pbDetour);

BOOL WINAPI DetourFunctionWithEmptyTrampolineEx(PBYTE pbTrampoline,
                                                PBYTE pbTarget,
                                                PBYTE pbDetour,
                                                PBYTE *ppbRealTrampoline,
                                                PBYTE *ppbRealTarget,
                                                PBYTE *ppbRealDetour);

BOOL  WINAPI DetourFunctionWithTrampoline(PBYTE pbTrampoline,
                                          PBYTE pbDetour);

BOOL  WINAPI DetourFunctionWithTrampolineEx(PBYTE pbTrampoline,
                                            PBYTE pbDetour,
                                            PBYTE *ppbRealTrampoline,
                                            PBYTE *ppbRealTarget);

BOOL  WINAPI DetourRemove(PBYTE pbTrampoline, PBYTE pbDetour);

////////////////////////////////////////////////////////////// Code Functions.
//
PBYTE WINAPI DetourFindFunction(PCHAR pszModule, PCHAR pszFunction);
PBYTE WINAPI DetourGetFinalCode(PBYTE pbCode, BOOL fSkipJmp);

PBYTE WINAPI DetourCopyInstruction(PBYTE pbDst, PBYTE pbSrc, PBYTE *ppbTarget);
PBYTE WINAPI DetourCopyInstructionEx(PBYTE pbDst,
                                     PBYTE pbSrc,
                                     PBYTE *ppbTarget,
                                     LONG *plExtra);

///////////////////////////////////////////////////// Loaded Binary Functions.
//
HMODULE WINAPI DetourEnumerateModules(HMODULE hModuleLast);
PBYTE WINAPI DetourGetEntryPoint(HMODULE hModule);
BOOL WINAPI DetourEnumerateExports(HMODULE hModule,
                                   PVOID pContext,
                                   PF_DETOUR_BINARY_EXPORT_CALLBACK pfExport);

PBYTE WINAPI DetourFindPayload(HMODULE hModule, REFGUID rguid, DWORD *pcbData);
DWORD WINAPI DetourGetSizeOfPayloads(HMODULE hModule);

///////////////////////////////////////////////// Persistent Binary Functions.
//
BOOL WINAPI DetourBinaryBindA(PCHAR pszFile, PCHAR pszDll, PCHAR pszPath);
BOOL WINAPI DetourBinaryBindW(PWCHAR pwzFile, PWCHAR pwzDll, PWCHAR pwzPath);
#ifdef UNICODE
#define DetourBinaryBind  DetourBinaryBindW
#else
#define DetourBinaryBind  DetourBinaryBindA
#endif // !UNICODE

PDETOUR_BINARY WINAPI DetourBinaryOpen(HANDLE hFile);
PBYTE WINAPI DetourBinaryEnumeratePayloads(PDETOUR_BINARY pBinary,
                                           GUID *pGuid,
                                           DWORD *pcbData,
                                           DWORD *pnIterator);
PBYTE WINAPI DetourBinaryFindPayload(PDETOUR_BINARY pBinary,
                                     REFGUID rguid,
                                     DWORD *pcbData);
PBYTE WINAPI DetourBinarySetPayload(PDETOUR_BINARY pBinary,
                                    REFGUID rguid,
                                    PBYTE pbData,
                                    DWORD cbData);
BOOL WINAPI DetourBinaryDeletePayload(PDETOUR_BINARY pBinary, REFGUID rguid);
BOOL WINAPI DetourBinaryPurgePayloads(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryResetImports(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryEditImports(PDETOUR_BINARY pBinary,
                                    PVOID pContext,
                                    PF_DETOUR_BINARY_BYWAY_CALLBACK pfByway,
                                    PF_DETOUR_BINARY_FILE_CALLBACK pfFile,
                                    PF_DETOUR_BINARY_SYMBOL_CALLBACK pfSymbol,
                                    PF_DETOUR_BINARY_FINAL_CALLBACK pfFinal);
BOOL WINAPI DetourBinaryWrite(PDETOUR_BINARY pBinary, HANDLE hFile);
BOOL WINAPI DetourBinaryClose(PDETOUR_BINARY pBinary);

/////////////////////////////////////////////// First Chance Exception Filter.
//
LPTOP_LEVEL_EXCEPTION_FILTER WINAPI
DetourFirstChanceExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelFilter);

///////////////////////////////////////////////// Create Process & Inject Dll.
//
typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEA)
    (LPCSTR lpApplicationName,
     LPSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCSTR lpCurrentDirectory,
     LPSTARTUPINFOA lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation);

typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEW)
    (LPCWSTR lpApplicationName,
     LPWSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCWSTR lpCurrentDirectory,
     LPSTARTUPINFOW lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation);
                                  
BOOL WINAPI DetourCreateProcessWithDllA(LPCSTR lpApplicationName,
                                        LPSTR lpCommandLine,
                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        BOOL bInheritHandles,
                                        DWORD dwCreationFlags,
                                        LPVOID lpEnvironment,
                                        LPCSTR lpCurrentDirectory,
                                        LPSTARTUPINFOA lpStartupInfo,
                                        LPPROCESS_INFORMATION lpProcessInformation,
                                        LPCSTR lpDllName,
                                        PDETOUR_CREATE_PROCESS_ROUTINEA
                                        pfCreateProcessA);

BOOL WINAPI DetourCreateProcessWithDllW(LPCWSTR lpApplicationName,
                                        LPWSTR lpCommandLine,
                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        BOOL bInheritHandles,
                                        DWORD dwCreationFlags,
                                        LPVOID lpEnvironment,
                                        LPCWSTR lpCurrentDirectory,
                                        LPSTARTUPINFOW lpStartupInfo,
                                        LPPROCESS_INFORMATION lpProcessInformation,
                                        LPCWSTR lpDllName,
                                        PDETOUR_CREATE_PROCESS_ROUTINEW
                                        pfCreateProcessW);
                  
#ifdef UNICODE
#define DetourCreateProcessWithDll  DetourCreateProcessWithDllW
#define PDETOUR_CREATE_PROCESS_ROUTINE     PDETOUR_CREATE_PROCESS_ROUTINEW
#else
#define DetourCreateProcessWithDll  DetourCreateProcessWithDllA
#define PDETOUR_CREATE_PROCESS_ROUTINE     PDETOUR_CREATE_PROCESS_ROUTINEA
#endif // !UNICODE

BOOL WINAPI DetourContinueProcessWithDllA(HANDLE hProcess, LPCSTR lpDllName);
BOOL WINAPI DetourContinueProcessWithDllW(HANDLE hProcess, LPCWSTR lpDllName);

#ifdef UNICODE
#define DetourContinueProcessWithDll    DetourContinueProcessWithDllW
#else
#define DetourContinueProcessWithDll    DetourContinueProcessWithDllA
#endif // !UNICODE
//
//////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif // __cplusplus

/////////////////////////////////////////////////////////////////// Old Names.
//
#define ContinueProcessWithDll            DetourContinueProcessWithDll 
#define ContinueProcessWithDllA           DetourContinueProcessWithDllA
#define ContinueProcessWithDllW           DetourContinueProcessWithDllW
#define CreateProcessWithDll              DetourCreateProcessWithDll 
#define CreateProcessWithDllA             DetourCreateProcessWithDllA
#define CreateProcessWithDllW             DetourCreateProcessWithDllW
#define DETOUR_TRAMPOLINE_WO_TARGET       DETOUR_TRAMPOLINE_EMPTY
#define DetourBinaryPurgePayload          DetourBinaryPurgePayloads
#define DetourEnumerateExportsForInstance DetourEnumerateExports
#define DetourEnumerateInstances          DetourEnumerateModules
#define DetourFindEntryPointForInstance   DetourGetEntryPoint
#define DetourFindFinalCode               DetourGetFinalCode
#define DetourFindPayloadInBinary         DetourFindPayload
#define DetourGetSizeOfBinary             DetourGetSizeOfPayloads
#define DetourRemoveWithTrampoline        DetourRemove
#define PCREATE_PROCESS_ROUTINE           PDETOUR_CREATE_PROCESS_ROUTINE
#define PCREATE_PROCESS_ROUTINEA          PDETOUR_CREATE_PROCESS_ROUTINEA
#define PCREATE_PROCESS_ROUTINEW          PDETOUR_CREATE_PROCESS_ROUTINEW
//

#endif // _DETOURS_H_

////////////////////////////////////////////////////////////////  End of File.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\util\wiaudbg.cpp ===
/****************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        wiaudbg.cpp
*
*  VERSION:     1.0
*
*  DATE:        11/21/2000
*
*  AUTHOR:      
*
*  DESCRIPTION:
*    Implementation of debugging functions.
*
*****************************************************************************/

#include "pch.h"

//#include "cplusinc.h"
#include "stdlib.h"
#include "stdio.h"
#include <sddl.h>

// debug log is saved to this file 
#define WIAUDBG_FILE_NAME "%userprofile%\\wiadebug.log"
// registry key location
#define WIAUDBG_FLAGS_REGKEY "System\\CurrentControlSet\\Control\\StillImage\\Debug"
// registry DWORD value name
#define WIAUDBG_FLAGS_REGVAL "DebugFlags"
// registry DWORD for max log file size
#define WIAUDBG_REGVAL_FILE_SIZE_LIMIT "DebugFileSizeLimit"
#define WIAUDBG_FILE_SIZE_LIMIT (512 * 1024) // bytes
// Prefix for all messages
const CHAR PREFIX_WIA[] = "WIA: ";

// if we fail to acquire mutex within this time, shutdown tracing
const INT WIAUDBG_DEBUG_TIMEOUT = 10000;

// globals
DWORD  g_dwDebugFlags         = WIAUDBG_DEFAULT_FLAGS;
HANDLE g_hDebugFile           = INVALID_HANDLE_VALUE;
DWORD  g_dwDebugFileSizeLimit = WIAUDBG_FILE_SIZE_LIMIT;
BOOL   g_bDebugInited         = FALSE;

static CHAR   g_szDebugFileName[MAX_PATH] = "";
static CHAR   g_szModuleName[MAX_PATH]    = "";
static HANDLE g_hDebugFileMutex           = NULL;
static BOOL   g_bInited                   = FALSE;
static BOOL   g_bBannerPrinted            = FALSE;

#undef TRACE
#ifdef DEBUG
#define TRACE(x) WiauInternalTrace x
#else
#define TRACE(x)
#endif

////////////////////////////////////////////////
// WiauInternalTrace
//
// Internal tracing for problems in DebugWrite
//
static void WiauInternalTrace(LPCSTR fmt, ...)
{
    char buffer[1024] = {0};
    size_t len = 0;
    va_list marker;

    va_start(marker, fmt);

    _vsnprintf(buffer, sizeof(buffer) - 2, fmt, marker);
    len = strlen(buffer);

    if ((len > 0) && (len < sizeof(buffer) - 1))
    {
        // make sure the line has terminating "\n"
        if(buffer[len - 1] != '\n') {
            buffer[len++] = '\n';
            buffer[len] = '\0';
        }
        OutputDebugStringA(buffer);
    }

    va_end(marker);
}


////////////////////////////////////////////////
// WiauCreateLogFileMutex
//
// Create logfile mutex with appropriate DACL
//
BOOL WiauCreateLogFileMutex(void)
{
#undef CHECK
#define CHECK(x) if(!(x)) { \
     TRACE(("%s(%d): %s failed (%d)", __FILE__, __LINE__, #x, GetLastError())); \
     goto Cleanup; } 
#undef CHECK2
#define CHECK2(x, y) if(!(x)) { \
     TRACE(("%s(%d): %s failed (%d)", __FILE__, __LINE__, #x, GetLastError())); \
     TRACE(y); goto Cleanup; } 

    const TCHAR *COREDBG_OBJECT_DACLS= TEXT("D:(A;OICI;GA;;;BA)")       // Admin
                                       TEXT(  "(A;OICI;GA;;;LS)")   // Local Service
                                       TEXT(  "(A;OICI;GA;;;AU)");  // Authenticated Users.


    SECURITY_ATTRIBUTES SA = {0};
    BOOL                bSuccess = FALSE;

    SA.nLength              = sizeof(SECURITY_ATTRIBUTES);
    SA.bInheritHandle       = FALSE;
    SA.lpSecurityDescriptor = NULL;

    if (ConvertStringSecurityDescriptorToSecurityDescriptor(
            COREDBG_OBJECT_DACLS,
            SDDL_REVISION_1, 
            &(SA.lpSecurityDescriptor), 
            NULL)) 
    {
        CHECK((g_hDebugFileMutex = CreateMutexA(&SA, FALSE, "Global\\WiaDebugFileMut")) != NULL);

        bSuccess = TRUE;
    } 

Cleanup:

    if (SA.lpSecurityDescriptor)
    {
        LocalFree(SA.lpSecurityDescriptor);
    }

    return bSuccess;
}

////////////////////////////////////////////////
// DebugWrite
//
// Writes specified number of bytes to a debug 
// file, creating it if needed. Thread-safe. 
// Registers any failure and from that point returns 
// immediately.
//
static void 
DebugWrite(LPCSTR buffer, DWORD n)
{
#undef CHECK
#define CHECK(x) if(!(x)) { \
    TRACE(("%s(%d): %s failed (%d)", __FILE__, __LINE__, #x, GetLastError())); \
    bCatastrophicFailure = TRUE; goto Cleanup; } 
#undef CHECK2
#define CHECK2(x, y) if(!(x)) { \
    TRACE(("%s(%d): %s failed (%d)", __FILE__, __LINE__, #x, GetLastError())); \
    TRACE(y); bCatastrophicFailure = TRUE; goto Cleanup; } 

    DWORD cbWritten;
    DWORD dwWaitResult;
    LARGE_INTEGER newPos = { 0, 0 };
    static BOOL bCatastrophicFailure = FALSE;
    BOOL bMutexAcquired = FALSE;

    // if something is broken, return immediately
    if(bCatastrophicFailure) return;

    // make sure we have file mutex
    if(!g_hDebugFileMutex) 
    {
        CHECK(WiauCreateLogFileMutex());
    }

    // acquire mutex
    dwWaitResult = WaitForSingleObject(g_hDebugFileMutex, WIAUDBG_DEBUG_TIMEOUT);

    // if we failed to acquire mutex within the specified timeout,
    // shutdown tracing (on free builds users will not know this)
    CHECK(dwWaitResult == WAIT_OBJECT_0 || dwWaitResult == WAIT_ABANDONED);

    bMutexAcquired = TRUE;

    // make sure we have open file
    if(g_hDebugFile == INVALID_HANDLE_VALUE)
    {
        // attempt to open file
        CHECK(ExpandEnvironmentStringsA(WIAUDBG_FILE_NAME, g_szDebugFileName, MAX_PATH));

        g_hDebugFile = CreateFileA(g_szDebugFileName, GENERIC_WRITE, 
            FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        CHECK2(g_hDebugFile != INVALID_HANDLE_VALUE, 
            ("g_szDebugFileName = '%s'", g_szDebugFileName)); 
    }

    // seek to the end of file
    CHECK(SetFilePointerEx(g_hDebugFile, newPos, &newPos, SEEK_END));

    // check the file size
    if(newPos.HighPart != 0 || newPos.LowPart > g_dwDebugFileSizeLimit)
    {
        static CHAR LogFullMessage[128];

        TRACE(("Reached log file maximum size of %d", g_dwDebugFileSizeLimit));

        sprintf(LogFullMessage, "Log file reached maximum size of %d, logging stopped.", g_dwDebugFileSizeLimit);
        CHECK2(WriteFile(g_hDebugFile, LogFullMessage, strlen(LogFullMessage), &cbWritten, NULL), ("%d", cbWritten));
        bCatastrophicFailure = TRUE;
    }

    // write data
    CHECK2(WriteFile(g_hDebugFile, buffer, n, &cbWritten, NULL),
        ("%d %d", cbWritten, n));

    // make sure we write to the disk now.
    FlushFileBuffers(g_hDebugFile);

    CHECK2(cbWritten == n, ("%d %d", n, cbWritten))

Cleanup:
    if(bMutexAcquired) ReleaseMutex(g_hDebugFileMutex);
    return;
}

////////////////////////////////////////////////
// PrintBanner
//
// Since we append to the log file, we need a 
// seperator of some sort so we know when a 
// new execution has started.
//
void PrintBanner(void)
{
    char buffer[1024] = {0};
    size_t len = 0;

    SYSTEMTIME SysTime;
    GetLocalTime(&SysTime);

    if (g_dwDebugFlags)
    {
        _snprintf(buffer, 
                  sizeof(buffer) - 1, 
                  "====================Start '%s' Debug - Time: %d/%02d/%02d %02d:%02d:%02d:%02d\\r\\n====================",
                  g_szModuleName,
                  SysTime.wYear,
                  SysTime.wMonth,
                  SysTime.wDay,
                  SysTime.wHour,
                  SysTime.wMinute,
                  SysTime.wSecond,
                  SysTime.wMilliseconds);

        buffer[sizeof(buffer) - 1] = '\0';
    }

    len = strlen(buffer);
    if(len > 0) 
    {
        if(!(g_dwDebugFlags & WIAUDBG_DONT_LOG_TO_FILE))
        {
            DebugWrite(buffer, len);
        }

        if(!(g_dwDebugFlags & WIAUDBG_DONT_LOG_TO_DEBUGGER))
        {
            OutputDebugStringA(buffer);
        }
    }

    return;
}


////////////////////////////////////////////////
// wiauDbgHelper
//
// Formats message and writes it into log file 
// and/or debugger;
//
void wiauDbgHelper(LPCSTR prefix,
                   LPCSTR fname,
                   LPCSTR fmt,
                   va_list marker)
{
    char buffer[1024] = {0};
    size_t len = 0;

    if(!g_bDebugInited) 
    {
        wiauDbgInit(NULL);  
    }
    
    //
    // The first time we ever print a debug statement, lets 
    // output a seperator line since when we output to file
    // we append, this way we can seperate different execution
    // sessions.
    //
    if (!g_bBannerPrinted)
    {
        PrintBanner();
        g_bBannerPrinted = TRUE;
    }

    if (g_dwDebugFlags & WIAUDBG_PRINT_TIME) 
    {
        SYSTEMTIME MsgTime;
        GetLocalTime(&MsgTime);

        _snprintf(buffer,
                  sizeof(buffer) - 1,
                  "%s%s[%02d:%02d:%02d.%03d] %s: ",
                  PREFIX_WIA,
                  prefix,
                  MsgTime.wHour, 
                  MsgTime.wMinute, 
                  MsgTime.wSecond, 
                  MsgTime.wMilliseconds,
                  fname);

        buffer[sizeof(buffer) - 1] = '\0';
    }
    else
    {
        _snprintf(buffer,
                  sizeof(buffer) - 1,
                  "%s%s%s: ",
                  PREFIX_WIA,
                  prefix,
                  fname);

        buffer[sizeof(buffer) - 1] = '\0';
    }

    
    len = strlen(buffer);

    if (len < sizeof(buffer) - 2)
    {
        _vsnprintf(buffer + len, 
                   sizeof(buffer) - len - 2,
                   fmt, 
                   marker);

        buffer[sizeof(buffer) - 1] = '\0';
    }

    len = strlen(buffer);

    if ((len > 0) && (len <= sizeof(buffer)))
    {
        if (len > sizeof(buffer) - 2)
        {
            len = sizeof(buffer) - 2;
        }

        // make sure the line has terminating "\n"
        if (buffer[len - 1] != '\n') 
        {
            buffer[len++] = '\r';
            buffer[len++] = '\n';
            buffer[len] = '\0';
        }

        if(!(g_dwDebugFlags & WIAUDBG_DONT_LOG_TO_FILE))
        {
            DebugWrite(buffer, len);
        }

        if(!(g_dwDebugFlags & WIAUDBG_DONT_LOG_TO_DEBUGGER))
        {
            OutputDebugStringA(buffer);
        }
    }
}


////////////////////////////////////////////////
// wiauDbgHelper2
//
// Takes printf style arguments and calls wiauDbgHelper
//
void wiauDbgHelper2(LPCSTR prefix,
                    LPCSTR fname,
                    LPCSTR fmt,
                    ...)
{
    va_list marker;

    va_start(marker, fmt);
    wiauDbgHelper(prefix, fname, fmt, marker);
    va_end(marker);
}


////////////////////////////////////////////////
// GetRegDWORD
//
// Attempts to get a DWORD from the specified
// location.  If bSetIfNotExist is set, it 
// writes the registry setting to the current
// value in pdwValue.
//
LRESULT GetRegDWORD(HKEY        hKey,
                    const CHAR  *pszRegValName,
                    DWORD       *pdwValue,
                    BOOL        bSetIfNotExist)
{
    LRESULT lResult = ERROR_SUCCESS;
    DWORD   dwSize  = 0;
    DWORD   dwType  = REG_DWORD;

    if ((hKey          == NULL) ||
        (pszRegValName == NULL) ||
        (pdwValue      == NULL))
    {
        return ERROR_INVALID_HANDLE;
    }

    dwSize = sizeof(DWORD);

    lResult = RegQueryValueExA(hKey, 
                               pszRegValName, 
                               NULL, 
                               &dwType,
                               (BYTE*) pdwValue, 
                               &dwSize);

    // if we didn't find the key, create it.
    if (bSetIfNotExist)
    {
        if ((lResult != ERROR_SUCCESS) || 
            (dwType  != REG_DWORD))
        {
            lResult = RegSetValueExA(hKey, 
                                     pszRegValName, 
                                     0, 
                                     REG_DWORD, 
                                     (BYTE*) pdwValue, 
                                     dwSize);
        }
    }

    return lResult;
}

////////////////////////////////////////////////
// wiauDbgInit
//
// Overwrite g_dwDebugFlags and g_dwDebugFileSizeLimit 
// from registry
//
void wiauDbgInit(HINSTANCE hInstance)
{
    HKEY        hKey         = NULL;
    DWORD       dwDispositon = 0;
    DWORD       dwData;
    DWORD       dwDisposition               = 0;
    CHAR        szModulePath[MAX_PATH + 1]  = {0};
    CHAR        szDebugKey[1023 + 1]        = {0};
    CHAR        *pszFileName                = NULL;

    GetModuleFileNameA(hInstance, szModulePath, sizeof(szModulePath) - 1);
    pszFileName = strrchr(szModulePath, '\\');

    if (pszFileName == NULL) 
    {
        pszFileName = szModulePath;
    } 
    else 
    {
        pszFileName++;
    }

    //
    // build the registry key.
    //
    _snprintf(szDebugKey, sizeof(szDebugKey) - 1, "%s\\%s", WIAUDBG_FLAGS_REGKEY, pszFileName);
    lstrcpynA(g_szModuleName, pszFileName, sizeof(g_szModuleName));

    //
    // get/set the debug subkey.  The DebugValues value is stored on a per module
    // basis
    //
    if(RegCreateKeyExA(HKEY_LOCAL_MACHINE,
        szDebugKey,
        0,
        NULL,
        0,
        KEY_READ,
        NULL,
        &hKey,
        &dwDisposition) == ERROR_SUCCESS) 
    {
        dwData = g_dwDebugFlags;

        if (GetRegDWORD(hKey, WIAUDBG_FLAGS_REGVAL, &dwData, TRUE) == ERROR_SUCCESS)
        {
            g_dwDebugFlags = dwData;
        }

        RegCloseKey(hKey);
        hKey = NULL;
    }

    //
    // get/set the Max File Size value.  This is global to all debug modules since
    // the all write to the same file.
    //
    if(RegCreateKeyExA(HKEY_LOCAL_MACHINE,
        WIAUDBG_FLAGS_REGKEY,
        0,
        NULL,
        0,
        KEY_READ,
        NULL,
        &hKey,
        &dwDisposition) == ERROR_SUCCESS) 
    {
        dwData = g_dwDebugFileSizeLimit;

        if (GetRegDWORD(hKey, WIAUDBG_REGVAL_FILE_SIZE_LIMIT, &dwData, TRUE) == ERROR_SUCCESS)
        {
            g_dwDebugFileSizeLimit = dwData;
        }

        RegCloseKey(hKey);
        hKey = NULL;
    }

    g_bDebugInited = TRUE;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\util\wiaprop.cpp ===
/****************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        wiaprop.cpp
*
*  VERSION:     1.0
*
*  DATE:        11/10/2000
*
*  AUTHOR:      Dave Parsons
*
*  DESCRIPTION:
*    Helper functions for initializing WIA driver properties.
*
*****************************************************************************/

#include "pch.h"

//
// Constructor
//
CWiauPropertyList::CWiauPropertyList() :
        m_NumAlloc(0),
        m_NumProps(0),
        m_pId(NULL),
        m_pNames(NULL),
        m_pCurrent(NULL),
        m_pPropSpec(NULL),
        m_pAttrib(NULL)
{
}

//
// Destructor
//
CWiauPropertyList::~CWiauPropertyList()
{
    if (m_pId)
        delete []m_pId;
    if (m_pNames)
        delete []m_pNames;
    if (m_pCurrent)
        delete []m_pCurrent;
    if (m_pPropSpec)
        delete []m_pPropSpec;
    if (m_pAttrib)
        delete []m_pAttrib;
}

//
// This function allocates the property arrays
//
// Input:
//   NumProps -- number of properties to reserve space for. This number can be larger
//               than the actual number used, but cannot be smaller.
//
HRESULT
CWiauPropertyList::Init(INT NumProps)
{
    HRESULT hr = S_OK;

    REQUIRE_ARGS(NumProps < 1, hr, "Init");

    if (m_NumAlloc > 0)
    {
        wiauDbgError("Init", "Property list already initialized");
        hr = E_FAIL;
        goto Cleanup;
    }

    m_pId       = new PROPID[NumProps];
    m_pNames    = new LPOLESTR[NumProps];
    m_pCurrent  = new PROPVARIANT[NumProps];
    m_pPropSpec = new PROPSPEC[NumProps];
    m_pAttrib   = new WIA_PROPERTY_INFO[NumProps];

    REQUIRE_ALLOC(m_pId, hr, "Init");
    REQUIRE_ALLOC(m_pNames, hr, "Init");
    REQUIRE_ALLOC(m_pCurrent, hr, "Init");
    REQUIRE_ALLOC(m_pPropSpec, hr, "Init");
    REQUIRE_ALLOC(m_pAttrib, hr, "Init");

    m_NumAlloc = NumProps;
    m_NumProps = 0;

Cleanup:

    if ((m_pId       == NULL) ||
        (m_pNames    == NULL) ||
        (m_pCurrent  == NULL) ||
        (m_pPropSpec == NULL) ||
        (m_pAttrib   == NULL))
    {
        delete m_pId;
        delete m_pNames;
        delete m_pCurrent;
        delete m_pPropSpec;
        delete m_pAttrib;

        m_pId       = NULL;
        m_pNames    = NULL;
        m_pCurrent  = NULL;
        m_pPropSpec = NULL;
        m_pAttrib   = NULL;

        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//
// This function adds a property definition to the arrays
//
// Input:
//   index -- pointer to an int that will be set to the array index, useful
//            for passing to other property functions
//   PropId -- property ID constant
//   PropName -- property name string
//   Access -- determines access to the property, usually either
//             WIA_PROP_READ or WIA_PROP_RW
//   SubType -- indicates subtype of the property, usually either WIA_PROP_NONE,
//              WIA_PROP_RANGE, or WIA_PROP_LIST
//
HRESULT
CWiauPropertyList::DefineProperty(int *pIdx, PROPID PropId, LPOLESTR PropName, ULONG Access, ULONG SubType)
{
    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pIdx, hr, "DefineProperty");

    if (m_NumProps >= m_NumAlloc)
    {
        wiauDbgError("DefineProperty", "PropertyList is full. Increase number passed to Init");
        hr = E_FAIL;
        goto Cleanup;
    }

    int idx = m_NumProps++;

    m_pId[idx] = PropId;

    m_pNames[idx] = PropName;

    m_pCurrent[idx].vt = VT_EMPTY;

    m_pPropSpec[idx].ulKind = PRSPEC_PROPID;
    m_pPropSpec[idx].propid = PropId;

    m_pAttrib[idx].vt = VT_EMPTY;
    m_pAttrib[idx].lAccessFlags = Access | SubType;

    if (pIdx)
        *pIdx = idx;

Cleanup:
    return hr;
}

//
// This function sends all the newly created properties to WIA
//
// Input:
//   pWiasContext -- pointer to the context passed to drvInitItemProperties
//
HRESULT
CWiauPropertyList::SendToWia(BYTE *pWiasContext)
{
    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pWiasContext, hr, "SendToWia");

    if (m_NumProps == 0)
    {
        wiauDbgError("SendToWia", "No properties in the array, use DefineProperty");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  Set the property names
    //
    hr = wiasSetItemPropNames(pWiasContext, m_NumProps, m_pId, m_pNames);
    REQUIRE_SUCCESS(hr, "SendToWia", "wiasSetItemPropNames failed");

    //
    // Set the default values for the properties
    //
    hr = wiasWriteMultiple(pWiasContext, m_NumProps, m_pPropSpec, m_pCurrent);
    REQUIRE_SUCCESS(hr, "SendToWia", "wiasWriteMultiple failed");

    //
    // Set property access and valid value info
    //
    hr =  wiasSetItemPropAttribs(pWiasContext, m_NumProps, m_pPropSpec, m_pAttrib);
    REQUIRE_SUCCESS(hr, "SendToWia", "wiasSetItemPropAttribs failed");

Cleanup:
    return hr;
}

//
// This function can be used to reset the access and subtype of a property
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   Access -- determines access to the property, usually either
//             WIA_PROP_READ or WIA_PROP_RW
//   SubType -- indicates subtype of the property, usually either WIA_PROP_NONE,
//              WIA_PROP_RANGE, or WIA_PROP_LIST
//
HRESULT
CWiauPropertyList::SetAccessSubType(INT index, ULONG Access, ULONG SubType)
{
    HRESULT hr = S_OK;

    if (m_pAttrib == NULL)
    {
        hr = E_POINTER;
    }
    else if (index >= m_NumAlloc)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);
    }

    if (hr == S_OK)
    {
        m_pAttrib[index].lAccessFlags = Access | SubType;
    }

    return hr;
}

//
// Polymorphic function for setting the type and current, default, and valid values of a
// property. This function handles flag properties.
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   defaultValue -- default setting of this property on the device
//   currentValue -- current setting of this property on the device
//   validFlags -- combination of all valid flags
//
HRESULT
CWiauPropertyList::SetValidValues(INT index, LONG defaultValue, LONG currentValue, LONG validFlags)
{
    HRESULT hr = S_OK;

    if ((m_pAttrib  == NULL) || 
        (m_pCurrent == NULL))
    {
        hr = E_POINTER;
    }
    else if (index >= m_NumAlloc)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);
    }

    if (hr == S_OK)
    {
        m_pAttrib[index].vt                       = VT_I4;
        m_pAttrib[index].ValidVal.Flag.Nom        = defaultValue;
        m_pAttrib[index].ValidVal.Flag.ValidBits  = validFlags;
        m_pAttrib[index].lAccessFlags            |= WIA_PROP_FLAG;
        
        m_pCurrent[index].vt   = VT_I4;
        m_pCurrent[index].lVal = currentValue;
    }

    return hr;
}

//
// Polymorphic function for setting the type and current, default, and valid values of a
// property. This function handles VT_I4 range.
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   defaultValue -- default setting of this property on the device
//   currentValue -- current setting of this property on the device
//   minValue -- minimum value for the range
//   maxValue -- maximum value for the range
//   stepValue -- step value for the range
//
HRESULT
CWiauPropertyList::SetValidValues(INT index, LONG defaultValue, LONG currentValue,
                                 LONG minValue, LONG maxValue, LONG stepValue)
{
    HRESULT hr = S_OK;

    if ((m_pAttrib  == NULL) ||
        (m_pCurrent == NULL))
    {
        hr = E_POINTER;
    }
    else if (index >= m_NumAlloc)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);
    }

    if (hr == S_OK)
    {
        m_pAttrib[index].vt                  = VT_I4;
        m_pAttrib[index].ValidVal.Range.Nom  = defaultValue;
        m_pAttrib[index].ValidVal.Range.Min  = minValue;
        m_pAttrib[index].ValidVal.Range.Max  = maxValue;
        m_pAttrib[index].ValidVal.Range.Inc  = stepValue;
        m_pAttrib[index].lAccessFlags       |= WIA_PROP_RANGE;
        
        m_pCurrent[index].vt   = VT_I4;
        m_pCurrent[index].lVal = currentValue;
    }

    return hr;
}

//
// Polymorphic function for setting the type and current, default, and valid values of a
// property. This function handles VT_I4 list.
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   defaultValue -- default setting of this property on the device
//   currentValue -- current setting of this property on the device
//   numValues -- number of values in the list
//   pValues -- pointer to the value list
//
HRESULT
CWiauPropertyList::SetValidValues(INT index, LONG defaultValue, LONG currentValue,
                                 INT numValues, PLONG pValues)
{
    HRESULT hr = S_OK;

    if ((m_pAttrib  == NULL) ||
        (m_pCurrent == NULL))
    {
        hr = E_POINTER;
    }
    else if (index >= m_NumAlloc)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);
    }

    if (hr == S_OK)
    {
        m_pAttrib[index].vt                      = VT_I4;
        m_pAttrib[index].ValidVal.List.Nom       = defaultValue;
        m_pAttrib[index].ValidVal.List.cNumList  = numValues;
        m_pAttrib[index].ValidVal.List.pList     = (BYTE*)pValues;
        m_pAttrib[index].lAccessFlags           |= WIA_PROP_LIST;
    
        m_pCurrent[index].vt   = VT_I4;
        m_pCurrent[index].lVal = currentValue;
    }

    return hr;    
}

//
// Polymorphic function for setting the type and current, default, and valid values of a
// property. This function handles VT_BSTR list.
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   defaultValue -- default setting of this property on the device
//   currentValue -- current setting of this property on the device
//   numValues -- number of values in the list
//   pValues -- pointer to the value list
//
HRESULT
CWiauPropertyList::SetValidValues(INT index, BSTR defaultValue, BSTR currentValue,
                                  INT numValues, BSTR *pValues)
{
    HRESULT hr = S_OK;

    if ((m_pAttrib  == NULL) ||
        (m_pCurrent == NULL))
    {
        hr = E_POINTER;
    }
    else if (index >= m_NumAlloc)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);
    }

    if (hr == S_OK)
    {
        m_pAttrib[index].vt                          = VT_BSTR;
        m_pAttrib[index].ValidVal.ListBStr.Nom       = defaultValue;
        m_pAttrib[index].ValidVal.ListBStr.cNumList  = numValues;
        m_pAttrib[index].ValidVal.ListBStr.pList     = pValues;
        m_pAttrib[index].lAccessFlags               |= WIA_PROP_LIST;
    
        m_pCurrent[index].vt      = VT_BSTR;
        m_pCurrent[index].bstrVal = currentValue;
    }

    return hr;     
}

//
// Polymorphic function for setting the type and current, default, and valid values of a
// property. This function handles VT_R4 range.
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   defaultValue -- default setting of this property on the device
//   currentValue -- current setting of this property on the device
//   minValue -- minimum value for the range
//   maxValue -- maximum value for the range
//   stepValue -- step value for the range
//
HRESULT
CWiauPropertyList::SetValidValues(INT index, FLOAT defaultValue, FLOAT currentValue,
                                  FLOAT minValue, FLOAT maxValue, FLOAT stepValue)
{
    HRESULT hr = S_OK;

    if ((m_pAttrib  == NULL) ||
        (m_pCurrent == NULL))
    {
        hr = E_POINTER;
    }
    else if (index >= m_NumAlloc)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);
    }

    if (hr == S_OK)
    {
        m_pAttrib[index].vt                       = VT_R4;
        m_pAttrib[index].ValidVal.RangeFloat.Nom  = defaultValue;
        m_pAttrib[index].ValidVal.RangeFloat.Min  = minValue;
        m_pAttrib[index].ValidVal.RangeFloat.Max  = maxValue;
        m_pAttrib[index].ValidVal.RangeFloat.Inc  = stepValue;
        m_pAttrib[index].lAccessFlags            |= WIA_PROP_RANGE;
        
        m_pCurrent[index].vt     = VT_R4;
        m_pCurrent[index].fltVal = currentValue;
    }

    return hr;
}

//
// Polymorphic function for setting the type and current, default, and valid values of a
// property. This function handles VT_R4 list.
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   defaultValue -- default setting of this property on the device
//   currentValue -- current setting of this property on the device
//   numValues -- number of values in the list
//   pValues -- pointer to the value list
//
HRESULT
CWiauPropertyList::SetValidValues(INT index, FLOAT defaultValue, FLOAT currentValue,
                                  INT numValues, PFLOAT pValues)
{
    HRESULT hr = S_OK;

    if ((m_pAttrib  == NULL) ||
        (m_pCurrent == NULL))
    {
        hr = E_POINTER;
    }
    else if (index >= m_NumAlloc)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);
    }

    if (hr == S_OK)
    {
        m_pAttrib[index].vt                           = VT_R4;
        m_pAttrib[index].ValidVal.ListFloat.Nom       = defaultValue;
        m_pAttrib[index].ValidVal.ListFloat.cNumList  = numValues;
        m_pAttrib[index].ValidVal.ListFloat.pList     = (BYTE*)pValues;
        m_pAttrib[index].lAccessFlags                |= WIA_PROP_LIST;
    
        m_pCurrent[index].vt     = VT_R4;
        m_pCurrent[index].fltVal = currentValue;
    }

    return hr;     
}

//
// Polymorphic function for setting the type and current, default, and valid values of a
// property. This function handles VT_CLSID list.
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   defaultValue -- default setting of this property on the device
//   currentValue -- current setting of this property on the device
//   numValues -- number of values in the list
//   pValues -- pointer to the value list
//
HRESULT
CWiauPropertyList::SetValidValues(INT index, CLSID *defaultValue, CLSID *currentValue,
                                  INT numValues, CLSID **pValues)
{
    HRESULT hr = S_OK;

    if ((m_pAttrib      == NULL) ||
        (m_pCurrent     == NULL) ||
        (defaultValue   == NULL) ||
        (pValues        == NULL))
    {
        hr = E_POINTER;
    }
    else if (index >= m_NumAlloc)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);
    }

    if (hr == S_OK)
    {
        m_pAttrib[index].vt                          = VT_CLSID;
        m_pAttrib[index].ValidVal.ListGuid.Nom       = *defaultValue;
        m_pAttrib[index].ValidVal.ListGuid.cNumList  = numValues;
        m_pAttrib[index].ValidVal.ListGuid.pList     = *pValues;
        m_pAttrib[index].lAccessFlags               |= WIA_PROP_LIST;
    
        m_pCurrent[index].vt    = VT_CLSID;
        m_pCurrent[index].puuid = currentValue;
    }

    return hr;    
}

//
// Polymorphic function for setting the type and current value for a VT_I4
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   value -- value to use for the current value
//
HRESULT
CWiauPropertyList::SetCurrentValue(INT index, LONG value)
{
    HRESULT hr = S_OK;

    if ((m_pAttrib  == NULL) ||
        (m_pCurrent == NULL))
    {
        hr = E_POINTER;
    }
    else if (index >= m_NumAlloc)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);
    }

    if (hr == S_OK)
    {
        m_pCurrent[index].vt   = VT_I4;
        m_pAttrib[index].vt    = VT_I4;
        m_pCurrent[index].lVal = value;
    }

    return hr;
}

//
// Polymorphic function for setting the type and current value for a VT_BSTR
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   value -- value to use for the current value
//
HRESULT
CWiauPropertyList::SetCurrentValue(INT index, BSTR value)
{
    HRESULT hr = S_OK;

    if ((m_pAttrib  == NULL) ||
        (m_pCurrent == NULL))
    {
        hr = E_POINTER;
    }
    else if (index >= m_NumAlloc)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);
    }

    if (hr == S_OK)
    {
        m_pCurrent[index].vt      = VT_BSTR;
        m_pAttrib[index].vt       = VT_BSTR;
        m_pCurrent[index].bstrVal = value;
    }

    return hr;
}

//
// Polymorphic function for setting the type and current value for a VT_R4
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   value -- value to use for the current value
//
HRESULT
CWiauPropertyList::SetCurrentValue(INT index, FLOAT value)
{
    HRESULT hr = S_OK;

    if ((m_pAttrib  == NULL) ||
        (m_pCurrent == NULL))
    {
        hr = E_POINTER;
    }
    else if (index >= m_NumAlloc)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);
    }

    if (hr == S_OK)
    {
        m_pCurrent[index].vt     = VT_R4;
        m_pAttrib[index].vt      = VT_R4;
        m_pCurrent[index].fltVal = value;
    }

    return hr;
}

//
// Polymorphic function for setting the type and current value for a VT_CLSID
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   value -- value to use for the current value
//
HRESULT
CWiauPropertyList::SetCurrentValue(INT index, CLSID *pValue)
{
    HRESULT hr = S_OK;

    if ((m_pAttrib  == NULL) ||
        (m_pCurrent == NULL))
    {
        hr = E_POINTER;
    }
    else if (index >= m_NumAlloc)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);
    }

    if (hr == S_OK)
    {
        m_pCurrent[index].vt     = VT_CLSID;
        m_pAttrib[index].vt      = VT_CLSID;
        m_pCurrent[index].puuid  = pValue;
    }

    return hr;
}

//
// Polymorphic function for setting the type and current value for a property which holds a SYSTEMTIME
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   value -- value to use for the current value
//
HRESULT
CWiauPropertyList::SetCurrentValue(INT index, PSYSTEMTIME value)
{
    HRESULT hr = S_OK;

    if ((m_pAttrib == NULL) ||
        (m_pCurrent == NULL))
    {
        hr = E_POINTER;
    }
    else if (index >= m_NumAlloc)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);
    }

    if (hr == S_OK)
    {
        m_pCurrent[index].vt           = VT_UI2 | VT_VECTOR;
        m_pAttrib[index].vt            = VT_UI2 | VT_VECTOR;
        m_pAttrib[index].lAccessFlags |= WIA_PROP_NONE;
        m_pCurrent[index].caui.cElems  = sizeof(SYSTEMTIME)/sizeof(WORD);
        m_pCurrent[index].caui.pElems  = (USHORT *) value;
    }

    return hr;
}

//
// Polymorphic function for setting the type and current value for a property which holds a VT_UI1 vector
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   value -- value to use for the current value
//   size -- number of elements in the vector
//
HRESULT
CWiauPropertyList::SetCurrentValue(INT index, BYTE *value, INT size)
{
    HRESULT hr = S_OK;

    if ((m_pAttrib  == NULL) ||
        (m_pCurrent == NULL))
    {
        hr = E_POINTER;
    }
    else if (index >= m_NumAlloc)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);
    }

    if (hr == S_OK)
    {
        m_pCurrent[index].vt          = VT_UI1 | VT_VECTOR;
        m_pAttrib[index].vt           = VT_UI1 | VT_VECTOR;
        m_pCurrent[index].caub.cElems = size;
        m_pCurrent[index].caub.pElems = value;
    }

    return hr;
}

//
// Finds the index given a property ID
//
INT
CWiauPropertyList::LookupPropId(PROPID PropId)
{
    for (int count = 0; count < m_NumProps; count++)
    {
        if (m_pId[count] == PropId)
            return count;
    }

    //
    // Value not found
    //
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\filter\inpin.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998-2000
 *
 *  TITLE:       inpin.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        9/7/98
 *               2000/11/13 - OrenR - Major bug fixes 
 *
 *  DESCRIPTION: This module implements CStillInputPin object.
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop

///////////////////////////////
// g_AcceptedMediaSubtypes
//
const CLSID* g_AcceptedMediaSubtypes[] =
{
     &MEDIATYPE_NULL,
     &MEDIASUBTYPE_RGB8,
     &MEDIASUBTYPE_RGB555,
     &MEDIASUBTYPE_RGB565,
     &MEDIASUBTYPE_RGB24,
     &MEDIASUBTYPE_RGB32,
     NULL
};

/*****************************************************************************

   CStillInputPin Constructor

   <Notes>

 *****************************************************************************/

CStillInputPin::CStillInputPin(TCHAR        *pObjName,
                               CStillFilter *pStillFilter,
                               HRESULT      *phr,
                               LPCWSTR      pPinName) :
    m_pSamples(NULL),
    m_SampleHead(0),
    m_SampleTail(0),
    m_SamplingSize(0),
    m_pBits(NULL),
    m_BitsSize(0),
    CBaseInputPin(pObjName, (CBaseFilter *)pStillFilter, &m_QueueLock, phr, pPinName)
{
    DBG_FN("CStillInputPin::CStillInputPin");
}


/*****************************************************************************

   CStillInputPin::CheckMediaType

   <Notes>

 *****************************************************************************/

HRESULT
CStillInputPin::CheckMediaType(const CMediaType* pmt)
{
    DBG_FN("CStillInputPin::CheckMediaType");
    ASSERT(this     !=NULL);
    ASSERT(pmt      !=NULL);

    HRESULT hr            = S_OK;
    INT     iMediaSubtype = 0; 

    //
    // Check for bad params
    //

    if (pmt == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CStillInputPin::CheckMediaType, failed because we received a "
                         "NULL CMediaType pointer"));
    }

    //
    // we only accept the subtypes in our 
    // g_AcceptedMediaSubtypes list above.
    //

    if (hr == S_OK)
    {
        //
        // This should be a Video media type, otherwise, no point in 
        // continuing.
        //
        const GUID *pType = pmt->Type();

        if ((pType  == NULL) ||
            (*pType != MEDIATYPE_Video))
        {
            hr = VFW_E_TYPE_NOT_ACCEPTED;    
        }
    }

    //
    // Search our g_AcceptedMediaSubtypes list to see if the we support
    // the subtype being requested.
    //
    if (hr == S_OK)
    {
        BOOL       bFound    = FALSE;
        const GUID *pSubType = pmt->Subtype();

        iMediaSubtype = 0;

        while ((g_AcceptedMediaSubtypes[iMediaSubtype] != NULL) && 
               (!bFound))
        {
            //
            // Check if the GUID passed in to us is equal to the
            //

            if ((pSubType) &&
                (*pSubType == *g_AcceptedMediaSubtypes[iMediaSubtype]))
            {
                hr = S_OK;
                bFound = TRUE;
            }
            else
            {
                ++iMediaSubtype;
            }
        }

        if (!bFound)
        {
            hr = VFW_E_TYPE_NOT_ACCEPTED;
        }
    }

    //
    // So far so good.  We found the requested SubType, so now verify
    // that we aren't using any compression.
    //
    if (hr == S_OK)
    {
        //
        // Assume that this won't work.
        //
        hr = VFW_E_TYPE_NOT_ACCEPTED;

        //
        // media type and subtype are acceptable 
        // check for compression. 
        //
        // We do not do any decompression at all.
        //

        BITMAPINFOHEADER *pBitmapInfoHeader = NULL;
        const GUID       *pFormatType       = pmt->FormatType();

        if (pFormatType)
        {
            if (*pFormatType == FORMAT_VideoInfo)
            {
                VIDEOINFOHEADER  *pVideoInfoHeader  = NULL;

                DBG_TRC(("CStillInputPin::CheckMediaType, FORMAT_VideoInfo"));
                pVideoInfoHeader = reinterpret_cast<VIDEOINFOHEADER*>(pmt->Format());

                if (pVideoInfoHeader)
                {
                    pBitmapInfoHeader = &(pVideoInfoHeader->bmiHeader);
                }
            }
        }

        if (pBitmapInfoHeader)
        {
            if ((pBitmapInfoHeader->biCompression == BI_RGB) ||
                (pBitmapInfoHeader->biCompression == BI_BITFIELDS))
            {
                //
                // Cool, this is an acceptable media type, return 
                // success
                //
                hr = S_OK;
            }
        }
    }

    //
    // Okay, we like this media type.  We now check it against the
    // current display.  For example, if the bit depth of this 
    // media type is greater than the video card currently supports,
    // then this will reject it, and ask for another.
    //
    if (hr == S_OK)
    {
        CImageDisplay ImageDisplay;

        hr = ImageDisplay.CheckMediaType(pmt);
    }

    return hr;
}


/*****************************************************************************

   CStillInputPin::EndOfStream

   This is just a filter -- we pretty much just forward this message on.

 *****************************************************************************/

HRESULT
CStillInputPin::EndOfStream()
{
    DBG_FN("CStillInputPin::EndOfStream");
    ASSERT(this!=NULL);
    ASSERT(m_pFilter!=NULL);

    //
    // We must call this according to the MSDN documentation.  It states
    // that this must be called to ensure that the state of the filter
    // is okay before we proceed to deliver this indicator.
    //
    HRESULT hr = CheckStreaming();

    if (hr == S_OK)
    {
        if (m_pFilter && ((CStillFilter*)m_pFilter)->m_pOutputPin)
        {
            hr =  ((CStillFilter*)m_pFilter)->m_pOutputPin->DeliverEndOfStream();

            CHECK_S_OK2(hr,("m_pOutputPin->DeliverEndOfStream()"));
    
            if (VFW_E_NOT_CONNECTED == hr)
            {
                hr = S_OK;
            }
        }
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CStillInputPin::BeginFlush

   This is just a filter -- we pretty much just forward this message on.

 *****************************************************************************/

HRESULT
CStillInputPin::BeginFlush()
{
    DBG_FN("CStillInputPin::BeginFlush");
    ASSERT(this!=NULL);
    ASSERT(m_pFilter!=NULL);

    //
    // We must call BeginFlush on the base input pin because it will set the
    // state of the object so that it cannot receive anymore media samples
    // while we are flushing.  Make sure we do this at the beginning of this
    // function.
    //
    HRESULT hr = CBaseInputPin::BeginFlush();

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Begin flush means we must empty out our sample queue.
    //

    int iSampleSize = m_SamplingSize;

    //
    // UnInitalize our sample queue to discard any samples we may currently
    // have queued.
    //
    hr = UnInitializeSampleQueue();
    CHECK_S_OK2(hr, ("CStillInputPin::BeginFlush, failed to uninitialize "
                     "sample queue"));

    //
    // Re-Initialize the sample queue so that we have our buffer, but it
    // is empty.
    //
    hr = InitializeSampleQueue(iSampleSize);
    CHECK_S_OK2(hr, ("CStillInputPin::BeginFlush, failed to re-initialize "
                     "the sample queue"));

    //
    // Deliver the BeginFlush message downstream
    //
    if (m_pFilter && ((CStillFilter*)m_pFilter)->m_pOutputPin)
    {
        hr =  ((CStillFilter*)m_pFilter)->m_pOutputPin->DeliverBeginFlush();
        if (VFW_E_NOT_CONNECTED == hr)
        {
            hr = S_OK;
        }
        CHECK_S_OK2(hr,("m_pOutputPin->DeliverBeginFlush()"));
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CStillInputPin::EndFlush

   This is just a filter -- we pretty much just forward this message on.

 *****************************************************************************/

HRESULT
CStillInputPin::EndFlush()
{
    DBG_FN("CStillInputPin::EndFlush");
    ASSERT(this!=NULL);
    ASSERT(m_pFilter!=NULL);

    HRESULT hr = E_POINTER;

    //
    // Deliver the EndFlush message downstream.
    //
    if (m_pFilter && ((CStillFilter*)m_pFilter)->m_pOutputPin)
    {
        hr = ((CStillFilter*)m_pFilter)->m_pOutputPin->DeliverEndFlush();

        if (VFW_E_NOT_CONNECTED == hr)
        {
            hr = S_OK;
        }

        CHECK_S_OK2(hr,("m_pOutputPin->DeliverEndFlush()"));
    }

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // We must call the EndFlush function implemented by the base input
    // pin as it will set the state of the object such that we are now
    // ready to receive new media samples again.  Make sure we call this at
    // the end of this function.
    //
    hr = CBaseInputPin::EndFlush();

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CStillInputPin::NewSegment

   This is just a filter -- we pretty much just forward this message on.

 *****************************************************************************/
HRESULT
CStillInputPin::NewSegment(REFERENCE_TIME tStart,
                           REFERENCE_TIME tStop,
                           double dRate)
{
    DBG_FN("CStillInputPin::NewSegment");
    ASSERT(this!=NULL);
    ASSERT(m_pFilter!=NULL);

    HRESULT hr = E_POINTER;

    if (m_pFilter && ((CStillFilter*)m_pFilter)->m_pOutputPin)
    {
        hr = ((CStillFilter*)m_pFilter)->m_pOutputPin->DeliverNewSegment(
                                                                tStart, 
                                                                tStop, 
                                                                dRate);

        if (VFW_E_NOT_CONNECTED == hr)
        {
            hr = S_OK;
        }

        CHECK_S_OK2(hr,("m_pOutputPin->DeliverNewSegment"
                        "(tStart, tStop, dRate)"));
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CStillInputPin::SetMediaType

   <Notes>

 *****************************************************************************/
HRESULT
CStillInputPin::SetMediaType(const CMediaType *pmt)
{
    DBG_FN("CStillInputPin::SetMediaType");

    ASSERT(this         !=NULL);
    ASSERT(m_pFilter    !=NULL);
    ASSERT(pmt          !=NULL);

    HRESULT hr = S_OK;

#ifdef DEBUG
    // Display the type of the media for debugging perposes
//    DBG_TRC(("CStillInputPin::SetMediaType, setting the following "
//             "media type for Still Filter"));
//    DisplayMediaType( pmt );
#endif


    if ((m_pFilter == NULL) ||
        (pmt       == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CStillInputPin::SetMediaType, received either a NULL "
                         "media type pointer, or our filter pointer is NULL.  "
                         "pmt = 0x%08lx, m_pFilter = 0x%08lx", pmt, m_pFilter));

        return hr;
    }
    
    BITMAPINFOHEADER    *pBitmapInfoHeader = NULL;
    const GUID          *pFormatType       = pFormatType = pmt->FormatType();

    if (hr == S_OK)
    {
        ASSERT(pFormatType != NULL);

        if (pFormatType)
        {
            // We need to get the BitmapInfoHeader

            if (*pFormatType == FORMAT_VideoInfo)
            {
                VIDEOINFOHEADER *pHdr = reinterpret_cast<VIDEOINFOHEADER*>(pmt->Format());

                if (pHdr)
                {
                    pBitmapInfoHeader = &(pHdr->bmiHeader);
                }
            }
            else
            {
                hr = E_FAIL;
                CHECK_S_OK2(hr, ("CStillInputPin::SetMediaType, received a Format Type other "
                         "than a FORMAT_VideoInfo.  This is the "
                         "only supported format"));
            }
            
            ASSERT (pBitmapInfoHeader != NULL);
        }
        else
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr, ("CStillInputPin::SetMediaType, pFormatType is NULL, this should "
                             "never happen"));
        }
    
        if (pBitmapInfoHeader)
        {
            hr = ((CStillFilter*)m_pFilter)->InitializeBitmapInfo(pBitmapInfoHeader);
        
            CHECK_S_OK2(hr,("m_pFilter->InitializeBitmapInfo()"));
        
            m_BitsSize = ((CStillFilter*)m_pFilter)->GetBitsSize();
        
            //
            // see if the base class likes it
            //
        
            hr = CBaseInputPin::SetMediaType(pmt);
            CHECK_S_OK2(hr,("CBaseInputPin::SetMediaType(pmt)"));
        }
        else
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr, ("CStillInputPin::SetMediaType, pBitmapInfoHeader is NULL, "
                             "this should never happen"));
        }
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CStillInputPin::Receive

   A new frame has arrived. If we have a sampling queue, put it into the
   queue, otherwise, deliver to the filter immediately.

 *****************************************************************************/

HRESULT
CStillInputPin::Receive(IMediaSample* pSample)
{
    ASSERT(this!=NULL);
    ASSERT(m_pFilter!=NULL);
    ASSERT(pSample!=NULL);

    HRESULT hr = E_POINTER;

    // 
    // Check all is well with the base class Receive function.
    //
    hr = CBaseInputPin::Receive(pSample);

    //
    // Check for bad args
    //

    if (hr == S_OK)
    {
        //
        // copy the sample data to the sampling queue
        //

        if ((DWORD)pSample->GetActualDataLength() == m_BitsSize)
        {
            BYTE *pBits = NULL;

            hr = pSample->GetPointer(&pBits);
            CHECK_S_OK2(hr,("CStillInputPin::Receive, "
                            "pSample->GetPointer(&pBits)"));

            if (SUCCEEDED(hr) && pBits)
            {
                if (m_SamplingSize > 1)
                {
                    //
                    // Add this sample's bits to our queue.
                    //
                    AddFrameToQueue(pBits);
                }
                else
                {
                    //
                    // single sample. send  it immediately
                    //

                    if (m_pFilter)
                    {
                        HRESULT hr2 = S_OK;

                        HGLOBAL hDib = NULL;

                        hr2 = CreateBitmap(pBits, &hDib);

                        CHECK_S_OK2(hr2, ("CStillInputFilter::Receive, "
                                          "CreateBitmap failed.  This "
                                          "is non fatal"));

                        if (hDib)
                        {
                            hr2 = DeliverBitmap(hDib);

                            CHECK_S_OK2(hr2, 
                                        ("CStillInputFilter::Receive, "
                                         "DeliverBitmap failed.  This "
                                         "is non fatal"));

                            hr2 = FreeBitmap(hDib);

                            CHECK_S_OK2(hr2, 
                                        ("CStillInputFilter::Receive, "
                                         "FreeBitmap failed.  This is "
                                         "non fatal"));
                        }
                    }
                    else
                    {
                        DBG_ERR(("CStillInputPin::Receive .m_pFilter is NULL, "
                                 "not calling DeliverSnapshot"));
                    }
                }
            }
            else
            {
                if (!pBits)
                {
                    DBG_ERR(("CStillInputPin::Receive, pBits is NULL"));
                }
            }
        }
        else
        {
            DBG_ERR(("CStillInputPin::Receive, pSample->GetActualDataLength "
                     "!= m_BitsSize"));
        }

        if (m_pFilter)
        {
            if (((CStillFilter*)m_pFilter)->m_pOutputPin)
            {
                hr = ((CStillFilter*)m_pFilter)->m_pOutputPin->Deliver(pSample);

                CHECK_S_OK2(hr,("CStillInputPin::Receive, "
                                "m_pFilter->m_pOutputPin->Deliver(pSample) "
                                "failed"));
            }
            else
            {
                hr = E_POINTER;
                CHECK_S_OK2(hr, ("CStillInputPin::Receive, "
                                 "m_pFilter->m_pOutputPin is NULL, not "
                                 "calling Deliver"));
            }
        }
        else
        {
            hr = E_POINTER;
            CHECK_S_OK2(hr, ("CStillInputPin::Receive, m_pFilter is NULL, "
                             "not calling m_pOutputPin->Deliver"));
            
        }

        //
        // it is possible that our output pin is not connected
        // we fake an error here.
        //

        if (VFW_E_NOT_CONNECTED == hr)
        {
            hr = S_OK;
        }
    }
    else
    {
        DBG_ERR(("CStillInputPin::Receive bad args detected, pSample is "
                 "NULL!"));
    }

    CHECK_S_OK(hr);
    return hr;
}

/*****************************************************************************

   CStillInputPin::Active

   <Notes>

 *****************************************************************************/

HRESULT
CStillInputPin::Active()
{
    DBG_FN("CStillInputPin::Active");
    ASSERT(this!=NULL);

    HRESULT hr;

    //
    // time to allocate sample queue
    //

    hr = InitializeSampleQueue(m_SamplingSize);
    CHECK_S_OK2(hr,("InitializeSampleQueue"));

    return hr;
}


/*****************************************************************************

   CStillInputPin::Inactive

   <Notes>

 *****************************************************************************/

HRESULT
CStillInputPin::Inactive()
{
    DBG_FN("CStillInputPin::Inactive");
    ASSERT(this!=NULL);

    HRESULT hr = S_OK;

    hr = UnInitializeSampleQueue();

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CStillInputPin::GetSamplingSize

   <Notes>

 *****************************************************************************/

int
CStillInputPin::GetSamplingSize()
{
    DBG_FN("CStillInputPin::GetSamplingSize");
    ASSERT(this!=NULL);

    return m_SamplingSize;
}


/*****************************************************************************

   CStillInputPin::SetSamplingSize

   <Notes>

 *****************************************************************************/

HRESULT
CStillInputPin::SetSamplingSize(int Size)
{
    DBG_FN("CStillInputPin::SetSamplingSize");
    ASSERT(this!=NULL);

    //
    // this can only be done when we are in stopped state
    //

    if (!IsStopped())
    {
        DBG_ERR(("Setting sampling size while not in stopped state"));
        return VFW_E_NOT_STOPPED;
    }

    return InitializeSampleQueue(Size);
}



/*****************************************************************************

   CStillInputPin::InitializeSampleQueue

   Initialize sampling queue. Each sample in the queue contain a frame and
   timestamp.

 *****************************************************************************/

HRESULT
CStillInputPin::InitializeSampleQueue(int Size)
{
    DBG_FN("CStillInputPin::InitializeSampleQueue");
    ASSERT(this!=NULL);

    HRESULT hr = S_OK;

    //
    // Check for bad args
    //

    if (Size < 0 || Size > MAX_SAMPLE_SIZE)
    {
        hr = E_INVALIDARG;
    }

    if (hr == S_OK)
    {
        m_QueueLock.Lock();

        if (!m_pSamples || Size != m_SamplingSize)
        {
            m_SamplingSize = Size;
            if (m_pSamples)
            {
                delete [] m_pSamples;
                m_pSamples = NULL;

                if (m_pBits)
                {
                    delete [] m_pBits;
                    m_pBits = NULL;
                }
            }

            //
            // if size is one, we do not allocate any sample cache at all.
            //

            if (Size > 1)
            {
                m_pSamples = new STILL_SAMPLE[Size];
                if (m_pSamples)
                {
                    m_pBits = new BYTE[m_BitsSize * Size];
                    if (m_pBits)
                    {
                        for (int i = 0; i < Size ; i++)
                        {
                            m_pSamples[i].pBits = m_pBits + i * m_BitsSize;
                        }
                    }
                    else
                    {
                        delete [] m_pSamples;
                        m_pSamples = NULL;

                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        m_SampleHead = 0;
        m_SampleTail = 0;

        m_QueueLock.Unlock();

        hr = S_OK;
    }

    CHECK_S_OK(hr);
    return hr;
}

/*****************************************************************************

   CStillInputPin::UnInitializeSampleQueue

   Initialize sampling queue. Each sample in the queue contain a frame and
   timestamp.

 *****************************************************************************/

HRESULT
CStillInputPin::UnInitializeSampleQueue()
{
    DBG_FN("CStillInputPin::UnInitializeSampleQueue");

    ASSERT(this!=NULL);

    HRESULT hr = S_OK;

    if (hr == S_OK)
    {
        m_QueueLock.Lock();

        if (m_pSamples)
        {
            delete [] m_pSamples;
            m_pSamples = NULL;

            delete [] m_pBits;
            m_pBits = NULL;
        }

        m_SampleHead = 0;
        m_SampleTail = 0;

        m_QueueLock.Unlock();
    }

    return hr;
}



/*****************************************************************************

   CStillInputPin::Snapshot

   Does a snapshot on the video stream.
   The give timestamp is compared against each queued sample and
   a final candidate is determined and delivered.

 *****************************************************************************/

HRESULT
CStillInputPin::Snapshot(ULONG TimeStamp)
{
    DBG_FN("CStillInputPin::Snapshot");

    ASSERT(this!=NULL);
    ASSERT(m_pFilter!=NULL);

    HRESULT hr = S_OK;

    //
    // if we do not have cache at all, do nothing
    //

    if (m_SamplingSize > 1 || m_pSamples)
    {
        m_QueueLock.Lock();

        HGLOBAL hDib                = NULL;
        int     MinTimeDifference   = INT_MAX;
        int     TimeDifference      = 0;
        int     PreferSampleIndex   = -1;
        int     iSampleHead         = m_SampleHead;
        int     iSampleTail         = m_SampleTail;

        if (iSampleTail == iSampleHead)
        {
            DBG_ERR(("CStillInputPin::Snapshot, sample queue is empty, "
                     "not able to deliver a snapshot"));
        }

        //
        // Search for the sample who's timestamp is closest to the requested 
        // timestamp.
        //
        while (iSampleTail != iSampleHead)
        {
            if (m_pSamples)
            {
                TimeDifference = abs(m_pSamples[iSampleTail].TimeStamp - 
                                     TimeStamp);
            }
            else
            {
                TimeDifference = 0;
            }

            if (MinTimeDifference > TimeDifference)
            {
                PreferSampleIndex = iSampleTail;
                MinTimeDifference = TimeDifference;
            }

            if (++iSampleTail >= m_SamplingSize)
                iSampleTail = 0;
        }

        //
        // We found our sample, now deliver it.
        // Notice that we unlock the queue after we created our bitmap AND 
        // before we deliver it.
        //
        // ***NOTE***
        // It is VERY important that we free the lock before delivering 
        // the bitmap because the delivery process will probably involve 
        // saving to a file which is very time consuming, which would 
        // guarantee that we drop frames, which we would like to try and 
        // avoid.
        //

        //
        // Create our bitmap.  This copies the bits out of the sample queue
        // so that they can be delivered.  Since the bits are copied out of 
        // the queue, we are safe in releasing the queue lock after the 
        // copy operation.
        //
        if (PreferSampleIndex != -1)
        {
            hr = CreateBitmap(m_pSamples[PreferSampleIndex].pBits, &hDib);
        }
        else
        {
            //
            // We couldn't find a sample, tell someone, and also dump
            // the sample queue for analysis, since this shouldn't really 
            // happen considering we receive about 15 to 30 samples per second.
            //
            DBG_WRN(("CStillInputPin::Snapshot, could not find sample with "
                     "close enough timestamp to requested timestamp of '%d'",
                     TimeStamp));

#ifdef DEBUG
            DumpSampleQueue(TimeStamp);
#endif
        }

        //
        // Unlock our queue.
        //
        m_QueueLock.Unlock();

        //
        // If we successfully created the bitmap, then deliver it, and then
        // free it.
        //
        if (hDib)
        {
            //
            // Deliver the bitmap via the registered callback function in the 
            // filter.
            //
            hr = DeliverBitmap(hDib);

            CHECK_S_OK2(hr, ("CStillInputPin::Snapshot, failed to deliver "
                             "bitmap"));

            //
            // Free the bitmap
            //
            FreeBitmap(hDib);
            hDib = NULL;
        }
    }
    

    CHECK_S_OK(hr);
    return hr;
}

/*****************************************************************************

   CStillInputPin::AddFrameToQueue

   <Notes>

 *****************************************************************************/

HRESULT
CStillInputPin::AddFrameToQueue(BYTE *pBits)
{
    HRESULT hr = S_OK;

    m_QueueLock.Lock();

    if (m_pSamples)
    {
        m_pSamples[m_SampleHead].TimeStamp = GetTickCount();

        memcpy(m_pSamples[m_SampleHead].pBits, pBits, m_BitsSize);

        if (++m_SampleHead >= m_SamplingSize)
        {
            m_SampleHead = 0;
        }

        if (m_SampleHead == m_SampleTail)
        {
            //
            //overflowing, discard the very last one
            //

            if (++m_SampleTail >= m_SamplingSize)
                m_SampleTail = 0;
        }
    }
    else
    {
        DBG_ERR(("CStillInputPin::AddFrameToQueue, m_pSamples is NULL!"));
    }

    m_QueueLock.Unlock();

    return hr;
}

/*****************************************************************************

   CStillInputPin::CreateBitmap

   <Notes>

 *****************************************************************************/

HRESULT 
CStillInputPin::CreateBitmap(BYTE    *pBits, 
                             HGLOBAL *phDib)
{
    DBG_FN("CStillInputPin::CreateBitmap");

    ASSERT(m_pFilter != NULL);
    ASSERT(this      != NULL);
    ASSERT(pBits     != NULL);
    ASSERT(phDib     != NULL);

    HRESULT hr = S_OK;

    if ((pBits == NULL) ||
        (phDib == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CStillInputPin::CreateBitmap received NULL param"));
    }
    else if (m_pFilter == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CStillInputPin::CreateBitmap, m_pFilter is NULL"));
    }

    if (hr == S_OK)
    {
        HGLOBAL hDIB = GlobalAlloc(GHND, 
                                   ((CStillFilter*)m_pFilter)->m_DIBSize);

        if (hDIB)
        {
            BYTE *pDIB = NULL;

            pDIB = (BYTE*) GlobalLock(hDIB);

            if ((pDIB) && (((CStillFilter*) m_pFilter)->m_pbmi))
            {
                DWORD dwSizeToCopy = 0;
                
                dwSizeToCopy = ((CStillFilter*) m_pFilter)->m_bmiSize + 
                               ((CStillFilter*) m_pFilter)->m_BitsSize;

                //
                // Copy the BitmapInfo header and the bits into the allocated
                // memory DIB.  Note that if the combined size of the bits
                // and header exceeds the memory we allocated, we abort.
                //
                if (dwSizeToCopy <= ((CStillFilter*)m_pFilter)->m_DIBSize)
                {
                    memcpy(pDIB, 
                           ((CStillFilter*) m_pFilter)->m_pbmi, 
                           ((CStillFilter*) m_pFilter)->m_bmiSize);
    
                    memcpy(pDIB + ((CStillFilter*) m_pFilter)->m_bmiSize, 
                           pBits, 
                           ((CStillFilter*) m_pFilter)->m_BitsSize);

                    GlobalUnlock(hDIB);
                    *phDib = hDIB;
                }
                else
                {
                    GlobalFree(hDIB);
                    hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                }
            }
            else
            {
                GlobalFree(hDIB);
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

/*****************************************************************************

   CStillInputPin::FreeBitmap

   <Notes>

 *****************************************************************************/

HRESULT
CStillInputPin::FreeBitmap(HGLOBAL hDib)
{
    DBG_FN("CStillInputPin::FreeBitmap");

    HRESULT hr = S_OK;

    if (hDib)
    {
        GlobalFree(hDib);
    }

    return hr;
}

/*****************************************************************************

   CStillInputPin::DeliverBitmap

   <Notes>

 *****************************************************************************/

HRESULT
CStillInputPin::DeliverBitmap(HGLOBAL hDib)
{
    DBG_FN("CStillInputPin::DeliverBitmap");

    ASSERT(m_pFilter != NULL);
    ASSERT(hDib      != NULL);

    HRESULT hr = S_OK;

    if ((m_pFilter == NULL) ||
        (hDib      == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CStillInputPin::DeliverBitmap received NULL "
                         "param"));
    }

    if (hr == S_OK)
    {
        hr = ((CStillFilter*)m_pFilter)->DeliverSnapshot(hDib);
    }

    return hr;
}


#ifdef DEBUG
/*****************************************************************************

   CStillInputPin::DumpSampleQueue

   Used for debugging, dumps the queue of samples showing their
   timestamps

 *****************************************************************************/

void
CStillInputPin::DumpSampleQueue(ULONG ulRequestedTimestamp)
{
    DBG_TRC(("***CStillPin::DumpSampleQueue, dumping queued filter samples, "
             "Requested TimeStamp = '%lu' ***", ulRequestedTimestamp));

    if (m_SamplingSize > 1 || m_pSamples)
    {
        for (int i = 0; i < m_SamplingSize; i++)
        {
            int TimeDifference;

            if (m_pSamples)
            {
                TimeDifference = abs(m_pSamples[i].TimeStamp - 
                                     ulRequestedTimestamp);
            }
            else
            {
                TimeDifference = 0;
            }

            DBG_PRT(("Sample: '%d',  Timestamp: '%lu', Abs Diff: '%d'",
                     i,
                     m_pSamples[i].TimeStamp,
                     TimeDifference));
        }
    }

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\filter\inpin.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       inpin.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu (taken from WilliamH src)
 *
 *  DATE:        9/7/99
 *
 *  DESCRIPTION: input pin definitions
 *
 *****************************************************************************/

#ifndef __INPIN_H_
#define __INPIN_H_

class CStillFilter;
class CStillOutputPin;

class CStillInputPin : public CBaseInputPin
{

    friend class CStillOutputPin;
    friend class CStillFilter;

public:
    CStillInputPin(TCHAR        *pObjName, 
                   CStillFilter *pStillFilter, 
                   HRESULT      *phr, 
                   LPCWSTR      pPinName);

    HRESULT         CheckMediaType(const CMediaType* pmt);
    HRESULT         SetMediaType(const CMediaType *pmt);
    STDMETHODIMP    Receive(IMediaSample* pSample);
    STDMETHODIMP    BeginFlush();
    STDMETHODIMP    EndFlush();
    STDMETHODIMP    EndOfStream();
    STDMETHODIMP    NewSegment(REFERENCE_TIME tStart,REFERENCE_TIME tStop,double dRate);
    HRESULT         Active();
    HRESULT         Inactive();
    HRESULT         SetSamplingSize(int Size);
    int             GetSamplingSize();
    HRESULT         Snapshot(ULONG TimeStamp);
    HRESULT         InitializeSampleQueue(int Size);
    HRESULT         UnInitializeSampleQueue();

    IMemAllocator* GetAllocator();

private:

    HRESULT CreateBitmap(BYTE       *pBits, 
                         HGLOBAL    *phDib);

    HRESULT DeliverBitmap(HGLOBAL hDib);

    HRESULT FreeBitmap(HGLOBAL hDib);

    HRESULT AddFrameToQueue(BYTE *pBits);

#ifdef DEBUG
    void DumpSampleQueue(ULONG ulRequestedTimestamp);
#endif

    CCritSec        m_QueueLock;

    int             m_SamplingSize;
    DWORD           m_BitsSize;
    int             m_SampleHead;
    int             m_SampleTail;
    STILL_SAMPLE   *m_pSamples;
    BYTE           *m_pBits;

};

inline IMemAllocator* CStillInputPin::GetAllocator()
{
    // The input pin only has an allocator if it is connected.
    ASSERT(IsConnected());

    // m_pAllocator should never be NULL if the input pin is connected.
    ASSERT(m_pAllocator != NULL);

    return m_pAllocator;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\util\rwspy\rwspy.c ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT        0x0500
#endif

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include "detours.h"

//
// Registry information used by RWSpy
//
WCHAR RWSpyKey[] = L"Software\\Microsoft\\RWSpy";

WCHAR DeviceValueName[] = L"FileToSpyOn";
WCHAR DeviceNameToSpyOn[MAX_PATH] = L"";

WCHAR LogFileValueName[] = L"Log File";
WCHAR DefaultLogFileName[] = L"%SystemRoot%\\rwspy.log";
WCHAR LogFileName[MAX_PATH] = L"\0";

//
// Globals
//
HANDLE g_hDeviceToSpyOn = INVALID_HANDLE_VALUE;
HANDLE g_hLogFile = INVALID_HANDLE_VALUE;

//
// Detours trampolines
//
DETOUR_TRAMPOLINE(HANDLE WINAPI Real_CreateFileW(LPCWSTR a0, DWORD a1, DWORD a2,
    LPSECURITY_ATTRIBUTES a3, DWORD a4, DWORD a5, HANDLE a6), CreateFileW);

DETOUR_TRAMPOLINE(BOOL WINAPI Real_WriteFile(HANDLE hFile, LPCVOID lpBuffer,
                                             DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped), WriteFile);

DETOUR_TRAMPOLINE(BOOL WINAPI Real_WriteFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD dwNumberOfBytesToWrite,
                                               LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletion), WriteFileEx);

DETOUR_TRAMPOLINE(BOOL WINAPI Real_ReadFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToRead,
                                            LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped), ReadFile);

DETOUR_TRAMPOLINE(BOOL WINAPI Real_ReadFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD dwNumberOfBytesToRead,
                                               LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletion), ReadFileEx);

DETOUR_TRAMPOLINE(BOOL WINAPI Real_DeviceIoControl(HANDLE hFile, DWORD code, LPVOID inBuffer, DWORD cbIn,
    LPVOID outBuffer, DWORD cbOutSize, LPDWORD cbOutActual, LPOVERLAPPED lpOverlapped), DeviceIoControl);

DETOUR_TRAMPOLINE(BOOL WINAPI Real_CloseHandle(HANDLE hObject), CloseHandle);


// closes log and makes further writing impossible until log reopened
void CloseLog(void)
{
    if(g_hLogFile != INVALID_HANDLE_VALUE) {
        Real_CloseHandle(g_hLogFile);
        g_hLogFile = INVALID_HANDLE_VALUE;
    }
}

// Attempts to open log file. Assumes that LogFileName[] is already set
// elsewhere.
BOOL OpenLog(void)
{
    BOOL success = FALSE;

    CloseLog();

    g_hLogFile = Real_CreateFileW(LogFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                                  CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if(g_hLogFile != INVALID_HANDLE_VALUE) {
        success = TRUE;
    }

    return success;
}

// Writes specified number of characters to the log file
BOOL WriteToLog(CHAR *bytes, DWORD len)
{
    BOOL success = FALSE;
                   
    if(g_hLogFile != INVALID_HANDLE_VALUE && len && bytes) {
        DWORD cbWritten;
        if(Real_WriteFile(g_hLogFile, bytes, len, &cbWritten, NULL) && len == cbWritten) {
            success = TRUE;
        } else {
            CloseLog();
        }
    }
    return success;
}

// writes printf-style string to the log file
void Log(LPCSTR fmt, ...)
{
    va_list marker;
    CHAR buffer[1024];
    DWORD cbToWrite;

    if(g_hLogFile == INVALID_HANDLE_VALUE || fmt == NULL)
        return;

    va_start(marker, fmt);
    _vsnprintf(buffer, sizeof(buffer), fmt, marker);
    cbToWrite = lstrlenA(buffer);
    
    WriteToLog(buffer, cbToWrite);
}

// writes db-style bytes to the log file
void LogBytes(BYTE *pBytes, DWORD dwBytes)
{
    DWORD nBytes = min(dwBytes, 8192L);
    const static CHAR hex[] = "0123456789ABCDEF";
    CHAR buffer[80];
    DWORD cbToWrite = 75;
    DWORD byte = 0;
    int pos;

    if(g_hLogFile == INVALID_HANDLE_VALUE || pBytes == NULL || nBytes == 0)
        return;
    
    while(byte < nBytes) {
        
        if((byte % 16) == 0) {

            if(byte != 0) {
                // write previous line into file
                if(!WriteToLog(buffer, cbToWrite))
                    break;
            }

            memset(buffer, ' ', cbToWrite - 1);
            buffer[cbToWrite - 1] = '\n';
            
            buffer[0] = hex[(byte >> 12) & 0xF];
            buffer[1] = hex[(byte >> 8) & 0xF];
            buffer[2] = hex[(byte >> 4) & 0xF];
            buffer[3] = hex[byte & 0xF];
        }

        pos = (byte % 16 < 8 ? 5 : 6)+ (byte % 16) * 3;
        
        buffer[pos] = hex[(pBytes[byte] >> 4) & 0xF];
        buffer[pos + 1] = hex[pBytes[byte] & 0xF];

        pos = 5 + 16 * 3 + 2 + (byte % 16);
        buffer[pos] = pBytes[byte] >= ' ' && pBytes[byte] <= 127 ? pBytes[byte] : '.';

        byte++;
    }

    // write one final line
    WriteToLog(buffer, cbToWrite);
}


HANDLE WINAPI
   My_CreateFileW(LPCWSTR a0,
                    DWORD a1,
                    DWORD a2,
                    LPSECURITY_ATTRIBUTES a3,
                    DWORD a4,
                    DWORD a5,
                    HANDLE a6)
{
    HANDLE hResult;

    __try {
        hResult = Real_CreateFileW(a0, a1, a2, a3, a4, a5, a6);
    }

    __finally {
        // if we have a file to spy on
        if(DeviceNameToSpyOn[0]) {
            WCHAR *pw = DeviceNameToSpyOn;
            LPCWSTR p = a0;

            while(*p && *pw) {
                WCHAR w = *p;
                if(w != *pw)
                    break;
                p++;
                pw++;
            }

            if(*p == L'\0' && *pw == L'\0') {
                // we got our file
                if(hResult == INVALID_HANDLE_VALUE) {
                    Log("Tried creating '%S', LastError() = : %d\n", a0 ? a0 : L"NULL", GetLastError());
                } else {
                    Log("Created '%S', handle: %x\n", a0 ? a0 : L"NULL", hResult);
                }

                if(hResult != INVALID_HANDLE_VALUE) {
                    // successsfully created
                    if(g_hDeviceToSpyOn != INVALID_HANDLE_VALUE && hResult != g_hDeviceToSpyOn) {
                        // hmm... it was already open. Let user know
                        // this happened:
                        Log("Note: we were already spying on this device with handle %x. Changing to %x\n",
                              g_hDeviceToSpyOn, hResult);
                    }
                    g_hDeviceToSpyOn = hResult;
                }
            }

        } else {
            // simply record the file name into output file
            Log("Creating file: '%S', result: %x\n", a0 ? a0 : L"NULL", hResult); 
        }
    }

    return hResult;
}


BOOL WINAPI
   My_WriteFile(HANDLE hFile,
                  LPCVOID lpBuffer,
                  DWORD nNumberOfBytesToWrite,
                  LPDWORD lpNumberOfBytesWritten,
                  LPOVERLAPPED lpOverlapped)
{
    BOOL bresult;
    DWORD bytesWritten;

    __try {
        bresult = Real_WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
    }

    __finally {
        if(g_hDeviceToSpyOn != INVALID_HANDLE_VALUE && hFile == g_hDeviceToSpyOn) {
            bytesWritten = lpNumberOfBytesWritten ? *lpNumberOfBytesWritten :
                           nNumberOfBytesToWrite;
            if(bresult) {
                Log("Wrote %d bytes:\n", bytesWritten);
            } else {
                Log("Failure writing %d bytes, LastError() = %d:\n",
                      nNumberOfBytesToWrite, GetLastError());
            }
            LogBytes((BYTE *)lpBuffer, bytesWritten);
        }
    }

    return bresult;
}


BOOL WINAPI
   My_WriteFileEx(HANDLE hFile,
                  LPCVOID lpBuffer,
                  DWORD nNumberOfBytesToWrite,
                  LPOVERLAPPED lpOverlapped,
                  LPOVERLAPPED_COMPLETION_ROUTINE lpOverlappedCompletion)
{
    BOOL bresult;

    __try {
        bresult = Real_WriteFileEx(hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped, lpOverlappedCompletion);
    }

    __finally {
        if(g_hDeviceToSpyOn != INVALID_HANDLE_VALUE && hFile == g_hDeviceToSpyOn) {
            if(bresult) {
                Log("Submitted %d bytes to WriteEx:\n", nNumberOfBytesToWrite);
            } else {
                Log("Failed to submit %d bytes to WriteEx, LastError() = %d:\n",
                      nNumberOfBytesToWrite, GetLastError());
            }
            LogBytes((BYTE *)lpBuffer, nNumberOfBytesToWrite);
        }
    }

    return bresult;
}



BOOL WINAPI
   My_ReadFile(HANDLE hFile,
                 LPCVOID lpBuffer,
                 DWORD nNumberOfBytesToRead,
                 LPDWORD lpNumberOfBytesRead,
                 LPOVERLAPPED lpOverlapped)
{
    BOOL bresult;
    DWORD bytesRead;

    __try {
        bresult = Real_ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
    }

    __finally {
        if(g_hDeviceToSpyOn != INVALID_HANDLE_VALUE && hFile == g_hDeviceToSpyOn) {
            bytesRead = lpNumberOfBytesRead ? *lpNumberOfBytesRead :
                        nNumberOfBytesToRead;
            if(bresult) {
                Log("Read %d bytes:\n", bytesRead);
                LogBytes((BYTE *)lpBuffer, bytesRead);
            } else {
                Log("Failure to read %d bytes, LastError() = %d:\n",
                      nNumberOfBytesToRead, GetLastError());
            }
        }
    }

    return bresult;
}

//
// Please, note that to see ReadEx bytes one needs to detour 
// the completion routine (we don't do it here).
//
BOOL WINAPI
   My_ReadFileEx(HANDLE hFile,
                   LPCVOID lpBuffer,
                   DWORD nNumberOfBytesToRead,
                   LPOVERLAPPED lpOverlapped,
                   LPOVERLAPPED_COMPLETION_ROUTINE lpOverlappedCompletion)
{
    BOOL bresult;

    __try {
        bresult = Real_ReadFileEx(hFile, lpBuffer, nNumberOfBytesToRead, lpOverlapped, lpOverlappedCompletion);
    }

    __finally {
        if(g_hDeviceToSpyOn != INVALID_HANDLE_VALUE && hFile == g_hDeviceToSpyOn) {
            if(bresult) {
                Log("Submitted ReadEx for %d bytes:\n", nNumberOfBytesToRead);
            } else {
                Log("Failed to sumbit ReadEx for %d bytes, LastError() = %d:\n",
                      nNumberOfBytesToRead, GetLastError());
            }
        }
    }

    return bresult;
}



BOOL WINAPI
   My_DeviceIoControl(HANDLE hFile, DWORD code, LPVOID inBuffer, DWORD cbIn,
                        LPVOID outBuffer, DWORD cbOutSize, LPDWORD pcbOutActual, LPOVERLAPPED lpOverlapped)
{
    BOOL result;
    DWORD outBytes;
    DWORD Function; 
    __try {
        result = Real_DeviceIoControl(hFile, code, inBuffer, cbIn, outBuffer, cbOutSize, pcbOutActual, lpOverlapped);
    }
    __finally {
        if(g_hDeviceToSpyOn != INVALID_HANDLE_VALUE && hFile == g_hDeviceToSpyOn) {
            outBytes = pcbOutActual ? *pcbOutActual : cbOutSize;

            Function = (code >> 2) & 0xFFF;
            
            Log("DeviceIoControl code = %x, Function = %x, %d bytes in:\n",
                  code, Function, cbIn);
            LogBytes((BYTE *)inBuffer, cbIn);
            if(outBytes) {
                Log("   %d bytes out:\n", outBytes);
                LogBytes((BYTE *)outBuffer, outBytes);
            }
        }
    }
    
    return result;
}


BOOL WINAPI
   My_CloseHandle(HANDLE hObject)
{
    BOOL bresult;

    __try {
        bresult = Real_CloseHandle(hObject);
    }

    __finally {
        if(g_hDeviceToSpyOn != INVALID_HANDLE_VALUE && hObject == g_hDeviceToSpyOn) {
            Log("Closed handle %x\n", hObject);
            g_hDeviceToSpyOn = INVALID_HANDLE_VALUE;
        }
    }

    return bresult;
}


void PrepareLogger()
{
    HKEY hKey;
    WCHAR buffer[MAX_PATH];

    // retrieve our configuration from the registry
    if(ERROR_SUCCESS == RegCreateKeyExW(HKEY_LOCAL_MACHINE, RWSpyKey,
                                        0, NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, NULL))
    {
        DWORD dwType, cbData = sizeof(buffer);

        cbData = sizeof(buffer);
        if(ERROR_SUCCESS == RegQueryValueExW(hKey, LogFileValueName, 0, &dwType, (BYTE *) buffer, &cbData) &&
           cbData)
        {
            ExpandEnvironmentStringsW(buffer, LogFileName, MAX_PATH);
        } else {
            // no log file name value found, create it so that users 
            // would know what its name is
            cbData = lstrlenW(DefaultLogFileName) * sizeof(DefaultLogFileName[0]);
            RegSetValueExW(hKey, LogFileValueName, 0, REG_EXPAND_SZ, (BYTE *) DefaultLogFileName, cbData);
        }

        DeviceNameToSpyOn[0] = L'\0';
        cbData = sizeof(DeviceNameToSpyOn);
        if(ERROR_SUCCESS != RegQueryValueExW(hKey, DeviceValueName, NULL, &dwType, (LPBYTE) DeviceNameToSpyOn, &cbData)
           || !DeviceNameToSpyOn[0])
        {
            // no "FileToSpyOn" value found, create it so that users
            // would know what the value name is
            RegSetValueExW(hKey, DeviceValueName, 0, REG_SZ, (BYTE *)DeviceNameToSpyOn, sizeof(WCHAR));
        }
        RegCloseKey(hKey);
    }

    // if we still don't have file name, use the default one
    if(!LogFileName[0]) {
        ExpandEnvironmentStringsW(DefaultLogFileName, LogFileName, MAX_PATH);
    }

    OpenLog();
                                     
    DetourFunctionWithTrampoline((PBYTE) Real_CreateFileW, (PBYTE) My_CreateFileW);
    DetourFunctionWithTrampoline((PBYTE) Real_WriteFile, (PBYTE) My_WriteFile);
    DetourFunctionWithTrampoline((PBYTE) Real_WriteFileEx, (PBYTE) My_WriteFileEx);
    DetourFunctionWithTrampoline((PBYTE) Real_ReadFile, (PBYTE) My_ReadFile);
    DetourFunctionWithTrampoline((PBYTE) Real_ReadFileEx, (PBYTE) My_ReadFileEx);
    DetourFunctionWithTrampoline((PBYTE) Real_DeviceIoControl, (PBYTE) My_DeviceIoControl);
    DetourFunctionWithTrampoline((PBYTE) Real_CloseHandle, (PBYTE) My_CloseHandle);
}



BOOL APIENTRY DllMain(HINSTANCE hModule, DWORD dwReason, PVOID lpReserved)
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            PrepareLogger();
            break;
        case DLL_PROCESS_DETACH:
            CloseLog();
            break;
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            break;
    }
    return TRUE;
}


// This is necessary for detours static injection code (see detours
// code if you need to understand why)  
void NullExport()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\filter\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2000
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        9/7/99
 *
 *  DESCRIPTION: Precomplied header for filter
 *
 *****************************************************************************/

#ifndef _WIA_VIDEO_FILTER_PRECOMP_
#define _WIA_VIDEO_FILTER_PRECOMP_

#include <streams.h>

#include <tchar.h>
#include <initguid.h>
#include <atlbase.h>
#include <psnew.h>
#include <istillf.h>
#include <stillf.h>         // stillf.h must come before inpin.h & outpin.h
#include <inpin.h>
#include <outpin.h>
#include <limits.h>
#include <objbase.h>
#include <vfwmsgs.h>
#include <coredbg.h>

extern HINSTANCE g_hInstance;
#ifdef DEBUG
void DisplayMediaType(const CMediaType *pmt);
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\filter\istillf.h ===
/*++
Copyright (c) 1998- Microsoft Corporation

Module Name:

    istillf.h

Abstract:
    Header file that declares IID_IStillSnapshot interface which is implemented
    in stillf.cpp

Author:

    William Hsieh (williamh) created

Revision History:

--*/
#ifndef __ISTILLF_H_
#define __ISTILLF_H_

DEFINE_GUID(CLSID_STILL_FILTER,
0xbc7acb90, 0x622b, 0x11d2, 0x82, 0x9d, 0x00, 0xc0, 0x4f, 0x8e, 0xc1, 0x83);

DEFINE_GUID(IID_IStillSnapshot,
0x19da0cc0, 0x6ea7, 0x11d2, 0x82, 0xb8, 0x00, 0xc0, 0x4f, 0x8e, 0xc1, 0x83);



//
// This is the callback function for ReadBits method
// Count contain how many DIB bits are returned
// while lParam is the context parameter passed
// in ReadBits call.
//


typedef BOOL (*LPSNAPSHOTCALLBACK)(HGLOBAL hDIB, LPARAM lParam);


extern "C"
{
    #undef  INTERFACE
    #define INTERFACE   IStillSnapshot


    DECLARE_INTERFACE_(IStillSnapshot, IUnknown)
    {
        STDMETHOD(Snapshot)(ULONG TimeStamp) PURE;
        STDMETHOD(SetSamplingSize)(int Size) PURE;
        STDMETHOD_(int, GetSamplingSize)() PURE;
        STDMETHOD_(DWORD, GetBitsSize)() PURE;
        STDMETHOD_(DWORD, GetBitmapInfoSize)() PURE;
        STDMETHOD(GetBitmapInfo)(BYTE* Buffer, DWORD BufferSize) PURE;
        STDMETHOD(RegisterSnapshotCallback)(LPSNAPSHOTCALLBACK pCallback, LPARAM lParam) PURE;
        STDMETHOD(GetBitmapInfoHeader)(BITMAPINFOHEADER *pbmih) PURE;
    };
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\filter\sources.inc ===
!include          $(PROJECT_ROOT)\wia\wiaenv.inc

MAJORCOMP=DirectShow
MINORCOMP=StillFilter

TARGETNAME=wiasf
TARGETPATH=$(OBJ_DIR)

TARGETTYPE=DYNLINK
TARGETEXT=ax
DLLDEF=..\wiasf.def
DLLENTRY        = _DllMainCRTStartup
#DLLENTRY=DllMain

USE_MSVCRT=1

#Common include files

INCLUDES= $(INCLUDES) \
    $(PROJECT_ROOT)\inc\psutil; \
    $(PROJECT_ROOT)\inc; \
    $(BASEDIR)\public\sdk\amovie\inc; \
    $(SDK_INC_PATH)\atl30;

!if ("$(NTDEBUG)" == "") || ("$(NTDEBUG)" == "ntsdnodbg")
LINKLIBS=$(SDK_LIB_PATH)\strmbase.lib
!ELSE
LINKLIBS=$(SDK_LIB_PATH)\strmbasd.lib
!ENDIF

TARGETLIBS= \
            $(SDK_LIB_PATH)\ADVAPI32.lib \
            $(SDK_LIB_PATH)\GDI32.lib    \
            $(SDK_LIB_PATH)\KERNEL32.lib \
            $(SDK_LIB_PATH)\user32.lib   \
            $(SDK_LIB_PATH)\oleaut32.lib \
            $(SDK_LIB_PATH)\ole32.lib    \
            $(SDK_LIB_PATH)\uuid.lib     \
            $(SDK_LIB_PATH)\winmm.lib    \
            $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\$(O)\psutil.lib \
            $(WIA_LIB_PATH)\stirt.lib


SOURCES= \
    ..\inpin.cpp \
    ..\outpin.cpp \
    ..\stillf.cpp \
    ..\stillf.rc


PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\filter\outpin.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998-2000
 *
 *  TITLE:       outpin.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu (taken from WilliamH src)
 *
 *  DATE:        9/7/99
 *
 *  DESCRIPTION: Output pin definitions
 *
 *****************************************************************************/

#ifndef __OUTPIN_H_
#define __OUTPIN_H_

class CStillFilter;
class CStillInputPin;

class CStillOutputPin : public CBaseOutputPin
{
    friend CStillInputPin;
    friend CStillFilter;

public:
    CStillOutputPin(TCHAR           *pObjName, 
                    CStillFilter    *pStillFilter, 
                    HRESULT         *phr, 
                    LPCWSTR         pPinName);

    virtual ~CStillOutputPin();

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP Notify(IBaseFilter* pSender, Quality q);
    HRESULT CheckMediaType(const CMediaType* pmt);
    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);
    HRESULT DecideBufferSize(IMemAllocator* pAllocator,ALLOCATOR_PROPERTIES* pProperty);
    HRESULT SetMediaType(const CMediaType* pmt);
    HRESULT GetMediaType(int iPosition, CMediaType* pmt);

private:
    CStillInputPin* GetInputPin();

    IUnknown*       m_pMediaUnk;
};

inline CStillInputPin* CStillOutputPin::GetInputPin()
{
    // m_pFilter should never be NULL because a valid filter pointer is
    // always passed to CStillOutputPin's constructor.
    ASSERT(m_pFilter != NULL);

    // m_pInputPin should never be NULL because CoCreateInstance() will not
    // create a CStillFilter object if an error occurs in CStillFilter's 
    // constructor.
    ASSERT(((CStillFilter*) m_pFilter)->m_pInputPin != NULL);

    if (((CStillFilter*) m_pFilter)->m_pInputPin)
    {
        return ((CStillFilter*) m_pFilter)->m_pInputPin;
    }
    else
    {
        return NULL;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\filter\outpin.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998-2000
 *
 *  TITLE:       stillf.cpp
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      WilliamH (created)
 *               RickTu
 *
 *  DATE:        9/7/98
 *
 *  DESCRIPTION: This module implements video stream capture filter.
 *               It implements CStillInputPin, CStillOutputPin and CStillFilter objects.
 *               implements IID_IStillGraph interface provided for the caller
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop

/*****************************************************************************

   CStillOutputPin constructor

   <Notes>

 *****************************************************************************/

CStillOutputPin::CStillOutputPin(TCHAR          *pObjName,
                                 CStillFilter   *pStillFilter,
                                 HRESULT        *phr,
                                 LPCWSTR        pPinName)
  : m_pMediaUnk(NULL),
    CBaseOutputPin(pObjName, 
                   (CBaseFilter *)pStillFilter, 
                   &pStillFilter->m_Lock, 
                   phr, 
                   pPinName)
{
    DBG_FN("CStillOutputPin::CStillOutputPin");

    CHECK_S_OK2(*phr,("CBaseOutputPin constructor"));
}

/*****************************************************************************

   CStillOutputPin Destructor

   <Notes>

 *****************************************************************************/

CStillOutputPin::~CStillOutputPin()
{
    if (m_pMediaUnk)
    {
        m_pMediaUnk->Release();
        m_pMediaUnk = NULL;
    }
}

/*****************************************************************************

   CStillOutputPin::NonDelegatingQueryInterface

   Add our stuff to the base class QI.

 *****************************************************************************/

STDMETHODIMP
CStillOutputPin::NonDelegatingQueryInterface(REFIID riid, 
                                             PVOID  *ppv )
{
    DBG_FN("CStillOutputPin::NonDelegatingQueryInterface");

    ASSERT(this!=NULL);
    ASSERT(ppv!=NULL);
    ASSERT(m_pFilter!=NULL);

    HRESULT hr = E_POINTER;

    if (!ppv)
    {
        hr = E_INVALIDARG;
    }
    else if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking)
    {
        if (!m_pMediaUnk && m_pFilter)
        {
            ASSERT(m_pFilter!=NULL);
            hr = CreatePosPassThru(
                                GetOwner(),
                                FALSE,
                                (IPin*)((CStillFilter*)m_pFilter)->m_pInputPin,
                                &m_pMediaUnk);
        }

        if (m_pMediaUnk)
        {
            hr = m_pMediaUnk->QueryInterface(riid, ppv);
        }
        else
        {
            hr = E_NOINTERFACE;
            *ppv = NULL;
        }
    }
    else
    {
        hr = CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }

    return hr;
}

/*****************************************************************************

   CStillOutputPin::DecideAllocator

   <Notes>

 *****************************************************************************/

HRESULT
CStillOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    HRESULT         hr                  = S_OK;
    CStillInputPin  *pInputPin          = NULL;
    IMemAllocator   *pInputPinAllocator = NULL;

    // The caller should passes in valid arguments.
    ASSERT((pPin != NULL) && (ppAlloc != NULL));

    if ((pPin == NULL) || (ppAlloc == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CStillOutputPin::DecideAllocator received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        *ppAlloc = NULL;
    
        pInputPin = GetInputPin();
    
        if (pInputPin == NULL)
        {
            hr = E_POINTER;
            CHECK_S_OK2(hr, ("CStillOutputPin::DecideAllocator, pInputPin is NULL, "
                             "this should never happen"));
        }
    }

    if (hr == S_OK)
    {
        if (!pInputPin->IsConnected()) 
        {
            hr = VFW_E_NOT_CONNECTED;
            CHECK_S_OK2(hr, ("CStillOutputPin::DecideAllocator input pin is not connected"));
        }
    }

    if (hr == S_OK)
    {
        pInputPinAllocator = pInputPin->GetAllocator();

        hr = pPin->NotifyAllocator(pInputPinAllocator, pInputPin->IsReadOnly());
    
        if (FAILED(hr)) 
        {
            CHECK_S_OK2(hr, ("CStillOutputPin::DecideAllocator failed to notify downstream "
                             "pin of new allocator"));
        }

        if (pInputPinAllocator == NULL)
        {
            hr = E_POINTER;
            CHECK_S_OK2(hr, ("CStillOutputPin::DecideAllocator, pInputPinAllocator is NULL, "
                             "this should never happen"));
        }
    }


    if (hr == S_OK)
    {
        pInputPinAllocator->AddRef();
        *ppAlloc = pInputPinAllocator;
    }

    return hr;
}

/*****************************************************************************

   CStillOutputPin::DecideBufferSize

   <Notes>

 *****************************************************************************/

HRESULT
CStillOutputPin::DecideBufferSize(IMemAllocator        *pMemAllocator,
                                  ALLOCATOR_PROPERTIES *pAllocProperty)
{
    // This function is never called because we overrode 
    // CBaseOutputPin::DecideAllocator().  We have to define 
    // it because it is a virtual function in CBaseOutputPin.
    return E_UNEXPECTED;
}


/*****************************************************************************

   CStillOutputPin::CheckMediaType

   <Notes>

 *****************************************************************************/

HRESULT
CStillOutputPin::CheckMediaType(const CMediaType* pmt)
{
    DBG_FN("CStillOutputPin::CheckMediaType");

    ASSERT(this         !=NULL);
    ASSERT(m_pFilter    !=NULL);
    ASSERT(pmt          !=NULL);

    HRESULT hr = E_POINTER;

    //
    // the input pin must be connected first because we only accept
    // media type determined by our input pin.
    //

    if (m_pFilter && ((CStillFilter*)m_pFilter)->m_pInputPin)
    {
        if (((CStillFilter*)m_pFilter)->m_pInputPin->m_Connected != NULL)
        {
            //
            // if our input pin is connected, we only accept the
            // the media type agreed on the input pin.
            //

            if (pmt && (((CStillFilter*)m_pFilter)->m_pInputPin->m_mt == *pmt))
            {
                hr = S_OK;
            }
            else
            {
                hr = VFW_E_TYPE_NOT_ACCEPTED;
            }
        }
        else
        {
            DBG_ERR(("m_pFilter->m_pInputPin->m_Connected is NULL!"));
        }
    }
    else
    {
#ifdef DEBUG
        if (!m_pFilter)
        {
            DBG_ERR(("m_pFilter is NULL!"));
        }
        else if (!((CStillFilter*)m_pFilter)->m_pInputPin)
        {
            DBG_ERR(("m_pFilter->m_pInputPin is NULL!"));
        }
#endif
    }

    return hr;
}


/*****************************************************************************

   CStillOutputPin::GetMediaType

   <Notes>

 *****************************************************************************/

HRESULT
CStillOutputPin::GetMediaType(int        iPosition, 
                              CMediaType *pmt)
{
    DBG_FN("CStillOutputPin::GetMediaType");

    ASSERT(this     !=NULL);
    ASSERT(m_pFilter!=NULL);
    ASSERT(pmt      !=NULL);

    HRESULT hr = E_POINTER;

    if (!pmt)
    {
        hr = E_INVALIDARG;

        DBG_ERR(("CStillOutputPin::GetMediaType CMediaType 'pmt' param "
                 "is NULL! returning hr = 0x%08lx", hr));
    }
    else if (m_pFilter && ((CStillFilter*)m_pFilter)->m_pInputPin)
    {
        //
        // if the input is not connected, we do not have preferred
        // media type
        //

        if (!((CStillFilter*)m_pFilter)->m_pInputPin->IsConnected())
        {
            hr = E_UNEXPECTED;

            DBG_ERR(("CStillOutputPin::GetMediaType was called but "
                     "the input pin is not connected, Returning hr = "
                     "0x%08lx", hr));
        }
        else if (iPosition < 0)
        {
            hr = E_INVALIDARG;
            DBG_ERR(("CStillOutputPin::GetMediaType requesting a media type "
                     "in position %d, which is invalid, returning hr = "
                     "0x%08lx", iPosition, hr));
        }
        else if (iPosition > 0 )
        {
            //
            // this is not an error case since the caller is enumerating all the
            // media types we support.  We return that we don't have any more
            // items that we support.
            //
            hr = VFW_S_NO_MORE_ITEMS;
        }
        else
        {
            // 
            // Position being requested is position 0, since less than or
            // greater than 0 are unsupported.  
            // In effect, our output pin supports any media our input pin 
            // supports, we don't do any conversions.
            //
            *pmt = ((CStillFilter*)m_pFilter)->m_pInputPin->m_mt;
            hr = S_OK;
        }
    }
    else
    {
#ifdef DEBUG
        if (!m_pFilter)
        {
            DBG_ERR(("CStillOutputPin::GetMediaType, m_pFilter is NULL, "
                     "this should never happen!"));
        }
        else if (!((CStillFilter*)m_pFilter)->m_pInputPin)
        {
            DBG_ERR(("CStillOutputPin::GetMediaType "
                     "m_pFilter->m_pInputPin "
                     "is NULL.  The input pin should always "
                     "exist if the filter exists!"));
        }
#endif
    }

    return hr;
}


/*****************************************************************************

   CStillOutputPin::SetMediaType

   <Notes>

 *****************************************************************************/

HRESULT
CStillOutputPin::SetMediaType(const CMediaType* pmt)
{
    DBG_FN("CStillOutputPin::SetMediaType");

    ASSERT(this !=NULL);
    ASSERT(pmt);

    HRESULT hr = S_OK;

#ifdef DEBUG
    // Display the type of the media for debugging perposes
//    DBG_TRC(("CStillOutputPin::SetMediaType, setting the following media "
//             "type for Still Filter"));
//    DisplayMediaType( pmt );
#endif

    hr = CBaseOutputPin::SetMediaType(pmt);
    CHECK_S_OK2(hr,("CBaseOutputPin::SetMediaType(pmt)"));

    return hr;
}


/*****************************************************************************

   CStillOutputPin::Notify

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CStillOutputPin::Notify(IBaseFilter *pSender, 
                        Quality     q)
{
    ASSERT(this     !=NULL);
    ASSERT(m_pFilter!=NULL);

    HRESULT hr = E_POINTER;

    if (m_pFilter && ((CStillFilter*)m_pFilter)->m_pInputPin)
    {
        hr = ((CStillFilter*)m_pFilter)->m_pInputPin->PassNotify(q);
    }
    else
    {
#ifdef DEBUG
        if (!m_pFilter)
        {
            DBG_ERR(("m_pFilter is NULL"));
        }
        else if (!((CStillFilter*)m_pFilter)->m_pInputPin)
        {
            DBG_ERR(("m_pFilter->m_pInputPin is NULL"));
        }
#endif

    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\filter\stillf.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998-2000
 *
 *  TITLE:       stillf.cpp
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      WilliamH (created)
 *               RickTu
 *
 *  DATE:        9/7/98
 *
 *  DESCRIPTION: This module implements video stream capture filter.
 *               It implements CStillFilter objects.
 *               implements IID_IStillGraph interface provided for the caller
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop

HINSTANCE g_hInstance;

extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE hInstance, ULONG ulReason, LPVOID pv);

/*****************************************************************************

   DllMain

   <Notes>

 *****************************************************************************/

BOOL
DllMain(HINSTANCE   hInstance,
        DWORD       dwReason,
        LPVOID      lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            //
            // Init Debug subsystem
            //
            DBG_INIT(hInstance);
    
            //
            // Requires '{' and '}' since DBG_FN is an object with a
            // constructor and a destructor.
            //

            DBG_FN("DllMain - ProcessAttach");
    
            //
            // We do not need thread attach/detach calls
            //
    
            DisableThreadLibraryCalls(hInstance);
    
            //
            // Record what instance we are
            //
    
            g_hInstance = hInstance;
        }
        break;
    
        case DLL_PROCESS_DETACH:
        {
    
            //
            // Requires '{' and '}' since DBG_FN is an object with a
            // constructor and a destructor.
            //

            DBG_FN("DllMain - ProcessDetach");
        }
        break;
    }

    return DllEntryPoint(hInstance, dwReason, lpReserved);

}


///////////////////////////////
// sudPinTypes
//
// template definitions for CClassFactorySample
//
const AMOVIESETUP_MEDIATYPE sudPinTypes =
{
    &MEDIATYPE_Video,       // major media type GUID
    &MEDIASUBTYPE_NULL      // subtype GUID
};


///////////////////////////////
// psudPins
//
const AMOVIESETUP_PIN   psudPins[] =
{
    {
                    // CStillInputPin
    L"Input",           // pin name
    FALSE,              // not rendered
    FALSE,              // not output pin
    FALSE,              // not allow none
    FALSE,              // not allow many
    &CLSID_NULL,            // connect to any filter
    L"Output",          // connect to output pin
    1,              // one media type
    &sudPinTypes            // the media type
    },
    {
                    // CStillInputPin
    L"Output",          // pin name
    FALSE,              // not rendered
    TRUE,               // not output pin
    FALSE,              // not allow none
    FALSE,              // not allow many
    &CLSID_NULL,            // connect to any filter
    L"Input",           // connect to input pin
    1,              // one media type
    &sudPinTypes            // the media type
    }
};

///////////////////////////////
// sudStillFilter
//
const AMOVIESETUP_FILTER sudStillFilter =
{
    &CLSID_STILL_FILTER,        // filter clsid
    L"WIA Stream Snapshot Filter",      // filter name
    MERIT_DO_NOT_USE,           //
    2,                  // two pins
    psudPins,               // our pins
};

///////////////////////////////
// g_Templates
//
CFactoryTemplate g_Templates[1] =
{
    {
    L"WIA Stream Snapshot Filter",  // filter name
    &CLSID_STILL_FILTER,        // filter clsid
    CStillFilter::CreateInstance,   // API used to create filter instances
    NULL,               // no init function provided.
    &sudStillFilter         // the filter itself
    },
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);



/*****************************************************************************

   DllRegisterServer

   Used to register the classes provided in this dll.

 *****************************************************************************/

STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2(TRUE);
}


/*****************************************************************************

   DllUnregisterServer

   Used to unregister classes provided by this dll.

 *****************************************************************************/

STDAPI
DllUnregisterServer()
{
    return AMovieDllRegisterServer2(FALSE);
}


/*****************************************************************************

   CStillFilter::CreateInstance

   CreateInstance API to create CStillFilter instances

 *****************************************************************************/

CUnknown* WINAPI CStillFilter::CreateInstance(LPUNKNOWN pUnk, 
                                              HRESULT   *phr )
{
    return new CStillFilter(TEXT("Stream Snapshot Filter"), pUnk, phr );
}

#ifdef DEBUG


/*****************************************************************************

   DisplayMediaType

   <Notes>

 *****************************************************************************/

void DisplayMediaType(const CMediaType *pmt)
{

    //
    // Dump the GUID types and a short description
    //

    DBG_TRC(("<--- CMediaType 0x%x --->",pmt));

    DBG_PRT(("Major type  == %S",
             GuidNames[*pmt->Type()]));

    DBG_PRT(("Subtype     == %S (%S)",
             GuidNames[*pmt->Subtype()],GetSubtypeName(pmt->Subtype())));

    DBG_PRT(("Format size == %d",pmt->cbFormat));
    DBG_PRT(("Sample size == %d",pmt->GetSampleSize()));

    //
    // Dump the generic media types
    //

    if (pmt->IsFixedSize())
    {
        DBG_PRT(("==> This media type IS a fixed size sample"));
    }
    else
    {
        DBG_PRT(("==> This media type IS NOT a fixed size sample >"));
    }

    if (pmt->IsTemporalCompressed())
    {
        DBG_PRT(("==> This media type IS temporally compressed"));
    }
    else
    {
        DBG_PRT(("==> This media type IS NOT temporally compressed"));
    }

}
#endif


/*****************************************************************************

   DefaultGetBitsCallback

   <Notes>

 *****************************************************************************/

void DefaultGetBitsCallback(int     Count, 
                            LPARAM  lParam)
{
    SetEvent((HANDLE)lParam);
}


/*****************************************************************************

   CStillFilter constructor

   <Notes>

 *****************************************************************************/

CStillFilter::CStillFilter(TCHAR        *pObjName, 
                           LPUNKNOWN    pUnk, 
                           HRESULT      *phr) :
    m_pInputPin(NULL),
    m_pOutputPin(NULL),
    m_pbmi(NULL),
    m_pBits(NULL),
    m_BitsSize(0),
    m_bmiSize(0),
    m_pCallback(NULL),
    CBaseFilter(pObjName, pUnk, &m_Lock, CLSID_STILL_FILTER)
{
    DBG_FN("CStillFilter::CStillFilter");

    // create our input and output pin
    m_pInputPin  = new CStillInputPin(TEXT("WIA Still Input Pin"),  
                                      this, 
                                      phr, 
                                      L"Input");

    if (!m_pInputPin)
    {
        DBG_ERR(("Unable to create new CStillInputPin!"));
        *phr = E_OUTOFMEMORY;
        return;
    }

    m_pOutputPin = new CStillOutputPin(TEXT("WIA Still Output Pin"), 
                                       this, 
                                       phr, 
                                       L"Output");

    if (!m_pOutputPin)
    {
        DBG_ERR(("Unable to create new CStillOutputPin!"));
        *phr = E_OUTOFMEMORY;
        return;
    }
}

/*****************************************************************************

   CStillFilter desctructor

   <Notes>

 *****************************************************************************/

CStillFilter::~CStillFilter()
{
    DBG_FN("CStillFilter::~CStillFilter");

    if (m_pInputPin)
    {
        delete m_pInputPin;
        m_pInputPin = NULL;
    }

    if (m_pOutputPin)
    {
        if (m_pOutputPin->m_pMediaUnk)
        {
            m_pOutputPin->m_pMediaUnk->Release();
            m_pOutputPin->m_pMediaUnk = NULL;
        }

        delete m_pOutputPin;
        m_pOutputPin = NULL;
    }


    if (m_pbmi)
    {
        delete [] m_pbmi;
        m_pbmi = NULL;
    }

    if (m_pBits)
    {
        delete [] m_pBits;
        m_pBits = NULL;
    }
}


/*****************************************************************************

   CStillFilter::NonDelegatingQueryInterface

   Add our logic to the base class QI.

 *****************************************************************************/

STDMETHODIMP
CStillFilter::NonDelegatingQueryInterface(REFIID riid, 
                                          void **ppv)
{
    DBG_FN("CStillFilter::NonDelegatingQueryInterface");
    ASSERT(this!=NULL);
    ASSERT(ppv!=NULL);

    HRESULT hr;

    if (!ppv)
    {
        hr = E_INVALIDARG;
    }
    else if (riid == IID_IStillSnapshot)
    {
        hr = GetInterface((IStillSnapshot *)this, ppv);
    }
    else
    {
        hr = CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }

    return hr;
}


/*****************************************************************************

   CStillFilter::GetPinCount

   <Notes>

 *****************************************************************************/

int
CStillFilter::GetPinCount()
{
    return 2;  // input & output
}


/*****************************************************************************

   CStillFilter::GetPin

   <Notes>

 *****************************************************************************/

CBasePin*
CStillFilter::GetPin( int n )
{
    ASSERT(this!=NULL);

    if (0 == n)
    {
        ASSERT(m_pInputPin!=NULL);
        return (CBasePin *)m_pInputPin;
    }
    else if (1 == n)
    {
        ASSERT(m_pOutputPin!=NULL);
        return (CBasePin *)m_pOutputPin;
    }

    return NULL;
}


/*****************************************************************************

   CStillFilter::Snapshot

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CStillFilter::Snapshot( ULONG TimeStamp )
{
    DBG_FN("CStillFilter::Snapshot");
    ASSERT(this!=NULL);
    ASSERT(m_pInputPin!=NULL);

    HRESULT hr = E_POINTER;

    if (m_pInputPin)
    {
        hr = m_pInputPin->Snapshot(TimeStamp);
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CStillFilter::GetBitsSize

   <Notes>

 *****************************************************************************/

STDMETHODIMP_(DWORD)
CStillFilter::GetBitsSize()
{
    DBG_FN("CStillFilter::GetBitsSize");
    ASSERT(this!=NULL);

    return m_BitsSize;
}


/*****************************************************************************

   CStillFilter::GetBitmapInfoSize

   <Notes>

 *****************************************************************************/

STDMETHODIMP_(DWORD)
CStillFilter::GetBitmapInfoSize()
{
    DBG_FN("CStillFilter::GetBitmapInfoSize");
    ASSERT(this!=NULL);

    return m_bmiSize;
}


/*****************************************************************************

   CStillFilter::GetBitmapInfo

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CStillFilter::GetBitmapInfo( BYTE* Buffer, DWORD BufferSize )
{
    DBG_FN("CStillFilter::GetBitmapInfo");

    ASSERT(this     !=NULL);
    ASSERT(m_pbmi   !=NULL);

    if (BufferSize && !Buffer)
        return E_INVALIDARG;

    if (BufferSize < m_bmiSize)
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

    if (!m_pbmi)
        return E_UNEXPECTED;

    memcpy(Buffer, m_pbmi, m_bmiSize);

    return NOERROR;
}


/*****************************************************************************

   CStillFilter::GetBitmapInfoHeader

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CStillFilter::GetBitmapInfoHeader( BITMAPINFOHEADER *pbmih )
{
    DBG_FN("CStillFilter::GetBitmapInfoHeader");

    ASSERT(this     !=NULL);
    ASSERT(m_pbmi   !=NULL);
    ASSERT(pbmih    !=NULL);

    HRESULT hr;

    if (!pbmih)
    {
        hr = E_INVALIDARG;
    }
    else if (!m_pbmi)
    {
        hr = E_POINTER;
    }
    else
    {
        *pbmih = *(BITMAPINFOHEADER*)m_pbmi;
        hr = S_OK;
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CStillFilter::SetSamplingSize

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CStillFilter::SetSamplingSize( int Size )
{
    DBG_FN("CStillFilter::SetSamplingSize");

    ASSERT(this         !=NULL);
    ASSERT(m_pInputPin  !=NULL);

    HRESULT hr = E_POINTER;

    if (m_pInputPin)
    {
        hr = m_pInputPin->SetSamplingSize(Size);
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CStillFilter::GetSamplingSize

   <Notes>

 *****************************************************************************/

STDMETHODIMP_(int)
CStillFilter::GetSamplingSize()
{
    DBG_FN("CStillFilter::GetSamplingSize");

    ASSERT(this         !=NULL);
    ASSERT(m_pInputPin  !=NULL);

    HRESULT hr = E_POINTER;

    if (m_pInputPin)
    {
        hr = m_pInputPin->GetSamplingSize();
    }

    CHECK_S_OK(hr);
    return hr;
}



/*****************************************************************************

   CStillFilter::RegisterSnapshotCallback

   This function registers a notification callback for newly
   arrived frames.  Without registering a callback, all captured
   frames are discarded.

 *****************************************************************************/

STDMETHODIMP
CStillFilter::RegisterSnapshotCallback( LPSNAPSHOTCALLBACK pCallback,
                                        LPARAM lParam
                                       )
{
    DBG_FN("CStillFilter::RegisterSnapshotCallback");

    ASSERT(this != NULL);

    HRESULT hr = S_OK;

    m_Lock.Lock();

    if (pCallback && !m_pCallback)
    {
        m_pCallback     = pCallback;
        m_CallbackParam = lParam;
    }
    else if (!pCallback)
    {
        m_pCallback     = NULL;
        m_CallbackParam = 0;
    }
    else if (m_pCallback)
    {
        DBG_TRC(("registering snapshot callback when it is already registered"));
        hr = E_INVALIDARG;
    }

    m_Lock.Unlock();

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CStillFilter::DeliverSnapshot

   This function is called from the input pin whenever a new frame is captured.
   The given parameter points to the pixel data (BITMAPINFOHEADER is already
   cached in *m_pbmi).  A new DIB is allocated to store away the newly arrived
   bits.  The new bits are ignored, however, if the callback is not registered.

 *****************************************************************************/

HRESULT
CStillFilter::DeliverSnapshot(HGLOBAL hDib)
{
    DBG_FN("CStillFilter::DeliverSnapshot");

    ASSERT(this !=NULL);
    ASSERT(hDib !=NULL);

    HRESULT hr = S_OK;

    if (hDib == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CStillFilter::DeliverSnapshot received NULL param"));
    }

    if (hr == S_OK)
    {
        m_Lock.Lock();
    
        if (m_pCallback && hDib)
        {
            BOOL bSuccess = TRUE;
    
            bSuccess = (*m_pCallback)(hDib, m_CallbackParam);
        }
    
        m_Lock.Unlock();
    }

    return hr;
}


/*****************************************************************************

   CStillFilter::InitializeBitmapInfo

   This function intialize allocates a BITMAPINFO and copies BITMAPINFOHEADER
   and necessary color table or color mask fromt the given VIDEOINFO.

 *****************************************************************************/

HRESULT
CStillFilter::InitializeBitmapInfo( BITMAPINFOHEADER *pbmiHeader )
{
    DBG_FN("CStillFilter::InitializeBitmapInfo");
    ASSERT(this       !=NULL);
    ASSERT(pbmiHeader !=NULL);

    HRESULT hr = E_OUTOFMEMORY;

    if (!pbmiHeader)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        int ColorTableSize = 0;

        m_bmiSize = pbmiHeader->biSize;

        if (pbmiHeader->biBitCount <= 8)
        {
            //
            // If biClrUsed is zero, it indicates (1 << biBitCount) entries
            //

            if (pbmiHeader->biClrUsed)
                ColorTableSize = pbmiHeader->biClrUsed * sizeof(RGBQUAD);
            else
                ColorTableSize = ((DWORD)1 << pbmiHeader->biBitCount) * 
                                              sizeof(RGBQUAD);

            m_bmiSize += ColorTableSize;
        }

        //
        // color mask
        //

        if (BI_BITFIELDS == pbmiHeader->biCompression)
        {
            //
            // 3 dword of mask
            //

            m_bmiSize += 3 * sizeof(DWORD);
        }

        //
        // now calculate bits size
        // each scanline must be 32 bits aligned.
        //

        m_BitsSize = (((pbmiHeader->biWidth * pbmiHeader->biBitCount + 31) 
                        & ~31) >> 3)
                        * ((pbmiHeader->biHeight < 0) ? -pbmiHeader->biHeight:
                            pbmiHeader->biHeight);

        m_DIBSize = m_bmiSize + m_BitsSize;

        if (m_pbmi)
        {
            delete [] m_pbmi;
        }

        m_pbmi = new BYTE[m_bmiSize];

        if (m_pbmi)
        {
            BYTE *pColorTable = ((BYTE*)pbmiHeader + (WORD)(pbmiHeader->biSize));

            //
            // Copy BITMAPINFOHEADER
            //

            memcpy(m_pbmi, pbmiHeader, pbmiHeader->biSize);

            //
            // copy the color table or color masks if there are any
            //

            if (BI_BITFIELDS == pbmiHeader->biCompression)
            {
                memcpy(m_pbmi + pbmiHeader->biSize, 
                       pColorTable, 
                       3 * sizeof(DWORD));
            }

            if (ColorTableSize)
            {
                memcpy(m_pbmi + pbmiHeader->biSize, 
                       pColorTable, 
                       ColorTableSize);
            }

            hr = S_OK;
        }
    }

    CHECK_S_OK(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\filter\stillf.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998 - 2000
 *
 *  TITLE:       stillf.h
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      WilliamH (original)
 *               RickTu   (revision)
 *
 *  DATE:        9/7/99
 *
 *  DESCRIPTION: Declarations for still filter class
 *
 *****************************************************************************/

#ifndef __STILLF_H_
#define __STILLF_H_

class CStillFilter;
class CStillOutputPin;
class CStillInputPin;

const int MAX_SAMPLE_SIZE = 16;

typedef struct StillSample
{
    ULONG   TimeStamp;
    BYTE*   pBits;
}STILL_SAMPLE, *PSTILL_SAMPLE;


class CStillFilter : public CBaseFilter, public IStillSnapshot
{
    friend class CStillInputPin;
    friend class CStillOutputPin;

public:
    CStillFilter(TCHAR* pObjName, LPUNKNOWN pUnk, HRESULT* phr);
    ~CStillFilter();
    static CUnknown* WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT* phr);
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    DECLARE_IUNKNOWN;

    int GetPinCount();
    CBasePin* GetPin( int n);
    HRESULT Active();
    HRESULT Inactive();

    //
    // IStillSnapshot interface
    //
    STDMETHODIMP Snapshot(ULONG TimeStamp);
    STDMETHODIMP SetSamplingSize(int Size);
    STDMETHODIMP_(int) GetSamplingSize();
    STDMETHODIMP_(DWORD) GetBitsSize();
    STDMETHODIMP_(DWORD) GetBitmapInfoSize();
    STDMETHODIMP GetBitmapInfo(BYTE* pBuffer, DWORD BufferSize);
    STDMETHODIMP RegisterSnapshotCallback(LPSNAPSHOTCALLBACK pCallback, LPARAM lParam);
    STDMETHODIMP GetBitmapInfoHeader(BITMAPINFOHEADER *pbmih);
    //
    // support functions
    //
    HRESULT InitializeBitmapInfo( BITMAPINFOHEADER *pbmiHeader );
    HRESULT DeliverSnapshot(HGLOBAL hDib);

private:
    CCritSec            m_Lock;
    CStillOutputPin     *m_pOutputPin;
    CStillInputPin      *m_pInputPin;
    BYTE                *m_pBits;
    BYTE                *m_pbmi;
    DWORD               m_bmiSize;
    DWORD               m_BitsSize;
    DWORD               m_DIBSize;
    LPSNAPSHOTCALLBACK  m_pCallback;
    LPARAM              m_CallbackParam;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\usd\defprop.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       DefProp.h
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        30 July, 1998
*
*  DESCRIPTION:
*   Default property Declarations and definitions for the
*   WIA test scanner.
*
*******************************************************************************/


#define VT_V_UI1   (VT_VECTOR | VT_UI1)

#define PREFFERED_FORMAT_NOM        &WiaImgFmt_JPEG
#define FORMAT_NOM                  &WiaImgFmt_JPEG

#define NUM_CAM_ITEM_PROPS  (19)
#define NUM_CAM_DEV_PROPS   (7)
#define NUM_CAP_ENTRIES     (5)
#define NUM_EVENTS          (4)

extern PROPID             gItemPropIDs[NUM_CAM_ITEM_PROPS];
extern LPOLESTR           gItemPropNames[NUM_CAM_ITEM_PROPS];
extern PROPID             gItemCameraPropIDs[WIA_NUM_IPC];
extern LPOLESTR           gItemCameraPropNames[WIA_NUM_IPC];
extern PROPID             gDevicePropIDs[NUM_CAM_DEV_PROPS];
extern LPOLESTR           gDevicePropNames[NUM_CAM_DEV_PROPS];
extern PROPSPEC           gDevicePropSpecDefaults[NUM_CAM_DEV_PROPS];
extern WIA_PROPERTY_INFO  gDevPropInfoDefaults[NUM_CAM_DEV_PROPS];
extern PROPSPEC           gPropSpecDefaults[NUM_CAM_ITEM_PROPS];
extern LONG               gPropVarDefaults[];
extern WIA_PROPERTY_INFO  gWiaPropInfoDefaults[NUM_CAM_ITEM_PROPS];
extern WIA_DEV_CAP_DRV    gCapabilities[NUM_CAP_ENTRIES];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\usd\globals.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999 - 2000
 *
 *  TITLE:       globals.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        9/16/99
 *
 *  DESCRIPTION: Globals for this module
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop

PROPID gItemPropIDs[NUM_CAM_ITEM_PROPS] = {
    WIA_IPA_DATATYPE,
    WIA_IPA_DEPTH,
    WIA_IPA_PIXELS_PER_LINE,
    WIA_IPA_NUMBER_OF_LINES,
    WIA_IPC_THUMBNAIL,
    WIA_IPA_ITEM_TIME,
    WIA_IPC_THUMB_WIDTH,
    WIA_IPC_THUMB_HEIGHT,
    WIA_IPA_PREFERRED_FORMAT,
    WIA_IPA_ITEM_SIZE,
    WIA_IPA_FORMAT,
    WIA_IPA_TYMED,
    WIA_IPA_COMPRESSION,
    WIA_IPA_CHANNELS_PER_PIXEL,
    WIA_IPA_BITS_PER_CHANNEL,
    WIA_IPA_PLANAR,
    WIA_IPA_BYTES_PER_LINE,
    WIA_IPA_ACCESS_RIGHTS,
    WIA_IPA_MIN_BUFFER_SIZE
};

LPOLESTR gItemPropNames[NUM_CAM_ITEM_PROPS] =
{
    WIA_IPA_DATATYPE_STR,
    WIA_IPA_DEPTH_STR,
    WIA_IPA_PIXELS_PER_LINE_STR,
    WIA_IPA_NUMBER_OF_LINES_STR,
    WIA_IPC_THUMBNAIL_STR,
    WIA_IPA_ITEM_TIME_STR,
    WIA_IPC_THUMB_WIDTH_STR,
    WIA_IPC_THUMB_HEIGHT_STR,
    WIA_IPA_PREFERRED_FORMAT_STR,
    WIA_IPA_ITEM_SIZE_STR,
    WIA_IPA_FORMAT_STR,
    WIA_IPA_TYMED_STR,
    WIA_IPA_COMPRESSION_STR,
    WIA_IPA_CHANNELS_PER_PIXEL_STR,
    WIA_IPA_BITS_PER_CHANNEL_STR,
    WIA_IPA_PLANAR_STR,
    WIA_IPA_BYTES_PER_LINE_STR,
    WIA_IPA_ACCESS_RIGHTS_STR,
    WIA_IPA_MIN_BUFFER_SIZE_STR
};

PROPID gItemCameraPropIDs[WIA_NUM_IPC] = {
    WIA_IPC_AUDIO_AVAILABLE,
    WIA_IPC_AUDIO_DATA
};

LPOLESTR gItemCameraPropNames[WIA_NUM_IPC] =
{
    WIA_IPC_AUDIO_AVAILABLE_STR,
    WIA_IPC_AUDIO_DATA_STR,
};

PROPID gDevicePropIDs[NUM_CAM_DEV_PROPS] =
{
    WIA_DPA_CONNECT_STATUS,
    WIA_DPC_PICTURES_TAKEN,
    WIA_DPC_THUMB_WIDTH,
    WIA_DPC_THUMB_HEIGHT,
    WIA_DPV_DSHOW_DEVICE_PATH,
    WIA_DPV_IMAGES_DIRECTORY,
    WIA_DPV_LAST_PICTURE_TAKEN
};

LPOLESTR gDevicePropNames[NUM_CAM_DEV_PROPS] =
{
    WIA_DPA_CONNECT_STATUS_STR,
    WIA_DPC_PICTURES_TAKEN_STR,
    WIA_DPC_THUMB_WIDTH_STR,
    WIA_DPC_THUMB_HEIGHT_STR,
    WIA_DPV_DSHOW_DEVICE_PATH_STR,
    WIA_DPV_IMAGES_DIRECTORY_STR,
    WIA_DPV_LAST_PICTURE_TAKEN_STR
};

PROPSPEC gDevicePropSpecDefaults[NUM_CAM_DEV_PROPS] = {

    {PRSPEC_PROPID, WIA_DPA_CONNECT_STATUS},
    {PRSPEC_PROPID, WIA_DPC_PICTURES_TAKEN},
    {PRSPEC_PROPID, WIA_DPC_THUMB_WIDTH},
    {PRSPEC_PROPID, WIA_DPC_THUMB_HEIGHT},
    {PRSPEC_PROPID, WIA_DPV_DSHOW_DEVICE_PATH},
    {PRSPEC_PROPID, WIA_DPV_IMAGES_DIRECTORY},
    {PRSPEC_PROPID, WIA_DPV_LAST_PICTURE_TAKEN}
};

WIA_PROPERTY_INFO  gDevPropInfoDefaults[NUM_CAM_DEV_PROPS] = {
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4,       0,    0,    0,    0}, // WIA_DPA_CONNECT_STATUS
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4,       0,    0,    0,    0}, // WIA_DPC_PICTURES_TAKEN
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4,       0,    0,    0,    0}, // WIA_DPC_THUMB_WIDTH
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4,       0,    0,    0,    0}, // WIA_DPC_THUMB_HEIGHT
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_LPWSTR,   0,    0,    0,    0}, // WIA_DPV_DSHOW_DEVICE_PATH
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_LPWSTR,   0,    0,    0,    0}, // WIA_DPV_IMAGES_DIRECTORY
    {WIA_PROP_RW   | WIA_PROP_NONE,    VT_LPWSTR,   0,    0,    0,    0}  // WIA_DPV_LAST_PICTURE_TAKEN
};

PROPSPEC gPropSpecDefaults[NUM_CAM_ITEM_PROPS] = {
   {PRSPEC_PROPID, WIA_IPA_DATATYPE},
   {PRSPEC_PROPID, WIA_IPA_DEPTH},
   {PRSPEC_PROPID, WIA_IPA_PIXELS_PER_LINE},
   {PRSPEC_PROPID, WIA_IPA_NUMBER_OF_LINES},
   {PRSPEC_PROPID, WIA_IPC_THUMBNAIL},
   {PRSPEC_PROPID, WIA_IPA_ITEM_TIME},
   {PRSPEC_PROPID, WIA_IPC_THUMB_WIDTH},
   {PRSPEC_PROPID, WIA_IPC_THUMB_HEIGHT},
   {PRSPEC_PROPID, WIA_IPA_PREFERRED_FORMAT},
   {PRSPEC_PROPID, WIA_IPA_ITEM_SIZE},
   {PRSPEC_PROPID, WIA_IPA_FORMAT},
   {PRSPEC_PROPID, WIA_IPA_TYMED},
   {PRSPEC_PROPID, WIA_IPA_COMPRESSION},
   {PRSPEC_PROPID, WIA_IPA_CHANNELS_PER_PIXEL},
   {PRSPEC_PROPID, WIA_IPA_BITS_PER_CHANNEL},
   {PRSPEC_PROPID, WIA_IPA_PLANAR},
   {PRSPEC_PROPID, WIA_IPA_BYTES_PER_LINE},
   {PRSPEC_PROPID, WIA_IPA_ACCESS_RIGHTS},
   {PRSPEC_PROPID, WIA_IPA_MIN_BUFFER_SIZE},
};

LONG  gPropVarDefaults[(sizeof(PROPVARIANT) / sizeof(LONG)) * (NUM_CAM_ITEM_PROPS)] = {
   // VARTYPE                 reserved    val               pad/array ptr
   (LONG)VT_I4,               0x00000000, WIA_DATA_COLOR,0x00000000,            // WIA_IPA_DATATYPE
   (LONG)VT_I4,               0x00000000, 24,                 0x00000000,            // WIA_IPA_DEPTH

   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_PIXELS_PER_LINE
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_NUMBER_OF_LINES

   (LONG)VT_VECTOR | VT_UI1,  0x00000000, 0,                 0x00000000,            // WIA_IPC_THUMBNAIL
   (LONG)VT_VECTOR | VT_I4,   0x00000000, 0,                 0x00000000,            // WIA_IPA_ITEM_TIME
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPC_THUMB_WIDTH
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPC_THUMB_HEIGHT
   (LONG)VT_CLSID,            0x00000000, PtrToLong(PREFFERED_FORMAT_NOM)/* BUGBUG can our dll be loaded at > 4gig ??*/,0x00000000,    // WIA_IPA_PREFERRED_FORMAT
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_ITEM_SIZE
   (LONG)VT_CLSID,            0x00000000, PtrToLong(FORMAT_NOM)/* BUGBUG can our dll be loaded at > 4gig ??*/,  0x00000000,            // WIA_IPA_FORMAT
   (LONG)VT_I4,               0x00000000, TYMED_FILE,        0x00000000,            // WIA_IPA_TYMED
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_COMPRESSION
   (LONG)VT_I4,               0x00000000, 3,                 0x00000000,            // WIA_IPA_CHANNELS PER PIXEL
   (LONG)VT_I4,               0x00000000, 8,                 0x00000000,            // WIA_IPA_BITS PER CHANNEL
   (LONG)VT_I4,               0x00000000, WIA_PACKED_PIXEL,  0x00000000,            // WIA_IPA_PLANAR
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_WIDTH IN BYTES
   (LONG)VT_I4,               0x00000000, WIA_ITEM_RD,       0x00000000,             // WIA_IPA_ACCESS_RIGHTS

   (LONG)VT_I4,               0x00000000, 65535,             0x00000000,            // WIA_IPA_MIN_BUFFER_SIZE
};


// Default device extended properties.

#define NUM_DATATYPE 1
LONG lDataTypes[NUM_DATATYPE] = {
    WIA_DATA_COLOR
};

#define NUM_DEPTH 1
LONG lDepths[NUM_DEPTH] = {
    24
};

//
//  Different formats supported
//

#define NUM_FORMAT 3

GUID* pguidFormats[NUM_FORMAT] =
{
    (GUID*) &WiaImgFmt_JPEG,
    (GUID*) &WiaImgFmt_MEMORYBMP,
    (GUID*) &WiaImgFmt_BMP
};

GUID g_guidFormats[NUM_FORMAT];   // FormatID's specified in pguidFormats are copied to g_guidFormats
                                  // during SetFormatAttribs

//
//  This is an array of WIA_FORMAT_INFOs, describing the different formats
//  and their corresponding media types.  Initialized in minidrvr.cpp
//

WIA_FORMAT_INFO* g_wfiTable = NULL;

//
//  Different media types supported
//

#define NUM_TYMED  2
LONG lTymeds [NUM_TYMED]= {
    TYMED_FILE,
    TYMED_CALLBACK,
};

//
// Extended information for each property
//

WIA_PROPERTY_INFO  gWiaPropInfoDefaults[NUM_CAM_ITEM_PROPS] = {

    {WIA_PROP_READ | WIA_PROP_LIST, VT_I4, NUM_DATATYPE, WIA_DATA_COLOR, PtrToLong(lDataTypes)/* BUGBUG can our dll be loaded at > 4gig ??*/, 0}, // WIA_IPA_DATATYPE
    {WIA_PROP_READ | WIA_PROP_LIST, VT_I4, NUM_DEPTH,    24,                  PtrToLong(lDepths)/* BUGBUG can our dll be loaded at > 4gig ??*/,    0}, // WIA_IPA_DEPTH

    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_PIXELS_PER_LINE
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_NUMBER_OF_LINES
    {WIA_PROP_READ | WIA_PROP_NONE, VT_V_UI1, 0,    0,    0,    0}, // WIA_IPC_THUMBNAIL
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_ITEM_TIME
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPC_THUMB_WIDTH
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPC_THUMB_HEIGHT
    {WIA_PROP_READ | WIA_PROP_NONE, VT_CLSID, 0,    0,    0,    0}, // WIA_IPA_PREFERRED_FORMAT, set later
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_ITEM_SIZE

    {WIA_PROP_RW   | WIA_PROP_LIST, VT_CLSID, 0,    0,    0,    0}, // WIA_IPA_FORMAT, set later
    {WIA_PROP_RW   | WIA_PROP_LIST, VT_I4,    NUM_TYMED,    TYMED_FILE, PtrToLong(lTymeds)/* BUGBUG can our dll be loaded at > 4gig ??*/,     0}, // WIA_IPA_TYMED
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_COMPRESSION
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_CHANNELS
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_BITS_PER_CHANNEL
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_PLANAR
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_BYTES_PER_LINE
    {WIA_PROP_RW   | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_ACCESS_RIGHTS

    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_MIN_BUFFER_SIZE

};



//
// Device capabilities.  Events are listed before commands to simplify the
// implementation of drvGetCapabilities(...)
//

#define N   WIA_NOTIFICATION_EVENT
#define A   WIA_ACTION_EVENT
#define NA  (WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT)

WIA_DEV_CAP_DRV gCapabilities[NUM_CAP_ENTRIES] =
{
    {(GUID *)&WIA_EVENT_DEVICE_CONNECTED,    N,  L"Device connected",    L"Device connected",    WIA_ICON_DEVICE_CONNECTED},
    {(GUID *)&WIA_EVENT_DEVICE_DISCONNECTED, N,  L"Device disconnected", L"Device disconnected", WIA_ICON_DEVICE_DISCONNECTED},
    {(GUID *)&WIA_EVENT_ITEM_CREATED,        N,  L"New picture created", L"New picture created", WIA_ICON_ITEM_CREATED},
    {(GUID *)&WIA_EVENT_ITEM_DELETED,        N,  L"Picture deleted",     L"Picture deleted",     WIA_ICON_ITEM_DELETED},
    {(GUID *)&WIA_CMD_TAKE_PICTURE,          0,  L"Take picture",        L"Take picture",        WIA_ICON_TAKE_PICTURE}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\usd\image.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999 - 2000
 *
 *  TITLE:       image.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        9/16/99
 *
 *  DESCRIPTION: CImage class for WIA still from video driver.  Encapsulate
 *               saved images into a class (one instace for each class)
 *
 *****************************************************************************/


#ifndef __WIA_STILL_DRIVER_IMAGE_H_
#define __WIA_STILL_DRIVER_IMAGE_H_


#define THUMB_WIDTH     80
#define THUMB_HEIGHT    60
#define THUMB_BPP       3
#define THUMB_SIZE_BYTES (THUMB_WIDTH * THUMB_HEIGHT * THUMB_BPP)

extern CLSID g_clsidBMPEncoder;


class CImage
{
public:
    CImage(LPCTSTR  pszStillPath,
           BSTR     bstrRootFullItemName,
           LPCTSTR  pszPath,
           LPCTSTR  pszName,
           LONG     FolderType);

    ~CImage();

    //
    // Methods
    //

    STDMETHOD(InitImageInformation)(BYTE *pWiasContext,LONG *plDevErrVal);
    STDMETHOD(SetItemSize)(BYTE *pWiasContext, MINIDRV_TRANSFER_CONTEXT * pDrvTranCtx);
    STDMETHOD(LoadThumbnail)(BYTE *pWiasContext);
    STDMETHOD(LoadImageInfo)(BYTE *pWiasContext);

    void    GetImageTimeStamp( SYSTEMTIME * pst );
    void    GetImageSizes();
    LPCTSTR ActualImagePath();
    HRESULT DoDelete();

    //
    // "Properties" -- still methods but just returning information
    //

    BSTR        bstrItemName();
    BSTR        bstrFullItemName();
    LONG        ThumbWidth();
    LONG        ThumbHeight();

private:
    CSimpleString       m_strRootPath;
    CSimpleString       m_strPathItem;
    CSimpleString       m_strName;
    CSimpleBStr         m_bstrRootFullItemName;
    CSimpleBStr         m_bstrFullItemName;
    CSimpleBStr         m_bstrItemName;
    LONG                m_FolderType;
    SYSTEMTIME          m_ImageTime;
    BOOL                m_bImageTimeValid;
    CRITICAL_SECTION    m_cs;
    PBYTE               m_pThumb;
};

typedef struct _STILLCAM_IMAGE_CONTEXT
{
    CImage *        pImage;

} STILLCAM_IMAGE_CONTEXT,*PSTILLCAM_IMAGE_CONTEXT;


class CMappedView
{

private:
    BYTE * m_pBits;
    HANDLE m_hFile;
    HANDLE m_hMap;
    LONG   m_lSize;

public:
    CMappedView( LPCTSTR pszFile, LONG lSize, DWORD dwOpen )
      : m_pBits(NULL),
        m_hFile(INVALID_HANDLE_VALUE),
        m_hMap(NULL),
        m_lSize(lSize)
    {
        m_hFile = CreateFile( pszFile,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_WRITE | FILE_SHARE_READ,
                              NULL,
                              dwOpen,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL
                             );

        if (m_hFile == INVALID_HANDLE_VALUE)
        {
            WIA_ERROR((TEXT("CreateFile failed w/GLE = %d"),GetLastError()));
        }

        WIA_TRACE((TEXT("CMappedView(0x%x) for %s"),m_hFile,pszFile));

        DoCreateFileMapping();
    }

    CMappedView( HANDLE hFile, LONG lSize )
      : m_pBits(NULL),
        m_hFile(hFile),
        m_hMap(INVALID_HANDLE_VALUE),
        m_lSize(lSize)
    {
        WIA_TRACE((TEXT("CMappedView(0x%x)"),m_hFile));

        DoCreateFileMapping();
    }

    void DoCreateFileMapping()
    {
        if (m_hFile != INVALID_HANDLE_VALUE)
        {
            m_hMap = CreateFileMapping( m_hFile,
                                        NULL,
                                        PAGE_READWRITE,
                                        0,
                                        m_lSize,
                                        NULL
                                       );

            if (m_hMap)
            {
                m_pBits = (PBYTE)MapViewOfFileEx( m_hMap,
                                                  FILE_MAP_READ | FILE_MAP_WRITE,
                                                  0,
                                                  0,
                                                  0,
                                                  NULL
                                                 );
            }
            else
            {
                WIA_ERROR((TEXT("CreateFileMapping failed w/GLE = %d"),GetLastError()));
            }
        }
    }

    LARGE_INTEGER FileSize()
    {
        WIA_TRACE((TEXT("CMappedView::FileSize")));

        LARGE_INTEGER li;

        li.QuadPart = 0;

#ifdef WINNT
        GetFileSizeEx( m_hFile, &li );
#else
        DWORD LowPart = 0;


        LowPart = GetFileSize( m_hFile, (DWORD *)&li.HighPart );

        if (LowPart != -1)
        {
            li.LowPart = LowPart;
        }
#endif

        return li;
    }

    void CloseAndRelease()
    {
        WIA_TRACE((TEXT("CMappedView::CloseAndRelease()")));

        if (m_pBits)
        {
            if (!UnmapViewOfFile( m_pBits ))
            {
                WIA_ERROR((TEXT("UnmapViewOfFile failed w/GLE = %d"),GetLastError()));
            }
            m_pBits = NULL;
        }

        if (m_hMap)
        {
            if (!CloseHandle( m_hMap ))
            {
                WIA_ERROR((TEXT("CloseHandle( m_hMap ) failed w/GLE = %s"),GetLastError()));
            }
            m_hMap = NULL;
        }

        if (m_hFile != INVALID_HANDLE_VALUE)
        {
            WIA_TRACE((TEXT("Closing file handle (0x%x)"),m_hFile));

            if (!CloseHandle( m_hFile ))
            {
                WIA_ERROR((TEXT("CloseHandle( m_hFile ) failed w/GLE = %s"),GetLastError()));
            }
            m_hFile = INVALID_HANDLE_VALUE;
        }
    }

    ~CMappedView()
    {
        WIA_TRACE((TEXT("~CMappedView")));
        CloseAndRelease();
    }

    PBYTE Bits()
    {
        return m_pBits;
    }

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\usd\image.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999 - 2000
 *
 *  TITLE:       image.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        9/16/99
 *
 *  DESCRIPTION: Image class that encapsulates stored images from the
 *               streaming video device.
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop

CLSID g_clsidBMPEncoder = GUID_NULL;

using namespace Gdiplus;

/*****************************************************************************

   CImage constructor/desctructor

   <Notes>

 *****************************************************************************/

CImage::CImage(LPCTSTR     pszStillPath,
               BSTR        bstrRootFullItemName,
               LPCTSTR     pszPath,
               LPCTSTR     pszName,
               LONG        FolderType)
  : m_strRootPath(pszStillPath),
    m_strPathItem(pszPath),
    m_strName(pszName),
    m_bstrItemName(pszName),
    m_bstrRootFullItemName(bstrRootFullItemName),
    m_FolderType(FolderType),
    m_bImageTimeValid(FALSE),
    m_pThumb(NULL)
{
    DBG_FN("CImage::CImage");

    CSimpleStringWide str;
    CSimpleStringWide strName(m_bstrItemName);

    //
    // First, we need to strip off the extensions
    // from the appropriate places
    //

    strName = strName.Left(strName.ReverseFind( TEXT('.') ));

    m_bstrItemName = CSimpleBStr(strName);

    str = bstrRootFullItemName;
    str.Concat(L"\\");
    str += CSimpleStringWide(m_bstrItemName);

    m_bstrFullItemName = str.String();
}


CImage::~CImage()
{
    if (m_pThumb)
    {
        delete [] m_pThumb;
    }
}

/*****************************************************************************

   CImage::LoadImageInfo

   Loads information about the image such as its width, height, type, etc.

 *****************************************************************************/

STDMETHODIMP
CImage::LoadImageInfo( BYTE * pWiasContext )
{
    ASSERT(pWiasContext != NULL);

    HRESULT hr = S_OK;
    LONG    lBitsPerChannel     = 0;
    LONG    lBitsPerPixel       = 0;
    LONG    lWidth              = 0;
    LONG    lHeight             = 0;
    LONG    lChannelsPerPixel   = 0;
    LONG    lBytesPerLine       = 0;
    Bitmap  Image(CSimpleStringConvert::WideString(m_strPathItem));

    if (pWiasContext == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("LoadImageInfo received a NULL pointer"));
        return hr;
    }
    else if (Image.GetLastStatus() != Ok)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CImage::LoadImageInfo failed to get the image information"
                         "for file '%ls'", CSimpleStringConvert::WideString(m_strPathItem)));

        return hr;
    }

    if (hr == S_OK)
    {
        PixelFormat lFormat;
        lFormat = Image.GetPixelFormat();

        if ((lFormat == PixelFormat16bppGrayScale) ||
            (lFormat == PixelFormat16bppRGB555)    ||
            (lFormat == PixelFormat16bppRGB565)    ||
            (lFormat == PixelFormat16bppARGB1555))
        {
            lBitsPerPixel   = 16;
            lBitsPerChannel = 5;   // this is actually not completely correct for RGB565, but anyway...
        }
        else if (lFormat == PixelFormat24bppRGB)
        {
            lBitsPerPixel   = 24;
            lBitsPerChannel = 8;
        }
        else if ((lFormat == PixelFormat32bppRGB)   ||
                 (lFormat == PixelFormat32bppARGB)  ||
                 (lFormat == PixelFormat32bppPARGB))
        {
            lBitsPerPixel   = 32;
            lBitsPerChannel = 10; // well, video cap won't have alpha in it, 
        }

        lWidth            = (LONG) Image.GetWidth();
        lHeight           = (LONG) Image.GetHeight();
        lChannelsPerPixel = 3;
        lBytesPerLine     = lWidth * (lBitsPerPixel / 8);
    }

    if (hr == S_OK)
    {
        PROPSPEC    propSpecs[7];
        PROPVARIANT propVars[7];

        ZeroMemory(propSpecs, sizeof(propSpecs));

        // WIA_IPA_DATATYPE
        propSpecs[0].ulKind = PRSPEC_PROPID;
        propSpecs[0].propid = WIA_IPA_DATATYPE;
        propVars[0].vt      = VT_I4;
        propVars[0].lVal    = WIA_DATA_COLOR;

        // WIA_IPA_DEPTH
        propSpecs[1].ulKind = PRSPEC_PROPID;
        propSpecs[1].propid = WIA_IPA_DEPTH;
        propVars[1].vt      = VT_I4;
        propVars[1].lVal    = lBitsPerPixel;

        // WIA_IPA_PIXELS_PER_LINE
        propSpecs[2].ulKind = PRSPEC_PROPID;
        propSpecs[2].propid = WIA_IPA_PIXELS_PER_LINE;
        propVars[2].vt      = VT_I4;
        propVars[2].lVal    = lWidth;

        // WIA_IPA_NUMBER_OF_LINES
        propSpecs[3].ulKind = PRSPEC_PROPID;
        propSpecs[3].propid = WIA_IPA_NUMBER_OF_LINES;
        propVars[3].vt      = VT_I4;
        propVars[3].lVal    = lHeight;

        // WIA_IPA_CHANNELS_PER_PIXEL
        propSpecs[4].ulKind = PRSPEC_PROPID;
        propSpecs[4].propid = WIA_IPA_CHANNELS_PER_PIXEL;
        propVars[4].vt      = VT_I4;
        propVars[4].lVal    = lChannelsPerPixel;

        // WIA_IPA_BITS_PER_CHANNEL
        propSpecs[5].ulKind = PRSPEC_PROPID;
        propSpecs[5].propid = WIA_IPA_BITS_PER_CHANNEL;
        propVars[5].vt      = VT_I4;
        propVars[5].lVal    = lBitsPerChannel;

        // WIA_IPA_BYTES_PER_LINE
        propSpecs[6].ulKind = PRSPEC_PROPID;
        propSpecs[6].propid = WIA_IPA_BYTES_PER_LINE;
        propVars[6].vt      = VT_I4;
        propVars[6].lVal    = lBytesPerLine;

        // write the values of the properties.
        hr = wiasWriteMultiple(pWiasContext, 
                               sizeof(propVars) / sizeof(propVars[0]), 
                               propSpecs, 
                               propVars);

        CHECK_S_OK2(hr, ("CImage::LoadImageInfo, failed to write image properties"));
    }

    return hr;
}



/*****************************************************************************

   CImage::SetItemSize

   Call wia to calc new item size

 *****************************************************************************/

STDMETHODIMP
CImage::SetItemSize(BYTE                     * pWiasContext, 
                    MINIDRV_TRANSFER_CONTEXT * pDrvTranCtx)
{
    HRESULT                    hr;
    MINIDRV_TRANSFER_CONTEXT   drvTranCtx;
    GUID                       guidFormatID;
    BOOL                       bWriteProps = (pDrvTranCtx == NULL);

    DBG_FN("CImage::SetItemSize");

    ZeroMemory(&drvTranCtx, sizeof(MINIDRV_TRANSFER_CONTEXT));

    if (!pDrvTranCtx)
    {
        pDrvTranCtx = &drvTranCtx;
    }

    hr = wiasReadPropGuid(pWiasContext,
                          WIA_IPA_FORMAT,
                          (GUID*)&(pDrvTranCtx->guidFormatID),
                          NULL,
                          FALSE);

    CHECK_S_OK2(hr,("wiasReadPropGuid( WIA_IPA_FORMAT )"));

    if (FAILED(hr))
    {
        return hr;
    }

    hr = wiasReadPropLong( pWiasContext,
                           WIA_IPA_TYMED,
                           (LONG*)&(pDrvTranCtx->tymed),
                           NULL,
                           FALSE
                         );
    CHECK_S_OK2(hr,("wiasReadPropLong( WIA_IPA_TYMED )"));

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Wias works for DIB, and minidriver support native formats
    //

    if ((pDrvTranCtx->guidFormatID != WiaImgFmt_JPEG) &&
        (pDrvTranCtx->guidFormatID != WiaImgFmt_FLASHPIX) &&
        (pDrvTranCtx->guidFormatID != WiaImgFmt_TIFF))
    {
        //
        // Create the image from the file.
        //
        Bitmap BitmapImage(CSimpleStringConvert::WideString(m_strPathItem));
        if (Ok == BitmapImage.GetLastStatus())
        {
            //
            // Get the image's dimensions
            //
            UINT nSourceWidth = BitmapImage.GetWidth();
            UINT nSourceHeight = BitmapImage.GetHeight();
            if (nSourceWidth && nSourceHeight)
            {
                //
                // Fill in info for drvTranCtx
                //
                pDrvTranCtx->lCompression   = WIA_COMPRESSION_NONE;
                pDrvTranCtx->lWidthInPixels = nSourceWidth;
                pDrvTranCtx->lLines         = nSourceHeight;
                pDrvTranCtx->lDepth         = 24;

                hr = wiasGetImageInformation( pWiasContext, 0, pDrvTranCtx );

                //
                // We need to write out the item size based on
                // the JPEG converted to a BMP.  But we only need
                // to do this if the incoming context was NULL.
                //
                if (bWriteProps)
                {
                    hr = wiasWritePropLong( pWiasContext,
                                            WIA_IPA_ITEM_SIZE,
                                            pDrvTranCtx->lItemSize
                                          );
                    CHECK_S_OK2(hr,("wiasWritePropLong( WIA_IPA_ITEM_SIZE )"));

                    hr = wiasWritePropLong( pWiasContext,
                                            WIA_IPA_BYTES_PER_LINE,
                                            pDrvTranCtx->cbWidthInBytes
                                          );
                    CHECK_S_OK2(hr,("wiasWritePropLong( WIA_IPA_BYTES_PER_LINE )"));
                }

            }
            else
            {
                DBG_ERR(("nSourceWidth OR nSourceHeight were zero"));
                hr = E_FAIL;
            }

        }
        else
        {
            DBG_ERR(("Ok == BitmapImage.GetLastStatus failed"));
            hr = E_FAIL;
        }

    }
    else
    {

        CMappedView cmv( ActualImagePath(), 0, OPEN_EXISTING );

        LARGE_INTEGER liSize = cmv.FileSize();
        ULONG         ulSize;

        if (liSize.HighPart)
        {
            ulSize = 0;
            DBG_ERR(("The file was bigger than 4GB!!!"));
        }
        else
        {
            //
            // We could truncate here, I know, but that would have to be one huge file...
            // Anyway, the size wouldn't fit in te properties, which expects a LONG
            //
            ulSize = (ULONG)liSize.LowPart;
        }

        pDrvTranCtx->lItemSize      = ulSize;
        pDrvTranCtx->cbWidthInBytes = 0;

        if (bWriteProps)
        {
            //
            // We need to write out the item size based on the file size...
            //

            hr = wiasWritePropLong(pWiasContext,
                                   WIA_IPA_ITEM_SIZE,
                                   ulSize);

            CHECK_S_OK2(hr,("wiasWritePropLong( WIA_IPA_ITEM_SIZE )"));

            hr = wiasWritePropLong(pWiasContext,
                                   WIA_IPA_BYTES_PER_LINE,
                                   0);
        }

        CHECK_S_OK2(hr,("wiasWritePropLong( WIA_IPA_BYTES_PER_LINE )"));
    }

    CHECK_S_OK(hr);
    return hr;
}



/*****************************************************************************

   CImage::LoadThumbnail

   Loads (or creates if not already present) the thumbnail for this item.
   We also write the thumbnail as a property for this item.

 *****************************************************************************/

STDMETHODIMP
CImage::LoadThumbnail( BYTE * pWiasContext )
{

    HRESULT hr = E_FAIL;
    DBG_FN("CImage::LoadThumbnail");

    //
    // Only create the thumbnail if we haven't done so already
    //
    if (!m_pThumb)
    {
        Status StatusResult = Ok;

        //
        // Open the source image and make sure it is OK
        //
        Bitmap SourceImage( CSimpleStringConvert::WideString(m_strPathItem) );

        StatusResult = SourceImage.GetLastStatus();
        if (Ok == StatusResult)
        {

            //
            // Create the scaled bitmap and make sure it is OK
            //
            Bitmap ScaledImage(THUMB_WIDTH, THUMB_HEIGHT);

            StatusResult = ScaledImage.GetLastStatus();
            if (Ok == StatusResult)
            {
                //
                // Get a graphics to render the scaled image to and make sure it isn't NULL
                //
                Graphics *pScaledGraphics = Graphics::FromImage(&ScaledImage);
                if (pScaledGraphics)
                {
                    //
                    // Make sure it is valid
                    //
                    StatusResult = pScaledGraphics->GetLastStatus();
                    if (StatusResult == Ok)
                    {
                        //
                        // Draw the image scaled to thumbnail size
                        //
                        StatusResult = pScaledGraphics->DrawImage(&SourceImage, 0, 0, THUMB_WIDTH, THUMB_HEIGHT );
                        if (Ok == StatusResult)
                        {
                            //
                            // Create a bitmap to hold the flipped thumbnail and make sure it is OK
                            //
                            Bitmap FlippedImage(THUMB_WIDTH, THUMB_HEIGHT);

                            StatusResult = FlippedImage.GetLastStatus();
                            if (Ok == StatusResult)
                            {
                                //
                                // Create a graphics object to render the flipped image to and make sure it isn't NULL
                                //
                                Graphics *pFlippedGraphics = Graphics::FromImage(&FlippedImage);
                                if (pFlippedGraphics)
                                {
                                    //
                                    // Make sure it is valid
                                    //
                                    StatusResult = pFlippedGraphics->GetLastStatus();
                                    if (Ok == StatusResult)
                                    {
                                        //
                                        // Set up the parallelogram to flip the image
                                        //
                                        Point SourcePoints[3];
                                        SourcePoints[0].X = 0;
                                        SourcePoints[0].Y = THUMB_HEIGHT;
                                        SourcePoints[1].X = THUMB_WIDTH;
                                        SourcePoints[1].Y = THUMB_HEIGHT;
                                        SourcePoints[2].X = 0;
                                        SourcePoints[2].Y = 0;

                                        //
                                        // Draw the image, flipped
                                        //
                                        StatusResult = pFlippedGraphics->DrawImage(&ScaledImage, SourcePoints, 3);
                                        if (StatusResult == Ok)
                                        {
                                            //
                                            // Get the scaled and flipped image bits
                                            //
                                            Rect rcThumb( 0, 0, THUMB_WIDTH, THUMB_HEIGHT );
                                            BitmapData BitmapData;

// This ifdef is due to an API change in GDI+.  Notice
// that the first param to LockBits in the new version 
// takes a ptr to RECT.  Old version takes a reference
// to a RECT.
#ifdef DCR_USE_NEW_293849
                                            StatusResult = FlippedImage.LockBits( &rcThumb, ImageLockModeRead, PixelFormat24bppRGB, &BitmapData );
#else
                                            StatusResult = FlippedImage.LockBits( rcThumb, ImageLockModeRead, PixelFormat24bppRGB, &BitmapData );
#endif
                                            if (Ok == StatusResult)
                                            {
                                                //
                                                // Allocate the thumbnail data
                                                //
                                                m_pThumb = new BYTE[THUMB_SIZE_BYTES];
                                                if (m_pThumb)
                                                {
                                                    //
                                                    // Copy the thumbnail data over
                                                    //
                                                    CopyMemory( m_pThumb, BitmapData.Scan0, THUMB_SIZE_BYTES );
                                                }
                                                else
                                                {
                                                    hr = E_OUTOFMEMORY;
                                                    CHECK_S_OK2(hr, ("m_pThumb is NULL, couldn't allocate memory"));
                                                }
                                                //
                                                // Unlock the bits
                                                //
                                                FlippedImage.UnlockBits( &BitmapData );
                                            }
                                            else
                                            {
                                                DBG_ERR(("FlippedImage.LockBits( &rcThumb, ImageLockModeRead, PixelFormat24bppRGB, &BitmapData ) failed"));
                                            }
                                        }
                                        else
                                        {
                                            DBG_ERR(("pFlippedGraphics->DrawImage(&ScaledImage, SourcePoints, 3) failed"));
                                        }
                                    }
                                    else
                                    {
                                        DBG_ERR(("Ok == pFlippedGraphics->GetLastStatus() failed = '%d' (0x%08x)",
                                                 StatusResult, StatusResult));
                                    }
                                    //
                                    // Free the graphics object
                                    //
                                    delete pFlippedGraphics;
                                }
                                else
                                {
                                    DBG_ERR(("Graphics *pFlippedGraphics = Graphics::FromImage(&FlippedImage); returned NULL"));
                                }
                            }
                            else
                            {
                                DBG_ERR(("Ok == FlippedImage.GetLastStatus() failed = '%d',(0x%08x)",
                                         StatusResult, StatusResult));
                            }
                        }
                        else
                        {
                            DBG_ERR(("pScaledGraphics->DrawImage(&SourceImage, 0, 0, THUMB_WIDTH, THUMB_HEIGHT ) failed"));
                        }
                    }
                    else
                    {
                        DBG_ERR(("pScaledGraphics->GetLastStatus() failed = '%d' (0x%08x)",
                                 StatusResult, StatusResult));
                    }
                    //
                    // Free the graphics object
                    //
                    delete pScaledGraphics;
                }
                else
                {
                    DBG_ERR(("Graphics *pScaledGraphics = Graphics::FromImage(&ScaledImage); returned NULL"));
                }
            }
            else
            {
                DBG_ERR(("ScaledImage.GetLastStatus() failed = '%d' (0x%08x)",
                         StatusResult, StatusResult));
            }
        }
        else
        {
            DBG_ERR(("SourceImage.GetLastStatus() failed = '%d' (0x%08x)",
                     StatusResult, StatusResult));
        }
    }

    if (m_pThumb)
    {
        //
        // We have the bits, write them out as a property
        //

        PROPSPEC    propSpec;
        PROPVARIANT propVar;

        PropVariantInit(&propVar);

        propVar.vt          = VT_VECTOR | VT_UI1;
        propVar.caub.cElems = THUMB_SIZE_BYTES;
        propVar.caub.pElems = m_pThumb;

        propSpec.ulKind = PRSPEC_PROPID;
        propSpec.propid = WIA_IPC_THUMBNAIL;

        hr = wiasWriteMultiple(pWiasContext, 1, &propSpec, &propVar);
        CHECK_S_OK2(hr,("wiasWriteMultiple( WIA_IPC_THUMBNAIL )"));
    }
    else
    {
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
        }
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CImage::InitImageInformation

   Called to initialize the properties for this image.  In the process,
   we also load (or create if needed) the thumbnail for this item.

 *****************************************************************************/

STDMETHODIMP
CImage::InitImageInformation(BYTE *pWiasContext,
                             LONG *plDevErrVal)
{
    HRESULT hr = S_OK;
    SYSTEMTIME st;


    DBG_FN("CImage::InitImageInformation");

    //
    // Use WIA services to set the extended property access and
    // valid value information from gWiaPropInfoDefaults.
    //

    hr = wiasSetItemPropAttribs( pWiasContext,
                                 NUM_CAM_ITEM_PROPS,
                                 gPropSpecDefaults,
                                 gWiaPropInfoDefaults
                               );
    //
    // Use WIA services to write image properties.
    //

    hr = wiasWritePropLong(pWiasContext, WIA_IPC_THUMB_WIDTH, ThumbWidth());
    CHECK_S_OK2(hr,("wiasWritePropLong( WIA_IPC_THUMB_WIDTH )"));

    hr = wiasWritePropLong(pWiasContext, WIA_IPC_THUMB_HEIGHT, ThumbHeight());
    CHECK_S_OK2(hr,("wiasWritePropLong( WIA_IPC_THUMB_HEIGHT )"));

    hr = wiasWritePropGuid(pWiasContext, WIA_IPA_PREFERRED_FORMAT, WiaImgFmt_JPEG);
    CHECK_S_OK2(hr,("wiasWritePropGuid( WIA_IPA_PREFERRED_FORMAT )"));

    GetImageTimeStamp( &st );
    hr = wiasWritePropBin( pWiasContext, WIA_IPA_ITEM_TIME, sizeof(SYSTEMTIME), (PBYTE)&st);
    CHECK_S_OK2(hr,("wiasWritePropBin( WIA_IPA_ITEM_TIME )"));

    //
    // calc item size
    //

    hr = SetItemSize(pWiasContext,NULL);
    CHECK_S_OK2(hr,("SetItemSize"));

    //
    // load thumbnail
    //

    hr = LoadThumbnail( pWiasContext );
    CHECK_S_OK2(hr,("LoadThumbnail"));

    //
    // Load additional image information such as the pixels per line, 
    // number of lines, etc.
    //
    hr = LoadImageInfo(pWiasContext);

    CHECK_S_OK2(hr,("wiaSetItemPropAttribs"));

    return hr;
}


/*****************************************************************************

   CImage::bstrItemName

   Returns the item name in the form of a BSTR.

 *****************************************************************************/

BSTR
CImage::bstrItemName()
{
    DBG_FN("CImage::bstrItemName");

    return m_bstrItemName;
}


/*****************************************************************************

   CImage::bstrFullItemName

   Returns the full item name in the form of a BSTR.

 *****************************************************************************/

BSTR
CImage::bstrFullItemName()
{
    DBG_FN("CImage::bstrFullItemName");

    return m_bstrFullItemName;
}



/*****************************************************************************

   CImage::ThumbWidth

   returns the thumbnail width

 *****************************************************************************/

LONG
CImage::ThumbWidth()
{
    DBG_FN("CImage::ThumbWidth");

    return THUMB_WIDTH;
}



/*****************************************************************************

   CImage::ThumbHeight

   returns the thumbnail height

 *****************************************************************************/

LONG
CImage::ThumbHeight()
{
    DBG_FN("CImage::ThumbHeight");

    return THUMB_HEIGHT;
}


/*****************************************************************************

   CImage::ImageTimeStamp

   returns creation time of image

 *****************************************************************************/

void
CImage::GetImageTimeStamp(SYSTEMTIME * pst)
{
    DBG_FN("CImage::ImageTimeStamp");

    if (!m_bImageTimeValid)
    {
        HANDLE hFile = CreateFile(m_strPathItem,
                                  GENERIC_READ,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            FILETIME ft;

            if (GetFileTime( hFile, &ft, NULL, NULL ))
            {
                FILETIME ftLocal;

                if (FileTimeToLocalFileTime(&ft, &ftLocal))
                {
                    if (FileTimeToSystemTime( &ftLocal, &m_ImageTime ))
                    {

                        m_bImageTimeValid = TRUE;
                    }

                }

            }

            CloseHandle( hFile );
        }
        else
        {
            DBG_ERR(("CreateFile( %ls ) failed, GLE = %d",
                     m_strPathItem.String(), GetLastError()));

            //
            // default to filling in structure w/zeros
            //

            memset( pst, 0, sizeof(SYSTEMTIME) );
        }
    }

    if (m_bImageTimeValid && pst)
    {
        *pst = m_ImageTime;
    }
}



/*****************************************************************************

   CImage::ActualImagePath

   Returns filename path of actual image

 *****************************************************************************/

LPCTSTR
CImage::ActualImagePath()
{
    DBG_FN("CImage::ActualImagePath");

    return m_strPathItem.String();
}



/*****************************************************************************

   CImage::DoDelete

   Deletes the file (and thumbail) from the disk.

 *****************************************************************************/

HRESULT
CImage::DoDelete()
{
    HRESULT hr = S_OK;
    BOOL    bResFile;

    DBG_FN("CImage::DoDelete");

    //
    // Make sure we have a file to delete...
    //

    if (!m_strPathItem.Length())
    {
        DBG_ERR(("filename for item is zero length!"));
        hr = E_INVALIDARG;
    }
    else
    {
        //
        // We've got an item, so delete it and the thumbnail file
        //

        bResFile = DeleteFile(m_strPathItem.String());

        if (!bResFile)
        {
            DBG_ERR(("DeleteFile( %ls ) failed, GLE = %d",
                     m_strPathItem.String(),GetLastError()));
        }

        if (bResFile)
        {
            m_strPathItem           = NULL;
            m_strRootPath           = NULL;
            m_strName               = NULL;
            m_bstrRootFullItemName  = NULL;
            m_bstrFullItemName      = NULL;
            m_bImageTimeValid       = FALSE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

    }

    CHECK_S_OK(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\usd\minidrv.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998 - 2000
 *
 *  TITLE:       minidrv.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        9/9/99
 *
 *  DESCRIPTION: This module implements IWiaMiniDrv for this device.
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#include "wiamindr_i.c"
#include <sddl.h>
#include <shlobj.h>

///////////////////////////////
// Constants
//
const TCHAR* EVENT_PREFIX_GLOBAL        = TEXT("Global\\");
const TCHAR* EVENT_SUFFIX_TAKE_PICTURE  = TEXT("_TAKE_PICTURE");
const TCHAR* EVENT_SUFFIX_PICTURE_READY = TEXT("_PICTURE_READY");
const UINT   TAKE_PICTURE_TIMEOUT       = 1000 * 15;  // 15 seconds
//const UINT   DEFAULT_LOCK_TIMEOUT       = 1000 * 2;  // 2 seconds

// This is the Security Descriptor Language
// - Each ACE (access control entry) is represented in by parentheses.
// - A      = Allow ACE (as opposed to a Deny ACE)
// - OICI   = Allow Object Inheritance and Container Inheritence
// - GA     = Generic All Access (Full Control)
// - SY     = System account (SID)
// - BA     = Builtin Administrators Group
// - CO     = Creator/Owner
// - GR     = Generic Read
// - GW     = Generic Write
// - GX     = Generic Execute.
// - IU     = Interactive Users (User's logged on at the computer)
//
// More info, go to http://msdn.microsoft.com/library/psdk/winbase/accctrl_2n1v.htm
//
//
//                                                   
const TCHAR *OBJECT_DACLS= TEXT("D:(A;OICI;GA;;;SY)")                   // SYSTEM
                             TEXT("(A;OICI;GA;;;BA)")                   // Admin
                             TEXT("(A;OICI;GRGWGXDTSDCCLC;;;WD)")       // Everyone
                             TEXT("(A;OICI;GRGWGXDTSDCCLC;;;PU)")       // Power Users
                             TEXT("(A;OICI;GRGWGXDTSDCCLC;;;BU)");      // Users




/*****************************************************************************

   DirectoryExists

   Checks to see whether the given fully qualified directory exists.

 *****************************************************************************/

BOOL DirectoryExists(LPCTSTR pszDirectoryName)
{
    BOOL bExists = FALSE;

    //
    // Try to determine if this directory exists
    //

    if (pszDirectoryName)
    {
        DWORD dwFileAttributes = GetFileAttributes(pszDirectoryName);
    
        if (dwFileAttributes == 0xFFFFFFFF || 
            !(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            bExists = FALSE;
        }
        else
        {
            bExists = TRUE;
        }
    }
    else
    {
        bExists = FALSE;
    }

    return bExists;
}


/*****************************************************************************

   RecursiveCreateDirectory

   Take a fully qualified path and create the directory in pieces as needed.

 *****************************************************************************/

BOOL RecursiveCreateDirectory(CSimpleString *pstrDirectoryName)
{
    ASSERT(pstrDirectoryName != NULL);

    //
    // If this directory already exists, return true.
    //

    if (DirectoryExists(*pstrDirectoryName))
    {
        return TRUE;
    }

    //
    // Otherwise try to create it.
    //

    CreateDirectory(*pstrDirectoryName, NULL );

    //
    // If it now exists, return true
    //

    if (DirectoryExists(*pstrDirectoryName))
    {
        return TRUE;
    }
    else
    {
        //
        // Remove the last subdir and try again
        //

        int nFind = pstrDirectoryName->ReverseFind(TEXT('\\'));
        if (nFind >= 0)
        {
            RecursiveCreateDirectory(&(pstrDirectoryName->Left(nFind)));

            //
            // Now try to create it.
            //

            CreateDirectory(*pstrDirectoryName, NULL);
        }
    }

    //
    //Does it exist now?
    //

    return DirectoryExists(*pstrDirectoryName);
}

///////////////////////////////
// SetDirectorySecurity
//
HRESULT SetDirectorySecurity(CSimpleString *pstrDirectoryName)
{
    HRESULT             hr       = S_OK;
    BOOL                bSuccess = TRUE;
    SECURITY_ATTRIBUTES SA;

    SA.nLength = sizeof(SECURITY_ATTRIBUTES);
    SA.bInheritHandle = TRUE;

    if (ConvertStringSecurityDescriptorToSecurityDescriptor(
            OBJECT_DACLS,
            SDDL_REVISION_1, 
            &(SA.lpSecurityDescriptor), 
            NULL)) 
    {
        bSuccess = SetFileSecurity(*pstrDirectoryName, 
                                   DACL_SECURITY_INFORMATION, 
                                   SA.lpSecurityDescriptor);

        if (!bSuccess)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        if (SA.lpSecurityDescriptor)
        {
            LocalFree(SA.lpSecurityDescriptor);
        }
    } 
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvInitializeWia [IWiaMiniDrv]

   WIA calls this method to ask us to do the following:

       * Initialize our mini driver.
       * Setup our optional private interface(s).
       * Build our device item tree.

   During initializiation we:

       * Cache the STI device pointer for locking.
       * Cache the device ID and root item full item name.
       * Initialize and hook up the DirectShow stream.


 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvInitializeWia( BYTE            *pWiasContext,
                                LONG            lFlags,
                                BSTR            bstrDeviceID,
                                BSTR            bstrRootFullItemName,
                                IUnknown        *pStiDevice,
                                IUnknown        *pIUnknownOuter,
                                IWiaDrvItem     **ppIDrvItemRoot,
                                IUnknown        **ppIUnknownInner,
                                LONG            *plDevErrVal
                               )
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvInitializeWia");

    //
    // Initialize return values
    //

    if (ppIDrvItemRoot)
    {
        *ppIDrvItemRoot = NULL;
    }

    if (ppIUnknownInner)
    {
        *ppIUnknownInner = NULL;
    }

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    //
    // Enter the critical section.
    //
    EnterCriticalSection(&m_csItemTree);

    m_dwConnectedApps++;

    DBG_TRC(("CVideoStiUsd::drvInitializeWia - Initializing Video Driver, "
             "Num Connected Apps = '%lu', device id = '%ws', Root Item Name = '%ws'", 
             m_dwConnectedApps,
             bstrDeviceID, 
             bstrRootFullItemName));

    if (m_dwConnectedApps == 1)
    {
        //
        // Cache what we need to
        //
    
        if (pStiDevice)
        {
            pStiDevice->QueryInterface( IID_IStiDevice, (void **)&m_pStiDevice );
        }
    
        m_strDeviceId.Assign(CSimpleStringWide(bstrDeviceID));
        m_strRootFullItemName.Assign(CSimpleStringWide(bstrRootFullItemName));
    
        //
        // Set the images directory.  The first param is NULL, which indicates 
        // that a default directory should be set.
        //
        if (hr == S_OK)
        {
            hr = SetImagesDirectory(NULL,
                                    pWiasContext,
                                    &m_pRootItem,
                                    plDevErrVal);
        }

        //
        // Enable the take picture event so that an app can send this driver
        // the take picture command, and this driver can signal the appliation
        // that owns wiavideo to take the picture.
        //
        if (hr == S_OK)
        {
            EnableTakePicture(pWiasContext);
        }
    }
    else
    {
        RefreshTree(m_pRootItem, plDevErrVal);
    }

    if (ppIDrvItemRoot)
    {
        *ppIDrvItemRoot = m_pRootItem;
    }

    //
    // Leave the critical section
    //
    LeaveCriticalSection(&m_csItemTree);

    CHECK_S_OK(hr);
    return hr;
}

/**************************************************************************\

 CVideoStiUsd::drvUnInitializeWia [IWiaMiniDrv]

   Gets called when a client connection is going away.
   WIA calls this method to ask us to do the following:

       * Cleanup any resources that are releated to this client connection
         (identified by pWiasContext)

 *************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvUnInitializeWia(BYTE *pWiasContext)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvUnInitializeWia");

    EnterCriticalSection(&m_csItemTree);

    if (m_dwConnectedApps > 0)
    {
        m_dwConnectedApps--;
    }

    DBG_TRC(("CVideoStiUsd::drvUnInitializeWia, Num Connected Apps = '%lu'",
             m_dwConnectedApps));

    if ((m_dwConnectedApps == 0) && (m_pRootItem))
    {
        DisableTakePicture(pWiasContext, TRUE);

        DBG_TRC(("CVideoStiUsd::drvUnInitializeWia, no more connected apps, deleting tree"));

        hr = m_pRootItem->UnlinkItemTree(WiaItemTypeDisconnected);
        CHECK_S_OK2(hr,("m_pRootItem->UnlinkItemTree()"));

        // Clear the root item
        m_pRootItem = NULL;

        // Clear the pointer to the STI device we received
        m_pStiDevice = NULL;

        // reset the num pictures taken to 0.
        m_lPicsTaken = 0;
    }

    LeaveCriticalSection(&m_csItemTree);

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvGetDeviceErrorStr [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvGetDeviceErrorStr(LONG        lFlags,
                                   LONG        lDevErrVal,
                                   LPOLESTR *  ppszDevErrStr,
                                   LONG *      plDevErr)
{
    HRESULT hr = E_NOTIMPL;

    DBG_FN("CVideoStiUsd::drvGetDeviceErrorStr");

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvDeviceCommand [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvDeviceCommand(BYTE *          pWiasContext,
                               LONG            lFlags,
                               const GUID *    pGUIDCommand,
                               IWiaDrvItem **  ppMiniDrvItem,
                               LONG *          plDevErrVal)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvDeviceCommand");

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    //
    // We support "Take snapshot" 
    //

    if (*pGUIDCommand == WIA_CMD_TAKE_PICTURE)
    {
        DBG_TRC(("CVideoStiUsd::drvDeviceCommand received command "
                 "WIA_CMD_TAKE_PICTURE"));

        //
        // Take a picture
        //
        hr = TakePicture(pWiasContext, ppMiniDrvItem);
    }
    else if (*pGUIDCommand == WIA_CMD_ENABLE_TAKE_PICTURE)
    {
        //
        // This command doesn't do anything.  However WiaVideo still expects
        // it to succeed, so if you remove this, remove the call from WiaVideo too.
        //
        DBG_TRC(("CVideoStiUsd::drvDeviceCommand received command "
                 "WIA_CMD_ENABLE_TAKE_PICTURE"));

        hr = S_OK;
    }
    else if (*pGUIDCommand == WIA_CMD_DISABLE_TAKE_PICTURE)
    {
        //
        // This command doesn't do anything.  However WiaVideo still expects
        // it to succeed, so if you remove this, remove the call from WiaVideo too.
        //

        DBG_TRC(("CVideoStiUsd::drvDeviceCommand received command "
                 "WIA_CMD_DISABLE_TAKE_PICTURE"));

        hr = S_OK;
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CVideoStiUsd::ValidateDataTransferContext

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::ValidateDataTransferContext(
                               PMINIDRV_TRANSFER_CONTEXT pDataTransferContext)
{
    DBG_FN("CVideoStiUsd::ValidateDataTransferContext");

    if (pDataTransferContext->lSize != sizeof(MINIDRV_TRANSFER_CONTEXT))
    {
        DBG_ERR(("invalid data transfer context -- wrong lSize"));
        return E_INVALIDARG;;
    }

    //
    // for tymed file or hglobal, only WiaImgFmt_BMP || WiaImgFmt_JPEG 
    // is allowed
    //

    if ((pDataTransferContext->tymed == TYMED_FILE) ||
        (pDataTransferContext->tymed == TYMED_HGLOBAL)
       )
    {
  
        if ((pDataTransferContext->guidFormatID != WiaImgFmt_BMP) &&
            (pDataTransferContext->guidFormatID != WiaImgFmt_JPEG))
        {
           DBG_ERR(("invalid format -- asked for TYMED_FILE or TYMED_HGLOBAL "
                    "but guidFormatID != (WiaImgFmt_BMP | WiaImgFmt_JPEG)"));

           return E_INVALIDARG;;
        }
  
    }

    //
    // for tymed CALLBACK, only WiaImgFmt_MEMORYBMP, WiaImgFmt_BMP and 
    // WiaImgFmt_JPEG are allowed
    //

    if (pDataTransferContext->tymed == TYMED_CALLBACK)
    {
        if ((pDataTransferContext->guidFormatID != WiaImgFmt_BMP) &&
            (pDataTransferContext->guidFormatID != WiaImgFmt_MEMORYBMP) &&
            (pDataTransferContext->guidFormatID != WiaImgFmt_JPEG))
        {
           DBG_ERR(("invalid format -- asked for TYMED_CALLBACK but "
                    "guidFormatID != (WiaImgFmt_BMP | WiaImgFmt_MEMORYBMP "
                    "| WiaImgFmt_JPEG)"));

           return E_INVALIDARG;;
        }
    } 


    //
    // callback is always double buffered, non-callback never is
    //

    if (pDataTransferContext->pTransferBuffer == NULL)
    {
        DBG_ERR(("invalid transfer context -- pTransferBuffer is NULL!"));
        return E_INVALIDARG;
    } 

    return S_OK;
}



/*****************************************************************************

   CVideoStiUsd::SendBitmapHeader

   Sends bitmap header during banded transfer

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::SendBitmapHeader(IWiaDrvItem *               pDrvItem,
                               PMINIDRV_TRANSFER_CONTEXT   pTranCtx)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::SendBitmapHeader");

    //
    // driver is sending TOPDOWN data, must swap biHeight
    //
    // this routine assumes pTranCtx->pHeader points to a
    // BITMAPINFO header (TYMED_FILE doesn't use this path
    // and DIB is the only format supported now)
    //

    PBITMAPINFO pbmi = (PBITMAPINFO)pTranCtx->pTransferBuffer;

    if (pTranCtx->guidFormatID == WiaImgFmt_MEMORYBMP)
    {
        pbmi->bmiHeader.biHeight = -pbmi->bmiHeader.biHeight;
    }

    hr = pTranCtx->pIWiaMiniDrvCallBack->MiniDrvCallback(
                                            IT_MSG_DATA,
                                            IT_STATUS_TRANSFER_TO_CLIENT,
                                            0,
                                            0,
                                            pTranCtx->lHeaderSize,
                                            pTranCtx,
                                            0);

    if (hr == S_OK) 
    {
        //
        // advance offset for destination copy
        //

        pTranCtx->cbOffset += pTranCtx->lHeaderSize;

    }

    CHECK_S_OK(hr);
    return hr;
}



/*****************************************************************************

   CVideoStiUsd::drvAquireItemData [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvAcquireItemData(BYTE *                    pWiasContext,
                                 LONG                      lFlags,
                                 PMINIDRV_TRANSFER_CONTEXT pDataContext,
                                 LONG *                    plDevErrVal)
{
    HRESULT hr = E_NOTIMPL;

    DBG_FN("CVideoStiUsd::drvAcquireItemData");

    *plDevErrVal = 0;

    //
    // Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);

    if (FAILED(hr))
    {
        CHECK_S_OK2(hr, ("wiaGetDrvItem Failed"));
        return hr;
    }

    //
    // Validate the data transfer context.
    //

    hr = ValidateDataTransferContext( pDataContext );

    if (FAILED(hr))
    {
        CHECK_S_OK2(hr, ("ValidateTransferContext failed"));
        return hr;
    }

#ifdef DEBUG
    //
    // Dump the request
    //

    DBG_TRC(("Asking for TYMED of 0x%x", pDataContext->tymed));

    if (pDataContext->guidFormatID == WiaImgFmt_BMP)
    {
        DBG_TRC(("Asking for WiaImgFmt_BMP"));
    }
    else if (pDataContext->guidFormatID == WiaImgFmt_MEMORYBMP)
    {
        DBG_TRC(("Asking for WiaImgFmt_MEMORYBMP"));
    }
    else if (pDataContext->guidFormatID == WiaImgFmt_JPEG)
    {
        DBG_TRC(("Asking for WiaImgFmt_JPEG"));
    }
#endif

    //
    // get item specific driver data
    //

    STILLCAM_IMAGE_CONTEXT  *pContext;

    pDrvItem->GetDeviceSpecContext((BYTE **)&pContext);

    if (!pContext)
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("drvAcquireItemData, NULL item context"));
        return hr;
    }

    //
    // Use our internal routines to get format specific info...
    //

    if (pContext->pImage)
    {
        hr = pContext->pImage->SetItemSize( pWiasContext, pDataContext );
        CHECK_S_OK2(hr, ("pContext->pImage->SetItemSize()"));
    }
    else
    {
        DBG_ERR(("Couldn't use our internal routines to compute image "
                 "information, this is bad!"));

        //
        // As a last resort, use WIA services to fetch format specific info.
        //

        hr = wiasGetImageInformation(pWiasContext,
                                     0,
                                     pDataContext);

        CHECK_S_OK2(hr,("wiaGetImageInformation()"));
    }


    if (FAILED(hr))
    {
        CHECK_S_OK2(hr, ("wiasGetImageInformation failed"));
        return hr;
    }

    //
    // determine if this is a callback or buffered transfer
    //

    if (pDataContext->tymed == TYMED_CALLBACK)
    {
        DBG_TRC(("Caller wants callback"));

        //
        // For formats that have a data header, send it to the client
        //

        if (pDataContext->lHeaderSize > 0)
        {
            DBG_TRC(("Sending Bitmap Header..."));
            hr = SendBitmapHeader( pDrvItem, pDataContext );

            CHECK_S_OK2(hr,("SendBitmapHeader( pDrvItem, pDataContext )"));
        }

        if (hr == S_OK)
        {
            DBG_TRC(("Calling LoadImageCB..."));
            hr = LoadImageCB( pContext, pDataContext, plDevErrVal );
            CHECK_S_OK2(hr, ("LoadImageCB( pContext, pDataContext, "
                             "plDevErrVal"));
        }
    } 
    else 
    {
        DBG_TRC(("Caller doesn't want callback"));

        //
        // inc past header
        //

        pDataContext->cbOffset += pDataContext->lHeaderSize;

        DBG_TRC(("Calling LoadImage..."));
        hr = LoadImage( pContext, pDataContext, plDevErrVal );
        CHECK_S_OK2(hr, ("LoadImage( pContext, pDataContext, "
                         "plDevErrVal )"));
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvInitItemProperties [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvInitItemProperties(BYTE * pWiasContext,
                                    LONG   lFlags,
                                    LONG * plDevErrVal)
{
    DBG_FN("CVideoStiUsd::drvInitItemProperties");

    HRESULT                  hr = S_OK;
    LONG                     lItemType;
    PSTILLCAM_IMAGE_CONTEXT  pContext;
    IWiaDrvItem *            pDrvItem;  // This is not a CComPtr because there
                                        // is no addref for us to release
    //
    // This device doesn't touch hardware to initialize the
    // device item properties.
    //

    *plDevErrVal = 0;

    //
    // Parameter validation.
    //

    if (!pWiasContext)
    {
        DBG_ERR(("drvInitItemProperties, invalid input pointers"));
        return E_INVALIDARG;
    }

    //
    // Get a pointer to the associated driver item.
    //

    if (hr == S_OK)
    {
        hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
        CHECK_S_OK2(hr,("wiaGetDrvItem"));
    }

    if (hr == S_OK)
    {
        //
        // Root item has the all the device properties
        //
    
        hr = pDrvItem->GetItemFlags(&lItemType);
        CHECK_S_OK2(hr,("pDrvItem->GetItemFlags"));
    }

    if (hr == S_OK)
    {
        if (lItemType & WiaItemTypeRoot) 
        {
            //
            // Root item property init finishes here
            //
    
            hr = InitDeviceProperties( pWiasContext, plDevErrVal );
            CHECK_S_OK2(hr,("InitDeviceProperties for root item"));

        }
        else if (lItemType & WiaItemTypeFile)
        {
            //
            // If this is a file, init the properties
            //
    
            //
            // Add the item property names.
            //
    
            if (hr == S_OK)
            {
                hr = wiasSetItemPropNames(pWiasContext,
                                          NUM_CAM_ITEM_PROPS,
                                          gItemPropIDs,
                                          gItemPropNames);

                CHECK_S_OK2(hr,("wiaSetItemPropNames for item"));
            }

            if (hr == S_OK)
            {
                //
                // Use WIA services to set the default item properties.
                //
        
                hr = wiasWriteMultiple(pWiasContext,
                                       NUM_CAM_ITEM_PROPS,
                                       gPropSpecDefaults,
                                       (PROPVARIANT*)gPropVarDefaults);

                CHECK_S_OK2(hr,("wiaWriteMultiple for item props"));
            }
            
            if (hr == S_OK)
            {
                hr = pDrvItem->GetDeviceSpecContext( (BYTE **)&pContext );
                CHECK_S_OK2(hr,("GetDeviceSpecContext"));
            }

            if (hr == S_OK)
            {
                hr = InitImageInformation(pWiasContext, pContext, plDevErrVal);
                CHECK_S_OK2(hr,("InitImageInformation"));
            }
        }
    }

    return hr;
}

/*****************************************************************************

   CVideoStiUsd::ValidateItemProperties

   <Notes>

 *****************************************************************************/
HRESULT
CVideoStiUsd::ValidateItemProperties(BYTE               *pWiasContext,
                                     LONG               lFlags,
                                     ULONG              nPropSpec,
                                     const PROPSPEC     *pPropSpec,
                                     LONG               *plDevErrVal,
                                     IWiaDrvItem        *pDrvItem)
{
    DBG_FN("CVideoStiUsd::ValidateFileProperties");

    HRESULT hr = S_OK;

    if ((pWiasContext == NULL) || 
        (pPropSpec    == NULL))
    {
        hr = E_INVALIDARG;

        CHECK_S_OK2(hr, ("CVideoStiUsd::ValidateItemProperties received "
                         "NULL params"));
        return hr;
    }

    STILLCAM_IMAGE_CONTEXT  *pContext = NULL;

    hr = pDrvItem->GetDeviceSpecContext( (BYTE **)&pContext);

    CHECK_S_OK2(hr,("CVideoStiUsd::ValidateItemProperties, "
                    "GetDeviceSpecContext failed"));

    if (SUCCEEDED(hr) && pContext)
    {
        CImage * pImage = pContext->pImage;

        if (pImage)
        {
            //
            // calc item size
            //

            hr = pImage->SetItemSize( pWiasContext, NULL );
            CHECK_S_OK2(hr,("SetItemSize( pWiasContext )"));
        }


        //
        //  Change MinBufferSize property.  Need to get Tymed and
        //  ItemSize first, since MinBufferSize in dependant on these
        //  properties.
        //

        LONG        lTymed;
        LONG        lItemSize;
        LONG        lMinBufSize = 0;

        hr = wiasReadPropLong(pWiasContext, 
                              WIA_IPA_TYMED, 
                              &lTymed, 
                              NULL, 
                              TRUE);

        CHECK_S_OK2(hr, ("wiasReadPropLong( WIA_IPA_TYPMED )"));

        if (SUCCEEDED(hr))
        {
            hr = wiasReadPropLong(pWiasContext, 
                                  WIA_IPA_ITEM_SIZE, 
                                  &lItemSize, 
                                  NULL, 
                                  TRUE);

            CHECK_S_OK2(hr,("wiasReadPropLong( WIA_IPA_ITEM_SIZE )"));

            if (SUCCEEDED(hr))
            {
                //
                //  Update the MinBufferSize property.
                //

                switch (lTymed)
                {
                    case TYMED_CALLBACK:
                        lMinBufSize = 65535;
                    break;

                    default:
                        lMinBufSize = lItemSize;
                    break;
                }

                if (lMinBufSize)
                {
                    hr = wiasWritePropLong(pWiasContext, 
                                           WIA_IPA_MIN_BUFFER_SIZE, 
                                           lMinBufSize);

                    CHECK_S_OK2(hr, ("wiasWritePropLong( "
                                     "WIA_IPA_MIN_BUFFER_SIZE )"));
                }

                DBG_TRC(("WIA_IPA_MIN_BUFFER_SIZE set to %d bytes",
                         lMinBufSize));
            }
        }
    }

    return hr;
}

/*****************************************************************************

   CVideoStiUsd::ValidateDeviceProperties

   <Notes>

 *****************************************************************************/
HRESULT
CVideoStiUsd::ValidateDeviceProperties(BYTE             *pWiasContext,
                                       LONG             lFlags,
                                       ULONG            nPropSpec,
                                       const PROPSPEC   *pPropSpec,
                                       LONG             *plDevErrVal,
                                       IWiaDrvItem      *pDrvItem)
{
    DBG_FN("CVideoStiUsd::ValidateRootProperties");

    HRESULT hr = S_OK;

    //
    // Parameter validation.
    //

    if ((pWiasContext == NULL) || 
        (pPropSpec    == NULL))
    {
        hr = E_INVALIDARG;

        CHECK_S_OK2(hr, ("CVideoStiUsd::ValidateDeviceProperties received "
                         "NULL params"));
        return hr;
    }

    for (ULONG i = 0; i < nPropSpec; i++)
    {
        if ((pPropSpec[i].ulKind == PRSPEC_PROPID) &&
            (pPropSpec[i].propid == WIA_DPV_LAST_PICTURE_TAKEN))
        {
            DBG_TRC(("CVideoStiUsd::ValidateDeviceProperties, setting the "
                     "WIA_DPV_LAST_PICTURE_TAKEN property."));

            EnterCriticalSection(&m_csItemTree);

            //
            // process the last picture taken property change.
            //
    
            BSTR bstrLastPictureTaken = NULL;
    
            //
            // Read in the value for last picture taken.
            //
            hr = wiasReadPropStr(pWiasContext, 
                                 WIA_DPV_LAST_PICTURE_TAKEN, 
                                 &bstrLastPictureTaken, 
                                 NULL, 
                                 TRUE);
    
            if (hr == S_OK)
            {
                m_strLastPictureTaken = bstrLastPictureTaken;

                DBG_TRC(("CVideoStiUsd::ValidateDeviceProperties, last picture "
                         "taken = '%ls'", m_strLastPictureTaken.String()));

                //
                // This will add the new item to the tree and queue an 
                // ITEM_CREATED event
                // 
                hr = SignalNewImage(bstrLastPictureTaken);
            }

            // reset the last picture taken value.  This is needed because the
            // service checks to see if the new value being set is the same as 
            // the current value, and if it is, it doesn't forward it on to us.
            // This is bad in the event of the Scanner and Camera wizard, where
            // it takes 1 picture, (so LAST_PICTURE_TAKEN has a value of "Picture 1"),
            // then deletes it, then user backs up the wizard, and takes a picture
            // again.  This new picture will have a value of "Picture 1" but we won't
            // add it to the tree because the value of the property hasn't changed
            // as far as the wia service is concerned.
            //
            if (hr == S_OK)
            {
                //
                // Write the Last Picture Taken
                //
                hr = wiasWritePropStr(pWiasContext, 
                                      WIA_DPV_LAST_PICTURE_TAKEN, 
                                      CSimpleBStr(TEXT("")));

            }
    
            //
            // Free the BSTR
            //
            if (bstrLastPictureTaken)
            {
                ::SysFreeString(bstrLastPictureTaken);
                bstrLastPictureTaken = NULL;
            }

            LeaveCriticalSection(&m_csItemTree);
        }
        else if ((pPropSpec[i].ulKind == PRSPEC_PROPID) &&
                 (pPropSpec[i].propid == WIA_DPV_IMAGES_DIRECTORY))
        {
            //
            // DPV_IMAGES_DIRECTORY - 
            //
    
            hr = E_FAIL;
            CHECK_S_OK2(hr, ("CVideoStiUsd::ValidateRootProperties, "
                             "attempting to validate the Images Directory "
                             "property, but this is a read-only "
                             "property"));
        }
        else if ((pPropSpec[i].ulKind == PRSPEC_PROPID) &&
                 (pPropSpec[i].propid == WIA_DPV_DSHOW_DEVICE_PATH))
        {
            //
            // process the DShowDeviceID change.
            //
    
            hr = E_FAIL;
            CHECK_S_OK2(hr, ("CVideoStiUsd::ValidateRootProperties, "
                             "attempting to validate the DShow Device "
                             "ID property, but this is a read-only "
                             "property"));
        }
    }

    return hr;
}

/*****************************************************************************

   CVideoStiUsd::drvValidateItemProperties [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/
STDMETHODIMP
CVideoStiUsd::drvValidateItemProperties(BYTE           *pWiasContext,
                                        LONG           lFlags,
                                        ULONG          nPropSpec,
                                        const PROPSPEC *pPropSpec,
                                        LONG           *plDevErrVal)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvValidateItemProperties");

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    //
    // Parameter validation.
    //

    if ((pWiasContext == NULL) || 
        (pPropSpec    == NULL))
    {
        hr = E_INVALIDARG;

        CHECK_S_OK2(hr, ("CVideoStiUsd::drvValidateItemProperties received "
                         "NULL params"));
        return hr;
    }

    //
    // Get item in question
    //

    //
    // not a CComPtr because there isn't an extra ref
    // on this guy from the caller
    //
    IWiaDrvItem* pDrvItem = NULL;  
                                   

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);

    CHECK_S_OK2(hr,("wiasGetDrvItem( pWiasContext, &pDrvItem )"));

    if (SUCCEEDED(hr))
    {
        LONG lItemType = 0;

        //
        // What kind of item is this?
        //

        hr = pDrvItem->GetItemFlags(&lItemType);
        CHECK_S_OK2(hr,("pDrvItem->GetItemFlags( &lItemType )"));

        if (SUCCEEDED(hr))
        {
            if (lItemType & WiaItemTypeFile)
            {
                hr = ValidateItemProperties(pWiasContext, 
                                            lFlags,
                                            nPropSpec,
                                            pPropSpec,
                                            plDevErrVal,
                                            pDrvItem);
            }
            else if (lItemType & WiaItemTypeRoot)
            {
                hr = ValidateDeviceProperties(pWiasContext, 
                                              lFlags,
                                              nPropSpec,
                                              pPropSpec,
                                              plDevErrVal,
                                              pDrvItem);
            }
        }
    }

    CHECK_S_OK(hr);

    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvWriteItemProperties [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvWriteItemProperties(BYTE *                    pWiasContext,
                                     LONG                      lFLags,
                                     PMINIDRV_TRANSFER_CONTEXT pmdtc,
                                     LONG *                    plDevErrVal)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvWriteItemProperties");

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    CHECK_S_OK(hr);
    return hr;
}

/*****************************************************************************

   CVideoStiUsd::ReadItemProperties

   We only support reading thumbnails on demand for items

 *****************************************************************************/

HRESULT
CVideoStiUsd::ReadItemProperties(BYTE           *pWiasContext,
                                 LONG           lFlags,
                                 ULONG          nPropSpec,
                                 const PROPSPEC *pPropSpec,
                                 LONG           *plDevErrVal,
                                 IWiaDrvItem    *pDrvItem)
{
    HRESULT                 hr        = S_OK;
    STILLCAM_IMAGE_CONTEXT  *pContext = NULL;

    if ((pPropSpec == NULL) ||
        (pDrvItem  == NULL))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::ReadItemProperties received a "
                         "NULL param"));
        return hr;
    }

    //
    // It's an item, now loop through the requested properties
    // and see if they're looking for the Thumbnail
    //

    for (ULONG i = 0; i < nPropSpec; i++)
    {
        if (((pPropSpec[i].ulKind == PRSPEC_PROPID) && 
             (pPropSpec[i].propid == WIA_IPC_THUMBNAIL)) ||
            ((pPropSpec[i].ulKind == PRSPEC_LPWSTR) && 
             (wcscmp(pPropSpec[i].lpwstr, WIA_IPC_THUMBNAIL_STR) == 0)))
        {
            //
            // They'd like the thumbnail
            //

            hr = pDrvItem->GetDeviceSpecContext((BYTE **)&pContext);
            CHECK_S_OK2(hr,("pDrvItem->GetDeviceSpecContext()"));

            if (SUCCEEDED(hr) && pContext)
            {
                if (pContext->pImage)
                {
                    //
                    // Use our internal routines to load the thumbnail...
                    //

                    hr = pContext->pImage->LoadThumbnail(pWiasContext);
                    break;
                }
                else
                {
                    DBG_ERR(("pContext->pImage was NULL!"));
                }
            }
            else
            {
                DBG_ERR(("Couldn't get pContext"));
            }
        }
    }

    return hr;
}

/*****************************************************************************

   CVideoStiUsd::ReadDeviceProperties

   We support all our custom properties

 *****************************************************************************/

HRESULT
CVideoStiUsd::ReadDeviceProperties(BYTE             *pWiasContext,
                                   LONG             lFlags,
                                   ULONG            nPropSpec,
                                   const PROPSPEC   *pPropSpec,
                                   LONG             *plDevErrVal,
                                   IWiaDrvItem      *pDrvItem)
{
    HRESULT hr = S_OK;

    if ((pPropSpec == NULL) ||
        (pDrvItem  == NULL))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::ReadItemProperties received a "
                         "NULL param"));
        return hr;
    }

    for (ULONG i = 0; i < nPropSpec; i++)
    {
        if (((pPropSpec[i].ulKind == PRSPEC_PROPID) && 
             (pPropSpec[i].propid == WIA_DPC_PICTURES_TAKEN)) ||
            ((pPropSpec[i].ulKind == PRSPEC_LPWSTR) && 
             (!wcscmp(pPropSpec[i].lpwstr, WIA_DPC_PICTURES_TAKEN_STR))))
        {
            //
            // Requesting the number of pictures taken.
            //

            DBG_TRC(("CVideoStiUsd::ReadDeviceProperties, reading propID "
                     "'%lu' (0x%08lx) WIA_DPC_PICTURES_TAKEN = '%lu'", 
                     pPropSpec[i].propid, 
                     pPropSpec[i].propid, 
                     m_lPicsTaken));

            wiasWritePropLong(pWiasContext, 
                              WIA_DPC_PICTURES_TAKEN, 
                              m_lPicsTaken);

        }
        else if (((pPropSpec[i].ulKind == PRSPEC_PROPID) && 
                  (pPropSpec[i].propid == WIA_DPV_DSHOW_DEVICE_PATH)) ||
                 ((pPropSpec[i].ulKind == PRSPEC_LPWSTR) && 
                  (!wcscmp(pPropSpec[i].lpwstr, WIA_DPV_DSHOW_DEVICE_PATH_STR))))
        {
            //
            // Requesting the DShow Device ID.
            //

            DBG_TRC(("CVideoStiUsd::ReadDeviceProperties, reading propID "
                     "'%lu' (0x%08lx) WIA_DPV_DSHOW_DEVICE_PATH = '%ls'", 
                     pPropSpec[i].propid, 
                     pPropSpec[i].propid, 
                     m_strDShowDeviceId.String()));
            
            wiasWritePropStr(pWiasContext, 
                             WIA_DPV_DSHOW_DEVICE_PATH, 
                             CSimpleBStr(m_strDShowDeviceId).BString());

        }
        else if (((pPropSpec[i].ulKind == PRSPEC_PROPID) && 
                  (pPropSpec[i].propid == WIA_DPV_IMAGES_DIRECTORY)) ||
                 ((pPropSpec[i].ulKind == PRSPEC_LPWSTR) && 
                  (!wcscmp(pPropSpec[i].lpwstr, WIA_DPV_IMAGES_DIRECTORY_STR))))
        {
            //
            // Requesting the Images Directory.
            //

            DBG_TRC(("CVideoStiUsd::ReadDeviceProperties, reading propID "
                     "'%lu' (0x%08lx) WIA_DPV_IMAGES_DIRECTORY = '%ls'", 
                     pPropSpec[i].propid, 
                     pPropSpec[i].propid, 
                     m_strStillPath.String()));

            wiasWritePropStr(pWiasContext, 
                             WIA_DPV_IMAGES_DIRECTORY, 
                             CSimpleBStr(m_strStillPath).BString());
        }
        else if (((pPropSpec[i].ulKind == PRSPEC_PROPID) && 
                  (pPropSpec[i].propid == WIA_DPV_LAST_PICTURE_TAKEN)) ||
                 ((pPropSpec[i].ulKind == PRSPEC_LPWSTR) && 
                  (!wcscmp(pPropSpec[i].lpwstr, WIA_DPV_LAST_PICTURE_TAKEN_STR))))
        {
            //
            // Requesting the last picture taken
            //

            DBG_TRC(("CVideoStiUsd::ReadDeviceProperties, reading propID "
                     "'%lu' (0x%08lx) WIA_DPV_LAST_PICTURE_TAKEN = '%ls'", 
                     pPropSpec[i].propid, 
                     pPropSpec[i].propid, 
                     m_strLastPictureTaken.String()));

            wiasWritePropStr(pWiasContext, 
                             WIA_DPV_LAST_PICTURE_TAKEN, 
                             CSimpleBStr(m_strLastPictureTaken).BString());
        }
    }

    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvReadItemProperties [IWiaMiniDrv]

   We only support reading thumbnails on demand.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvReadItemProperties(BYTE            *pWiasContext,
                                    LONG            lFlags,
                                    ULONG           nPropSpec,
                                    const PROPSPEC  *pPropSpec,
                                    LONG            *plDevErrVal)
{
    HRESULT     hr          = S_OK;
    LONG        lItemType   = 0;
    IWiaDrvItem *pDrvItem   = NULL;

    DBG_FN("CVideoStiUsd::drvReadItemProperties");

    //
    // Check for bad args
    //

    if ((nPropSpec    == 0)    ||
        (pPropSpec    == NULL) ||
        (pWiasContext == NULL))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::drvReadItemProperties received "
                         "NULL params"));

        return hr;
    }

    if (hr == S_OK)
    {
        //
        // Make sure we're dealing with an item, not the root item.
        //

        //
        // Get minidriver item
        //

        hr = wiasGetDrvItem(pWiasContext, &pDrvItem);

        if ((hr == S_OK) && (pDrvItem == NULL))
        {
            hr = E_FAIL;
        }

        CHECK_S_OK2(hr,("CVideoStiUsd::drvReadItemProperties, wiasGetDrvItem "
                        "failed"));
    }


    if (hr == S_OK)
    {
        hr = pDrvItem->GetItemFlags(&lItemType);
        CHECK_S_OK2(hr,("pDrvItem->GetItemFlags()"));
    }

    if (hr == S_OK)
    {
        if ((lItemType & WiaItemTypeFile) && (!(lItemType & WiaItemTypeRoot)))
        {
            //
            // If property being requested is a file and it is NOT the root, 
            // then read in the item property.
            //

            hr = ReadItemProperties(pWiasContext,
                                    lFlags,
                                    nPropSpec,
                                    pPropSpec,
                                    plDevErrVal,
                                    pDrvItem);
        }
        else if ((lItemType & WiaItemTypeFolder) && 
                 (lItemType & WiaItemTypeRoot))
        {
            // 
            // If the property being requested is the root, then read in 
            // the device properties.
            //

            hr = ReadDeviceProperties(pWiasContext,
                                      lFlags,
                                      nPropSpec,
                                      pPropSpec,
                                      plDevErrVal,
                                      pDrvItem);
        }
    }

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvLockWiaDevice [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvLockWiaDevice(BYTE *pWiasContext,
                               LONG lFlags,
                               LONG *plDevErrVal)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvLockWiaDevice");

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    //
    // We are purposely not locking the driver.  This driver is thread 
    // safe and it looks like with large volumes of images (>1000) 
    // you get better performance if the driver manages synchronization.
    //
    // return m_pStiDevice->LockDevice(DEFAULT_LOCK_TIMEOUT);

    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvUnLockWiaDevice [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvUnLockWiaDevice(BYTE *pWiasContext,
                                 LONG lFlags,
                                 LONG *plDevErrVal)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvUnLockWiaDevice");

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    //
    // We are purposely not locking the driver.  This driver is thread 
    // safe and it looks like with large volumes of images (>1000) 
    // you get better performance if the driver manages synchronization.
    //
    // return m_pStiDevice->UnLockDevice();

    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvAnalyzeItem [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvAnalyzeItem(BYTE *pWiasContext,
                             LONG lFlags,
                             LONG *plDevErrVal)
{
    HRESULT hr = E_NOTIMPL;

    DBG_FN("CVideoStiUsd::drvAnalyzeItem");

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvDeleteItem [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvDeleteItem(BYTE *pWiasContext,
                            LONG lFlags,
                            LONG *plDevErrVal)
{
    HRESULT hr = E_FAIL;

    DBG_FN("CVideoStiUsd::drvDeleteItem");

    //
    // check for bad params
    //

    if (pWiasContext == NULL)
    {
        DBG_ERR(("pWiasContext is NULL!"));
        return E_INVALIDARG;
    }

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    EnterCriticalSection(&m_csItemTree);

    //
    // Get a pointer to the associated driver item.
    //

    IWiaDrvItem * pDrvItem = NULL;

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    CHECK_S_OK2(hr,("wiasGetDrvItem"));

    if (SUCCEEDED(hr) && pDrvItem)
    {
        //
        // get item specific driver data
        //

        STILLCAM_IMAGE_CONTEXT  *pContext = NULL;

        pDrvItem->GetDeviceSpecContext((BYTE **)&pContext);

        CHECK_S_OK2(hr,("pDrvItem->GetDeviceSpecContext"));

        if (SUCCEEDED(hr) && pContext && pContext->pImage)
        {

            //
            // Delete the file in question
            //

            hr = pContext->pImage->DoDelete();
            CHECK_S_OK2(hr,("pContext->pImage->DoDelete()"));

            //
            // Dec the number of pictures taken
            //

            InterlockedDecrement(&m_lPicsTaken);

            //
            // write out the new amount
            //

            wiasWritePropLong(pWiasContext, 
                              WIA_DPC_PICTURES_TAKEN, 
                              m_lPicsTaken);


            if (SUCCEEDED(hr))
            {
                HRESULT hr2;

                BSTR bstrItemName = NULL;

                //
                // Get bstr of full item name
                //

                hr2 = pDrvItem->GetFullItemName(&bstrItemName);
                CHECK_S_OK2(hr2,("pDrvItem->GetFullItemName()"));

                //
                // Send event that item was deleted
                //

                hr2 = wiasQueueEvent(CSimpleBStr(m_strDeviceId), 
                                     &WIA_EVENT_ITEM_DELETED, 
                                     bstrItemName);

                CHECK_S_OK2(hr2, 
                            ("wiasQueueEvent( WIA_EVENT_ITEM_DELETED )"));

                //
                // Cleanup
                //

                if (bstrItemName)
                {
                    SysFreeString(bstrItemName);
                    bstrItemName = NULL;
                }
            }
        }
        else
        {
            DBG_ERR(("pContext or pContext->pImage are NULL!"));
            hr = E_FAIL;
        }
    }

    LeaveCriticalSection( &m_csItemTree );

    CHECK_S_OK(hr);
    return hr;
}



/*****************************************************************************

   CVideoStiUsd::drvFreeDrvItem [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvFreeDrvItemContext(LONG lFlags,
                                    BYTE *pDevContext,
                                    LONG *plDevErrVal)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvFreeDrvItemContext");

    PSTILLCAM_IMAGE_CONTEXT pContext = (PSTILLCAM_IMAGE_CONTEXT)pDevContext;

    if (pContext != NULL) 
    {
        //
        // delete is safe even if param is NULL.
        //
        delete pContext->pImage;
        pContext->pImage = NULL;
    }

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CMiniDev::drvGetCapabilities [IWiaMiniDrv]

   Let WIA know what things this driver can do.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvGetCapabilities(BYTE            *pWiasContext,
                                 LONG            lFlags,
                                 LONG            *pCelt,
                                 WIA_DEV_CAP_DRV **ppCapabilities,
                                 LONG            *plDevErrVal)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvGetCapabilities");

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    //
    // Return Commmand and/or Events depending on flags
    //

    switch (lFlags)
    {
        case WIA_DEVICE_COMMANDS:

            //
            //  Only commands
            //
            *pCelt = NUM_CAP_ENTRIES - NUM_EVENTS;
            *ppCapabilities = &gCapabilities[NUM_EVENTS];                
        break;

        case WIA_DEVICE_EVENTS:

            //
            //  Only events
            //

            *pCelt = NUM_EVENTS;
            *ppCapabilities = gCapabilities;
        break;

        case (WIA_DEVICE_COMMANDS | WIA_DEVICE_EVENTS):

            //
            //  Both events and commands
            //

            *pCelt = NUM_CAP_ENTRIES;
            *ppCapabilities = gCapabilities;
        break;

        default:

            //
            // Flags is invalid
            //

            DBG_ERR(("drvGetCapabilities, flags was invalid"));
            hr =  E_INVALIDARG;
        break;
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvGetWiaFormatInfo [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvGetWiaFormatInfo(BYTE            *pWiasContext,
                                  LONG            lFlags,
                                  LONG            *pCelt,
                                  WIA_FORMAT_INFO **ppwfi,
                                  LONG            *plDevErrVal)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvGetWiaFormatInfo");

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    //
    //  If it hasn't been done already, set up the g_wfiTable table
    //

    if (!m_wfi)
    {
        DBG_ERR(("drvGetWiaFormatInfo, m_wfi is NULL!"));
        return E_OUTOFMEMORY;
    }

    if (pCelt)
    {
        *pCelt = NUM_WIA_FORMAT_INFO;
    }

    if (ppwfi)
    {
        *ppwfi = m_wfi;
    }

    CHECK_S_OK(hr);
    return hr;
}

/*****************************************************************************

   CVideoStiUsd::drvNotifyPnpEvent [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvNotifyPnpEvent(const GUID *pEventGUID,
                                BSTR       bstrDeviceID,
                                ULONG      ulReserved)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvNotifyPnpEvent");

    //
    // CONNECTED event is of no interest, because a new USD is always created
    //

    if (*pEventGUID == WIA_EVENT_DEVICE_DISCONNECTED)
    {
        DBG_TRC(("got a WIA_EVENT_DISCONNECTED"));
    }

    CHECK_S_OK(hr);
    return hr;
}

/*****************************************************************************

   CVideoStiUsd::VerifyCorrectImagePath

   <Notes>

 *****************************************************************************/

HRESULT
CVideoStiUsd::VerifyCorrectImagePath(BSTR bstrNewImageFullPath)
{
    DBG_FN("CVideoStiUsd::VerifyCorrectImagePath");

    HRESULT        hr       = S_OK;
    INT            iIndex   = 0;
    CSimpleString  strImageFullPath;

    if (bstrNewImageFullPath == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CVideoStiUsd::VerifyCorrectImagePath received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        strImageFullPath = CSimpleStringConvert::NaturalString(
                                       CSimpleStringWide(bstrNewImageFullPath));

        //
        // Get the filename out of the full path.  Find the last backslash.
        //
        iIndex = strImageFullPath.ReverseFind('\\');
        strImageFullPath[iIndex] = 0;

        if (strImageFullPath != m_strStillPath)
        {
            hr = E_ACCESSDENIED;
            CHECK_S_OK2(hr, ("CVideoStiUsd::VerifyCorrectImagePath, the file that is "
                             "being added to the tree '%ls' is not in the allowed directory, "
                             "denying request with an E_ACCESSDENIED",
                              CSimpleStringWide(strImageFullPath).String()));
        }
    }

    return hr;
}

/*****************************************************************************

   CVideoStiUsd::SignalNewImage

   <Notes>

 *****************************************************************************/

HRESULT
CVideoStiUsd::SignalNewImage(BSTR bstrNewImageFullPath)
{
    DBG_FN("CVideoStiUsd::SignalNewImage");

    HRESULT              hr               = S_OK;
    CComPtr<IWiaDrvItem> pDrvItem         = NULL;
    BSTR                 bstrFullItemName = NULL;
    CSimpleString        strImageFullPath;

    if (hr == S_OK)
    {
        hr = VerifyCorrectImagePath(bstrNewImageFullPath);
    }

    if (hr == S_OK)
    {
        strImageFullPath = CSimpleStringConvert::NaturalString(
                                       CSimpleStringWide(bstrNewImageFullPath));
    
        DBG_TRC(("CVideoStiUsd::SignalNewImage, adding image '%ls' to "
                 "tree of device '%ls'",
                 CSimpleStringWide(strImageFullPath).String(),
                 m_strDeviceId.String()));
    
        // Add the new item to the tree if doesn't already exist
        //
    
        // Get the filename out of the full path.  Find the last backslash and
        // move 1 beyond it.
        //
        INT iIndex = strImageFullPath.ReverseFind('\\') + 1;
    
        if (!IsFileAlreadyInTree(m_pRootItem, &(strImageFullPath[iIndex])))
        {
            hr = AddTreeItem(&strImageFullPath, &pDrvItem);
    
            CHECK_S_OK2(hr, ("CVideoStiUsd::SignalNewImage, failed to add "
                             "image '%ls' to tree of device '%ls'",
                             CSimpleStringWide(strImageFullPath).String(),
                             m_strDeviceId.String()));
        
            if (hr == S_OK)
            {
                //
                // Get the full item name for this item
                //
        
                m_pLastItemCreated = pDrvItem;
                hr = pDrvItem->GetFullItemName(&bstrFullItemName);
                CHECK_S_OK2(hr,("CVideoStiUsd::SignalNewImage, failed to get Item "
                                "name for newly added item"));
            }
        
            if (hr == S_OK)
            {
                //
                // Queue an event that a new item was created.
                //
        
                hr = wiasQueueEvent(CSimpleBStr(m_strDeviceId), 
                                    &WIA_EVENT_ITEM_CREATED, 
                                    bstrFullItemName);
        
                CHECK_S_OK2(hr,("CVideoStiUsd::SignalNewImage, failed to "
                                "queue a new WIA_EVENT_ITEM_CREATED event"));
            }
    
            if (bstrFullItemName)
            {
                SysFreeString(bstrFullItemName);
                bstrFullItemName = NULL;
            }
        }
        else
        {
            DBG_TRC(("CVideoStiUsd::SignalNewImage, item '%ls' is already in the "
                     "tree.  Probably tree was recently refreshed",
                     bstrNewImageFullPath));
        }
    }

    return hr;
}


/*****************************************************************************

   CVideoStiUsd::SetImagesDirectory

   <Notes>

 *****************************************************************************/

HRESULT
CVideoStiUsd::SetImagesDirectory(BSTR        bstrNewImagesDirectory,
                                 BYTE        *pWiasContext,
                                 IWiaDrvItem **ppIDrvItemRoot,
                                 LONG        *plDevErrVal)
{
    DBG_FN("CVideoStiUsd::SetImagesDirectory");

    HRESULT         hr = S_OK;
    CSimpleString   strOriginalDirectory;

    //
    // If we received a NULL Images directory, then build up our own 
    // generated one, then build the item tree.
    //

    strOriginalDirectory = m_strStillPath;

    if (bstrNewImagesDirectory == NULL)
    {
        //
        // If this path is not in the registry, we default to constructing
        // a path of this type:
        //
        // %TEMP%\WIA\%DeviceID%

        TCHAR szTempPath[MAX_PATH + 1] = {0};

        hr = SHGetFolderPath(NULL, CSIDL_COMMON_APPDATA, NULL, SHGFP_TYPE_DEFAULT, szTempPath);

        //
        // We allow for the case of S_FALSE which indicates that the folder doesn't
        // exist.  This is fine since we recursively create it below.
        //
        if ((hr == S_OK) || (hr == S_FALSE))
        {
            //
            // Set path to "Documents and Settings\Application Data\Microsoft\Wia\{deviceid}"
            //
            m_strStillPath.Assign(szTempPath);

            if (!m_strStillPath.MatchLastCharacter(TEXT('\\')))
            {
                m_strStillPath += CSimpleString(TEXT("\\"));
            }

            m_strStillPath += TEXT("Microsoft\\WIA\\");
            m_strStillPath += m_strDeviceId;
        }
    }
    else
    {
        // we received a valid BSTR, attempt to create the directory.

        m_strStillPath = bstrNewImagesDirectory;
    }

    if (!RecursiveCreateDirectory(&m_strStillPath))
    {
        hr = E_FAIL;

        CHECK_S_OK2(hr, ("RecursiveCreateDirectory( %ws ) failed w/GLE=%d",
                         m_strStillPath.String(), 
                         ::GetLastError() ));
    }

    //
    // Set the security DACL on the directory so that users and power users
    // will be able to write and delete from it too.
    //
    if (hr == S_OK)
    {
        //
        // We only set this directory security if we are using our default directory
        // path.  This isn't an issue now since the user cannot update the directory,
        // but in the future if we allow them to, this could expose a security whole.
        //
        if (bstrNewImagesDirectory == NULL)
        {
            hr = SetDirectorySecurity(&m_strStillPath);
        }

    }

    if (hr == S_OK)
    {
        if (m_strStillPath.Length())
        {
            BOOL bSendUpdateEvent = FALSE;

            //
            // If the original directory is different from the new directory 
            // and we already have a tree, then we should destroy our 
            // existing tree, and recreate it for the new directory.
            //
            if ((strOriginalDirectory.CompareNoCase(m_strStillPath) != 0) &&
                (m_pRootItem != NULL))
            {
                EnterCriticalSection( &m_csItemTree );

                hr = m_pRootItem->UnlinkItemTree(WiaItemTypeDisconnected);
                CHECK_S_OK2(hr,("m_pRootItem->UnlinkItemTree()"));

                if (SUCCEEDED(hr))
                {
                    bSendUpdateEvent = TRUE;
                    m_pRootItem = NULL;
                }

                LeaveCriticalSection( &m_csItemTree );
            }

            //
            // Build the item tree.
            //

            hr = BuildItemTree(ppIDrvItemRoot, plDevErrVal);

            //
            // write out the new amount of pictures taken
            //
    
            wiasWritePropLong(pWiasContext, 
                              WIA_DPC_PICTURES_TAKEN, 
                              m_lPicsTaken);

            if (bSendUpdateEvent)
            {
                wiasQueueEvent(CSimpleBStr(m_strDeviceId), 
                               &WIA_EVENT_TREE_UPDATED, 
                               NULL);
            }
        }
        else
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr, 
                        ("CVideoStiUsd::SetImagesDirectory, new directory "
                         "path has a length of 0, Directory = '%ls'", 
                         m_strStillPath.String()));
        }
    }

    return hr;
}


/*****************************************************************************

   CVideoStiUsd::TakePicture

   <Notes>

 *****************************************************************************/

HRESULT
CVideoStiUsd::TakePicture(BYTE        *pTakePictureOwner,
                          IWiaDrvItem **ppNewDrvItem)
{
    HRESULT hr = S_OK;

    //
    // Notice that we are allowing multiple applications to call the 
    // take picture command, even if they weren't the owns that enabled
    // it.  
    //

    DBG_TRC(("CVideoStiUsd::drvDeviceCommand received command "
             "WIA_CMD_TAKE_PICTURE"));

    if ((m_hTakePictureEvent) && (m_hPictureReadyEvent))
    {
        DWORD dwResult = 0;

        m_pLastItemCreated = NULL;

        //
        // Tell the WiaVideo object that pertains to this device ID to 
        // take a picture.
        //
        SetEvent(m_hTakePictureEvent);

        // The WiaVideo object has a thread waiting on the 
        // m_hTakePictureEvent. When it is signalled, the WiaVideo object
        // takes the picture, then sets the driver's custom 
        // "LastPictureTaken" property.  This causes the driver to update 
        // its tree and queue an ITEM_CREATED event.  Once this is complete,
        // the WiaVideo object sets the PictureReady Event, at which point 
        // we return from this function call.

//        dwResult = WaitForSingleObject(m_hPictureReadyEvent, 
//                                       TAKE_PICTURE_TIMEOUT);

        if (dwResult == WAIT_OBJECT_0)
        {
//            *ppNewDrvItem = m_pLastItemCreated;
        }
        else
        {
            if (dwResult == WAIT_TIMEOUT)
            {
                hr = E_FAIL;
                CHECK_S_OK2(hr, ("CVideoStiUsd::TakePicture timed out "
                                 "after waiting for '%lu' seconds for the "
                                 "WiaVideo object to take a picture",
                                 TAKE_PICTURE_TIMEOUT));
            }
            else if (dwResult == WAIT_ABANDONED)
            {
                hr = E_FAIL;
                CHECK_S_OK2(hr, ("CVideoStiUsd::TakePicture failed, received "
                                 "a WAIT_ABANDONED from the Wait function"));
            }
            else
            {
                hr = E_FAIL;
                CHECK_S_OK2(hr, ("CVideoStiUsd::TakePicture failed to take a "
                                 "picture."));
            }
        }
    }
    else
    {
        DBG_TRC(("CVideoStiUsd::drvDeviceCommand, ignoring "
                 "WIA_CMD_TAKE_PICTURE request, events created "
                 "by WiaVideo are not open"));
    }

    return hr;
}

/*****************************************************************************

   CVideoStiUsd::EnableTakePicture

   <Notes>

 *****************************************************************************/

HRESULT
CVideoStiUsd::EnableTakePicture(BYTE *pTakePictureOwner)
{
    DBG_FN("CVideoStiUsd::EnableTakePicture");

    HRESULT             hr = S_OK;
    CSimpleString       strTakePictureEvent;
    CSimpleString       strPictureReadyEvent;
    CSimpleString       strDeviceID;
    SECURITY_ATTRIBUTES SA;

    SA.nLength        = sizeof(SECURITY_ATTRIBUTES);
    SA.bInheritHandle = TRUE;

    //
    // Convert to security descriptor
    //
    ConvertStringSecurityDescriptorToSecurityDescriptor(OBJECT_DACLS,
                                                        SDDL_REVISION_1, 
                                                        &(SA.lpSecurityDescriptor), 
                                                        NULL);

    
    strDeviceID = CSimpleStringConvert::NaturalString(m_strDeviceId);

    m_pTakePictureOwner = pTakePictureOwner;

    if (hr == S_OK)
    {
        INT             iPosition = 0;
        CSimpleString   strModifiedDeviceID;

        // Change the device ID from {6B...}\xxxx, to {6B...}_xxxx

        iPosition = strDeviceID.ReverseFind('\\');
        strModifiedDeviceID = strDeviceID.MakeUpper();
        strModifiedDeviceID.SetAt(iPosition, '_');

        //
        // Generate the event names.  These names contain the Device ID in 
        // them so that they are unique across devices.
        //
        strTakePictureEvent  = EVENT_PREFIX_GLOBAL;
        strTakePictureEvent += strModifiedDeviceID;
        strTakePictureEvent += EVENT_SUFFIX_TAKE_PICTURE;

        strPictureReadyEvent  = EVENT_PREFIX_GLOBAL;
        strPictureReadyEvent += strModifiedDeviceID;
        strPictureReadyEvent += EVENT_SUFFIX_PICTURE_READY;
    }

    if (hr == S_OK)
    {
        m_hTakePictureEvent = CreateEvent(&SA,
                                          FALSE,
                                          FALSE, 
                                          strTakePictureEvent);
        //
        // This is not really an error since the events will not have been created until
        // the WiaVideo object comes up.
        //
        if (m_hTakePictureEvent == NULL)
        {
            hr = E_FAIL;
            DBG_TRC(("CVideoStiUsd::EnableTakePicture, failed to open the "
                     "WIA event '%ls', this is not fatal (LastError = '%lu' "
                     "(0x%08lx))", 
                     strTakePictureEvent.String(),
                     ::GetLastError(), 
                     ::GetLastError()));
        }
    }

    if (hr == S_OK)
    {
        m_hPictureReadyEvent = CreateEvent(&SA,
                                           FALSE,
                                           FALSE, 
                                           strPictureReadyEvent);

        //
        // This is not really an error since the events will not have been created until
        // the WiaVideo object comes up.
        //
        if (m_hPictureReadyEvent == NULL)
        {
            hr = E_FAIL;

            DBG_TRC(("CVideoStiUsd::EnableTakePicture, failed to open the WIA "
                     "event '%ls', this is not fatal (LastError = '%lu' "
                     "(0x%08lx))", 
                     strPictureReadyEvent.String(),
                     ::GetLastError(), 
                     ::GetLastError()));
        }
    }

    if (SA.lpSecurityDescriptor)
    {
        LocalFree(SA.lpSecurityDescriptor);
    }

    return hr;
}

/*****************************************************************************

   CVideoStiUsd::DisableTakePicture

   <Notes>

 *****************************************************************************/

HRESULT
CVideoStiUsd::DisableTakePicture(BYTE *pTakePictureOwner,
                                 BOOL bShuttingDown)
{
    HRESULT hr = S_OK;

    if (m_hTakePictureEvent)
    {
        ::CloseHandle(m_hTakePictureEvent);
        m_hTakePictureEvent = NULL;
    }

    if (m_hPictureReadyEvent)
    {
        ::CloseHandle(m_hPictureReadyEvent);
        m_hPictureReadyEvent = NULL;
    }

    m_pTakePictureOwner = NULL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\usd\itemtree.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2000
 *
 *  TITLE:       ItemTree.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        9/10/99        RickTu
 *               2000/11/09     OrenR
 *
 *  DESCRIPTION: This code was originally in 'camera.cpp' but was broken out.
 *               This code builds and maintains the camera's IWiaDrvItem tree.
 *
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop


/*****************************************************************************

   CVideoStiUsd::BuildItemTree

   Constructs an item tree which represents the layout of this
   WIA camera...

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::BuildItemTree(IWiaDrvItem **  ppIDrvItemRoot,
                            LONG *          plDevErrVal)
{
    HRESULT hr;

    DBG_FN("CVideoStiUsd::BuildItemTree");

    EnterCriticalSection( &m_csItemTree );

    //
    // Check for bad args
    //

    if (!ppIDrvItemRoot)
    {
        hr = E_POINTER;
    }

    //
    // Make sure that there is only one item tree
    //

    else if (m_pRootItem)
    {
        *ppIDrvItemRoot = m_pRootItem;

        //
        // refresh our tree.  We prune out all files which no longer exist
        // but for some reason remain in our tree (this can happen if someone
        // manually deletes a file from the temp WIA directory where we store
        // these images before they are transfered)
        //

        RefreshTree(m_pRootItem, plDevErrVal);

        hr = S_OK;
    }

    //
    // Lastly, build the tree if we need to
    //

    else
    {
        //
        // First check to see if we have a corresponding DShow device id
        // in the registry -- if not, then bail.
        //

        if (!m_strDShowDeviceId.Length())
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr, ("CVideoStiUsd::BuildItemTree, the DShow Device ID"
                             "is empty, this should never happen"));
        }
        else
        {
            //
            // Create the new root
            //

            CSimpleBStr bstrRoot(L"Root");

            //
            // Call Wia service library to create new root item
            //

            hr = wiasCreateDrvItem(WiaItemTypeFolder | 
                                   WiaItemTypeRoot   | 
                                   WiaItemTypeDevice,
                                   bstrRoot.BString(),
                                   CSimpleBStr(m_strRootFullItemName),
                                   (IWiaMiniDrv *)this,
                                   sizeof(STILLCAM_IMAGE_CONTEXT),
                                   NULL,
                                   ppIDrvItemRoot);

            CHECK_S_OK2( hr, ("wiaCreateDrvItem" ));

            if (SUCCEEDED(hr) && *ppIDrvItemRoot)
            {
                m_pRootItem = *ppIDrvItemRoot;

                //
                // Add the items for this device
                //

                hr = EnumSavedImages( m_pRootItem );
                CHECK_S_OK2( hr, ("EnumSavedImages" ));


            }
        }
    }

    LeaveCriticalSection(&m_csItemTree);

    CHECK_S_OK(hr);
    return hr;
}

/*****************************************************************************

   CVideoStiUsd::AddTreeItem

   <Notes>

 *****************************************************************************/

HRESULT
CVideoStiUsd::AddTreeItem(CSimpleString *pstrFullImagePath,
                          IWiaDrvItem   **ppDrvItem)
{
    HRESULT hr          = S_OK;
    INT     iPos        = 0;
    LPCTSTR pszFileName = NULL;

    if (pstrFullImagePath == NULL)
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::AddTreeItem, received NULL "
                         "param"));
        return hr;
    }

    //
    // Extract the file name from the full path.  We do this by searching 
    // for the  first '\' from the end of the string.
    //
    iPos = pstrFullImagePath->ReverseFind('\\');

    if (iPos < (INT) pstrFullImagePath->Length())
    {
        //
        // increment the position by 1 because we want to skip over the 
        // backslash.
        //
        ++iPos;

        // 
        // point to the filename within the full path.
        //
        pszFileName = &(*pstrFullImagePath)[iPos];
    }

    if (pszFileName)
    {
        //
        // Create a new DrvItem for this image and add it to the
        // DrvItem tree.
        //

        IWiaDrvItem *pNewFolder = NULL;

        hr = CreateItemFromFileName(WiaItemTypeFile | WiaItemTypeImage,
                                    pstrFullImagePath->String(),
                                    pszFileName,
                                    &pNewFolder);

        CHECK_S_OK2( hr, ("CVideoStiUsd::AddTreeItem, "
                          "CreateItemFromFileName failed"));

        if (hr == S_OK)
        {
            hr = pNewFolder->AddItemToFolder(m_pRootItem);

            CHECK_S_OK2( hr, ("CVideoStiUsd::AddTreeItem, "
                              "pNewFolder->AddItemToFolder failed"));
        }

        if (ppDrvItem)
        {
            *ppDrvItem = pNewFolder;
            (*ppDrvItem)->AddRef();
        }

        pNewFolder->Release();
    }

    return hr;
}



/*****************************************************************************

   CVideoStiUsd::EnumSavedImages

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::EnumSavedImages(IWiaDrvItem * pRootItem)
{
    DBG_FN("CVideoStiUsd::EnumSavedImages");

    HRESULT          hr = S_OK;
    WIN32_FIND_DATA  FindData;

    if (!m_strStillPath.Length())
    {
        DBG_ERR(("m_strStillPath is NULL, can't continue!"));
        return E_FAIL;
    }

    CSimpleString strTempName(m_strStillPath);
    strTempName.Concat( TEXT("\\*.jpg") );

    //
    // look for files at this level
    //

    HANDLE hFile = FindFirstFile(strTempName.String(), &FindData);

    if (hFile != INVALID_HANDLE_VALUE)
    {

        BOOL bStatus = FALSE;

        do
        {
            //
            // generate file name
            //

            strTempName.Assign( m_strStillPath );
            strTempName.Concat( TEXT("\\") );
            strTempName.Concat( FindData.cFileName );

            hr = AddTreeItem(&strTempName, NULL);

            if (FAILED(hr))
            {

                continue;
            }

            //
            // look for more images
            //

            bStatus = FindNextFile(hFile,&FindData);

        } while (bStatus);

        FindClose(hFile);
    }

    return S_OK;
}

/*****************************************************************************

   CVideoStiUsd::DoesFileExist

   <Notes>

 *****************************************************************************/

BOOL 
CVideoStiUsd::DoesFileExist(BSTR bstrFileName)
{
    DBG_FN("CVideoStiUsd::DoesFileExist");

    BOOL  bExists  = FALSE;
    DWORD dwAttrib = 0;

    if (bstrFileName == NULL)
    {
        return FALSE;
    }

    CSimpleString strTempName(m_strStillPath);
    strTempName.Concat(TEXT("\\"));
    strTempName.Concat(bstrFileName);
    strTempName.Concat(TEXT(".jpg"));

    dwAttrib = ::GetFileAttributes(strTempName);

    if (dwAttrib != 0xFFFFFFFF)
    {
        bExists = TRUE;
    }
    else
    {
        bExists = FALSE;
    }

    return bExists;
}


/*****************************************************************************

   CVideoStiUsd::PruneTree

   Removes nodes from the tree whose filenames no longer exist in the temp
   directory

 *****************************************************************************/

HRESULT 
CVideoStiUsd::PruneTree(IWiaDrvItem * pRootItem,
                        BOOL        * pbTreeChanged)
{
    DBG_FN("CVideoStiUsd::PruneTree");

    HRESULT                 hr             = S_OK;
    BOOL                    bTreeChanged   = FALSE;
    IWiaDrvItem             *pCurrentItem  = NULL;
    IWiaDrvItem             *pNextItem     = NULL;
    BSTR                    bstrItemName   = NULL;

    if ((pRootItem == NULL) || (pbTreeChanged == NULL))
    {
        return E_INVALIDARG;
    }
    else if (!m_strStillPath.Length())
    {
        DBG_ERR(("m_strStillPath is NULL, can't continue!"));
        return E_FAIL;
    }

    // This function DOES NOT do an AddRef
    hr = pRootItem->GetFirstChildItem(&pCurrentItem);

    while ((hr == S_OK) && (pCurrentItem != NULL))
    {
        pNextItem = NULL;

        pCurrentItem->AddRef();

        hr = pCurrentItem->GetItemName(&bstrItemName);

        if (SUCCEEDED(hr) && (bstrItemName != NULL))
        {
            //
            // if the filename for this item does not exist, 
            // then remove it from our tree.
            //
            if (!DoesFileExist(bstrItemName))
            {
                //
                // get the next item in the list so we don't lose our place
                // in the list after removing the current item.
                //
                hr = pCurrentItem->GetNextSiblingItem(&pNextItem);
                CHECK_S_OK2(hr, ("pCurrentItem->GetNextSiblingItem"));

                //
                // remove the item from the folder, we no longer need it.
                //
                hr = pCurrentItem->RemoveItemFromFolder(WiaItemTypeDeleted);
                CHECK_S_OK2(hr, ("pItemToRemove->RemoveItemFromFolder"));

                //
                // Report the error, but continue.  If we failed to 
                // remove the item from the tree, for whatever reason, 
                // there really is nothing we can do but proceed and 
                // prune the remainder of the tree.  
                //
                if (hr != S_OK)
                {
                    DBG_ERR(("Failed to remove item from folder, "
                             "hr = 0x%08lx", 
                             hr));

                    hr = S_OK;
                }

                if (m_lPicsTaken > 0)
                {
                    //
                    // Decrement the # of pics taken only if the 
                    // current # of pics is greater than 0.
                    //
                    InterlockedCompareExchange(
                                     &m_lPicsTaken, 
                                     m_lPicsTaken - 1,
                                     (m_lPicsTaken > 0) ? m_lPicsTaken : -1);
                }

                //
                // Indicate the tree was changed so we can send a notification
                // when we are done.
                //
                bTreeChanged = TRUE;
            }
            else
            {
                // file does exist, all is well in the world, move on to next
                // item in the tree.
                hr = pCurrentItem->GetNextSiblingItem(&pNextItem);
            }
        }

        //
        // release the current item since we AddRef'd it at the start of this 
        // loop.  
        //
        pCurrentItem->Release();
        pCurrentItem = NULL;

        // 
        // set our next item to be our current item.  It is possible that
        // pNextItem is NULL.
        //
        pCurrentItem = pNextItem;

        //
        // Free the BSTR.
        //
        if (bstrItemName)
        {
            ::SysFreeString(bstrItemName);
            bstrItemName = NULL;
        }
    }

    hr = S_OK;

    if (pbTreeChanged)
    {
        *pbTreeChanged = bTreeChanged;
    }


    return hr;
}

/*****************************************************************************

   CVideoStiUsd::IsFileAlreadyInTree

   <Notes>

 *****************************************************************************/

BOOL 
CVideoStiUsd::IsFileAlreadyInTree(IWiaDrvItem * pRootItem,
                                  LPCTSTR       pszFileName)
{
    DBG_FN("CVideoStiUsd::IsFileAlreadyInTree");

    HRESULT         hr                          = S_OK;
    BOOL            bFound                      = FALSE;
    IWiaDrvItem     *pCurrentItem               = NULL;

    if ((pRootItem   == NULL) ||
        (pszFileName == NULL))
    {
        bFound = FALSE;
        DBG_ERR(("CVideoStiUsd::IsFileAlreadyInTree received a NULL pointer, "
                 "returning FALSE, item not found in tree."));

        return bFound;
    }

    CSimpleString strFileName( m_strStillPath );
    CSimpleString strBaseName( pszFileName );
    strFileName.Concat( TEXT("\\") );
    strFileName.Concat( strBaseName );

    CImage Image(m_strStillPath,
                 CSimpleBStr(m_strRootFullItemName),
                 strFileName.String(),
                 strBaseName.String(),
                 WiaItemTypeFile | WiaItemTypeImage);

    hr = pRootItem->FindItemByName(0, 
                                   Image.bstrFullItemName(),
                                   &pCurrentItem);

    if (hr == S_OK)
    {
        bFound = TRUE;
        //
        // Don't forget to release the driver item, since it was AddRef'd by
        // FindItemByName(..)
        //
        pCurrentItem->Release();
    }
    else
    {
        bFound = FALSE;
    }

    return bFound;
}


/*****************************************************************************

   CVideoStiUsd::AddNewFilesToTree

   <Notes>

 *****************************************************************************/

HRESULT
CVideoStiUsd::AddNewFilesToTree(IWiaDrvItem * pRootItem,
                                BOOL        * pbTreeChanged)
{
    DBG_FN("CVideoStiUsd::AddNewFilesToTree");

    HRESULT          hr           = E_FAIL;
    BOOL             bTreeChanged = FALSE;
    HANDLE           hFile        = NULL;
    BOOL             bFileFound   = FALSE;
    WIN32_FIND_DATA  FindData;

    if ((pRootItem     == NULL) ||
        (pbTreeChanged == NULL))
    {
        return E_INVALIDARG;
    }

    if (!m_strStillPath.Length())
    {
        DBG_ERR(("m_strStillPath is NULL, can't continue!"));
        return E_FAIL;
    }

    CSimpleString strTempName(m_strStillPath);
    strTempName.Concat( TEXT("\\*.jpg") );

    //
    // Find all JPG files in the m_strStillPath directory.
    // This directory is %windir%\temp\wia\{Device GUID}\XXXX
    // where X is numeric.
    //
    hFile = FindFirstFile(strTempName.String(), &FindData);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        bFileFound = TRUE;
    }

    //
    // Iterate through all files in the directory and for each
    // one check to see if it is already in the tree.  If it 
    // isn't, then add it to the tree.  If it is, do nothing
    // and move to the next file in the directory
    //
    while (bFileFound)
    {
        //
        // Check if the file in the directory is already in our
        // tree.
        //
        if (!IsFileAlreadyInTree(pRootItem, FindData.cFileName))
        {
            //
            // add an image to this folder
            //
            // generate file name
            //
    
            strTempName.Assign( m_strStillPath );
            strTempName.Concat( TEXT("\\") );
            strTempName.Concat( FindData.cFileName );

            hr = AddTreeItem(&strTempName, NULL);

            // 
            // Set this flag to indicate that changes were made to the 
            // tree, hence we will send an event indicating this when we
            // are done.
            //
            bTreeChanged = TRUE;
        }

        //
        // look for more images
        //
    
        bFileFound = FindNextFile(hFile,&FindData);
    }

    if (hFile)
    {
        FindClose(hFile);
        hFile = NULL;
    }

    if (pbTreeChanged)
    {
        *pbTreeChanged = bTreeChanged;
    }

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::RefreshTree

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::RefreshTree(IWiaDrvItem * pRootItem,
                          LONG *        plDevErrVal)
{
    DBG_FN("CVideoStiUsd::RefreshTree");

    BOOL    bItemsAdded    = FALSE;
    BOOL    bItemsRemoved  = FALSE;
    HRESULT hr             = S_OK;

    //
    // Remove any dead nodes from the tree.  A dead node is a node in the tree
    // whose file has been deleted from the directory in m_strStillPath, 
    // but we still have a tree item for it.  
    //
    hr = PruneTree(pRootItem, &bItemsRemoved);
    CHECK_S_OK2(hr, ("PruneTree"));

    //
    // Add any news files that have been added to the folder but for some 
    // reason we don't have a tree node for them.
    //
    hr = AddNewFilesToTree(pRootItem, &bItemsAdded);
    CHECK_S_OK2(hr, ("AddNewFilesToTree"));
    
    //
    // If we added new nodes, removed some nodes, or both, then notify the 
    // guys upstairs (in the UI world) that the tree has been updated.
    //
    if ((bItemsAdded) || (bItemsRemoved))
    {
        hr = wiasQueueEvent(CSimpleBStr(m_strDeviceId), 
                            &WIA_EVENT_TREE_UPDATED, 
                            NULL);
    }

    return hr;
}



/*****************************************************************************

   CVideoStiUsd::CreateItemFromFileName

   Helper function that creates a WIA item from a filename (which is a .jpg).

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::CreateItemFromFileName(LONG              FolderType,
                                     LPCTSTR           pszPath,
                                     LPCTSTR           pszName,
                                     IWiaDrvItem **    ppNewFolder)
{
    HRESULT                 hr         = E_FAIL;
    IWiaDrvItem *           pNewFolder = NULL;
    PSTILLCAM_IMAGE_CONTEXT pContext   = NULL;

    DBG_FN("CVideoStiUsd::CreateItemFromFileName");

    //
    // Check for bad args
    //

    if (!ppNewFolder)
    {
        DBG_ERR(("ppNewFolder is NULL, returning E_INVALIDARG"));
        return E_INVALIDARG;
    }

    //
    // Set up return value
    //

    *ppNewFolder = NULL;

    //
    // Create new image object
    //

    CImage * pImage = new CImage(m_strStillPath,
                                 CSimpleBStr(m_strRootFullItemName),
                                 pszPath,
                                 pszName,
                                 FolderType);

    if (!pImage)
    {
        DBG_ERR(("Couldn't create new CImage, returning E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    //
    // call Wia to create new DrvItem
    //


    hr = wiasCreateDrvItem(FolderType,
                           pImage->bstrItemName(),
                           pImage->bstrFullItemName(),
                           (IWiaMiniDrv *)this,
                           sizeof(STILLCAM_IMAGE_CONTEXT),
                           (BYTE **)&pContext,
                           &pNewFolder);

    CHECK_S_OK2( hr, ("wiasCreateDrvItem"));

    if (SUCCEEDED(hr) && pNewFolder)
    {

        //
        // init device specific context
        //

        pContext->pImage = pImage;

        //
        // Return the item
        //

        *ppNewFolder = pNewFolder;


        //
        // Inc the number of pictures taken
        //

        InterlockedIncrement(&m_lPicsTaken);

    }
    else
    {
        DBG_ERR(("CVideoStiUsd::CreateItemFromFileName - wiasCreateItem "
                 "failed or returned NULL pNewFolder, hr = 0x%08lx, "
                 "pNewFolder = 0x%08lx, pContext = 0x%08lx", 
                 hr,
                 pNewFolder,pContext ));

        delete pImage;
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


/*****************************************************************************

   CVideoStiUsd::InitDeviceProperties

   Initializes properties for the device on the device root item.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::InitDeviceProperties(BYTE *  pWiasContext,
                                   LONG *  plDevErrVal)
{
    HRESULT                  hr             = S_OK;
    BSTR                     bstrFirmwreVer = NULL;
    int                      i              = 0;
    SYSTEMTIME               camTime;
    PROPVARIANT              propVar;

    DBG_FN("CVideoStiUsd::InitDeviceProperties");

    //
    // This device doesn't touch hardware to initialize the device properties.
    //

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    //
    // Parameter validation.
    //

    if (pWiasContext == NULL)
    {
        hr = E_INVALIDARG;

        CHECK_S_OK2(hr, ("CVideoStiUsd::InitDeviceProperties received "
                         "NULL param."));

        return hr;
    }

    //
    // Write standard property names
    //

    hr = wiasSetItemPropNames(pWiasContext,
                              sizeof(gDevicePropIDs)/sizeof(PROPID),
                              gDevicePropIDs,
                              gDevicePropNames);

    CHECK_S_OK2(hr, ("wiaSetItemPropNames"));

    if (hr == S_OK)
    {

        //
        // Write the properties supported by all WIA devices
        //
    
        bstrFirmwreVer = SysAllocString(L"<NA>");
        if (bstrFirmwreVer)
        {
            wiasWritePropStr(pWiasContext, 
                             WIA_DPA_FIRMWARE_VERSION, 
                             bstrFirmwreVer);

            SysFreeString(bstrFirmwreVer);
        }
    
        hr = wiasWritePropLong(pWiasContext, WIA_DPA_CONNECT_STATUS, 1);
        hr = wiasWritePropLong(pWiasContext, WIA_DPC_PICTURES_TAKEN, 0);
    
        //
        // Write the camera properties, just default values, it may 
        // vary with items
        //
    
        hr = wiasWritePropLong(pWiasContext, WIA_DPC_THUMB_WIDTH,  80);
        hr = wiasWritePropLong(pWiasContext, WIA_DPC_THUMB_HEIGHT, 60);
    
        //
        // Write the Directshow Device ID
        //
        hr = wiasWritePropStr(pWiasContext, 
                              WIA_DPV_DSHOW_DEVICE_PATH, 
                              CSimpleBStr(m_strDShowDeviceId));
    
        //
        // Write the Images Directory
        //
        hr = wiasWritePropStr(pWiasContext, 
                              WIA_DPV_IMAGES_DIRECTORY, 
                              CSimpleBStr(m_strStillPath));
    
        //
        // Write the Last Picture Taken
        //
        hr = wiasWritePropStr(pWiasContext, 
                              WIA_DPV_LAST_PICTURE_TAKEN, 
                              CSimpleBStr(TEXT("")));
    
    
        //
        // Use WIA services to set the property access and
        // valid value information from gDevPropInfoDefaults.
        //
    
        hr =  wiasSetItemPropAttribs(pWiasContext,
                                     NUM_CAM_DEV_PROPS,
                                     gDevicePropSpecDefaults,
                                     gDevPropInfoDefaults);
    }

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::InitImageInformation

   Used to initialize device items (images) from this device.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::InitImageInformation( BYTE *                  pWiasContext,
                                    PSTILLCAM_IMAGE_CONTEXT pContext,
                                    LONG *                  plDevErrVal
                                  )
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::InitImageInformation");

    //
    // Check for bad args
    //

    if ((pWiasContext == NULL) || 
        (pContext     == NULL))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::InitImageInformation, received "
                         "NULL params"));
        return hr;
    }

    //
    // Get the image in question
    //

    CImage * pImage = pContext->pImage;

    if (pImage == NULL)
    {
        hr = E_INVALIDARG;
    }

    if (hr == S_OK)
    {
        //
        // Ask the image to initialize the information
        //
    
        hr = pImage->InitImageInformation(pWiasContext, plDevErrVal);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\usd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsusd.rc
//

#define IDS_SNAPSHOT                201

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\usd\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        9/7/99
 *
 *  DESCRIPTION: Precompiled header file for video usd
 *
 *****************************************************************************/


#ifndef _WIA_VIDEO_USD_PRECOMP_H_
#define _WIA_VIDEO_USD_PRECOMP_H_

#ifdef DBG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#include <windows.h>

#include <psnew.h>
#include <simstr.h>
#include <simreg.h>
#include <simbstr.h>
#include <simlist.h>
#include <wiadebug.h>

#include <winioctl.h>
#include <ole2.h>
#include <initguid.h>
#include <gdiplus.h>
#include <uuids.h>
#include <sti.h>
#include <stiusd.h>
#include <stierr.h>
#include <atlbase.h>
#include <wiamindr.h>
#include <resource.h>
#include <istillf.h>
#include <vcamprop.h>
#include <image.h>
#include <vstiusd.h>
#include <defprop.h>
#include <coredbg.h>

extern HINSTANCE g_hInstance;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\usd\transfer.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2000
 *
 *  TITLE:       Transfer.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        9/10/99        RickTu
 *               2000/11/09     OrenR
 *
 *  DESCRIPTION: This was originally in camera.cpp but was broken out for
 *               clarity.  The functions in this file are responsible for
 *               transfering the image to the requesting application.
 *
 *****************************************************************************/
#include <precomp.h>
#pragma hdrstop
#include <gphelper.h>

using namespace Gdiplus;

/*****************************************************************************

   CVideoStiUsd::DoBandedTransfer

   hand back the given bits in the specified chunk sizes

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::DoBandedTransfer(MINIDRV_TRANSFER_CONTEXT *pTransCtx,
                               PBYTE                    pSrc,
                               LONG                     lBytesToTransfer)
{
    HRESULT hr = E_FAIL;

    DBG_FN("CVideoStiUsd::DoBandedTransfer");

    //
    // Check for bad args
    //

    if ((pTransCtx        == NULL) ||
        (pSrc             == NULL) ||
        (lBytesToTransfer == 0))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::DoBandedTransfer, received "
                         "NULL param"));
        return hr;
    }

    //
    // callback loop
    //

    LONG  lTransferSize     = 0;
    LONG  lPercentComplete  = 0;

    do
    {

        PBYTE pDst = pTransCtx->pTransferBuffer;

        //
        // transfer up to entire buffer size
        //

        lTransferSize = lBytesToTransfer;

        if (lBytesToTransfer > pTransCtx->lBufferSize)
        {
            lTransferSize = pTransCtx->lBufferSize;
        }

        //
        // copy data
        //

        DBG_TRC(("memcpy(src=0x%x,dst=0x%x,size=0x%x)",
                 pDst,
                 pSrc,
                 lTransferSize));

        memcpy(pDst, pSrc, lTransferSize);

        lPercentComplete = 100 * (pTransCtx->cbOffset + lTransferSize);
        lPercentComplete /= pTransCtx->lItemSize;

        //
        // make callback
        //

        hr = pTransCtx->pIWiaMiniDrvCallBack->MiniDrvCallback(
                                                 IT_MSG_DATA,
                                                 IT_STATUS_TRANSFER_TO_CLIENT,
                                                 lPercentComplete,
                                                 pTransCtx->cbOffset,
                                                 lTransferSize,
                                                 pTransCtx,
                                                 0);

        CHECK_S_OK2(hr,("pTransCtx->pWiaMiniDrvCallback->MiniDrvCallback"));

        DBG_TRC(("%d percent complete",lPercentComplete));

        //
        // inc pointers (redundant pointers here)
        //

        pSrc                += lTransferSize;
        pTransCtx->cbOffset += lTransferSize;
        lBytesToTransfer    -= lTransferSize;

        if (hr != S_OK)
        {
            break;
        }

    } while (lBytesToTransfer > 0);


    CHECK_S_OK(hr);
    return hr;
}



/*****************************************************************************

   CVideoStiUsd::DoTransfer

   Transfers the given bits all at once

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::DoTransfer(MINIDRV_TRANSFER_CONTEXT *pTransCtx,
                         PBYTE                    pSrc,
                         LONG                     lBytesToTransfer)
{

    HRESULT hr = E_FAIL;

    DBG_FN("CVideoStiUsd::DoTransfer");

    //
    // Check for bad args
    //

    if ((pTransCtx        == NULL) ||
        (pSrc             == NULL) ||
        (lBytesToTransfer == 0))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::DoTransfer, received "
                         "NULL param"));
        return hr;
    }

    if (lBytesToTransfer > (LONG)(pTransCtx->lBufferSize - pTransCtx->cbOffset))
    {
        DBG_TRC(("lBytesToTransfer = %d, (lBufferSize = %d) - "
                 "(cbOffset = %d) is %d",
                 lBytesToTransfer,
                 pTransCtx->lBufferSize,
                 pTransCtx->cbOffset,
                 (pTransCtx->lBufferSize - pTransCtx->cbOffset)));

        DBG_ERR(("lBytesToTransfer is bigger than supplied buffer!"));

        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
    }
    else
    {

        //
        // Show 20% completion
        //

        if (pTransCtx->pIWiaMiniDrvCallBack)
        {
            pTransCtx->pIWiaMiniDrvCallBack->MiniDrvCallback(
                                           IT_MSG_STATUS,
                                           IT_STATUS_TRANSFER_FROM_DEVICE,
                                           (LONG)20,  // Percentage Complete,
                                           0,
                                           0,
                                           pTransCtx,
                                           0);
        }


        PBYTE pDst = pTransCtx->pTransferBuffer;
        pDst += pTransCtx->cbOffset;

        //
        // copy the bits
        //

        memcpy(pDst, pSrc, lBytesToTransfer);

        hr = S_OK;

        // Since we are copying all the bits in one shot, any status
        // callback is just a simulation anyway.  So lets give enough
        // increments to bring the progress dialog up to 100 %.

        if (pTransCtx->pIWiaMiniDrvCallBack)
        {

            // Show 60% completion
            pTransCtx->pIWiaMiniDrvCallBack->MiniDrvCallback(
                                           IT_MSG_STATUS,
                                           IT_STATUS_TRANSFER_FROM_DEVICE,
                                           (LONG)60,  // Percentage Complete,
                                           0,
                                           0,
                                           pTransCtx,
                                           0);

            // Show 90% completion
            pTransCtx->pIWiaMiniDrvCallBack->MiniDrvCallback(
                                           IT_MSG_STATUS,
                                           IT_STATUS_TRANSFER_FROM_DEVICE,
                                           (LONG)90,  // Percentage Complete,
                                           0,
                                           0,
                                           pTransCtx,
                                           0);

            // Show 99% completion
            pTransCtx->pIWiaMiniDrvCallBack->MiniDrvCallback(
                                           IT_MSG_STATUS,
                                           IT_STATUS_TRANSFER_FROM_DEVICE,
                                           (LONG)99,  // Percentage Complete,
                                           0,
                                           0,
                                           pTransCtx,
                                           0);


            // Show 100% completion
            pTransCtx->pIWiaMiniDrvCallBack->MiniDrvCallback(
                                           IT_MSG_STATUS,
                                           IT_STATUS_TRANSFER_FROM_DEVICE,
                                           (LONG)100,  // Percentage Complete,
                                           0,
                                           0,
                                           pTransCtx,
                                           0);
        }
    }

    CHECK_S_OK(hr);
    return hr;
}



/*****************************************************************************

   CVideoUsd::StreamJPEGBits

   Transfers the JPEG bits of a file

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::StreamJPEGBits(STILLCAM_IMAGE_CONTEXT   *pContext,
                             MINIDRV_TRANSFER_CONTEXT *pTransCtx,
                             BOOL                     bBanded)
{
    HRESULT hr   = E_FAIL;
    PBYTE   pSrc = NULL;

    DBG_FN("CVideoStiUsd::StreamJPEGBits");

    //
    // Check for invalid args
    //

    if ((pContext         == NULL) ||
        (pContext->pImage == NULL) ||
        (pTransCtx        == NULL))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::StreamJPEGBits received NULL "
                         "params"));
        return hr;
    }

    //
    // try to open mapping to disk file -- we will use this if it is a JPEG
    // file because we just want to stream the bits back.
    //

    CMappedView cmvImage(pContext->pImage->ActualImagePath(), 
                         0, 
                         OPEN_EXISTING);

    pSrc = cmvImage.Bits();

    if (pSrc)
    {
        //
        // We only handle 2GB of data (that's all WIA handles as well)
        //

        LARGE_INTEGER liSize = cmvImage.FileSize();
        LONG lBytes = liSize.LowPart;

        if (bBanded)
        {
            hr = DoBandedTransfer(pTransCtx, pSrc, lBytes);
        }
        else
        {
            hr = DoTransfer(pTransCtx, pSrc, lBytes);
        }
    }

    CHECK_S_OK(hr);
    return hr;
}




/*****************************************************************************

   CVideoStiUsd::StreamBMPBits

   Transfers the BMP bits of a file

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::StreamBMPBits(STILLCAM_IMAGE_CONTEXT   *pContext,
                            MINIDRV_TRANSFER_CONTEXT *pTransCtx,
                            BOOL                     bBanded)
{
    DBG_FN("CVideoStiUsd::StreamBMPBits");

    //
    // Assume failure
    //
    HRESULT hr = E_FAIL;

    if ((pContext         == NULL) ||
        (pContext->pImage == NULL) ||
        (pTransCtx        == NULL))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::StreamBMPBits received NULL params"));
        return hr;
    }

    //
    // Open the file
    //
    Bitmap SourceBitmap(CSimpleStringConvert::WideString(
                                    CSimpleString(
                                        pContext->pImage->ActualImagePath())));

    if (Ok == SourceBitmap.GetLastStatus())
    {
        //
        // Get the image dimensions
        //
        UINT nSourceWidth = SourceBitmap.GetWidth();
        UINT nSourceHeight = SourceBitmap.GetHeight();
        if (nSourceWidth && nSourceHeight)
        {
            //
            // Create the target bitmap
            //
            Bitmap TargetBitmap( nSourceWidth, nSourceWidth );
            if (Ok == TargetBitmap.GetLastStatus())
            {
                //
                // Assume failure
                //
                bool bDrawSucceeded = false;

                //
                // Create a graphics object
                //
                Graphics *pGraphics = Graphics::FromImage(&TargetBitmap);
                if (pGraphics)
                {
                    //
                    // Make sure it is valid
                    //
                    if (pGraphics->GetLastStatus() == Ok)
                    {
                        //
                        // Flip the image, if they asked for a BMP
                        //
                        if (pTransCtx->guidFormatID == WiaImgFmt_BMP)
                        {
                            //
                            // Set up the parallelogram to flip the image
                            //
                            Point SourcePoints[3];
                            SourcePoints[0].X = 0;
                            SourcePoints[0].Y = nSourceHeight;
                            SourcePoints[1].X = nSourceWidth;
                            SourcePoints[1].Y = nSourceHeight;
                            SourcePoints[2].X = 0;
                            SourcePoints[2].Y = 0;

                            //
                            // Draw the image, flipped
                            //
                            if (pGraphics->DrawImage(&SourceBitmap, 
                                                     SourcePoints, 3) == Ok)
                            {
                                //
                                // We've got a good target image
                                //
                                bDrawSucceeded = true;
                            }
                        }
                        else
                        {
                            //
                            // Draw the image normally
                            //
                            if (pGraphics->DrawImage(&SourceBitmap,0,0) == Ok)
                            {
                                //
                                // We've got a good target image
                                //
                                bDrawSucceeded = true;
                            }
                        }
                    }
                    //
                    // Clean up our dynamically allocated graphics
                    //
                    delete pGraphics;
                }

                if (bDrawSucceeded)
                {
                    Rect rcTarget( 0, 0, nSourceWidth, nSourceHeight );
                    Gdiplus::BitmapData BitmapData;

                    //
                    // Get to the bits of the image
                    //
                    if (Ok == TargetBitmap.LockBits(&rcTarget, 
                                                    ImageLockModeRead, 
                                                    PixelFormat24bppRGB, 
                                                    &BitmapData))
                    {
                        if (bBanded)
                        {
                            //
                            // This will be our return value
                            //
                            hr = DoBandedTransfer(
                                     pTransCtx, 
                                     (PBYTE)BitmapData.Scan0, 
                                     (BitmapData.Stride * BitmapData.Height));
                        }
                        else
                        {
                            //
                            // This will be our return value
                            //
                            hr = DoTransfer(
                                    pTransCtx, 
                                    (PBYTE)BitmapData.Scan0, 
                                    (BitmapData.Stride * BitmapData.Height));
                        }

                        TargetBitmap.UnlockBits( &BitmapData );

                    }
                }
            }
        }
    }

    CHECK_S_OK(hr);
    return hr;
}



/*****************************************************************************

   CVideoUsd::LoadImageCB

   Loads an image one piece at a time.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::LoadImageCB(STILLCAM_IMAGE_CONTEXT    *pContext,
                          MINIDRV_TRANSFER_CONTEXT  *pTransCtx,
                          PLONG                     plDevErrVal)
{
    HRESULT hr = E_FAIL;

    DBG_FN("CVideoStiUsd::LoadImageCB");

    //
    // verify parameters
    //

    if ((pContext         == NULL) ||
        (pContext->pImage == NULL) ||
        (pTransCtx        == NULL))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::LoadImageCB received NULL params"));
        return hr;
    }

    if (pTransCtx->guidFormatID == WiaImgFmt_JPEG)
    {
        hr = StreamJPEGBits( pContext, pTransCtx, TRUE );
    }
    else if (pTransCtx->guidFormatID == WiaImgFmt_BMP)
    {
        hr = StreamBMPBits( pContext, pTransCtx, TRUE );
    }
    else if (pTransCtx->guidFormatID == WiaImgFmt_MEMORYBMP)
    {
        hr = StreamBMPBits( pContext, pTransCtx, TRUE );
    }
    else
    {
        DBG_ERR(("Asking for unsupported format"));
        return E_NOTIMPL;
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CVideoStiUsd::LoadImage

   Loads an image in a single transfer

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::LoadImage(STILLCAM_IMAGE_CONTEXT     *pContext,
                        MINIDRV_TRANSFER_CONTEXT   *pTransCtx,
                        PLONG                       plDevErrVal)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::LoadImage");

    //
    // verify some params
    //

    if ((pContext         == NULL) ||
        (pTransCtx        == NULL))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::LoadImage received NULL params"));
        return hr;
    }

    if ((pTransCtx->guidFormatID == WiaImgFmt_BMP))
    {
        hr = StreamBMPBits( pContext, pTransCtx, FALSE );
    }
    else if (pTransCtx->guidFormatID == WiaImgFmt_JPEG)
    {
        hr = StreamJPEGBits( pContext, pTransCtx, FALSE );
    }
    else
    {
        DBG_ERR(("Unsupported format"));
        return E_NOTIMPL;
    }

    CHECK_S_OK(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\usd\videousd.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998 - 2000
 *
 *  TITLE:       videousd.cpp
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      WilliamH (created)
 *               RickTu   (modified for WIA)
 *
 *  DATE:        9/7/99
 *
 *  DESCRIPTION: This module implements wiavideo.dll
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#include <advpub.h>

HINSTANCE g_hInstance;


/*****************************************************************************

   DllMain

   <Notes>

 *****************************************************************************/

BOOL
DllMain(HINSTANCE   hInstance,
        DWORD       dwReason,
        LPVOID      lpReserved)
{
    switch (dwReason)
    {

        case DLL_PROCESS_ATTACH:
            // 
            // Init the debug library
            // 
            DBG_INIT(hInstance);
    
            //
            // We do not need thread attach/detach calls
            //
    
            DisableThreadLibraryCalls(hInstance);
    
            //
            // Record what instance we are
            //
    
            g_hInstance = hInstance;
        break;
    
        case DLL_PROCESS_DETACH:
    
        break;

    }
    return TRUE;
}


/*****************************************************************************

   DllCanUnloadNow

   Let the outside world know when they can unload this dll

 *****************************************************************************/

STDAPI DllCanUnloadNow(void)
{
    return CVideoUsdClassFactory::CanUnloadNow();
}


/*****************************************************************************

   DllGetClassObject

   This is what the outside world calls to get an object of ours
   instantiated.

 *****************************************************************************/

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return CVideoUsdClassFactory::GetClassObject(rclsid, riid, ppv);
}



/*****************************************************************************

   Installs information in an .inf that is in our resource fork.

   <Notes>

 *****************************************************************************/


HRESULT InstallInfFromResource(HINSTANCE hInstance, 
                               LPCSTR    pszSectionName)
{
    HRESULT hr;
    HINSTANCE hInstAdvPackDll = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hInstAdvPackDll)
    {
        REGINSTALL pfnRegInstall = reinterpret_cast<REGINSTALL>(GetProcAddress( hInstAdvPackDll, "RegInstall" ));
        if (pfnRegInstall)
        {
#if defined(WINNT)
            STRENTRY astrEntry[] =
            {
                { "25", "%SystemRoot%"           },
                { "11", "%SystemRoot%\\system32" }
            };
            STRTABLE strTable = { sizeof(astrEntry)/sizeof(astrEntry[0]), astrEntry };
            hr = pfnRegInstall(hInstance, pszSectionName, &strTable);
#else
            hr = pfnRegInstall(hInstance, pszSectionName, NULL);
#endif
        } else hr = HRESULT_FROM_WIN32(GetLastError());
        FreeLibrary(hInstAdvPackDll);
    } else hr = HRESULT_FROM_WIN32(GetLastError());
    return hr;
}


/*****************************************************************************

   DllRegisterServer

   Register the objects we provide.

 *****************************************************************************/

STDAPI DllRegisterServer(void)
{

    return InstallInfFromResource( g_hInstance, "RegDll" );
}


/*****************************************************************************

   DllUnregisterServer

   Unregister the objects we provide.

 *****************************************************************************/

STDAPI DllUnregisterServer(void)
{
    return InstallInfFromResource( g_hInstance, "UnregDll" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\usd\sources.inc ===
!include          $(PROJECT_ROOT)\wia\wiaenv.inc

MAJORCOMP=STIUSD
MINORCOMP=Video

TARGETNAME=wiavusd
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=DYNLINK
TARGETEXT=dll
DLLENTRY=_DllMainCRTStartup

DLLDEF=..\wiavusd.def

        #Common include files


# Utilities flags

# External references
INCLUDES = $(INCLUDES); \
        $(PROJECT_ROOT)\inc\psutil; \
        $(SDK_INC_PATH)\atl30;                \
        $(SHELL_INC_PATH);\
        $(PROJECT_ROOT)\wia\drivers\video\filter; \
        $(PROJECT_ROOT)\wia\drivers\video\usd;


TARGETLIBS= \
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
        $(SDK_LIB_PATH)\gdi32.lib \
        $(SDK_LIB_PATH)\ole32.lib \
        $(SDK_LIB_PATH)\oleaut32.lib \
        $(SDK_LIB_PATH)\uuid.lib \
        $(SDK_LIB_PATH)\strmiids.lib \
        $(SDK_LIB_PATH)\wiaguid.lib \
        $(SDK_LIB_PATH)\gdiplus.lib \
        $(SDK_LIB_PATH)\shfolder.lib \
        $(DDK_LIB_PATH)\wiaservc.lib \
        $(WIA_LIB_PATH)\stirt.lib \
        $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\$(O)\psutil.lib

# Source files
SOURCES= \
     ..\itemtree.cpp \
     ..\transfer.cpp \
     ..\globals.cpp  \
     ..\image.cpp    \
     ..\minidrv.cpp  \
     ..\videousd.cpp \
     ..\vstiusd.cpp  \
     ..\videousd.rc



PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\usd\_simreg.cpp ===
#include <precomp.h>
#pragma hdrstop

#include <atlbase.h>
#include <wia.h>

#include "..\..\..\ui\uicommon\simreg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\usd\vstiusd.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999 - 2000
 *
 *  TITLE:       vstiusd.cpp
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      WilliamH (created)
 *               RickTu   (ported to WIA)
 *
 *  DATE:        9/7/99
 *
 *  DESCRIPTION: This module implements the CVideoStiUsd object &
 *               supported classes.
 *
 *****************************************************************************/


#include <precomp.h>
#pragma hdrstop

DEFINE_GUID(CLSID_VIDEO_STIUSD,0x0527d1d0, 0x88c2, 0x11d2, 0x82, 0xc7, 0x00, 0xc0, 0x4f, 0x8e, 0xc1, 0x83);


/*****************************************************************************

   CVideoUsdClassFactory constructor / desctructor

   <Notes>

 *****************************************************************************/

ULONG g_cDllRef = 0;

CVideoUsdClassFactory::CVideoUsdClassFactory()
{
}


/*****************************************************************************

   CVideoUsdClassFactory::QueryInterface

   Add our info to the base class QI code.

 *****************************************************************************/

STDMETHODIMP
CVideoUsdClassFactory::QueryInterface( REFIID riid, void **ppvObject)
{
    DBG_FN("CVideoUsdClassFactory::QueryInterface");

    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
    {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}


/*****************************************************************************

   CVideoUsdClassFactory::AddRef

   <Notes>

 *****************************************************************************/

STDMETHODIMP_(ULONG) CVideoUsdClassFactory::AddRef(void)
{
    DBG_FN("CVideoUsdClassFactory::AddRef");

    InterlockedIncrement((LONG *)&g_cDllRef);
    InterlockedIncrement((LONG *)&m_cRef);
    return m_cRef;
}


/*****************************************************************************

   CVideoUsdClassFactory::Release

   <Notes>

 *****************************************************************************/

STDMETHODIMP_(ULONG)
CVideoUsdClassFactory::Release(void)
{
    DBG_FN("CVideoUsdClassFactory::Release");

    InterlockedDecrement((LONG *)&g_cDllRef);
    InterlockedDecrement((LONG *)&m_cRef);

    if (m_cRef == 0) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}



/*****************************************************************************

   CVideoUsdClassFactory::CreateInstance

   Instantiate one of the objects we are responsible for.

 *****************************************************************************/

STDMETHODIMP
CVideoUsdClassFactory::CreateInstance(IUnknown  *pOuterUnk, 
                                      REFIID    riid, 
                                      void      **ppv)
{
    DBG_FN("CVideoUsdClassFactory::CreateInstance");

    //
    // Check for bad args
    //

    if (!ppv)
    {
        DBG_ERR(("ppv is NULL.  returning E_INVALIDARG"));
        return E_INVALIDARG;
    }

    *ppv = NULL;

    //
    // If it's not an interface we support, bail early
    //

    if (!IsEqualIID(riid, IID_IStiUSD)     &&
        !IsEqualIID(riid, IID_IWiaMiniDrv) &&
        !IsEqualIID(riid, IID_IUnknown))
    {
        return E_NOINTERFACE;
    }

    //
    // When created for aggregation, only IUnknown can be requested.
    //

    if (pOuterUnk &&
        !IsEqualIID(riid, IID_IUnknown))
    {
        return CLASS_E_NOAGGREGATION;
    }

    //
    // Create our Usd/Wia mini driver
    //

    CVideoStiUsd   *pUsd = NULL;
    HRESULT         hr;

    pUsd = new CVideoStiUsd(pOuterUnk);

    if (!pUsd) 
    {
        DBG_ERR(("Couldn't create new CVideoStiUsd class, "
                 "returning E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    hr = pUsd->PrivateInitialize();

    if (hr != S_OK) 
    {
        CHECK_S_OK2( hr, ("pUsd->PrivateInitialize" ));
        delete pUsd;
        return hr;
    }

    //  Move to the requested interface if we aren't aggregated.
    //  Don't do this if aggregated, or we will lose the private
    //  IUnknown and then the caller will be hosed.

    hr = pUsd->NonDelegatingQueryInterface(riid, ppv);
    CHECK_S_OK2( hr, ("pUsd->NonDelegatingQueryInterface" ));

    pUsd->NonDelegatingRelease();

    return hr;
}


/*****************************************************************************

   CVideoUsdClassFactory::LockServer

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoUsdClassFactory::LockServer(BOOL fLock)
{
    DBG_FN("CVideoUsdClassFactory::LockServer");

    if (fLock)
    {
        InterlockedIncrement((LONG*)&g_cDllRef);
    }
    else
    {
        InterlockedDecrement((LONG*)&g_cDllRef);
    }

    return S_OK;
}


/*****************************************************************************

   CVideoUsdClassFactory::GetClassObject

   <Notes>

 *****************************************************************************/

HRESULT
CVideoUsdClassFactory::GetClassObject(REFCLSID rclsid, 
                                      REFIID   riid, 
                                      void     **ppv)
{
    DBG_FN("CVideoUsdClassFactory::GetClassObject");

    if (!ppv)
    {
        return E_INVALIDARG;
    }

    if (rclsid == CLSID_VIDEO_STIUSD &&
        (riid == IID_IUnknown || riid == IID_IClassFactory))
    {
        CVideoUsdClassFactory *pFactory = NULL;

        pFactory = new CVideoUsdClassFactory();

        if (pFactory)
        {
            *ppv = pFactory;
            pFactory->AddRef();
            return S_OK;
        }
        else
        {
            *ppv = NULL;
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


/*****************************************************************************

   CVideoUsdClassFactory::CanUnloadNow

   Lets the outside world know if we can be unloaded.

 *****************************************************************************/

HRESULT
CVideoUsdClassFactory::CanUnloadNow()
{
    DBG_FN("CVideoUsdClassFactory::CanUnloadNow");

    return (0 == g_cDllRef) ? S_OK : S_FALSE;
}


/*****************************************************************************

   CVideoStiUsd constructor/destructor

   <Notes>

 *****************************************************************************/

CVideoStiUsd::CVideoStiUsd(IUnknown * pUnkOuter)
 :  m_bDeviceIsOpened(FALSE),
    m_lPicsTaken(0),
    m_hTakePictureEvent(NULL),
    m_hPictureReadyEvent(NULL),
    m_pTakePictureOwner(NULL),
    m_pLastItemCreated(NULL),
    m_dwConnectedApps(0),
    m_cRef(1)
{
    //
    // See if we are aggregated. If we are (almost always the case) save
    // pointer to the controlling Unknown , so subsequent calls will be
    // delegated. If not, set the same pointer to "this".
    //

    if (pUnkOuter)
    {
        m_pUnkOuter = pUnkOuter;
    }
    else
    {
        //
        // Cast below is needed in order to point to right virtual table
        //

        m_pUnkOuter = reinterpret_cast<IUnknown*>
                      (static_cast<INonDelegatingUnknown*>
                      (this));
    }

}

HRESULT CVideoStiUsd::PrivateInitialize()
{
    HRESULT hr = S_OK;
    
    HANDLE hThread = NULL;
    DWORD  dwId    = 0;

    //
    // Set up some global info
    //

    m_wfi = (WIA_FORMAT_INFO*) CoTaskMemAlloc(sizeof(WIA_FORMAT_INFO) * 
                                              NUM_WIA_FORMAT_INFO);

    if (m_wfi)
    {
        //
        //  Set up the format/tymed pairs
        //

        m_wfi[0].guidFormatID = WiaImgFmt_JPEG;
        m_wfi[0].lTymed = TYMED_CALLBACK;

        m_wfi[1].guidFormatID = WiaImgFmt_JPEG;
        m_wfi[1].lTymed = TYMED_FILE;

        m_wfi[2].guidFormatID = WiaImgFmt_MEMORYBMP;
        m_wfi[2].lTymed = TYMED_CALLBACK;

        m_wfi[3].guidFormatID = WiaImgFmt_BMP;
        m_wfi[3].lTymed = TYMED_CALLBACK;

        m_wfi[4].guidFormatID = WiaImgFmt_BMP;
        m_wfi[4].lTymed = TYMED_FILE;
    }

    //
    // Initialize critical sections
    //

    __try 
    {
        if (!InitializeCriticalSectionAndSpinCount(&m_csItemTree, MINLONG))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DBG_ERR(("ERROR: Failed to initialize one of critsections "
                     "(0x%08X)", 
                     hr));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        hr = E_OUTOFMEMORY;
    }

    //
    // Initialize GDI+
    //

    Gdiplus::Status                 StatusResult     = Gdiplus::Ok;
    Gdiplus::GdiplusStartupInput    StartupInput;
    m_ulGdiPlusToken = NULL;

    if (hr == S_OK) 
    {
        StatusResult = Gdiplus::GdiplusStartup(&m_ulGdiPlusToken,
                                               &StartupInput,
                                               NULL);

        if (StatusResult != Gdiplus::Ok)
        {
            DBG_ERR(("ERROR: Failed to start up GDI+, Status code returned "
                     "by GDI+ = '%d'",
                     StatusResult));

            hr = HRESULT_FROM_WIN32(StatusResult);
        }
    }

    return hr;
}

CVideoStiUsd::~CVideoStiUsd()
{

    if (m_pRootItem)
    {
        HRESULT hr = S_OK;

        DBG_TRC(("CVideoStiUsd::~CVideoStiUsd, driver is being destroyed, "
                 "and for some reason the tree still exists, deleting tree..."));

        hr = m_pRootItem->UnlinkItemTree(WiaItemTypeDisconnected);

        // Clear the root item
        m_pRootItem = NULL;
    }

    //
    // Disable Take Picture command.
    //
    DisableTakePicture(NULL, TRUE);

    //
    // Shutdown GDI+
    //
    Gdiplus::GdiplusShutdown(m_ulGdiPlusToken);

    CloseDevice();

    if (m_wfi)
    {
        CoTaskMemFree( (LPVOID)m_wfi );
        m_wfi = NULL;
    }

    DeleteCriticalSection(&m_csItemTree);
}


/*****************************************************************************

   CVideoStiUsd::NonDelegatingQueryInterface

   This is the inner object QI -- in other words, handle QI's for the
   interfaces our object supports.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::NonDelegatingQueryInterface(REFIID  riid, 
                                          LPVOID  *ppvObj )
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::NonDelegatingQueryInterface");

    //
    // Check for invalid args
    //

    if (!ppvObj)
    {
        DBG_ERR(("ppvObj is NULL, returning E_INVALIDARG"));
        return E_INVALIDARG;
    }

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = static_cast<INonDelegatingUnknown*>(this);
    }
    else if (IsEqualIID(riid, IID_IStiUSD))
    {
        *ppvObj = static_cast<IStiUSD*>(this);
    }
    else if (IsEqualIID(riid, IID_IWiaMiniDrv))
    {
        *ppvObj = static_cast<IWiaMiniDrv*>(this);
    }
    else
    {
        hr =  E_NOINTERFACE;
        DBG_ERR(("CVideoStiUsd::NonDelegatingQueryInterface requested "
                 "interface we don't support, returning hr = 0x%08lx", hr));
    }

    if (SUCCEEDED(hr)) 
    {
        (reinterpret_cast<IUnknown*>(*ppvObj))->AddRef();
    }

    CHECK_S_OK(hr);
    return hr;
}



/*****************************************************************************

   CVideoStiUsd::NonDelegatingAddRef

   This is the inner object AddRef -- actually inc the ref count
   for our interfaces.

 *****************************************************************************/

STDMETHODIMP_(ULONG)
CVideoStiUsd::NonDelegatingAddRef(void)
{
    DBG_FN("CVideoStiUsd::NonDelegatingAddRef");

    return InterlockedIncrement((LPLONG)&m_cRef);
}



/*****************************************************************************

   CVideoStiUsd::NonDelegatingRelease

   This is the inner object Release -- actually dec the ref count
   for our interfaces.

 *****************************************************************************/

STDMETHODIMP_(ULONG)
CVideoStiUsd::NonDelegatingRelease(void)
{
    DBG_FN("CVideoStiUsd::NonDelegatingRelease");

    ULONG ulRef = 0;

    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if (!ulRef) 
    {
        delete this;
    }

    return ulRef;
}


/*****************************************************************************

   CVideoStiUsd::QueryInterface

   Outer QI -- used for aggregation

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    DBG_FN("CVideoStiUsd::QueryInterface");

    return m_pUnkOuter->QueryInterface( riid, ppvObj );
}


/*****************************************************************************

   CVideoStiUsd::AddRef

   Outer AddRef -- used for aggregation

 *****************************************************************************/

STDMETHODIMP_(ULONG)
CVideoStiUsd::AddRef(void)
{
    DBG_FN("CVideoStiUsd::AddRef");
    return m_pUnkOuter->AddRef();
}


/*****************************************************************************

   CVideoStiUsd::Release

   Outer Release -- used for aggregation

 *****************************************************************************/

STDMETHODIMP_(ULONG)
CVideoStiUsd::Release(void)
{
    DBG_FN("CVideoStiUsd::Release");
    return m_pUnkOuter->Release();
}


/*****************************************************************************

   CVideoStiUsd::Initialize [IStillUsd]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::Initialize(PSTIDEVICECONTROL pDcb,
                         DWORD             dwStiVersion,
                         HKEY              hParameterKey)
{
    DBG_FN("CVideoStiUsd::Initialize");

    HRESULT hr = S_OK;
    WCHAR DeviceName[MAX_PATH] = {0};

    if ((pDcb == NULL) || (hParameterKey == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CVideoStiUsd::Initialize, received a "
                         "NULL pointer, either 'pDcb = 0x%08lx' is NULL "
                         "or 'hParameterKey = 0x%08lx' is NULL",
                         pDcb, hParameterKey));
    }

    if (hr == S_OK)
    {
        //
        // get the device symbolic name. We use the name to get an IMoniker to
        // the device filter proxy.
        //
        hr = pDcb->GetMyDevicePortName(DeviceName, 
                                       sizeof(DeviceName)/sizeof(WCHAR));

        if (SUCCEEDED(hr))
        {
            hr = OpenDevice(DeviceName);
        }
    }

    if (hr == S_OK)
    {
        HKEY    hKey    = NULL;
        DWORD   dwType  = 0;
        LRESULT lResult = ERROR_SUCCESS;
        TCHAR   szValue[MAX_PATH + 1] = {0};
        DWORD   dwSize  = sizeof(szValue) - sizeof(szValue[0]);

        lResult = RegOpenKeyEx(hParameterKey, 
                               TEXT("DeviceData"),
                               0, 
                               KEY_READ, 
                               &hKey);

        if (lResult == ERROR_SUCCESS)
        {
            //
            // Read DShow device ID from DeviceData registry
            //
            lResult = RegQueryValueEx(hKey, 
                                      TEXT("DShowDeviceId"), 
                                      NULL,
                                      &dwType, 
                                      (BYTE*) szValue,
                                      &dwSize);

            szValue[sizeof(szValue) / sizeof(szValue[0]) - 1] = '\0';
        }

        if (hKey)
        {
            RegCloseKey(hKey);
            hKey = NULL;
        }

        if (lResult == ERROR_SUCCESS)
        {
            m_strDShowDeviceId = szValue;
        }
        else
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr, ("CVideoStiUsd::Initialize, failed to retrieve the "
                             "DShow Device ID."));
        }
    }

    return hr;
}


/*****************************************************************************

   CVideoStiUsd::CloseDevice [IStillUsd]

   <Notes>

 *****************************************************************************/

HRESULT
CVideoStiUsd::CloseDevice()
{
    DBG_FN("CVideoStiUsd::CloseDevice");

    m_bDeviceIsOpened = FALSE;

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::OpenDevice [IStillUsd]

   <Notes>

 *****************************************************************************/

HRESULT
CVideoStiUsd::OpenDevice(LPCWSTR DeviceName)
{
    DBG_FN("CVideoStiUsd::OpenDevice");

    //
    // Check for bad args
    //

    if (!DeviceName || (0 == *DeviceName))
    {
        return E_INVALIDARG;
    }


    m_bDeviceIsOpened = TRUE;

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::GetCapabilities [IStillUsd]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::GetCapabilities(PSTI_USD_CAPS pDevCaps)
{
    DBG_FN("CVideoStiUsd::GetCapabilities");

    //
    // Check for bad args
    //

    if (!pDevCaps)
    {
        return E_INVALIDARG;
    }


    memset(pDevCaps, 0, sizeof(STI_USD_CAPS));

    pDevCaps->dwVersion     = STI_VERSION;
    pDevCaps->dwGenericCaps = STI_USD_GENCAP_NATIVE_PUSHSUPPORT;

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::GetStatus [IStillUsd]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::GetStatus(PSTI_DEVICE_STATUS pDevStatus)
{
    DBG_FN("CVideoStiUsd::GetStatus");

    if (!pDevStatus)
    {
        return E_INVALIDARG;
    }

    if (pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE )
    {
        if (m_bDeviceIsOpened)
        {
            pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
        }
        else
        {
            pDevStatus->dwOnlineState &= ~STI_ONLINESTATE_OPERATIONAL;
        }
    }

    return S_OK;
}



/*****************************************************************************

   CVideoStiUsd::DeviceReset [IStillUsd]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::DeviceReset()
{
    DBG_FN("CVideoStiUsd::DeviceReset");

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::Diagnostic [IStillUsd]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::Diagnostic(LPSTI_DIAG pStiDiag)
{
    DBG_FN("CVideoStiUsd::Diagnostic");

    //
    // Check for bad args
    //

    if (!pStiDiag)
    {
        return E_INVALIDARG;
    }

    //
    // Return diag info
    //

    pStiDiag->dwStatusMask = 0;
    memset(&pStiDiag->sErrorInfo, 0, sizeof(pStiDiag->sErrorInfo));

    if (m_bDeviceIsOpened)
    {
        pStiDiag->sErrorInfo.dwGenericError = NOERROR;
    }
    else
    {
        pStiDiag->sErrorInfo.dwGenericError = STI_NOTCONNECTED;
    }

    pStiDiag->sErrorInfo.dwVendorError = 0;

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::Escape [IStillUsd]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::Escape(STI_RAW_CONTROL_CODE Function,
                     LPVOID               DataIn,
                     DWORD                DataInSize,
                     LPVOID               DataOut,
                     DWORD                DataOutSize,
                     DWORD                *pActualSize)
{

    DBG_FN("CVideoStiUsd::Escape");

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::GetLastError [IStillUsd]

   Not implemented yet.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::GetLastError(LPDWORD pLastError)
{
    DBG_FN("CVideoStiUsd::GetLastError( NOT_IMPL )");

    return E_NOTIMPL;
}


/*****************************************************************************

   CVideoStiUsd::LockDevice [IStillUsd]

   No actual locking of the device has to happen, so just return success.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::LockDevice()
{
    DBG_FN("CVideoStiUsd::LockDevice");

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::UnLockDevice [IStillUsd]

   No actual locking/unlocking of the device has to happen, so just return
   success.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::UnLockDevice()
{
    DBG_FN("CVideoStiUsd::UnlockDevice");

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::RawReadData [IStillUsd]

   Not implemented yet.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::RawReadData(LPVOID        Buffer,
                          LPDWORD       BufferSize,
                          LPOVERLAPPED  lpOverlapped)
{
    DBG_FN("CVideoStiUsd::RawReadData( NOT_IMPL )");

    return E_NOTIMPL;
}


/*****************************************************************************

   CVideoStiUsd::RawWriteData [IStillUsd]

   Not implemented yet.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::RawWriteData(LPVOID Buffer,
                           DWORD BufferSize,
                           LPOVERLAPPED lpOverlapped)
{
    DBG_FN("CVideoStiUsd::RawWriteData( NOT_IMPL )");

    return E_NOTIMPL;
}


/*****************************************************************************

   CVideoStiUsd::RawReadCommand [IStillUsd]

   Not implemented yet.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::RawReadCommand(LPVOID Buffer,
                             LPDWORD BufferSize,
                             LPOVERLAPPED lpOverlapped)
{
    DBG_FN("CVideoStiUsd::RawReadCommand( NOT_IMPL )");

    return E_NOTIMPL;
}


/*****************************************************************************

   CVideoStiUsd::RawWriteCommand [IStillUsd]

   Not implemented yet.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::RawWriteCommand(LPVOID Buffer,
                              DWORD BufferSize,
                              LPOVERLAPPED lpOverlapped)
{
    DBG_FN("CVideoStiUsd::RawWriteCommand( NOT_IMPL )");

    return E_NOTIMPL;
}


/*****************************************************************************

   CVideoStiUsd::SetNotificationHandle [IStillUsd]

   Sets the event notification handle.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::SetNotificationHandle(HANDLE hEvent)
{
    DBG_FN("CVideoStiUsd::SetNotificationHandle");

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::GetNotificationData [IStillUsd]

   Returns the current event notification handle.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::GetNotificationData(LPSTINOTIFY lpNotify)
{
    DBG_FN("CVideoStiUsd::GetNotificationData");

    HRESULT hr = STIERR_NOEVENTS;

    DBG_ERR(("We were called, but no events are present -- why?"));

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CVideoStiUsd::GetLastErrorInfo [IStillUsd]

   Not implemented yet.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
{
    DBG_FN("CVideoStiUsd::GetLastErrorInfo( NOT_IMPL )");

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\video\usd\vstiusd.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999 - 2000
 *
 *  TITLE:       vstiusd.h
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      WilliamH (original for Twain)
 *               RickTu (port for WIA)
 *
 *  DATE:       9/16/99
 *
 *  DESCRIPTION: Header file that decalres CVideoSTiUsd class and other
 *               needed classes.
 *
 *****************************************************************************/


#ifndef _WIA_STILL_DRIVER_VSTIUSD_H_
#define _WIA_STILL_DRIVER_VSTIUSD_H_

extern HINSTANCE g_hInstance;
extern ULONG     g_cDllRef;

#define NUM_WIA_FORMAT_INFO 5

HRESULT FindEncoder(const GUID &guidFormat, CLSID *pClsid);

//
// Base class for supporting non-delegating IUnknown for contained objects
//

struct INonDelegatingUnknown
{
    // *** IUnknown-like methods ***
    STDMETHOD(NonDelegatingQueryInterface)( THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease)( THIS) PURE;
};


///////////////////////////////
// CVideoUsdClassFactory
//
class CVideoUsdClassFactory : public IClassFactory
{
private:
    ULONG m_cRef;

public:
    CVideoUsdClassFactory();

    //
    // Declare IUnknown methods
    //

    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);

    //
    // IClassFactory implemenation
    //
    STDMETHODIMP LockServer(BOOL fLock);
    STDMETHODIMP CreateInstance(IUnknown *pOuterUnk, REFIID riid, void **ppv);

    static HRESULT GetClassObject(REFCLSID rclsid, REFIID riid, void **ppv);
    static HRESULT CanUnloadNow();
};


///////////////////////////////
// CVideoStiUsd
//
class CVideoStiUsd : public IStiUSD,
                     public IWiaMiniDrv,
                     public INonDelegatingUnknown
                     
{
public:
    CVideoStiUsd(IUnknown * pUnkOuter);
    HRESULT PrivateInitialize();
    ~CVideoStiUsd();

    //
    // Real IUnknown methods
    //

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

    //
    // Aggregate IUnknown methods
    //

    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IStillUsd implementation
    //
    STDMETHODIMP Initialize(PSTIDEVICECONTROL pDcb, DWORD dwStiVersion, HKEY hParameterKey);
    STDMETHODIMP GetCapabilities(PSTI_USD_CAPS pDevCaps);
    STDMETHODIMP GetStatus(PSTI_DEVICE_STATUS pDevStatus);
    STDMETHODIMP DeviceReset();
    STDMETHODIMP Diagnostic(LPSTI_DIAG pBuffer);
    STDMETHODIMP Escape(STI_RAW_CONTROL_CODE Function, LPVOID DataIn, DWORD DataInSize, LPVOID DataOut, DWORD DataOutSize, DWORD *pActualSize);
    STDMETHODIMP GetLastError(LPDWORD pLastError);
    STDMETHODIMP LockDevice();
    STDMETHODIMP UnLockDevice();
    STDMETHODIMP RawReadData(LPVOID Buffer, LPDWORD BufferSize, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawWriteData(LPVOID Buffer, DWORD BufferSize, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawReadCommand(LPVOID Buffer, LPDWORD BufferSize, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawWriteCommand(LPVOID Buffer, DWORD BufferSize, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP SetNotificationHandle(HANDLE hEvent);
    STDMETHODIMP GetNotificationData(LPSTINOTIFY lpNotify);
    STDMETHODIMP GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo);

    //
    // IWiaMiniDrv methods
    //

    STDMETHOD(drvInitializeWia)(THIS_
        BYTE*                       pWiasContext,
        LONG                        lFlags,
        BSTR                        bstrDeviceID,
        BSTR                        bstrRootFullItemName,
        IUnknown                   *pStiDevice,
        IUnknown                   *pIUnknownOuter,
        IWiaDrvItem               **ppIDrvItemRoot,
        IUnknown                  **ppIUnknownInner,
        LONG                       *plDevErrVal);

    STDMETHOD(drvGetDeviceErrorStr)(THIS_
        LONG                        lFlags,
        LONG                        lDevErrVal,
        LPOLESTR                   *ppszDevErrStr,
        LONG                       *plDevErr);

    STDMETHOD(drvDeviceCommand)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        const GUID                 *pGUIDCommand,
        IWiaDrvItem               **ppMiniDrvItem,
        LONG                       *plDevErrVal);

    STDMETHOD(drvAcquireItemData)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        PMINIDRV_TRANSFER_CONTEXT   pDataContext,
        LONG                       *plDevErrVal);

    STDMETHOD(drvInitItemProperties)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *plDevErrVal);

    STDMETHOD(drvValidateItemProperties)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        ULONG                       nPropSpec,
        const PROPSPEC             *pPropSpec,
        LONG                       *plDevErrVal);

    STDMETHOD(drvWriteItemProperties)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFLags,
        PMINIDRV_TRANSFER_CONTEXT   pmdtc,
        LONG                       *plDevErrVal);

    STDMETHOD(drvReadItemProperties)(THIS_
        BYTE                       *pWiaItem,
        LONG                        lFlags,
        ULONG                       nPropSpec,
        const PROPSPEC             *pPropSpec,
        LONG                       *plDevErrVal);

    STDMETHOD(drvLockWiaDevice)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *plDevErrVal);

    STDMETHOD(drvUnLockWiaDevice)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *plDevErrVal );

    STDMETHOD(drvAnalyzeItem)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *plDevErrVal);

    STDMETHOD(drvDeleteItem)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *plDevErrVal);

    STDMETHOD(drvFreeDrvItemContext)(THIS_
        LONG                        lFlags,
        BYTE                       *pDevContext,
        LONG                       *plDevErrVal);

    STDMETHOD(drvGetCapabilities)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *pCelt,
        WIA_DEV_CAP_DRV           **ppCapabilities,
        LONG                       *plDevErrVal);

    STDMETHOD(drvGetWiaFormatInfo)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *pCelt,
        WIA_FORMAT_INFO            **ppwfi,
        LONG                       *plDevErrVal);

    STDMETHOD(drvNotifyPnpEvent)(THIS_
        const GUID                 *pEventGUID,
        BSTR                        bstrDeviceID,
        ULONG                       ulReserved);

    STDMETHOD(drvUnInitializeWia)(THIS_
        BYTE*);


    //
    // Utility functions
    //

    STDMETHOD(BuildItemTree)(IWiaDrvItem **ppIDrvItemRoot, LONG *plDevErrVal);
    STDMETHOD(RefreshTree)(IWiaDrvItem *pIDrvItemRoot, LONG *plDevErrVal);
    STDMETHOD(EnumSavedImages)(IWiaDrvItem *pRootItem);
    STDMETHOD(CreateItemFromFileName)(LONG FolderType,LPCTSTR pszPath,LPCTSTR pszName,IWiaDrvItem **ppNewFolder);
    STDMETHOD(InitDeviceProperties)(BYTE *pWiasContext, LONG *plDevErrVal);
    STDMETHOD(InitImageInformation)(BYTE *pWiasContext, PSTILLCAM_IMAGE_CONTEXT pContext, LONG *plDevErrVal);
    STDMETHOD(SendBitmapHeader)( IWiaDrvItem *pDrvItem, PMINIDRV_TRANSFER_CONTEXT pTranCtx);
    STDMETHOD(ValidateDataTransferContext)(PMINIDRV_TRANSFER_CONTEXT  pDataTransferContext);
    STDMETHOD(LoadImageCB)(STILLCAM_IMAGE_CONTEXT *pContext,MINIDRV_TRANSFER_CONTEXT *pTransCtx, PLONG plDevErrVal);
    STDMETHOD(LoadImage)(STILLCAM_IMAGE_CONTEXT *pContext,MINIDRV_TRANSFER_CONTEXT *pTransCtx, PLONG plDevErrVal);
    STDMETHODIMP_(VOID) HandleNewBits(HGLOBAL hDib,IWiaDrvItem **ppItem);
    STDMETHOD(DoBandedTransfer)(MINIDRV_TRANSFER_CONTEXT *pTransCtx,PBYTE pSrc,LONG lBytesToTransfer);
    STDMETHOD(DoTransfer)(MINIDRV_TRANSFER_CONTEXT *pTransCtx,PBYTE pSrc,LONG lBytesToTransfer);
    STDMETHOD(StreamJPEGBits)(STILLCAM_IMAGE_CONTEXT *pContext, MINIDRV_TRANSFER_CONTEXT *pTransCtx, BOOL bBanded);
    STDMETHOD(StreamBMPBits)(STILLCAM_IMAGE_CONTEXT *pContext, MINIDRV_TRANSFER_CONTEXT *pTransCtx, BOOL bBanded);


private:

    //
    // IStiUSD stuff
    //

    HRESULT     OpenDevice(LPCWSTR DeviceName);
    HRESULT     CloseDevice();

    //
    // Misc functions
    //

    HRESULT VerifyCorrectImagePath(BSTR bstrNewImageFullPath);

    HRESULT SignalNewImage(BSTR bstrNewImageFullPath);

    BOOL FindCaptureFilter( LPCTSTR             pszDeviceId,
                            CComPtr<IMoniker> & pCaptureFilterMoniker );

    BOOL DoesFileExist(BSTR bstrFileName);
    BOOL IsFileAlreadyInTree( IWiaDrvItem * pRootItem,
                              LPCTSTR       pszFileName );

    HRESULT PruneTree( IWiaDrvItem * pRootItem,
                       BOOL        * pbTreeChanged );

    HRESULT AddNewFilesToTree( IWiaDrvItem * pRootItem,
                               BOOL        * pbTreeChanged );

    HRESULT AddTreeItem(CSimpleString *pstrFullImagePath,
                        IWiaDrvItem   **ppDrvItem);

    HRESULT SetImagesDirectory(BSTR           bstrNewImagesDirectory,
                               BYTE           *pWiasContext,
                               IWiaDrvItem    **ppIDrvItemRoot,
                               LONG           *plDevErrVal);

    HRESULT ValidateItemProperties(BYTE *             pWiasContext,
                                   LONG               lFlags,
                                   ULONG              nPropSpec,
                                   const PROPSPEC *   pPropSpec,
                                   LONG *             plDevErrVal,
                                   IWiaDrvItem *      pDrvItem);

        
    HRESULT ValidateDeviceProperties(BYTE *             pWiasContext,
                                     LONG               lFlags,
                                     ULONG              nPropSpec,
                                     const PROPSPEC *   pPropSpec,
                                     LONG *             plDevErrVal,
                                     IWiaDrvItem *      pDrvItem);

    HRESULT ReadItemProperties(BYTE *             pWiasContext,
                               LONG               lFlags,
                               ULONG              nPropSpec,
                               const PROPSPEC *   pPropSpec,
                               LONG *             plDevErrVal,
                               IWiaDrvItem *      pDrvItem);


    HRESULT ReadDeviceProperties(BYTE *             pWiasContext,
                                 LONG               lFlags,
                                 ULONG              nPropSpec,
                                 const PROPSPEC *   pPropSpec,
                                 LONG *             plDevErrVal,
                                 IWiaDrvItem *      pDrvItem);


    HRESULT EnableTakePicture(BYTE *pTakePictureOwner);
    HRESULT TakePicture(BYTE *pTakePictureOwner, IWiaDrvItem ** ppNewDrvItem);
    HRESULT DisableTakePicture(BYTE *pTakePictureOwner, BOOL bShuttingDown);

    //
    // IWiaMiniDrv stuff
    //

    CSimpleStringWide       m_strDeviceId;
    CSimpleStringWide       m_strRootFullItemName;
    CSimpleStringWide       m_strStillPath;
    CSimpleStringWide       m_strDShowDeviceId;
    CSimpleStringWide       m_strLastPictureTaken;
    CRITICAL_SECTION        m_csItemTree;

    CComPtr<IWiaDrvItem>    m_pRootItem;
    CComPtr<IStiDevice>     m_pStiDevice;
    WIA_FORMAT_INFO *       m_wfi;
    LONG                    m_lPicsTaken;
    HANDLE                  m_hTakePictureEvent;
    HANDLE                  m_hPictureReadyEvent;
    ULONG_PTR               m_ulGdiPlusToken;
    IWiaDrvItem *           m_pLastItemCreated;  // only valid while inside m_csSnapshot
    BYTE *                  m_pTakePictureOwner;

    DWORD                   m_dwConnectedApps;

    //
    // IUnknown stuff
    //

    ULONG       m_cRef;                 // Device object reference count.
    LPUNKNOWN   m_pUnkOuter;            // Pointer to outer unknown.


    //
    // IStiUSD stuff
    //
    BOOL        m_bDeviceIsOpened;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\apiutil.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stiapi.h

Abstract:

    Various definitions and constants, needed for internal client/server API interface

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/

#ifndef _APIUTIL_H_
#define _APIUTIL_h_

# ifdef __cplusplus
extern "C"   {
# endif // __cplusplus


#ifdef MIDL_PASS
#define RPC_STATUS      long
#define STI_API_STATUS  long
#define STI_API_FUNCTION stdcall
#else
# include <rpc.h>
#endif // MIDL_PASS

//
//  RPC utilities
//

//
// COnnection options for named-pipe transport
//
# define PROT_SEQ_NP_OPTIONS_W    L"Security=Impersonation Dynamic False"

//
// Transport sequences
//
//#define  IRPC_LRPC_SEQ    "mswmsg"
#define STI_LRPC_SEQ        TEXT("ncalrpc")

//
// Interface name for named-pipe transport
//
#define STI_INTERFACE       "\\pipe\\stiapis"
#define STI_INTERFACE_W     L"\\pipe\\stiapis"
//
// Local RPC end-point
//
#define STI_LRPC_ENDPOINT   TEXT("STI_LRPC")
#define STI_LRPC_ENDPOINT_W L"STI_LRPC"

//
// Local RPC max concurrent calls
//
#define STI_LRPC_MAX_REQS   RPC_C_LISTEN_MAX_CALLS_DEFAULT

//
// Number of concurrent RPC threads
//
#define STI_LRPC_THREADS            1


//
// Useful types
//
#ifdef UNICODE
typedef unsigned short *RPC_STRING ;
#else
typedef unsigned char *RPC_STRING ;

#endif

extern PVOID
MIDL_user_allocate( IN size_t Size);

extern VOID
MIDL_user_free( IN PVOID pvBlob);

extern RPC_STATUS
RpcBindHandleForServer( OUT handle_t * pBindingHandle,
                       IN LPWSTR      pwszServerName,
                       IN LPWSTR      pwszInterfaceName,
                       IN LPWSTR      pwszOptions
                       );

extern RPC_STATUS
RpcBindHandleFree( IN OUT handle_t * pBindingHandle);

# ifdef __cplusplus
};
# endif // __cplusplus


#endif // _APIUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\asyncrpceventtransport.h ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        3/22/2002
 *
 *  @doc    INTERNAL
 *
 *  @module AsyncRPCEventTransport.h - Definitions for the client-side transport mechanism to receive events |
 *
 *  This header file contains the definition for the AsyncRPCEventTransport
 *  class.  It is a subclss of <c ClientEventTransport> and is used to shield 
 *  the higher-level run-time event notification classes from the particulars
 *  of a specific transport mechanism, in this case AsyncRPC.
 *
 *****************************************************************************/

//
//  Defines
//

#define DEF_LRPC_SEQ        TEXT("ncalrpc")
#define DEF_LRPC_ENDPOINT   TEXT("WET_LRPC")

#define AsyncRPCEventTransport_UNINIT_SIG ClientEventTransport_UNINIT_SIG
#define AsyncRPCEventTransport_INIT_SIG   ClientEventTransport_INIT_SIG
#define AsyncRPCEventTransport_TERM_SIG   ClientEventTransport_TERM_SIG
#define AsyncRPCEventTransport_DEL_SIG    ClientEventTransport_DEL_SIG

/*****************************************************************************
 *  
 *  @doc INTERNAL
 *  
 *  @class AsyncRPCEventTransport | Implements an event notification mechanism over AsyncRPC.
 *  
 *  @comm
 *  This is a sub-class of <c ClientEventTransport>.  It is used to shield the higher-level 
 *  run-time event notification classes from the implmentation details of 
 *  AsyncRPC as a transport mechanism.
 *
 *  NOTE:  Most methods of this class are not thread safe.  The caller of this
 *  class is expected to synchronize access to it.
 *
 *****************************************************************************/
class AsyncRPCEventTransport : public ClientEventTransport
{
//@access Public members
public:

    // @cmember Constructor
    AsyncRPCEventTransport();
    // @cmember Destructor
    virtual ~AsyncRPCEventTransport();

    // @cmember Connect to the WIA Service
    HRESULT virtual OpenConnectionToServer();
    // @cmember Disconnect from the WIA Service
    HRESULT virtual CloseConnectionToServer();
    // @cmember Sets up the mechanism by which the client will receive notifications
    HRESULT virtual OpenNotificationChannel();
    // @cmember Tears down the mechanism by which the client receives notifications
    HRESULT virtual CloseNotificationChannel();

    // @cmember Informs service of client's specific registration/unregistration requests
    HRESULT virtual SendRegisterUnregisterInfo(EventRegistrationInfo *pEventRegistrationInfo);

    // @cmember Once an event occurs, this will retrieve the relevant data
    HRESULT virtual FillEventData(WiaEventInfo *pWiaEventInfo);

//@access Private members
protected:
                                                                                          
    // @cmember Frees any memory allocated for the members in <md AsyncRPCEventTransport::m_AsyncEventNotifyData>.
    VOID FreeAsyncEventNotifyData();

    // @cmember Keeps track of the outstanding AsyncRPC Call used to receive notifications
    RPC_ASYNC_STATE m_AsyncState;

    // @cmember This member is filled in by the server when the AsyncRPC call completes
    WIA_ASYNC_EVENT_NOTIFY_DATA m_AsyncEventNotifyData;

    // @cmember Handle to the RPC server from which we receive event notifications
    RPC_BINDING_HANDLE m_RpcBindingHandle;

    // @cmember Our context which uniquely identifies us with the server.
    STI_CLIENT_CONTEXT m_AsyncClientContext;
    // @cmember Our context which uniquely identifies us with the server.
    STI_CLIENT_CONTEXT m_SyncClientContext;

    //
    //  Comments for member variables
    //
    // @mdata ULONG | AsyncRPCEventTransport | m_ulSig | 
    //   The signature for this class, used for debugging purposes.
    //   Doing a <nl>"db [addr_of_class]"<nl> would yield one of the following
    //   signatures for this class:
    //   @flag AsyncRPCEventTransport_UNINIT_SIG | 'TrnU' - Object has not been successfully
    //       initialized
    //   @flag AsyncRPCEventTransport_INIT_SIG | 'TrnI' - Object has been successfully
    //       initialized
    //   @flag AsyncRPCEventTransport_TERM_SIG | 'TrnT' - Object is in the process of
    //       terminating.
    //    @flag AsyncRPCEventTransport_INIT_SIG | 'TrnD' - Object has been deleted 
    //       (destructor was called)
    //
    //
    // @mdata HANDLE | AsyncRPCEventTransport | m_hPendingEvent |
    //  Handle to an event object used to signal caller that an event is ready for retrieval.
    //  Callers get this handle first via a call to <mf ClientEventTransport::getNotificationHandle>.
    //  They then wait on this handle until signaled, which indicates a WIA event has arrived
    //  and is ready for retrieval.  The event information is then retrieved via a call to
    //  <mf AsyncRPCEventTransport::FillEventData>.
    //
    // @mdata RPC_ASYNC_STATE | AsyncRPCEventTransport | m_AsyncState |
    // This structure is used to make the Async call by which we receive event notifications
    // from the server.  See <mf AsyncRPCEventTransport::OpenNotificationChannel>.
    //
    // @mdata WIA_ASYNC_EVENT_NOTIFY_DATA | AsyncRPCEventTransport | m_AsyncEventNotifyData |
    // This member is filled in by the server when the AsyncRPC call completes.  If the call
    // completed successfully, this structure contains the relevant WIA event information.
    //
    // @mdata RPC_BINDING_HANDLE | AsyncRPCEventTransport | m_RpcBindingHandle |
    // RPC Binding handle used to reference our RPC server from which we receive event notifications.
    //
    // @mdata STI_CLIENT_CONTEXT | AsyncRPCEventTransport | m_ClientContext |
    // Our context which uniquely identifies us with the server.
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\asyncrpceventclient.h ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        3/25/2002
 *
 *  @doc    INTERNAL
 *
 *  @module AsyncRPCEventClient.h - Definitions for <c AsyncRPCEventClient> |
 *
 *  This file contains the class definition for <c AsyncRPCEventClient>.
 *
 *****************************************************************************/

//
//  Defines
//

/*****************************************************************************
 *  
 *  @doc INTERNAL
 *  
 *  @class AsyncRPCEventClient | Sub-class of <c WiaEventClient> containing implementation specific to AsyncRPC
 *  
 *  @comm
 *  This sub-class <c WiaEventClient> contains implementation which is specific
 *  to supporting event notification over AsyncRPC.
 *
 *****************************************************************************/
class AsyncRPCEventClient : public WiaEventClient
{
//@access Public members
public:

    // @cmember Constructor
    AsyncRPCEventClient(STI_CLIENT_CONTEXT ClientContext);
    // @cmember Destructor
    virtual ~AsyncRPCEventClient();

    // @cmember Saves the async rpc params for this client
    HRESULT saveAsyncParams(RPC_ASYNC_STATE *pAsyncState, WIA_ASYNC_EVENT_NOTIFY_DATA *pAsyncEventData);

    // @cmember Add a pending event.
    virtual HRESULT AddPendingEventNotification(WiaEventInfo *pWiaEventInfo);
    // @cmember Checks whether the client is interested in the event from the given device.
    virtual BOOL IsRegisteredForEvent(WiaEventInfo *pWiaEventInfo);

    // @cmember Sends next event in the pending event list
    HRESULT SendNextEventNotification();

//@access Private members
private:

    // @cmember Saves the async RPC state inforamtion needed to notify clinet of an event
    RPC_ASYNC_STATE *m_pAsyncState;

    // @cmember Saves the out parameter for the  AsyncCall
    WIA_ASYNC_EVENT_NOTIFY_DATA *m_pAsyncEventData;

    //@mdata RPC_ASYNC_STATE* | AsyncRPCEventClient | m_pAsyncState |
    //  This member saves the RPC state fore the outstanding AsyncRPC call.  Completeling this
    //  call is was notifies a client of a WIA event.
    //
    //@mdata WIA_ASYNC_EVENT_NOTIFY_DATA* | AsyncRPCEventClient | m_pAsyncEventData |
    //  This structure stores the [OUT} parameter of the AsyncRPC call used for event notifications.
    //  We fill this structure out before completing the AsyncRPC call.
    //
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\buffer.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    buffer.h

Abstract:

    Definition of BUFFER class.

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/

#ifndef _INC_BUFFER
#define _INC_BUFFER

extern "C"
{

# include <windows.h>
};


/*************************************************************************

    NAME:       BUFFER (buf)

    SYNOPSIS:   A resizable object which lives in the application heap.

                Upon construction, the buffer takes a requested size in
                bytes; it allocates storage sufficient to hold that size.
                The client can later change this size with Resize, Trim,
                and FillOut.  QuerySize returns the current size of
                the buffer; QueryPtr returns a pointer to its storage.

                Note that a buffer may have size 0, in which case it
                keeps no allocated storage.

    INTERFACE:  BUFFER()        - Constructor, naming initial size in bytes

                QuerySize()     - return size in bytes
                QueryPtr()      - return pointer to data buffer

                Resize()        - resize the object to the given number
                                  of bytes.  Returns TRUE if the resize was
                                  successful; otherwise returns FALSE (use
                                  GetLastError for error code)

                Trim()          - force block to occupy no more storage
                                  than the client has requested.

    PARENT:

**************************************************************************/

class BUFFER
{
private:
    BYTE *  _pb;        // pointer to storage
    UINT    _cb;        // size of storage, as requested by client

    inline VOID VerifyState() const;

    UINT QueryActualSize();
    dllexp BOOL GetNewStorage( UINT cbRequested );
    BOOL ReallocStorage( UINT cbNewlyRequested );

public:
    dllexp BUFFER( UINT cbRequested = 0 )
    {
        _pb = NULL;
        _cb = 0;

        if ( cbRequested != 0 )
        {
            GetNewStorage(cbRequested);
        }
    }

    dllexp ~BUFFER()
    {
        if ( _pb )
        {
            ::LocalFree( (HANDLE) _pb );
        }
    }

    dllexp VOID * QueryPtr() const
        { return _pb; }

    dllexp UINT QuerySize() const
        { return _cb; }

    //
    //  If a resize is needed, added cbSlop to it
    //

    dllexp BOOL Resize( UINT cbNewReqestedSize,
                        UINT cbSlop = 0);

    // The following method deals with the difference between the
    // actual memory size and the requested size.  These methods are
    // intended to be used when optimization is key.
    // Trim reallocates the buffer so that the actual space allocated is
    // minimally more than the size requested
    //
    dllexp VOID Trim();
};

//
//  This class is a single item in a chain of buffers
//

class BUFFER_CHAIN_ITEM : public BUFFER
{

friend class BUFFER_CHAIN;

public:
    dllexp BUFFER_CHAIN_ITEM( UINT cbReq = 0 )
      : BUFFER( cbReq ),
        _cbUsed( 0 )
        { _ListEntry.Flink = NULL; }

    dllexp ~BUFFER_CHAIN_ITEM()
        { if ( _ListEntry.Flink )
              RemoveEntryList( &_ListEntry );
        }

    dllexp DWORD QueryUsed( VOID ) const
        { return _cbUsed; }

    dllexp VOID SetUsed( DWORD cbUsed )
        { _cbUsed = cbUsed; }

private:
    LIST_ENTRY _ListEntry;
    DWORD      _cbUsed;     // Bytes of valid data in this buffer
};

class BUFFER_CHAIN
{
public:
    dllexp BUFFER_CHAIN()
        { InitializeListHead( &_ListHead ); }

    dllexp ~BUFFER_CHAIN()
        { DeleteChain(); }

    dllexp BOOL AppendBuffer( BUFFER_CHAIN_ITEM * pBCI );

    //
    //  Returns total number of bytes freed by deleting all of the buffer
    //  chain items
    //

    dllexp DWORD DeleteChain();

    //
    //  Enums buffer chain.  Pass pBCI as NULL on first call, pass return
    //  value till NULL on subsequent calls
    //

    dllexp BUFFER_CHAIN_ITEM * NextBuffer( BUFFER_CHAIN_ITEM * pBCI );

    //
    //  Gives back total number of bytes allocated by chain (includes unused
    //  bytes)
    //

    dllexp DWORD CalcTotalSize( BOOL fUsed = FALSE ) const;

private:

    LIST_ENTRY _ListHead;

};

#endif  /* _INC_BUFFER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\cdlg.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cdlg.h

Abstract:

    Imitation of MFC CDialog class

Author:

    Vlad Sadovsky   (vlads) 26-Mar-1997

Revision History:

    26-Mar-1997     VladS       created

--*/

#ifndef _CDLG_H
#define _CDLG_H

#define ID_TIMER_EVENT  1000

class CDlg
{
public:
    void SetInstance(HINSTANCE hInst);
    void SetDlgID(UINT id);
    void Destroy();

    CDlg(int DlgID, HWND hWndParent, HINSTANCE hInst,UINT   msElapseTimePeriod=0);
    ~CDlg();

    HWND GetWindow() const { return m_hDlg; }
    HWND GetParent() const { return ::GetParent(m_hDlg); }
    HWND GetDlgItem(int iD) const { return ::GetDlgItem(m_hDlg,iD); }
    HINSTANCE GetInstance() const { return m_Inst;}
    UINT_PTR GetTimerId(VOID) const {return m_uiTimerId;}
    BOOL EndDialog(int iRet) { return ::EndDialog(m_hDlg,iRet); }

    // If you want your own dlg proc.
    INT_PTR CreateModal();
    HWND    CreateModeless();

    virtual BOOL CALLBACK DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    virtual int OnCommand(UINT id,HWND    hwndCtl, UINT codeNotify);
    virtual void OnInit();
    virtual int OnNotify(NMHDR * pHdr);

private:
    BOOL m_bCreatedModeless;
    void SetWindow(HWND hDlg) { m_hDlg=hDlg; }
    int             m_DlgID;
    HWND            m_hDlg;
    HWND            m_hParent;
    HINSTANCE       m_Inst;
    UINT            m_msElapseTimePeriod;
    UINT_PTR        m_uiTimerId;

protected:
    static INT_PTR CALLBACK BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};


#endif  // _CDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\base.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    base.h

Abstract:

    Universal base class for error cascading and debugging information

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/

#ifndef _BASE_H_
#define _BASE_H_

/*************************************************************************

    NAME:   BASE (base)

    SYNOPSIS:   Universal base object, root of every class.
        It contains universal error status and debugging
        support.

    INTERFACE:  ReportError()   - report an error on the object from
                  within the object.

        QueryError()    - return the current error state,
                  or 0 if no error outstanding.

        operator!() - return TRUE if an error is outstanding.
                  Typically means that construction failed.

    CAVEATS:    This sort of error reporting is safe enough in a single-
        threaded system, but loses robustness when multiple threads
        access shared objects.  Use it for constructor-time error
        handling primarily.

*************************************************************************/

class BASE : public IUnknown
{
private:
    UINT    m_err;

protected:

    LONG    m_cRef;

    BASE() { m_err = 0; m_cRef = 1;}
    VOID    ReportError( UINT err ) { m_err = err; }

public:

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)( THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)( THIS) PURE;

    // *** BASE Methods
    UINT    QueryError() const { return m_err; }
    LONG    QueryRefCount() { return m_cRef;}
    BOOL    operator!() const  { return (m_err != 0); }
};

#endif // _BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\cfactory.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       CFactory.h
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        26 Dec, 1997
*
*  DESCRIPTION:
*   Declarations and definitions for Class factory.
*
*******************************************************************************/

typedef HRESULT (*FPCREATEINSTANCE)(const IID& iid, void** ppv);

// FACTORY_DATA - Information CFactory needs to create a component

typedef struct _FACTORY_DATA
{
    FPCREATEINSTANCE    CreateInstance; // Pointer to creating function.
    IClassFactory*      pIClassFactory; // Pointer to running class factory.
    DWORD               dwRegister;     // ID for running object.

    const CLSID* pclsid;                // The class ID for the component.
    const GUID*  plibid;                // Type library ID.

    // Registry strings:

    LPCTSTR szRegName;                   // Name of the component.
    LPCTSTR szProgID;                    // Program ID.
    LPCTSTR szVerIndProgID;              // Version-independent program ID.
    LPCTSTR szService;                   // Name of service.

} FACTORY_DATA, *PFACTORY_DATA;

// Class Factory

class CFactory : public IClassFactory
{
public:
	// IUnknown
	virtual HRESULT __stdcall QueryInterface(const IID& iid, void** ppv) ;
	virtual ULONG   __stdcall AddRef() ;
	virtual ULONG   __stdcall Release() ;
	
	// IClassFactory
	virtual HRESULT __stdcall CreateInstance(IUnknown* pUnknownOuter,
	                                         const IID& iid,
                                             void** ppv) ;

    virtual HRESULT __stdcall LockServer(BOOL bLock) ; 

	// Constructor - Pass pointer to data of component to create.
    CFactory(const PFACTORY_DATA pFactoryData);

	// Destructor
	~CFactory() { }

	// Static FactoryData support functions

    // Helper function for CanUnloadNow
 	static BOOL IsLocked()
		{ return (s_cServerLocks > 0) ;}

	// Functions to [un]register all components
    static HRESULT RegisterUnregisterAll(
        PFACTORY_DATA   pFactoryData,
        UINT            uiFactoryDataCount,
        BOOLEAN         bRegister,
        BOOLEAN         bOutProc);

	// Function to determine if component can be unloaded
	static HRESULT CanUnloadNow() ;

	// Out-of-process server support

    static BOOL StartFactories(
        PFACTORY_DATA   pFactoryData,
        UINT            uiFactoryDataCount);

    static void StopFactories(
        PFACTORY_DATA   pFactoryData,
        UINT            uiFactoryDataCount);

	static DWORD s_dwThreadID ;

	// Shut down the application.
	static void CloseExe()
	{
		if (CanUnloadNow() == S_OK)
		{
			::PostThreadMessage(s_dwThreadID, WM_QUIT, 0, 0) ;
		}
	}

public:
	// Reference Count
	LONG m_cRef ;

	// Pointer to information about class this factory creates
    PFACTORY_DATA m_pFactoryData;

	// Count of locks
    static LONG s_cServerLocks;

	// Module handle
    static HMODULE s_hModule;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\coredbg.h ===
#pragma once
// this is incompatible with stidebug.h, so don't include stidebug.h
#define _STIDEBUG_H_ 
#undef ASSERT
#undef REQUIRE
#undef DPRINTF
#undef DPRINTF2
#undef DPRINTF_NOINFO

//
// predefined bits in debug flags
//

// something is really wrong, should not go unnoticed
#define COREDBG_ERRORS                  0x00000001

// something that may be of interest to debugging person
#define COREDBG_WARNINGS                0x00000002

// trace random low-priority things with DBG_TRC
#define COREDBG_TRACES                  0x00000004

// trace function entries, exits (if so equipped) 
// with DBG_FN
#define COREDBG_FNS                     0x00000008

// break on errors
#define COREDBG_BREAK_ON_ERRORS         0x80000000

// log to file (default) 
#define COREDBG_DONT_LOG_TO_FILE        0x40000000

// log to debugger (default)
#define COREDBG_DONT_LOG_TO_DEBUGGER    0x20000000


// debug log is saved to this file 
#define COREDBG_FILE_NAME "%userprofile%\\wiadebug.log"
// registry key location
#define COREDBG_FLAGS_REGKEY "System\\CurrentControlSet\\Control\\StillImage\\Debug"
// registry DWORD value name
#define COREDBG_FLAGS_REGVAL "DebugFlags"
// registry DWORD for max log file size
#define COREDBG_REGVAL_FILE_SIZE_LIMIT "DebugFileSizeLimit"
#define COREDBG_FILE_SIZE_LIMIT (512 * 1024) // bytes

#ifdef DEBUG
// by default log errors only in debug builds
#define COREDBG_DEFAULT_FLAGS COREDBG_ERRORS
#else
// by default log errors only in free builds
#define COREDBG_DEFAULT_FLAGS COREDBG_ERRORS
#endif

/****************************************************************************

HOW TO USE WIA CORE DEBUG (main macros)
======================================

- DBG_INIT(hInstance)
  Call from WinMain or DllMain to enable debug flags on a per module
  basis.  If you don't call it, all DLLs will inherit the debug flags
  of the process that creates them.

- DBG_ERR(("Something happened, hr = 0x%x", hr));
  Use when an error condition occurred.
  
- DBG_WRN(("Warning, something happening, Value=%d", iValue));
  Use in a situation warranting a warning.
  
- DBG_TRC(("Random trace statement, Value=%s", szValue));
  Use sparingly to trace certain parts of your code.  Minimize spew!!!
  
- DBG_PRT(("Output without standard File,Line,ThreadID info, Value=%d", iValue));
  Same as DBG_TRC, but doesn't output the File,Line,ThreadID line.  
  ***Use this only if you are doing some special formatting (use sparingly)***
  
- DBG_FN(FnName)
  Tracks entry and exits from a given scope.
  
- CHECK_NOERR   (VarName)
  CHECK_NOERR2  (VarName, (YourMsg,...))
  Does GetLastError and if not 0, outputs error.
    
- CHECK_S_OK    (hr)
  CHECK_S_OK2   (hr, (YourMsg,...))
  Checks if hr == S_OK, if not, outputs error.
    
- CHECK_SUCCESS (lResult)
  CHECK_SUCCESS2(lResult, (YourMsg,...))
  Checks if lResult == ERROR_SUCCESS, if not, outputs error.
    
- REQUIRE_NOERR   (VarName)
  REQUIRE_NOERR2  (VarName, (YourMsg,...))
  Same as equivalent CHECK_* macros above, but calls "goto Cleanup" as well
  
- REQUIRE_S_OK    (hr)
  REQUIRE_S_OK2   (hr, (YourMsg,...))
  Same as equivalent CHECK_* macros above, but calls "goto Cleanup" as well
  
- REQUIRE_SUCCESS (lResult)
  REQUIRE_SUCCESS2(lResult, (YourMsg,...))
  Same as equivalent CHECK_* macros above, but calls "goto Cleanup" as well    
  
HOW TO TURN ON WIA CORE DEBUG (3 ways)
======================================

1) Set registry HKLM\System\CurrentControlSet\Control\StillImage\Debug\<ModuleName>, 
   DWORD value "DebugFlags" to an OR'd value of above COREDBG_* flags.  
   Need to restart app to pick up new settings. Key is auto created the first time
   the app is run.  (Note: <ModuleName> above is the name 
   of your DLL or EXE.  e.g. wiavusd.dll has a registry key of 
   "HKLM\System\CurrentControlSet\Control\StillImage\Debug\wiavusd.dll")

                            OR

2) In the debugger, set g_dwDebugFlags to OR'd value of COREDBG_* flags above.
   You can do this anytime during the debug session.
   
                            OR

3) Call in your code WIA_SET_FLAGS(COREDBG_ERRORS | COREDBG_WARNINGS | COREDBG_TRACES);
   or any combo of the COREDBG_* flags.
   
*****************************************************************************/


#define DBG_INIT(x) DINIT(x)
#define DBG_TERM()  DTERM()
#define DBG_ERR(x)  DPRINTF(COREDBG_ERRORS, x)
#define DBG_WRN(x)  DPRINTF(COREDBG_WARNINGS, x)
#define DBG_TRC(x)  DPRINTF(COREDBG_TRACES, x)
#define DBG_PRT(x)  DPRINTF_NOINFO(COREDBG_TRACES, x)
#define DBG_SET_FLAGS(x) g_dwDebugFlags = (x)

#ifdef __cplusplus
extern "C" {
#endif

    //
    // accessible to your startup code and at runtime in debugger
    // defined in wia\common\stirt\coredbg.cpp
    //
    extern DWORD  g_dwDebugFlags; 
    extern HANDLE g_hDebugFile;
    extern DWORD  g_dwDebugFileSizeLimit;
    extern BOOL   g_bDebugInited;
    void __stdcall CoreDbgTrace(LPCSTR fmt, ...);
    void __stdcall CoreDbgTraceWithTab(LPCSTR fmt, ...);
    void __stdcall CoreDbgInit(HINSTANCE hInstance);
    void __stdcall CoreDbgTerm();


#ifdef DEBUG

#define DINIT(x) CoreDbgInit(x)
#define DTERM()  CoreDbgTerm()

#define ASSERT(x) \
    if(!(x)) { \
        DWORD threadId = GetCurrentThreadId(); \
        CoreDbgTrace("WIA: [%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId, #x); \
        CoreDbgTraceWithTab("ASSERT FAILED. '%s'", #x); \
        DebugBreak(); \
    }

    
#define VERIFY(x) ASSERT(x)
#define REQUIRE(x) ASSERT(x)
    
#define DPRINTF(flags, x) \
    if(!g_bDebugInited) \
    { \
        CoreDbgInit(NULL); \
    } \
    if(flags & g_dwDebugFlags) { \
        DWORD threadId = GetCurrentThreadId(); \
        CoreDbgTrace("WIA: [%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        CoreDbgTraceWithTab x; \
        if((flags & COREDBG_ERRORS) && (g_dwDebugFlags & COREDBG_BREAK_ON_ERRORS)) { \
            DebugBreak(); \
        } \
    }
    
#define DPRINTF2(flags, x, y) \
    if(!g_bDebugInited) \
    { \
        CoreDbgInit(NULL); \
    } \
    if (flags & g_dwDebugFlags) { \
        DWORD threadId = GetCurrentThreadId(); \
        CoreDbgTrace("WIA: [%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        CoreDbgTraceWithTab x; \
        CoreDbgTraceWithTab y; \
        if((flags & COREDBG_ERRORS) && (g_dwDebugFlags & COREDBG_BREAK_ON_ERRORS)) { \
            DebugBreak(); \
        } \
    }
    
#define DPRINTF_NOINFO(flags, x) \
    if(!g_bDebugInited) \
    { \
        CoreDbgInit(NULL); \
    } \
    if (flags & g_dwDebugFlags) { \
        CoreDbgTraceWithTab x; \
        if((flags & COREDBG_ERRORS) && (g_dwDebugFlags & COREDBG_BREAK_ON_ERRORS)) { \
            DebugBreak(); \
        } \
    }

#ifdef __cplusplus
#define DBG_FN(x) CoreDbgFn __CoreDbgFnObject(#x)
#else
#define DBG_FN(x) 
#endif
        

#else // begin NODEBUG

#define DINIT(x) CoreDbgInit(x)
#define DTERM()  CoreDbgTerm()
#define ASSERT(x) 
#define VERIFY(x) x
#define REQUIRE(x) x    

#define DPRINTF(flags, x) \
    if(!g_bDebugInited) \
    { \
        CoreDbgInit(NULL); \
    } \
    if(flags & g_dwDebugFlags) { \
        CoreDbgTraceWithTab x; \
    }
    
#define DPRINTF2(flags, x, y) \
    if(!g_bDebugInited) \
    { \
        CoreDbgInit(NULL); \
    } \
    if(flags & g_dwDebugFlags) { \
        CoreDbgTraceWithTab x; \
        CoreDbgTraceWithTab y; \
    }

#define DPRINTF_NOINFO(flags, x) \
    if(!g_bDebugInited) \
    { \
        CoreDbgInit(NULL); \
    } \
    if(flags & g_dwDebugFlags) { \
        CoreDbgTraceWithTab x; \
    }

#ifdef __cplusplus
#define DBG_FN(x) CoreDbgFn __CoreDbgFnObject(#x)
#else
#define DBG_FN(x) 
#endif

#endif // end NODEBUG

#define COREDBG_MFMT_FLAGS (FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM | \
    FORMAT_MESSAGE_MAX_WIDTH_MASK)

#define REQUIRE_NOERR(x) \
    if(!(x)) { \
        DWORD __dwCoreDbgLastError = GetLastError(); \
        CHAR szError[80] = {0}; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __dwCoreDbgLastError, 0, szError, sizeof(szError) / sizeof(szError[0]) - 1, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        szError[sizeof(szError) / sizeof(szError[0]) - 1] = '\0'; \
        DBG_ERR(("ERROR: %s = %d (0x%08X), '%s'", #x, __dwCoreDbgLastError, __dwCoreDbgLastError, szError)); \
        goto Cleanup; \
    }

#define REQUIRE_NOERR2(x, y) \
    if(!(x)) { \
        DWORD __dwCoreDbgLastError = GetLastError(); \
        CHAR szError[80] = {0}; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __dwCoreDbgLastError, 0, szError, sizeof(szError) / sizeof(szError[0]) - 1, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        szError[sizeof(szError) / sizeof(szError[0]) - 1] = '\0'; \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = %d (0x%08X), '%s'", #x, __dwCoreDbgLastError, __dwCoreDbgLastError, szError), y); \
        goto Cleanup; \
    }
    
#define REQUIRE_S_OK(x) { \
    HRESULT __hrCoreDbg = S_OK; \
    __hrCoreDbg = (x); \
    if(__hrCoreDbg != S_OK) { \
        CHAR szError[80] = {0}; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __hrCoreDbg, 0, szError, sizeof(szError) / sizeof(szError[0]) - 1, NULL)) \
        { \
            wsprintfA(szError, "Unknown hr"); \
        } \
        szError[sizeof(szError) / sizeof(szError[0]) - 1] = '\0'; \
        DBG_ERR(("ERROR: %s = 0x%08X, '%s'", #x, __hrCoreDbg, szError)); \
        goto Cleanup; \
    } \
}

#define REQUIRE_S_OK2(x,y) { \
    HRESULT __hrCoreDbg = S_OK; \
    __hrCoreDbg = (x); \
    if(__hrCoreDbg != S_OK) { \
        CHAR szError[80] = {0}; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __hrCoreDbg, 0, szError, sizeof(szError) / sizeof(szError[0]) - 1, NULL)) \
        { \
            wsprintfA(szError, "Unknown hr"); \
        } \
        szError[sizeof(szError) / sizeof(szError[0]) - 1] = '\0'; \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = 0x%08X, '%s'", #x, __hrCoreDbg, szError), y); \
        goto Cleanup; \
    } \
} 

#define REQUIRE_SUCCESS(x) { \
    UINT __resultCoreDbg = (x); \
    if(__resultCoreDbg != ERROR_SUCCESS) { \
        CHAR szError[80] = {0}; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __resultCoreDbg, 0, szError, sizeof(szError) / sizeof(szError[0]) - 1, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        szError[sizeof(szError) / sizeof(szError[0]) - 1] = '\0'; \
        DBG_ERR(("ERROR: %s = 0x%08X, '%s'", #x, __resultCoreDbg, szError)); \
        goto Cleanup; \
    } \
} 

#define REQUIRE_SUCCESS2(x, y) { \
    UINT __resultCoreDbg = (x); \
    if(__resultCoreDbg != ERROR_SUCCESS) { \
        CHAR szError[80] = {0}; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __resultCoreDbg, 0, szError, sizeof(szError) / sizeof(szError[0]) - 1, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        szError[sizeof(szError) / sizeof(szError[0]) - 1] = '\0'; \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = 0x%08X, '%s'", #x, __resultCoreDbg, szError), y); \
        goto Cleanup; \
    } \
} 

#define CHECK_NOERR(x) \
    if(!(x)) { \
        DWORD __dwCoreDbgLastError = GetLastError(); \
        CHAR szError[80] = {0}; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __dwCoreDbgLastError, 0, szError, sizeof(szError) / sizeof(szError[0]) - 1, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        szError[sizeof(szError) / sizeof(szError[0]) - 1] = '\0'; \
        DBG_ERR(("ERROR: %s = %d (0x%08X), '%s'", #x, __dwCoreDbgLastError, __dwCoreDbgLastError, szError)); \
    }

#define CHECK_NOERR2(x, y) \
    if(!(x)) { \
        DWORD __dwCoreDbgLastError = GetLastError(); \
        CHAR szError[80] = {0}; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __dwCoreDbgLastError, 0, szError, sizeof(szError) / sizeof(szError[0]) - 1, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        szError[sizeof(szError) / sizeof(szError[0]) - 1] = '\0'; \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = %d (0x%08X), '%s'", #x, __dwCoreDbgLastError, __dwCoreDbgLastError, szError), y); \
    }

#define CHECK_S_OK(x) { \
    HRESULT __hrCoreDbg = S_OK; \
    __hrCoreDbg = (x); \
    if(__hrCoreDbg != S_OK) { \
        CHAR szError[80] = {0}; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __hrCoreDbg, 0, szError, sizeof(szError) / sizeof(szError[0]) - 1, NULL)) \
        { \
            wsprintfA(szError, "Unknown hr"); \
        } \
        szError[sizeof(szError) / sizeof(szError[0]) - 1] = '\0'; \
        DBG_ERR(("ERROR: %s = 0x%08X, '%s'", #x, __hrCoreDbg, szError)); \
    } \
}

#define CHECK_S_OK2(x,y) { \
    HRESULT __hrCoreDbg = S_OK; \
    __hrCoreDbg = (x); \
    if(__hrCoreDbg != S_OK) { \
        CHAR szError[80] = {0}; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __hrCoreDbg, 0, szError, sizeof(szError) / sizeof(szError[0]) - 1, NULL)) \
        { \
            wsprintfA(szError, "Unknown hr"); \
        } \
        szError[sizeof(szError) / sizeof(szError[0]) - 1] = '\0'; \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = 0x%08X, '%s'", #x, __hrCoreDbg, szError), y); \
    } \
}

#define CHECK_SUCCESS(x) { \
    UINT __resultCoreDbg = (x); \
    if(__resultCoreDbg != ERROR_SUCCESS) { \
        CHAR szError[80] = {0}; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __resultCoreDbg, 0, szError, sizeof(szError) / sizeof(szError[0]) - 1, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        szError[sizeof(szError) / sizeof(szError[0]) - 1] = '\0'; \
        DBG_ERR(("ERROR: %s = 0x%08X, '%s'", #x, __resultCoreDbg, szError)); \
    } \
} 

#define CHECK_SUCCESS2(x, y) { \
    UINT __resultCoreDbg = (x); \
    if(__resultCoreDbg != ERROR_SUCCESS) { \
        CHAR szError[80] = {0}; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __resultCoreDbg, 0, szError, sizeof(szError) / sizeof(szError[0]) - 1, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        szError[sizeof(szError) / sizeof(szError[0]) - 1] = '\0'; \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = 0x%08X, '%s'", #x, __resultCoreDbg, szError), y); \
    } \
} 

#ifdef __cplusplus
    class CoreDbgFn {
    private:
        LPCSTR m_fn;
        DWORD m_threadId;
    public:

        CoreDbgFn(LPCSTR fn)
        { 
            m_fn = fn;
            m_threadId = GetCurrentThreadId();
            if(!g_bDebugInited) 
            {
                CoreDbgInit(NULL);
            }
            if(g_dwDebugFlags & COREDBG_FNS) 
            {
                CoreDbgTraceWithTab("WIA: Thread 0x%X (%d) Entering %s", m_threadId, m_threadId, m_fn);
            }
        } 
        
        ~CoreDbgFn() 
        { 
            if(g_dwDebugFlags & COREDBG_FNS) 
            {
                CoreDbgTraceWithTab("WIA: Thread 0x%X (%d) Leaving  %s", m_threadId, m_threadId, m_fn); 
            }
        }
    };
#endif



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\clienteventtransport.h ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        3/22/2002
 *
 *  @doc    INTERNAL
 *
 *  @module ClientEventTransport.h - Definitions for the client-side transport mechanism to receive events |
 *
 *  This header file contains the definition for the ClientEventTransport
 *  class.  It is used to shield the higher-level run-time event notification
 *  classes from the particulars of a specific transport mechanism.
 *
 *****************************************************************************/

//
//  Defines
//

#define ClientEventTransport_UNINIT_SIG   0x556E7254
#define ClientEventTransport_INIT_SIG     0x496E7254
#define ClientEventTransport_TERM_SIG     0x546E7254
#define ClientEventTransport_DEL_SIG      0x446E7254

/*****************************************************************************
 *  
 *  @doc INTERNAL
 *  
 *  @class ClientEventTransport | Used to abstract implementation details of various transport mechanisms
 *  
 *  @comm
 *  This is a base class.  It is used to shield the higher-level 
 *  run-time event notification classes from the implmentation details of 
 *  various transport mechanisms.
 *
 *****************************************************************************/
class ClientEventTransport 
{
//@access Public members
public:

    // @cmember Constructor
    ClientEventTransport();
    // @cmember Destructor
    virtual ~ClientEventTransport();

    // @cmember Initializes and creates any dependant objects
    HRESULT virtual Initialize();

    // @cmember Connect to the WIA Service
    HRESULT virtual OpenConnectionToServer();
    // @cmember Disconnect from the WIA Service
    HRESULT virtual CloseConnectionToServer();
    // @cmember Sets up the mechanism by which the client will receive notifications
    HRESULT virtual OpenNotificationChannel();
    // @cmember Tears down the mechanism by which the client receives notifications
    HRESULT virtual CloseNotificationChannel();

    // @cmember Informs service of client's specific registration/unregistration requests
    HRESULT virtual SendRegisterUnregisterInfo(EventRegistrationInfo *pEventRegistrationInfo);

    // @cmember Retrieves a HANDLE which callers can Wait on to receive event notifications
    HANDLE  virtual getNotificationHandle();
    // @cmember Once an event occurs, this will retrieve the relevant data
    HRESULT virtual FillEventData(WiaEventInfo *pWiaEventInfo);

//@access Private members
protected:

    // @cmember Signature of class
    ULONG m_ulSig;

    // @cmember Handle to an event object used to signal caller that an event is ready for retrieval
    HANDLE m_hPendingEvent;

    //
    //  Comments for member variables
    //
    // @mdata ULONG | ClientEventTransport | m_ulSig | 
    //   The signature for this class, used for debugging purposes.
    //   Doing a <nl>"db [addr_of_class]"<nl> would yield one of the following
    //   signatures for this class:
    //   @flag ClientEventTransport_UNINIT_SIG | 'TrnU' - Object has not been successfully
    //       initialized
    //   @flag ClientEventTransport_INIT_SIG | 'TrnI' - Object has been successfully
    //       initialized
    //   @flag ClientEventTransport_TERM_SIG | 'TrnT' - Object is in the process of
    //       terminating.
    //    @flag ClientEventTransport_INIT_SIG | 'TrnD' - Object has been deleted 
    //       (destructor was called)
    //
    //
    // @cmember HANDLE | ClientEventTransport | m_hPendingEvent |
    //  Handle to an event object used to signal caller that an event is ready for retrieval.
    //  Callers get this handle first via a call to <mf ClientEventTransport::getNotificationHandle>.
    //  They then wait on this handle until signaled, which indicates a WIA event has arrived
    //  and is ready for retrieval.  The event information is then retrieved via a call to
    //  <mf ClientEventTransport::FillEventData>.
    //
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\clienteventregistrationinfo.h ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        4/1/2002
 *
 *  @doc    INTERNAL
 *
 *  @module ClientEventRegistrationInfo.cpp - Definitions for <c ClientEventRegistrationInfo> |
 *
 *  This file contains the class definition for <c ClientEventRegistrationInfo>.
 *
 *****************************************************************************/

/*****************************************************************************
 *  
 *  @doc INTERNAL
 *  
 *  @class ClientEventRegistrationInfo | Sub-class of <c ClientEventRegistrationInfo>
 *  
 *  @comm
 *  This class is very similar to its parent <c ClientEventRegistrationInfo>.
 *  The main difference is that it AddRef's and Releases the callback member.
 *
 *****************************************************************************/
class ClientEventRegistrationInfo : public EventRegistrationInfo
{
//@access Public members
public:

    // @cmember Constructor
    ClientEventRegistrationInfo(DWORD dwFlags, GUID guidEvent, WCHAR *wszDeviceID, IWiaEventCallback *pIWiaEventCallback);
    // @cmember Destructor
    virtual ~ClientEventRegistrationInfo();

    // @cmember Returns the callback interface for this registration
    virtual IWiaEventCallback* getCallbackInterface();
    // @cmember Ensures this registration is set to unregister
    virtual VOID setToUnregister();

//@access Private members
private:

    // @cmember The GIT cookie for the callback interface
    DWORD m_dwInterfaceCookie;

    //@mdata DWORD | ClientEventRegistrationInfo | m_dwInterfaceCookie |
    //  In order to ensure correct access from multiple apartments,
    //  we store the callback interface in the process-wide GIT.  This 
    //  cookie is used to retrieve the callback interface whenever we need it.
    //  
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\cstring.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cstring.h

Abstract:

    Extracted from MFC

Author:

Revision History:

--*/

#ifndef _CSTRING_H_
#define _CSTRING_H_

# include <ctype.h>
# include <tchar.h>
#include <stidebug.h>

#define _AFX_NO_BSTR_SUPPORT    1

#define AFX_CDECL               CDECL
#define AFXAPI                  WINAPI
#define AFX_DATA
#define AFX_DATADEF
#define DEBUG_NEW           new
#define TRACE1(s,x)         DPRINTF(DM_TRACE,s,x)
#define VERIFY              REQUIRE
#define _AFX_INLINE         inline


BOOL
AfxIsValidString(
    LPCWSTR     lpsz,
    int         nLength
    ) ;

BOOL
AfxIsValidString(
    LPCSTR  lpsz,
    int     nLength
    ) ;

BOOL
AfxIsValidAddress(
    const void* lp,
    UINT nBytes,
    BOOL bReadWrite
    );

/////////////////////////////////////////////////////////////////////////////
// Strings

#ifndef _OLEAUTO_H_
#ifdef OLE2ANSI
    typedef LPSTR BSTR;
#else
    typedef LPWSTR BSTR;// must (semantically) match typedef in oleauto.h
#endif
#endif

struct CStringData
{
    long    nRefs;     // reference count
    int     nDataLength;
    int     nAllocLength;
    // TCHAR data[nAllocLength]

    TCHAR* data()
        { return (TCHAR*)(this+1); }
};

class CString
{
public:
// Constructors
    CString();
    CString(const CString& stringSrc);
    CString(TCHAR ch, int nRepeat = 1);
    CString(LPCSTR lpsz);
    CString(LPCWSTR lpsz);
    CString(LPCTSTR lpch, int nLength);
    CString(const unsigned char* psz);

// Attributes & Operations
    // as an array of characters
    int GetLength() const;
    BOOL IsEmpty() const;
    void Empty();                       // free up the data

    TCHAR GetAt(int nIndex) const;      // 0 based
    TCHAR operator[](int nIndex) const; // same as GetAt
    void SetAt(int nIndex, TCHAR ch);
    operator LPCTSTR() const;           // as a C string

    // overloaded assignment
    const CString& operator=(const CString& stringSrc);
    const CString& operator=(TCHAR ch);
#ifdef _UNICODE
    const CString& operator=(char ch);
#endif
    const CString& operator=(LPCSTR lpsz);
    const CString& operator=(LPCWSTR lpsz);
    const CString& operator=(const unsigned char* psz);

    // string concatenation
    const CString& operator+=(const CString& string);
    const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
    const CString& operator+=(char ch);
#endif
    const CString& operator+=(LPCTSTR lpsz);

    friend CString AFXAPI operator+(const CString& string1,
            const CString& string2);
    friend CString AFXAPI operator+(const CString& string, TCHAR ch);
    friend CString AFXAPI operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
    friend CString AFXAPI operator+(const CString& string, char ch);
    friend CString AFXAPI operator+(char ch, const CString& string);
#endif
    friend CString AFXAPI operator+(const CString& string, LPCTSTR lpsz);
    friend CString AFXAPI operator+(LPCTSTR lpsz, const CString& string);

    // string comparison
    int Compare(LPCTSTR lpsz) const;         // straight character
    int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
    int Collate(LPCTSTR lpsz) const;         // NLS aware

    // simple sub-string extraction
    CString Mid(int nFirst, int nCount) const;
    CString Mid(int nFirst) const;
    CString Left(int nCount) const;
    CString Right(int nCount) const;

    CString SpanIncluding(LPCTSTR lpszCharSet) const;
    CString SpanExcluding(LPCTSTR lpszCharSet) const;

    // upper/lower/reverse conversion
    void MakeUpper();
    void MakeLower();
    void MakeReverse();

    // trimming whitespace (either side)
    void TrimRight();
    void TrimLeft();

    // searching (return starting index, or -1 if not found)
    // look for a single character match
    int Find(TCHAR ch) const;               // like "C" strchr
    int ReverseFind(TCHAR ch) const;
    int FindOneOf(LPCTSTR lpszCharSet) const;

    // look for a specific sub-string
    int Find(LPCTSTR lpszSub) const;        // like "C" strstr

    // simple formatting
    void AFX_CDECL Format(LPCTSTR lpszFormat, ...);
    void AFX_CDECL Format(UINT nFormatID, ...);

    // formatting for localization (uses FormatMessage API)
    void AFX_CDECL FormatMessage(LPCTSTR lpszFormat, ...);
    void AFX_CDECL FormatMessage(UINT nFormatID, ...);

    // input and output
    //friend CArchive& AFXAPI operator<<(CArchive& ar, const CString& string);
    //friend CArchive& AFXAPI operator>>(CArchive& ar, CString& string);

    // Windows support
    BOOL LoadString(UINT nID);          // load from string resource
                                        // 255 chars max
#ifndef _UNICODE
    // ANSI <-> OEM support (convert string in place)
    void AnsiToOem();
    void OemToAnsi();
#endif

#ifndef _AFX_NO_BSTR_SUPPORT
    // OLE BSTR support (use for OLE automation)
    BSTR AllocSysString() const;
    BSTR SetSysString(BSTR* pbstr) const;
#endif

    // Access to string implementation buffer as "C" character array
    LPTSTR GetBuffer(int nMinBufLength);
    void ReleaseBuffer(int nNewLength = -1);
    LPTSTR GetBufferSetLength(int nNewLength);
    void FreeExtra();

    // Use LockBuffer/UnlockBuffer to turn refcounting off
    LPTSTR LockBuffer();
    void UnlockBuffer();

// Implementation
public:
    ~CString();
    int GetAllocLength() const;

protected:
    LPTSTR m_pchData;   // pointer to ref counted string data

    // implementation helpers
    CStringData* GetData() const;
    void Init();
    void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
    void AllocBuffer(int nLen);
    void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
    void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
    void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
    void FormatV(LPCTSTR lpszFormat, va_list argList);
    void CopyBeforeWrite();
    void AllocBeforeWrite(int nLen);
    void Release();
    static void PASCAL Release(CStringData* pData);
    static int PASCAL SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
bool AFXAPI operator==(const CString& s1, const CString& s2);
bool AFXAPI operator==(const CString& s1, LPCTSTR s2);
bool AFXAPI operator==(LPCTSTR s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator!=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>=(LPCTSTR s1, const CString& s2);

// conversion helpers
int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
//extern AFX_DATA TCHAR afxChNil;
const CString& AFXAPI AfxGetEmptyString();
#define afxEmptyString AfxGetEmptyString()

// CString
_AFX_INLINE CStringData* CString::GetData() const
    { ASSERT(m_pchData != NULL); return ((CStringData*)m_pchData)-1; }
_AFX_INLINE void CString::Init()
    { m_pchData = afxEmptyString.m_pchData; }
_AFX_INLINE CString::CString(const unsigned char* lpsz)
    { Init(); *this = (LPCSTR)lpsz; }
_AFX_INLINE const CString& CString::operator=(const unsigned char* lpsz)
    { *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
_AFX_INLINE const CString& CString::operator+=(char ch)
    { *this += (TCHAR)ch; return *this; }
_AFX_INLINE const CString& CString::operator=(char ch)
    { *this = (TCHAR)ch; return *this; }
_AFX_INLINE CString AFXAPI operator+(const CString& string, char ch)
    { return string + (TCHAR)ch; }
_AFX_INLINE CString AFXAPI operator+(char ch, const CString& string)
    { return (TCHAR)ch + string; }
#endif

_AFX_INLINE int CString::GetLength() const
    { return GetData()->nDataLength; }
_AFX_INLINE int CString::GetAllocLength() const
    { return GetData()->nAllocLength; }
_AFX_INLINE BOOL CString::IsEmpty() const
    { return GetData()->nDataLength == 0; }
_AFX_INLINE CString::operator LPCTSTR() const
    { return m_pchData; }
_AFX_INLINE int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
    { return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

// CString support (windows specific)
_AFX_INLINE int CString::Compare(LPCTSTR lpsz) const
    { return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
_AFX_INLINE int CString::CompareNoCase(LPCTSTR lpsz) const
    { return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CString::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
_AFX_INLINE int CString::Collate(LPCTSTR lpsz) const
    { return _tcscoll(m_pchData, lpsz); }   // locale sensitive

_AFX_INLINE TCHAR CString::GetAt(int nIndex) const
{
    ASSERT(nIndex >= 0);
    ASSERT(nIndex < GetData()->nDataLength);
    return m_pchData[nIndex];
}
_AFX_INLINE TCHAR CString::operator[](int nIndex) const
{
    // same as GetAt
    ASSERT(nIndex >= 0);
    ASSERT(nIndex < GetData()->nDataLength);
    return m_pchData[nIndex];
}
_AFX_INLINE bool AFXAPI operator==(const CString& s1, const CString& s2)
    { return s1.Compare(s2) == 0; }
_AFX_INLINE bool AFXAPI operator==(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) == 0; }
_AFX_INLINE bool AFXAPI operator==(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) == 0; }
_AFX_INLINE bool AFXAPI operator!=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) != 0; }
_AFX_INLINE bool AFXAPI operator!=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) != 0; }
_AFX_INLINE bool AFXAPI operator!=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) != 0; }
_AFX_INLINE bool AFXAPI operator<(const CString& s1, const CString& s2)
    { return s1.Compare(s2) < 0; }
_AFX_INLINE bool AFXAPI operator<(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) < 0; }
_AFX_INLINE bool AFXAPI operator<(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) > 0; }
_AFX_INLINE bool AFXAPI operator>(const CString& s1, const CString& s2)
    { return s1.Compare(s2) > 0; }
_AFX_INLINE bool AFXAPI operator>(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) > 0; }
_AFX_INLINE bool AFXAPI operator>(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) < 0; }
_AFX_INLINE bool AFXAPI operator<=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) <= 0; }
_AFX_INLINE bool AFXAPI operator<=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) <= 0; }
_AFX_INLINE bool AFXAPI operator<=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) >= 0; }
_AFX_INLINE bool AFXAPI operator>=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) >= 0; }
_AFX_INLINE bool AFXAPI operator>=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) >= 0; }
_AFX_INLINE bool AFXAPI operator>=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) <= 0; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\digita.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    digita.h

Abstract:

    FlashPoint Digita command language

Notes:

    Non-portable, for use with Win32 environment.

    CDP == Camera Device Protocol

    Structure types , defined in this file are used to fill protocol buffer.
    It is important to keep packing option set to single byte setting.

Author:

    Vlad Sadovsky   (VladS)    11/13/1998

Environment:

    User Mode - Win32

Revision History:

    11/13/1998      VladS       Created

--*/

#if !defined( _DIGITA_H_ )
#define _DIGITA_H_


#if _MSC_VER > 1000
#pragma once
#endif

#ifndef RC_INVOKED
#include <pshpack1.h>
#endif // RC_INVOKED

//
// Include files
//
#include <digitaer.h>

//
// Local definitions
//

#define INT16   short
#define UINT16  unsigned short


typedef INT32   TINT32 ;
typedef UINT32  TUINT32 ;
typedef INT16   TINT16;
typedef UINT16  TUINT16;
typedef UINT32  TBITFLAGS;

typedef BYTE    TPName[4];
typedef BYTE    TDOSName[16];
typedef BYTE    TString[32];


//
// Big-endian <-> little-endian Macro DEFINITIONS
//
// Camera software expects big-endian representation of numbers, so when we send
// integers from x86 to it, we need to do a swap. Same applies to all integers
// we receive from camera
//

#if defined(_X86_) || defined(_IA64_)

#define LB8(b) (b)
#define BL8(b) LB8(b)
#define LB16(w) (((INT16)(HIBYTE(w))) | ((LOBYTE(w) << 8) & 0xFF00))
#define BL16(w) LB16(w)
#define LB32(l) (((INT32)(LB16(HIWORD(l)))) | ((INT32)(LB16(LOWORD(l))) << 16))
#define BL32(l) LB32(l)

#else

#define LB8(b) (b)
#define BL8(b) (b)
#define LB16(w) (w)
#define BL16(w) (w)
#define LB32(l) (l)
#define BL32(l) (l)

#endif

//
// Protocol definitions
//
typedef struct {

    ULONG   ulLength;   // Length of the structure minus length of this field
    BYTE    bVersion;   // the version of the CDP packet
    CHAR    cReserved[3]; // reserved
    SHORT   shCommand;  // the command
    SHORT   shResult;   // the result code
} TCDPHeader;

typedef struct {
    TCDPHeader  sCDPHeader; // the header fields of the camera device protocol
    BYTE        bData[1];   // this is the start of the data to be sent with the message
} TCDP;


//
// Definitions
//
typedef enum {
    VTUInt  = 1,
    VTInt   = 2,
    VTFixed = 3,
    VTBool  = 4,
    VTBitFlags = 5,
    VTPname = 6,
    VTDOSName = 7,
    VTString = 8,
    VTUIList = 9
} TValueType;


typedef struct {
    TPName       Name;
    TValueType   Type;
    union {
        UINT    fUInt;
        INT     fInt;
        UINT    fFixed;
        BOOL    fBool;
        UINT    fBitFlags;
        TPName   fPName;
        TDOSName fDOSName;
        TString  fString;
    } Data;
    //PNameValue
}  PNameTypeValueStruct;


//
// Protocol command ranges
//

#define CDP_CMN_HOST2CAM_MIN        0x0000
#define CDP_CMN_HOST2CAM_MAX        0x5fff

#define CDP_PROD_HOST2CAM_MIN       0x6000
#define CDP_PROD_HOST2CAM_MAX       0x6FFF

#define CDP_TEST_HOST2CAM_MIN       0x7000
#define CDP_TEST_HOST2CAM_MAX       0x7FFF

#define CDP_RESRV_HOST2CAM_MIN      0x8000
#define CDP_RESRV_HOST2CAM_MAX      0xFFFF

//
// Protocol command values
//
typedef enum {
    kCDPGetProductInfo = 0x0001,
    kCDPGetImageSpecifications = 0x0002,
    kCDPGetCameraStatus = 0x0003,
    kCDPSetProductInfo = 0x0005,
    kCDPGetCameraCapabilities = 0x0010,
    kCDPGetCameraState = 0x0011,
    kCDPSetCameraState = 0x0012,
    kCDPGetCameraDefaults = 0x0013,
    kCDPSetCameraDefaults = 0x0014,
    kCDPRestoreCameraStates = 0x0015,
    kCDPGetSceneAnalysis = 0x0018,
    kCDPGetPowerMode = 0x0019,
    kCDPSetPowerMode = 0x001a,
    kCDPGetS1Mode = 0x001d,
    kCDPSetS1Mode = 0x001e,
    kCDPStartCapture = 0x0030,
    kCDPGetFileList = 0x0040,
    kCDPGetNewFileList = 0x0041,
    kCDPGetFileData = 0x0042,
    kCDPEraseFile = 0x0043,
    kCDPGetStorageStatus = 0x0044,
    kCDPSetFileData = 0x0047,
    kCDPGetFileTag = 0x0048,
    kCDPSetUserFileTag = 0x0049,
    kCDPGetClock = 0x0070,
    kCDPSetClock = 0x0071,
    kCDPGetError = 0x0078,
    kCDPGetInterfaceTimeout = 0x0090,
    kCDPSetInterfaceTimeout = 0x0091,

} TCDPHostToCameraNewCommands;


typedef enum {
    kCHNoErr = 0x0000
} TCHCommonErrorCodes;


//
// Properties names for product info
//
// Nb: defined as 4 byte-long  packed string , always in lowercase
//

#define PI_FIRMWARE         (UINT32)'fwc'
#define PI_PRODUCTTYPEINFO  (UINT32)'pti'
#define PI_IPC              (UINT32)'ipc'
#define PI_CARV             (UINT32)'carv'

//
// Public functions and types
//

//
// GetImageSpecifications
//
typedef struct {

    // CCD Specifications
    TUINT32 CCDPattern;
    TUINT32 CCDPixelsHorz;
    TUINT32 CCDPixelsVert;
    TUINT32 CCDRingPixelsHorz;
    TUINT32 CCDRingPixelsVert;
    TUINT32 BadColumns;
    TUINT32 BadPixels;

    // Thumbnail specifications
    TUINT32 ThumbnailType;
    TUINT32 ThumbnailPixelsHorz;
    TUINT32 ThumbnailPixelsVert;
    TUINT32 ThumbnailFileSize;

    // Screennail specifications
    TUINT32 ScreennailType;
    TUINT32 ScreennailPixelsHorz;
    TUINT32 ScreennailPixelsVert;

    // Focus zone specifications
    TUINT32 FocusZoneType;
    TUINT32 FocusZoneNumHorz;
    TUINT32 FocusZoneNumVert;
    TUINT32 FocusZoneOriginHorz;
    TUINT32 FocusZoneOriginVert;
    TUINT32 FocusZoneSizeHorz;
    TUINT32 FocusZoneSizeVert;

    // Exposure zone specifications
    TUINT32 ExposureZoneType;
    TUINT32 ExposureZoneNumHorz;
    TUINT32 ExposureZoneNumVert;
    TUINT32 ExposureZoneOriginHorz;
    TUINT32 ExposureZoneOriginVert;
    TUINT32 ExposureZoneSizeHorz;
    TUINT32 ExposureZoneSizeVert;

} TImageSpecifications;

//
// GetError
//
typedef struct {
    TUINT32 Date;
    TUINT32 Time;
    TINT32  ErrorCode;
    TString ErrorDescription;
} TErrorData;

//
// GetCameraState
//

//
// GetFileList
//

typedef enum {
    kFSDriveRAM         = 1 ,     // internal RAM disk
    kFSDriveRemovable   = 2       // removable disk
} TDriveType;

typedef struct {
    TUINT32     DriveNo;
    TString     PathName;
    TDOSName    DOSName;
} TFileNameStruct;

typedef struct {
    TUINT32     DriveNo;
    TString     PathName;
    TDOSName    DOSName;
    TUINT32     FileLength;
    TBITFLAGS   FileStatus;
} TFileItem;


typedef struct {
    TUINT32     Offset;         // Starting relative position of requested data
    TUINT32     Length;         // Byte count of requested data
    TUINT32     FileSize;       // Total size of the file
} TPartialTag;

typedef struct {
    TUINT32     DataSize;       // Length of data returned
    TUINT32     Height;         // Height in pixels
    TUINT32     Width;          // Width in pixels
    TUINT32     Type;           // Format of the data

    BYTE        Data[1];        // Actual data

} TThumbnailData;

#ifndef RC_INVOKED
#include <poppack.h>
#endif // RC_INVOKED

#endif // _DIGITA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\debug.h ===
/***************************************************************************
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       debug.h
 *  Content:    debugging macros and prototypes
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *
 *   10/27/96   vlads   Loosely based on somebody's else debugging support
 *
 *@@END_MSINTERNAL
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 ***************************************************************************/

#ifndef _INC_DEBUG
#define _INC_DEBUG

#ifdef __cplusplus
extern "C"
{
#endif

#ifdef MAXDEBUG
    #define RD(x)       x
    #ifdef DEBUG
        #define D(x)    x
    #else
        #define D(x)
    #endif
#else
    #define RD(x)
    #define D(x)
#endif

/*****************************************************************************
 *
 *  assert.c - Assertion stuff
 *
 *****************************************************************************/

typedef enum {
    DbgFlAlways  = 0x00000000,   /* Unconditional    */
    DbgFlDll     = 0x00000001,   /* Dll bookkeeping  */
    DbgFlFactory = 0x00000002,   /* IClassFactory    */
    DbgFlSti     = 0x00000004,   /* ISti             */
    DbgFlStiObj  = 0x00000008,   /* ISti objects     */
    DbgFlDevice  = 0x00000010,   /* Device code      */
    DbgFlUtil    = 0x10000000,   /* Misc utility fns */
    DbgFlCommon  = 0x40000000,   /* common.c         */
    DbgFlError   = 0x80000000,   /* Errors           */
} DBGFL;                         /* debug output flags       */

VOID  EXTERNAL  InitializeDebuggingSupport(VOID);
VOID  EXTERNAL  SetDebugLogFileA(CHAR *pszLogFileName);
DBGFL EXTERNAL  SetCurrentDebugFlags(DBGFL NewFlags) ;

void EXTERNAL WarnPszV(LPCSTR ptsz, ...);
void EXTERNAL DebugOutPtszV(DBGFL DebFl, LPCTSTR ptsz, ...);
int  EXTERNAL AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine);

#ifndef DEBUG
#define DebugOutPtszV  1?(void)0 : (void)
#endif

#ifdef MAXDEBUG
    #define RPF WarnPszV
#else
    #define WarnPszV 1?(void)0 : (void)
    #define RPF 1?(void)0 : (void)
    #define iarg 0
#endif

/*****************************************************************************
 *
 *      Buffer scrambling
 *
 *      All output buffers should be scrambled on entry to any function.
 *
 *      Each output bitmask should set an unused bit randomly to ensure
 *      that callers ignore bits that aren't defined.
 *
 *****************************************************************************/

#ifdef MAXDEBUG

void EXTERNAL ScrambleBuf(LPVOID pv, UINT cb);
void EXTERNAL ScrambleBit(LPDWORD pdw, DWORD flMask);

#else

#define ScrambleBuf(pv, cb)
#define ScrambleBit(pdw, flRandom)

#endif

/*****************************************************************************
 *
 *      Procedure enter/exit tracking.
 *
 *      Start a procedure with
 *
 *      EnterProc(ProcedureName, (_ "format", arg, arg, arg, ...));
 *      EnterProcS(ProcedureName, (_ "format", arg, arg, arg, ...));
 *      EnterProcI(ProcedureName, (_ "format", arg, arg, arg, ...));
 *      EnterProcR(ProcedureName, (_ "format", arg, arg, arg, ...));
 *
 *      The format string is documented in EmitPal.
 *
 *      Suffixing an "S" indicates that the macro should not generate
 *      a procedure name because there is a formal parameter with the
 *      name s_szProc.  This is a hack.
 *
 *      Suffixing an "R" indicates that the macro should generate a
 *      procedure name in RDEBUG.
 *
 *      Suffixing an "I" indicates that the macro should emit a dummy
 *      procedure name in RDEBUG because the interface is internal.
 *
 *      End a procedure with one of the following:
 *
 *          ExitProc();
 *
 *              Procedure returns no value.
 *
 *          ExitProcX();
 *
 *              Procedure returns an arbitrary DWORD.
 *
 *          ExitOleProc();
 *
 *              Procedure returns an HRESULT (named "hres").
 *
 *          ExitOleProcPpv(ppvOut);
 *
 *              Procedure returns an HRESULT (named "hres") and, on success,
 *              puts a new object in ppvOut.
 *
 *****************************************************************************/

#define cpvArgMax   10  /* Max of 10 args per procedure */

typedef struct ARGLIST {
    LPCSTR pszProc;
    LPCSTR pszFormat;
    PV rgpv[cpvArgMax];
} ARGLIST, *PARGLIST;

void EXTERNAL ArgsPalPszV(PARGLIST pal, LPCSTR psz, ...);
void EXTERNAL EnterDbgflPszPal(DBGFL Dbgfl, LPCSTR psz, PARGLIST pal);
void EXTERNAL ExitDbgflPalHresPpv(DBGFL, PARGLIST, HRESULT, PPV);

#ifdef DEBUG_VALIDATE

extern DBGFL DbgFlCur;

#define AssertFPtsz(c, ptsz) \
        ((c) ? 0 : AssertPtszPtszLn(ptsz, TEXT(__FILE__), __LINE__))
#define ValidateF(c, arg) \
        ((c) ? 0 : (RPF arg, ValidationException(), 0))
#define ConfirmF(c) \
    ((c) ? 0 : AssertPtszPtszLn(TEXT(#c), TEXT(__FILE__), __LINE__))

#else   /* !DEBUG */

#define AssertFPtsz(c, ptsz)
#define ValidateF(c, arg)
#define ConfirmF(c)     (c)

#endif

/*
 *  CAssertF - compile-time assertion.
 */
#define CAssertF(c)     switch(0) case c: case 0:

#define _SetupEnterProc(nm)                             \
        static CHAR s_szProc[] = #nm;                   \
        ARGLIST _al[1]                                  \

#define _ _al,

#define ppvDword ((PPV)1)
#define ppvVoid  ((PPV)2)
#define ppvBool  ((PPV)3)

#define _DoEnterProc(v)                                 \
        ArgsPalPszV v;                                  \
        EnterDbgflPszPal(DbgFl, s_szProc, _al)            \

#define _EnterProc(nm, v)                               \
        _SetupEnterProc(nm);                            \
        _DoEnterProc(v)                                 \

#define _ExitOleProcPpv(ppv)                            \
        ExitDbgflPalHresPpv(DbgFl, _al, hres, (PPV)(ppv)) \

#define _ExitOleProc()                                  \
        _ExitOleProcPpv(0)                              \

#define _ExitProc()                                     \
        ExitDbgflPalHresPpv(DbgFl, _al, 0, ppvVoid)       \

#define _ExitProcX(x)                                   \
        ExitDbgflPalHresPpv(DbgFl, _al, (HRESULT)(x), ppvDword) \

#define _ExitProcF(x)                                   \
        ExitDbgflPalHresPpv(DbgFl, _al, (HRESULT)(x), ppvBool) \

#if defined(DEBUG)

#define EnterProc           _EnterProc
#define ExitOleProcPpv      _ExitOleProcPpv
#define ExitOleProc         _ExitOleProc
#define ExitProc            _ExitProc
#define ExitProcX           _ExitProcX
#define ExitProcF           _ExitProcF

#define EnterProcS(nm, v)                               \
        static CHAR s_szProc2[] = #nm;                  \
        ARGLIST _al[1];                                 \
        ArgsPalPszV v;                                  \
        EnterDbgflPszPal(DbgFl, s_szProc2, _al)           \

#define EnterProcI          _EnterProc
#define EnterProcR          _EnterProc
#define ExitOleProcPpvR     _ExitOleProcPpv
#define ExitOleProcR        _ExitOleProc
#define ExitProcR           _ExitProc
#define ExitProcXR          _ExitProcX
#define ExitProcFR          _ExitProcF

#elif defined(RDEBUG)

#define EnterProc(nm, v)
#define ExitOleProcPpv(ppv)
#define ExitOleProc()
#define ExitProc()
#define ExitProcX(x)
#define ExitProcF(x)

#define EnterProcS(nm, v)
#define EnterProcI(nm, v)   static CHAR s_szProc[] = ""
#define EnterProcR(nm, v)   static CHAR s_szProc[] = #nm
#define ExitOleProcPpvR(ppv)
#define ExitOleProcR()
#define ExitProcR()
#define ExitProcXR()
#define ExitProcFR()

#else

#define EnterProc(nm, v)
#define ExitOleProcPpv(ppv)
#define ExitOleProc()
#define ExitProc()
#define ExitProcX(x)
#define ExitProcF(x)

#define EnterProcS(nm, v)
#define EnterProcI(nm, v)
#define EnterProcR(nm, v)
#define ExitOleProcPpvR(ppv)
#define ExitOleProcR()
#define ExitProcR()
#define ExitProcXR(x)
#define ExitProcFR(x)

#endif

#define AssertF(c)      AssertFPtsz(c, TEXT(#c))


#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\digitaer.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    digitaer.h

Abstract:

    FlashPoint Digita command language error codes

Notes:

    Non-portable, for use with Win32 environment.

Author:

    Vlad Sadovsky   (VladS)    11/13/1998

Environment:

    User Mode - Win32

Revision History:

    11/13/1998      VladS       Created

--*/

#pragma once

typedef     UINT    CDPERROR   ;

//
// No error detected
//
#define CDPERR_NOERROR          0

//
// Illegal command or command not implemented
//
#define CDPERR_UNIMPLEMENTED    1

//
// Protocol error
//
#define CDPERR_PROT_ERROR       2

//
// Timeout of interface
//
#define CDPERR_APPTIMEOUT       3

//
// Memory errors, corrupted image, OS errors, media read/write errors , etc
//
#define CDPERR_INTERNAL         4

//
// INvalid parameter value
//
#define CDPERR_INVALID_PARAM    5

//
// File system is full
//
#define CDPERR_FILESYS_FULL     6

//
// Specified file is not found
//
#define CDPERR_FILE_NOT_FOUND   7

//
// Image does not contain data section ( f.e. thumbnail, audio )
//
#define CDPERR_DATA_NOT_FOUND   8

//
// Unknown file type
//
#define CDPERR_INVALID_FILE_TYPE  9

//
// Unknown drive name
//
#define CDPERR_UNKNOWN_DRIVE    10

//
// Specified drive is not mounted
//
#define CDPERR_DRIVE_NOT_MOUNTED 11

//
// System is currently busy
//
#define CDPERR_SYSTEM_BUSY      12

//
// Low battery
//
#define CDPERR_BATTERY_LOW      13


#ifndef CDPERR_CANCEL_CALLBACK
//BUGBUG
#define CDPERR_CANCEL_CALLBACK  141
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\eventlog.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    eventlog.h

Abstract:

    This file defines functions and types required for logging events to the event logger.

Author:

    Vlad Sadovsky (vlads)   10-Jan-1997


Environment:

    User Mode - Win32

Revision History:

    26-Jan-1997     VladS       created

--*/

# ifndef _EVENTLOG_H_
# define _EVENTLOG_H_

# include <windows.h>

/***********************************************************
 *    Type Definitions
 ************************************************************/

class EVENT_LOG  {

  private:

     DWORD     m_ErrorCode;     // error code for last operation
     HANDLE    m_hEventSource;  // handle for reporting events
     LPCTSTR   m_lpszSource;    // source name for event log

  public:

     dllexp
     EVENT_LOG( IN LPCTSTR lpszSourceName);   // name of source for event log

     dllexp
    ~EVENT_LOG( VOID);

     dllexp
     VOID
     LogEvent(
        IN DWORD  idMessage,                  // id for log message
        IN WORD   cSubStrings,                // count of substrings
        IN const  CHAR * apszSubStrings[],    // substrings in the message
        IN DWORD  errCode = 0);               // error code if any

     VOID
     LogEvent(
        IN DWORD  idMessage,                  // id for log message
        IN WORD   cSubStrings,                // count of substrings
        IN CHAR * apszSubStrings[],           // substrings in the message
        IN DWORD  errCode = 0)                // error code if any
    {
        LogEvent(idMessage, cSubStrings,
                 (const CHAR **) apszSubStrings, errCode);
    }

     dllexp
     VOID
     LogEvent(
        IN DWORD   idMessage,                  // id for log message
        IN WORD    cSubStrings,                // count of substrings
        IN WCHAR * apszSubStrings[],           // substrings in the message
        IN DWORD   errCode = 0);               // error code if any

     BOOL Success( VOID) const
     { return ( m_ErrorCode == NO_ERROR); }

     DWORD GetErrorCode( VOID) const
     { return ( m_ErrorCode); }

  private:

     dllexp VOID
     LogEventPrivate(
        IN DWORD idMessage,
        IN WORD  wEventType,
        IN WORD  cSubStrings,
        IN const CHAR * apszSubStrings[],
        IN DWORD  errCode);

};

typedef EVENT_LOG * LPEVENT_LOG;

VOID
WINAPI
RegisterStiEventSources(VOID);

# endif // _EVENTLOG_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\makefile.inc ===
# If this is NT, define robust flag and /Oicf switch, but for Chicago platforms define
# the switch only (robust is not valid)
!ifndef CHICAGO_PRODUCT
MIDL_FLAGS=$(MIDL_FLAGS) -robust /Oicf
!else
MIDL_FLAGS=$(MIDL_FLAGS) /Oicf
!endif


$(TARGETSRCS_WIA) : $(WIA_INC_DIR)\wia.idl $(WIA_INC_DIR)\wia.acf
    midl $(MIDL_FLAGS) /I$(WIA_INC_DIR) /I$(SDK_INC_PATH) \
         /h $(O)\wia.h \
         /dlldata $(O)\wia_a.c \
         /acf wia.acf \
         /tlb $(O)\wia.tlb \
         /proxy $(O)\wia_p.c \
         /iid $(O)\wia_i.c \
         wia.idl

$(TARGETSRCS_MINI)   : $(WIA_INC_DIR)\wiamindr.idl $(WIA_INC_DIR)\wia.idl
    midl $(MIDL_FLAGS) /I$(WIA_INC_DIR) /I$(SDK_INC_PATH) \
         /h $(O)\wiamindr.h \
         /dlldata $(O)\wiamindr_a.c \
         /tlb $(O)\wiamindr.tlb \
         /proxy $(O)\wiamindr_p.c \
         /iid $(O)\wiamindr_i.c \
         wiamindr.idl

$(TARGETSRCS_WIASCRIPT) : $(WIA_INC_DIR)\wiascr.idl
    midl $(MIDL_FLAGS) /I$(WIA_INC_DIR) /I$(SDK_INC_PATH) \
         /h $(O)\wiascr.h \
         /dlldata $(O)\wiascr_a.c \
         /tlb $(O)\wiascr.tlb \
         /proxy $(O)\wiascr_p.c \
         /iid $(O)\wiascr_i.c \
         wiascr.idl

$(TARGETSRCS_PRIV) : $(WIA_INC_DIR)\wiapriv.idl
    midl $(MIDL_FLAGS) /I$(WIA_INC_DIR) /I$(SDK_INC_PATH) \
         /h $(O)\wiapriv.h \
         /dlldata $(O)\wia_a.c \
         /tlb $(O)\wiapriv.tlb \
         /proxy $(O)\wiapriv_p.c \
         /iid $(O)\wiapriv_i.c \
         wiapriv.idl

$(TARGETSRCS_VIDEO) : $(WIA_INC_DIR)\wiavideo.idl
    midl $(MIDL_FLAGS) /I$(WIA_INC_DIR) /I$(SDK_INC_PATH) \
         /h $(O)\wiavideo.h \
         /dlldata $(O)\wiavideo_a.c \
         /tlb $(O)\wiavideo.tlb \
         /proxy $(O)\wiavideo_p.c \
         /iid $(O)\wiavideo_i.c \
         wiavideo.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\linklist.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    linklist.h

Abstract:

    This file contains the generic doubly-linked list manipulation package
    stolen from NT & made digestible by Win95

Author:

    Vlad Sadovsky   (VladS)    11-Feb-1997

Revision History:

    VladS   02-11-97    Extracted from NT SDK headers to use on Win9x

--*/


#ifndef _LINKLIST_H_
#define _LINKLIST_H_


//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#ifndef CONTAINING_RECORD
#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (PCHAR)(&((type *)0)->field)))
#endif  // CONTAINING_RECORD

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//


//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }


#endif  // _LINKLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\enum.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    enum.h

Abstract:

Author:

        Keisuke Tsuchida    (KeisukeT)    01-Jun-2000

Revision History:


--*/

#ifndef _ENUM_H_
#define _ENUM_H_


//
// Define
//


#define MONITOR_NAME            TEXT("STIMON.EXE")
#define RUNDLL32                TEXT("RUNDLL32.EXE")
#define STILL_IMAGE             TEXT("StillImage")
#define FRIENDLYNAME            TEXT("FriendlyName")
#define VENDORSETUP             TEXT("VendorSetup")
#define DEVICESECTION           TEXT("DeviceData")
#define PORTNAME                TEXT("PortName")
#define DEVICETYPE              TEXT("DeviceType")
#define DEVICESUBTYPE           TEXT("DeviceSubType")
#define CREATEFILENAME          TEXT("CreateFileName")
#define CAPABILITIES            TEXT("Capabilities")
#define EVENTS                  TEXT("Events")
#define PROPERTYPAGES           TEXT("PropertyPages")
#define VENDOR                  TEXT("Vendor")
#define UNINSTALLSECTION        TEXT("UninstallSection")
#define SUBCLASS                TEXT("SubClass")
#define ICMPROFILES             TEXT("ICMProfiles")
#define INFPATH                 TEXT("InfPath")
#define INFSECTION              TEXT("InfSection")
#define ISPNP                   TEXT("IsPnP")
#define LPTENUM                 TEXT("LptEnum")
#define ENUM                    TEXT("\\Enum")
#define PORTS                   TEXT("Ports")
#define DONT_LOAD               TEXT("don't load")
#define CONTROL_INI             TEXT("control.ini")
#define CPL_NAME                TEXT("sticpl.cpl")
#define NO                      TEXT("no")
#define LAUNCH_APP              TEXT("LaunchApplications")
#define SZ_GUID                 TEXT("GUID")
#define CONNECTION              TEXT("Connection")
#define SERIAL                  TEXT("Serial")
#define PARALLEL                TEXT("Parallel")
#define BOTH                    TEXT("Both")
#define AUTO                    TEXT("AUTO")
#define VIDEO_PATH_ID           TEXT("DShowDeviceId")
#define DEVICESECTION           TEXT("DeviceData")
#define WIAACMGR_PATH           TEXT("wiaacmgr.exe")
#define WIAACMGR_ARG            TEXT("-SelectDevice")
#define WIADEVLISTMUTEX         TEXT("WiaDeviceListMutex")
#define WIA_GUIDSTRING          TEXT("{6BDD1FC6-810F-11D0-BEC7-08002BE2092F}")

#define REGKEY_DEVICE_PARMS             TEXT("Device Parameters")
#define REGKEY_CONTROLINIFILEMAPPING    TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping\\control.ini")
#define REGSTR_VAL_FRIENDLY_NAME        TEXT("FriendlyName")
#define REGSTR_VAL_FRIENDLY_NAME_A      "FriendlyName"
#define REGSTR_VAL_DEVICE_ID            TEXT("DeviceID")
#define REGSTR_VAL_DEVICE_ID_W          L"DeviceID"
#define REGSTR_VAL_DEVICE_ID_A          "DeviceID"

#define FLAG_NO_LPTENUM         1
#define ENUMLPT_HOLDTIME        3000    // in millisec

//
// Typedef
//

typedef struct _WIA_DEVPROP {

    BOOL    bIsPlugged;
    ULONG   ulProblem;
    ULONG   ulStatus;
    HKEY    hkDeviceRegistry;

} WIA_DEVPROP, *PWIA_DEVPROP;

typedef struct _WIA_DEVKEYLIST {

    DWORD           dwNumberOfDevices;
    WIA_DEVPROP     Dev[1];

} WIA_DEVKEYLIST, *PWIA_DEVKEYLIST;



//
// Prototype
//

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

PWIA_DEVKEYLIST
WiaCreateDeviceRegistryList(
    BOOL    bEnumActiveOnly
    );

VOID
WiaDestroyDeviceRegistryList(
    PWIA_DEVKEYLIST pWiaDevKeyList
    );

BOOL IsStiRegKey(
    HKEY    hkDevRegKey);

BOOL
IsPnpLptExisting(
    VOID
    );
    
VOID
EnumLpt(
    VOID
    );


#ifdef __cplusplus
}
#endif // __cplusplus



#endif // _ENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\hpojsti.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    hpojsti.h

Abstract:


Notes:

Author:

    Vlad Sadovsky   (VladS)    6/4/1999

Environment:

    User Mode - Win32

Revision History:

    6/4/1999        VladS       Created

--*/


//
// Set packing
//
#include <pshpack8.h>

//
// Escape function codes
//

//
// Get timeout values
//
#define HPOJ_STI_GET_TIMEOUTS   1


//
// Set timeout values
//
#define HPOJ_STI_SET_TIMEOUTS   2



//
// Escape data structures
//
typedef struct _PTIMEOUTS_INFO
{
    DWORD   dwReadTimeout;
    DWORD   dwWriteTimeout;

} TIMEOUTS_INFO, *PTIMEOUTS_INFO;

EXTERN_C
INT32
WINAPI
GetScannerTimeouts(
    INT32    *puiReadTimeout,
    INT32    *puiWriteTimeout
    );

EXTERN_C
INT32
WINAPI
SetScannerTimeouts(
    INT32    uiReadTimeout,
    INT32    uiWriteTimeout
    );

//
// Reset packing
//

#include <poppack.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\lock.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    lock.h

Abstract:

    Portable synronization primitive class ( between Win9x and NT)
    Win9x does not

Author:

    Vlad Sadovsky (vlads)   02-Jan-1997


Environment:

    User Mode - Win32

Revision History:

    02-Jan-1997     VladS       created

--*/


# ifndef _LOCK_H_
# define _LOCK_H_

/************************************************************
 *     Include Headers
 ************************************************************/

# ifdef _cplusplus
extern "C" {
# endif // _cplusplus

# ifdef _cplusplus
}; // extern "C"
# endif // _cplusplus

#ifndef DBG_REQUIRE
#define DBG_REQUIRE REQUIRE
#endif


#ifndef RTL_RESOURCE

//
//  Shared resource function definitions. It is declared in NTRTL , but not in windows SDK header files
//

typedef struct _RTL_RESOURCE {

    //
    //  The following field controls entering and exiting the critical
    //  section for the resource
    //

    RTL_CRITICAL_SECTION CriticalSection;

    //
    //  The following four fields indicate the number of both shared or
    //  exclusive waiters
    //

    HANDLE SharedSemaphore;
    ULONG NumberOfWaitingShared;
    HANDLE ExclusiveSemaphore;
    ULONG NumberOfWaitingExclusive;

    //
    //  The following indicates the current state of the resource
    //
    //      <0 the resource is acquired for exclusive access with the
    //         absolute value indicating the number of recursive accesses
    //         to the resource
    //
    //       0 the resource is available
    //
    //      >0 the resource is acquired for shared access with the
    //         value indicating the number of shared accesses to the resource
    //

    LONG NumberOfActive;
    HANDLE ExclusiveOwnerThread;

    ULONG Flags;        // See RTL_RESOURCE_FLAG_ equates below.

    PVOID DebugInfo;
} RTL_RESOURCE, *PRTL_RESOURCE;

#define RTL_RESOURCE_FLAG_LONG_TERM     ((ULONG) 0x00000001)

#endif // RTL_RESOURCE

/************************************************************
 *   Type Definitions
 ************************************************************/

# ifdef _cplusplus
extern "C" {
# endif // _cplusplus


BOOL
InitializeResource(
    IN PRTL_RESOURCE Resource
    );


BOOL
AcquireResourceShared(
    IN PRTL_RESOURCE Resource,
    IN BOOL          Wait
    );


BOOL
AcquireResourceExclusive(
    IN PRTL_RESOURCE Resource,
    IN BOOL Wait
    );


BOOL
ReleaseResource(
    IN PRTL_RESOURCE Resource
    );


BOOL
ConvertSharedToExclusive(
    IN PRTL_RESOURCE Resource
    );


BOOL
ConvertExclusiveToShared(
    IN PRTL_RESOURCE Resource
    );


VOID
DeleteResource (
    IN PRTL_RESOURCE Resource
    );

# ifdef _cplusplus
}; // extern "C"
# endif // _cplusplus


///////////////////////////////////////////////////////////////////////
//
//  Simple RTL_RESOURCE Wrapper class
//
//////////////////////////////////////////////////////////////////////

enum SYNC_LOCK_TYPE
{
    SYNC_LOCK_READ = 0,        // Take the lock for read only
    SYNC_LOCK_WRITE            // Take the lock for write
};

enum SYNC_CONV_TYPE
{
    SYNC_CONV_READ = 0,        // Convert the lock from write to read
    SYNC_CONV_WRITE            // Convert the lock from read to write
};

class SYNC_RESOURCE
{

friend class TAKE_SYNC_RESOURCE;

public:

    SYNC_RESOURCE()
        {  InitializeResource( &_rtlres ); }

    ~SYNC_RESOURCE()
        { DeleteResource( &_rtlres ); }

    void Lock( enum SYNC_LOCK_TYPE type )
        { if ( type == SYNC_LOCK_READ ) {
              DBG_REQUIRE( AcquireResourceShared( &_rtlres, TRUE ) );
           } else {
              DBG_REQUIRE( AcquireResourceExclusive( &_rtlres, TRUE ));
           }
        }

    void Convert( enum SYNC_CONV_TYPE type )
        { if ( type == SYNC_CONV_READ ) {
              DBG_REQUIRE( ConvertExclusiveToShared( &_rtlres ));
          } else {
              DBG_REQUIRE( ConvertSharedToExclusive( &_rtlres ));
          }
        }

    void Unlock( VOID )
        { DBG_REQUIRE( ReleaseResource( &_rtlres )); }

private:
    RTL_RESOURCE _rtlres;
};


///////////////////////////////////////////////////////////////////
// Instantiate one of these classes in a block of code
// when you want that block of code to be protected
// against re-entrancy.
// The Take() and Release() functions should rarely be necessary,
// and must be used in matched pairs with Release() called first.
///////////////////////////////////////////////////////////////////

class TAKE_SYNC_RESOURCE
{
private:
    SYNC_RESOURCE& _syncres;

public:
    void Take(void) { _syncres.Lock(SYNC_LOCK_WRITE); }
    void Release(void) { _syncres.Unlock(); }
    TAKE_SYNC_RESOURCE(SYNC_RESOURCE& syncres) : _syncres(syncres) { Take(); }
    ~TAKE_SYNC_RESOURCE() { Release(); }
};

//
// Auto critical section clss
//

class CRIT_SECT
{
public:
    BOOL Lock()
    {
        if (m_bInitialized) {
            EnterCriticalSection(&m_sec);
            return TRUE;
        }
        return FALSE;
    }

    void Unlock()
    {
        LeaveCriticalSection(&m_sec);
    }

    CRIT_SECT()
    {
        m_bInitialized = FALSE;
        __try {
            #ifdef UNICODE
            if(InitializeCriticalSectionAndSpinCount(&m_sec, MINLONG)) {
            #else
            InitializeCriticalSection(&m_sec); {
            #endif
                m_bInitialized = TRUE;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    ~CRIT_SECT()
    {
        if (m_bInitialized) {
            DeleteCriticalSection(&m_sec);
            m_bInitialized = FALSE;
        }
    }
    BOOL    IsInitialized() {return m_bInitialized;}

    CRITICAL_SECTION m_sec;
    BOOL       m_bInitialized;
};

class TAKE_CRIT_SECT
{
private:
    CRIT_SECT& _syncres;
    BOOL       m_bLocked;

public:
    inline TAKE_CRIT_SECT(CRIT_SECT& syncres) : _syncres(syncres), m_bLocked(FALSE) { m_bLocked = _syncres.Lock(); }
    inline ~TAKE_CRIT_SECT() { if (m_bLocked) {_syncres.Unlock(); m_bLocked = FALSE;}; }
};

//
// Auto mutex class
//

class MUTEX_OBJ
{
private:
    HANDLE m_hMutex;

public:
    BOOL inline  IsValid(VOID) {return (m_hMutex!=INVALID_HANDLE_VALUE);}
    void Lock() { ::WaitForSingleObject(m_hMutex, INFINITE); }
    void Unlock() { ::ReleaseMutex(m_hMutex); }
    MUTEX_OBJ(LPCTSTR   pszName) {
        m_hMutex = ::CreateMutex(NULL,
                                 FALSE,
                                 pszName
                                 );
    }

    ~MUTEX_OBJ() {CloseHandle(m_hMutex);m_hMutex = INVALID_HANDLE_VALUE;}
};

class TAKE_MUTEX
{
private:
    HANDLE const m_hMutex;

public:
    void Take(void) { ::WaitForSingleObject(m_hMutex, INFINITE); }
    void Release(void) { ::ReleaseMutex(m_hMutex); }
    TAKE_MUTEX(HANDLE hMutex) : m_hMutex(hMutex) { Take(); }
    ~TAKE_MUTEX() { Release(); }
};

class TAKE_MUTEX_OBJ
{
private:
    MUTEX_OBJ& _syncres;

public:
    inline TAKE_MUTEX_OBJ(MUTEX_OBJ& syncres) : _syncres(syncres) { _syncres.Lock(); }
    inline ~TAKE_MUTEX_OBJ() { _syncres.Unlock(); }
};

# endif // _LOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\missdef.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       MISSDEF.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      KeisukeT
 *
 *  DATE:        1/14/2000
 *
 *  DESCRIPTION: Where to put definitions which should be common header file.
 *
 *******************************************************************************/
#ifndef _MISSDEF_H_INCLUDED
#define _MISSDEF_H_INCLUDED


#endif // !_MISSDEF_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\eventregistrationinfo.h ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        3/24/2002
 *
 *  @doc    INTERNAL
 *
 *  @module EventRegistrationInfo.h - Definitions for <c EventRegistrationInfo> |
 *
 *  This file contains the class definition for <c EventRegistrationInfo>.
 *
 *****************************************************************************/

#define WILDCARD_DEVICEID_STR   L"*"

/*****************************************************************************
 *  
 *  @doc INTERNAL
 *  
 *  @class EventRegistrationInfo | Holds the event info relating to a specific 
 *  registration.
 *  
 *  @comm
 *  Instances of this class hold information relating to a client's run-time 
 *  event registration.  When an event occurs, this information is used to 
 *  determine whether the event matches a given registration.
 *
 *  A list of all a client's registrations is stored by instances
 *  of <c WiaEventClient>.
 *****************************************************************************/
class EventRegistrationInfo 
{
//@access Public members
public:

    // @cmember Constructor
    EventRegistrationInfo(DWORD dwFlags, GUID guidEvent, WCHAR *wszDeviceID, ULONG_PTR Callback = 0);
    // @cmember Destructor
    virtual ~EventRegistrationInfo();

    // @cmember Increment reference count
    virtual ULONG __stdcall AddRef();
    // @cmember Decrement reference count
    virtual ULONG __stdcall Release();

    // @cmember Accessor method for the flags
    DWORD       getFlags();
    // @cmember Accessor method for the EventGuid
    GUID        getEventGuid();
    // @cmember Accessor method for the device id
    BSTR        getDeviceID();
    // @cmember Accessor method for the event callback
    ULONG_PTR   getCallback();

    // @cmember Returns true if this registration matches the device event
    BOOL MatchesDeviceEvent(BSTR bstrDevice, GUID guidEvent);
    // @cmember Returns true if this registration is semantically equivalent
    BOOL Equals(EventRegistrationInfo *pEventRegistrationInfo);
    // @cmember Dumps the fields of this class.
    VOID Dump();

//@access Protected members
protected:

    // @cmember Ref count
    ULONG m_cRef;

    // @cmember The flags used when registering
    DWORD m_dwFlags;
    // @cmember The event this registration is for
    GUID m_guidEvent;
    // @cmember The WIA DeviceID whose events we're interested in
    BSTR m_bstrDeviceID;
    // @cmember The callback part of this registration
    ULONG_PTR   m_Callback;

    //
    //  Comments for member variables
    //
    // @mdata ULONG | EventRegistrationInfo | m_cRef | 
    //   The reference count for this class.  Used for lifetime 
    //   management.
    //
    // @mdata DWORD | EventRegistrationInfo | m_dwFlags | 
    // The flags used when registering.
    //
    // @mdata GUID | EventRegistrationInfo | m_guidEvent | 
    // The event this registration is for.
    //
    // @mdata BSTR | EventRegistrationInfo | m_bstrDeviceID | 
    // The WIA DeviceID whose events we're interested in.  If this is
    //  "*", it means we're interested in all devices.
    //
    // @mdata ULONG_PTR | EventRegistrationInfo | m_Callback | 
    // When a client registers for a WIA event notification, it specifies
    // a callback on which to receive the notification.  Since we do not use
    // COM to do the registration on the server-side, this callback pointer
    // cannot be used there.  It does however help to uniquely identify
    // a certain registration (e.g. Registration for event X on Device Foo for Interface I
    // is different to registration for event X on Device Foo for Interface J).
    // On the client-side, it is used to store the client callback pointer since
    // it has meaning in the client address space.
    //
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\out_stidebug.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stidebug.h

Abstract:

    Environment independent assertion/logging routines

    Usage:

        ASSERT(exp)     Evaluates its argument.  If "exp" evals to
                        FALSE, then the app will terminate, naming
                        the file name and line number of the assertion
                        in the source.

        UIASSERT(exp)   Synonym for ASSERT.

        ASSERTSZ(exp,sz) As ASSERT, except will also print the message
                        "sz" with the assertion message should it fail.

        REQUIRE(exp)    As ASSERT, except that its expression is still
                        evaluated in retail versions.  (Other versions
                        of ASSERT disappear completely in retail builds.)

    The ASSERT macros expect a symbol _FILENAME_DEFINED_ONCE, and will
    use the value of that symbol as the filename if found; otherwise,
    they will emit a new copy of the filename, using the ANSI C __FILE__
    macro.  A client sourcefile may therefore define __FILENAME_DEFINED_ONCE
    in order to minimize the DGROUP footprint of a number of ASSERTs.

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/



#ifndef _STIDEBUG_H_
#define _STIDEBUG_H_

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#if defined(__cplusplus)
extern "C"
{
#endif

VOID UIAssertHelper( const CHAR* pszFileName, UINT nLine );
VOID UIAssertSzHelper( const CHAR* pszMessage, const CHAR* pszFileName, UINT nLine );

VOID AssertHelper( const CHAR* pszFileName, UINT nLine );
VOID AssertSzHelper( const CHAR* pszMessage, const CHAR* pszFileName, UINT nLine );

#if defined(DEBUG)

# ifdef USE_MESSAGEBOX_UI

#  define ASSERT(exp) \
    { if (!(exp)) UIAssertHelper(__FILE__, __LINE__); }

#  define ASSERTSZ(exp, sz) \
    { if (!(exp)) UIAssertSzHelper((sz), __FILE__, __LINE__); }

# else

#ifndef ASSERT
#  define ASSERT(exp) \
    { if (!(exp)) AssertHelper(__FILE__, __LINE__); }
#endif

#  define ASSERTSZ(exp, sz) \
    { if (!(exp)) AssertSzHelper((sz), __FILE__, __LINE__); }

#define EVAL(exp)   \
    ((exp) || AssertHelper(__FILE__, __LINE__))

# endif // USE_MESSAGEBOX_UI

# define UIASSERT(exp)  ASSERT(exp)
# define REQUIRE(exp)   ASSERT(exp)

#else // !DEBUG

#ifndef ASSERT
# define ASSERT(exp)        ;
#endif

# define EVAL(exp)          ;
# define UIASSERT(exp)      ;
# define ASSERTSZ(exp, sz)  ;
# define REQUIRE(exp)       { (exp); }

#endif // DEBUG



//
// Debug mask management.
//

// NOTE: You can #define your own DM_* values using bits in the HI BYTE

#define DM_TRACE    0x0001      // Trace messages
#define DM_WARNING  0x0002      // Warning
#define DM_ERROR    0x0004      // Error
#define DM_ASSERT   0x0008      // Assertions
#define DM_DATA     0x0010      // Data Transfered
#define DM_INFO         0x0020      // Info we are currently interested in

#define DM_LOG_FILE 0x0100
#define DM_PREFIX   0x0200


#if !defined(StiDebugMsg)

//
// StiDebugMsg(mask, msg, args...) - Generate wsprintf-formatted msg using
// specified debug mask.  System debug mask governs whether message is output.
//

#define REGVAL_STR_DEBUGMASK_A    "DebugMask"
#define REGVAL_STR_DEBUGMASK_W    L"DebugMask"

void __cdecl StiDebugMsg(UINT mask, LPCSTR psz, ...);

UINT WINAPI  StiSetDebugParameters(PSTR pszName,PSTR pszLogFile);
UINT WINAPI  StiSetDebugMask(UINT mask);
UINT WINAPI  StiGetDebugMask(void);

#endif

#ifdef  DEBUG

#define Break()  DebugBreak()
#define DPRINTF  StiDebugMsg

#else

#define Break()

//
// Nb: Following definition is needed to avoid compiler complaining
// about empty function name in expression. In retail builds using this macro
// will cause string parameters not appear in executable
//
#define DPRINTF     1?(void)0 : (void)

#endif

#if defined(__cplusplus)
}
#endif

#if defined(__cplusplus)

#ifdef  DEBUG

class DBGTRACE
{
private:
    TCHAR   m_szMessage[200];

public:
    inline DBGTRACE(LPTSTR szMsg) {
        lstrcpy(m_szMessage,szMsg);
        DPRINTF(DM_TRACE,"ProcTraceEnter:%s",m_szMessage);
    }

    inline ~DBGTRACE() {
        DPRINTF(DM_TRACE,"ProcTraceExit:%s",m_szMessage);
    }
};


#else

class DBGTRACE
{
public:
    inline DBGTRACE(LPTSTR szMsg) {
    }

    inline ~DBGTRACE() {
    }
};
#endif

#endif

#endif // _STIDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\scsiscan.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 1996-2000, MICROSOFT CORP.
*
*  FILE:        scsiscan.h
*
*  VERSION:     1.0
*
*  DATE:        2/11/1997
*
*  DESCRIPTION:
*    IOCTL definitions for the SCSI scanner device driver.
*
*****************************************************************************/

//
// Turns off []
//
#pragma warning(disable : 4200)

#ifndef _SCSISCAN_H_
#define _SCSISCAN_H_

// SCSISCAN_CMD.SrbFlags

#define SRB_FLAGS_DISABLE_SYNCH_TRANSFER    0x00000008
#define SRB_FLAGS_DISABLE_AUTOSENSE         0x00000020
#define SRB_FLAGS_DATA_IN                   0x00000040
#define SRB_FLAGS_DATA_OUT                  0x00000080
#define SRB_FLAGS_NO_DATA_TRANSFER          0x00000000

// SCSISCAN_CMD.SrbStatus definitions

#define SRB_STATUS_PENDING                  0x00
#define SRB_STATUS_SUCCESS                  0x01
#define SRB_STATUS_ABORTED                  0x02
#define SRB_STATUS_ABORT_FAILED             0x03
#define SRB_STATUS_ERROR                    0x04
#define SRB_STATUS_BUSY                     0x05
#define SRB_STATUS_INVALID_REQUEST          0x06
#define SRB_STATUS_INVALID_PATH_ID          0x07
#define SRB_STATUS_NO_DEVICE                0x08
#define SRB_STATUS_TIMEOUT                  0x09
#define SRB_STATUS_SELECTION_TIMEOUT        0x0A
#define SRB_STATUS_COMMAND_TIMEOUT          0x0B
#define SRB_STATUS_MESSAGE_REJECTED         0x0D
#define SRB_STATUS_BUS_RESET                0x0E
#define SRB_STATUS_PARITY_ERROR             0x0F
#define SRB_STATUS_REQUEST_SENSE_FAILED     0x10
#define SRB_STATUS_NO_HBA                   0x11
#define SRB_STATUS_DATA_OVERRUN             0x12
#define SRB_STATUS_UNEXPECTED_BUS_FREE      0x13
#define SRB_STATUS_PHASE_SEQUENCE_FAILURE   0x14
#define SRB_STATUS_BAD_SRB_BLOCK_LENGTH     0x15
#define SRB_STATUS_REQUEST_FLUSHED          0x16
#define SRB_STATUS_INVALID_LUN              0x20
#define SRB_STATUS_INVALID_TARGET_ID        0x21
#define SRB_STATUS_BAD_FUNCTION             0x22
#define SRB_STATUS_ERROR_RECOVERY           0x23

#define SRB_STATUS_QUEUE_FROZEN             0x40
#define SRB_STATUS_AUTOSENSE_VALID          0x80

#define SRB_STATUS(Status) (Status & ~(SRB_STATUS_AUTOSENSE_VALID | SRB_STATUS_QUEUE_FROZEN))

typedef struct _SCSISCAN_CMD {
	ULONG   Reserved1;	
	ULONG   Size;
	ULONG   SrbFlags;				
	UCHAR   CdbLength;
	UCHAR   SenseLength;
	UCHAR	Reserved2;
	UCHAR	Reserved3;
	ULONG   TransferLength;
	UCHAR	Cdb[16];	
	PUCHAR  pSrbStatus;
	PUCHAR	pSenseBuffer;
} SCSISCAN_CMD, *PSCSISCAN_CMD;
	
// Temporarily set to 128. Should be determined by other definition.
#define MAX_STRING 128

typedef struct _SCSISCAN_INFO{
	ULONG   Size;
	ULONG   Flags;
    UCHAR   PortNumber;
    UCHAR   PathId;
    UCHAR   TargetId;
    UCHAR   Lun;
    UCHAR   AdapterName[MAX_STRING];
	ULONG   Reserved;
} SCSISCAN_INFO, *PSCSISCAN_INFO;

#define SCSISCAN_RESERVED         0x000
#define SCSISCAN_CMD_CODE         0x004
#define SCSISCAN_LOCKDEVICE       0x005
#define SCSISCAN_UNLOCKDEVICE     0x006
#define SCSISCAN_SET_TIMEOUT      0x007
#define SCSISCAN_GET_INFO         0x008

//---------------------------------------------------------------------------
// IOCTL definitions.
// Use these definitions when calling DeviceIoControl
//---------------------------------------------------------------------------
#define IOCTL_SCSISCAN_CMD		     CTL_CODE(FILE_DEVICE_SCANNER, SCSISCAN_CMD_CODE,	    METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_SCSISCAN_LOCKDEVICE    CTL_CODE(FILE_DEVICE_SCANNER, SCSISCAN_LOCKDEVICE,		METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_SCSISCAN_UNLOCKDEVICE  CTL_CODE(FILE_DEVICE_SCANNER, SCSISCAN_UNLOCKDEVICE,	METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_SCSISCAN_SET_TIMEOUT   CTL_CODE(FILE_DEVICE_SCANNER, SCSISCAN_SET_TIMEOUT,	METHOD_BUFFERED,   FILE_ANY_ACCESS)
#define IOCTL_SCSISCAN_GET_INFO      CTL_CODE(FILE_DEVICE_SCANNER, SCSISCAN_GET_INFO   ,	METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\regentry.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    regentry.h

Abstract:

    Wrapper for registry access Win32 APIs


Usage:

    Construct a RegEntry object by specifying the subkey (under
    HKEY_CURRENT_USER by default, but can be overridden.)

    All member functions are inline so there is minimal overhead.

    All member functions (except the destructor) set an internal
    error state which can be retrieved with GetError().
    Zero indicates no error.

    RegEntry works only with strings and DWORDS which are both set
    using the overloaded function SetValue()

        SetValue("valuename", "string");
        SetValue("valuename", 42);

    Values are retrieved with GetString() and GetNumber().  GetNumber()
    allows you to specificy a default if the valuename doesn't exist.

    DeleteValue() removes the valuename and value pair.

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/


#ifndef REGENTRY_INC
#define REGENTRY_INC

#ifndef STRICT
#define STRICT
#endif


#include <windows.h>

class StiCString;

class RegEntry
{
    public:
        RegEntry();
        RegEntry(const TCHAR *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
        ~RegEntry();
        BOOL    Open(const TCHAR *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
        BOOL    Close();
        long    GetError()  { return m_error; }
        long    SetValue(const TCHAR *pszValue, const TCHAR *string);
        long    SetValue(const TCHAR *pszValue, const TCHAR *string, DWORD dwType);
        long    SetValue(const TCHAR *pszValue, unsigned long dwNumber);
        long    SetValue(const TCHAR *pszValue, BYTE * pValue,unsigned long dwNumber);
        TCHAR*  GetString(const TCHAR *pszValue, TCHAR *string, unsigned long length);
        VOID    GetValue(const TCHAR *pszValueName, BUFFER *pValue);
        long    GetNumber(const TCHAR *pszValue, long dwDefault = 0);
        long    DeleteValue(const TCHAR *pszValue);
        long    FlushKey();
        VOID    MoveToSubKey(const TCHAR *pszSubKeyName);
        BOOL    EnumSubKey(DWORD index, StiCString *pStrString);
        BOOL    GetSubKeyInfo(DWORD *NumberOfSubKeys, DWORD *pMaxSubKeyLength);
        HKEY    GetKey()    { return m_hkey; };
        BOOL    IsValid()   { return bhkeyValid;};

    private:
        HKEY    m_hkey;
        long    m_error;
        BOOL    bhkeyValid;
};

class RegEnumValues
{
    public:
        RegEnumValues(RegEntry *pRegEntry);
        ~RegEnumValues();
        long    Next();
        TCHAR *  GetName()       {return pchName;}
        DWORD   GetType()       {return dwType;}
        LPBYTE  GetData()       {return pbValue;}
        DWORD   GetDataLength() {return dwDataLength;}

    private:
        RegEntry * pRegEntry;
        DWORD   iEnum;
        DWORD   cEntries;
        TCHAR *  pchName;
        LPBYTE  pbValue;
        DWORD   dwType;
        DWORD   dwDataLength;
        DWORD   cMaxValueName;
        DWORD   cMaxData;
        LONG    m_error;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\sti.h ===
/*++

Copyright (c) 1986-1997  Microsoft Corporation

Module Name:

    sti.h

Abstract:

    This module contains the user mode still image APIs in COM format

Revision History:


--*/

#ifndef _STICOM_
#define _STICOM_

//
// Set packing
//
#include <pshpack8.h>

//
// Only use UNICODE STI interfaces
//
#define STI_UNICODE 1

//
// Include COM definitions
//
#ifndef _NO_COM
#include <objbase.h>
#endif

#include <stireg.h>
#include <stierr.h>

//
// Compiler pragmas
//
#pragma warning(disable:4200)       // warning about zero-sized arrays being non-stadard C extension

#define DLLEXP __declspec( dllexport )

#ifdef __cplusplus
extern "C" {
#endif

#if defined( _WIN32 ) && !defined( _NO_COM)

/*
 * Class IID's
 */

// B323F8E0-2E68-11D0-90EA-00AA0060F86C
DEFINE_GUID(CLSID_Sti, 0xB323F8E0L, 0x2E68, 0x11D0, 0x90, 0xEA, 0x00, 0xAA, 0x00, 0x60, 0xF8, 0x6C);

/*
 * Interface IID's
 */

// {641BD880-2DC8-11D0-90EA-00AA0060F86C}
DEFINE_GUID(IID_IStillImageW, 0x641BD880L, 0x2DC8, 0x11D0, 0x90, 0xEA, 0x00, 0xAA, 0x00, 0x60, 0xF8, 0x6C);

// {A7B1F740-1D7F-11D1-ACA9-00A02438AD48}
DEFINE_GUID(IID_IStillImageA, 0xA7B1F740L, 0x1D7F, 0x11D1, 0xAC, 0xA9, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);


// {6CFA5A80-2DC8-11D0-90EA-00AA0060F86C}
DEFINE_GUID(IID_IStiDevice, 0x6CFA5A80L, 0x2DC8, 0x11D0, 0x90, 0xEA, 0x00, 0xAA, 0x00, 0x60, 0xF8, 0x6C);

/*
 * Standard event GUIDs
 */

// {740D9EE6-70F1-11d1-AD10-00A02438AD48}
DEFINE_GUID(GUID_DeviceArrivedLaunch, 0x740d9ee6, 0x70f1, 0x11d1, 0xad, 0x10, 0x0, 0xa0, 0x24, 0x38, 0xad, 0x48);

// {A6C5A715-8C6E-11d2-977A-0000F87A926F}
DEFINE_GUID(GUID_ScanImage,
0xa6c5a715, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);

 // {B441F425-8C6E-11d2-977A-0000F87A926F}
DEFINE_GUID(GUID_ScanPrintImage,
0xb441f425, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);


// {C00EB793-8C6E-11d2-977A-0000F87A926F}
DEFINE_GUID(GUID_ScanFaxImage,
0xc00eb793, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);


// {C00EB795-8C6E-11d2-977A-0000F87A926F}
DEFINE_GUID(GUID_STIUserDefined1,
0xc00eb795, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);


// {C77AE9C5-8C6E-11d2-977A-0000F87A926F}
DEFINE_GUID(GUID_STIUserDefined2,
0xc77ae9c5, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);


// {C77AE9C6-8C6E-11d2-977A-0000F87A926F}
DEFINE_GUID(GUID_STIUserDefined3,
0xc77ae9c6, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);

#endif

//
// Generic constants and definitions
//
#define STI_VERSION_FLAG_MASK       0xff000000
#define STI_VERSION_FLAG_UNICODE    0x01000000

#define GET_STIVER_MAJOR(dwVersion)   (HIWORD(dwVersion) & ~STI_VERSION_FLAG_MASK)
#define GET_STIVER_MINOR(dwVersion)   LOWORD(dwVersion)

#define STI_VERSION_REAL            0x00000002
#define STI_VERSION_MIN_ALLOWED     0x00000002

#ifdef UNICODE
#define STI_VERSION                 (STI_VERSION_REAL | STI_VERSION_FLAG_UNICODE)
#else
#define STI_VERSION                 (STI_VERSION_REAL)
#endif

//
// Maximum length of internal device name
//
#define STI_MAX_INTERNAL_NAME_LENGTH    128

// begin sti_device_information

//
//  Device information definitions and prototypes
// ----------------------------------------------
//

//
//  Following information is used for enumerating still image devices , currently configured
//  in the system. Presence of the device in the enumerated list does not mean availability
// of the device, it only means that device was installed at least once and had not been removed since.
//

//
// Type of device ( scanner, camera) is represented by DWORD value with
// hi word containing generic device type , and lo word containing sub-type
//
typedef enum _STI_DEVICE_MJ_TYPE {
    StiDeviceTypeDefault          = 0,
    StiDeviceTypeScanner          = 1,
    StiDeviceTypeDigitalCamera    = 2,
    StiDeviceTypeStreamingVideo   = 3
} STI_DEVICE_MJ_TYPE;

typedef DWORD STI_DEVICE_TYPE;

//
// Macros to extract device type/subtype from single type field
//
#define GET_STIDEVICE_TYPE(dwDevType)   HIWORD(dwDevType)
#define GET_STIDEVICE_SUBTYPE(dwDevType)   LOWORD(dwDevType)

//
// Device capabilities bits.
// Various capabilities are grouped into separate bitmasks
//

typedef struct _STI_DEV_CAPS {
    DWORD   dwGeneric;
} STI_DEV_CAPS, *PSTI_DEV_CAPS;

//
// Generic capabilities mask contain 16 bits , common for all devices, maintained by MS
// and 16 bits , which USD can use for proprietary capbailities reporting.
//

#define GET_STIDCOMMON_CAPS(dwGenericCaps)   LOWORD(dwGenericCaps)
#define GET_STIVENDOR_CAPS(dwGenericCaps)    HIWORD(dwGenericCaps)

#define STI_GENCAP_COMMON_MASK  (DWORD)0x00ff

//
// Notifications are supported.
// If this capability set , device can be subscribed to .
//
#define STI_GENCAP_NOTIFICATIONS    0x00000001

//
// Polling required .
// This capability is used when previous is set to TRUE. Presence of it means
// that device is not capable of issuing "truly" asyncronous notifications, but can
// be polled to determine the moment when event happened
#define STI_GENCAP_POLLING_NEEDED   0x00000002

//
// Generate event on device arrival
// If this capability is set, still image service will generate event when device
// instance is successfully initialized ( typically in response to PnP arrival)

//
// Note: on initial service enumeration events will nto be generated to avoid
// end-user confusion.
//
#define STI_GENCAP_GENERATE_ARRIVALEVENT    0x00000004

//
// Auto port selection on non-PnP buses
// This capability indicates that USD is able to detect non-PnP device on a
// bus , device is supposed to be attached to.
//
#define STI_GENCAP_AUTO_PORTSELECT   0x00000008

//
// WIA capability bit.
// This capability indicates that USD is WIA capable.
//
#define STI_GENCAP_WIA              0x00000010

//
// Subset driver bit.
// This capability indicates that there is more featured driver exists. All 
// of inbox driver has this bit set. Fully featured (IHV) driver shouldn't have
// this bit set.
//
#define STI_GENCAP_SUBSET           0x00000020

//
//
// Type of bus connection for those in need to know
//
#define STI_HW_CONFIG_UNKNOWN   0x0001
#define STI_HW_CONFIG_SCSI      0x0002
#define STI_HW_CONFIG_USB       0x0004
#define STI_HW_CONFIG_SERIAL    0x0008
#define STI_HW_CONFIG_PARALLEL  0x0010

//
// Device information structure, this is not configurable. This data is returned from
// device enumeration API and is used for populating UI or selecting which device
// should be used in current session
//
typedef struct _STI_DEVICE_INFORMATIONW {
    DWORD   dwSize;

    // Type of the hardware imaging device
    STI_DEVICE_TYPE   DeviceType;

    // Device identifier for reference when creating device object
    WCHAR   szDeviceInternalName[STI_MAX_INTERNAL_NAME_LENGTH];

    // Set of capabilities flags
    STI_DEV_CAPS   DeviceCapabilities;

    // This includes bus type
    DWORD   dwHardwareConfiguration;

    // Vendor description string
    LPWSTR    pszVendorDescription;

    // Device description , provided by vendor
    LPWSTR    pszDeviceDescription;

    // String , representing port on which device is accessible.
    LPWSTR    pszPortName;

    // Control panel propery provider
    LPWSTR    pszPropProvider;

    // Local specific ("friendly") name of the device, mainly used for showing in the UI
    LPWSTR    pszLocalName;

} STI_DEVICE_INFORMATIONW, *PSTI_DEVICE_INFORMATIONW;

typedef struct _STI_DEVICE_INFORMATIONA {
    DWORD   dwSize;

    // Type of the hardware imaging device
    STI_DEVICE_TYPE   DeviceType;

    // Device identifier for reference when creating device object
    CHAR    szDeviceInternalName[STI_MAX_INTERNAL_NAME_LENGTH];

    // Set of capabilities flags
    STI_DEV_CAPS   DeviceCapabilities;

    // This includes bus type
    DWORD   dwHardwareConfiguration;

    // Vendor description string
    LPCSTR    pszVendorDescription;

    // Device description , provided by vendor
    LPCSTR    pszDeviceDescription;

    // String , representing port on which device is accessible.
    LPCSTR    pszPortName;

    // Control panel propery provider
    LPCSTR    pszPropProvider;

    // Local specific ("friendly") name of the device, mainly used for showing in the UI
    LPCSTR    pszLocalName;

} STI_DEVICE_INFORMATIONA, *PSTI_DEVICE_INFORMATIONA;

#if defined(UNICODE) || defined(STI_UNICODE)
typedef STI_DEVICE_INFORMATIONW STI_DEVICE_INFORMATION;
typedef PSTI_DEVICE_INFORMATIONW PSTI_DEVICE_INFORMATION;
#else
typedef STI_DEVICE_INFORMATIONA STI_DEVICE_INFORMATION;
typedef PSTI_DEVICE_INFORMATIONA PSTI_DEVICE_INFORMATION;
#endif

//
// EXTENDED STI INFORMATION TO COVER WIA
//

typedef struct _STI_WIA_DEVICE_INFORMATIONW {
    DWORD   dwSize;

    // Type of the hardware imaging device
    STI_DEVICE_TYPE   DeviceType;

    // Device identifier for reference when creating device object
    WCHAR   szDeviceInternalName[STI_MAX_INTERNAL_NAME_LENGTH];

    // Set of capabilities flags
    STI_DEV_CAPS   DeviceCapabilities;

    // This includes bus type
    DWORD   dwHardwareConfiguration;

    // Vendor description string
    LPWSTR    pszVendorDescription;

    // Device description , provided by vendor
    LPWSTR    pszDeviceDescription;

    // String , representing port on which device is accessible.
    LPWSTR    pszPortName;

    // Control panel propery provider
    LPWSTR    pszPropProvider;

    // Local specific ("friendly") name of the device, mainly used for showing in the UI
    LPWSTR    pszLocalName;

    //
    // WIA values
    //

    LPWSTR    pszUiDll;
    LPWSTR    pszServer;

} STI_WIA_DEVICE_INFORMATIONW, *PSTI_WIA_DEVICE_INFORMATIONW;


typedef struct _STI_WIA_DEVICE_INFORMATIONA {
    DWORD   dwSize;

    // Type of the hardware imaging device
    STI_DEVICE_TYPE   DeviceType;

    // Device identifier for reference when creating device object
    CHAR    szDeviceInternalName[STI_MAX_INTERNAL_NAME_LENGTH];

    // Set of capabilities flags
    STI_DEV_CAPS   DeviceCapabilities;

    // This includes bus type
    DWORD   dwHardwareConfiguration;

    // Vendor description string
    LPCSTR    pszVendorDescription;

    // Device description , provided by vendor
    LPCSTR    pszDeviceDescription;

    // String , representing port on which device is accessible.
    LPCSTR    pszPortName;

    // Control panel propery provider
    LPCSTR    pszPropProvider;

    // Local specific ("friendly") name of the device, mainly used for showing in the UI
    LPCSTR    pszLocalName;

    //
    // WIA values
    //

    LPCSTR    pszUiDll;
    LPCSTR    pszServer;

} STI_WIA_DEVICE_INFORMATIONA, *PSTI_WIA_DEVICE_INFORMATIONA;


#if defined(UNICODE) || defined(STI_UNICODE)
typedef STI_WIA_DEVICE_INFORMATIONW STI_WIA_DEVICE_INFORMATION;
typedef PSTI_WIA_DEVICE_INFORMATIONW PSTI_WIA_DEVICE_INFORMATION;
#else
typedef STI_WIA_DEVICE_INFORMATIONA STI_WIA_DEVICE_INFORMATION;
typedef PSTI_WIA_DEVICE_INFORMATIONA PSTI_WIA_DEVICE_INFORMATION;
#endif


// end sti_device_information

//
// Device state information.
// ------------------------
//
// Following types  are used to inquire state characteristics of the device after
// it had been opened.
//
// Device configuration structure contains configurable parameters reflecting
// current state of the device
//
//
// Device hardware status.
//

//
// Individual bits for state acquiring  through StatusMask
//

// State of hardware as known to USD
#define STI_DEVSTATUS_ONLINE_STATE      0x0001

// State of pending events ( as known to USD)
#define STI_DEVSTATUS_EVENTS_STATE      0x0002

//
// Online state values
//
#define STI_ONLINESTATE_OPERATIONAL         0x00000001
#define STI_ONLINESTATE_PENDING             0x00000002
#define STI_ONLINESTATE_ERROR               0x00000004
#define STI_ONLINESTATE_PAUSED              0x00000008
#define STI_ONLINESTATE_PAPER_JAM           0x00000010
#define STI_ONLINESTATE_PAPER_PROBLEM       0x00000020
#define STI_ONLINESTATE_OFFLINE             0x00000040
#define STI_ONLINESTATE_IO_ACTIVE           0x00000080
#define STI_ONLINESTATE_BUSY                0x00000100
#define STI_ONLINESTATE_TRANSFERRING        0x00000200
#define STI_ONLINESTATE_INITIALIZING        0x00000400
#define STI_ONLINESTATE_WARMING_UP          0x00000800
#define STI_ONLINESTATE_USER_INTERVENTION   0x00001000
#define STI_ONLINESTATE_POWER_SAVE          0x00002000

//
// Event processing parameters
//
#define STI_EVENTHANDLING_ENABLED           0x00000001
#define STI_EVENTHANDLING_POLLING           0x00000002
#define STI_EVENTHANDLING_PENDING           0x00000004

typedef struct _STI_DEVICE_STATUS {

    DWORD   dwSize;

    // Request field - bits of status to verify
    DWORD   StatusMask;

    //
    // Fields are set when status mask contains STI_DEVSTATUS_ONLINE_STATE bit set
    //
    // Bitmask describing  device state
    DWORD   dwOnlineState;

    // Device status code as defined by vendor
    DWORD   dwHardwareStatusCode;

    //
    // Fields are set when status mask contains STI_DEVSTATUS_EVENTS_STATE bit set
    //

    // State of device notification processing (enabled, pending)
    DWORD   dwEventHandlingState;

    // If device is polled, polling interval in ms
    DWORD   dwPollingInterval;

} STI_DEVICE_STATUS,*PSTI_DEVICE_STATUS;

//
// Structure to describe diagnostic ( test ) request to be processed by USD
//

// Basic test for presence of associated hardware
#define STI_DIAGCODE_HWPRESENCE         0x00000001

//
// Status bits for diagnostic
//

//
// generic diagnostic errors
//

typedef struct _ERROR_INFOW {

    DWORD   dwSize;

    // Generic error , describing results of last operation
    DWORD   dwGenericError;

    // vendor specific error code
    DWORD   dwVendorError;

    // String, describing in more details results of last operation if it failed
    WCHAR   szExtendedErrorText[255];

} STI_ERROR_INFOW,*PSTI_ERROR_INFOW;

typedef struct _ERROR_INFOA {

    DWORD   dwSize;

    DWORD   dwGenericError;
    DWORD   dwVendorError;

    CHAR   szExtendedErrorText[255];

} STI_ERROR_INFOA,*PSTI_ERROR_INFOA;

#if defined(UNICODE) || defined(STI_UNICODE)
typedef STI_ERROR_INFOW STI_ERROR_INFO;
#else
typedef STI_ERROR_INFOA STI_ERROR_INFO;
#endif

typedef STI_ERROR_INFO* PSTI_ERROR_INFO;

typedef struct _STI_DIAG {

    DWORD   dwSize;

    // Diagnostic request fields. Are set on request by caller

    // One of the
    DWORD   dwBasicDiagCode;
    DWORD   dwVendorDiagCode;

    // Response fields
    DWORD   dwStatusMask;

    STI_ERROR_INFO  sErrorInfo;

} STI_DIAG,*LPSTI_DIAG;

//
typedef STI_DIAG    DIAG;
typedef LPSTI_DIAG  LPDIAG;


// end device state information.

//
// Flags passed to WriteToErrorLog call in a first parameter, indicating type of the message
// which needs to be logged
//
#define STI_TRACE_INFORMATION       0x00000001
#define STI_TRACE_WARNING           0x00000002
#define STI_TRACE_ERROR             0x00000004

//
// Event notification mechansims.
// ------------------------------
//
// Those are used to inform last subscribed caller of the changes in device state, initiated by
// device.
//
// The only supported discipline of notification is stack. The last caller to subscribe will be notified
// and will receive notification data. After caller unsubscribes , the previously subscribed caller will
// become active.
//

// Notifications are sent to subscriber via window message. Window handle is passed as
// parameter
#define STI_SUBSCRIBE_FLAG_WINDOW   0x0001

// Device notification is signalling Win32 event ( auto-set event). Event handle
// is passed as a parameter
#define STI_SUBSCRIBE_FLAG_EVENT    0x0002

typedef struct _STISUBSCRIBE {

    DWORD   dwSize;

    DWORD   dwFlags;

    // Not used . Will be used for subscriber to set bit mask filtering different events
    DWORD   dwFilter;

    // When STI_SUBSCRIBE_FLAG_WINDOW bit is set, following fields should be set
    // Handle of the window which will receive notification message
    HWND    hWndNotify;

    // Handle of Win32 auto-reset event , which will be signalled whenever device has
    // notification pending
    HANDLE  hEvent;

    // Code of notification message, sent to window
    UINT    uiNotificationMessage;

} STISUBSCRIBE,*LPSTISUBSCRIBE;

#define MAX_NOTIFICATION_DATA   64


//
// Structure to describe notification information
//
typedef struct _STINOTIFY {

    DWORD   dwSize;                 // Total size of the notification structure

    // GUID of the notification being retrieved
    GUID    guidNotificationCode;

    // Vendor specific notification description
    BYTE    abNotificationData[MAX_NOTIFICATION_DATA];     // USD specific

} STINOTIFY,*LPSTINOTIFY;


// end event_mechanisms

//
// STI device broadcasting
//

//
// When STI Device is being added or removed, PnP broadacst is being sent , but it is not obvious
// for application code to recognize if it is STI device and if so, what is the name of the
// device. STI subsystem will analyze PnP broadcasts and rebroadcast another message via
// BroadcastSystemMessage / WM_DEVICECHANGE / DBT_USERDEFINED .

// String passed as user defined message contains STI prefix, action and device name

#define STI_ADD_DEVICE_BROADCAST_ACTION     "Arrival"
#define STI_REMOVE_DEVICE_BROADCAST_ACTION  "Removal"

#define STI_ADD_DEVICE_BROADCAST_STRING     "STI\\" STI_ADD_DEVICE_BROADCAST_ACTION "\\%s"
#define STI_REMOVE_DEVICE_BROADCAST_STRING  "STI\\" STI_REMOVE_DEVICE_BROADCAST_ACTION "\\%s"


// end STI broadcasting


//
// Device create modes
//

// Device is being opened only for status querying and notifications receiving
#define STI_DEVICE_CREATE_STATUS         0x00000001

// Device is being opened for data transfer ( supersedes status mode)
#define STI_DEVICE_CREATE_DATA           0x00000002

#define STI_DEVICE_CREATE_BOTH           0x00000003

//
// Bit mask for legitimate mode bits, which can be used when calling CreateDevice
//
#define STI_DEVICE_CREATE_MASK           0x0000FFFF

//
// Flags controlling device enumeration
//
#define STIEDFL_ALLDEVICES             0x00000000
#define STIEDFL_ATTACHEDONLY           0x00000001

//
// Control code , sent to the device through raw control interface
//
typedef  DWORD STI_RAW_CONTROL_CODE;

//
// All raw codes below this one are reserved for future use.
//
#define STI_RAW_RESERVED    0x1000

 /*
  * COM Interfaces to STI
  */

#ifdef __cplusplus

/* 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined */
interface IStillImageW;
interface IStillImageA;

interface IStiDevice;

#endif

#ifndef MIDL_PASS

//DLLEXP STDMETHODIMP StiCreateInstanceW(HINSTANCE hinst, DWORD dwVer, interface IStillImageW **ppSti, LPUNKNOWN punkOuter);
//DLLEXP STDMETHODIMP StiCreateInstanceA(HINSTANCE hinst, DWORD dwVer, interface IStillImageA **ppSti, LPUNKNOWN punkOuter);
STDMETHODIMP StiCreateInstanceW(HINSTANCE hinst, DWORD dwVer, interface IStillImageW **ppSti, LPUNKNOWN punkOuter);
STDMETHODIMP StiCreateInstanceA(HINSTANCE hinst, DWORD dwVer, interface IStillImageA **ppSti, LPUNKNOWN punkOuter);

#if defined(UNICODE) || defined(STI_UNICODE)
#define IID_IStillImage     IID_IStillImageW
#define IStillImage         IStillImageW
#define StiCreateInstance   StiCreateInstanceW
#else
#define IID_IStillImage     IID_IStillImageA
#define IStillImage         IStillImageA
#define StiCreateInstance   StiCreateInstanceA
#endif

typedef interface IStiDevice              *LPSTILLIMAGEDEVICE;

typedef interface IStillImage             *PSTI;
typedef interface IStiDevice              *PSTIDEVICE;

typedef interface IStillImageA            *PSTIA;
typedef interface IStiDeviceA             *PSTIDEVICEA;

typedef interface IStillImageW            *PSTIW;
typedef interface IStiDeviceW             *PSTIDEVICEW;

//DLLEXP STDMETHODIMP StiCreateInstance(HINSTANCE hinst, DWORD dwVer, PSTI *ppSti, LPUNKNOWN punkOuter);

/*
 * IStillImage interface
 *
 * Top level STI access interface.
 *
 */

#undef INTERFACE
#define INTERFACE IStillImageW
DECLARE_INTERFACE_(IStillImageW, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    /*** IStillImage methods ***/
    STDMETHOD(Initialize) (THIS_ HINSTANCE hinst,DWORD dwVersion) PURE;

    STDMETHOD(GetDeviceList)(THIS_ DWORD dwType,DWORD dwFlags,DWORD *pdwItemsReturned,LPVOID *ppBuffer) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPWSTR  pwszDeviceName, LPVOID *ppBuffer) PURE;

    STDMETHOD(CreateDevice) (THIS_ LPWSTR  pwszDeviceName, DWORD   dwMode, PSTIDEVICE *pDevice,LPUNKNOWN punkOuter) PURE;

    //
    // Device instance values. Used to associate various data with device.
    //
    STDMETHOD(GetDeviceValue)(THIS_ LPWSTR  pwszDeviceName,LPWSTR    pValueName,LPDWORD  pType,LPBYTE   pData,LPDWORD    cbData);
    STDMETHOD(SetDeviceValue)(THIS_ LPWSTR  pwszDeviceName,LPWSTR   pValueName,DWORD   Type,LPBYTE  pData,DWORD   cbData);

    //
    // For appllication started through push model launch, returns associated information
    //
    STDMETHOD(GetSTILaunchInformation)(THIS_ LPWSTR  pwszDeviceName, DWORD *pdwEventCode,LPWSTR  pwszEventName) PURE;
    STDMETHOD(RegisterLaunchApplication)(THIS_ LPWSTR  pwszAppName,LPWSTR  pwszCommandLine) PURE;
    STDMETHOD(UnregisterLaunchApplication)(THIS_ LPWSTR  pwszAppName) PURE;

    //
    // To control state of notification handling. For polled devices this means state of monitor
    // polling, for true notification devices means enabling/disabling notification flow
    // from monitor to registered applications
    //
    STDMETHOD(EnableHwNotifications)(THIS_ LPCWSTR  pwszDeviceName,BOOL bNewState) PURE;
    STDMETHOD(GetHwNotificationState)(THIS_ LPCWSTR  pwszDeviceName,BOOL *pbCurrentState) PURE;

    //
    // When device is installed but not accessible, application may request bus refresh
    // which in some cases will make device known. This is mainly used for nonPnP buses
    // like SCSI, when device was powered on after PnP enumeration
    //
    //
    STDMETHOD(RefreshDeviceBus)(THIS_ LPCWSTR  pwszDeviceName) PURE;

    //
    // Launch application to emulate event on a device. Used by "control center" style components,
    // which intercept device event , analyze and later force launch based on certain criteria.
    //
    STDMETHOD(LaunchApplicationForDevice)(THIS_ LPWSTR  pwszDeviceName,LPWSTR    pwszAppName,LPSTINOTIFY    pStiNotify);

    //
    // For non-PnP devices with non-known bus type connection, setup extension, associated with the
    // device can set it's parameters
    //
    STDMETHOD(SetupDeviceParameters)(THIS_ PSTI_DEVICE_INFORMATIONW);

    //
    // Write message to STI error log
    //
    STDMETHOD(WriteToErrorLog)(THIS_ DWORD dwMessageType,LPCWSTR pszMessage) PURE;

    #ifdef NOT_IMPLEMENTED

        //
        // TO register application for receiving various STI notifications
        //
        STIMETHOD(RegisterDeviceNotification(THIS_ LPWSTR  pwszAppName,LPSUBSCRIBE lpSubscribe) PURE;
        STIMETHOD(UnregisterDeviceNotification(THIS_ ) PURE;

    #endif //NOT_IMPLEMENTED

};

typedef struct IStillImageW *LPSTILLIMAGEW;

#undef INTERFACE
#define INTERFACE IStillImageA
DECLARE_INTERFACE_(IStillImageA, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    /*** IStillImage methods ***/
    STDMETHOD(Initialize) (THIS_ HINSTANCE hinst,DWORD dwVersion) PURE;

    STDMETHOD(GetDeviceList)(THIS_ DWORD dwType,DWORD dwFlags,DWORD *pdwItemsReturned,LPVOID *ppBuffer) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPCSTR  pwszDeviceName, LPVOID *ppBuffer) PURE;

    STDMETHOD(CreateDevice) (THIS_ LPCSTR  pwszDeviceName, DWORD   dwMode, PSTIDEVICE *pDevice,LPUNKNOWN punkOuter) PURE;

    //
    // Device instance values. Used to associate various data with device.
    //
    STDMETHOD(GetDeviceValue)(THIS_ LPCSTR  pwszDeviceName,LPCSTR   pValueName,LPDWORD  pType,LPBYTE   pData,LPDWORD    cbData);
    STDMETHOD(SetDeviceValue)(THIS_ LPCSTR  pwszDeviceName,LPCSTR   pValueName,DWORD   Type,LPBYTE  pData,DWORD   cbData);

    //
    // For appllication started through push model launch, returns associated information
    //
    STDMETHOD(GetSTILaunchInformation)(THIS_ LPSTR  pwszDeviceName, DWORD *pdwEventCode,LPSTR  pwszEventName) PURE;
    STDMETHOD(RegisterLaunchApplication)(THIS_ LPCSTR  pwszAppName,LPCSTR  pwszCommandLine) PURE;
    STDMETHOD(UnregisterLaunchApplication)(THIS_ LPCSTR  pwszAppName) PURE;

    //
    // To control state of notification handling. For polled devices this means state of monitor
    // polling, for true notification devices means enabling/disabling notification flow
    // from monitor to registered applications
    //
    STDMETHOD(EnableHwNotifications)(THIS_ LPCSTR  pwszDeviceName,BOOL bNewState) PURE;
    STDMETHOD(GetHwNotificationState)(THIS_ LPCSTR  pwszDeviceName,BOOL *pbCurrentState) PURE;

    //
    // When device is installed but not accessible, application may request bus refresh
    // which in some cases will make device known. This is mainly used for nonPnP buses
    // like SCSI, when device was powered on after PnP enumeration
    //
    //
    STDMETHOD(RefreshDeviceBus)(THIS_ LPCSTR  pwszDeviceName) PURE;

    //
    // Launch application to emulate event on a device. Used by "control center" style components,
    // which intercept device event , analyze and later force launch based on certain criteria.
    //
    STDMETHOD(LaunchApplicationForDevice)(THIS_ LPCSTR    pwszDeviceName,LPCSTR    pwszAppName,LPSTINOTIFY    pStiNotify);


    //
    // For non-PnP devices with non-known bus type connection, setup extension, associated with the
    // device can set it's parameters
    //
    STDMETHOD(SetupDeviceParameters)(THIS_ PSTI_DEVICE_INFORMATIONA);

    //
    // Write message to STI error log
    //
    STDMETHOD(WriteToErrorLog)(THIS_ DWORD dwMessageType,LPCSTR pszMessage) PURE;

    #ifdef NOT_IMPLEMENTED

        //
        // TO register application for receiving various STI notifications
        //
        STIMETHOD(RegisterDeviceNotification(THIS_ LPWSTR  pwszAppName,LPSUBSCRIBE lpSubscribe) PURE;
        STIMETHOD(UnregisterDeviceNotification(THIS_ ) PURE;

    #endif //NOT_IMPLEMENTED

};

typedef struct IStillImageA *LPSTILLIMAGEA;

#if defined(UNICODE) || defined(STI_UNICODE)
#define IStillImageVtbl     IStillImageWVtbl
#else
#define IStillImageVtbl     IStillImageAVtbl
#endif

typedef struct IStillImage  *LPSTILLIMAGE;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IStillImage_QueryInterface(p,a,b)       (p)->lpVtbl->QueryInterface(p,a,b)
#define IStillImage_AddRef(p)                   (p)->lpVtbl->AddRef(p)
#define IStillImage_Release(p)                  (p)->lpVtbl->Release(p)
#define IStillImage_Initialize(p,a,b)           (p)->lpVtbl->Initialize(p,a,b)

#define IStillImage_GetDeviceList(p,a,b,c,d)    (p)->lpVtbl->GetDeviceList(p,a,b,c,d)
#define IStillImage_GetDeviceInfo(p,a,b)        (p)->lpVtbl->GetDeviceInfo(p,a,b)
#define IStillImage_CreateDevice(p,a,b,c,d)     (p)->lpVtbl->CreateDevice(p,a,b,c,d)
#define IStillImage_GetDeviceValue(p,a,b,c,d,e)           (p)->lpVtbl->GetDeviceValue(p,a,b,c,d,e)
#define IStillImage_SetDeviceValue(p,a,b,c,d,e)           (p)->lpVtbl->SetDeviceValue(p,a,b,c,d,e)
#define IStillImage_GetSTILaunchInformation(p,a,b,c)      (p)->lpVtbl->GetSTILaunchInformation(p,a,b,c)
#define IStillImage_RegisterLaunchApplication(p,a,b)      (p)->lpVtbl->RegisterLaunchApplication(p,a,b)
#define IStillImage_UnregisterLaunchApplication(p,a)      (p)->lpVtbl->UnregisterLaunchApplication(p,a)
#define IStillImage_EnableHwNotifications(p,a,b)          (p)->lpVtbl->EnableHwNotifications(p,a,b)
#define IStillImage_GetHwNotificationState(p,a,b)         (p)->lpVtbl->GetHwNotificationState(p,a,b)
#define IStillImage_RefreshDeviceBus(p,a)                 (p)->lpVtbl->RefreshDeviceBus(p,a)

#endif

/*
 * IStillImage_Device interface
 *
 * This is generic per device interface. Specialized interfaces are also
 * available
 */
#undef INTERFACE
#define INTERFACE IStiDevice
DECLARE_INTERFACE_(IStiDevice, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    /*** IStiDevice methods ***/
    STDMETHOD(Initialize) (THIS_ HINSTANCE hinst,LPCWSTR pwszDeviceName,DWORD dwVersion,DWORD  dwMode) PURE;

    STDMETHOD(GetCapabilities) (THIS_ PSTI_DEV_CAPS pDevCaps) PURE;

    STDMETHOD(GetStatus) (THIS_ PSTI_DEVICE_STATUS pDevStatus) PURE;

    STDMETHOD(DeviceReset)(THIS ) PURE;
    STDMETHOD(Diagnostic)(THIS_ LPSTI_DIAG pBuffer) PURE;

    STDMETHOD(Escape)(THIS_ STI_RAW_CONTROL_CODE    EscapeFunction,LPVOID  lpInData,DWORD   cbInDataSize,LPVOID pOutData,DWORD dwOutDataSize,LPDWORD pdwActualData) PURE ;

    STDMETHOD(GetLastError) (THIS_ LPDWORD pdwLastDeviceError) PURE;

    STDMETHOD(LockDevice) (THIS_ DWORD dwTimeOut) PURE;
    STDMETHOD(UnLockDevice) (THIS ) PURE;

    STDMETHOD(RawReadData)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawWriteData)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;

    STDMETHOD(RawReadCommand)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawWriteCommand)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;

    //
    // Subscription is used to enable "control center" style applications , where flow of
    // notifications should be redirected from monitor itself to another "launcher"
    //
    STDMETHOD(Subscribe)(THIS_ LPSTISUBSCRIBE lpSubsribe) PURE;
    STDMETHOD(GetLastNotificationData)(THIS_ LPSTINOTIFY   lpNotify) PURE;
    STDMETHOD(UnSubscribe)(THIS ) PURE;

    STDMETHOD(GetLastErrorInfo) (THIS_ STI_ERROR_INFO *pLastErrorInfo) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IStiDevice_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IStiDevice_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IStiDevice_Release(p)                   (p)->lpVtbl->Release(p)
#define IStiDevice_Initialize(p,a,b,c,d)        (p)->lpVtbl->Initialize(p,a,b,c,d)

#define IStiDevice_GetCapabilities(p,a)         (p)->lpVtbl->GetCapabilities(p,a)
#define IStiDevice_GetStatus(p,a)               (p)->lpVtbl->GetStatus(p,a)
#define IStiDevice_DeviceReset(p)               (p)->lpVtbl->DeviceReset(p)
#define IStiDevice_LockDevice(p,a)              (p)->lpVtbl->LockDevice(p,a)
#define IStiDevice_UnLockDevice(p)              (p)->lpVtbl->UnLockDevice(p)

#define IStiDevice_Diagnostic(p,a)              (p)->lpVtbl->Diagnostic(p,a)
#define IStiDevice_Escape(p,a,b,c,d,e,f)        (p)->lpVtbl->Escape(p,a,b,c,d,e,f)
#define IStiDevice_GetLastError(p,a)            (p)->lpVtbl->GetLastError(p,a)
#define IStiDevice_RawReadData(p,a,b,c)         (p)->lpVtbl->RawReadData(p,a,b,c)
#define IStiDevice_RawWriteData(p,a,b,c)        (p)->lpVtbl->RawWriteData(p,a,b,c)
#define IStiDevice_RawReadCommand(p,a,b,c)      (p)->lpVtbl->RawReadCommand(p,a,b,c)
#define IStiDevice_RawWriteCommand(p,a,b,c)     (p)->lpVtbl->RawWriteCommand(p,a,b,c)

#define IStiDevice_Subscribe(p,a)               (p)->lpVtbl->Subscribe(p,a)
#define IStiDevice_GetNotificationData(p,a)     (p)->lpVtbl->GetNotificationData(p,a)
#define IStiDevice_UnSubscribe(p)               (p)->lpVtbl->UnSubscribe(p)

#define IStiDevice_GetLastErrorInfo(p,a)        (p)->lpVtbl->GetLastErrorInfo(p,a)

#endif

#endif  // MIDL_PASS

#ifdef __cplusplus
};
#endif

//
// Reset packing
//
#include <poppack.h>

#endif // _STICOM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\ptpusd.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        ptpusd.h
*
*  VERSION:     1.0
*
*  DATE:        12/12/2000
*
*  AUTHOR:      Dave Parsons
*
*  DESCRIPTION:
*    Structures and constants needed to issue vendor-specific Picture
*    Transfer Protocol (PIMA 15740 - digital still camera command
*    protocol) commands through the WIA PTP driver.
*
*****************************************************************************/

//
// Pass this value in the dwEscapeCode argument of IWiaItemExtras::Escape
// to execute a PTP vendor command
//
const DWORD ESCAPE_PTP_CLEAR_STALLS   = 0x0200; 
const DWORD ESCAPE_PTP_VENDOR_COMMAND = 0x0100;
const DWORD ESCAPE_PTP_ADD_OBJ_CMD    = 0x0010;
const DWORD ESCAPE_PTP_REM_OBJ_CMD    = 0x0020;
const DWORD ESCAPE_PTP_ADD_OBJ_RESP   = 0x0040;
const DWORD ESCAPE_PTP_REM_OBJ_RESP   = 0x0080;
const DWORD ESCAPE_PTP_ADDREM_PARM1   = 0x0000;
const DWORD ESCAPE_PTP_ADDREM_PARM2   = 0x0001;
const DWORD ESCAPE_PTP_ADDREM_PARM3   = 0x0002;
const DWORD ESCAPE_PTP_ADDREM_PARM4   = 0x0003;
const DWORD ESCAPE_PTP_ADDREM_PARM5   = 0x0004;

//
// PTP command request
//
const DWORD PTP_MAX_PARAMS = 5;

#pragma pack(push, Old, 1)

typedef struct _PTP_VENDOR_DATA_IN
{
    WORD    OpCode;                 // Opcode
    DWORD   SessionId;              // Session id
    DWORD   TransactionId;          // Transaction id
    DWORD   Params[PTP_MAX_PARAMS]; // Parameters to the command
    DWORD   NumParams;              // Number of parameters passed in
    DWORD   NextPhase;              // Indicates whether to read data,
    BYTE    VendorWriteData[1];     // Optional first byte of data to
                                    // write to the device

} PTP_VENDOR_DATA_IN, *PPTP_VENDOR_DATA_IN;

//
// PTP response block
//
typedef struct _PTP_VENDOR_DATA_OUT
{
    WORD    ResponseCode;           // Response code
    DWORD   SessionId;              // Session id
    DWORD   TransactionId;          // Transaction id
    DWORD   Params[PTP_MAX_PARAMS]; // Parameters of the response
    BYTE    VendorReadData[1];      // Optional first byte of data to
                                    // read from the device

} PTP_VENDOR_DATA_OUT, *PPTP_VENDOR_DATA_OUT;

#pragma pack(pop, Old)

//
// Handy structure size constants
//
const DWORD SIZEOF_REQUIRED_VENDOR_DATA_IN = sizeof(PTP_VENDOR_DATA_IN) - 1;
const DWORD SIZEOF_REQUIRED_VENDOR_DATA_OUT = sizeof(PTP_VENDOR_DATA_OUT) - 1;

//
// NextPhase constants
//
const DWORD PTP_NEXTPHASE_READ_DATA = 3;
const DWORD PTP_NEXTPHASE_WRITE_DATA = 4;
const DWORD PTP_NEXTPHASE_NO_DATA = 5;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\stiapi.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stiapi.h

Abstract:

    Prototypes for RPC based interface between client and server
    sides of STI

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/

#ifndef _STIAPI_H_
#define _STIAPI_h_

# ifdef __cplusplus
extern "C"   {
# endif // __cplusplus

#ifndef STI_DEVICE_HANDLE
typedef HANDLE STI_DEVICE_HANDLE;
#endif

//
// Custom STI monitor messages. Used by monitor internally or
// by control panel in cases when we don't want to use RPC APIs
//

#define STIMON_WINDOW_CLASS         TEXT("STIExe_Window_Class")

#define STISVC_WINDOW_CLASS         TEXT("STISvcHiddenWindow")

#define STIMON_MSG_REFRESH          WM_USER+201
#define STIMON_MSG_ADD_DEVICE       WM_USER+202
#define STIMON_MSG_REMOVE_DEVICE    WM_USER+203
#define STIMON_MSG_SET_PARAMETERS   WM_USER+204
#define STIMON_MSG_LOG_MESSAGE      WM_USER+205
#define STIMON_MSG_VISUALIZE        WM_USER+206
#define STIMON_MSG_ENABLE_NOTIFICATIONS WM_USER+207


//
// Subcommand values for main message
// Passed via wParam ( should fit WORD)
//
#define STIMON_MSG_SET_TIMEOUT      1

#define STIMON_MSG_REFRESH_REREAD   2
#define STIMON_MSG_REFRESH_SUSPEND  3
#define STIMON_MSG_REFRESH_RESUME   4
#define STIMON_MSG_REFRESH_SET_FLAG 5
#define STIMON_MSG_REFRESH_CLEAR_FLAG  6
#define STIMON_MSG_REFRESH_PURGE    7
#define STIMON_MSG_REFRESH_DEV_INFO 8


#define STIMON_MSG_NOTIF_ENABLE     1
#define STIMON_MSG_NOTIF_DISABLE    2
#define STIMON_MSG_NOTIF_QUERY      3
#define STIMON_MSG_NOTIF_SET_INACTIVE 5



//
// Bit flags for refresh message
// Passed via lParam ( should fit WORD)
//
#define STIMON_MSG_REFRESH_NEW      0x0001
#define STIMON_MSG_REFRESH_EXISTING 0x0002
#define STIMON_MSG_PURGE_REMOVED    0x0004
#define STIMON_MSG_BOOT             0x0008


//

DWORD
RpcStiApiGetVersion(
    LPCWSTR pszServer,
    DWORD   dwReserved,
    DWORD   *pdwVersion
    );

DWORD
WINAPI
RpcStiApiOpenDevice(
    IN  LPCWSTR  pszServer,
    IN  LPCWSTR  pdeviceName,
    IN  DWORD   dwMode,
    IN  DWORD   dwAccessRequired,
    IN  DWORD   dwProcessId,
    OUT STI_DEVICE_HANDLE *pHandle
    );

DWORD
WINAPI
RpcStiApiCloseDevice(
    IN  LPCWSTR       pszServer,
    IN  STI_DEVICE_HANDLE hDevice
    );

DWORD
WINAPI
RpcStiApiSubscribe(
    IN STI_DEVICE_HANDLE Handle,
    IN LPSTISUBSCRIBE    lpSubscribe
    );

DWORD
WINAPI
RpcStiApiGetLastNotificationData(
    IN  STI_DEVICE_HANDLE Handle,
    OUT LPSTINOTIFY   lpNotify
    );

DWORD
WINAPI
RpcStiApiUnSubscribe(
    IN STI_DEVICE_HANDLE Handle
    );

DWORD
WINAPI
RpcStiApiEnableHwNotifications(
    IN  LPCWSTR  pszServer,
    IN  LPCWSTR  pdeviceName,
    IN  BOOL     bNewState
    ) ;

DWORD
WINAPI
RpcStiApiGetHwNotificationState(
    IN  LPCWSTR  pszServer,
    IN  LPCWSTR  pdeviceName,
    OUT LPDWORD  pState
    );

DWORD
WINAPI
RpcStiApiLaunchApplication(
    IN  LPCWSTR  pszServer,
    IN  LPCWSTR  pdeviceName,
    IN  LPCWSTR  pAppName,
    IN  LPSTINOTIFY   pStiNotify
    );

DWORD
WINAPI
RpcStiApiLockDevice(
    IN  LPCWSTR  pdeviceName,
    IN  DWORD    dwWait,
    IN  BOOL     bInServerProcess
    );

DWORD
WINAPI
RpcStiApiUnlockDevice(
    IN  LPCWSTR  pdeviceName,
    IN  BOOL     bInServerProcess
    );

///////////////////////////////////////////////////////////////


DWORD
RpcStiApiRegisterDeviceNotification(

    );

DWORD
RpcStiApiUnregisterDeviceNotification(

    );

DWORD
RpcStiApiGetDeviceNotification(

    );

DWORD
RpcStiApiEnableDeviceNotifications(

    BOOL    fEnable
    );


DWORD
RpcStiApiEnumerateDevices(

    );

DWORD
RpcStiApiReadDeviceData(

    );

DWORD
RpcStiApiWriteDeviceData(

    );

DWORD
RpcStiApiReadDeviceCommand(

    );

DWORD
RpcStiApiWriteDeviceCommand(

    );


DWORD
RpcStiApiReadDeviceValue(

    );

DWORD
RpcStiApiWriteDeviceValue(

    );

DWORD
RpcStiApiDeviceEscape(

    );

DWORD
RpcStiApiGetDeviceStatus(

    );

DWORD
RpcStiApiGetDeviceLastError(

    );

DWORD
RpcStiApiResetDevice(

    );

VOID
WINAPI
MigrateRegisteredSTIAppsForWIAEvents(
    HWND        hWnd,
    HINSTANCE   hInst,
    PTSTR       pszCommandLine,
    INT         iParam
    );


# ifdef __cplusplus
};
# endif // __cplusplus


#endif // _STIAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\registrationcookie.h ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        4/1/2002
 *
 *  @doc    INTERNAL
 *
 *  @module RegistrationCookie.h - Definitions for <c RegistrationCookie> |
 *
 *  This file contains the class definition for <c RegistrationCookie>.
 *
 *****************************************************************************/

//
//  Defines
//

#define RegistrationCookie_UNINIT_SIG   0x55436552
#define RegistrationCookie_INIT_SIG     0x49436552
#define RegistrationCookie_TERM_SIG     0x54436552
#define RegistrationCookie_DEL_SIG      0x44436552

/*****************************************************************************
 *  
 *  @doc INTERNAL
 *  
 *  @class RegistrationCookie | This class is handed back during WIA Event Registration
 *  
 *  @comm
 *  The semantics of this class are very similar to the idea of a cookie i.e.
 *  the client makes a WIA runtime event registration, and gets a pointer to this
 *  class back as its cookie.  This class is associated with that registration.  
 *  
 *  Releasing this cookie causes unregistration.
 *
 *****************************************************************************/
class WiaEventReceiver;
class RegistrationCookie : public IUnknown
{
//@access Public members
public:

    // @cmember Constructor
    RegistrationCookie(WiaEventReceiver *pWiaEventReceiver, ClientEventRegistrationInfo *pClientEventRegistration);
    // @cmember Destructor
    virtual ~RegistrationCookie();

    // @cmember Query Interface
    HRESULT _stdcall QueryInterface(const IID &iid,void**ppv);
    // @cmember Increment reference count
    virtual ULONG __stdcall AddRef();
    // @cmember Decrement reference count
    virtual ULONG __stdcall Release();

//@access Private members
private:

    // @cmember Signature of class
    ULONG m_ulSig;

    // @cmember Ref count
    ULONG m_cRef;

    // @cmember Pointer to client's <c WiaEventReceiver>
    WiaEventReceiver *m_pWiaEventReceiver;

    // @cmember Pointer to client's <c ClientEventRegistrationInfo>
    ClientEventRegistrationInfo *m_pClientEventRegistration;

    //
    //  Comments for member variables
    //
    // @mdata ULONG | RegistrationCookie | m_ulSig | 
    //   The signature for this class, used for debugging purposes.
    //   Doing a <nl>"db [addr_of_class]"<nl> would yield one of the following
    //   signatures for this class:
    //   @flag RegistrationCookie_UNINIT_SIG | 'ReCU' - Object has not been successfully
    //       initialized
    //   @flag RegistrationCookie_INIT_SIG | 'ReCI' - Object has been successfully
    //       initialized
    //   @flag RegistrationCookie_TERM_SIG | 'ReCT' - Object is in the process of
    //       terminating.
    //    @flag RegistrationCookie_INIT_SIG | 'ReCD' - Object has been deleted 
    //       (destructor was called)
    //
    //
    // @mdata ULONG | RegistrationCookie | m_cRef | 
    //   The reference count for this class.  Used for lifetime 
    //   management.
    //
    // @mdata WiaEventReceiver* | RegistrationCookie | m_pWiaEventReceiver | 
    //  Pointer to client's <c WiaEventReceiver>.  Notice that we do no ref counting
    //  on this pointer.  This is because the client's global <c WiaEventReceiver> object
    //  lifetime is considered to be that of the client.  It will only be freed
    //  when the STI.DLL is unloaded.  Technically, we could just directly 
    //  access the g_WiaEventReceiver object, but keeping a member variable gives us more
    //  flexibility (e.g. if instead of a statically allocated class, we moved to
    //  dynamic singleton instatiation, this class would not change except to add relevant
    //  AddRef/Release calls).
    //
    // @mdata ClientEventRegistrationInfo* | RegistrationCookie | m_pClientEventRegistration | 
    //  Pointer to client's <c ClientEventRegistrationInfo>.  Releasing this class will
    //  result in an Unregistration call on <md RegistrationCookie::m_pWiaEventReceiver> for this
    //  registration.
    //  We hold a ref count on this registration class.
    //
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\stidebug.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stidebug.h

Abstract:

    Environment independent assertion/logging routines

    Usage:

        ASSERT(exp)     Evaluates its argument.  If "exp" evals to
                        FALSE, then the app will terminate, naming
                        the file name and line number of the assertion
                        in the source.

        UIASSERT(exp)   Synonym for ASSERT.

        ASSERTSZ(exp,sz) As ASSERT, except will also print the message
                        "sz" with the assertion message should it fail.

        REQUIRE(exp)    As ASSERT, except that its expression is still
                        evaluated in retail versions.  (Other versions
                        of ASSERT disappear completely in retail builds.)

    The ASSERT macros expect a symbol _FILENAME_DEFINED_ONCE, and will
    use the value of that symbol as the filename if found; otherwise,
    they will emit a new copy of the filename, using the ANSI C __FILE__
    macro.  A client sourcefile may therefore define __FILENAME_DEFINED_ONCE
    in order to minimize the DGROUP footprint of a number of ASSERTs.

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created
    13-Apr-1999     VladS       make UNICODE aware

--*/


#ifndef _STIDEBUG_H_
#define _STIDEBUG_H_

#if defined(DEBUG)
static const char szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#if defined(__cplusplus)
extern "C"
{
#endif

extern VOID UIAssertHelper( const CHAR* pszFileName, UINT nLine );
extern VOID UIAssertSzHelper( const TCHAR* pszMessage, const CHAR* pszFileName, UINT nLine );

extern VOID AssertHelper( const CHAR* pszFileName, UINT nLine );
extern VOID AssertSzHelper( const TCHAR* pszMessage, const CHAR* pszFileName, UINT nLine );

#if defined(DEBUG)

# ifdef USE_MESSAGEBOX_UI

#  define ASSERT(exp) \
    { if (!(exp)) UIAssertHelper(__FILE__, __LINE__); }

#  define ASSERTSZ(exp, sz) \
    { if (!(exp)) UIAssertSzHelper((sz), __FILE__, __LINE__); }

# else

#  define ASSERT(exp) \
    { if (!(exp)) AssertHelper(__FILE__, __LINE__); }

#  define ASSERTSZ(exp, sz) \
    { if (!(exp)) AssertSzHelper((sz), __FILE__, __LINE__); }

#define EVAL(exp)   \
    ((exp) || AssertHelper(__FILE__, __LINE__))

# endif // USE_MESSAGEBOX_UI

# define UIASSERT(exp)  ASSERT(exp)
# define REQUIRE(exp)   ASSERT(exp)

#else // !DEBUG

# define ASSERT(exp)        ;
# define EVAL(exp)          ;
# define UIASSERT(exp)      ;
# define ASSERTSZ(exp, sz)  ;
# define REQUIRE(exp)       { (exp); }

#endif // DEBUG



//
// Debug mask management.
//

// NOTE: You can #define your own DM_* values using bits in the HI BYTE

#define DM_TRACE    0x0001      // Trace messages
#define DM_WARNING  0x0002      // Warning
#define DM_ERROR    0x0004      // Error
#define DM_ASSERT   0x0008      // Assertions

#define DM_LOG_FILE 0x0100
#define DM_PREFIX   0x0200


#if !defined(StiDebugMsg)

//
// StiDebugMsg(mask, msg, args...) - Generate wsprintf-formatted msg using
// specified debug mask.  System debug mask governs whether message is output.
//

#define REGVAL_STR_DEBUGMASK_A    "DebugMask"
#define REGVAL_STR_DEBUGMASK_W    L"DebugMask"

void __cdecl StiDebugMsg(UINT mask, LPCTSTR psz, ...);

UINT WINAPI  StiSetDebugParameters(PTSTR pszName,PTSTR pszLogFile);
UINT WINAPI  StiSetDebugMask(UINT mask);
UINT WINAPI  StiGetDebugMask(void);

#endif

#ifdef  DEBUG

#define Break()  DebugBreak()
#define DPRINTF  StiDebugMsg

#else

#define Break()

//
// Nb: Following definition is needed to avoid compiler complaining
// about empty function name in expression. In retail builds using this macro
// will cause string parameters not appear in executable
//
#define DPRINTF     1?(void)0 : (void)

#endif

#if defined(__cplusplus)
}
#endif

#if defined(__cplusplus)

#ifdef  DEBUG

class DBGTRACE
{
private:
    TCHAR   m_szMessage[200];

public:
    inline DBGTRACE(LPTSTR szMsg) {
        ZeroMemory(m_szMessage, sizeof(m_szMessage));
        lstrcpyn(m_szMessage,szMsg, sizeof(m_szMessage) / sizeof(m_szMessage[0]) - 1);
        DPRINTF(DM_TRACE,TEXT("ProcTraceEnter:%s At sec =%d "),
                m_szMessage,::GetTickCount()/1000);
    }

    inline ~DBGTRACE() {
        DPRINTF(DM_TRACE,TEXT("ProcTraceExit:%s At sec. =%d "),m_szMessage,::GetTickCount()/1000);
    }
};

#else

class DBGTRACE
{
public:
    inline DBGTRACE(LPTSTR szMsg) {
    }

    inline ~DBGTRACE() {
    }
};

#endif

#endif


//
// Performance monitoring
//

#if defined(__cplusplus)

#ifdef  DEBUG

class TICK_COUNTER
{
private:
    UINT    m_uiStartingCount;
    TCHAR   m_szMessage[200];

public:
    inline TICK_COUNTER(LPTSTR szMsg) {
        ZeroMemory(m_szMessage, sizeof(m_szMessage));
        lstrcpyn(m_szMessage,szMsg, sizeof(m_szMessage) / sizeof(m_szMessage[0]) - 1);
        m_uiStartingCount = ::GetTickCount();
    }

    inline ~TICK_COUNTER() {
        DPRINTF(DM_TRACE,TEXT("Elapsed time in (%s) is: %d ticks, %d seconds"),
                m_szMessage,
                ::GetTickCount() - m_uiStartingCount,
                (::GetTickCount() - m_uiStartingCount) / 1000
                );
    }

    inline ElapsedTicks(VOID) { return (::GetTickCount() - m_uiStartingCount);}

};

#else

class TICK_COUNTER
{
public:
    inline TICK_COUNTER(LPTSTR szMsg) {
    }

    inline ~TICK_COUNTER() {
    }
};

#endif
#endif


#endif // _STIDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\stidev.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    stidev.h

Abstract:

    Prototypes for commonly used STI related routines

Notes:

Author:

    Vlad Sadovsky   (VladS)    9/23/1998

Environment:

    User Mode - Win32

Revision History:

    9/23/1998       VladS       Created

--*/


#ifdef __cplusplus
extern "C"{
#endif

HRESULT
VenStiGetDeviceByModelID(
                LPCTSTR lpszModelID,
                LPCTSTR lpszVendor,
                LPCTSTR lpszFriendlyName,
                LPWSTR pStiDeviceName
                );

BOOL
VenStiInitializeDeviceCache(
    VOID
    );

BOOL
VenStiTerminateDeviceCache(
    VOID
    );

HRESULT
VenStiGetDeviceInterface(
    LPWSTR      pStiDeviceName,
    PSTIDEVICE  *ppStiDevice
    );


#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\stierr.h ===
/*++

Copyright (c) 1986-1997  Microsoft Corporation

Module Name:

    stierr.h

Abstract:

    This module contains the user mode still image APIs error and status codes

Author:


Revision History:


--*/

#ifndef _STIERR_
#define _STIERR_


//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

//
// Generic test for information on any status value.
//

#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for warning on any status value.
//

#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)

//
// Generic test for error on any status value.
//

#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)

//
// Error codes are constructed as compound COM status codes
//

/*
 * The operation completed successfully
 */
#define STI_OK  S_OK
#define STI_ERROR_NO_ERROR          STI_OK

/*
 * The device exists but not currently attached to the system
 */
#define STI_NOTCONNECTED            S_FALSE

/*
 * The requested change in device mode settings had no effect
 */
#define STI_CHANGENOEFFECT          S_FALSE

/*
 * The application requires newer version
 */
#define STIERR_OLD_VERSION      \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_OLD_WIN_VERSION)

/*
 * The application was written for pre-release version of provider DLL
 */
#define STIERR_BETA_VERSION     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_RMODE_APP)

/*
 * The requested object could not be created due to incompatible or mismatched driver
 */
#define STIERR_BADDRIVER        \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_BAD_DRIVER_LEVEL)

/*
 * The device is not registered
 */
#define STIERR_DEVICENOTREG     REGDB_E_CLASSNOTREG

/*
 * The requested container does not exist
 */
#define STIERR_OBJECTNOTFOUND \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_FILE_NOT_FOUND)

/*
 * An invalid or not state matching parameter was passed to the API
 */
#define STIERR_INVALID_PARAM    E_INVALIDARG

/*
 * The specified interface is not supported
 */
#define STIERR_NOINTERFACE      E_NOINTERFACE

/*
 * The undetermined error occured
 */
#define STIERR_GENERIC          E_FAIL

/*
 * There is not enough memory to perform requested operation
 */
#define STIERR_OUTOFMEMORY      E_OUTOFMEMORY

/*
 * The application called unsupported (at this time)function
 */
#define STIERR_UNSUPPORTED      E_NOTIMPL

/*
 * The application requires newer version
 */
#define STIERR_NOT_INITIALIZED     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_NOT_READY)

/*
 * The application requires newer version
 */
#define STIERR_ALREADY_INITIALIZED     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_ALREADY_INITIALIZED)

/*
 * The operation can not performed while device is locked
 */
#define STIERR_DEVICE_LOCKED    \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_LOCK_VIOLATION)

/*
 * The specified propery can not be changed for this device
 */
#define STIERR_READONLY         E_ACCESSDENIED

/*
 * The device already has notification handle associated with it
 */
#define STIERR_NOTINITIALIZED   E_ACCESSDENIED


/*
 * The device needs to be locked before attempting this operation
 */
#define STIERR_NEEDS_LOCK    \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_NOT_LOCKED)

/*
 * The device is opened by another application in data mode
 */
#define STIERR_SHARING_VIOLATION    \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_SHARING_VIOLATION)


/*
 * Handle already set for this context
 */
#define STIERR_HANDLEEXISTS     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_ALREADY_EXISTS)

 /*
  * Device name is not recognized
  */
#define STIERR_INVALID_DEVICE_NAME     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_INVALID_NAME)

 /*
  * Device hardware type is not valid
  */
#define STIERR_INVALID_HW_TYPE     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_INVALID_DATA)


 /*
  * Device hardware type is not valid
  */
#define STIERR_INVALID_HW_TYPE     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_INVALID_DATA)

 /*
  * No events available
  */
#define STIERR_NOEVENTS     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_NO_MORE_ITEMS)

 /*
  * Device appears as not ready
  */
#define STIERR_DEVICE_NOTREADY     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_NOT_READY)


//#define STIERR_


#endif // _STIERR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\stirc.h ===
#include "stimsg.h"

#define IDS_STIDEVICE   4001
#define IDS_STIOBJ      4002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\stilog.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stitrace.h

Abstract:

    This file defines functions and types required to support file logging
    for all STI components


Author:

    Vlad Sadovsky (vlads)   02-Sep-1997


Environment:

    User Mode - Win32

Revision History:

    02-Sep-1997     VladS       created

--*/

# ifndef _STITRACE_H_
# define _STITRACE_H_

# include <windows.h>

/***********************************************************
 *    Named constants  definitions
 ************************************************************/

#define STI_MAX_LOG_SIZE            1000000         // in bytes

#define STI_TRACE_INFORMATION       0x00000001
#define STI_TRACE_WARNING           0x00000002
#define STI_TRACE_ERROR             0x00000004

#define STI_TRACE_ADD_TIME          0x00010000
#define STI_TRACE_ADD_MODULE        0x00020000
#define STI_TRACE_ADD_THREAD        0x00040000
#define STI_TRACE_ADD_PROCESS       0x00080000
#define STI_TRACE_LOG_TOUI          0x00100000

#define STI_TRACE_MESSAGE_TYPE_MASK 0x0000ffff
#define STI_TRACE_MESSAGE_FLAGS_MASK  0xffff0000

#ifndef STIMON_MSG_LOG_MESSAGE
// BUGBUG
#define STIMON_MSG_LOG_MESSAGE      WM_USER+205
#endif

#ifdef __cplusplus
//
// Class definitions used only in C++ code
//

#include <base.h>
#include <lock.h>
#include <stistr.h>

#ifndef DLLEXP
//#define DLLEXP __declspec( dllexport )
#define DLLEXP
#endif


/***********************************************************
 *    Type Definitions
 ************************************************************/

#define SIGNATURE_FILE_LOG      (DWORD)'SFLa'
#define SIGNATURE_FILE_LOG_FREE (DWORD)'SFLf'

#define STIFILELOG_CHECK_TRUNCATE_ON_BOOT   0x00000001                      
                        
class STI_FILE_LOG  : public BASE {

private:

    DWORD       m_dwSignature;
    LPCTSTR     m_lpszSource;       // Name of the file , containing log
    DWORD       m_dwReportMode;     // Bit mask , describing which messages types get reported
    DWORD       m_dwMaxSize;        // Maximum size ( in bytes )
    HANDLE      m_hLogFile;
    HMODULE     m_hDefaultMessageModule;
    LONG        m_lWrittenHeader;

    TCHAR       m_szLogFilePath[MAX_PATH];
    TCHAR       m_szTracerName[16];
    TCHAR       m_szProcessName[13];

    VOID
    WriteStringToLog(
        LPCTSTR pszTextBuffer,
        BOOL    fFlush=FALSE
    );

public:

    DLLEXP
    STI_FILE_LOG(
        IN LPCTSTR lpszTracerName,
        IN LPCTSTR lpszLogName,
        IN DWORD   dwFlags = 0,
        IN HMODULE hMessageModule = NULL
        );

    DLLEXP
    ~STI_FILE_LOG( VOID);

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    BOOL
    inline
    IsValid(VOID)
    {
        return (( QueryError() == NO_ERROR) && (m_dwSignature == SIGNATURE_FILE_LOG));
    }

    DWORD
    inline
    SetReportMode(
        DWORD   dwNewMode
        ) {
        DWORD   dwOldMode = m_dwReportMode;
        m_dwReportMode = dwNewMode;
        return dwOldMode;
    }

    DWORD
    inline
    QueryReportMode(
        VOID
        ) {
        return m_dwReportMode;
    }

    VOID
    WriteLogSessionHeader(
        VOID
    );


    DLLEXP
    void
    ReportMessage(
        DWORD   dwType,
        LPCTSTR psz,
        ...
        );

    DLLEXP
    void
    STI_FILE_LOG::
    ReportMessage(
        DWORD   dwType,
        DWORD   idMessage,
        ...
    );

    DLLEXP
    void
    vReportMessage(
        DWORD   dwType,
        LPCTSTR psz,
        va_list arglist
        );


};

typedef STI_FILE_LOG * LPSTI_FILE_LOG;

#endif // C++

//
// C calls to allow non-C++ code access file logging objects
//

#ifdef __cplusplus
extern "C" {
#endif

HANDLE
WINAPI
CreateStiFileLog(
    IN  LPCTSTR lpszTracerName,
    IN  LPCTSTR lpszLogName,
    IN  DWORD   dwReportMode
    );

DWORD
WINAPI
CloseStiFileLog(
    IN  HANDLE  hFileLog
    );

DWORD
WINAPI
ReportStiLogMessage(
    IN  HANDLE  hFileLog,
    IN  DWORD   dwType,
    IN  LPCTSTR psz,
    ...
    );

#ifdef __cplusplus
}
#endif

#endif // _STITRACE_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\stimsg.h ===
/*++;

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sti.mc, sti.h

Abstract:

    This file contains the message definitions for the STI DLL 

Author:

    Vlad Sadovsky   (VladS)    01-Oct-1997

Revision History:

Notes:

--*/

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: MSG_FAILED_OPEN_DEVICE_KEY
//
// MessageText:
//
//  Loading USD, cannot open device registry key.
//
#define MSG_FAILED_OPEN_DEVICE_KEY       0xC0002001L

//
// MessageId: MSG_FAILED_READ_DEVICE_NAME
//
// MessageText:
//
//  Loading USD, cannot read device name from registry.
//
#define MSG_FAILED_READ_DEVICE_NAME      0xC0002002L

//
// MessageId: MSG_FAILED_CREATE_DCB
//
// MessageText:
//
//  Loading USD, failed to create device control block. Error code (hex)=%1!x!.
//
#define MSG_FAILED_CREATE_DCB            0xC0002003L

//
// MessageId: MSG_LOADING_USD
//
// MessageText:
//
//  Attempting to load user-mode driver (USD) for the device.
//
#define MSG_LOADING_USD                  0x40002004L

//
// MessageId: MSG_LOADING_PASSTHROUGH_USD
//
// MessageText:
//
//  Could not create instance for registered USD, possibly incorrect class ID or problems loading DLL. Trying to initialize pass-through USD.Error code (hex)=%1!x!. 
//
#define MSG_LOADING_PASSTHROUGH_USD      0x40002005L

//
// MessageId: MSG_INITIALIZING_USD
//
// MessageText:
//
//  Completed loading USD, calling initialization routine.
//
#define MSG_INITIALIZING_USD             0x40002006L

//
// MessageId: MSG_OLD_USD
//
// MessageText:
//
//  Version of USD is either too old or too new , will not work with this version of sti dll.
//
#define MSG_OLD_USD                      0xC0002008L

//
// MessageId: MSG_SUCCESS_USD
//
// MessageText:
//
//  Successfully loaded user mode driver.
//
#define MSG_SUCCESS_USD                  0x40002009L

//
// MessageId: MSG_FAILED_INIT_USD
//
// MessageText:
//
//  USD failed Initialize method, returned error code (hex)=%1!x!.
//  .               
//  
//  
//
#define MSG_FAILED_INIT_USD              0xC000200AL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\stilib.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stilib.h

Abstract:

    Various library definitions , common for multiple STI subprojects

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/

#ifndef _INC_STILIB
#define _INC_STILIB

# if !defined( dllexp)
# define dllexp               __declspec( dllexport)
# endif // !defined( dllexp)

#include <linklist.h>
#include <buffer.h>
//#include <stistr.h>

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


#if !defined(DEBUG)
#if defined(_DEBUG) || defined(DBG)
#define DEBUG
#endif
#endif

#ifdef DBCS
#define IS_LEAD_BYTE(c)     IsDBCSLeadByte(c)
#else
#define IS_LEAD_BYTE(c)     0
#endif

#ifdef DEBUG
void            cdecl nprintf(const char *, ...);
#endif

#ifdef DBCS
#define ADVANCE(p)  (p += IS_LEAD_BYTE(*p) ? 2 : 1)
#else
#define ADVANCE(p)  (++p)
#endif

#define SPN_SET(bits,ch)    bits[(ch)/8] |= (1<<((ch) & 7))
#define SPN_TEST(bits,ch)   (bits[(ch)/8] & (1<<((ch) & 7)))

int sbufchkf(const char FAR *, unsigned short);


// I_IsBadStringPtrA()
//
// Private Win32 version of IsBadStringPtr that works properly, i.e.
// like the Win16 version, it returns TRUE if the string is not
// null-terminated.
BOOL WINAPI I_IsBadStringPtrA(LPCSTR lpsz, UINT ucchMax);

//
//
//
#define     IS_EMPTY_STRING(pch) (!(pch) || !(*(pch)))

//
// String run-time calls
//
//
#define strcpyf(d,s)    lstrcpy((d),(s))
#define strcatf(d,s)    lstrcat((d),(s))
#define strlenf(s)      lstrlen((s))

#define strcmpf(s1,s2)  lstrcmp(s1,s2)
#define stricmpf(s1,s2) lstrcmpi(s1,s2)

#pragma intrinsic(memcmp,memset)
#define memcmpf(d,s,l)  memcmp((d),(s),(l))
#define memsetf(s,c,l)  memset((s),(c),(l))
#define memmovef(d,s,l) MoveMemory((d),(s),(l))
#define memcpyf(d,s,l)  CopyMemory((d),(s),(l))

/*
 * WaitAndYield processes all input messages.  WaitAndProcessSends only
 * processes SendMessages.
 *
 * WaitAndYield takes an optional parameter which is the ID of another
 * thread concerned with the waiting.  If it's not NULL, WM_QUIT messages
 * will be posted to that thread's queue when they are seen in the message
 * loop.
 */
DWORD WaitAndYield(HANDLE hObject, DWORD dwTimeout, volatile DWORD *pidOtherThread = NULL);
DWORD WaitAndProcessSends(HANDLE hObject, DWORD dwTimeout);

//
// Message box routines
//

#define IDS_MSGTITLE    1024

//extern int MsgBox( HWND hwndDlg, UINT idMsg, UINT wFlags, const STR **aps = NULL );
//extern UINT MsgBoxPrintf(HWND hwnd,UINT uiMsg,UINT uiTitle,UINT uiFlags,...);
//extern UINT LoadMsgPrintf(STR& strMessage,UINT  uiMsg,...);

//
// Registry access class
//
//#include <regentry.h>

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#if !defined(DBG) && !defined(DEBUG)
//
// Overloaded allocation operators
//

inline void  * __cdecl operator new(size_t size)
{
    return (void *)LocalAlloc(LPTR,size);
}
inline void  __cdecl operator delete(void *ptr)
{
    LocalFree(ptr);
}

#if 0
inline UINT __cdecl allocated_size(void *ptr)
{
    return ptr ? (UINT)LocalSize(ptr) : 0;
}
#endif

#endif

#endif /* _INC_STILIB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\stipriv.h ===
/***************************************************************************
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       stipriv.h
 *  Content:    Internal include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *
 *   10/28/96   vlads   Starting code for STI
 *
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifdef __cplusplus
extern "C" {
#endif

#ifndef FINAL
    #define EXPIRE_YEAR 2001
    #define EXPIRE_MONTH  01
    #define EXPIRE_DAY    24
#endif

typedef LPUNKNOWN   PUNK;
typedef LPVOID      PV, *PPV;
typedef CONST VOID *PCV;
typedef REFIID      RIID;
typedef CONST GUID *PCGUID;

#define MAX_REG_CHAR    128

//
// We need to use free-threading model, definitions for which are guarded
// with the following define ( in VC 5.0).
//
#ifndef  _WIN32_DCOM
//#define _WIN32_DCOM
#endif


/***************************************************************************
 *
 *      Global variables
 *
 ***************************************************************************/

extern  HINSTANCE   g_hInst;
extern  BOOL        g_NoUnicodePlatform;
extern  BOOL        g_COMInitialized;
extern  HANDLE  g_hStiFileLog;

/*****************************************************************************
 *
 *      stiobj.c - ISti objectimplementation
 *
 *****************************************************************************/

STDMETHODIMP CStiObj_New(PUNK punkOuter, RIID riid, PPV ppvOut);

STDMETHODIMP StiCreateHelper(
    HINSTANCE hinst,
    DWORD dwVer,
    PPV ppvObj,
    PUNK punkOuter,
    RIID riid
    );

STDMETHODIMP StiPrivateGetDeviceInfoHelperW(
    LPWSTR  pwszDeviceName,
    LPVOID  *ppBuffer
    );

/*****************************************************************************
 *
 *
 *****************************************************************************/

#define INTERNAL NTAPI  /* Called only within a translation unit */
#define EXTERNAL NTAPI  /* Called from other translation units */
#define INLINE static __inline

#define BEGIN_CONST_DATA data_seg(".text", "CODE")
#define END_CONST_DATA data_seg(".data", "DATA")

/*
 *  Arithmetic on pointers.
 */
#define pvSubPvCb(pv, cb) ((PV)((PBYTE)pv - (cb)))
#define pvAddPvCb(pv, cb) ((PV)((PBYTE)pv + (cb)))
#define cbSubPvPv(p1, p2) ((PBYTE)(p1) - (PBYTE)(p2))

/*
 * Convert an object (X) to a count of bytes (cb).
 */
#define cbX(X) sizeof(X)

/*
 * Convert an array name (A) to a generic count (c).
 */
#define cA(a) (cbX(a)/cbX(a[0]))

/*
 * Convert a count of X's (cx) into a count of bytes.
 */
#define  cbCxX(cx, X) ((cx) * cbX(X))

/*
 * Convert a count of chars (cch), tchars (ctch), wchars (cwch),
 * or dwords (cdw) into a count of bytes.
 */
#define  cbCch(cch)  cbCxX( cch,  CHAR)
#define cbCwch(cwch) cbCxX(cwch, WCHAR)
#define cbCtch(ctch) cbCxX(ctch, TCHAR)
#define  cbCdw(cdw)  cbCxX( cdw, DWORD)

/*
 * Zero an arbitrary buffer.  It is a common error to get the second
 * and third parameters to memset backwards.
 */
#define ZeroBuf(pv, cb) memset(pv, 0, cb)

/*
 * Zero an arbitrary object.
 */
#define ZeroX(x) ZeroBuf(&(x), cbX(x))

/*
 * land -- Logical and.  Evaluate the first.  If the first is zero,
 * then return zero.  Otherwise, return the second.
 */

#define fLandFF(f1, f2) ((f1) ? (f2) : 0)

/*
 * limp - logical implication.  True unless the first is nonzero and
 * the second is zero.
 */
#define fLimpFF(f1, f2) (!(f1) || (f2))

/*
 * leqv - logical equivalence.  True if both are zero or both are nonzero.
 */
#define fLeqvFF(f1, f2) (!(f1) == !(f2))


/*
 *  fInOrder - checks that i1 <= i2 < i3.
 */
#define fInOrder(i1, i2, i3) ((unsigned)((i2)-(i1)) < (unsigned)((i3)-(i1)))

/*
 * Words to keep preprocessor happy.
 */
#define comma ,
#define empty

/*
 *  Atomically exchange one value for another.
 */
#define pvExchangePpvPv(ppv, pv) \
        (PV)InterlockedExchangePointer((PPV)(ppv), (PV)(pv))

/*
 *  Creating HRESULTs from a USHORT or from a LASTERROR.
 */
#define hresUs(us) MAKE_HRESULT(SEVERITY_SUCCESS, 0, (USHORT)(us))
#define hresLe(le) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, (USHORT)(le))

/***************************************************************************
 *
 *  Debug / RDebug / Retail
 *
 *  If either DEBUG or RDEBUG, set MAXDEBUG.
 *
 *  Retail defines nothing.
 *
 ***************************************************************************/

#if defined(DEBUG) || defined(RDEBUG)
//#define MAXDEBUG
#endif

/***************************************************************************
 *
 *                            Validation Code....
 *
 *  "If it crashes in retail, it must crash in debug."
 *
 *  What we don't want is an app that works fine under debug, but crashes
 *  under retail.
 *
 *  So if we find an invalid parameter in debug that would not have been
 *  detected by retail, let it pass through after a warning.  That way,
 *  the invalid parameter continues onward through the system and creates
 *  as much (or more) havoc in debug as it would under retail.
 *
 *  The _fFastValidXxx functions perform cursory validation.
 *  The _fFullValidXxx functions perform full validation.
 *
 *  In retail, fFastValidXxx maps to _fFastValidXxx.
 *
 *  In debug, fFastValidXxx performs a full validation and throws away
 *  the error value, then returns the value of _fFastValidXxx.
 *
 *  The hresFullValidXxx functions return HRESULTs instead of BOOLs.
 *
 *  Values for Xxx:
 *
 *      Hwnd      - hwnd = window handle
 *      Pdw       - pdw = pointer to a dword
 *      PdwOut    - pdw = pointer to a dword that will be set initially to 0
 *      Pfn       - pfn = function pointer
 *      riid      - riid = pointer to IID
 *      guid      - pguid = pointer to GUID
 *
 *      ReadPx    - p -> structure for reading, X = structure name
 *      WritePx   - p -> structure for writing, X = structure name
 *
 *      ReadPxCb  - p -> structure for reading, X = structure name
 *                  first field of structure is dwSize which must be
 *                  equal to cbX(X).
 *
 *      WritePxCb - p -> structure for writing, X = structure name
 *                  first field of structure is dwSize which must be
 *                  equal to cbX(X).
 *
 *      ReadPvCb  - p -> buffer, cb = size of buffer
 *      WritePvCb - p -> buffer, cb = size of buffer
 *
 *      Pobj      - p -> internal interface
 *
 *      fl        - fl = incoming flags, flV = valid flags
 *
 ***************************************************************************/

#ifndef MAXDEBUG

/*
 *  Wrappers that throw away the szProc and iarg info.
 */

#define hresFullValidHwnd_(hwnd, z, i)                              \
       _hresFullValidHwnd_(hwnd)                                    \

#define hresFullValidPdwOut_(pdw, z, i)                             \
       _hresFullValidPdwOut_(pdw)                                   \

#define hresFullValidReadPxCb_(pv, cb, pszProc, iarg)               \
       _hresFullValidReadPxCb_(pv, cb)                              \

#define hresFullValidReadPvCb_(pv, cb, pszProc, iarg)               \
       _hresFullValidReadPvCb_(pv, cb)                              \

#define hresFullValidWritePxCb_(pv, cb, pszProc, iarg)              \
       _hresFullValidWritePxCb_(pv, cb)                             \

#define hresFullValidWritePvCb_(pv, cb, pszProc, iarg)              \
       _hresFullValidWritePvCb_(pv, cb)                             \

#define hresFullValidFl_(fl, flV, pszProc, iarg)                    \
       _hresFullValidFl_(fl, flV)                                   \

#define hresFullValidPfn_(pfn, pszProc, iarg)                       \
       _hresFullValidPfn_(pfn)                                      \

#define hresFullValidPitf_(punk, pszProc, iarg)                     \
       _hresFullValidPitf_(punk)                                    \

#define hresFullValidHwnd0_(hwnd, pszProc, iarg)                    \
       _hresFullValidHwnd0_(hwnd)                                   \

#define hresFullValidPitf0_(punk, pszProc, iarg)                    \
       _hresFullValidPitf0_(punk)                                   \

#endif

/*
 *  The actual functions.
 */

STDMETHODIMP hresFullValidHwnd_(HWND hwnd, LPCSTR pszProc, int iarg);
STDMETHODIMP hresFullValidPdwOut_(PV pdw, LPCSTR pszProc, int iarg);
STDMETHODIMP hresFullValidReadPxCb_(PCV pv, UINT cb, LPCSTR pszProc, int iarg);
STDMETHODIMP hresFullValidReadPvCb_(PCV pv, UINT cb, LPCSTR pszProc, int iarg);
STDMETHODIMP hresFullValidWritePxCb_(PV pv, UINT cb, LPCSTR pszProc, int iarg);
STDMETHODIMP hresFullValidWritePvCb_(PV pv, UINT cb, LPCSTR pszProc, int iarg);
STDMETHODIMP hresFullValidFl_(DWORD fl, DWORD flV, LPCSTR pszProc, int iarg);
STDMETHODIMP hresFullValidPfn_(FARPROC pfn, LPCSTR pszProc, int iarg);
STDMETHODIMP hresFullValidPitf_(PUNK punk, LPCSTR pszProc, int iarg);

HRESULT INLINE
hresFullValidHwnd0_(HWND hwnd, LPCSTR pszProc, int iarg)
{
    HRESULT hres;
    if (hwnd) {
        hres = hresFullValidHwnd_(hwnd, pszProc, iarg);
    } else {
        hres = S_OK;
    }
    return hres;
}

HRESULT INLINE
hresFullValidPitf0_(PUNK punk, LPCSTR pszProc, int iarg)
{
    HRESULT hres;
    if (punk) {
        hres = hresFullValidPitf_(punk, pszProc, iarg);
    } else {
        hres = S_OK;
    }
    return hres;
}

/*
 *  Wrappers for derived types.
 */

#define hresFullValidRiid_(riid, s_szProc, iarg)                    \
        hresFullValidReadPvCb_(riid, cbX(IID), s_szProc, iarg)      \

/*
 *  Wrapers that add the szProc and iarg info.
 */

#define hresFullValidHwnd(hwnd, iarg)                               \
        hresFullValidHwnd_(hwnd, s_szProc, iarg)                    \

#define hresFullValidPdwOut(pdw, i)                                 \
        hresFullValidPdwOut_(pdw, s_szProc, i)                      \

#define hresFullValidReadPdw_(pdw, z, i)                            \
        hresFullValidReadPvCb_(pdw, cbX(DWORD), z, i)               \

#define hresFullValidRiid(riid, iarg)                               \
        hresFullValidRiid_(riid, s_szProc, iarg)                    \

#define hresFullValidGuid(pguid, iarg)                              \
        hresFullValidReadPvCb_(pguid, cbX(GUID), s_szProc, iarg)    \

#define hresFullValidReadPxCb(pv, X, iarg)                          \
        hresFullValidReadPxCb_(pv, cbX(X), s_szProc, iarg)          \

#define hresFullValidReadPvCb(pv, cb, iarg)                         \
        hresFullValidReadPvCb_(pv, cb, s_szProc, iarg)              \

#define hresFullValidReadPx(pv, X, iarg)                            \
        hresFullValidReadPvCb_(pv, cbX(X), s_szProc, iarg)          \

#define hresFullValidWritePxCb(pv, X, iarg)                         \
        hresFullValidWritePxCb_(pv, cbX(X), s_szProc, iarg)         \

#define hresFullValidWritePvCb(pv, cb, iarg)                        \
        hresFullValidWritePvCb_(pv, cb, s_szProc, iarg)             \

#define hresFullValidWritePx(pv, X, iarg)                           \
        hresFullValidWritePvCb_(pv, cbX(X), s_szProc, iarg)         \

#define hresFullValidReadPdw(pdw, iarg)                             \
        hresFullValidReadPdw_(pdw, s_szProc, iarg)                  \

#define hresFullValidFl(fl, flV, iarg)                              \
        hresFullValidFl_(fl, flV, s_szProc, iarg)                   \

#define hresFullValidPfn(pfn, iarg)                                 \
        hresFullValidPfn_((FARPROC)(pfn), s_szProc, iarg)           \

#define hresFullValidPitf(pitf, iarg)                               \
        hresFullValidPitf_((PUNK)(pitf), s_szProc, iarg)            \

#define hresFullValidHwnd0(hwnd, iarg)                              \
        hresFullValidHwnd0_(hwnd, s_szProc, iarg)                   \

#define hresFullValidPitf0(pitf, iarg)                              \
        hresFullValidPitf0_((PUNK)(pitf), s_szProc, iarg)           \

/*****************************************************************************
 *
 *  @doc INTERNAL
 *
 *  @func   void | ValidationException |
 *
 *          Raises a parameter validation exception in MAXDEBUG.
 *
 *****************************************************************************/

#define ecValidation (ERROR_SEVERITY_ERROR | hresLe(ERROR_INVALID_PARAMETER))

#ifdef MAXDEBUG
#define ValidationException() RaiseException(ecValidation, 0, 0, 0)
#else
#define ValidationException()
#endif

/*
 * TFORM(x) expands to x##A if ANSI or x##W if UNICODE.
 *          This T-izes a symbol, in the sense of TCHAR or PTSTR.
 *
 * SFORM(x) expands to x##W if ANSI or x##A if UNICODE.
 *          This anti-T-izes a symbol.
 */

#ifdef UNICODE
#define _TFORM(x) x##W
#define _SFORM(x) x##A
#else
#define _TFORM(x) x##A
#define _SFORM(x) x##W
#endif

#define TFORM(x)    _TFORM(x)
#define SFORM(x)    _SFORM(x)


/*
 *  SToT(dst, cchDst, src) - convert S to T
 *  TToS(dst, cchDst, src) - convert T to S
 *
 *  Remember, "T" means "ANSI if ANSI, or UNICODE if UNICODE",
 *  and "S" is the anti-T.
 *
 *  So SToT converts to the preferred character set, and TToS converts
 *  to the alternate character set.
 *
 */

#define AToU(dst, cchDst, src) \
    MultiByteToWideChar(CP_ACP, 0, src, -1, dst, cchDst)
#define UToA(dst, cchDst, src) \
    WideCharToMultiByte(CP_ACP, 0, src, -1, dst, cchDst, 0, 0)

#ifdef UNICODE
#define SToT AToU
#define TToS UToA
#define AToT AToU
#define TToU(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
#else
#define SToT UToA
#define TToS AToU
#define AToT(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
#define TToU AToU
#endif

/*****************************************************************************
 *
 *      Unicode wrappers for Win95
 *
 *****************************************************************************/

#ifndef UNICODE

#define LoadStringW     _LoadStringW

int EXTERNAL LoadStringW(HINSTANCE hinst, UINT ids, LPWSTR pwsz, int cwch);

#endif


//
// Migration function
//
BOOL
RegisterSTIAppForWIAEvents(
    WCHAR   *pszName,
    WCHAR   *pszWide,
    BOOL    fSetAsDefault
    );

HRESULT RunRegisterProcess(
    CHAR   *szAppName,
    CHAR   *szCmdLine);

//
// C specific macros, not needed in C++ code
//
#ifndef __cplusplus

/*****************************************************************************
 *
 *      Common Object Managers for the Component Object Model
 *
 *      OLE wrapper macros and structures.  For more information, see
 *      the beginning of common.c
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      Pre-vtbl structures
 *
 *      Careful!  If you change these structures, you must also adjust
 *      common.c accordingly.
 *
 *****************************************************************************/

typedef struct PREVTBL {                /* Shared vtbl prefix */
    RIID riid;                          /* Type of this object */
    ULONG lib;                          /* offset from start of object */
} PREVTBL, *PPREVTBL;

typedef struct PREVTBLP {               /* Prefix for primary vtbl */
    PPV rgvtbl;                         /* Array of standard vtbls */
    UINT cbvtbl;                        /* Size of vtbl array in bytes */
    STDMETHOD(QIHelper)(PV pv, RIID riid, PPV ppvOut); /* QI helper */
    STDMETHOD_(void,FinalizeProc)(PV pv);/* Finalization procedure */
    PREVTBL prevtbl;                    /* lib must be zero */
} PREVTBLP, *PPREVTBLP;

/*
 *      A fuller implementation is in common.c.  Out here, we need only
 *      concern ourselves with getting to the primary interface.
 */

#define _thisPv(pitf)                                                   \
        pvSubPvCb(pitf, (*(PPREVTBL*)(pitf))[-1].lib)

#define _thisPvNm(pitf, nm)                                             \
        pvSubPvCb(pitf, FIELD_OFFSET(ThisClass, nm))                    \

#ifndef MAXDEBUG

#define hresPvVtbl_(pv, vtbl, pszProc)                                  \
       _hresPvVtbl_(pv, vtbl)                                           \

#endif

HRESULT EXTERNAL
hresPvVtbl_(PV pv, PV vtbl, LPCSTR pszProc);

#define hresPvVtbl(pv, vtbl)                                            \
        hresPvVtbl_(pv, vtbl, s_szProc)                                 \

#define hresPvI(pv, I)                                                  \
        hresPvVtbl(pv, Class_Vtbl(ThisClass, I))                        \

#define hresPv(pv)                                                      \
        hresPvI(pv, ThisInterface)                                      \

#ifdef MAXDEBUG

#define hresPvT(pv)                                                     \
        hresPvVtbl(pv, vtblExpected)                                    \

#else

#define hresPvT(pv)                                                     \
        hresPv(pv)                                                      \

#endif

/*****************************************************************************
 *
 *      Declaring interfaces
 *
 *      The extra level of indirection on _Primary_Interface et al
 *      allow the interface name to be a macro which expands to the
 *      *real* name of the interface.
 *
 *****************************************************************************/

#define __Class_Vtbl(C, I)              &c_##I##_##C##VI.vtbl
#define  _Class_Vtbl(C, I)            __Class_Vtbl(C, I)
#define   Class_Vtbl(C, I)             _Class_Vtbl(C, I)

#define Num_Interfaces(C)               cA(c_rgpv##C##Vtbl)

#ifdef  DEBUG

#define Simple_Interface(C)             Primary_Interface(C, IUnknown); \
                                        Default_QueryInterface(C)       \
                                        Default_AddRef(C)               \
                                        Default_Release(C)
#define Simple_Vtbl(C)                  Class_Vtbl(C)
#define Simple_Interface_Begin(C)       Primary_Interface_Begin(C, IUnknown)
#define Simple_Interface_End(C)         Primary_Interface_End(C, IUnknown)

#else

#define Simple_Interface(C)             Primary_Interface(C, IUnknown)
#define Simple_Vtbl(C)                  Class_Vtbl(C)
#define Simple_Interface_Begin(C)                                       \
        struct S_##C##Vtbl c_##I##_##C##VI = { {                        \
            c_rgpv##C##Vtbl,                                            \
            cbX(c_rgpv##C##Vtbl),                                       \
            C##_QIHelper,                                               \
            C##_Finalize,                                               \
            { &IID_##IUnknown, 0 },                                     \
        }, {                                                            \
            Common##_QueryInterface,                                    \
            Common##_AddRef,                                            \
            Common##_Release,                                           \

#define Simple_Interface_End(C)                                         \
        } };                                                            \

#endif

#define _Primary_Interface(C, I)                                        \
        extern struct S_##C##Vtbl {                                     \
            PREVTBLP prevtbl;                                           \
            I##Vtbl vtbl;                                               \
        } c_##I##_##C##VI                                               \

#define Primary_Interface(C, I)                                         \
       _Primary_Interface(C, I)                                         \

#define _Primary_Interface_Begin(C, I)                                  \
        struct S_##C##Vtbl c_##I##_##C##VI = { {                        \
            c_rgpv##C##Vtbl,                                            \
            cbX(c_rgpv##C##Vtbl),                                       \
            C##_QIHelper,                                               \
            C##_Finalize,                                               \
            { &IID_##I, 0, },                                           \
        }, {                                                            \
            C##_QueryInterface,                                         \
            C##_AddRef,                                                 \
            C##_Release,                                                \

#define Primary_Interface_Begin(C, I)                                   \
       _Primary_Interface_Begin(C, I)                                   \

#define Primary_Interface_End(C, I)                                     \
        } };                                                            \

#define _Secondary_Interface(C, I)                                      \
        extern struct S_##I##_##C##Vtbl {                               \
            PREVTBL prevtbl;                                            \
            I##Vtbl vtbl;                                               \
        } c_##I##_##C##VI                                               \

#define Secondary_Interface(C, I)                                       \
       _Secondary_Interface(C, I)                                       \

/*
 *  Secret backdoor for the "private" IUnknown in common.c
 */
#define _Secondary_Interface_Begin(C, I, ofs, Pfx)                      \
        struct S_##I##_##C##Vtbl c_##I##_##C##VI = { {                  \
            &IID_##I,                                                   \
            ofs,                                                        \
        }, {                                                            \
            Pfx##QueryInterface,                                        \
            Pfx##AddRef,                                                \
            Pfx##Release,                                               \

#define Secondary_Interface_Begin(C, I, nm)                             \
       _Secondary_Interface_Begin(C, I, FIELD_OFFSET(C, nm), Common_)   \

#define _Secondary_Interface_End(C, I)                                   \
        } };                                                            \

#define Secondary_Interface_End(C, I, nm)                               \
       _Secondary_Interface_End(C, I)                                   \

#define Interface_Template_Begin(C)                                     \
        PV c_rgpv##C##Vtbl[] = {                                        \

#define Primary_Interface_Template(C, I)                                \
        Class_Vtbl(C, I),                                               \

#define Secondary_Interface_Template(C, I)                              \
        Class_Vtbl(C, I),                                               \

#define Interface_Template_End(C)                                       \
        };                                                              \


STDMETHODIMP Common_QueryInterface(PV, RIID, PPV);
STDMETHODIMP_(ULONG) Common_AddRef(PV pv);
STDMETHODIMP_(ULONG) Common_Release(PV pv);

STDMETHODIMP Common_QIHelper(PV, RIID, PPV);
void EXTERNAL Common_Finalize(PV);

#ifndef MAXDEBUG

#define _Common_New_(cb, punkOuter, vtbl, pvpObj, z)                \
       __Common_New_(cb, punkOuter, vtbl, pvpObj)                   \

#define _Common_NewRiid_(cb, vtbl, punkOuter, riid, pvpObj, z)      \
       __Common_NewRiid_(cb, vtbl, punkOuter, riid, pvpObj)         \

#endif

STDMETHODIMP
_Common_New_(ULONG cb, PUNK punkOuter, PV vtbl, PPV ppvObj, LPCSTR s_szProc);

STDMETHODIMP
_Common_NewRiid_(ULONG cb, PV vtbl, PUNK punkOuter, RIID riid, PPV pvpObj,
                 LPCSTR s_szProc);

#define Common_NewCb(cb, C, punkOuter, ppvObj)                          \
       _Common_New_(cb, punkOuter, Class_Vtbl(C, ThisInterface), ppvObj, s_szProc)

#define Common_New(C, punkOuter, ppvObj)                                \
        Common_NewCb(cbX(C), C, punkOuter, ppvObj)                      \

#define Common_NewCbRiid(cb, C, punkOuter, riid, ppvObj) \
       _Common_NewRiid_(cb, Class_Vtbl(C, ThisInterface), punkOuter, riid, ppvObj, s_szProc)

#define Common_NewRiid(C, punkOuter, riid, ppvObj) \
   _Common_NewRiid_(cbX(C), Class_Vtbl(C, ThisInterface), punkOuter, riid, ppvObj, s_szProc)

#ifdef DEBUG
PV EXTERNAL Common_IsType(PV pv);
#else
#define Common_IsType
#endif
#define Assert_CommonType Common_IsType

STDMETHODIMP Forward_QueryInterface(PV pv, RIID riid, PPV ppvObj);
STDMETHODIMP_(ULONG) Forward_AddRef(PV pv);
STDMETHODIMP_(ULONG) Forward_Release(PV pv);

void EXTERNAL Invoke_Release(PPV pv);

#define Common_DumpObjects()

/*****************************************************************************
 *
 *      OLE wrappers
 *
 *      These basically do the same as IUnknown_Mumble, except that they
 *      avoid side-effects in evaluation by being inline functions.
 *
 *****************************************************************************/

HRESULT INLINE
OLE_QueryInterface(PV pv, RIID riid, PPV ppvObj)
{
    PUNK punk = pv;
    return punk->lpVtbl->QueryInterface(punk, riid, ppvObj);
}

ULONG INLINE
OLE_AddRef(PV pv)
{
    PUNK punk = pv;
    return punk->lpVtbl->AddRef(punk);
}

ULONG INLINE
OLE_Release(PV pv)
{
    PUNK punk = pv;
    return punk->lpVtbl->Release(punk);
}

/*****************************************************************************
 *
 *      Macros that forward to the common handlers after DebugOuting.
 *      Use these only in DEBUG.
 *
 *      It is assumed that DbgFl has been #define'd to the appropriate DbgFl.
 *
 *****************************************************************************/

#ifdef  DEBUG

#define Default_QueryInterface(Class)                           \
STDMETHODIMP                                                    \
Class##_QueryInterface(PV pv, RIID riid, PPV ppvObj)            \
{                                                               \
    DebugOutPtszV(DbgFl, TEXT(#Class) TEXT("_QueryInterface()")); \
    return Common_QueryInterface(pv, riid, ppvObj);             \
}                                                               \

#define Default_AddRef(Class)                                   \
STDMETHODIMP_(ULONG)                                            \
Class##_AddRef(PV pv)                                           \
{                                                               \
    ULONG ulRc = Common_AddRef(pv);                             \
    DebugOutPtszV(DbgFl, TEXT(#Class)                          \
                        TEXT("_AddRef(%08x) -> %d"), pv, ulRc); \
    return ulRc;                                                \
}                                                               \

#define Default_Release(Class)                                  \
STDMETHODIMP_(ULONG)                                            \
Class##_Release(PV pv)                                          \
{                                                               \
    ULONG ulRc = Common_Release(pv);                            \
    DebugOutPtszV(DbgFl, TEXT(#Class)                          \
                       TEXT("_Release(%08x) -> %d"), pv, ulRc); \
    return ulRc;                                                \
}                                                               \

#endif

/*****************************************************************************
 *
 *      Paranoid callbacks
 *
 *      Callback() performs a callback.  The callback must accept exactly
 *      two parameters, both pointers.  (All our callbacks are like this.)
 *      And it must return a BOOL.
 *
 *****************************************************************************/

typedef BOOL (FAR PASCAL * STICALLBACKPROC)(LPVOID, LPVOID);

#ifdef MAXDEBUG
BOOL EXTERNAL Callback(STICALLBACKPROC, PVOID, PVOID);
#else
#define Callback(pec, pv1, pv2) pec(pv1, pv2)
#endif

/*
 *  Describes the CLSIDs we provide to OLE.
 */

typedef STDMETHOD(CREATEFUNC)(PUNK punkOuter, RIID riid, PPV ppvOut);

typedef struct CLSIDMAP {
    REFCLSID rclsid;        /* The clsid */
    CREATEFUNC pfnCreate;   /* How to create it */
    UINT    ids;            /* String that describes it */
} CLSIDMAP, *PCLSIDMAP;

#define cclsidmap   1       /* CLSID_Sti */

extern CLSIDMAP c_rgclsidmap[cclsidmap];

/*****************************************************************************
 *
 *      sti.c - Basic DLL stuff
 *
 *****************************************************************************/

void EXTERNAL DllEnterCrit(void);
void EXTERNAL DllLeaveCrit(void);

void EXTERNAL DllAddRef(void);
void EXTERNAL DllRelease(void);

BOOL EXTERNAL DllInitializeCOM(void);
BOOL EXTERNAL DllUnInitializeCOM(void);

extern CHAR   szProcessCommandLine[];

#ifdef DEBUG

extern UINT g_thidCrit;

#define InCrit() (g_thidCrit == GetCurrentThreadId())

#endif


/*****************************************************************************
 *
 *      sticf.c - IClassFactory implementation
 *
 *****************************************************************************/

STDMETHODIMP CSti_Factory_New(CREATEFUNC pfnCreate, RIID riid, PPV ppvObj);

/*****************************************************************************
 *
 *      device.c - IStiDevice implementation
 *
 *****************************************************************************/

 #define    STI_MUTEXNAME_PREFIX            L"STIDeviceMutex_"

STDMETHODIMP CStiDevice_New(PUNK punkOuter, RIID riid, PPV ppvObj);
STDMETHODIMP OpenDeviceRegistryKey(LPCWSTR  pwszDeviceName,LPCWSTR      pwszSubKeyName,HKEY *phkeyDeviceParameters);

/*****************************************************************************
 *
 *      passusd.c - Pass through USD
 *
 *****************************************************************************/

#define     StiReadControlInfo        STI_RAW_RESERVED+1
#define     StiWriteControlInfo       STI_RAW_RESERVED+2
#define     StiTransact               STI_RAW_RESERVED+3

STDMETHODIMP CStiEmptyUSD_New(PUNK punkOuter, RIID riid, PPV ppvObj);

/*****************************************************************************
 *
 *      hel.c - Hardware emulation layer
 *
 *****************************************************************************/

//
// Device types
//
#define HEL_DEVICE_TYPE_WDM          1
#define HEL_DEVICE_TYPE_PARALLEL     2
#define HEL_DEVICE_TYPE_SERIAL       3

//
// Device open flags
//
#define STI_HEL_OPEN_CONTROL         0x00000001
#define STI_HEL_OPEN_DATA            0x00000002

STDMETHODIMP    NewDeviceControl(DWORD dwDeviceType,DWORD dwMode,LPCWSTR pwszPortName,DWORD dwFlags,PSTIDEVICECONTROL *ppDevCtl);

STDMETHODIMP    CWDMDeviceControl_New(PUNK punkOuter, RIID riid, PPV ppvObj);
STDMETHODIMP    CCommDeviceControl_New(PUNK punkOuter, RIID riid, PPV ppvObj);


/*****************************************************************************
 *
 *      util.c - Misc utilities
 *
 *****************************************************************************/

#define ctchGuid    (1 + 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

#ifndef     MAXDEBUG

#define hresValidInstanceVer_(hinst, dwVer, z)                      \
       _hresValidInstanceVer_(hinst, dwVer)                         \

#endif

HRESULT EXTERNAL
hresValidInstanceVer_(HINSTANCE hinst, DWORD dwVersion, LPCSTR s_szProc);

#define hresValidInstanceVer(hinst, dwVer)                          \
        hresValidInstanceVer_(hinst, dwVer, s_szProc)               \

HRESULT
EXTERNAL
DupEventHandle(HANDLE h, LPHANDLE phOut);

PV EXTERNAL
pvFindResource(HINSTANCE hinst, DWORD id, LPCTSTR rt);

HRESULT
ParseCommandLine(LPSTR   lpszCmdLine,UINT    *pargc,LPTSTR  *argv);

void    WINAPI
StiLogTrace(
    DWORD   dwType,
    DWORD   idMessage,
    ...
    );


#endif //  __cplusplus

/*****************************************************************************
 *
 *      olesupp.c - Misc utilities
 *
 *****************************************************************************/

STDMETHODIMP
MyCoCreateInstanceW(
    LPWSTR      pwszClsid,
    LPUNKNOWN   punkOuter,
    RIID        riid,
    PPV         ppvOut,
    HINSTANCE   *phinst
    );

STDMETHODIMP
MyCoCreateInstanceA(
    LPSTR       ptszClsid,
    LPUNKNOWN   punkOuter,
    RIID        riid,
    PPV         ppvOut,
    HINSTANCE   *phinst
    );


/*****************************************************************************
 *
 *      osutil.c - Misc utilities , specific for platform
 *
 *****************************************************************************/
BOOL EXTERNAL   OSUtil_IsPlatformUnicode(VOID);
HRESULT WINAPI EXTERNAL OSUtil_GetWideString(LPWSTR *ppszWide,LPCSTR pszAnsi);
HRESULT WINAPI EXTERNAL OSUtil_GetAnsiString(LPSTR *     ppszAnsi,LPCWSTR     lpszWide);

HRESULT WINAPI
OSUtil_RegOpenKeyExW(HKEY   hKey,LPCWSTR lpszKeyStrW,DWORD      dwReserved,REGSAM       samDesired,PHKEY        phkResult);

LONG WINAPI
OSUtil_RegCreateKeyExW(
    HKEY hKey, LPWSTR lpszSubKeyW, DWORD dwReserved, LPWSTR lpszClassW, DWORD dwOptions,
    REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);

LONG WINAPI
OSUtil_RegQueryValueExW(HKEY hKey,LPCWSTR lpszValueNameW,DWORD  *pdwType,BYTE* lpData,DWORD     *pcbData,BOOL fUnicodeCaller);

LONG WINAPI
OSUtil_RegSetValueExW(HKEY  hKey,LPCWSTR lpszValueNameW,DWORD   dwType,BYTE* lpData,DWORD       cbData,BOOL fUnicodeCaller);

HRESULT
ReadRegistryStringA(HKEY     hkey,LPCWSTR  pszValueNameW,LPCWSTR  pszDefaultValueW,BOOL     fExpand,LPWSTR * ppwszResult);
HRESULT
ReadRegistryStringW(HKEY     hkey,LPCWSTR  pszValueNameW,LPCWSTR  pszDefaultValueW,BOOL     fExpand,LPWSTR * ppwszResult);

#ifdef UNICODE
    #define ReadRegistryString ReadRegistryStringW
#else
    #define ReadRegistryString ReadRegistryStringA
#endif    

DWORD
ReadRegistryDwordW( HKEY   hkey,LPCWSTR pszValueNameW,DWORD   dwDefaultValue );

DWORD
WriteRegistryStringA(
    IN HKEY hkey,
    IN LPCSTR  pszValueName,
    IN LPCSTR  pszValue,
    IN DWORD   cbValue,
    IN DWORD   fdwType);

DWORD
WriteRegistryStringW(IN HKEY     hkey,
    IN LPCWSTR  pszValueNameW,IN LPCWSTR  pszValueW,IN DWORD    cbValue,IN DWORD    fdwType);

LONG WINAPI
OSUtil_RegDeleteValueW(HKEY hKey,LPWSTR lpszValueNameW);

HANDLE WINAPI
OSUtil_CreateFileW(
    LPCWSTR lpszFileNameW,DWORD dwDesiredAccess,DWORD dwShareMode,LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,DWORD dwFlagsAndAttributes,HANDLE hTemplateFile);

HRESULT
WINAPI
ExtractCommandLineArgumentW(
    LPCSTR  lpszSwitchName,
    LPWSTR  pwszSwitchValue
    );

HRESULT
WINAPI
ExtractCommandLineArgumentA(
    LPCSTR  lpszSwitchName,
    LPSTR   pszSwitchValue
    );

/*****************************************************************************
 *
 *      string.c - Misc utilities , specific for platform
 *      Nb: Prorotypes for Cruntime string functions are in string.h
 *
 *****************************************************************************/
#pragma intrinsic(memcmp,memset,memcpy)

#define OSUtil_StrLenW  wcslen
#define OSUtil_StrCmpW  wcscmp
#define OSUtil_lstrcpyW wcscpy
#define OSUtil_lstrcatW wcscat
#define OSUtil_lstrcpynW wcsncpy

// Security.c
DWORD
CreateWellKnownSids(
        VOID
        );

VOID
FreeWellKnownSids(
    VOID
    );

DWORD
CreateGlobalSyncObjectSD(
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    );


/*****************************************************************************
 *
 *      mem.c - Memory management
 *
 *      Be extremely careful with FreePv, because it doesn't work if
 *      the pointer is null.
 *
 *****************************************************************************/

HRESULT  INLINE
AllocCbPpv(UINT cb, PPV ppv)
{
    HRESULT hres;
    *ppv = LocalAlloc(LPTR, cb);
    hres = *ppv ? NOERROR : E_OUTOFMEMORY;
    return hres;
}

#define FreePv(pv) LocalFree((HLOCAL)(pv))

void  INLINE
FreePpv(PPV ppv)
{
    PV pv = (PV)InterlockedExchangePointer(ppv,(PV) 0);
    if (pv) {
        FreePv(pv);
    }
}

#if 0
#define NEED_REALLOC

STDMETHODIMP EXTERNAL ReallocCbPpv(UINT cb, PV ppvObj);
STDMETHODIMP EXTERNAL AllocCbPpv(UINT cb, PV ppvObj);

#ifdef NEED_REALLOC
#define FreePpv(ppv) (void)ReallocCbPpv(0, ppv)
#else
void EXTERNAL FreePpv(PV ppv);
#define FreePpv(ppv) FreePpv(ppv)
#endif
#endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\stireg.h ===
/*++

Copyright (c) 1986-1997  Microsoft Corporation

Module Name:

    stireg.h

Abstract:

    This module contains the STI registry entries

Author:


Revision History:


--*/

#ifndef _STIREG_
#define _STIREG_

//
// Registry keys and values
//
#define REGSTR_VAL_TYPE_W            L"Type"
#define REGSTR_VAL_VENDOR_NAME_W     L"Vendor"
#define REGSTR_VAL_DEVICETYPE_W      L"DeviceType"
#define REGSTR_VAL_DEVICESUBTYPE_W   L"DeviceSubType"
#define REGSTR_VAL_DEV_NAME_W        L"DeviceName"
#define REGSTR_VAL_DRIVER_DESC_W     L"DriverDesc"
#define REGSTR_VAL_FRIENDLY_NAME_W   L"FriendlyName"
#define REGSTR_VAL_GENERIC_CAPS_W    L"Capabilities"
#define REGSTR_VAL_HARDWARE_W        L"HardwareConfig"
#define REGSTR_VAL_HARDWARE          TEXT("HardwareConfig")
#define REGSTR_VAL_DEVICE_NAME_W     L"DriverDesc"
#define REGSTR_VAL_DATA_W            L"DeviceData"
#define REGSTR_VAL_GUID_W            L"GUID"
#define REGSTR_VAL_GUID               TEXT("GUID")
#define REGSTR_VAL_LAUNCH_APPS_W     L"LaunchApplications"
#define REGSTR_VAL_LAUNCH_APPS        TEXT("LaunchApplications")
#define REGSTR_VAL_LAUNCHABLE_W      L"Launchable"
#define REGSTR_VAL_LAUNCHABLE         TEXT("Launchable")

//
// CustomDeviceProperty names and values
//
#define IS_DIGITAL_CAMERA_STR   L"IsDigitalCamera"
#define IS_DIGITAL_CAMERA_VAL   1
#define SUPPORTS_MSCPLUS_STR    L"SupportsMSCPlus"
#define SUPPORTS_MSCPLUS_VAL    1

//
// Device instance value names
//
#define STI_DEVICE_VALUE_TWAIN_NAME    L"TwainDS"
#define STI_DEVICE_VALUE_ISIS_NAME     L"ISISDriverName"
#define STI_DEVICE_VALUE_ICM_PROFILE   L"ICMProfile"
#define STI_DEVICE_VALUE_DEFAULT_LAUNCHAPP  L"DefaultLaunchApp"
#define STI_DEVICE_VALUE_TIMEOUT       L"PollTimeout"
#define STI_DEVICE_VALUE_DISABLE_NOTIFICATIONS  L"DisableNotifications"
#define REGSTR_VAL_BAUDRATE            L"BaudRate"

#define STI_DEVICE_VALUE_TWAIN_NAME_A  "TwainDS"
#define STI_DEVICE_VALUE_ISIS_NAME_A   "ISISDriverName"
#define STI_DEVICE_VALUE_ICM_PROFILE_A   "ICMProfile"
#define STI_DEVICE_VALUE_DEFAULT_LAUNCHAPP_A  "DefaultLaunchApp"
#define STI_DEVICE_VALUE_TIMEOUT_A       "PollTimeout"
#define STI_DEVICE_VALUE_DISABLE_NOTIFICATIONS_A  "DisableNotifications"
#define REGSTR_VAL_BAUDRATE_A            "BaudRate"


#endif // _STIREG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\stitwn.h ===
#ifdef __cplusplus
extern "C"{
#endif


//
//  NLS -- to TWAIN conversion
//
VOID
SetIdentityNLSParameters(
    TW_IDENTITY *pIdentityStruct,
    SHORT       *pDeviceKind
);


#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\stiregi.h ===
/*++

Copyright (c) 1986-1997  Microsoft Corporation

Module Name:

    stiregi.h

Abstract:

    This module contains internal only STI registry entries

Author:


Revision History:


--*/

#ifndef _STIREGI_
#define _STIREGI_

#include <stireg.h>

//
//
// Private flags to communicate with class installer
#define SCIW_PRIV_SHOW_FIRST        0x00000001
#define SCIW_PRIV_CALLED_FROMCPL    0x00000002

//

//
// Registry names
//
#define REGSTR_PATH_STICONTROL_W        L"System\\CurrentControlSet\\Control\\StillImage"
#define REGSTR_PATH_STIDEVICES_W        L"System\\CurrentControlSet\\Services\\Class"
#define REGSTR_PATH_STIDEVICES_NT_W     L"System\\CurrentControlSet\\Control\\Class"
#define REGSTR_PATH_REG_APPS_W          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\StillImage\\Registered Applications"
#define REGSTR_PATH_ENUM_W              L"Enum"
#define REGSTR_PATH_EVENTS_W            L"\\Events"
#define REGSTR_PATH_LOGGING_W           L"\\Logging"
#define REGSTR_VAL_STIWIASVCDLL_W       L"WiaServiceDll"
#define REGSTR_VAL_LOCK_MGR_COOKIE_W    L"StiLockMgr"
#define REGSTR_PATH_STICONTROL_DEVLIST_W L"System\\CurrentControlSet\\Control\\StillImage\\DevList"
#define REGSTR_PATH_WIA_MSCDEVICES_W    L"System\\CurrentControlSet\\Control\\StillImage\\MSCDeviceList"

#define REGSTR_PATH_STICONTROL_A        "System\\CurrentControlSet\\Control\\StillImage"
#define REGSTR_PATH_STIDEVICES_A        "System\\CurrentControlSet\\Services\\Class"
#define REGSTR_PATH_STIDEVICES_NT_A     "System\\CurrentControlSet\\Control\\Class"
#define REGSTR_PATH_REG_APPS_A          "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\StillImage\\Registered Applications"
#define REGSTR_PATH_NT_ENUM_A           "System\\CurrentControlSet\\Enum"
#define REGSTR_PATH_EVENTS_A            "\\Events"
#define REGSTR_PATH_LOGGING_A           "\\Logging"
#define REGSTR_VAL_STIWIASVCDLL_A       "WiaServiceDll"
#define REGSTR_VAL_LOCK_MGR_COOKIE_A    "StiLockMgr"

#define REGSTR_PATH_SHAREDDLL       TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SharedDlls")
#define REGSTR_PATH_SOFT_STI        TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\StillImage")

//  FIX:  This should be moved to stireg.h
#define STI_DEVICE_VALUE_HOLDINGTIME_A      "LockHoldingTime"
#define STI_DEVICE_VALUE_HOLDINGTIME_W      L"LockHoldingTime"


#if defined(UNICODE)
#define REGSTR_PATH_EVENTS           REGSTR_PATH_EVENTS_W
#define REGSTR_PATH_STIDEVICES_NT    REGSTR_PATH_STIDEVICES_NT_W
#define REGSTR_PATH_STIDEVICES       REGSTR_PATH_STIDEVICES_W
#define REGSTR_PATH_STICONTROL       REGSTR_PATH_STICONTROL_W
#define REGSTR_PATH_LOGGING          REGSTR_PATH_LOGGING_W
#define REGSTR_VAL_STIWIASVCDLL      REGSTR_VAL_STIWIASVCDLL_W
#define REGSTR_PATH_REG_APPS         REGSTR_PATH_REG_APPS_W
#define REGSTR_VAL_LOCK_MGR_COOKIE   REGSTR_VAL_LOCK_MGR_COOKIE_W
#define STI_DEVICE_VALUE_HOLDINGTIME STI_DEVICE_VALUE_HOLDINGTIME_W

#else
#define REGSTR_PATH_EVENTS         REGSTR_PATH_EVENTS_A
#define REGSTR_PATH_STIDEVICES_NT  REGSTR_PATH_STIDEVICES_NT_A
#define REGSTR_PATH_STIDEVICES     REGSTR_PATH_STIDEVICES_A
#define REGSTR_PATH_STICONTROL     REGSTR_PATH_STICONTROL_A
#define REGSTR_PATH_LOGGING        REGSTR_PATH_LOGGING_A
#define REGSTR_VAL_STIWIASVCDLL    REGSTR_VAL_STIWIASVCDLL_A
#define REGSTR_PATH_REG_APPS       REGSTR_PATH_REG_APPS_A
#define REGSTR_VAL_LOCK_MGR_COOKIE REGSTR_VAL_LOCK_MGR_COOKIE_A
#define STI_DEVICE_VALUE_HOLDINGTIME STI_DEVICE_VALUE_HOLDINGTIME_A

#endif

//
// Registry keys and values
//
#define REGSTR_VAL_DEVICEPORT_W      L"CreateFileName"
#define REGSTR_VAL_USD_CLASS_W       L"USDClass"
#define REGSTR_VAL_USD_CLASS_A       "USDClass"
#define REGSTR_VAL_DEV_NAME_W        L"DeviceName"
#define REGSTR_VAL_DRIVER_DESC_W     L"DriverDesc"
#define REGSTR_VAL_FRIENDLY_NAME_W   L"FriendlyName"
#define REGSTR_VAL_FRIENDLY_NAME     TEXT("FriendlyName")
#define REGSTR_VAL_GENERIC_CAPS_W    L"Capabilities"
#define REGSTR_VAL_HARDWARE_W        L"HardwareConfig"
#define REGSTR_VAL_DEVICE_NAME_W     L"DriverDesc"
#define REGSTR_VAL_PROP_PROVIDER_W   L"PropertyPages"
#define REGSTR_VAL_DATA_W            L"DeviceData"
#define REGSTR_VAL_SUBCLASS_W        L"SubClass"
#define REGSTR_VAL_SUBCLASS           TEXT("SubClass")
#define REGSTR_VAL_LAUNCH_APPS_W     L"LaunchApplications"
#define REGSTR_VAL_LAUNCH_APPS        TEXT("LaunchApplications")
#define REGSTR_VAL_LAUNCHABLE_W      L"Launchable"
#define REGSTR_VAL_LAUNCHABLE         TEXT("Launchable")
#define REGSTR_VAL_LOG_LEVEL          TEXT("Level")
#define REGSTR_VAL_LOG_MODE           TEXT("Mode")
#define REGSTR_VAL_LOG_MAXSIZE        TEXT("MaxSize")
#define REGSTR_VAL_LOG_TRUNCATE_ON_BOOT TEXT("TruncateOnBoot")
#define REGSTR_VAL_LOG_DETAIL         TEXT("Detail")
#define REGSTR_VAL_LOG_CLEARLOG_ON_BOOT TEXT("ClearLogOnBoot")
#define REGSTR_VAL_LOG_TO_DEBUGGER  TEXT("LogToDebugger")
#define REGSTR_VAL_INFPATH          TEXT("InfPath")
#define REGSTR_VAL_INFSECTION       TEXT("InfSection")
#define REGSTR_VAL_ISPNP            TEXT("IsPnP")
#define REGSTR_VAL_MONITOR          TEXT("StillImageMonitor")
#define REGSTR_VAL_WIA_PRESENT      TEXT("WIADevicePresent")
#define REGSTR_VAL_MAX_LOCK_WAIT_TIME  TEXT("MaxLockWaitTime")
#define REGSTR_VAL_ENABLE_VOLUMES_W   L"EnableVolumeDevices"
#define REGSTR_VAL_MAKE_VOLUMES_VISIBLE_W L"MakeVolumeDevicesVisible"
#define REGSTR_VAL_WIA_EVENT_DEVICE_CONNECTED   L"{a28bbade-64b6-11d2-a231-00c04fa31809}";
#define REGSTR_VAL_QUERYDEVICEFORNAME   TEXT("QueryDeviceForName")  // used by PTP driver to determine if it should ask the device for its model name

//
// Still Image Class Name defines
//

#define CLASSNAME                    TEXT("Image")
#define STILLIMAGE                   TEXT("StillImage")

// #define CLASSNAME                 "Image"              <- Original
#define CLASSNAME_W                  L"Image"
//#define STILLIMAGE                    "StillImage"      <- Original
#define STILLIMAGE_W                 L"StillImage"



//
// Event logging
//
#define REGSTR_VAL_EVENT_LOG_DIRECTORY_A   "EventLogDirectory"


#define REGSTR_VAL_DEBUG_FLAGS_W     L"DebugFlags"
#define REGSTR_VAL_DEBUG_FILE_W      L"DebugLogFile"
#define REGSTR_VAL_DEBUG_STIMONUI_W  L"DebugStiMonUI"
#define REGSTR_VAL_DEBUG_STIMONUIWIN_W  L"StiMonUIWin"
#define REGVAL_STR_STIMON_DEBUGMASK_W L"StiMonDebugMask"
#define REGSTR_VAL_MIGRATE_STI_W        L"MigrateSTIApps"

#define REGSTR_VAL_DEBUG_FLAGS_A     "DebugFlags"
#define REGSTR_VAL_DEBUG_FILE_A      "DebugLogFile"
#define REGSTR_VAL_DEBUG_STIMONUI_A  "DebugStiMonUI"
#define REGSTR_VAL_DEBUG_STIMONUIWIN_A  "StiMonUIWin"
#define REGVAL_STR_STIMON_DEBUGMASK_A "StiMonDebugMask"
#define REGSTR_VAL_MIGRATE_STI_A        "MigrateSTIApps"

#if defined(UNICODE)

#define REGSTR_VAL_USD_CLASS         REGSTR_VAL_USD_CLASS_W
#define REGSTR_VAL_DEBUG_FLAGS       REGSTR_VAL_DEBUG_FLAGS_W
#define REGSTR_VAL_DEBUG_FILE        REGSTR_VAL_DEBUG_FILE_W
#define REGSTR_VAL_DEBUG_STIMONUI    REGSTR_VAL_DEBUG_STIMONUI_W
#define REGSTR_VAL_DEBUG_STIMONUIWIN REGSTR_VAL_DEBUG_STIMONUIWIN_W
#define REGVAL_STR_STIMON_DEBUGMASK  REGVAL_STR_STIMON_DEBUGMASK_W
#define REGSTR_VAL_MIGRATE_STI       REGSTR_VAL_MIGRATE_STI_W

#else

#define REGSTR_VAL_USD_CLASS         REGSTR_VAL_USD_CLASS_A
#define REGSTR_VAL_DEBUG_FLAGS       REGSTR_VAL_DEBUG_FLAGS_A
#define REGSTR_VAL_DEBUG_FILE        REGSTR_VAL_DEBUG_FILE_A
#define REGSTR_VAL_DEBUG_STIMONUI    REGSTR_VAL_DEBUG_STIMONUI_A
#define REGSTR_VAL_DEBUG_STIMONUIWIN REGSTR_VAL_DEBUG_STIMONUIWIN_A
#define REGVAL_STR_STIMON_DEBUGMASK  REGVAL_STR_STIMON_DEBUGMASK_A
#define REGSTR_VAL_MIGRATE_STI       REGSTR_VAL_MIGRATE_STI_A

#endif


#endif // _STIREGI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\stisvc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    svcinfo.h

Abstract:

Author:

    Vlad Sadovsky (vlads)   22-Sep-1997


Environment:

    User Mode - Win32

Revision History:

    22-Sep-1997     VladS       created

--*/


# ifndef _STISVC_H_
# define _STISVC_H_

//
// Service name.  Note:  Some strings are filename dependant, and must be
// updated if the filenames change.
//
#define STI_SERVICE_NAME        TEXT("StiSvc")
#define STI_DISPLAY_NAME        TEXT("Windows Image Acquisition (WIA)")
#define STI_IMAGE_NAME          TEXT("%systemroot%\\system32\\stisvc.exe")
#define STI_IMAGE_NAME_SVCHOST  TEXT("%SystemRoot%\\system32\\svchost.exe -k imgsvc")
#define STI_IMGSVC              TEXT("imgsvc")
#define REGSTR_SERVICEDLL       TEXT("ServiceDll")
#define STI_SERVICE__DATA       0x19732305
#define STI_SVC_HOST            REGSTR_PATH_NT_CURRENTVERSION TEXT("\\svchost")
#define STI_SERVICE_PARAMS      REGSTR_PATH_SERVICES TEXT("\\") STI_SERVICE_NAME TEXT("\\Parameters")
#define STI_SVC_DEPENDENCIES    TEXT("RpcSs\0\0")

#ifdef WINNT
    #define SYSTEM_PATH         TEXT("%SystemRoot%\\system32\\")
    #define PATH_REG_TYPE       REG_EXPAND_SZ
    #define SERVICE_FILE_NAME   TEXT("svchost.exe")
#else
    #define SYSTEM_PATH         TEXT("\\system\\")
    #define PATH_REG_TYPE       REG_SZ
    #define SERVICE_FILE_NAME   TEXT("stimon.exe")
#endif



//
// SCM parameters
//
#define START_HINT  4000
#define PAUSE_HINT  2000

#define STI_STOP_FOR_REMOVE_TIMEOUT 1000

//
// STI API specific access rights
//

//#define STI_SVC_SERVICE_TYPE    (SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS)
#define STI_SVC_SERVICE_TYPE    (SERVICE_WIN32_SHARE_PROCESS | SERVICE_INTERACTIVE_PROCESS)


#define STI_QUERY_SECURITY              0x0001
#define STI_SET_SECURITY                0x0002
#define STI_QUERY_STATISTICS            0x0004
#define STI_CLEAR_STATISTICS            0x0008
#define STI_QUERY_ADMIN_INFORMATION     0x0010
#define STI_SET_ADMIN_INFORMATION       0x0020

#define STI_ALL_ACCESS         (STANDARD_RIGHTS_REQUIRED       | \
                                 SYNCHRONIZE                   | \
                                 STI_QUERY_SECURITY            | \
                                 STI_SET_SECURITY              | \
                                 STI_QUERY_STATISTICS          | \
                                 STI_CLEAR_STATISTICS          | \
                                 STI_QUERY_ADMIN_INFORMATION   | \
                                 STI_SET_ADMIN_INFORMATION       \
                                )

#define STI_GENERIC_READ       (STANDARD_RIGHTS_READ           | \
                                 STI_QUERY_SECURITY            | \
                                 STI_QUERY_ADMIN_INFORMATION   | \
                                 STI_QUERY_STATISTICS)

#define STI_GENERIC_WRITE      (STANDARD_RIGHTS_WRITE          | \
                                 STI_SET_SECURITY              | \
                                 STI_SET_ADMIN_INFORMATION     | \
                                 STI_CLEAR_STATISTICS)

#define STI_GENERIC_EXECUTE    (STANDARD_RIGHTS_EXECUTE)

#define STI_SERVICE_CONTROL_BEGIN           128
#define STI_SERVICE_CONTROL_REFRESH         STI_SERVICE_CONTROL_BEGIN
#define STI_SERVICE_CONTROL_LPTENUM         STI_SERVICE_CONTROL_BEGIN+1
#define STI_SERVICE_CONTROL_EVENT_REREAD    STI_SERVICE_CONTROL_BEGIN+2
#define STI_SERVICE_CONTROL_END             STI_SERVICE_CONTROL_BEGIN+2

#endif // _STISVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\stiusd.h ===
/*++

Copyright (c) 1986-1997  Microsoft Corporation

Module Name:

    stiusd.h

Abstract:

    Definitions file for creating STI User-mode Still-image Drivers ( USD).

Author:


Revision History:


--*/

#ifndef _STIUSD_
#define _STIUSD_

// Include COM definitions
#define COM_NO_WINDOWS_H

//
#pragma intrinsic(memcmp,memset)

//
// Include COM definitions
//
#ifndef _NO_COM
#include <objbase.h>
#endif

#include <stireg.h>
#include <stierr.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Class IID's
 */


/*
 * Interface IID's
 */
#if defined( _WIN32 ) && !defined( _NO_COM)

// {0C9BB460-51AC-11D0-90EA-00AA0060F86C}
DEFINE_GUID(IID_IStiUSD, 0x0C9BB460L, 0x51AC, 0x11D0, 0x90, 0xEA, 0x00, 0xAA, 0x00, 0x60, 0xF8, 0x6C);

// {128A9860-52DC-11D0-9EDF-444553540000}
DEFINE_GUID(IID_IStiDeviceControl, 0x128A9860L, 0x52DC, 0x11D0, 0x9E, 0xDF, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);

#endif

/*
 * Data structures
 */

typedef struct _STI_USD_CAPS {

    DWORD   dwVersion;          // STI version used to build this USD

    DWORD   dwGenericCaps;

} STI_USD_CAPS,*PSTI_USD_CAPS;


//
// Claims to support device notifications asyncronously ( without polling)
//
#define STI_USD_GENCAP_NATIVE_PUSHSUPPORT STI_GENCAP_NOTIFICATIONS

//
// Asks to open device automatically ( not implemented now)
//
// #define STI_USD_GENCAP_OPEN_DEVICE_FOR_ME 0x00000002

typedef DWORD   USD_CONTROL_CODE;

/*
 * Generic constants and definitions
 */

//
// Internally used flags for open device mode.

// USD receives this  bit only when associated device instance is created by monitor process
//
#define STI_DEVICE_CREATE_FOR_MONITOR   0x01000000


#ifdef __cplusplus

struct IStiUSD;
struct IStiDeviceControl;

#endif

typedef struct IStiUSD             *PSTIUSD;
typedef struct IStiDeviceControl   *PSTIDEVICECONTROL;


/*
 * IStiDeviceControl interface
 *
 * Instance of object supporting this interface is passed to USD at the moment
 * of device object initialization.
 */
#undef INTERFACE
#define INTERFACE IStiDeviceControl
DECLARE_INTERFACE_(IStiDeviceControl, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    /*** IStiDeviceControl methods ***/
    STDMETHOD(Initialize) (THIS_ DWORD dwDeviceType,DWORD dwMode,LPCWSTR pwszPortName,DWORD dwFlags )PURE;
    STDMETHOD(RawReadData)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawWriteData)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawReadCommand)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawWriteCommand)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawDeviceControl)(THIS_ USD_CONTROL_CODE EscapeFunction,LPVOID  lpInData,DWORD   cbInDataSize,LPVOID pOutData,DWORD dwOutDataSize,LPDWORD pdwActualData) PURE ;
    STDMETHOD(GetLastError)(THIS_ LPDWORD     lpdwLastError) PURE;
    STDMETHOD(GetMyDevicePortName)(THIS_ LPWSTR lpszDevicePath,DWORD cwDevicePathSize ) PURE;
    STDMETHOD(GetMyDeviceHandle)(THIS_ LPHANDLE lph) PURE;
    STDMETHOD(GetMyDeviceOpenMode)(THIS_ LPDWORD pdwOpenMode ) PURE;
    STDMETHOD(WriteToErrorLog)(THIS_ DWORD dwMessageType,LPCWSTR pszMessage,DWORD dwErrorCode) PURE;
} ;

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IStiDeviceControl_QueryInterface(p,a,b)    (p)->lpVtbl->QueryInterface(p,a,b)
#define IStiDeviceControl_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IStiDeviceControl_Release(p)               (p)->lpVtbl->Release(p)
#define IStiDeviceControl_Initialize(p,a,b,c,d)    (p)->lpVtbl->Initialize(p,a,b,c,d)

#define IStiDeviceControl_RawReadData(p,a,b,c)     (p)->lpVtbl->RawReadData(p,a,b,c)
#define IStiDeviceControl_RawWriteData(p,a,b,c)    (p)->lpVtbl->RawWriteData(p,a,b,c)
#define IStiDeviceControl_RawReadCommand(p,a,b,c)  (p)->lpVtbl->RawReadCommand(p,a,b,c)
#define IStiDeviceControl_RawWriteCommand(p,a,b,c) (p)->lpVtbl->RawWriteCommand(p,a,b,c)
#define IStiDeviceControl_RawDeviceControl(p,a,b,c,d,e,f)   (p)->lpVtbl->RawDeviceControl(p,a,b,c,d,e,f)
#define IStiDeviceControl_GetLastError(p,a)        (p)->lpVtbl->GetLastError(p,a)
#define IStiDeviceControl_GetMyDevicePortName(p,a,b) (p)->lpVtbl->GetMyDevicePortName(p,a,b)
#define IStiDeviceControl_GetMyDeviceHandle(p,a)    (p)->lpVtbl->GetMyDeviceHandle(p,a)
#define IStiDeviceControl_GetMyDeviceOpenMode(p,a)  (p)->lpVtbl->GetMyDeviceOpenMode(p,a)
#define IStiDeviceControl_WriteToErrorLog(p,a,b,c)  (p)->lpVtbl->WriteToErrorLog(p,a,b,c)

#endif

/*
 * IStiUSD interface
 */
#undef INTERFACE
#define INTERFACE IStiUSD
DECLARE_INTERFACE_(IStiUSD, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    /*** IStiUSD methods ***/
    STDMETHOD(Initialize) (THIS_ PSTIDEVICECONTROL pHelDcb,DWORD dwStiVersion,HKEY hParametersKey) PURE;
    STDMETHOD(GetCapabilities) (THIS_ PSTI_USD_CAPS pDevCaps) PURE;
    STDMETHOD(GetStatus) (THIS_ PSTI_DEVICE_STATUS pDevStatus) PURE;
    STDMETHOD(DeviceReset)(THIS ) PURE;
    STDMETHOD(Diagnostic)(THIS_ LPSTI_DIAG pBuffer) PURE;
    STDMETHOD(Escape)(THIS_ STI_RAW_CONTROL_CODE    EscapeFunction,LPVOID  lpInData,DWORD   cbInDataSize,LPVOID pOutData,DWORD dwOutDataSize,LPDWORD pdwActualData) PURE ;
    STDMETHOD(GetLastError) (THIS_ LPDWORD pdwLastDeviceError) PURE;
    STDMETHOD(LockDevice) (THIS ) PURE;
    STDMETHOD(UnLockDevice) (THIS ) PURE;
    STDMETHOD(RawReadData)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawWriteData)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawReadCommand)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawWriteCommand)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(SetNotificationHandle)(THIS_ HANDLE hEvent) PURE;
    STDMETHOD(GetNotificationData)(THIS_ LPSTINOTIFY   lpNotify) PURE;
    STDMETHOD(GetLastErrorInfo) (THIS_ STI_ERROR_INFO *pLastErrorInfo) PURE;
} ;

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IStiUSD_QueryInterface(p,a,b)    (p)->lpVtbl->QueryInterface(p,a,b)
#define IStiUSD_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IStiUSD_Release(p)               (p)->lpVtbl->Release(p)
#define IStiUSD_Initialize(p,a,b,c)      (p)->lpVtbl->Initialize(p,a,b,c)
#define IStiUSD_GetCapabilities(p,a)     (p)->lpVtbl->GetCapabilities(p,a)
#define IStiUSD_GetStatus(p,a)           (p)->lpVtbl->GetStatus(p,a)
#define IStiUSD_DeviceReset(p)           (p)->lpVtbl->DeviceReset(p)
#define IStiUSD_Diagnostic(p,a)          (p)->lpVtbl->Diagnostic(p,a)
#define IStiUSD_Escape(p,a,b,c,d,e,f)    (p)->lpVtbl->Escape(p,a,b,c,d,e,f)
#define IStiUSD_GetLastError(p,a)        (p)->lpVtbl->GetLastError(p,a)
#define IStiUSD_LockDevice(p)            (p)->lpVtbl->LockDevice(p)
#define IStiUSD_UnLockDevice(p)          (p)->lpVtbl->UnLockDevice(p)
#define IStiUSD_RawReadData(p,a,b,c)     (p)->lpVtbl->RawReadData(p,a,b,c)
#define IStiUSD_RawWriteData(p,a,b,c)    (p)->lpVtbl->RawWriteData(p,a,b,c)
#define IStiUSD_RawReadCommand(p,a,b,c)  (p)->lpVtbl->RawReadCommand(p,a,b,c)
#define IStiUSD_RawWriteCommand(p,a,b,c) (p)->lpVtbl->RawWriteCommand(p,a,b,c)
#define IStiUSD_SetNotificationHandle(p,a) (p)->lpVtbl->SetNotificationHandle(p,a)
#define IStiUSD_GetNotificationData(p,a) (p)->lpVtbl->GetNotificationData(p,a)
#define IStiUSD_GetLastErrorInfo(p,a)    (p)->lpVtbl->GetLastErrorInfo(p,a)

#endif

#ifdef __cplusplus
};
#endif

#endif // _STIUSD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\stistr.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stistr.h

Abstract:

    Lightweight string classes: definition.
    Supports both UNICODE and single-byte character strings

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997
        (Lifted from another C++ project with some modifications and adjustments)

Revision History:

    26-Jan-1997     VladS       created
    20-Apr-1999     VladS       redesigned to inherit from ATL Cstring class

--*/


#ifndef _STRING_H_
#define _STRING_H_

#ifndef USE_OLD_STI_STRINGS

class StiCString : public CString
{

friend class RegEntry;

public:
    StiCString()
    {
        CString::CString();
    }

    ~StiCString()
    {
    }

    VOID
    CopyString(LPCTSTR  lpszT)
    {
        AssignCopy(lstrlen(lpszT),lpszT);
    }
};

class STRArray : public CSimpleArray<StiCString *>
{

public:

    STRArray()
    {

    }

    ~STRArray()
    {
        // Free all allocated strings
        for(int i = 0; i < m_nSize; i++)
        {
            if(m_aT[i] != NULL) {
                delete m_aT[i];
                m_aT[i] = NULL;
            }
        }
    }

    BOOL
    Add(
        LPCTSTR lpszT
        )
    {
        StiCString  *pNew;

        pNew = new StiCString;

        if (pNew) {
            pNew->CopyString(lpszT);
            return Add(pNew);
        }

        return FALSE;
    }


    BOOL
    Add(
        StiCString* pstr
        )
    {
        StiCString  *pNew;

        pNew = new StiCString;

        if (pNew) {
            *pNew = *pstr;
            return CSimpleArray<StiCString *>::Add(pNew);
        }

        return FALSE;
    }


};

VOID
TokenizeIntoStringArray(
    STRArray&   array,
    LPCTSTR lpstrIn,
    TCHAR tcSplitter
    );


#else

//
//
//


# include <buffer.h>


//
//  Maximum number of characters a loadable string resource can be
//

# define STR_MAX_RES_SIZE            ( 260)



class STR;

//
//  If an application defines STR_MODULE_NAME, it will be used
//  as the default module name on string loads
//

#ifndef STR_MODULE_NAME
#define STR_MODULE_NAME   NULL
#endif

//
//  These are the characters that are considered to be white space
//
#define ISWHITE( ch )       ((ch) == L'\t' || (ch) == L' ' || (ch) == L'\r')
#define ISWHITEA( ch )      ((ch) == '\t' || (ch) == ' ' || (ch) == '\r')


class STR : public BUFFER
{

friend class RegEntry;

public:

    STR()
    {
        _fUnicode = FALSE;
        _fValid   = TRUE;
    }

     STR( const CHAR  * pchInit );
     STR( const WCHAR * pwchInit );
     STR( const STR & str );
     //STR( UINT dwSize );

     BOOL Append( const CHAR  * pchInit );
     BOOL Append( const WCHAR * pwchInit );
     BOOL Append( const STR   & str );

     BOOL Copy( const CHAR  * pchInit );
     BOOL Copy( const WCHAR * pwchInit );
     BOOL Copy( const STR   & str );

     BOOL Resize( UINT cbNewReqestedSize );

    //
    //  Loads a string from this module's string resource table
    //

     BOOL LoadString( IN DWORD   dwResID,IN LPCTSTR lpszModuleName = STR_MODULE_NAME);
     BOOL LoadString( IN DWORD   dwResID,IN HMODULE hModule);

    //
    //  Loads a string with insert params from this module's .mc resource
    //  table.  Pass zero for the resource ID to use *this.
    //

    BOOL FormatStringV(
    IN LPCTSTR lpszModuleName,
    ...
    );

     BOOL FormatString( IN DWORD   dwResID,
                              IN LPCTSTR apszInsertParams[],
                              IN LPCTSTR lpszModuleName = STR_MODULE_NAME);

    //
    //  Returns the number of bytes in the string excluding the terminating
    //  NULL
    //
     UINT QueryCB( VOID ) const
        { return IsUnicode() ? ::wcslen((WCHAR *)QueryStrW()) * sizeof(WCHAR) :
                               ::strlen((CHAR *) QueryStrA());  }

    //
    //  Returns the number of characters in the string excluding the terminating
    //  NULL
    //
     UINT QueryCCH( VOID ) const
        { return IsUnicode() ? ::wcslen((WCHAR *)QueryStrW()) :
                               ::strlen((CHAR *) QueryStrA());  }

    //
    // Makes a Widechar copy of the stored string in given buffer
    //
     BOOL CopyToBuffer( WCHAR * lpszBuffer, LPDWORD lpcch) const;

    //
    // Makes a schar copy of the stored string in given buffer
    //
     BOOL CopyToBufferA( CHAR * lpszBuffer, LPDWORD lpcch) const;

    //
    // In-place conversion
    //
    BOOL ConvertToW(VOID);
    BOOL ConvertToA(VOID);

    //
    //  If the string buffer is empty, returns the empty string, otherwise
    //  returns a pointer to the buffer
    //
#if 1
     CHAR * QueryStrA( VOID ) const;
     WCHAR * QueryStrW( VOID ) const;
#else
    //
    // _pszEmptyString doesn't get imported corectly, results in unresolved
    // externals
    //
     CHAR * QueryStrA( VOID ) const
        { return (QueryPtr() ? (CHAR *) QueryPtr() : (CHAR *) _pszEmptyString); }

     WCHAR * QueryStrW( VOID ) const
        { return (QueryPtr() ? (WCHAR *) QueryPtr() : (WCHAR *) _pszEmptyString); }
#endif //!DBG


#ifdef UNICODE
     WCHAR * QueryStr( VOID ) const
        { return QueryStrW(); }
#else
     CHAR * QueryStr( VOID ) const
        { return QueryStrA(); }
#endif

     BOOL IsUnicode( VOID ) const
        { return _fUnicode; }

     VOID SetUnicode( BOOL fUnicode )
        { _fUnicode = fUnicode; }

     BOOL IsValid( VOID ) const
        { return _fValid; }

    //
    //  Checks and returns TRUE if this string has no valid data else FALSE
    //
     BOOL IsEmpty( VOID) const
         {    //return ( *QueryStr() == '\0'); }
                 if (!QuerySize()  || !QueryPtr()) {
                         return TRUE;
                 }
                 LPBYTE pb = (BYTE *)QueryPtr();

                 return (_fUnicode) ?
                         ((WCHAR)*pb==L'\0') : ((CHAR)*pb=='\0') ;
         }


    //
    //  Makes a clone of the current string in the string pointer passed in.
    //
     BOOL
      Clone( OUT STR * pstrClone) const
        {
            if ( pstrClone == NULL) {
               SetLastError( ERROR_INVALID_PARAMETER);
               return ( FALSE);
            } else {

                return ( pstrClone->Copy( *this));
            }
        } // STR::Clone()

    //
    // Useful operators
    //

    operator const TCHAR *() const { return QueryStr(); }

    const inline STR&  operator =(LPCSTR lpstr) { Copy(lpstr); return  *this; }
    const inline STR&  operator =(LPCWSTR lpwstr) { Copy(lpwstr); return  *this; }
    const inline STR&  operator =(STR& cs) { Copy(cs);return  *this;  }


    const inline STR&  operator +=(LPCSTR lpstr) { Append(lpstr);return  *this;  }
    const inline STR&  operator +=(LPCWSTR lpwstr) { Append(lpwstr);return  *this;  }
    const inline STR&  operator +=(STR& cs) { Append(cs);return  *this;  }


private:


    //
    //  TRUE if the string has already been mapped to Unicode
    //  FALSE if the string is in Latin1
    //

    BOOL  _fUnicode;
    BOOL  _fValid;

    //
    //  Returned when our buffer is empty
    //
     static WCHAR _pszEmptyString[];

    VOID AuxInit( PBYTE pInit, BOOL fUnicode );
    BOOL AuxAppend( PBYTE pInit, UINT cbStr, BOOL fAddSlop = TRUE );

};

class STRArray {
    STR     *m_pcsContents, m_csEmpty;
    unsigned    m_ucItems, m_ucMax, m_uGrowBy;

    void    Grow();

public:

    STRArray(UINT uGrowBy = 10);
    ~STRArray();

    UINT    Count() const { return m_ucItems; }

    void    Add(LPCSTR lpstrNew);
    void    Add(LPCWSTR lpstrNew);

    STR&    operator[](UINT u) {
        return  u < m_ucItems ? m_pcsContents[u] : m_csEmpty;
    }

    void    Tokenize(LPCTSTR lpstrIn, TCHAR tcSplitter);
};

#endif

#endif // !_STRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\svcinfo.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    svcinfo.h

Abstract:

Author:

    Vlad Sadovsky (vlads)   22-Sep-1997


Environment:

    User Mode - Win32

Revision History:

    22-Sep-1997     VladS       created

--*/


# ifndef _SVCINFO_H_
# define _SVCINFO_H_

/************************************************************
 *     Include Headers
 ************************************************************/

#include <base.h>

/***********************************************************
 *    Named constants  definitions
 ************************************************************/

/************************************************************
 *    Private Constants
 ************************************************************/

#define NULL_SERVICE_STATUS_HANDLE      ( (SERVICE_STATUS_HANDLE ) NULL)
#define SERVICE_START_WAIT_HINT         ( 10000)        // milliseconds
#define SERVICE_STOP_WAIT_HINT          ( 10000)        // milliseconds

#ifndef DLLEXP
//#define DLLEXP __declspec( dllexport )
#define DLLEXP
#endif


/************************************************************
 *   Type Definitions
 ************************************************************/

#define SIGNATURE_SVC      (DWORD)'SVCa'
#define SIGNATURE_SVC_FREE (DWORD)'SVCf'

//
// These functions get called back with the pointer to SvcInfo object
// as the context parameter.
//
typedef   DWORD ( *PFN_SERVICE_SPECIFIC_INITIALIZE) ( LPVOID pContext);

typedef   DWORD ( *PFN_SERVICE_SPECIFIC_CLEANUP)    ( LPVOID pContext);

typedef   DWORD ( *PFN_SERVICE_SPECIFIC_PNPPWRHANDLER) ( LPVOID pContext,UINT   msg,WPARAM wParam,LPARAM lParam);

typedef   VOID  ( *PFN_SERVICE_CTRL_HANDLER)        ( DWORD  OpCode);

class  SVC_INFO : public BASE  {

    private:

      DWORD       m_dwSignature;

      SERVICE_STATUS          m_svcStatus;
      SERVICE_STATUS_HANDLE   m_hsvcStatus;
      HANDLE                  m_hShutdownEvent;

      STR       m_sServiceName;
      STR       m_sModuleName;

      //
      //  Call back functions for service specific data/function
      //

      PFN_SERVICE_SPECIFIC_INITIALIZE m_pfnInitialize;
      PFN_SERVICE_SPECIFIC_CLEANUP    m_pfnCleanup;
      PFN_SERVICE_SPECIFIC_PNPPWRHANDLER m_pfnPnpPower;

      DWORD ReportServiceStatus( VOID);
      VOID  InterrogateService( VOID );
      VOID  StopService( VOID );
      VOID  PauseService( VOID );
      VOID  ContinueService( VOID );
      VOID  ShutdownService( VOID );

  public:

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    //
    //  Initialization/Termination related methods
    //


    SVC_INFO(
        IN  LPCTSTR                          lpszServiceName,
        IN  TCHAR  *                         lpszModuleName,
        IN  PFN_SERVICE_SPECIFIC_INITIALIZE  pfnInitialize,
        IN  PFN_SERVICE_SPECIFIC_CLEANUP     pfnCleanup,
        IN  PFN_SERVICE_SPECIFIC_PNPPWRHANDLER pfnPnpPower
        );

      ~SVC_INFO( VOID);


    BOOL IsValid(VOID) const
    {
        return (( QueryError() == NO_ERROR) && (m_dwSignature == SIGNATURE_SVC));
    }

    DWORD QueryCurrentServiceState( VOID) const
    {
        return ( m_svcStatus.dwCurrentState);
    }

    //
    //  Parameter access methods.
    //


    //
    //  Service control related methods
    //

    LPCTSTR QueryServiceName(VOID) const
    {
        return m_sServiceName.QueryStr();
    }

    DWORD
    QueryServiceSpecificExitCode( VOID) const
    {
        return ( m_svcStatus.dwServiceSpecificExitCode);
    }

    VOID
    SetServiceSpecificExitCode( DWORD err)
    {
        m_svcStatus.dwServiceSpecificExitCode = err;
    }

    DWORD
    DelayCurrentServiceCtrlOperation( IN DWORD dwWaitHint)
    {
        return
          UpdateServiceStatus(m_svcStatus.dwCurrentState,
                              m_svcStatus.dwWin32ExitCode,
                              m_svcStatus.dwCheckPoint,
                              dwWaitHint);
    }

    DWORD
    UpdateServiceStatus(IN DWORD State,
                          IN DWORD Win32ExitCode,
                          IN DWORD CheckPoint,
                          IN DWORD WaitHint );

    VOID
    ServiceCtrlHandler( IN DWORD dwOpCode);

    DWORD
    StartServiceOperation(
        IN  PFN_SERVICE_CTRL_HANDLER         pfnCtrlHandler
        );


    //
    //  Miscellaneous methods
    //

};  // class SVC_INFO

typedef SVC_INFO * PSVC_INFO;


/************************************************************
 *    Macros
 ************************************************************/


//
//
//  Use the following macro once in outer scope of the file
//  where we construct the global SvcInfo object.
//
//  Every client of SvcInfo should define the following macro
//  passing as parameter their global pointer to SvcInfo object
//  This is required to generate certain stub functions, since
//  the service controller call-back functions do not return
//  the context information.
//
//  Also we define the global g_pSvcInfo variable and
//  a static variable gs_pfnSch,which is a pointer to the local service control handler function.
//

# define   _INTERNAL_DEFINE_SVCINFO_INTERFACE( pSvcInfo)   \
                                                    \
    static  VOID ServiceCtrlHandler( DWORD OpCode)  \
        {                                           \
            ( pSvcInfo)->ServiceCtrlHandler( OpCode); \
        }                                           \
                                                    \
    static PFN_SERVICE_CTRL_HANDLER gs_pfnSch = ServiceCtrlHandler;

//
// Since all the services should use the global variable called g_pSvcInfo
// this is a convenience macro for defining the interface for services
// structure
//
# define DEFINE_SVC_INFO_INTERFACE()   \
        PSVC_INFO         g_pSvcInfo;                \
        _INTERNAL_DEFINE_SVCINFO_INTERFACE( g_pSvcInfo);

//
//  Use the macro SERVICE_CTRL_HANDLER() to pass the parameter for
//  service control handler when we initialize the SvcInfo object
//
# define   SERVICE_CTRL_HANDLER()       ( gs_pfnSch)

# endif // _SVCINFO_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\usbscan.h ===
/*++

Copyright (C) 1997, Logitech Inc.

Module Name:
    UsbScan.h

Abstract:
    Interface with UsbScan kernel driver

Environment:
    User and kernel mode use

Notes:
    Interface definition for USB still image driver.

--*/

#ifndef _USBSCAN_H_
#define _USBSCAN_H_

#ifndef MAX_NUM_PIPES
 #define MAX_NUM_PIPES   8
#endif

#define BULKIN_FLAG 0x80

typedef struct _DRV_VERSION {
    OUT     unsigned    major;
    OUT     unsigned    minor;
    OUT     unsigned    internal;
} DRV_VERSION, *PDRV_VERSION;

typedef struct _IO_BLOCK {
    IN      unsigned    uOffset;
    IN      unsigned    uLength;
    IN OUT  PUCHAR      pbyData;
    IN      unsigned    uIndex;
} IO_BLOCK, *PIO_BLOCK;

typedef struct _IO_BLOCK_EX {
    IN      unsigned    uOffset;
    IN      unsigned    uLength;
    IN OUT  PUCHAR      pbyData;
    IN      unsigned    uIndex;

    //
    // Following two fields are described in sec. 9.3.1,2 USB specification
    //
    IN      UCHAR       bRequest;               // Specific request
    IN      UCHAR       bmRequestType;          // Bitmap - charateristics of request
    IN      UCHAR       fTransferDirectionIn;   // TRUE - Device-->Host; FALSE - Host-->Device

} IO_BLOCK_EX, *PIO_BLOCK_EX;


typedef struct _CHANNEL_INFO {
    OUT     unsigned    EventChannelSize;
    OUT     unsigned    uReadDataAlignment;
    OUT     unsigned    uWriteDataAlignment;
} CHANNEL_INFO, *PCHANNEL_INFO;

typedef enum {
    EVENT_PIPE,
    READ_DATA_PIPE,
    WRITE_DATA_PIPE,
    ALL_PIPE
} PIPE_TYPE;


typedef struct _USBSCAN_GET_DESCRIPTOR {
    IN      UCHAR   DescriptorType;             // high byte of wValue field in USB spec.
    IN      UCHAR   Index;                      // low byte of wValue field in USB spec.
    IN      USHORT  LanguageId;                 // wIndex field in USB spec.
} USBSCAN_GET_DESCRIPTOR, *PUSBSCAN_GET_DESCRIPTOR;


//
// The device descriptor structure reports information define in the hardware.
// If there is enough space to copy the strings, it will be done otherwise
// only the three first fields:
//
//   USHORT usVendorId;
//   USHORT usProductId;
//   USHORT usBcdDevice;
//
// will contain valid data.  Remember: The strings are UNICODE format.
//

typedef struct _DEVICE_DESCRIPTOR {
    OUT     USHORT   usVendorId;
    OUT     USHORT   usProductId;
    OUT     USHORT   usBcdDevice;
    OUT     USHORT   usLanguageId;
//    IN OUT  PWCHAR   pszManufacturer;
//    IN OUT  unsigned uManufacturerStrSize;
//    IN OUT  PWCHAR   pszProduct;
//    IN OUT  unsigned uProductStrSize;
//    IN OUT  PWCHAR   pszSerialNb;
//    IN OUT  unsigned uSerialNbStrSize;
} DEVICE_DESCRIPTOR, *PDEVICE_DESCRIPTOR;

typedef enum _RAW_PIPE_TYPE {
    USBSCAN_PIPE_CONTROL,
    USBSCAN_PIPE_ISOCHRONOUS,
    USBSCAN_PIPE_BULK,
    USBSCAN_PIPE_INTERRUPT
} RAW_PIPE_TYPE;

typedef struct _USBSCAN_PIPE_INFORMATION {
    USHORT          MaximumPacketSize;  // Maximum packet size for this pipe
    UCHAR           EndpointAddress;    // 8 bit USB endpoint address (includes direction)
    UCHAR           Interval;           // Polling interval in ms if interrupt pipe 
    RAW_PIPE_TYPE   PipeType;           // PipeType identifies type of transfer valid for this pipe
} USBSCAN_PIPE_INFORMATION, *PUSBSCAN_PIPE_INFORMATION;

typedef struct _USBSCAN_PIPE_CONFIGURATION {
    OUT     ULONG                          NumberOfPipes;
    OUT     USBSCAN_PIPE_INFORMATION       PipeInfo[MAX_NUM_PIPES];
} USBSCAN_PIPE_CONFIGURATION, *PUSBSCAN_PIPE_CONFIGURATION;

typedef struct _USBSCAN_TIMEOUT {
    ULONG           TimeoutRead;
    ULONG           TimeoutWrite;
    ULONG           TimeoutEvent;
} USBSCAN_TIMEOUT, *PUSBSCAN_TIMEOUT;


#define FILE_DEVICE_USB_SCAN    0x8000
#define IOCTL_INDEX             0x0800

#define IOCTL_GET_VERSION               CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX,   METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_CANCEL_IO                 CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+1, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_WAIT_ON_DEVICE_EVENT      CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+2, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_READ_REGISTERS            CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+3, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_WRITE_REGISTERS           CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+4, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_CHANNEL_ALIGN_RQST    CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+5, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_DEVICE_DESCRIPTOR     CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+6, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RESET_PIPE                CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+7, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_USB_DESCRIPTOR        CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+8, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SEND_USB_REQUEST          CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+9, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_PIPE_CONFIGURATION    CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+10,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SET_TIMEOUT               CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+11,METHOD_BUFFERED,FILE_ANY_ACCESS)

//
// Temporary to avoid breaking LOGISCAN code
//
#define ALL ALL_PIPE
#define IOCTL_ABORT_PIPE        IOCTL_CANCEL_IO
//
//
#endif // _USBSCAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\stitrace.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stitrace.h

Abstract:

    This file defines functions and types required to support file logging
    for all STI components
    

Author:

    Vlad Sadovsky (vlads)   02-Sep-1997


Environment:

    User Mode - Win32

Revision History:

    02-Sep-1997     VladS       created

--*/

# ifndef _STITRACE_H_
# define _STITRACE_H_

# include <windows.h>

#include <base.h>

/***********************************************************
 *    Named constants  definitions
 ************************************************************/

#define STI_TRACE_INFORMATION       0x0001
#define STI_TRACE_WARNING           0x0002
#define STI_TRACE_ERROR             0x0004

/***********************************************************
 *    Type Definitions
 ************************************************************/

class STI_FILE_LOG  : public BASE {

  private:

     LPCTSTR   m_lpszSource;    // Name of the file , containing log

  public:

     dllexp
     STI_FILE_LOG( IN LPCTSTR lpszSourceName);   // name of source for event log

     dllexp
    ~STI_FILE_LOG( VOID);

     dllexp
     VOID
     LogEvent(
        IN DWORD  idMessage,                  // id for log message
        IN WORD   cSubStrings,                // count of substrings
        IN const CHAR * apszSubStrings[],     // substrings in the message
        IN DWORD  errCode = 0);               // error code if any

     VOID
     LogEvent(
        IN DWORD  idMessage,                  // id for log message
        IN WORD   cSubStrings,                // count of substrings
        IN CHAR * apszSubStrings[],           // substrings in the message
        IN DWORD  errCode = 0)                // error code if any
    {
        LogEvent(idMessage, cSubStrings,
                 (const CHAR **) apszSubStrings, errCode);
    }

     dllexp
     VOID
     LogEvent(
        IN DWORD   idMessage,                  // id for log message
        IN WORD    cSubStrings,                // count of substrings
        IN WCHAR * apszSubStrings[],           // substrings in the message
        IN DWORD   errCode = 0);               // error code if any

     BOOL Success( VOID) const
     { return ( m_ErrorCode == NO_ERROR); }

     DWORD GetErrorCode( VOID) const
     { return ( m_ErrorCode); }

  private:

     dllexp VOID
     LogEventPrivate(
        IN DWORD idMessage,
        IN WORD  wEventType,
        IN WORD  cSubStrings,
        IN const CHAR * apszSubStrings[],
        IN DWORD  errCode);

};

typedef EVENT_LOG * LPEVENT_LOG;

# endif // _STITRACE_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\vcamprop.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       VCamProp.H
*
*  VERSION:     1.0
*
*  AUTHOR:      RickTu
*
*  DATE:        29 Sept, 1999
*
*  DESCRIPTION:
*   Definitions and declarations for DS Camera's private properties.
*
*******************************************************************************/

#ifndef __VCAMPROP_H__
#define __VCAMPROP_H__

#include  <guiddef.h>

//
// Private commands enabling WIA Video to respond to 
// TAKE_PICTURE commands sent to Video Driver.
//

const GUID WIA_CMD_ENABLE_TAKE_PICTURE =
{ /* 9bc87d4d-e949-44ce-866c-c6921302032d */
    0x9bc87d4d,
    0xe949,
    0x44ce,
    {0x86, 0x6c, 0xc6, 0x92, 0x13, 0x02, 0x03, 0x2d}
};

//
// Private command to tell the driver to create the DirectShow graph
//

const GUID WIA_CMD_DISABLE_TAKE_PICTURE =
{ /* 8127f490-1beb-4271-9f04-9c8e983f51fd */
    0x8127f490,
    0x1beb,
    0x4271,
    { 0x9f, 0x04, 0x9c, 0x8e, 0x98, 0x3f, 0x51, 0xfd}
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\validate.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    validate.h

Abstract:

Author:

    Vlad Sadovsky   (vlads) 26-Jun-1998

Revision History:

    26-Jun-1998     VladS       created

--*/

#ifndef _validate_h_
#define _validate_h_

#include <stidebug.h>

#ifdef __cplusplus
extern "C" {
#endif

/* parameter validation macros */

/*
 * call as:
 *
 * bOK = IS_VALID_READ_PTR(pfoo, CFOO);
 *
 * bOK = IS_VALID_HANDLE(hfoo, FOO);
 */

#ifdef DEBUG

#define IS_VALID_READ_PTR(ptr, type) \
   (IsBadReadPtr((ptr), sizeof(type)) ? \
    (DPRINTF(DM_ERROR, TEXT("invalid %hs read pointer - %#08lx"), (LPCSTR)#type TEXT(" *"), (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_PTR(ptr, type) \
   (IsBadWritePtr((PVOID)(ptr), sizeof(type)) ? \
    (DPRINTF(DM_ERROR, TEXT("invalid %hs write pointer - %#08lx"), (LPCSTR)#type TEXT(" *"), (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRA(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(char)) || IsBadStringPtrA((ptr), (UINT)(cch))) ? \
    (DPRINTF(DM_ERROR, TEXT("invalid LPSTR pointer - %#08lx"), (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRW(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(WCHAR)) || IsBadStringPtrW((ptr), (UINT)(cch))) ? \
    (DPRINTF(DM_ERROR, TEXT("invalid LPWSTR pointer - %#08lx"), (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_CODE_PTR(ptr, type) \
   (IsBadCodePtr((FARPROC)(ptr)) ? \
    (DPRINTF(DM_ERROR, TEXT("invalid %hs code pointer - %#08lx"), (LPCSTR)#type, (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_READ_BUFFER(ptr, type, len) \
   (IsBadReadPtr((ptr), sizeof(type)*(len)) ? \
    (DPRINTF(DM_ERROR, TEXT("invalid %hs read buffer pointer - %#08lx"), (LPCSTR)#type TEXT(" *"), (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_BUFFER(ptr, type, len) \
   (IsBadWritePtr((ptr), sizeof(type)*(len)) ? \
    (DPRINTF(DM_ERROR, TEXT("invalid %hs write buffer pointer - %#08lx"), (LPCSTR)#type TEXT(" *"), (ptr)), FALSE) : \
    TRUE)

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? \
    (DPRINTF(DM_ERROR, TEXT("invalid flags set - %#08lx"), ((dwFlags) & (~(dwAllFlags)))), FALSE) : \
    TRUE)

#define IS_VALID_PIDL(ptr) \
   ( !IsValidPIDL(ptr) ? \
    (DPRINTF(DM_ERROR, TEXT("invalid PIDL pointer - %#08lx"), (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_SIZE(cb, cbExpected) \
   ((cb) != (cbExpected) ? \
    (DPRINTF(DM_ERROR, TEXT("invalid size - is %#08lx, expected %#08lx"), (cb), (cbExpected)), FALSE) : \
    TRUE)


#else

#define IS_VALID_READ_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_WRITE_PTR(ptr, type) \
   (! IsBadWritePtr((PVOID)(ptr), sizeof(type)))

#define IS_VALID_STRING_PTRA(ptr, cch) \
   (! IsBadStringPtrA((ptr), (UINT)(cch)))

#define IS_VALID_STRING_PTRW(ptr, cch) \
   (! IsBadStringPtrW((ptr), (UINT)(cch)))

#define IS_VALID_CODE_PTR(ptr, type) \
   (! IsBadCodePtr((FARPROC)(ptr)))

#define IS_VALID_READ_BUFFER(ptr, type, len) \
   (! IsBadReadPtr((ptr), sizeof(type)*(len)))

#define IS_VALID_WRITE_BUFFER(ptr, type, len) \
   (! IsBadWritePtr((ptr), sizeof(type)*(len)))

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? FALSE : TRUE)

#define IS_VALID_PIDL(ptr) \
   (IsValidPIDL(ptr))

#define IS_VALID_SIZE(cb, cbExpected) \
   ((cb) == (cbExpected))

#endif

#ifdef UNICODE
#define IS_VALID_STRING_PTR     IS_VALID_STRING_PTRW
#else
#define IS_VALID_STRING_PTR     IS_VALID_STRING_PTRA
#endif


/* handle validation macros */

#ifdef DEBUG

#define IS_VALID_HANDLET(hnd, type) \
   (IsValidH##type(hnd) ? \
    TRUE : \
    (DPRINTF(DM_ERROR, TEXT("invalid H") #type TEXT(" - %#08lx"), (hnd)), FALSE))

#else

#define IS_VALID_HANDLET(hnd, type) \
   (IsValidH##type(hnd))

#endif

//
// Validation macros
//

//#define IS_VALID_HANDLE(h)  (((h) != NULL) && ((h) != INVALID_HANDLE_VALUE))

#define IS_VALID_HANDLE(hnd)    (IsValidHANDLE(hnd))

/* structure validation macros */

// Define VSTF if you want to validate the fields in structures.  This
// requires a handler function (of the form IsValid*()) that knows how
// to validate the specific structure type.

#ifdef VSTF

#ifdef DEBUG

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr) ? \
    TRUE : \
    (DPRINTF(DM_ERROR, TEXT("invalid %hs pointer - %#08lx"), (LPCSTR)#type TEXT(" *"), (ptr)), FALSE))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (IsValidP##type(ptr, x) ? \
    TRUE : \
    (DPRINTF(DM_ERROR, TEXT("invalid %hs pointer - %#08lx"), (LPCSTR)#type TEXT(" *"), (ptr)), FALSE))

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (IsValidP##type(ptr, x))

#endif

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#endif  // VSTF

/* OLE interface validation macro */

#define IS_VALID_INTERFACE_PTR(ptr, iface) \
   IS_VALID_STRUCT_PTR(ptr, ##iface)



BOOL IsValidHANDLE(HANDLE hnd);         // Compares with NULL and INVALID_HANDLE_VALUE
BOOL IsValidHANDLE2(HANDLE hnd);        // Compares with INVALID_HANDLE_VALUE

BOOL
IsValidHWND(
    HWND hwnd);

BOOL
IsValidHMENU(
    HMENU hmenu);

BOOL
IsValidShowCmd(
    int nShow);

#ifdef __cplusplus
};
#endif

#endif // _validate_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\waitcurs.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       WAITCURS.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/3/1999
 *
 *  DESCRIPTION: Change the cursor to an hourglass during lengthy operations.  To
 *               use, just put a CWaitCursor wc; in your function.  It will restore
 *               the cursor when the class is destroyed (usually when the function
 *               is exited.
 *
 *******************************************************************************/
#ifndef __WAITCURS_H_INCLUDED
#define __WAITCURS_H_INCLUDED

class CWaitCursor
{
private:
    HCURSOR m_hCurOld;
public:
    CWaitCursor(void)
    {
        m_hCurOld = SetCursor( LoadCursor( NULL, IDC_WAIT ) );
    }
    ~CWaitCursor(void)
    {
        SetCursor(m_hCurOld);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\wiaeventclient.h ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        3/24/2002
 *
 *  @doc    INTERNAL
 *
 *  @module WiaEventClient.h - Definition file for <c WiaEventClient> |
 *
 *  This file contains the class definition for the <c WiaEventClient> base
 *  class.
 *
 *****************************************************************************/

//
//  Defines
//

#define WiaEventClient_UNINIT_SIG   0x55636557
#define WiaEventClient_INIT_SIG     0x49636557
#define WiaEventClient_TERM_SIG     0x54636557
#define WiaEventClient_DEL_SIG      0x44636557

/*****************************************************************************
 *  
 *  @doc INTERNAL
 *  
 *  @class WiaEventClient | Base class used to store and manage run-time event
 *  information for a paricular WIA client.
 *  
 *  @comm
 *  Each client that registers for event notifications will have an instance 
 *  of this class on the server.  Each time an event registration is made, 
 *  the server checks whether the given client can be found .  If not, it 
 *  creates a new one of these, adding it to the list of registered clients.  
 *  Once we know the client context definitely exists, and any event registration 
 *  info is added to the appropriate instance of this class.  
 *
 *  This is a base class that is used to implements most of the above behavior.
 *  However, transport specific information is left up to sub-classes to 
 *  implement e.g. in order to send an event notification to a client over,
 *  AsyncRPC, we need an RPC_ASYNC_STATE and so on, which only a 
 *  <c AsyncRpcEventClient> will know how to handle.
 *
 *****************************************************************************/
class WiaEventClient 
{
//@access Public members
public:

    // @cmember Constructor
    WiaEventClient(STI_CLIENT_CONTEXT ClientContext);
    // @cmember Destructor
    virtual ~WiaEventClient();

    // @cmember Increment reference count
    virtual ULONG __stdcall AddRef();
    // @cmember Decrement reference count
    virtual ULONG __stdcall Release();

    // @cmember Initializer method
    virtual HRESULT Initialize();
    // @cmember Checks whether the client is interested in the event from the given device.
    virtual BOOL IsRegisteredForEvent(WiaEventInfo *pWiaEventInfo);
    // @cmember Add/Remove a client registration.
    virtual HRESULT RegisterUnregisterForEventNotification(EventRegistrationInfo *pEventRegistrationInfo);
    // @cmember Add a pending event.
    virtual HRESULT AddPendingEventNotification(WiaEventInfo *pWiaEventInfo);
    // @cmember Returns the context identifying this client
    virtual STI_CLIENT_CONTEXT getClientContext();
    // @cmember Sets the mark to indicate that this object should be removed
    virtual VOID MarkForRemoval();
    // @cmember Check the mark to indicate whether this object should be removed
    virtual BOOL isMarkedForRemoval();

//@access Protected members
protected:

    // @cmember Checks whether a semantically equal <c EventRegistrationInfo> is in the list
    EventRegistrationInfo* FindEqualEventRegistration(EventRegistrationInfo *pEventRegistrationInfo);
    // @cmember Walks event registration list and releases all elements.
    VOID DestroyRegistrationList();
    // @cmember Walks event event list and releases all elements.
    VOID DestroyPendingEventList();

    // @cmember Signature of class
    ULONG m_ulSig;

    // @cmember Ref count
    ULONG m_cRef;

    // @cmember Context which uniquely identifies this client to the server
    STI_CLIENT_CONTEXT m_ClientContext;

    // @cmember List holding the client's event registration data
    CSimpleLinkedList<EventRegistrationInfo*> m_ListOfEventRegistrations;

    // @cmember List holding the client's pending events
    CSimpleQueue<WiaEventInfo*> m_ListOfEventsPending;

    // @cmember Synchronization primitive used to protect access to the internal lists held by this class
    CRIT_SECT   m_csClientSync;

    // @cmember Set to TRUE when this object should be removed
    BOOL    m_bRemove;

    //
    //  Comments for member variables
    //
    // @mdata ULONG | WiaEventClient | m_ulSig | 
    //   The signature for this class, used for debugging purposes.
    //   Doing a <nl>"db [addr_of_class]"<nl> would yield one of the following
    //   signatures for this class:
    //   @flag WiaEventClient_UNINIT_SIG | 'WecU' - Object has not been successfully
    //       initialized
    //   @flag WiaEventClient_INIT_SIG | 'WecI' - Object has been successfully
    //       initialized
    //   @flag WiaEventClient_TERM_SIG | 'WecT' - Object is in the process of
    //       terminating.
    //    @flag WiaEventClient_INIT_SIG | 'WecD' - Object has been deleted 
    //       (destructor was called)
    //
    //
    // @mdata ULONG | WiaEventClient | m_cRef | 
    //   The reference count for this class.  Used for lifetime 
    //   management.
    //
    // @mdata STI_CLIENT_CONTEXT | WiaEventClient | m_ClientContext | 
    // Context which uniquely identifies this client to the server
    //
    // @mdata CSimpleLinkedList<lt>WIA_EVENT_REG_DATA*<gt> | WiaEventClient | m_ListOfEventRegistrations | 
    // List holding the client's event registration data.  This is used to check whether a given event
    // notification is needed by a client.  If the client has at least one registration matching the
    // event notification, the event is added to the list of pending events.
    //
    // @mdata CSimpleLinkedList<lt>WIA_EVENT_DATA*<gt> | WiaEventClient | m_ListOfEventsPending |
    // Each event notification needed by clients is added to this list of pending events for
    // later retrieval.  Sub-classes actually decide when to notify the client, and therefore when to
    // de-queue an event.
    //
    // @mdata CRIT_SECT | WiaEventClient | m_csClientSync | 
    // Synchronization primitive used to protect access to the internal lists held by this class
    //
    // @mdata BOOL | WiaEventClient | m_bRemove | 
    // Keeps track of whether this object is marked for removal.  When an object is marked
    // for removal, it may still be used as normal, but will be removed at the next available opertunity.
    //
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\wiadevd.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 1998-2000, MICROSOFT CORP.
*
*  FILE:        wiadevd.h
*
*  VERSION:     1.0
*
*  DATE:        7/5/1999
*
*  DESCRIPTION:
*    Device Dialog and UI extensibility declarations.
*
*****************************************************************************/

#ifndef _WIADEVD_H_INCLUDED
#define _WIADEVD_H_INCLUDED

#include "wia.h"

#if defined(__cplusplus)
extern "C" {
#endif

#include <pshpack8.h>

typedef struct tagDEVICEDIALOGDATA
{
    DWORD            cbSize;           // Size of the structure in bytes
    HWND             hwndParent;       // Parent window
    IWiaItem         *pIWiaItemRoot;   // Valid root item
    DWORD            dwFlags;          // Flags
    LONG             lIntent;          // Intent flags
    LONG             lItemCount;       // Number of items in ppWiaItems array.  Filled on return.
    IWiaItem         **ppWiaItems;     // Array of IWiaItem interface pointers.  Array must
                                       // be allocated using LocalAlloc, all interface pointers must be AddRef'ed
} DEVICEDIALOGDATA, *LPDEVICEDIALOGDATA, *PDEVICEDIALOGDATA;

HRESULT WINAPI DeviceDialog( PDEVICEDIALOGDATA pDeviceDialogData );

// IWiaUIExtension provides a means to replace a device's image acquisition dialog
// and to provide custom icons and logo bitmaps to appear on the standard dialog
#undef  INTERFACE
#define INTERFACE IWiaUIExtension
DECLARE_INTERFACE_(IWiaUIExtension, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWiaUIExtension methods ***
    STDMETHOD(DeviceDialog)( THIS_ PDEVICEDIALOGDATA pDeviceDialogData ) PURE;
    STDMETHOD(GetDeviceIcon)(THIS_ BSTR bstrDeviceId, HICON *phIcon, ULONG nSize ) PURE;
    STDMETHOD(GetDeviceBitmapLogo)(THIS_ BSTR bstrDeviceId, HBITMAP *phBitmap, ULONG nMaxWidth, ULONG nMaxHeight ) PURE;
};

// {da319113-50ee-4c80-b460-57d005d44a2c}
DEFINE_GUID(IID_IWiaUIExtension, 0xDA319113, 0x50EE, 0x4C80, 0xB4, 0x60, 0x57, 0xD0, 0x05, 0xD4, 0x4A, 0x2C);

typedef HRESULT (WINAPI *DeviceDialogFunction)(PDEVICEDIALOGDATA);

#define SHELLEX_WIAUIEXTENSION_NAME TEXT("WiaDialogExtensionHandlers")

// Define clipboard format names for retrieving data from an IDataObject
#define CFSTR_WIAITEMNAMES TEXT("WIAItemNames")
#define CFSTR_WIAITEMPTR   TEXT("WIAItemPointer")

#include <poppack.h>

#if defined(__cplusplus)
};
#endif

#endif // !_WIADEVD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\wiadef.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 1998-2000, MICROSOFT CORP.
*
*  FILE:        wiadef.h
*
*  VERSION:     2.0
*
*  DATE:        7/27/2000
*
*  DESCRIPTION:
*    Defines WIA constants.
*
*****************************************************************************/

#ifndef _WIADEF_H_
#define _WIADEF_H_

//
// Set packing
//
#include <pshpack8.h>

//
// Include COM definitions
//
#ifndef _NO_COM
#include <objbase.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**************************************************************************
*
* WIA Errors
*
***************************************************************************/

//
// Define the facility code. Move this to sdk\inc???
//

#define FACILITY_WIA 33

//
// Definitions for WIA_ERRORs and WIA_STATUSs. Applications can test for these returns
// on API return, to keep users informed of conditions which a user
// could correct.
//

#define BASE_VAL_WIA_ERROR   0x00000000
#define BASE_VAL_WIA_SUCCESS 0x00000000

#define WIA_ERROR_GENERAL_ERROR              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 1))
#define WIA_ERROR_PAPER_JAM                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 2))
#define WIA_ERROR_PAPER_EMPTY                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 3))
#define WIA_ERROR_PAPER_PROBLEM              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 4))
#define WIA_ERROR_OFFLINE                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 5))
#define WIA_ERROR_BUSY                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 6))
#define WIA_ERROR_WARMING_UP                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 7))
#define WIA_ERROR_USER_INTERVENTION          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 8))
#define WIA_ERROR_ITEM_DELETED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 9))
#define WIA_ERROR_DEVICE_COMMUNICATION       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 10))
#define WIA_ERROR_INVALID_COMMAND            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 11))
#define WIA_ERROR_INCORRECT_HARDWARE_SETTING MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 12))
#define WIA_ERROR_DEVICE_LOCKED              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 13))
#define WIA_ERROR_EXCEPTION_IN_DRIVER        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 14))
#define WIA_ERROR_INVALID_DRIVER_RESPONSE    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 15))


#define WIA_STATUS_END_OF_MEDIA              MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_WIA, (BASE_VAL_WIA_SUCCESS + 1))

//
// Returned by SelectDeviceDlg and SelectDeviceDlgId when there are no devices avaiable
//
#define WIA_S_NO_DEVICE_AVAILABLE            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 21))

//
// SelectDeviceDlg & GetImageDlg flags
//

#define WIA_SELECT_DEVICE_NODEFAULT          0x00000001

//
// GetImageDlg & DeviceDlg flags
//

#define WIA_DEVICE_DIALOG_SINGLE_IMAGE       0x00000002  // Only allow one image to be selected
#define WIA_DEVICE_DIALOG_USE_COMMON_UI      0x00000004  // Give preference to the system-provided UI, if available

//**************************************************************************
//
// Image types
//
//**************************************************************************

DEFINE_GUID(WiaImgFmt_UNDEFINED, 0xb96b3ca9,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_RAWRGB, 0xbca48b55,0xf272,0x4371,0xb0,0xf1,0x4a,0x15,0xd,0x5,0x7b,0xb4);
DEFINE_GUID(WiaImgFmt_MEMORYBMP, 0xb96b3caa,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_BMP, 0xb96b3cab,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_EMF, 0xb96b3cac,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_WMF, 0xb96b3cad,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_JPEG, 0xb96b3cae,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_PNG, 0xb96b3caf,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_GIF, 0xb96b3cb0,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_TIFF, 0xb96b3cb1,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_EXIF, 0xb96b3cb2,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_PHOTOCD, 0xb96b3cb3,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_FLASHPIX, 0xb96b3cb4,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_ICO, 0xb96b3cb5,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
// Canon Image File Format
DEFINE_GUID(WiaImgFmt_CIFF,0x9821a8ab,0x3a7e,0x4215,0x94,0xe0,0xd2,0x7a,0x46,0x0c,0x03,0xb2);
// Quickdraw Image Format
DEFINE_GUID(WiaImgFmt_PICT,0xa6bc85d8,0x6b3e,0x40ee,0xa9,0x5c,0x25,0xd4,0x82,0xe4,0x1a,0xdc);
// JPEG 2000 baseline file format
DEFINE_GUID(WiaImgFmt_JPEG2K,0x344ee2b2,0x39db,0x4dde,0x81,0x73,0xc4,0xb7,0x5f,0x8f,0x1e,0x49);
// JPEG 2000 extended file format
DEFINE_GUID(WiaImgFmt_JPEG2KX,0x43e14614,0xc80a,0x4850,0xba,0xf3,0x4b,0x15,0x2d,0xc8,0xda,0x27);


//**************************************************************************
//
// Document and other types
//
// Note: HTML, AVI, and MPEG used to have different GUIDs. Use the GUIDs
//       defined below from now on.
//
//**************************************************************************

DEFINE_GUID(WiaImgFmt_RTF, 0x573dd6a3,0x4834,0x432d,0xa9,0xb5,0xe1,0x98,0xdd,0x9e,0x89,0xd);
DEFINE_GUID(WiaImgFmt_XML, 0xb9171457,0xdac8,0x4884,0xb3,0x93,0x15,0xb4,0x71,0xd5,0xf0,0x7e);
DEFINE_GUID(WiaImgFmt_HTML, 0xc99a4e62,0x99de,0x4a94,0xac,0xca,0x71,0x95,0x6a,0xc2,0x97,0x7d);
DEFINE_GUID(WiaImgFmt_TXT, 0xfafd4d82,0x723f,0x421f,0x93,0x18,0x30,0x50,0x1a,0xc4,0x4b,0x59);
DEFINE_GUID(WiaImgFmt_MPG, 0xecd757e4,0xd2ec,0x4f57,0x95,0x5d,0xbc,0xf8,0xa9,0x7c,0x4e,0x52);
DEFINE_GUID(WiaImgFmt_AVI, 0x32f8ca14,0x87c,0x4908,0xb7,0xc4,0x67,0x57,0xfe,0x7e,0x90,0xab);
DEFINE_GUID(WiaImgFmt_ASF, 0x8d948ee9,0xd0aa,0x4a12,0x9d,0x9a,0x9c,0xc5,0xde,0x36,0x19,0x9b);
DEFINE_GUID(WiaImgFmt_SCRIPT, 0xfe7d6c53,0x2dac,0x446a,0xb0,0xbd,0xd7,0x3e,0x21,0xe9,0x24,0xc9);
DEFINE_GUID(WiaImgFmt_EXEC, 0x485da097,0x141e,0x4aa5,0xbb,0x3b,0xa5,0x61,0x8d,0x95,0xd0,0x2b);
DEFINE_GUID(WiaImgFmt_UNICODE16,0x1b7639b6,0x6357,0x47d1,0x9a,0x07,0x12,0x45,0x2d,0xc0,0x73,0xe9);
DEFINE_GUID(WiaImgFmt_DPOF,0x369eeeab,0xa0e8,0x45ca,0x86,0xa6,0xa8,0x3c,0xe5,0x69,0x7e,0x28);


//**************************************************************************
//
// Audio types
//
//**************************************************************************

DEFINE_GUID(WiaAudFmt_WAV, 0xf818e146,0x07af,0x40ff,0xae,0x55,0xbe,0x8f,0x2c,0x06,0x5d,0xbe);
DEFINE_GUID(WiaAudFmt_MP3, 0x0fbc71fb,0x43bf,0x49f2,0x91,0x90,0xe6,0xfe,0xcf,0xf3,0x7e,0x54);
DEFINE_GUID(WiaAudFmt_AIFF, 0x66e2bf4f,0xb6fc,0x443f,0x94,0xc8,0x2f,0x33,0xc8,0xa6,0x5a,0xaf);
DEFINE_GUID(WiaAudFmt_WMA, 0xd61d6413,0x8bc2,0x438f,0x93,0xad,0x21,0xbd,0x48,0x4d,0xb6,0xa1);


//**************************************************************************
//
// WIA Events
//
//**************************************************************************

//
// Event registration flags, used by RegisterEventLaunch,
// RegisterEventCallbackInterface and RegisterEventCallbackCLSID.
//

#define  WIA_REGISTER_EVENT_CALLBACK        0x00000001
#define  WIA_UNREGISTER_EVENT_CALLBACK      0x00000002
#define  WIA_SET_DEFAULT_HANDLER            0x00000004

//
// Event type : individual bits of the possible event type combinations
//

#define  WIA_NOTIFICATION_EVENT             0x00000001
#define  WIA_ACTION_EVENT                   0x00000002

//
// Flag to indicate the corresponding persistent handler is default
//

#define  WIA_IS_DEFAULT_HANDLER             0x00000001

//
// Event GUIDs
//

DEFINE_GUID(WIA_EVENT_DEVICE_DISCONNECTED,  0x143e4e83, 0x6497, 0x11d2, 0xa2, 0x31, 0x0, 0xc0, 0x4f, 0xa3, 0x18, 0x9);
DEFINE_GUID(WIA_EVENT_DEVICE_CONNECTED,     0xa28bbade, 0x64b6, 0x11d2, 0xa2, 0x31, 0x0, 0xc0, 0x4f, 0xa3, 0x18, 0x9);
DEFINE_GUID(WIA_EVENT_ITEM_DELETED,         0x1d22a559, 0xe14f, 0x11d2, 0xb3, 0x26, 0x00, 0xc0, 0x4f, 0x68, 0xce, 0x61);
DEFINE_GUID(WIA_EVENT_ITEM_CREATED,         0x4c8f4ef5, 0xe14f, 0x11d2, 0xb3, 0x26, 0x00, 0xc0, 0x4f, 0x68, 0xce, 0x61);
DEFINE_GUID(WIA_EVENT_TREE_UPDATED,         0xc9859b91, 0x4ab2, 0x4cd6, 0xa1, 0xfc, 0x58, 0x2e, 0xec, 0x55, 0xe5, 0x85);
DEFINE_GUID(WIA_EVENT_VOLUME_INSERT,        0x9638bbfd, 0xd1bd, 0x11d2, 0xb3, 0x1f, 0x00, 0xc0, 0x4f, 0x68, 0xce, 0x61);
DEFINE_GUID(WIA_EVENT_SCAN_IMAGE,           0xa6c5a715, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);
DEFINE_GUID(WIA_EVENT_SCAN_PRINT_IMAGE,     0xb441f425, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);
DEFINE_GUID(WIA_EVENT_SCAN_FAX_IMAGE,       0xc00eb793, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);
DEFINE_GUID(WIA_EVENT_SCAN_OCR_IMAGE,       0x9d095b89, 0x37d6, 0x4877, 0xaf, 0xed, 0x62, 0xa2, 0x97, 0xdc, 0x6d, 0xbe);
DEFINE_GUID(WIA_EVENT_SCAN_EMAIL_IMAGE,     0xc686dcee, 0x54f2, 0x419e, 0x9a, 0x27, 0x2f, 0xc7, 0xf2, 0xe9, 0x8f, 0x9e);
DEFINE_GUID(WIA_EVENT_SCAN_FILM_IMAGE,      0x9b2b662c, 0x6185, 0x438c, 0xb6, 0x8b, 0xe3, 0x9e, 0xe2, 0x5e, 0x71, 0xcb);
DEFINE_GUID(WIA_EVENT_SCAN_IMAGE2,          0xfc4767c1, 0xc8b3, 0x48a2, 0x9c, 0xfa, 0x2e, 0x90, 0xcb, 0x3d, 0x35, 0x90);
DEFINE_GUID(WIA_EVENT_SCAN_IMAGE3,          0x154e27be, 0xb617, 0x4653, 0xac, 0xc5, 0xf, 0xd7, 0xbd, 0x4c, 0x65, 0xce);
DEFINE_GUID(WIA_EVENT_SCAN_IMAGE4,          0xa65b704a, 0x7f3c, 0x4447, 0xa7, 0x5d, 0x8a, 0x26, 0xdf, 0xca, 0x1f, 0xdf);
DEFINE_GUID(WIA_EVENT_STORAGE_CREATED,      0x353308b2, 0xfe73, 0x46c8, 0x89, 0x5e, 0xfa, 0x45, 0x51, 0xcc, 0xc8, 0x5a);
DEFINE_GUID(WIA_EVENT_STORAGE_DELETED,      0x5e41e75e, 0x9390, 0x44c5, 0x9a, 0x51, 0xe4, 0x70, 0x19, 0xe3, 0x90, 0xcf);
DEFINE_GUID(WIA_EVENT_STI_PROXY,            0xd711f81f, 0x1f0d, 0x422d, 0x86, 0x41, 0x92, 0x7d, 0x1b, 0x93, 0xe5, 0xe5);
DEFINE_GUID(WIA_EVENT_CANCEL_IO,            0xc860f7b8, 0x9ccd, 0x41ea, 0xbb, 0xbf, 0x4d, 0xd0, 0x9c, 0x5b, 0x17, 0x95);

//
// Power management event GUIDs, sent by the WIA service to drivers
//

DEFINE_GUID(WIA_EVENT_POWER_SUSPEND,    0xa0922ff9, 0xc3b4, 0x411c, 0x9e, 0x29, 0x03, 0xa6, 0x69, 0x93, 0xd2, 0xbe);
DEFINE_GUID(WIA_EVENT_POWER_RESUME,     0x618f153e, 0xf686, 0x4350, 0x96, 0x34, 0x41, 0x15, 0xa3, 0x04, 0x83, 0x0c);


//
// No action handler and prompt handler
//

DEFINE_GUID(WIA_EVENT_HANDLER_NO_ACTION, 0xe0372b7d, 0xe115, 0x4525, 0xbc, 0x55, 0xb6, 0x29, 0xe6, 0x8c, 0x74, 0x5a);
DEFINE_GUID(WIA_EVENT_HANDLER_PROMPT, 0x5f4baad0, 0x4d59, 0x4fcd, 0xb2, 0x13, 0x78, 0x3c, 0xe7, 0xa9, 0x2f, 0x22);

#define WIA_EVENT_DEVICE_DISCONNECTED_STR   L"Device Disconnected"
#define WIA_EVENT_DEVICE_CONNECTED_STR      L"Device Connected"


//**************************************************************************
//
// WIA Commands
//
//**************************************************************************

DEFINE_GUID(WIA_CMD_SYNCHRONIZE, 0x9b26b7b2, 0xacad, 0x11d2, 0xa0, 0x93, 0x00, 0xc0, 0x4f, 0x72, 0xdc, 0x3c);
DEFINE_GUID(WIA_CMD_TAKE_PICTURE, 0xaf933cac, 0xacad, 0x11d2, 0xa0, 0x93, 0x00, 0xc0, 0x4f, 0x72, 0xdc, 0x3c);
DEFINE_GUID(WIA_CMD_DELETE_ALL_ITEMS, 0xe208c170, 0xacad, 0x11d2, 0xa0, 0x93, 0x00, 0xc0, 0x4f, 0x72, 0xdc, 0x3c);
DEFINE_GUID(WIA_CMD_CHANGE_DOCUMENT, 0x04e725b0, 0xacae, 0x11d2, 0xa0, 0x93, 0x00, 0xc0, 0x4f, 0x72, 0xdc, 0x3c);
DEFINE_GUID(WIA_CMD_UNLOAD_DOCUMENT, 0x1f3b3d8e, 0xacae, 0x11d2, 0xa0, 0x93, 0x00, 0xc0, 0x4f, 0x72, 0xdc, 0x3c);
DEFINE_GUID(WIA_CMD_DIAGNOSTIC, 0x10ff52f5, 0xde04, 0x4cf0, 0xa5, 0xad, 0x69, 0x1f, 0x8d, 0xce, 0x01, 0x41);

//
// The following are private commands for debugging use only.
//

DEFINE_GUID(WIA_CMD_DELETE_DEVICE_TREE, 0x73815942, 0xdbea, 0x11d2, 0x84, 0x16, 0x00, 0xc0, 0x4f, 0xa3, 0x61, 0x45);
DEFINE_GUID(WIA_CMD_BUILD_DEVICE_TREE, 0x9cba5ce0, 0xdbea, 0x11d2, 0x84, 0x16, 0x00, 0xc0, 0x4f, 0xa3, 0x61, 0x45);


//**************************************************************************
//
// WIA Icons
//
//   Event   : -1000 to -1499 (Standard), -1500 to -1999 (Custom)
//   Command : -2000 to -2499 (Standard), -2500 to -2999 (Custom)
//
//**************************************************************************

#define WIA_ICON_DEVICE_DISCONNECTED    (L"sti.dll,-1001")
#define WIA_ICON_DEVICE_CONNECTED       (L"sti.dll,-1001")
#define WIA_ICON_ITEM_DELETED           (L"sti.dll,-1001")
#define WIA_ICON_ITEM_CREATED           (L"sti.dll,-1001")
#define WIA_ICON_VOLUME_INSERT          (L"sti.dll,-1001")
#define WIA_ICON_SCAN_BUTTON_PRESS      (L"sti.dll,-1001")
#define WIA_ICON_SYNCHRONIZE            (L"sti.dll,-2000")
#define WIA_ICON_TAKE_PICTURE           (L"sti.dll,-2001")
#define WIA_ICON_DELETE_ALL_ITEMS       (L"sti.dll,-2002")
#define WIA_ICON_CHANGE_DOCUMENT        (L"sti.dll,-2003")
#define WIA_ICON_UNLOAD_DOCUMENT        (L"sti.dll,-2004")
#define WIA_ICON_DELETE_DEVICE_TREE     (L"sti.dll,-2005")
#define WIA_ICON_BUILD_DEVICE_TREE      (L"sti.dll,-2006")


//**************************************************************************
//
// WIA Callbacks
//
//**************************************************************************

//
// IImageTransfer TYMED
//

#define TYMED_CALLBACK                          128
#define TYMED_MULTIPAGE_FILE                    256
#define TYMED_MULTIPAGE_CALLBACK                512

//
// IImageTransfer Callback Status. Messages must be a single value
//

#define IT_MSG_DATA_HEADER                      0x0001
#define IT_MSG_DATA                             0x0002
#define IT_MSG_STATUS                           0x0003
#define IT_MSG_TERMINATION                      0x0004
#define IT_MSG_NEW_PAGE                         0x0005
#define IT_MSG_FILE_PREVIEW_DATA                0x0006
#define IT_MSG_FILE_PREVIEW_DATA_HEADER         0x0007

//
//  Flags may be bit field combinations
//

#define IT_STATUS_TRANSFER_FROM_DEVICE          0x0001
#define IT_STATUS_PROCESSING_DATA               0x0002
#define IT_STATUS_TRANSFER_TO_CLIENT            0x0004

//
// IWIAEventCallback codes
//

#define WIA_MAJOR_EVENT_DEVICE_CONNECT          0x01
#define WIA_MAJOR_EVENT_DEVICE_DISCONNECT       0x02
#define WIA_MAJOR_EVENT_PICTURE_TAKEN           0x03
#define WIA_MAJOR_EVENT_PICTURE_DELETED         0x04

//
// Device connection status
//

#define  WIA_DEVICE_NOT_CONNECTED               0
#define  WIA_DEVICE_CONNECTED                   1


//**************************************************************************
//
// WIA Enumeration Flags
//
//**************************************************************************

//
// EnumDeviceCapabilities flags
//

#define WIA_DEVICE_COMMANDS 1
#define WIA_DEVICE_EVENTS 2

//
// EnumDeviceInfo Flags
//

#define WIA_DEVINFO_ENUM_LOCAL                  0x00000010


//**************************************************************************
//
// WIA Item constants
//
//**************************************************************************

//
// Item Types
//

#define WiaItemTypeFree                         0x00000000
#define WiaItemTypeImage                        0x00000001
#define WiaItemTypeFile                         0x00000002
#define WiaItemTypeFolder                       0x00000004
#define WiaItemTypeRoot                         0x00000008
#define WiaItemTypeAnalyze                      0x00000010
#define WiaItemTypeAudio                        0x00000020
#define WiaItemTypeDevice                       0x00000040
#define WiaItemTypeDeleted                      0x00000080
#define WiaItemTypeDisconnected                 0x00000100
#define WiaItemTypeHPanorama                    0x00000200
#define WiaItemTypeVPanorama                    0x00000400
#define WiaItemTypeBurst                        0x00000800
#define WiaItemTypeStorage                      0x00001000
#define WiaItemTypeTransfer                     0x00002000
#define WiaItemTypeGenerated                    0x00004000
#define WiaItemTypeHasAttachments               0x00008000
#define WiaItemTypeVideo                        0x00010000

//
// 0x00020000 has been reserved for the TWAIN compatiblity layer
// pass-through feature.
//

#define WiaItemTypeRemoved                      0x80000000

#define WiaItemTypeMask                         0x8003FFFF

//
// Big max device specific item context
//

#define WIA_MAX_CTX_SIZE                        0x01000000


//**************************************************************************
//
// WIA Properties
//
//**************************************************************************

//
// Property access flags
//

#define WIA_PROP_READ            0x01
#define WIA_PROP_WRITE           0x02
#define WIA_PROP_RW              (WIA_PROP_READ | WIA_PROP_WRITE)
#define WIA_PROP_SYNC_REQUIRED   0x04

#define WIA_PROP_NONE            0x08
#define WIA_PROP_RANGE           0x10
#define WIA_PROP_LIST            0x20
#define WIA_PROP_FLAG            0x40

#define WIA_PROP_CACHEABLE       0x10000

//
// Item access flags
//

#define WIA_ITEM_CAN_BE_DELETED  0x80
#define WIA_ITEM_READ            WIA_PROP_READ
#define WIA_ITEM_WRITE           WIA_PROP_WRITE
#define WIA_ITEM_RD              (WIA_ITEM_READ | WIA_ITEM_CAN_BE_DELETED)
#define WIA_ITEM_RWD             (WIA_ITEM_READ | WIA_ITEM_WRITE | WIA_ITEM_CAN_BE_DELETED)

#ifndef __WIAPROP_H_INCLUDED
#define __WIAPROP_H_INCLUDED

//
// Device information properties
//

#define WIA_RESERVED_FOR_SMALL_NEW_PROPS        256
#define WIA_RESERVED_FOR_NEW_PROPS              1024
#define WIA_RESERVED_FOR_ALL_MS_PROPS           (1024*32)

#define WIA_DIP_FIRST                           2
#define WIA_DIP_DEV_ID                          2
#define WIA_DIP_VEND_DESC                       3
#define WIA_DIP_DEV_DESC                        4
#define WIA_DIP_DEV_TYPE                        5
#define WIA_DIP_PORT_NAME                       6
#define WIA_DIP_DEV_NAME                        7
#define WIA_DIP_SERVER_NAME                     8
#define WIA_DIP_REMOTE_DEV_ID                   9
#define WIA_DIP_UI_CLSID                        10
#define WIA_DIP_HW_CONFIG                       11
#define WIA_DIP_BAUDRATE                        12
#define WIA_DIP_STI_GEN_CAPABILITIES            13
#define WIA_DIP_WIA_VERSION                     14
#define WIA_DIP_DRIVER_VERSION                  15
#define WIA_DIP_LAST                            15

#define WIA_NUM_DIP          1 + WIA_DIP_LAST - WIA_DIP_FIRST

#define WIA_DIP_DEV_ID_STR                      L"Unique Device ID"
#define WIA_DIP_VEND_DESC_STR                   L"Manufacturer"
#define WIA_DIP_DEV_DESC_STR                    L"Description"
#define WIA_DIP_DEV_TYPE_STR                    L"Type"
#define WIA_DIP_PORT_NAME_STR                   L"Port"
#define WIA_DIP_DEV_NAME_STR                    L"Name"
#define WIA_DIP_SERVER_NAME_STR                 L"Server"
#define WIA_DIP_REMOTE_DEV_ID_STR               L"Remote Device ID"
#define WIA_DIP_UI_CLSID_STR                    L"UI Class ID"
#define WIA_DIP_HW_CONFIG_STR                   L"Hardware Configuration"
#define WIA_DIP_BAUDRATE_STR                    L"BaudRate"
#define WIA_DIP_STI_GEN_CAPABILITIES_STR        L"STI Generic Capabilities"
#define WIA_DIP_WIA_VERSION_STR                 L"WIA Version"
#define WIA_DIP_DRIVER_VERSION_STR              L"Driver Version"


//
// Constant arrays for device information property init
//

#ifdef WIA_DECLARE_DEVINFO_PROP_ARRAY

PROPSPEC g_psDeviceInfo[WIA_NUM_DIP] =
{
    {PRSPEC_PROPID, WIA_DIP_DEV_ID},
    {PRSPEC_PROPID, WIA_DIP_VEND_DESC},
    {PRSPEC_PROPID, WIA_DIP_DEV_DESC},
    {PRSPEC_PROPID, WIA_DIP_DEV_TYPE},
    {PRSPEC_PROPID, WIA_DIP_PORT_NAME},
    {PRSPEC_PROPID, WIA_DIP_DEV_NAME},
    {PRSPEC_PROPID, WIA_DIP_SERVER_NAME},
    {PRSPEC_PROPID, WIA_DIP_REMOTE_DEV_ID},
    {PRSPEC_PROPID, WIA_DIP_UI_CLSID},
    {PRSPEC_PROPID, WIA_DIP_HW_CONFIG},
    {PRSPEC_PROPID, WIA_DIP_BAUDRATE},
    {PRSPEC_PROPID, WIA_DIP_STI_GEN_CAPABILITIES},
    {PRSPEC_PROPID, WIA_DIP_WIA_VERSION},
    {PRSPEC_PROPID, WIA_DIP_DRIVER_VERSION},
};

PROPID g_piDeviceInfo[WIA_NUM_DIP] =
{
    WIA_DIP_DEV_ID,
    WIA_DIP_VEND_DESC,
    WIA_DIP_DEV_DESC,
    WIA_DIP_DEV_TYPE,
    WIA_DIP_PORT_NAME,
    WIA_DIP_DEV_NAME,
    WIA_DIP_SERVER_NAME,
    WIA_DIP_REMOTE_DEV_ID,
    WIA_DIP_UI_CLSID,
    WIA_DIP_HW_CONFIG,
    WIA_DIP_BAUDRATE,
    WIA_DIP_STI_GEN_CAPABILITIES,
    WIA_DIP_WIA_VERSION,
    WIA_DIP_DRIVER_VERSION,
};

LPOLESTR g_pszDeviceInfo[WIA_NUM_DIP] =
{
    WIA_DIP_DEV_ID_STR,
    WIA_DIP_VEND_DESC_STR,
    WIA_DIP_DEV_DESC_STR,
    WIA_DIP_DEV_TYPE_STR,
    WIA_DIP_PORT_NAME_STR,
    WIA_DIP_DEV_NAME_STR,
    WIA_DIP_SERVER_NAME_STR,
    WIA_DIP_REMOTE_DEV_ID_STR,
    WIA_DIP_UI_CLSID_STR,
    WIA_DIP_HW_CONFIG_STR,
    WIA_DIP_BAUDRATE_STR,
    WIA_DIP_STI_GEN_CAPABILITIES_STR,
    WIA_DIP_WIA_VERSION_STR,
    WIA_DIP_DRIVER_VERSION_STR,
};

#else

extern PROPSPEC             g_psDeviceInfo[WIA_NUM_DIP];
extern PROPID               g_piDeviceInfo[WIA_NUM_DIP];
extern LPOLESTR             g_pszDeviceInfo[WIA_NUM_DIP];

#endif


//
// Common device properties
//

#define WIA_DPA_FIRST                           WIA_DIP_FIRST + WIA_RESERVED_FOR_NEW_PROPS
#define WIA_DPA_FIRMWARE_VERSION                WIA_DPA_FIRST + 0
#define WIA_DPA_CONNECT_STATUS                  WIA_DPA_FIRST + 1
#define WIA_DPA_DEVICE_TIME                     WIA_DPA_FIRST + 2
#define WIA_DPA_LAST                            WIA_DPA_FIRST + 3

#define WIA_DPA_FIRMWARE_VERSION_STR            L"Firmware Version"
#define WIA_DPA_CONNECT_STATUS_STR              L"Connect Status"
#define WIA_DPA_DEVICE_TIME_STR                 L"Device Time"

#define WIA_NUM_DPA (1 + WIA_DPA_LAST - WIA_DPA_FIRST)


//
// Camera device properties
//

#define WIA_DPC_FIRST                           WIA_DPA_FIRST + WIA_RESERVED_FOR_NEW_PROPS
#define WIA_DPC_PICTURES_TAKEN                  WIA_DPC_FIRST + 0
#define WIA_DPC_PICTURES_REMAINING              WIA_DPC_FIRST + 1
#define WIA_DPC_EXPOSURE_MODE                   WIA_DPC_FIRST + 2
#define WIA_DPC_EXPOSURE_COMP                   WIA_DPC_FIRST + 3
#define WIA_DPC_EXPOSURE_TIME                   WIA_DPC_FIRST + 4
#define WIA_DPC_FNUMBER                         WIA_DPC_FIRST + 5
#define WIA_DPC_FLASH_MODE                      WIA_DPC_FIRST + 6
#define WIA_DPC_FOCUS_MODE                      WIA_DPC_FIRST + 7
#define WIA_DPC_FOCUS_MANUAL_DIST               WIA_DPC_FIRST + 8
#define WIA_DPC_ZOOM_POSITION                   WIA_DPC_FIRST + 9
#define WIA_DPC_PAN_POSITION                    WIA_DPC_FIRST + 10
#define WIA_DPC_TILT_POSITION                   WIA_DPC_FIRST + 11
#define WIA_DPC_TIMER_MODE                      WIA_DPC_FIRST + 12
#define WIA_DPC_TIMER_VALUE                     WIA_DPC_FIRST + 13
#define WIA_DPC_POWER_MODE                      WIA_DPC_FIRST + 14
#define WIA_DPC_BATTERY_STATUS                  WIA_DPC_FIRST + 15
#define WIA_DPC_THUMB_WIDTH                     WIA_DPC_FIRST + 16
#define WIA_DPC_THUMB_HEIGHT                    WIA_DPC_FIRST + 17
#define WIA_DPC_PICT_WIDTH                      WIA_DPC_FIRST + 18
#define WIA_DPC_PICT_HEIGHT                     WIA_DPC_FIRST + 19
#define WIA_DPC_DIMENSION                       WIA_DPC_FIRST + 20
#define WIA_DPC_COMPRESSION_SETTING             WIA_DPC_FIRST + 21
#define WIA_DPC_FOCUS_METERING                  WIA_DPC_FIRST + 22
#define WIA_DPC_TIMELAPSE_INTERVAL              WIA_DPC_FIRST + 23
#define WIA_DPC_TIMELAPSE_NUMBER                WIA_DPC_FIRST + 24
#define WIA_DPC_BURST_INTERVAL                  WIA_DPC_FIRST + 25
#define WIA_DPC_BURST_NUMBER                    WIA_DPC_FIRST + 26
#define WIA_DPC_EFFECT_MODE                     WIA_DPC_FIRST + 27
#define WIA_DPC_DIGITAL_ZOOM                    WIA_DPC_FIRST + 28
#define WIA_DPC_SHARPNESS                       WIA_DPC_FIRST + 29
#define WIA_DPC_CONTRAST                        WIA_DPC_FIRST + 30
#define WIA_DPC_CAPTURE_MODE                    WIA_DPC_FIRST + 31
#define WIA_DPC_CAPTURE_DELAY                   WIA_DPC_FIRST + 32
#define WIA_DPC_EXPOSURE_INDEX                  WIA_DPC_FIRST + 33
#define WIA_DPC_EXPOSURE_METERING_MODE          WIA_DPC_FIRST + 34
#define WIA_DPC_FOCUS_METERING_MODE             WIA_DPC_FIRST + 35
#define WIA_DPC_FOCUS_DISTANCE                  WIA_DPC_FIRST + 36
#define WIA_DPC_FOCAL_LENGTH                    WIA_DPC_FIRST + 37
#define WIA_DPC_RGB_GAIN                        WIA_DPC_FIRST + 38
#define WIA_DPC_WHITE_BALANCE                   WIA_DPC_FIRST + 39
#define WIA_DPC_UPLOAD_URL                      WIA_DPC_FIRST + 40
#define WIA_DPC_ARTIST                          WIA_DPC_FIRST + 41
#define WIA_DPC_COPYRIGHT_INFO                  WIA_DPC_FIRST + 42
#define WIA_DPC_LAST                            WIA_DPC_FIRST + 42

#define WIA_DPC_PICTURES_TAKEN_STR              L"Pictures Taken"
#define WIA_DPC_PICTURES_REMAINING_STR          L"Pictures Remaining"
#define WIA_DPC_EXPOSURE_MODE_STR               L"Exposure Mode"
#define WIA_DPC_EXPOSURE_COMP_STR               L"Exposure Compensation"
#define WIA_DPC_EXPOSURE_TIME_STR               L"Exposure Time"
#define WIA_DPC_FNUMBER_STR                     L"F Number"
#define WIA_DPC_FLASH_MODE_STR                  L"Flash Mode"
#define WIA_DPC_FOCUS_MODE_STR                  L"Focus Mode"
#define WIA_DPC_FOCUS_MANUAL_DIST_STR           L"Focus Manual Dist"
#define WIA_DPC_ZOOM_POSITION_STR               L"Zoom Position"
#define WIA_DPC_PAN_POSITION_STR                L"Pan Position"
#define WIA_DPC_TILT_POSITION_STR               L"Tilt Position"
#define WIA_DPC_TIMER_MODE_STR                  L"Timer Mode"
#define WIA_DPC_TIMER_VALUE_STR                 L"Timer Value"
#define WIA_DPC_POWER_MODE_STR                  L"Power Mode"
#define WIA_DPC_BATTERY_STATUS_STR              L"Battery Status"
#define WIA_DPC_THUMB_WIDTH_STR                 L"Thumbnail Width"
#define WIA_DPC_THUMB_HEIGHT_STR                L"Thumbnail Height"
#define WIA_DPC_PICT_WIDTH_STR                  L"Picture Width"
#define WIA_DPC_PICT_HEIGHT_STR                 L"Picture Height"
#define WIA_DPC_DIMENSION_STR                   L"Dimension"
#define WIA_DPC_COMPRESSION_SETTING_STR         L"Compression Setting"
#define WIA_DPC_FOCUS_METERING_MODE_STR         L"Focus Metering Mode"
#define WIA_DPC_TIMELAPSE_INTERVAL_STR          L"Timelapse Interval"
#define WIA_DPC_TIMELAPSE_NUMBER_STR            L"Timelapse Number"
#define WIA_DPC_BURST_INTERVAL_STR              L"Burst Interval"
#define WIA_DPC_BURST_NUMBER_STR                L"Burst Number"
#define WIA_DPC_EFFECT_MODE_STR                 L"Effect Mode"
#define WIA_DPC_DIGITAL_ZOOM_STR                L"Digital Zoom"
#define WIA_DPC_SHARPNESS_STR                   L"Sharpness"
#define WIA_DPC_CONTRAST_STR                    L"Contrast"
#define WIA_DPC_CAPTURE_MODE_STR                L"Capture Mode"
#define WIA_DPC_CAPTURE_DELAY_STR               L"Capture Delay"
#define WIA_DPC_EXPOSURE_INDEX_STR              L"Exposure Index"
#define WIA_DPC_EXPOSURE_METERING_MODE_STR      L"Exposure Metering Mode"
#define WIA_DPC_FOCUS_DISTANCE_STR              L"Focus Distance"
#define WIA_DPC_FOCAL_LENGTH_STR                L"Focus Length"
#define WIA_DPC_RGB_GAIN_STR                    L"RGB Gain"
#define WIA_DPC_WHITE_BALANCE_STR               L"White Balance"
#define WIA_DPC_UPLOAD_URL_STR                  L"Upload URL"
#define WIA_DPC_ARTIST_STR                      L"Artist"
#define WIA_DPC_COPYRIGHT_INFO_STR              L"Copyright Info"

#define WIA_NUM_DPC (1 + WIA_DPC_LAST - WIA_DPC_FIRST)


//
// Scanner device properties
//

#define WIA_DPS_FIRST                                  WIA_DPC_FIRST + WIA_RESERVED_FOR_NEW_PROPS
#define WIA_DPS_HORIZONTAL_BED_SIZE                    WIA_DPS_FIRST + 0
#define WIA_DPS_VERTICAL_BED_SIZE                      WIA_DPS_FIRST + 1
#define WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE             WIA_DPS_FIRST + 2
#define WIA_DPS_VERTICAL_SHEET_FEED_SIZE               WIA_DPS_FIRST + 3
#define WIA_DPS_SHEET_FEEDER_REGISTRATION              WIA_DPS_FIRST + 4
#define WIA_DPS_HORIZONTAL_BED_REGISTRATION            WIA_DPS_FIRST + 5
#define WIA_DPS_VERTICAL_BED_REGISTRATION              WIA_DPS_FIRST + 6
#define WIA_DPS_PLATEN_COLOR                           WIA_DPS_FIRST + 7
#define WIA_DPS_PAD_COLOR                              WIA_DPS_FIRST + 8
#define WIA_DPS_FILTER_SELECT                          WIA_DPS_FIRST + 9
#define WIA_DPS_DITHER_SELECT                          WIA_DPS_FIRST + 10
#define WIA_DPS_DITHER_PATTERN_DATA                    WIA_DPS_FIRST + 11
#define WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES         WIA_DPS_FIRST + 12
#define WIA_DPS_DOCUMENT_HANDLING_STATUS               WIA_DPS_FIRST + 13
#define WIA_DPS_DOCUMENT_HANDLING_SELECT               WIA_DPS_FIRST + 14
#define WIA_DPS_DOCUMENT_HANDLING_CAPACITY             WIA_DPS_FIRST + 15
#define WIA_DPS_OPTICAL_XRES                           WIA_DPS_FIRST + 16
#define WIA_DPS_OPTICAL_YRES                           WIA_DPS_FIRST + 17
#define WIA_DPS_ENDORSER_CHARACTERS                    WIA_DPS_FIRST + 18
#define WIA_DPS_ENDORSER_STRING                        WIA_DPS_FIRST + 19
#define WIA_DPS_SCAN_AHEAD_PAGES                       WIA_DPS_FIRST + 20
#define WIA_DPS_MAX_SCAN_TIME                          WIA_DPS_FIRST + 21
#define WIA_DPS_PAGES                                  WIA_DPS_FIRST + 22
#define WIA_DPS_PAGE_SIZE                              WIA_DPS_FIRST + 23
#define WIA_DPS_PAGE_WIDTH                             WIA_DPS_FIRST + 24
#define WIA_DPS_PAGE_HEIGHT                            WIA_DPS_FIRST + 25
#define WIA_DPS_PREVIEW                                WIA_DPS_FIRST + 26
#define WIA_DPS_TRANSPARENCY                           WIA_DPS_FIRST + 27
#define WIA_DPS_TRANSPARENCY_SELECT                    WIA_DPS_FIRST + 28
#define WIA_DPS_SHOW_PREVIEW_CONTROL                   WIA_DPS_FIRST + 29
#define WIA_DPS_MIN_HORIZONTAL_SHEET_FEED_SIZE         WIA_DPS_FIRST + 30
#define WIA_DPS_MIN_VERTICAL_SHEET_FEED_SIZE           WIA_DPS_FIRST + 31
#define WIA_DPS_LAST                                   WIA_DPS_FIRST + 31

#define WIA_DPS_HORIZONTAL_BED_SIZE_STR                L"Horizontal Bed Size"
#define WIA_DPS_VERTICAL_BED_SIZE_STR                  L"Vertical Bed Size"
#define WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE_STR         L"Horizontal Sheet Feed Size"
#define WIA_DPS_VERTICAL_SHEET_FEED_SIZE_STR           L"Vertical Sheet Feed Size"
#define WIA_DPS_SHEET_FEEDER_REGISTRATION_STR          L"Sheet Feeder Registration"
#define WIA_DPS_HORIZONTAL_BED_REGISTRATION_STR        L"Horizontal Bed Registration"
#define WIA_DPS_VERTICAL_BED_REGISTRATION_STR          L"Vertical Bed Registration"
#define WIA_DPS_PLATEN_COLOR_STR                       L"Platen Color"
#define WIA_DPS_PAD_COLOR_STR                          L"Pad Color"
#define WIA_DPS_FILTER_SELECT_STR                      L"Filter Select"
#define WIA_DPS_DITHER_SELECT_STR                      L"Dither Select"
#define WIA_DPS_DITHER_PATTERN_DATA_STR                L"Dither Pattern Data"
#define WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES_STR     L"Document Handling Capabilities"
#define WIA_DPS_DOCUMENT_HANDLING_STATUS_STR           L"Document Handling Status"
#define WIA_DPS_DOCUMENT_HANDLING_SELECT_STR           L"Document Handling Select"
#define WIA_DPS_DOCUMENT_HANDLING_CAPACITY_STR         L"Document Handling Capacity"
#define WIA_DPS_OPTICAL_XRES_STR                       L"Horizontal Optical Resolution"
#define WIA_DPS_OPTICAL_YRES_STR                       L"Vertical Optical Resolution"
#define WIA_DPS_ENDORSER_CHARACTERS_STR                L"Endorser Characters"
#define WIA_DPS_ENDORSER_STRING_STR                    L"Endorser String"
#define WIA_DPS_SCAN_AHEAD_PAGES_STR                   L"Scan Ahead Pages"
#define WIA_DPS_MAX_SCAN_TIME_STR                      L"Max Scan Time"
#define WIA_DPS_PAGES_STR                              L"Pages"
#define WIA_DPS_PAGE_SIZE_STR                          L"Page Size"
#define WIA_DPS_PAGE_WIDTH_STR                         L"Page Width"
#define WIA_DPS_PAGE_HEIGHT_STR                        L"Page Height"
#define WIA_DPS_PREVIEW_STR                            L"Preview"
#define WIA_DPS_TRANSPARENCY_STR                       L"Transparency Adapter"
#define WIA_DPS_TRANSPARENCY_SELECT_STR                L"Transparency Adapter Select"
#define WIA_DPS_SHOW_PREVIEW_CONTROL_STR               L"Show preview control"
#define WIA_DPS_MIN_HORIZONTAL_SHEET_FEED_SIZE_STR     L"Minimum Horizontal Sheet Feed Size"
#define WIA_DPS_MIN_VERTICAL_SHEET_FEED_SIZE_STR       L"Minimum Vertical Sheet Feed Size"

#define WIA_NUM_DPS (1 + WIA_DPS_LAST - WIA_DPS_FIRST)


//
// File System Properties
//
#define WIA_DPF_FIRST                           WIA_DPS_FIRST + WIA_RESERVED_FOR_SMALL_NEW_PROPS
#define WIA_DPF_MOUNT_POINT                     WIA_DPF_FIRST + 0
#define WIA_DPF_LAST                            WIA_DPF_FIRST + 0

#define WIA_DPF_MOUNT_POINT_STR                 L"Directory mount point"

#define WIA_NUM_DPF (1 + WIA_DPF_LAST - WIA_DPF_FIRST)

//
// Video Camera properties.
//
//
#define WIA_DPV_FIRST                           WIA_DPF_FIRST + WIA_RESERVED_FOR_SMALL_NEW_PROPS
#define WIA_DPV_LAST_PICTURE_TAKEN              WIA_DPV_FIRST + 0
#define WIA_DPV_IMAGES_DIRECTORY                WIA_DPV_FIRST + 1
#define WIA_DPV_DSHOW_DEVICE_PATH               WIA_DPV_FIRST + 2
#define WIA_DPV_LAST                            WIA_DPV_FIRST + 2

#define WIA_DPV_LAST_PICTURE_TAKEN_STR          L"Last Picture Taken"
#define WIA_DPV_IMAGES_DIRECTORY_STR            L"Images Directory"
#define WIA_DPV_DSHOW_DEVICE_PATH_STR           L"Directshow Device Path"

#define WIA_NUM_DPV (1 + WIA_DPV_LAST - WIA_DPV_FIRST)


//
// Common item properties
//

#define WIA_IPA_FIRST                           WIA_DPS_FIRST + WIA_RESERVED_FOR_NEW_PROPS
#define WIA_IPA_ITEM_NAME                       WIA_IPA_FIRST + 0
#define WIA_IPA_FULL_ITEM_NAME                  WIA_IPA_FIRST + 1
#define WIA_IPA_ITEM_TIME                       WIA_IPA_FIRST + 2
#define WIA_IPA_ITEM_FLAGS                      WIA_IPA_FIRST + 3
#define WIA_IPA_ACCESS_RIGHTS                   WIA_IPA_FIRST + 4
#define WIA_IPA_DATATYPE                        WIA_IPA_FIRST + 5
#define WIA_IPA_DEPTH                           WIA_IPA_FIRST + 6
#define WIA_IPA_PREFERRED_FORMAT                WIA_IPA_FIRST + 7
#define WIA_IPA_FORMAT                          WIA_IPA_FIRST + 8
#define WIA_IPA_COMPRESSION                     WIA_IPA_FIRST + 9
#define WIA_IPA_TYMED                           WIA_IPA_FIRST + 10
#define WIA_IPA_CHANNELS_PER_PIXEL              WIA_IPA_FIRST + 11
#define WIA_IPA_BITS_PER_CHANNEL                WIA_IPA_FIRST + 12
#define WIA_IPA_PLANAR                          WIA_IPA_FIRST + 13
#define WIA_IPA_PIXELS_PER_LINE                 WIA_IPA_FIRST + 14
#define WIA_IPA_BYTES_PER_LINE                  WIA_IPA_FIRST + 15
#define WIA_IPA_NUMBER_OF_LINES                 WIA_IPA_FIRST + 16
#define WIA_IPA_GAMMA_CURVES                    WIA_IPA_FIRST + 17
#define WIA_IPA_ITEM_SIZE                       WIA_IPA_FIRST + 18
#define WIA_IPA_COLOR_PROFILE                   WIA_IPA_FIRST + 19
#define WIA_IPA_MIN_BUFFER_SIZE                 WIA_IPA_FIRST + 20
// Note:  BUFFER_SIZE and MIN_BUFFER_SIZE have the same propids
#define WIA_IPA_BUFFER_SIZE                     WIA_IPA_FIRST + 20
#define WIA_IPA_REGION_TYPE                     WIA_IPA_FIRST + 21
#define WIA_IPA_ICM_PROFILE_NAME                WIA_IPA_FIRST + 22
#define WIA_IPA_APP_COLOR_MAPPING               WIA_IPA_FIRST + 23
#define WIA_IPA_PROP_STREAM_COMPAT_ID           WIA_IPA_FIRST + 24
#define WIA_IPA_FILENAME_EXTENSION              WIA_IPA_FIRST + 25
#define WIA_IPA_SUPPRESS_PROPERTY_PAGE          WIA_IPA_FIRST + 26
#define WIA_IPA_LAST                            WIA_IPA_FIRST + 26

#define  WIA_IPA_ITEM_NAME_STR                  L"Item Name"
#define  WIA_IPA_FULL_ITEM_NAME_STR             L"Full Item Name"
#define  WIA_IPA_ITEM_TIME_STR                  L"Item Time Stamp"
#define  WIA_IPA_ITEM_FLAGS_STR                 L"Item Flags"
#define  WIA_IPA_ACCESS_RIGHTS_STR              L"Access Rights"
#define  WIA_IPA_DATATYPE_STR                   L"Data Type"
#define  WIA_IPA_DEPTH_STR                      L"Bits Per Pixel"
#define  WIA_IPA_PREFERRED_FORMAT_STR           L"Preferred Format"
#define  WIA_IPA_FORMAT_STR                     L"Format"
#define  WIA_IPA_COMPRESSION_STR                L"Compression"
#define  WIA_IPA_TYMED_STR                      L"Media Type"
#define  WIA_IPA_CHANNELS_PER_PIXEL_STR         L"Channels Per Pixel"
#define  WIA_IPA_BITS_PER_CHANNEL_STR           L"Bits Per Channel"
#define  WIA_IPA_PLANAR_STR                     L"Planar"
#define  WIA_IPA_PIXELS_PER_LINE_STR            L"Pixels Per Line"
#define  WIA_IPA_BYTES_PER_LINE_STR             L"Bytes Per Line"
#define  WIA_IPA_NUMBER_OF_LINES_STR            L"Number of Lines"
#define  WIA_IPA_GAMMA_CURVES_STR               L"Gamma Curves"
#define  WIA_IPA_ITEM_SIZE_STR                  L"Item Size"
#define  WIA_IPA_COLOR_PROFILE_STR              L"Color Profiles"
#define  WIA_IPA_MIN_BUFFER_SIZE_STR            L"Buffer Size"
#define  WIA_IPA_REGION_TYPE_STR                L"Region Type"
#define  WIA_IPA_ICM_PROFILE_NAME_STR           L"Color Profile Name"
#define  WIA_IPA_APP_COLOR_MAPPING_STR          L"Application Applies Color Mapping"
#define  WIA_IPA_PROP_STREAM_COMPAT_ID_STR      L"Stream Compatibility ID"
#define  WIA_IPA_FILENAME_EXTENSION_STR         L"Filename extension"
#define  WIA_IPA_SUPPRESS_PROPERTY_PAGE_STR     L"Suppress a property page"

#define  WIA_NUM_IPA (1 + WIA_IPA_LAST - WIA_IPA_FIRST)


//
// Camera item properties
//

#define WIA_IPC_FIRST                          WIA_IPA_FIRST + WIA_RESERVED_FOR_NEW_PROPS
#define WIA_IPC_THUMBNAIL                      WIA_IPC_FIRST + 0
#define WIA_IPC_THUMB_WIDTH                    WIA_IPC_FIRST + 1
#define WIA_IPC_THUMB_HEIGHT                   WIA_IPC_FIRST + 2
#define WIA_IPC_AUDIO_AVAILABLE                WIA_IPC_FIRST + 3
#define WIA_IPC_AUDIO_DATA_FORMAT              WIA_IPC_FIRST + 4
#define WIA_IPC_AUDIO_DATA                     WIA_IPC_FIRST + 5
#define WIA_IPC_NUM_PICT_PER_ROW               WIA_IPC_FIRST + 6
#define WIA_IPC_SEQUENCE                       WIA_IPC_FIRST + 7
#define WIA_IPC_TIMEDELAY                      WIA_IPC_FIRST + 8
#define WIA_IPC_LAST                           WIA_IPC_FIRST + 8

#define WIA_IPC_THUMBNAIL_STR                  L"Thumbnail Data"
#define WIA_IPC_THUMB_WIDTH_STR                L"Thumbnail Width"
#define WIA_IPC_THUMB_HEIGHT_STR               L"Thumbnail Height"
#define WIA_IPC_AUDIO_AVAILABLE_STR            L"Audio Available"
#define WIA_IPC_AUDIO_DATA_FORMAT_STR          L"Audio Format"
#define WIA_IPC_AUDIO_DATA_STR                 L"Audio Data"
#define WIA_IPC_NUM_PICT_PER_ROW_STR           L"Pictures per Row"
#define WIA_IPC_SEQUENCE_STR                   L"Sequence Number"
#define WIA_IPC_TIMEDELAY_STR                  L"Time Delay"

#define WIA_NUM_IPC (1 + WIA_IPC_LAST - WIA_IPC_FIRST)


//
// Scanner item properties
//
#define WIA_IPS_FIRST                          WIA_IPC_FIRST + WIA_RESERVED_FOR_NEW_PROPS
#define WIA_IPS_CUR_INTENT                     WIA_IPS_FIRST + 0
#define WIA_IPS_XRES                           WIA_IPS_FIRST + 1
#define WIA_IPS_YRES                           WIA_IPS_FIRST + 2
#define WIA_IPS_XPOS                           WIA_IPS_FIRST + 3
#define WIA_IPS_YPOS                           WIA_IPS_FIRST + 4
#define WIA_IPS_XEXTENT                        WIA_IPS_FIRST + 5
#define WIA_IPS_YEXTENT                        WIA_IPS_FIRST + 6
#define WIA_IPS_PHOTOMETRIC_INTERP             WIA_IPS_FIRST + 7
#define WIA_IPS_BRIGHTNESS                     WIA_IPS_FIRST + 8
#define WIA_IPS_CONTRAST                       WIA_IPS_FIRST + 9
#define WIA_IPS_ORIENTATION                    WIA_IPS_FIRST + 10
#define WIA_IPS_ROTATION                       WIA_IPS_FIRST + 11
#define WIA_IPS_MIRROR                         WIA_IPS_FIRST + 12
#define WIA_IPS_THRESHOLD                      WIA_IPS_FIRST + 13
#define WIA_IPS_INVERT                         WIA_IPS_FIRST + 14
#define WIA_IPS_WARM_UP_TIME                   WIA_IPS_FIRST + 15
#define WIA_IPS_LAST                           WIA_IPS_FIRST + 15

#define WIA_IPS_CUR_INTENT_STR                 L"Current Intent"
#define WIA_IPS_XRES_STR                       L"Horizontal Resolution"
#define WIA_IPS_YRES_STR                       L"Vertical Resolution"
#define WIA_IPS_XPOS_STR                       L"Horizontal Start Position"
#define WIA_IPS_YPOS_STR                       L"Vertical Start Position"
#define WIA_IPS_XEXTENT_STR                    L"Horizontal Extent"
#define WIA_IPS_YEXTENT_STR                    L"Vertical Extent"
#define WIA_IPS_PHOTOMETRIC_INTERP_STR         L"Photometric Interpretation"
#define WIA_IPS_BRIGHTNESS_STR                 L"Brightness"
#define WIA_IPS_CONTRAST_STR                   L"Contrast"
#define WIA_IPS_ORIENTATION_STR                L"Orientation"
#define WIA_IPS_ROTATION_STR                   L"Rotation"
#define WIA_IPS_MIRROR_STR                     L"Mirror"
#define WIA_IPS_THRESHOLD_STR                  L"Threshold"
#define WIA_IPS_INVERT_STR                     L"Invert"
#define WIA_IPS_WARM_UP_TIME_STR               L"Lamp Warm up Time"

#define WIA_NUM_IPS (1 + WIA_IPS_LAST - WIA_IPS_FIRST)

//**************************************************************************
//
// Vendor defined property area
//
//**************************************************************************

#define WIA_PRIVATE_DEVPROP    (WIA_IPS_FIRST + WIA_RESERVED_FOR_ALL_MS_PROPS)
#define WIA_PRIVATE_ITEMPROP   (WIA_PRIVATE_DEVPROP + WIA_RESERVED_FOR_ALL_MS_PROPS)


//**************************************************************************
//
// WIA Property Constants
//
//**************************************************************************

//
// WIA_DPC_WHITE_BALANCE constants
//

#define WHITEBALANCE_MANUAL        1
#define WHITEBALANCE_AUTO          2
#define WHITEBALANCE_ONEPUSH_AUTO      3
#define WHITEBALANCE_DAYLIGHT          4
#define WHITEBALANCE_FLORESCENT        5
#define WHITEBALANCE_TUNGSTEN          6
#define WHITEBALANCE_FLASH         7

//
// WIA_DPC_FOCUS_MODE constants
//

#define FOCUSMODE_MANUAL        1
#define FOCUSMODE_AUTO          2
#define FOCUSMODE_MACROAUTO     3

//
// WIA_DPC_EXPOSURE_METERING_MODE constants
//

#define EXPOSUREMETERING_AVERAGE    1
#define EXPOSUREMETERING_CENTERWEIGHT   2
#define EXPOSUREMETERING_MULTISPOT  3
#define EXPOSUREMETERING_CENTERSPOT 4

//
// WIA_DPC_FLASH_MODE constants
//

#define FLASHMODE_AUTO          1
#define FLASHMODE_OFF           2
#define FLASHMODE_FILL          3
#define FLASHMODE_REDEYE_AUTO       4
#define FLASHMODE_REDEYE_FILL       5
#define FLASHMODE_EXTERNALSYNC      6

//
// WIA_DPC_EXPOSURE_MODE constants
//

#define EXPOSUREMODE_MANUAL     1
#define EXPOSUREMODE_AUTO       2
#define EXPOSUREMODE_APERTURE_PRIORITY  3
#define EXPOSUREMODE_SHUTTER_PRIORITY   4
#define EXPOSUREMODE_PROGRAM_CREATIVE   5
#define EXPOSUREMODE_PROGRAM_ACTION 6
#define EXPOSUREMODE_PORTRAIT       7

//
// WIA_DPC_CAPTURE_MODE constants
//

#define CAPTUREMODE_NORMAL      1
#define CAPTUREMODE_BURST       2
#define CAPTUREMODE_TIMELAPSE       3

//
// WIA_DPC_EFFECT_MODE constants
//

#define EFFECTMODE_STANDARD     1
#define EFFECTMODE_BW           2
#define EFFECTMODE_SEPIA        3

//
// WIA_DPC_FOCUS_METERING_MODE constants
//

#define FOCUSMETERING_CENTERSPOT    1
#define FOCUSMETERING_MULTISPOT     2

//
// WIA_DPC_POWER_MODE constants
//

#define POWERMODE_LINE              1
#define POWERMODE_BATTERY           2

//
// WIA_DPS_SHEET_FEEDER_REGISTRATION and
// WIA_DPS_HORIZONTAL_BED_REGISTRATION constants
//

#define  LEFT_JUSTIFIED             0
#define  CENTERED                   1
#define  RIGHT_JUSTIFIED            2

//
// WIA_DPS_VERTICAL_BED_REGISTRATION constants
//

#define  TOP_JUSTIFIED              0
#define  CENTERED                   1
#define  BOTTOM_JUSTIFIED           2

//
// WIA_DPS_ORIENTATION and WIA_DPS_ROTATION constants
//

#define  PORTRAIT                   0
#define  LANSCAPE                   1
#define  ROT180                     2
#define  ROT270                     3

//
// WIA_DPS_MIRROR flags
//

#define  MIRRORED                   0x01

//
// WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES flags
//

#define  FEED                       0x01
#define  FLAT                       0x02
#define  DUP                        0x04
#define  DETECT_FLAT                0x08
#define  DETECT_SCAN                0x10
#define  DETECT_FEED                0x20
#define  DETECT_DUP                 0x40
#define  DETECT_FEED_AVAIL          0x80
#define  DETECT_DUP_AVAIL           0x100

//
// WIA_DPS_DOCUMENT_HANDLING_STATUS flags
//

#define  FEED_READY                 0x01
#define  FLAT_READY                 0x02
#define  DUP_READY                  0x04
#define  FLAT_COVER_UP              0x08
#define  PATH_COVER_UP              0x10
#define  PAPER_JAM                  0x20

//
// WIA_DPS_DOCUMENT_HANDLING_SELECT flags
//

#define  FEEDER                     0x001
#define  FLATBED                    0x002
#define  DUPLEX                     0x004
#define  FRONT_FIRST                0x008
#define  BACK_FIRST                 0x010
#define  FRONT_ONLY                 0x020
#define  BACK_ONLY                  0x040
#define  NEXT_PAGE                  0x080
#define  PREFEED                    0x100
#define  AUTO_ADVANCE               0x200

//
// WIA_DPS_TRANSPARENCY flags
//

#define  LIGHT_SOURCE_PRESENT_DETECT 0x01
#define  LIGHT_SOURCE_PRESENT        0x02
#define  LIGHT_SOURCE_DETECT_READY   0x04
#define  LIGHT_SOURCE_READY          0x08

//
// WIA_DPS_TRANSPARENCY_SELECT flags
//

#define  LIGHT_SOURCE_SELECT        0x001

//
// WIA_DPS_SCAN_AHEAD_PAGES constants
//

#define  WIA_SCAN_AHEAD_ALL         0

//
// WIA_DPS_PAGES constants
//

#define  ALL_PAGES                  0

//
// WIA_DPS_PREVIEW constants
//

#define WIA_FINAL_SCAN              0
#define WIA_PREVIEW_SCAN            1

//
// WIA_DPS_SHOW_PREVIEW_CONTROL constants
//

#define WIA_SHOW_PREVIEW_CONTROL        0
#define WIA_DONT_SHOW_PREVIEW_CONTROL   1

//
// Predefined strings for WIA_DPS_ENDORSER_STRING
//

#define WIA_ENDORSER_TOK_DATE       L"$DATE$"
#define WIA_ENDORSER_TOK_TIME       L"$TIME$"
#define WIA_ENDORSER_TOK_PAGE_COUNT L"$PAGE_COUNT$"
#define WIA_ENDORSER_TOK_DAY        L"$DAY$"
#define WIA_ENDORSER_TOK_MONTH      L"$MONTH$"
#define WIA_ENDORSER_TOK_YEAR       L"$YEAR$"

//
// WIA_DPS_PAGE_SIZE constants
//

#define WIA_PAGE_A4         0
#define WIA_PAGE_LETTER     1
#define WIA_PAGE_CUSTOM     2

//
// WIA_IPA_COMPRESSION constants
//

#define WIA_COMPRESSION_NONE        0
#define WIA_COMPRESSION_BI_RLE4     1
#define WIA_COMPRESSION_BI_RLE8     2
#define WIA_COMPRESSION_G3          3
#define WIA_COMPRESSION_G4          4
#define WIA_COMPRESSION_JPEG        5


//
// WIA_IPA_PLANAR constants
//

#define WIA_PACKED_PIXEL            0
#define WIA_PLANAR                  1

//
// WIA_IPA_DATATYPE constants
//

#define WIA_DATA_THRESHOLD                      0
#define WIA_DATA_DITHER                         1
#define WIA_DATA_GRAYSCALE                      2
#define WIA_DATA_COLOR                          3
#define WIA_DATA_COLOR_THRESHOLD                4
#define WIA_DATA_COLOR_DITHER                   5

//
// WIA_IPA_SUPPRESS_PROPERTY_PAGE flags
//

#define WIA_PROPPAGE_SCANNER_ITEM_GENERAL       0x00000001
#define WIA_PROPPAGE_CAMERA_ITEM_GENERAL        0x00000002

//
// WIA_IPS_CUR_INTENT flags
//
#define WIA_INTENT_NONE                 0x00000000
#define WIA_INTENT_IMAGE_TYPE_COLOR     0x00000001
#define WIA_INTENT_IMAGE_TYPE_GRAYSCALE 0x00000002
#define WIA_INTENT_IMAGE_TYPE_TEXT      0x00000004
#define WIA_INTENT_IMAGE_TYPE_MASK      0x0000000F
#define WIA_INTENT_MINIMIZE_SIZE        0x00010000
#define WIA_INTENT_MAXIMIZE_QUALITY     0x00020000
#define WIA_INTENT_BEST_PREVIEW         0x00040000
#define WIA_INTENT_SIZE_MASK            0x000F0000

//
// WIA_IPS_PHOTOMETRIC_INTERP constants
//

#define WIA_PHOTO_WHITE_1      0   // default, white is 1, black is 0
#define WIA_PHOTO_WHITE_0      1   // default, white is 0, black is 1


//**************************************************************************
//
// WIA Extended Property Identifiers
//
//**************************************************************************

#define  WIA_RANGE_MIN                          0
#define  WIA_RANGE_NOM                          1
#define  WIA_RANGE_MAX                          2
#define  WIA_RANGE_STEP                         3
#define  WIA_RANGE_NUM_ELEMS                    4

#define  WIA_LIST_COUNT                         0
#define  WIA_LIST_NOM                           1
#define  WIA_LIST_VALUES                        2
#define  WIA_LIST_NUM_ELEMS                     2

#define  WIA_FLAG_NOM                           0
#define  WIA_FLAG_VALUES                        1
#define  WIA_FLAG_NUM_ELEMS                     2


//**************************************************************************
//
// Property id to string mapping
//
//**************************************************************************

#ifdef DEFINE_WIA_PROPID_TO_NAME

WIA_PROPID_TO_NAME g_wiaPropIdToName[] =
{
    {WIA_DIP_DEV_ID,                          WIA_DIP_DEV_ID_STR},
    {WIA_DIP_VEND_DESC,                       WIA_DIP_VEND_DESC_STR},
    {WIA_DIP_DEV_DESC,                        WIA_DIP_DEV_DESC_STR},
    {WIA_DIP_DEV_TYPE,                        WIA_DIP_DEV_TYPE_STR},
    {WIA_DIP_PORT_NAME,                       WIA_DIP_PORT_NAME_STR},
    {WIA_DIP_DEV_NAME,                        WIA_DIP_DEV_NAME_STR},
    {WIA_DIP_SERVER_NAME,                     WIA_DIP_SERVER_NAME_STR},
    {WIA_DIP_REMOTE_DEV_ID,                   WIA_DIP_REMOTE_DEV_ID_STR},
    {WIA_DIP_UI_CLSID,                        WIA_DIP_UI_CLSID_STR},
    {WIA_DIP_HW_CONFIG,                       WIA_DIP_HW_CONFIG_STR},
    {WIA_DIP_BAUDRATE,                        WIA_DIP_BAUDRATE_STR},
    {WIA_DIP_STI_GEN_CAPABILITIES,            WIA_DIP_STI_GEN_CAPABILITIES_STR},
    {WIA_DIP_WIA_VERSION,                     WIA_DIP_WIA_VERSION_STR},
    {WIA_DIP_DRIVER_VERSION,                  WIA_DIP_DRIVER_VERSION_STR},
    {WIA_DPA_FIRMWARE_VERSION,                WIA_DPA_FIRMWARE_VERSION_STR},
    {WIA_DPA_CONNECT_STATUS,                  WIA_DPA_CONNECT_STATUS_STR},
    {WIA_DPA_DEVICE_TIME,                     WIA_DPA_DEVICE_TIME_STR},
    {WIA_DPC_PICTURES_TAKEN,                  WIA_DPC_PICTURES_TAKEN_STR},
    {WIA_DPC_PICTURES_REMAINING,              WIA_DPC_PICTURES_REMAINING_STR},
    {WIA_DPC_EXPOSURE_MODE,                   WIA_DPC_EXPOSURE_MODE_STR},
    {WIA_DPC_EXPOSURE_COMP,                   WIA_DPC_EXPOSURE_COMP_STR},
    {WIA_DPC_EXPOSURE_TIME,                   WIA_DPC_EXPOSURE_TIME_STR},
    {WIA_DPC_FNUMBER,                         WIA_DPC_FNUMBER_STR},
    {WIA_DPC_FLASH_MODE,                      WIA_DPC_FLASH_MODE_STR},
    {WIA_DPC_FOCUS_MODE,                      WIA_DPC_FOCUS_MODE_STR},
    {WIA_DPC_FOCUS_MANUAL_DIST,               WIA_DPC_FOCUS_MANUAL_DIST_STR},
    {WIA_DPC_ZOOM_POSITION,                   WIA_DPC_ZOOM_POSITION_STR},
    {WIA_DPC_PAN_POSITION,                    WIA_DPC_PAN_POSITION_STR},
    {WIA_DPC_TILT_POSITION,                   WIA_DPC_TILT_POSITION_STR},
    {WIA_DPC_TIMER_MODE,                      WIA_DPC_TIMER_MODE_STR},
    {WIA_DPC_TIMER_VALUE,                     WIA_DPC_TIMER_VALUE_STR},
    {WIA_DPC_POWER_MODE,                      WIA_DPC_POWER_MODE_STR},
    {WIA_DPC_BATTERY_STATUS,                  WIA_DPC_BATTERY_STATUS_STR},
    {WIA_DPC_DIMENSION,                       WIA_DPC_DIMENSION_STR},
    {WIA_DPS_HORIZONTAL_BED_SIZE,             WIA_DPS_HORIZONTAL_BED_SIZE_STR},
    {WIA_DPS_VERTICAL_BED_SIZE,               WIA_DPS_VERTICAL_BED_SIZE_STR},
    {WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE,      WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE_STR},
    {WIA_DPS_VERTICAL_SHEET_FEED_SIZE,        WIA_DPS_VERTICAL_SHEET_FEED_SIZE_STR},
    {WIA_DPS_SHEET_FEEDER_REGISTRATION,       WIA_DPS_SHEET_FEEDER_REGISTRATION_STR},
    {WIA_DPS_HORIZONTAL_BED_REGISTRATION,     WIA_DPS_HORIZONTAL_BED_REGISTRATION_STR},
    {WIA_DPS_VERTICAL_BED_REGISTRATION,       WIA_DPS_VERTICAL_BED_REGISTRATION_STR},
    {WIA_DPS_PLATEN_COLOR,                    WIA_DPS_PLATEN_COLOR_STR},
    {WIA_DPS_PAD_COLOR,                       WIA_DPS_PAD_COLOR_STR},
    {WIA_DPS_FILTER_SELECT,                   WIA_DPS_FILTER_SELECT_STR},
    {WIA_DPS_DITHER_SELECT,                   WIA_DPS_DITHER_SELECT_STR},
    {WIA_DPS_DITHER_PATTERN_DATA,             WIA_DPS_DITHER_PATTERN_DATA_STR},
    {WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES,  WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES_STR},
    {WIA_DPS_DOCUMENT_HANDLING_STATUS,        WIA_DPS_DOCUMENT_HANDLING_STATUS_STR},
    {WIA_DPS_DOCUMENT_HANDLING_SELECT,        WIA_DPS_DOCUMENT_HANDLING_SELECT_STR},
    {WIA_DPS_DOCUMENT_HANDLING_CAPACITY,      WIA_DPS_DOCUMENT_HANDLING_CAPACITY_STR},
    {WIA_DPS_OPTICAL_XRES,                    WIA_DPS_OPTICAL_XRES_STR},
    {WIA_DPS_OPTICAL_YRES,                    WIA_DPS_OPTICAL_YRES_STR},
    {WIA_DPS_ENDORSER_CHARACTERS,             WIA_DPS_ENDORSER_CHARACTERS_STR},
    {WIA_DPS_ENDORSER_STRING,                 WIA_DPS_ENDORSER_STRING_STR},
    {WIA_DPS_SCAN_AHEAD_PAGES,                WIA_DPS_SCAN_AHEAD_PAGES_STR},
    {WIA_DPS_MAX_SCAN_TIME,                   WIA_DPS_MAX_SCAN_TIME_STR},
    {WIA_DPS_PAGES,                           WIA_DPS_PAGES_STR},
    {WIA_DPS_PAGE_SIZE,                       WIA_DPS_PAGE_SIZE_STR},
    {WIA_DPS_PAGE_WIDTH,                      WIA_DPS_PAGE_WIDTH_STR},
    {WIA_DPS_PAGE_HEIGHT,                     WIA_DPS_PAGE_HEIGHT_STR},
    {WIA_DPS_PREVIEW,                         WIA_DPS_PREVIEW_STR},
    {WIA_DPS_TRANSPARENCY,                    WIA_DPS_TRANSPARENCY_STR},
    {WIA_DPS_TRANSPARENCY_SELECT,             WIA_DPS_TRANSPARENCY_SELECT_STR},
    {WIA_DPS_SHOW_PREVIEW_CONTROL,            WIA_DPS_SHOW_PREVIEW_CONTROL_STR},
    {WIA_DPS_MIN_HORIZONTAL_SHEET_FEED_SIZE,  WIA_DPS_MIN_HORIZONTAL_SHEET_FEED_SIZE_STR},
    {WIA_DPS_MIN_VERTICAL_SHEET_FEED_SIZE,    WIA_DPS_MIN_VERTICAL_SHEET_FEED_SIZE_STR},
    {WIA_DPV_LAST_PICTURE_TAKEN,              WIA_DPV_LAST_PICTURE_TAKEN_STR},
    {WIA_DPV_IMAGES_DIRECTORY,                WIA_DPV_IMAGES_DIRECTORY_STR},
    {WIA_DPV_DSHOW_DEVICE_PATH,               WIA_DPV_DSHOW_DEVICE_PATH_STR},
    {WIA_DPF_MOUNT_POINT,                     WIA_DPF_MOUNT_POINT_STR},
    {WIA_IPA_ITEM_NAME,                       WIA_IPA_ITEM_NAME_STR},
    {WIA_IPA_FULL_ITEM_NAME,                  WIA_IPA_FULL_ITEM_NAME_STR},
    {WIA_IPA_ITEM_TIME,                       WIA_IPA_ITEM_TIME_STR},
    {WIA_IPA_ITEM_FLAGS,                      WIA_IPA_ITEM_FLAGS_STR},
    {WIA_IPA_ACCESS_RIGHTS,                   WIA_IPA_ACCESS_RIGHTS_STR},
    {WIA_IPA_DATATYPE,                        WIA_IPA_DATATYPE_STR},
    {WIA_IPA_DEPTH,                           WIA_IPA_DEPTH_STR},
    {WIA_IPA_PREFERRED_FORMAT,                WIA_IPA_PREFERRED_FORMAT_STR},
    {WIA_IPA_FORMAT,                          WIA_IPA_FORMAT_STR},
    {WIA_IPA_COMPRESSION,                     WIA_IPA_COMPRESSION_STR},
    {WIA_IPA_TYMED,                           WIA_IPA_TYMED_STR},
    {WIA_IPA_CHANNELS_PER_PIXEL,              WIA_IPA_CHANNELS_PER_PIXEL_STR},
    {WIA_IPA_BITS_PER_CHANNEL,                WIA_IPA_BITS_PER_CHANNEL_STR},
    {WIA_IPA_PLANAR,                          WIA_IPA_PLANAR_STR},
    {WIA_IPA_PIXELS_PER_LINE,                 WIA_IPA_PIXELS_PER_LINE_STR},
    {WIA_IPA_BYTES_PER_LINE,                  WIA_IPA_BYTES_PER_LINE_STR},
    {WIA_IPA_NUMBER_OF_LINES,                 WIA_IPA_NUMBER_OF_LINES_STR},
    {WIA_IPA_GAMMA_CURVES,                    WIA_IPA_GAMMA_CURVES_STR},
    {WIA_IPA_ITEM_SIZE,                       WIA_IPA_ITEM_SIZE_STR},
    {WIA_IPA_COLOR_PROFILE,                   WIA_IPA_COLOR_PROFILE_STR},
    {WIA_IPA_MIN_BUFFER_SIZE,                 WIA_IPA_MIN_BUFFER_SIZE_STR},
    {WIA_IPA_REGION_TYPE,                     WIA_IPA_REGION_TYPE_STR},
    {WIA_IPA_ICM_PROFILE_NAME,                WIA_IPA_ICM_PROFILE_NAME_STR},
    {WIA_IPA_APP_COLOR_MAPPING,               WIA_IPA_APP_COLOR_MAPPING_STR},
    {WIA_IPA_PROP_STREAM_COMPAT_ID,           WIA_IPA_PROP_STREAM_COMPAT_ID_STR},
    {WIA_IPA_FILENAME_EXTENSION,              WIA_IPA_FILENAME_EXTENSION_STR},
    {WIA_IPA_SUPPRESS_PROPERTY_PAGE,          WIA_IPA_SUPPRESS_PROPERTY_PAGE_STR},
    {WIA_IPC_THUMBNAIL,                       WIA_IPC_THUMBNAIL_STR},
    {WIA_IPC_THUMB_WIDTH,                     WIA_IPC_THUMB_WIDTH_STR},
    {WIA_IPC_THUMB_HEIGHT,                    WIA_IPC_THUMB_HEIGHT_STR},
    {WIA_IPC_AUDIO_AVAILABLE,                 WIA_IPC_AUDIO_AVAILABLE_STR},
    {WIA_IPC_AUDIO_DATA_FORMAT,               WIA_IPC_AUDIO_DATA_FORMAT_STR},
    {WIA_IPC_AUDIO_DATA,                      WIA_IPC_AUDIO_DATA_STR},
    {WIA_IPC_NUM_PICT_PER_ROW,                WIA_IPC_NUM_PICT_PER_ROW_STR},
    {WIA_IPC_SEQUENCE,                        WIA_IPC_SEQUENCE_STR},
    {WIA_IPC_TIMEDELAY,                       WIA_IPC_TIMEDELAY_STR},
    {WIA_IPS_CUR_INTENT,                      WIA_IPS_CUR_INTENT_STR},
    {WIA_IPS_XRES,                            WIA_IPS_XRES_STR},
    {WIA_IPS_YRES,                            WIA_IPS_YRES_STR},
    {WIA_IPS_XPOS,                            WIA_IPS_XPOS_STR},
    {WIA_IPS_YPOS,                            WIA_IPS_YPOS_STR},
    {WIA_IPS_XEXTENT,                         WIA_IPS_XEXTENT_STR},
    {WIA_IPS_YEXTENT,                         WIA_IPS_YEXTENT_STR},
    {WIA_IPS_PHOTOMETRIC_INTERP,              WIA_IPS_PHOTOMETRIC_INTERP_STR},
    {WIA_IPS_BRIGHTNESS,                      WIA_IPS_BRIGHTNESS_STR},
    {WIA_IPS_CONTRAST,                        WIA_IPS_CONTRAST_STR},
    {WIA_IPS_ORIENTATION,                     WIA_IPS_ORIENTATION_STR},
    {WIA_IPS_ROTATION,                        WIA_IPS_ROTATION_STR},
    {WIA_IPS_MIRROR,                          WIA_IPS_MIRROR_STR},
    {WIA_IPS_THRESHOLD,                       WIA_IPS_THRESHOLD_STR},
    {WIA_IPS_INVERT,                          WIA_IPS_INVERT_STR},
    {WIA_IPS_WARM_UP_TIME,                    WIA_IPS_WARM_UP_TIME_STR},
    {0,                                       L"Not a WIA property"}
};

#else

extern WIA_PROPID_TO_NAME g_wiaPropIdToName[];

#endif

#endif //WIAPROP_H_INCLUDED


//
//   Macro Helpers
//

#define WIA_PROP_LIST_COUNT(ppv) (((PROPVARIANT*)ppv)->cal.cElems - WIA_LIST_VALUES)

#define WIA_PROP_LIST_VALUE(ppv, index)                              \\
     ((index > ((PROPVARIANT*) ppv)->cal.cElems - WIA_LIST_VALUES) || (index < -WIA_LIST_NOM)) ?\\
     NULL :                                                          \\
     (((PROPVARIANT*) ppv)->vt == VT_UI1) ?                          \\
     ((PROPVARIANT*) ppv)->caub.pElems[WIA_LIST_VALUES + index] :    \\
     (((PROPVARIANT*) ppv)->vt == VT_UI2) ?                          \\
     ((PROPVARIANT*) ppv)->caui.pElems[WIA_LIST_VALUES + index] :    \\
     (((PROPVARIANT*) ppv)->vt == VT_UI4) ?                          \\
     ((PROPVARIANT*) ppv)->caul.pElems[WIA_LIST_VALUES + index] :    \\
     (((PROPVARIANT*) ppv)->vt == VT_I2) ?                           \\
     ((PROPVARIANT*) ppv)->cai.pElems[WIA_LIST_VALUES + index] :     \\
     (((PROPVARIANT*) ppv)->vt == VT_I4) ?                           \\
     ((PROPVARIANT*) ppv)->cal.pElems[WIA_LIST_VALUES + index] :     \\
     (((PROPVARIANT*) ppv)->vt == VT_R4) ?                           \\
     ((PROPVARIANT*) ppv)->caflt.pElems[WIA_LIST_VALUES + index] :   \\
     (((PROPVARIANT*) ppv)->vt == VT_R8) ?                           \\
     ((PROPVARIANT*) ppv)->cadbl.pElems[WIA_LIST_VALUES + index] :   \\
     (((PROPVARIANT*) ppv)->vt == VT_BSTR) ?                         \\
     (LONG)(((PROPVARIANT*) ppv)->cabstr.pElems[WIA_LIST_VALUES + index]) : \\
     NULL


//
//   End of Macro Helpers
//

#ifdef __cplusplus
};
#endif

//
// Reset packing
//
#include <poppack.h>

#endif // _WIADEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\wiaeventnotifier.h ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        3/24/2002
 *
 *  @doc    INTERNAL
 *
 *  @module WiaEventNotifier.h - Class definition file for <c WiaEventNotifier> |
 *
 *  This file contains the class definition for <c WiaEventNotifier>.  This is
 *  a server-side object used to manage run-time event notifications.
 *
 *****************************************************************************/

//
//  Defines
//

#define WiaEventNotifier_UNINIT_SIG   0x556E6557
#define WiaEventNotifier_INIT_SIG     0x496E6557
#define WiaEventNotifier_TERM_SIG     0x546E6557
#define WiaEventNotifier_DEL_SIG      0x446E6557

/*****************************************************************************
 *  
 *  @doc INTERNAL
 *  
 *  @class WiaEventNotifier | Manages run-time event notifications to registered clients
 *  
 *  @comm
 *  When WIA receives a device event, it needs to know which client to notify.
 *  Therefore, each client wishing to receive notifications registers with the 
 *  WIA Service.
 *
 *  The <c WiaEventNotifier> class manages this list of clients.  It is 
 *  responsible for notifiying these client when a relevant event occurs.
 *
 *****************************************************************************/
class WiaEventNotifier 
{
//@access Public members
public:

    // @cmember Constructor
    WiaEventNotifier();
    // @cmember Destructor
    virtual ~WiaEventNotifier();

    // @cmember Increment reference count
    virtual ULONG __stdcall AddRef();
    // @cmember Decrement reference count
    virtual ULONG __stdcall Release();

    // @cmember Initializer method
    HRESULT Initialize();

    // @cmember Add this client to our list of clients
    HRESULT AddClient(WiaEventClient *pWiaEventClient);
    // @cmember Remove client to our list of clients
    HRESULT RemoveClient(STI_CLIENT_CONTEXT ClientContext);

    // @cmember Returns the appropriate <c WiaEventClient> from its context
    WiaEventClient* GetClientFromContext(STI_CLIENT_CONTEXT ClientContext);
    // @cmember Marks the appropriate <c WiaEventClient> for later removal
    VOID MarkClientForRemoval(STI_CLIENT_CONTEXT ClientContext);

    // @cmember Walks the client list and notifies suitably registered clients of an event
    VOID NotifyClients(WiaEventInfo *pWiaEventInfo);
    // @cmember Walks the client list and removes any that are marked for removal
    VOID CleanupClientList();

    // @cmember CreateInstance method
    //static void CreateInstance();

//@access Private members
protected:

    // @cmember Checks whether the specified client is in the client list
    BOOL isRegisteredClient(STI_CLIENT_CONTEXT ClientContext);

    // @cmember Walks client list and releases all elements.
    VOID DestroyClientList();

    // @cmember Copies the client list.  Each client in the list is not addref'd.
    HRESULT CopyClientListNoAddRef(CSimpleLinkedList<WiaEventClient*> &newList);

    // @cmember Signature of class
    ULONG m_ulSig;

    // @cmember Ref count
    ULONG m_cRef;

    // @cmember List holding clients who are registered to receive notifications
    CSimpleLinkedList<WiaEventClient*> m_ListOfClients;

    // @cmember Synchronization primitive used to protect access to the list of client
    CRIT_SECT   m_csClientListSync;

    //
    //  Comments for member variables
    //
    // @mdata ULONG | WiaEventNotifier | m_ulSig | 
    //   The signature for this class, used for debugging purposes.
    //   Doing a <nl>"db [addr_of_class]"<nl> would yield one of the following
    //   signatures for this class:
    //   @flag WiaEventNotifier_UNINIT_SIG | 'WenU' - Object has not been successfully
    //       initialized
    //   @flag WiaEventNotifier_INIT_SIG | 'WenI' - Object has been successfully
    //       initialized
    //   @flag WiaEventNotifier_TERM_SIG | 'WenT' - Object is in the process of
    //       terminating.
    //    @flag WiaEventNotifier_INIT_SIG | 'WenD' - Object has been deleted 
    //       (destructor was called)
    //
    // @mdata ULONG | WiaEventNotifier | m_cRef | 
    //  The reference count for this class.  Used for lifetime 
    //  management.
    //
    // @mdata CSimpleLinkedList<lt>STI_CLIENT_CONTEXT<gt> | WiaEventNotifier | m_ListOfClients | 
    //  This member holds the list of clients who are registered to receive WIA event notifications.
    //
    //@mdata CRIT_SECT | WiaEventNotifier | m_csClientListSync |
    //  This is a wrapper for a syncronization primitive used to protect the client list.
    //
    
};

//
//  There is only one instance of the WiaEventNotifier
//
extern WiaEventNotifier *g_pWiaEventNotifier;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\wiadbg.h ===
#ifndef __WIADBG_H_INCLUDED
#define __WIADBG_H_INCLUDED

#if defined(DBG) || defined(_DEBUG) || defined(DEBUG)
#define WIA_DEBUG
#endif

#if defined(WIA_DEBUG)

// This will eliminate the warning "conditional expression is constant"
// that we get when compiling the do { ... } while (false) stuff in the
// debug macros when /W4 is set
#pragma warning(disable:4127)


    #define WIA_DEBUG_CREATE( hInstance, pszModuleName, bDisplayUi, bLogFile)\
    do\
    {\
        _global_pWiaDebugger = CWiaDebugger::Create( hInstance, pszModuleName, bDisplayUi, bLogFile );\
    } while (false)

    #define WIA_DEBUG_EXISTS() (_global_pWiaDebugger != NULL)

    #define WIA_DEBUG_DESTROY()\
    do\
    {\
        if (NULL != _global_pWiaDebugger) {\
            _global_pWiaDebugger->Destroy();\
            _global_pWiaDebugger = NULL;\
        }\
    } while (false)

    #define WIA_TRACE(args)\
    do\
    {\
        if (NULL != _global_pWiaDebugger)\
            _global_pWiaDebugger->WiaTrace args;\
    } while (false)

    #define WIA_ERROR(args)\
    do\
    {\
        if (NULL != _global_pWiaDebugger)\
            _global_pWiaDebugger->WiaError args;\
    } while (false)

    #define WIA_PRINT_COLOR(args)\
    do\
    {\
        if (NULL != _global_pWiaDebugger)\
            _global_pWiaDebugger->PrintColor args;\
    } while (false)

    #define WIA_SETFLAGS(flags)\
    do\
    {\
        if (NULL != _global_pWiaDebugger)\
            _global_pWiaDebugger->SetDebugFlags(flags);\
    } while (false)

    #define WIA_GETFLAGS(flags)\
    do\
    {\
        if (NULL != _global_pWiaDebugger)\
            flags = _global_pWiaDebugger->GetDebugFlags();\
    } while (false)

    #define WIA_SETFILEHANDLE(hndl)\
    do\
    {\
        if (NULL != _global_pWiaDebugger)\
            _global_pWiaDebugger->SetLogFileHandle;\
    } while (false)

#ifdef WINNT
    #define WIA_ASSERT(x)\
    do\
    {\
        if (!(x))\
        {\
            WIA_ERROR((TEXT("ASSERTION FAILED: %hs(%d): %hs"),__FILE__,__LINE__,#x));\
            DebugBreak();\
        }\
    }\
    while (false)
#else
    #define WIA_ASSERT(x)\
    do\
    {\
        if (!(x))\
        {\
            WIA_ERROR((TEXT("ASSERTION FAILED: %hs(%d): %hs"),__FILE__,__LINE__,#x));\
            _asm { int 3 };\
        }\
    }\
    while (false)
#endif

    #define WIA_PUSHFUNCTION(n)\
        CDebugFunctionPushPop _debugFunctionPushPop( &_global_pWiaDebugger, n )

    #define WIA_DECLARE_DEBUGGER()

    #define WIA_CHECK_HR(hr,fnc)\
    if (FAILED(hr))\
    {\
        WIA_ERROR((TEXT("%s failed, hr=0x%08X" ), fnc, hr));\
    }

    #define WIA_RETURN_HR(hr)\
    if (FAILED(hr))\
    {\
        WIA_ERROR((TEXT("Returning WiaError (hr=0x%08X)"),hr));\
    }\
    return hr;


#else

    #define WIA_DEBUG_CREATE(hInstance, pszModuleName, bDisplayUi, bLogFile)
    #define WIA_DEBUG_EXISTS() (0)
    #define WIA_DEBUG_DESTROY()
    #define WIA_TRACE(args)
    #define WIA_ERROR(args)
    #define WIA_PRINT_COLOR(args)
    #define WIA_SETFLAGS(flags)
    #define WIA_GETFLAGS(flags)
    #define WIA_SETFILEHANDLE(hndl)
    #define WIA_ASSERT(x)
    #define WIA_PUSHFUNCTION(n)
    #define WIA_DECLARE_DEBUGGER()
    #define WIA_CHECK_HR(hr,fnc)
    #define WIA_RETURN_HR(hr)        return hr;

#endif

class CWiaDebugger
{
private:
    HWND      m_hWnd;
    HANDLE    m_hLogFile;
    int       m_nStackLevel;
    TCHAR     m_szModuleName[MAX_PATH];
    BOOL      m_bDisplayUi;
    BOOL      m_bLogFile;
    HANDLE    m_hThread;
    HANDLE    m_hStartedEvent;
    DWORD     m_dwThreadId;
    int       m_nFlags;
    HINSTANCE m_hInstance;
    enum      { m_nBufferMax = 2048 };
private:
    CWiaDebugger( HINSTANCE hInstance, LPTSTR pszModuleName, BOOL bDisplayUi, BOOL bLogFile, HANDLE hStartedEvent );
    DWORD DebugLoop(void);
    static DWORD ThreadProc( LPVOID pParam );
public:
    ~CWiaDebugger(void);
    static CWiaDebugger * __stdcall Create( HINSTANCE hInstance, LPTSTR pszModuleName, BOOL bDisplayUi=TRUE, BOOL bLogFile=TRUE );

    void Destroy(void)
    {
        PostMessage( WM_CLOSE );
    }
    void PostMessage( UINT uMsg, WPARAM wParam=0, LPARAM lParam=0 )
    {
        if (m_hWnd)
            ::PostMessage( m_hWnd, uMsg, wParam, lParam );
        else PostThreadMessage( m_dwThreadId, uMsg, wParam, lParam );
    }
    const HANDLE ThreadHandle(void) const
    {
        return m_hThread;
    }

    HANDLE   SetLogFileHandle(HANDLE hFile);
    HANDLE   GetLogFileHandle(void);

    // Various forms of the WiaTrace commands
    void     WiaTrace( LPCWSTR lpszFormat, ... );
    void     WiaTrace( LPCSTR lpszFormat, ... );
    void     WiaTrace( HRESULT hr );

    // Various forms of the WiaError commands
    void     WiaError( LPCWSTR lpszFormat, ... );
    void     WiaError( LPCSTR lpszFormat, ... );
    void     WiaError( HRESULT hr );

    // Print in color
    void     PrintColor( COLORREF crColor, LPCWSTR lpszMsg );
    void     PrintColor( COLORREF crColor, LPCSTR lpszMsg );

    // Set the default debug level
    int      SetDebugFlags( int nDebugLevel );
    int      GetDebugFlags(void);

    // Call stack indenting
    int      PushLevel( LPCTSTR lpszFunctionName );
    int      PopLevel( LPCTSTR lpszFunctionName );
    int      GetStackLevel(void);

    enum
    {
        DebugNone            = 0x00000000,
        DebugToWindow        = 0x00000001,
        DebugToFile          = 0x00000002,
        DebugToDebugger      = 0x00000004,
        DebugPrintThreadId   = 0x00010000,
        DebugPrintModuleName = 0x00020000,
        DebugMaximum         = 0xFFFFFFFF
    };
protected:
    void   RouteString( LPWSTR lpszMsg, COLORREF nColor );
    void   RouteString( LPSTR lpszMsg, COLORREF nColor );
    void   WriteMessageToFile( LPTSTR lpszMsg );
    LPTSTR RemoveTrailingCrLf( LPTSTR lpszStr );
    LPSTR  UnicodeToAnsi( LPSTR lpszAnsi, LPTSTR lpszUnicode );
    LPTSTR AnsiToTChar( LPCSTR pszAnsi, LPTSTR pszTChar );
    LPTSTR WideToTChar( LPWSTR pszWide, LPTSTR pszTChar );
    int    AddString( const LPCTSTR sz, COLORREF cr );
    void   PrependString( LPTSTR lpszTgt, LPCTSTR lpszStr );
    void   PrependThreadId( LPTSTR lpszMsg );
    void   PrependModuleName( LPTSTR lpszMsg );
    void   InsertStackLevelIndent( LPTSTR lpszMsg, int nStackLevel );
};

class CDebugFunctionPushPop
{
    typedef (*CPushFunction)( LPCTSTR );
    typedef (*CPopFunction)( LPCTSTR );
    CWiaDebugger **m_ppDebugger;
    CPushFunction m_pfnPush;
    CPushFunction m_pfnPop;
    LPCTSTR m_lpszFunctionName;
public:
    CDebugFunctionPushPop( CWiaDebugger **ppDebugger, LPCTSTR lpszFunctionName=NULL )
        : m_ppDebugger(ppDebugger),
          m_lpszFunctionName(lpszFunctionName)
    {
        if (m_ppDebugger && *m_ppDebugger)
            (*m_ppDebugger)->PushLevel(m_lpszFunctionName);
    }
    ~CDebugFunctionPushPop(void)
    {
        if (m_ppDebugger && *m_ppDebugger)
            (*m_ppDebugger)->PopLevel(m_lpszFunctionName);
    }
};

#ifdef WIA_DEBUG
extern CWiaDebugger *_global_pWiaDebugger;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\wiaeventinfo.h ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        3/25/2002
 *
 *  @doc    INTERNAL
 *
 *  @module WiaEventInfo.h - Definition file for <c WiaEventInfo> |
 *
 *  This file contains the class definition for <c WiaEventInfo>.
 *
 *****************************************************************************/

//
//  Defines
//

/*****************************************************************************
 *  
 *  @doc INTERNAL
 *  
 *  @class WiaEventInfo | Class which holds WIA corresponding to a WIA event
 *  
 *  @comm
 *  This class contains all the necessary information that a client needs
 *  when receiving an event notification.
 *
 *****************************************************************************/
class WiaEventInfo 
{
//@access Public members
public:

    // @cmember Constructor
    WiaEventInfo();
    // @cmember Copy Constructor
    WiaEventInfo(WiaEventInfo *pWiaEventInfo);
    // @cmember Destructor
    virtual ~WiaEventInfo();

    // @cmember Increment reference count
    virtual ULONG __stdcall AddRef();
    // @cmember Decrement reference count
    virtual ULONG __stdcall Release();

    // @cmember Accessor method for m_guidEvent 
    GUID getEventGuid();
    // @cmember Accessor method for m_bstrEventDescription
    BSTR getEventDescription();
    // @cmember Accessor method for m_bstrDeviceID
    BSTR getDeviceID();                                      
    // @cmember Accessor method for m_bstrDeviceDescription
    BSTR getDeviceDescription();                             
    // @cmember Accessor method for m_bstrFullItemName
    BSTR getFullItemName();                                  
    // @cmember Accessor method for m_dwDeviceType           
    DWORD getDeviceType();                                   
    // @cmember Accessor method for m_ulEventType            
    ULONG getEventType();                                    
                                                             
    // @cmember Accessor method for m_guidEvent 
    VOID setEventGuid(GUID);                                 
    // @cmember Accessor method for m_bstrEventDescription
    VOID setEventDescription(WCHAR*);
    // @cmember Accessor method for m_bstrDeviceID
    VOID setDeviceID(WCHAR*);
    // @cmember Accessor method for m_bstrDeviceDescription
    VOID setDeviceDescription(WCHAR*);
    // @cmember Accessor method for m_bstrFullItemName
    VOID setFullItemName(WCHAR*);
    // @cmember Accessor method for m_dwDeviceType           
    VOID setDeviceType(DWORD);
    // @cmember Accessor method for m_ulEventType            
    VOID setEventType(ULONG);

//@access Private members
protected:

    // @cmember Ref count
    ULONG m_cRef;

    // @cmember The WIA Event guid
    GUID     m_guidEvent;
    // @cmember The description string for the event
    BSTR     m_bstrEventDescription;
    // @cmember The device which generated this event
    BSTR     m_bstrDeviceID;
    // @cmember The device description string
    BSTR     m_bstrDeviceDescription;
    // @cmember The name of the newly created item
    BSTR     m_bstrFullItemName;
    // @cmember The STI_DEVICE_TYPE
    DWORD    m_dwDeviceType;
    // @cmember The WIA event type
    ULONG    m_ulEventType;
    
    //
    //  Comments for member variables
    //
    // @mdata ULONG | WiaEventInfo | m_cRef | 
    //   The reference count for this class.  Used for lifetime 
    //   management.
    //
    // @mdata GUID | WiaEventInfo | m_guidEvent | 
    //   The WIA Event guid.
    //
    // @mdata BSTR | WiaEventInfo | m_bstrEventDescription | 
    //   The device which generated this event.
    //
    // @mdata BSTR | WiaEventInfo | m_bstrDeviceID | 
    //   The reference count for this class.  Used for lifetime 
    //   management.
    //
    // @mdata BSTR | WiaEventInfo | m_bstrDeviceDescription | 
    //   The device description string.
    //
    // @mdata BSTR | WiaEventInfo | m_bstrFullItemName | 
    //   The name of the newly created item, if one was created.
    //   For example, an event such as WIA_EVENT_ITEM_CREATED will have an
    //   item name, but most others will not.
    //
    // @mdata DWORD | WiaEventInfo | m_dwDeviceType | 
    //   The STI_DEVICE_TYPE.  Often, one is most interested in 
    //   the major device type (e.g. scanner,camera,video camera), and
    //   so the device typoe value must be split into its Major Type
    //   and sub-type values using the STI macros (GET_STIDEVICE_TYPE and
    //   GET_STIDEVICE_SUBTYPE)
    //
    // @mdata ULONG | WiaEventInfo | m_ulEventType | 
    //   The event type, as defined in wiadef.h.
    //
    // @mdata ULONG | WiaEventInfo | m_cRef | 
    //   The reference count for this class.  Used for lifetime 
    //   management.
    //
    // @mdata ULONG | WiaEventInfo | m_cRef | 
    //   The reference count for this class.  Used for lifetime 
    //   management.
    //
    // @mdata ULONG | WiaEventInfo | m_cRef | 
    //   The reference count for this class.  Used for lifetime 
    //   management.
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\wiacfact.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       WiaCFact.h
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        26 Dec, 1997
*
*  DESCRIPTION:
*   Declarations and definitions for Class factory.
*
*******************************************************************************/

typedef HRESULT (*FPCREATEINSTANCE)(const IID& iid, void** ppv);

// FACTORY_DATA - Information CFactory needs to create a component

typedef struct _FACTORY_DATA
{
    FPCREATEINSTANCE    CreateInstance; // Pointer to creating function.
    IClassFactory*      pIClassFactory; // Pointer to running class factory.
    DWORD               dwRegister;     // ID for running object.

    const CLSID* pclsid;                // The class ID for the component.
    const GUID*  plibid;                // Type library ID.

    // Registry strings:

    LPCTSTR szRegName;                   // Name of the component.
    LPCTSTR szProgID;                    // Program ID.
    LPCTSTR szVerIndProgID;              // Version-independent program ID.
    LPCTSTR szService;                   // Name of service.
    LPCTSTR szModuleFileName;            // Filename of module.

} FACTORY_DATA, *PFACTORY_DATA;

// Class Factory

class CFactory : public IClassFactory
{
public:
	// IUnknown
	virtual HRESULT __stdcall QueryInterface(const IID& iid, void** ppv) ;
	virtual ULONG   __stdcall AddRef() ;
	virtual ULONG   __stdcall Release() ;
	
	// IClassFactory
	virtual HRESULT __stdcall CreateInstance(IUnknown* pUnknownOuter,
	                                         const IID& iid,
                                             void** ppv) ;

    virtual HRESULT __stdcall LockServer(BOOL bLock) ; 

	// Constructor - Pass pointer to data of component to create.
    CFactory(const PFACTORY_DATA pFactoryData);

	// Destructor
	~CFactory() { }

	// Static FactoryData support functions

    // Helper function for CanUnloadNow
 	static BOOL IsLocked()
		{ return (s_cServerLocks > 0) ;}

	// Functions to [un]register all components
    static HRESULT RegisterUnregisterAll(
        PFACTORY_DATA   pFactoryData,
        UINT            uiFactoryDataCount,
        BOOLEAN         bRegister,
        BOOLEAN         bOutProc);

	// Function to determine if component can be unloaded
	static HRESULT CanUnloadNow() ;

	// Out-of-process server support

    static BOOL StartFactories(
        PFACTORY_DATA   pFactoryData,
        UINT            uiFactoryDataCount);

    static void StopFactories(
        PFACTORY_DATA   pFactoryData,
        UINT            uiFactoryDataCount);

	static DWORD s_dwThreadID ;

	// Shut down the application.
	static void CloseExe()
	{
		if (CanUnloadNow() == S_OK)
		{
			::PostThreadMessage(s_dwThreadID, WM_QUIT, 0, 0) ;
		}
	}

public:
	// Reference Count
	LONG m_cRef ;

	// Pointer to information about class this factory creates
    PFACTORY_DATA m_pFactoryData;

	// Count of locks
    static LONG s_cServerLocks;

	// Module handle
    static HMODULE s_hModule;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\wiaeventreceiver.h ===
/*****************************************************************************
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2002
 *
 *  AUTHOR:      ByronC
 *
 *  DATE:        3/30/2002
 *
 *  @doc    INTERNAL
 *
 *  @module WiaEventReceiver.h - Definitions for <c WiaEventReceiver> |
 *
 *  This file contains the class definition for <c WiaEventReceiver>.
 *
 *****************************************************************************/

//
//  Defines
//
#define WiaEventReceiver_UNINIT_SIG   0x55726557
#define WiaEventReceiver_INIT_SIG     0x49726557
#define WiaEventReceiver_TERM_SIG     0x54726557
#define WiaEventReceiver_DEL_SIG      0x44726557

/*****************************************************************************
 *  
 *  @doc INTERNAL
 *  
 *  @class WiaEventReceiver | This client-side class receives event notifications from the WIA service
 *  
 *  @comm
 *  There is a single instance of this class per client.  It is responsible 
 *  for letting the WIA service know that this client needs event notifications, 
 *  and it informs the WIA Service of the client's specific event 
 *  registrations/unregistrations.
 *
 *  When an event is received, it walks its list of registrations, and for 
 *  everyone that is a match for the current event, it uses the Callback 
 *  Interface stored in the registration info to notify the client of the event.
 *
 *  To shield this class from specifics related to a specific event notification
 *   transport machanism, it makes use of the <c ClientEventTransport> class.
 *
 *****************************************************************************/
class ClientEventTransport;
class WiaEventInfo;
class ClientEventRegistrationInfo;
class WiaEventReceiver 
{
//@access Public members
public:

    // @cmember Constructor
    WiaEventReceiver(ClientEventTransport *pClientEventTransport);
    // @cmember Destructor
    virtual ~WiaEventReceiver();

    // @cmember This method is called to start receiving notifications.  This method is idempotent.
    virtual HRESULT Start();

    // @cmember This method is called to stop receiving notifications.  This method is idempotent.
    virtual VOID Stop();

    // @cmember Make event callbacks to let this client know of an event notification
    virtual HRESULT NotifyCallbacksOfEvent(WiaEventInfo *pWiaEventInfo);

    // @cmember Informs service of client's specific registration/unregistration requests
    virtual HRESULT SendRegisterUnregisterInfo(ClientEventRegistrationInfo *pEventRegistrationInfo);

    // @cmember Procedure used to run the event thread  which waits for event notifications
    static DWORD WINAPI EventThreadProc(LPVOID lpParameter);

//@access Private members
private:

    // @cmember Walks event registration list and releases all elements.
    VOID DestroyRegistrationList();

    // @cmember Checks whether a semantically equal <c ClientEventRegistrationInfo> is in the list
    ClientEventRegistrationInfo* FindEqualEventRegistration(ClientEventRegistrationInfo *pEventRegistrationInfo);

    // @cmember Signature of class
    ULONG m_ulSig;

    // @cmember Ref count
    ULONG m_cRef;

    // @cmember Class used to implement the notification transport
    ClientEventTransport *m_pClientEventTransport;

    // @cmember List holding the client's event registration data
    CSimpleLinkedList<ClientEventRegistrationInfo*> m_ListOfEventRegistrations;

    // @cmember Handle to the thread we create to wait for event notifications.
    HANDLE m_hEventThread;

    // @cmember ID of the event thread we created.
    DWORD m_dwEventThreadID;

    // @cmember Synchronization primitive used to protect access to this class
    CRIT_SECT    m_csReceiverSync;

    // @cmember Signifies whether we are running or stopped
    BOOL         m_bIsRunning;

    //
    //  Comments for member variables
    //
    // @mdata ULONG | WiaEventReceiver | m_ulSig | 
    //   The signature for this class, used for debugging purposes.
    //   Doing a <nl>"db [addr_of_class]"<nl> would yield one of the following
    //   signatures for this class:
    //   @flag WiaEventReceiver_UNINIT_SIG | 'WerU' - Object has not been successfully
    //       initialized
    //   @flag WiaEventReceiver_INIT_SIG | 'WerI' - Object has been successfully
    //       initialized
    //   @flag WiaEventReceiver_TERM_SIG | 'WerT' - Object is in the process of
    //       terminating.
    //    @flag WiaEventReceiver_INIT_SIG | 'WerD' - Object has been deleted 
    //       (destructor was called)
    //
    // @mdata ULONG | WiaEventReceiver | m_cRef | 
    //   The reference count for this class.  Used for lifetime 
    //   management.
    //
    // @mdata ClientEventTransport* | WiaEventReceiver | m_pClientEventTransport | 
    //  Class used to implement the notification transport.  This extra layer of 
    //  abstraction is used to shield us from the implmentation details of various 
    //  transport mechanisms.  E.g. using AsyncRPC requires keeping track of 
    //  the RPC_ASYNC_STATE, which the <c WiaEventReceiver> doesn't need/want to deal
    //  with.
    //
    // @mdata CSimpleLinkedList<lt>ClientEventRegistrationInfo*<gt> | WiaEventReceiver | m_ListOfEventRegistrations | 
    //  List holding the client's event registration data.  When an event is received,
    //  we walk this list of registrations and make the callback for any that match.
    //  Each registration info also holds the callback interface pointer.
    //
    // @mdata HANDLE | WiaEventReceiver | m_hEventThread |
    //  Handle to the thread we create to wait for event notifications.  Notice that there
    //  is only one thread per client.  This thread waits on the event handle received from
    //  <mf ClientEventTransport::getNotificationHandle>.
    //
    // @mdata DWORD | WiaEventReceiver | m_dwEventThreadID |
    //  ID of the event thread we created.  This is used to store which thread should be actively
    //  waiting for event notifications.  It's conveivable, that in a multi-threaded application,
    //  many <mf WiaEventReceiver::Start>/<mf WiaEventReceiver::Stop> calls could be made very
    //  close together.  The possibility exists that one of the threads previously started, now stopped,
    //  has not completely shut down yet.  Therefore, each running thread checks its ID against this 
    //  thread id.  If they do not match, it means this thread is not the event thread, and should therefore
    //  exit.
    //
    // @mdata CRIT_SECT | WiaEventReceiver | m_csReceiverSync | 
    //  This synchronization class is used to ensure internal data entegrity.
    //
    // @mdata BOOL | WiaEventReceiver | m_bIsRunning | 
    //  Signifies whether we are running or stopped.  We are running if <mf WiaEventReceiver::Start>
    //  was called successfully.  We are stopped if we could not start, or <mf WiaEventReceiver::Stop>
    //  was called without a subsequent call to <mf WiaEventReceiver::Start>.
};

extern WiaEventReceiver g_WiaEventReceiver;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\wialog.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       WiaLog.h
*
*  VERSION:     1.0
*
*  AUTHOR:      CoopP
*
*  DATE:        20 Aug, 1999
*
*  DESCRIPTION:
*   Declarations and definitions for the WIA logging object.
*
*******************************************************************************/
#ifndef WIALOG_H
#define WIALOG_H

#include <wia.h>

// Flush state
#ifdef WINNT
    #define FLUSH_STATE FALSE
#else
//  Must be TRUE for Win9x
    #define FLUSH_STATE TRUE
#endif    

#define MAX_TEXT_BUFFER                1024
#define MAX_NAME_BUFFER                  64
#define NUM_BYTES_TO_LOCK_LOW          4096
#define NUM_BYTES_TO_LOCK_HIGH            0
#define WIA_MAX_LOG_SIZE            1000000
#define MAX_SIG_LEN                      64

// Type of logging
#define WIALOG_TRACE   0x00000001
#define WIALOG_WARNING 0x00000002
#define WIALOG_ERROR   0x00000004

// level of detail for TRACE logging
#define WIALOG_LEVEL1  1 // Entry and Exit point of each function/method
#define WIALOG_LEVEL2  2 // LEVEL 1, + traces within the function/method
#define WIALOG_LEVEL3  3 // LEVEL 1, LEVEL 2, and any extra debugging information
#define WIALOG_LEVEL4  4 // USER DEFINED data + all LEVELS of tracing

#define WIALOG_NO_RESOURCE_ID   0
#define WIALOG_NO_LEVEL         0


// format details for logging
#define WIALOG_ADD_TIME           0x00010000
#define WIALOG_ADD_MODULE         0x00020000
#define WIALOG_ADD_THREAD         0x00040000
#define WIALOG_ADD_THREADTIME     0x00080000
#define WIALOG_LOG_TOUI           0x00100000

#define WIALOG_MESSAGE_TYPE_MASK  0x0000ffff
#define WIALOG_MESSAGE_FLAGS_MASK 0xffff0000
#define WIALOG_CHECK_TRUNCATE_ON_BOOT   0x00000001

#define WIALOG_DEBUGGER           0x00000008
#define WIALOG_UI                 0x00000016

#define MAX_TRUNCATE_SIZE 350000

//
// NB!!! Move this to the IDL as soon as IWiaLogEx is in
//
// This struct is used to match a MethodId / MethodName pair
//

typedef struct _MapTableEntry {
    LONG    lSize;
    LONG    lMethodId;
    BSTR    bstrMethodName;
} MapTableEntry;

typedef struct _MappingTable {
    LONG            lSize;
    LONG            lNumEntries;
    MapTableEntry   *pEntries;
} MappingTable;

class CFactory;

class CWiaLog : public IWiaLog,
                public IWiaLogEx
{
public:

    //
    // IWiaLog public methods
    //

    static HRESULT CreateInstance(const IID& iid, void** ppv);

private:

    //
    // IUnknown methods
    //

    HRESULT _stdcall QueryInterface(const IID& iid, void** ppv);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();

    friend CFactory;

    //
    // Construction / Destruction
    //

    CWiaLog();
    ~CWiaLog();

    //
    // IWiaLog private methods (exposed to the client)
    //

    HRESULT _stdcall InitializeLog (LONG hInstance);
    HRESULT _stdcall Log    (LONG lFlags, LONG lResID, LONG lDetail, BSTR bstrText);
    HRESULT _stdcall hResult(HRESULT hr);

    //
    // IWiaLogEx private methods (exposed to the client)
    //

    HRESULT _stdcall InitializeLogEx     (BYTE* hInstance);
    HRESULT _stdcall LogEx               (LONG lMethodId, LONG lFlags, LONG lResID, LONG lDetail, BSTR bstrText);
    HRESULT _stdcall hResultEx           (LONG lMethodId, HRESULT hr);
    HRESULT _stdcall UpdateSettingsEx    (LONG lCount, LONG *plMethodIds);
    HRESULT _stdcall ExportMappingTableEx(MappingTable **ppTable);

    //
    // IWiaLog private methods (not exposed to the client)
    //

    HRESULT Initialize();
    HRESULT Trace  (BSTR bstrText, LONG lDetail = 0, LONG lMethodId = 0);
    HRESULT Warning(BSTR bstrText, LONG lMethodId = 0);
    HRESULT Error  (BSTR bstrText, LONG lMethodId = 0);

    //
    // IWiaLog private helpers (not exposed to the client)
    //

    BOOL OpenLogFile();
    VOID WriteStringToLog(LPTSTR pszTextBuffer,BOOL fFlush = FALSE);
    VOID WriteLogSessionHeader();

    BOOL QueryLoggingSettings();

    VOID ConstructText();
    BOOL FormatDLLName(HINSTANCE hInstance,TCHAR *pchBuffer,INT cbBuffer);
    BOOL FormatStdTime(const SYSTEMTIME *pstNow,TCHAR *pchBuffer);
    BOOL NeedsToBeFreed(BSTR* pBSTR);
    VOID ProcessTruncation();

    //
    // member variables
    //

    ULONG      m_cRef;                          // Reference count for this object.
    ITypeInfo* m_pITypeInfo;                    // Pointer to type information.

    DWORD      m_dwReportMode;                  // bit mask, describing which messages types get reported
    DWORD      m_dwMaxSize;                     // maximum size ( in bytes ) of LOG file
    HANDLE     m_hLogFile;                      // handle to active log file
    HINSTANCE  m_hInstance;                     // handle to caller's instance
    TCHAR      m_szFmtDLLName[MAX_NAME_BUFFER]; // calling DLL's name
    LONG       m_lDetail;                       // level of detailing for TRACE
    TCHAR      m_szLogFilePath[MAX_PATH];       // log file path
    BOOL       m_bLogToDebugger;                // log to the debugger
    BOOL       m_bLogToUI;                      // log to a UI, (window?)
    TCHAR      m_szKeyName[MAX_NAME_BUFFER];    // KEY name (registry)
    BOOL       m_bLoggerInitialized;            // Logger has valid data to function correctly
    TCHAR      m_szModeText[MAX_PATH * 2];     // Formatted logging text
    TCHAR      m_szTextBuffer[MAX_PATH];        // shared temporary text buffer
    TCHAR      m_szColumnHeader[MAX_PATH];      // column header information
    BOOL       m_bTruncate;                     // Truncate file on BOOT
    BOOL       m_bClear;                        // Clear Log file on BOOT
};

//
//  TEMPROARY ONLY!!!!
//  Define CWiaLogProc to be CWiaLogProcEx.  This is only until drivers are moved over to the new system!
//

#define CWiaLogProc CWiaLogProcEx

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\wiaintfc.h ===
/*++

Copyright (c) 1986-2002  Microsoft Corporation

Module Name:

    wiaintfc.h

Abstract:

    This module contains interface class GUID for WIA.

Revision History:


--*/


#ifndef _WIAINTFC_H_
#define _WIAINTFC_H_

//
// Set packing
//

#include <pshpack8.h>
#include <guiddef.h>

//
// GUID for Image class device interface.
//

DEFINE_GUID(GUID_DEVINTERFACE_IMAGE, 0x6bdd1fc6L, 0x810f, 0x11d0, 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f);

#endif // _WIAINTFC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\wiamonk.h ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1999
*
*  TITLE:       wiamonk.h
*
*  VERSION:     1.0
*
*  DATE:        10 Nov, 1999
*
*  DESCRIPTION:
*   This file describes the class used by WIA to imlement an instance moniker.
*
******************************************************************************/

class CWiaInstMonk : public IMoniker,
                     public IROTData
{
public:

    //
    //  Constructor, Destructor, Initialize
    //

    CWiaInstMonk();
    ~CWiaInstMonk();
    HRESULT _stdcall Initialize(LPOLESTR strName);

    //
	// IUnknown
    //

	HRESULT _stdcall QueryInterface(const IID& iid, void** ppv);
	ULONG   _stdcall AddRef();
	ULONG   _stdcall Release();

    //
    //  IROTData
    //

    HRESULT _stdcall GetComparisonData(
        BYTE *pbData,
        ULONG cbMax,   
        ULONG *pcbData);

    //
    // IMoniker
    //

    HRESULT _stdcall BindToObject(
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        REFIID riidResult,
        void **ppvResult);

    HRESULT _stdcall BindToStorage(
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        REFIID riid,
        void **ppvObj);

    HRESULT _stdcall Reduce(
        IBindCtx *pbc,
        DWORD dwReduceHowFar,
        IMoniker **ppmkToLeft,
        IMoniker **ppmkReduced);

    HRESULT _stdcall ComposeWith(
        IMoniker *pmkRight,
        BOOL fOnlyIfNotGeneric,
        IMoniker **ppmkComposite);

    HRESULT _stdcall Enum(
        BOOL fForward,
        IEnumMoniker **ppenumMoniker);

    HRESULT _stdcall IsEqual(
        IMoniker *pmkOtherMoniker);

    HRESULT _stdcall Hash(
        DWORD *pdwHash);

    HRESULT _stdcall IsRunning(
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        IMoniker *pmkNewlyRunning);

    HRESULT _stdcall GetTimeOfLastChange(
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        FILETIME *pFileTime);

    HRESULT _stdcall Inverse(
        IMoniker **ppmk);

    HRESULT _stdcall CommonPrefixWith(
        IMoniker *pmkOther,
        IMoniker **ppmkPrefix);

    HRESULT _stdcall RelativePathTo(
        IMoniker *pmkOther,
        IMoniker **ppmkRelPath);

    HRESULT _stdcall GetDisplayName(
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        LPOLESTR *ppszDisplayName);

    HRESULT _stdcall ParseDisplayName(
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        LPOLESTR pszDisplayName,
        ULONG    *pchEaten,
        IMoniker **ppmkOut);

    HRESULT _stdcall IsSystemMoniker(
        DWORD *pdwMksys);

    //
    //  IPersistStream
    //

    HRESULT _stdcall IsDirty();
    HRESULT _stdcall Load(IStream *pStm);
    HRESULT _stdcall Save(IStream *pStm, BOOL fClearDirty);
    HRESULT _stdcall GetSizeMax(ULARGE_INTEGER *pcbSize);

    //
    //  IPersist
    //

    HRESULT _stdcall GetClassID(LPCLSID pClassID);

private:
    LONG        m_cRef;
    BSTR        m_bstrName;
    IUnknown    *m_pIUnknownInner;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\wiapropui.h ===
#ifndef __WIAPROPUI_H_INCLUDED
#define __WIAPROPUI_H_INCLUDED

/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1999
*
*  TITLE:       WiaPropUI.H
*
*
*
*  DESCRIPTION:
*   Definitions and declarations for querying, displaying, and setting
*   WIA device and item properties
*
*******************************************************************************/


#include <objbase.h>

#ifdef __cplusplus
extern "C" {
#endif

 /* 83bbcbf3-b28a-4919-a5aa-73027445d672 */
// helper object for other WIA UI components
DEFINE_GUID (CLSID_WiaPropHelp, 0x83bbcbf3,0xb28a,0x4919,0xa5, 0xaa, 0x73, 0x02, 0x74, 0x45, 0xd6, 0x72);

DEFINE_GUID (IID_IWiaPropUI,  /* 7eed2e9b-acda-11d2-8080-00805f6596d2 */
    0x7eed2e9b,
    0xacda,
    0x11d2,
    0x80, 0x80, 0x00, 0x80, 0x5f, 0x65, 0x96, 0xd2
  );

// property sheet handler
DEFINE_GUID (CLSID_WiaPropUI,0x905667aa,0xacd6,0x11d2,0x80, 0x80,0x00,0x80,0x5f,0x65,0x96,0xd2);


#ifdef __cplusplus
}
#endif

// Define a structure for storing camera download options
typedef struct tagCamOptions
{
    BOOL bAutoCopy;        // TRUE if download should happen when camera is plugged in
    BOOL bShowUI;          // TRUE if the download should be interactive
    BOOL bDeleteFromDevice;// TRUE if images are removed from device after copy
    BOOL bCopyAsGroup;
    BSTR bstrDestination;  // path to default download site
    BSTR bstrAuthor;       // default image author
} CAMOPTIONS, *PCAMOPTIONS;

//
// Flags
//
#define PROPUI_DEFAULT            0
#define PROPUI_MODELESS           0
#define PROPUI_MODAL              1
#define PROPUI_READONLY           2




interface IWiaItem;
interface IWiaItem;

#undef INTERFACE
#define INTERFACE IWiaPropUI
//
// IWiaPropUI is meant to encapsulate the display and management of
// property sheets for camera and scanner devices, and for items saved
// in camera memory. Once a caller has a pointer to this interface, he can
// use it to open property sheets for multiple items; the implementation
// of the interface must support multiple active sheets and should also
// prevent duplicate sheets being displayed.
// Once the interface's ref count reaches zero, any open property sheets
// will be closed.
//
DECLARE_INTERFACE_(IWiaPropUI, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IWiaPropUI methods

    STDMETHOD(ShowItemProperties)(THIS_ HWND hParent, IN LPCWSTR szDeviceId, IN LPCWSTR szItem, DWORD dwFlags) PURE;
    STDMETHOD(GetItemPropertyPages) (THIS_ IWiaItem *pItem, IN OUT LPPROPSHEETHEADER ppsh);


};

#endif //__WIAPROPUI_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\wiaregst.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1999
*
*  TITLE:       wiaregst.h
*
*
*  DESCRIPTION:
*   Definition of registry paths for WIA and STI components.
*
*******************************************************************************/
#ifndef _WIAREGST_H_
#define _WIAREGST_H_


// These paths may be accessed by multiple components. Do not put paths to keys that only one
// component needs.


#define REGSTR_PATH_NAMESPACE_CLSID TEXT("CLSID\\{E211B736-43FD-11D1-9EFB-0000F8757FCD}")
#define REGSTR_PATH_USER_SETTINGS   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\WIA")
#define REGSTR_PATH_SHELL_USER_SETTINGS TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\WIA\\Shell")

// These values control what happens when a camera connects to the PC
#define REGSTR_VALUE_CONNECTACT  TEXT("Action")
#define REGSTR_VALUE_AUTODELETE  TEXT("DeleteOnSave")
#define REGSTR_VALUE_SAVEFOLDER  TEXT("DestinationFolder")
#define REGSTR_VALUE_USEDATE     TEXT("UseDate")
#ifndef NO_STI_REGSTR
#include "stiregi.h"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\wiatwcmp.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 1998-2001, MICROSOFT CORP.
*
*  FILE:        wiatwcmp.h
*
*  VERSION:     1.0
*
*  DATE:        6/01/2001
*
*  DESCRIPTION:
*    Defines TWAIN Compatibility Layer - Capability pass-through constants.
*    To support existing TWAIN applications that have private capabilities,
*    WIA drivers can utilize the Pass-through functionality.
*
*****************************************************************************/

#ifndef _WIATWCMP_H_
#define _WIATWCMP_H_

#define WiaItemTypeTwainCapabilityPassThrough   0x00020000

//**************************************************************************
//
// TWAIN capability pass-through
//
//**************************************************************************

//
// Escape code ranges 2001 - 3000 are reserved for future ESC_ commands
//

#define ESC_TWAIN_CAPABILITY                2001    // private TWAIN capability negotiation
#define ESC_TWAIN_PRIVATE_SUPPORTED_CAPS    2002    // query for supported private capabilities

typedef struct _TWAIN_CAPABILITY {
    LONG  lSize;    // size of TWAIN_CAPABILITY structure
    LONG  lMSG;     // TWAIN Message, MSG_GET, MSG_GETCURRENT, MSG_SET, etc..
    LONG  lCapID;   // id of capability to set or get
    LONG  lConType; // container type of capability
    LONG  lRC;      // TWAIN return code, TWRC_SUCCESS, TWRC_FAILURE, etc..
    LONG  lCC;      // TWAIN condition code, TWCC_SUCCESS, TWCC_BUMMER, etc..
    LONG  lDataSize;// data size
    BYTE  Data[1];  // first BYTE of data
}TWAIN_CAPABILITY,*PTWAIN_CAPABILITY;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\wiamdef.h ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998-1999
*
*  TITLE:       wiamdef.h
*
*  VERSION:     2.0
*
*  DATE:        28 July, 1999
*
*  DESCRIPTION:
*   Header file used to define WIA constants and globals.
*
******************************************************************************/

#pragma once

//
//  The following array of PROPIDs identifies properties that are ALWAYS
//  present in a WIA_PROPERTY_CONTEXT.  Drivers can specify additional
//  properties when creating a property context with wiasCreatePropContext.
//

#ifdef STD_PROPS_IN_CONTEXT

#define NUM_STD_PROPS_IN_CONTEXT 13
PROPID  WIA_StdPropsInContext[NUM_STD_PROPS_IN_CONTEXT] = {
    WIA_IPA_DATATYPE,
    WIA_IPA_DEPTH,
    WIA_IPS_XRES,
    WIA_IPS_XPOS,
    WIA_IPS_XEXTENT,
    WIA_IPA_PIXELS_PER_LINE,
    WIA_IPS_YRES,
    WIA_IPS_YPOS,
    WIA_IPS_YEXTENT,
    WIA_IPA_NUMBER_OF_LINES,
    WIA_IPS_CUR_INTENT,
    WIA_IPA_TYMED,
    WIA_IPA_FORMAT,
    };
#endif

//**************************************************************************
//
//  WIA Service prototypes
//
//
// History:
//
//    4/27/1999 - Initial Version
//
//**************************************************************************

// Flag used by wiasGetImageInformation.

#define WIAS_INIT_CONTEXT 1

// Flag used by wiasDownSampleBuffer

#define WIAS_GET_DOWNSAMPLED_SIZE_ONLY 0x1

//
// IWiaMiniDrvService methods
//

#ifdef __cplusplus
extern "C" {
#endif

HRESULT _stdcall wiasCreateDrvItem(LONG, BSTR, BSTR, IWiaMiniDrv*, LONG, BYTE**, IWiaDrvItem**);
HRESULT _stdcall wiasGetImageInformation(BYTE*, LONG, PMINIDRV_TRANSFER_CONTEXT);
HRESULT _stdcall wiasWritePageBufToFile(PMINIDRV_TRANSFER_CONTEXT);
HRESULT _stdcall wiasWriteBufToFile(LONG, PMINIDRV_TRANSFER_CONTEXT);
HRESULT _stdcall wiasReadMultiple(BYTE*, ULONG, const PROPSPEC*, PROPVARIANT*, PROPVARIANT*);
HRESULT _stdcall wiasReadPropStr(BYTE*, PROPID, BSTR*, BSTR*, BOOL);
HRESULT _stdcall wiasReadPropLong(BYTE*, PROPID, LONG*, LONG*, BOOL);
HRESULT _stdcall wiasReadPropFloat(BYTE*, PROPID, FLOAT*, FLOAT*, BOOL);
HRESULT _stdcall wiasReadPropGuid(BYTE*, PROPID, GUID*, GUID*, BOOL);
HRESULT _stdcall wiasReadPropBin(BYTE*, PROPID, BYTE**, BYTE**, BOOL);
HRESULT _stdcall wiasWriteMultiple(BYTE*, ULONG, const PROPSPEC*, const PROPVARIANT*);
HRESULT _stdcall wiasWritePropStr(BYTE*, PROPID, BSTR);
HRESULT _stdcall wiasWritePropLong(BYTE*, PROPID, LONG);
HRESULT _stdcall wiasWritePropFloat(BYTE*, PROPID, FLOAT);
HRESULT _stdcall wiasWritePropGuid(BYTE*, PROPID, GUID);
HRESULT _stdcall wiasWritePropBin(BYTE*, PROPID, LONG, BYTE*);
HRESULT _stdcall wiasGetPropertyAttributes(BYTE*, LONG, PROPSPEC*, ULONG*,  PROPVARIANT*);
HRESULT _stdcall wiasSetPropertyAttributes(BYTE*, LONG, PROPSPEC*, ULONG*,  PROPVARIANT*);
HRESULT _stdcall wiasSetItemPropNames(BYTE*, LONG, PROPID*, LPOLESTR*);
HRESULT _stdcall wiasSetItemPropAttribs(BYTE*, LONG, PROPSPEC*, PWIA_PROPERTY_INFO);
HRESULT _stdcall wiasValidateItemProperties(BYTE*, ULONG, const PROPSPEC*);
HRESULT _stdcall wiasSendEndOfPage(BYTE*, LONG, PMINIDRV_TRANSFER_CONTEXT);
HRESULT _stdcall wiasGetItemType(BYTE*, LONG*);
HRESULT _stdcall wiasGetDrvItem(BYTE*, IWiaDrvItem**);
HRESULT _stdcall wiasGetRootItem(BYTE*, BYTE**);

HRESULT _stdcall wiasSetValidFlag(BYTE*,         PROPID, ULONG, ULONG);
HRESULT _stdcall wiasSetValidRangeLong(BYTE*,    PROPID, LONG,  LONG,   LONG,   LONG);
HRESULT _stdcall wiasSetValidRangeFloat(BYTE*,   PROPID, FLOAT, FLOAT,  FLOAT,  FLOAT);
HRESULT _stdcall wiasSetValidListLong(BYTE*,     PROPID, ULONG, LONG,  LONG*);
HRESULT _stdcall wiasSetValidListFloat(BYTE*,    PROPID, ULONG, FLOAT, FLOAT*);
HRESULT _stdcall wiasSetValidListGuid(BYTE*,    PROPID, ULONG, GUID, GUID*);
HRESULT _stdcall wiasSetValidListStr(BYTE*,      PROPID, ULONG, BSTR,  BSTR*);

HRESULT _stdcall wiasCreatePropContext(ULONG, PROPSPEC*, ULONG, PROPID*, WIA_PROPERTY_CONTEXT*);
HRESULT _stdcall wiasFreePropContext(WIA_PROPERTY_CONTEXT*);
HRESULT _stdcall wiasIsPropChanged(PROPID, WIA_PROPERTY_CONTEXT*, BOOL*);
HRESULT _stdcall wiasSetPropChanged(PROPID, WIA_PROPERTY_CONTEXT*, BOOL);
HRESULT _stdcall wiasGetChangedValueLong(BYTE*,  WIA_PROPERTY_CONTEXT*, BOOL, PROPID, WIAS_CHANGED_VALUE_INFO*);
HRESULT _stdcall wiasGetChangedValueFloat(BYTE*, WIA_PROPERTY_CONTEXT*, BOOL, PROPID, WIAS_CHANGED_VALUE_INFO*);
HRESULT _stdcall wiasGetChangedValueGuid(BYTE*, WIA_PROPERTY_CONTEXT*, BOOL, PROPID, WIAS_CHANGED_VALUE_INFO*);
HRESULT _stdcall wiasGetChangedValueStr(BYTE*,   WIA_PROPERTY_CONTEXT*, BOOL, PROPID, WIAS_CHANGED_VALUE_INFO*);

HRESULT _stdcall wiasGetContextFromName(BYTE*, LONG, BSTR, BYTE**);

HRESULT _stdcall wiasUpdateScanRect(BYTE*, WIA_PROPERTY_CONTEXT*, LONG, LONG);
HRESULT _stdcall wiasUpdateValidFormat(BYTE*, WIA_PROPERTY_CONTEXT*, IWiaMiniDrv*);

HRESULT _stdcall wiasGetChildrenContexts(BYTE*, ULONG*, BYTE***);

HRESULT _stdcall wiasQueueEvent(BSTR, const GUID*, BSTR);

VOID    __cdecl   wiasDebugTrace(HINSTANCE, LPCSTR, ...);
VOID    __cdecl   wiasDebugError(HINSTANCE, LPCSTR, ...);
VOID    __stdcall wiasPrintDebugHResult(HINSTANCE, HRESULT);

BSTR    __cdecl   wiasFormatArgs(LPCSTR lpszFormat, ...);

HRESULT _stdcall wiasCreateChildAppItem(BYTE*, LONG, BSTR, BSTR, BYTE**);

HRESULT _stdcall wiasCreateLogInstance(BYTE*, IWiaLogEx**);
HRESULT _stdcall wiasDownSampleBuffer(LONG, WIAS_DOWN_SAMPLE_INFO*);
HRESULT _stdcall wiasParseEndorserString(BYTE*, LONG, WIAS_ENDORSER_INFO*, BSTR*);

#ifndef WIA_MAP_OLD_DEBUG

#if defined(_DEBUG) || defined(DBG) || defined(WIA_DEBUG)

#define WIAS_TRACE(x) wiasDebugTrace x
#define WIAS_ERROR(x) wiasDebugError x
#define WIAS_HRESULT(x) wiasPrintDebugHResult x
#define WIAS_ASSERT(x, y) \
        if (!(y)) { \
            WIAS_ERROR((x, (char*) TEXT("ASSERTION FAILED: %hs(%d): %hs"), __FILE__,__LINE__,#x)); \
            DebugBreak(); \
        }

#else

#define WIAS_TRACE(x)
#define WIAS_ERROR(x)
#define WIAS_HRESULT(x)
#define WIAS_ASSERT(x, y)

#endif

#define WIAS_LTRACE(pILog,ResID,Detail,Args) \
         { if ( pILog ) \
            pILog->Log(WIALOG_TRACE, ResID, Detail, wiasFormatArgs Args);\
         };
#define WIAS_LERROR(pILog,ResID,Args) \
         {if ( pILog )\
            pILog->Log(WIALOG_ERROR, ResID, WIALOG_NO_LEVEL, wiasFormatArgs Args);\
         };
#define WIAS_LWARNING(pILog,ResID,Args) \
         {if ( pILog )\
            pILog->Log(WIALOG_WARNING, ResID, WIALOG_NO_LEVEL, wiasFormatArgs Args);\
         };
#define WIAS_LHRESULT(pILog,hr) \
         {if ( pILog )\
            pILog->hResult(hr);\
         };

//
// IWiaLog Defines
//

// Type of logging
#define WIALOG_TRACE   0x00000001
#define WIALOG_WARNING 0x00000002
#define WIALOG_ERROR   0x00000004

// level of detail for TRACE logging
#define WIALOG_LEVEL1  1 // Entry and Exit point of each function/method
#define WIALOG_LEVEL2  2 // LEVEL 1, + traces within the function/method
#define WIALOG_LEVEL3  3 // LEVEL 1, LEVEL 2, and any extra debugging information
#define WIALOG_LEVEL4  4 // USER DEFINED data + all LEVELS of tracing

#define WIALOG_NO_RESOURCE_ID   0
#define WIALOG_NO_LEVEL         0

//
// Entering / Leaving class
//

class CWiaLogProc {
private:
    CHAR   m_szMessage[MAX_PATH];
    IWiaLog *m_pIWiaLog;
    INT     m_DetailLevel;
    INT     m_ResourceID;

public:
    inline CWiaLogProc(IWiaLog *pIWiaLog, INT ResourceID, INT DetailLevel, CHAR *pszMsg) {
        ZeroMemory(m_szMessage, sizeof(m_szMessage));
        lstrcpynA(m_szMessage,pszMsg, sizeof(m_szMessage) / sizeof(m_szMessage[0]) - 1);
        m_pIWiaLog = pIWiaLog;
        m_DetailLevel = DetailLevel;
        m_ResourceID = ResourceID;
        WIAS_LTRACE(pIWiaLog,
                    ResourceID,
                    DetailLevel,
                    ("%s, entering",m_szMessage));
    }

    inline ~CWiaLogProc() {
        WIAS_LTRACE(m_pIWiaLog,
                    m_ResourceID,
                    m_DetailLevel,
                    ("%s, leaving",m_szMessage));
    }
};

class CWiaLogProcEx {
private:
    CHAR        m_szMessage[MAX_PATH];
    IWiaLogEx   *m_pIWiaLog;
    INT         m_DetailLevel;
    INT         m_ResourceID;

public:
    inline CWiaLogProcEx(IWiaLogEx *pIWiaLog, INT ResourceID, INT DetailLevel, CHAR *pszMsg, LONG lMethodId = 0) {
        ZeroMemory(m_szMessage, sizeof(m_szMessage));
        lstrcpynA(m_szMessage,pszMsg, sizeof(m_szMessage) / sizeof(m_szMessage[0]) - 1);
        m_pIWiaLog = pIWiaLog;
        m_DetailLevel = DetailLevel;
        m_ResourceID = ResourceID;
        WIAS_LTRACE(pIWiaLog,
                    ResourceID,
                    DetailLevel,
                    ("%s, entering",m_szMessage));
    }

    inline ~CWiaLogProcEx() {
        WIAS_LTRACE(m_pIWiaLog,
                    m_ResourceID,
                    m_DetailLevel,
                    ("%s, leaving",m_szMessage));
    }
};

#endif // WIA_MAP_OLD_DEBUG


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\wiamicro.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 1999-2000, MICROSOFT CORP.
*
*  FILE:        wiamicro.h
*
*  VERSION:     3.0
*
*  DESCRIPTION:
*    Definitions to support WIA scanner and camera microdrivers.
*
*****************************************************************************/

#pragma once

#include <SCSISCAN.H>

#define WIAMICRO_API __declspec(dllexport)

#include <pshpack8.h>

/****************************************************************************\
* Scanner microdriver definitions
\****************************************************************************/

//
// Private #defines
//

#define MAX_IO_HANDLES 16
#define MAX_RESERVED    4
#define MAX_ANSI_CHAR 255

//
// Common BUS types
//

#define BUS_TYPE_SCSI         200
#define BUS_TYPE_USB          201
#define BUS_TYPE_PARALLEL     202
#define BUS_TYPE_FIREWIRE     203

//
// command list
//

#define SCAN_FIRST             10
#define SCAN_NEXT              20
#define SCAN_FINISHED          30

#define SCANMODE_FINALSCAN     0
#define SCANMODE_PREVIEWSCAN   1

#define CMD_INITIALIZE        100
#define CMD_UNINITIALIZE      101
#define CMD_SETXRESOLUTION    102
#define CMD_SETYRESOLUTION    103
#define CMD_SETCONTRAST       104
#define CMD_SETINTENSITY      105
#define CMD_SETDATATYPE       106
#define CMD_SETDITHER         107
#define CMD_SETMIRROR         108
#define CMD_SETNEGATIVE       109
#define CMD_SETTONEMAP        110
#define CMD_SETCOLORDITHER    111
#define CMD_SETMATRIX         112
#define CMD_SETSPEED          113
#define CMD_SETFILTER         114
#define CMD_LOAD_ADF          115
#define CMD_UNLOAD_ADF        116
#define CMD_GETADFAVAILABLE   117
#define CMD_GETADFOPEN        118
#define CMD_GETADFREADY       119
#define CMD_GETADFHASPAPER    120
#define CMD_GETADFSTATUS      121
#define CMD_GETADFUNLOADREADY 122
#define CMD_GETTPAAVAILABLE   123
#define CMD_GETTPAOPENED      124
#define CMD_TPAREADY          125
#define CMD_SETLAMP           126
#define CMD_SENDSCSICOMMAND   127
#define CMD_STI_DEVICERESET   128
#define CMD_STI_GETSTATUS     129
#define CMD_STI_DIAGNOSTIC    130
#define CMD_RESETSCANNER      131
#define CMD_GETCAPABILITIES   132
#define CMD_GET_INTERRUPT_EVENT 133
#define CMD_SETGSDNAME        134
#define CMD_SETSCANMODE       135
#define CMD_SETSTIDEVICEHKEY  136
#define CMD_GETSUPPORTEDFILEFORMATS 138
#define CMD_GETSUPPORTEDMEMORYFORMATS 139
#define CMD_SETFORMAT   140

#define SUPPORT_COLOR      0x00000001
#define SUPPORT_BW         0x00000002
#define SUPPORT_GRAYSCALE  0x00000004

//
// Error Codes
//

#define MCRO_ERROR_GENERAL_ERROR     0 // All lVal values are initialized to '0'
#define MCRO_STATUS_OK               1 // General success status return
#define MCRO_ERROR_PAPER_JAM         2 // ADF has a paper Jam
#define MCRO_ERROR_PAPER_PROBLEM     3 // ADF has a paper problem
#define MCRO_ERROR_PAPER_EMPTY       4 // ADF has no paper
#define MCRO_ERROR_OFFLINE           5 // ADF or Device is offline
#define MCRO_ERROR_USER_INTERVENTION 6 // User needs to interact with the physical device

//
// WIA compatible #defines
//

#define WIA_PACKED_PIXEL         0
#define WIA_PLANAR               1

#define WIA_ORDER_RGB            0
#define WIA_ORDER_BGR            1

#define WIA_DATA_THRESHOLD       0
#define WIA_DATA_DITHER          1
#define WIA_DATA_GRAYSCALE       2
#define WIA_DATA_COLOR           3
#define WIA_DATA_COLOR_THRESHOLD 4
#define WIA_DATA_COLOR_DITHER    5

//
// structure definitions
//

typedef struct _RANGEVALUE {
    LONG lMin;                  // minimum value
    LONG lMax;                  // maximum value
    LONG lStep;                 // increment/step value
} RANGEVALUE, *PRANGEVALUE;

typedef struct _SCANWINDOW {
    LONG xPos;                  // X position (left)
    LONG yPos;                  // Y position (top)
    LONG xExtent;               // X extent   (right)
    LONG yExtent;               // Y extent   (bottom)
} SCANWINDOW, *PSCANWINDOW;

typedef struct _SCANINFO {
    // Common Scanner specs
    LONG ADF;                   // (0 - no support,  1 - supported, 2 - supported and It can duplex)
    LONG TPA;                   // (0 - no support,  1 - supported)
    LONG Endorser;              // (0 - no endorser, 1 - supported)
    LONG OpticalXResolution;    // (dpi setting of optics)
    LONG OpticalYResolution;    // (dpi setting of optics)
    LONG BedWidth;              // (bed width in 1000's of an inch)
    LONG BedHeight;             // (bed height in 1000's of an inch)
    RANGEVALUE IntensityRange;  // (Intensity/Brightness ranges)
    RANGEVALUE ContrastRange;   // (Contrast ranges)
    LONG SupportedCompressionType; // (mask of supported compression types, 0 - None)
    LONG SupportedDataTypes;    // (mask of supported types, (ie. SUPPORT_COLOR|SUPPORT_BW...))
    // Current Image Info
    LONG WidthPixels;           // (width of image, using current scanner settings in pixels)
    LONG WidthBytes;            // (width of image, using current scanner settings in bytes)
    LONG Lines;                 // (height of image, using current scanner settings in pixles)
    LONG DataType;              // (current data type set)
    LONG PixelBits;             // (current bit depth setting)
    // Current Scanner settings
    LONG Intensity;             // (current Intensity/Brightness setting)
    LONG Contrast;              // (current contrast setting)
    LONG Xresolution;           // (current X Resolution)
    LONG Yresolution;           // (current Y Resolution
    SCANWINDOW Window;          // (current scanner window settings)
    // Scanner options
    LONG DitherPattern;
    LONG Negative;              // (0 - off,        1 - Negative is on)
    LONG Mirror;                // (0 - off,        1 - Mirror is on)
    LONG AutoBack;              // (0 - off,        1 - AutoBack is on)
    LONG ColorDitherPattern;    // (dither pattern??)
    LONG ToneMap;               // (tone map ??)
    LONG Compression;           // (0 - off,        1 - Compression is on)
    LONG RawDataFormat;         // (0 - Packed data 1 - Planar data)
    LONG RawPixelOrder;         // (0 - RGB,        1 - BGR)
    LONG bNeedDataAlignment;    // (0 - FALSE,      1 - TRUE)
    LONG DelayBetweenRead;      // delay between WIA Scan() calls requesting data (milliseconds)
    LONG MaxBufferSize;         // maximum buffer size in scanner
    HANDLE DeviceIOHandles[MAX_IO_HANDLES]; // Device IO handles needed for device communication
    LONG lReserved[MAX_RESERVED]; // (silly reserved bits)
    VOID *pMicroDriverContext;  // private data for Micro driver's only.
                                // The Micro Driver is responsible for allocating and freeing.
                                // CMD_INITIALIZE - allocate, CMD_UNINITIALIZE - free
}SCANINFO, *PSCANINFO;

typedef struct VAL {
        LONG      lVal;             // long value
        double    dblVal;           // float/double value
        GUID     *pGuid;            // GUID pointer
        PSCANINFO pScanInfo;        // pointer to the shared ScanInfo struct
        HGLOBAL   handle;           // handle value
        WCHAR   **ppButtonNames;    // pointer to button names array
        HANDLE   *pHandle;          // pointer to a Handle value
        LONG      lReserved;        // lone value
        CHAR   szVal[MAX_ANSI_CHAR];// ANSI string
}VAL, *PVAL;

//
// Micro driver entry points
//

WIAMICRO_API HRESULT MicroEntry(LONG lCommand, PVAL pValue);
WIAMICRO_API HRESULT Scan(PSCANINFO pScanInfo, LONG lPhase, PBYTE pBuffer, LONG lLength, LONG *plReceived);
WIAMICRO_API HRESULT SetPixelWindow(PSCANINFO pScanInfo, LONG x, LONG y, LONG xExtent, LONG yExtent);

//
// optional debug trace
//

VOID Trace(LPCTSTR Format, ...);

#include <poppack.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\inc\wiautil.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        wiautil.h
*
*  VERSION:     1.0
*
*  DATE:        11/17/2000
*
*  DESCRIPTION:
*    Definitions for WIA driver helper classes and functions.
*    NOTE: This header requires wiamindr.h to be included.
*
*****************************************************************************/

#pragma once

/**************************************************************************\
* CWiauFormatConverter
*
*   Helper class for converting images to BMP format.
*
\**************************************************************************/

typedef struct _BMP_IMAGE_INFO
{
    INT     Width;      // Width of the image in pixels
    INT     Height;     // Height of the image in lines
    INT     ByteWidth;  // Width of the image in bytes
    INT     Size;       // Total size of the image, including headers
} BMP_IMAGE_INFO, *PBMP_IMAGE_INFO;

typedef enum
{
    SKIP_OFF,
    SKIP_FILEHDR,
    SKIP_BOTHHDR

} SKIP_AMOUNT;

class CWiauFormatConverter
{
public:
    CWiauFormatConverter();
    ~CWiauFormatConverter();

    /**************************************************************************\
    * Init
    *
    *   Intializes this class and GDI+ for converting images. This method
    *   should be called just once.
    *
    \**************************************************************************/

    HRESULT Init();


    /**************************************************************************\
    * IsFormatSupported
    *
    *   This method will verify that GDI+ supports the image format
    *   that is to be converted.
    *
    * Arguments:
    *
    *   pguidFormat - pointer to GUID format from gdiplusimaging.h
    *
    \**************************************************************************/

    BOOL IsFormatSupported(const GUID *pguidFormat);


    /**************************************************************************\
    * ConvertToBmp
    *
    *   This method will convert an image to BMP format. The caller can pass
    *   a result buffer in ppDest and the size in piDestSize. Alternatively
    *   the caller can set *ppDest to NULL and *piDestSize to zero to
    *   indicate that this method should allocate the memory. The caller is
    *   responsible for freeing the memory with "delete []".
    *
    * Arguments:
    *
    *    pSource         - pointer to memory location of source image
    *    iSourceSize     - size of source image
    *    ppDest          - location to receive memory location of result image
    *    piDestSize      - location to receive size of result image
    *    pBmpImageInfo   - location to receive stats about the BMP
    *    iSkipAmt        - Indicates how much of the BMP header to skip:
    *                       SKIP_OFF     = skip neither header
    *                       SKIP_FILEHDR = skip the file header
    *                       SKIP_BOTHHDR = skip the file and info headers
    *
    \**************************************************************************/

    HRESULT ConvertToBmp(BYTE *pSource, INT iSourceSize, BYTE **ppDest, INT *piDestSize,
                         BMP_IMAGE_INFO *pBmpImageInfo, SKIP_AMOUNT iSkipAmt = SKIP_OFF);


private:
    ULONG_PTR   m_Token;
    UINT        m_EncoderCount;
    BYTE       *m_pEncoderInfo;
    GUID        m_guidCodecBmp;
};


/**************************************************************************\
* CWiauPropertyList
*
*   Helper class for definining and initializing WIA properties
*
\**************************************************************************/

class CWiauPropertyList
{
private:

    int                  m_NumAlloc;    // number of slots allocated
    int                  m_NumProps;    // number of properties defined
    PROPID              *m_pId;         // property ids
    LPOLESTR            *m_pNames;      // property names
    PROPVARIANT         *m_pCurrent;    // current value
    PROPSPEC            *m_pPropSpec;   // property spec (used for WriteMultiple)
    WIA_PROPERTY_INFO   *m_pAttrib;     // property attributes

public:

    CWiauPropertyList();
    ~CWiauPropertyList();
    
    /**************************************************************************\
    * Init
    *
    *   Initializes the property info object.
    *
    * Arguments:
    *   NumProps - number of properties to reserve space for. This number can
    *              be larger than the actual number used, but cannot be smaller.
    *
    \**************************************************************************/
    
    HRESULT Init(INT NumProps);
    
    
    /**************************************************************************\
    * DefineProperty
    *
    *   Adds a property definition to the object.
    *
    * Arguments:
    *   index    - pointer to an int that will be set to the property index
    *              within the object, useful for passing to other property
    *              info methods
    *   PropId   - property ID constant
    *   PropName - property name string
    *   Access   - determines access to the property, usually either
    *              WIA_PROP_READ or WIA_PROP_RW
    *   SubType  - indicates subtype of the property, usually either
    *              WIA_PROP_NONE, WIA_PROP_FLAG, WIA_PROP_RANGE, or WIA_PROP_LIST
    *
    \**************************************************************************/

    HRESULT DefineProperty(int *pIdx, PROPID PropId, LPOLESTR PropName,
                           ULONG Access, ULONG SubType);
    
    
    /**************************************************************************\
    * SendToWia
    *
    *   Calls the WIA service to define all of the properties currently
    *   contained in the object. Should be called once after all properties
    *   are defined and set.
    *
    * Arguments:
    *   pWiasContext - pointer to the context passed into drvInitItemProperties
    *
    \**************************************************************************/
    
    HRESULT SendToWia(BYTE *pWiasContext);
    
    
    /**************************************************************************\
    * SetAccessSubType
    *
    *   Used to reset the access and subtype of a property.
    *
    * Arguments:
    *   index   - the property index, from DefineProperty
    *   Access  - determines access to the property, usually either
    *             WIA_PROP_READ or WIA_PROP_RW
    *   SubType - indicates subtype of the property, usually either
    *             WIA_PROP_NONE, WIA_PROP_FLAG, WIA_PROP_RANGE, or WIA_PROP_LIST
    *
    \**************************************************************************/
    
    HRESULT SetAccessSubType(INT index, ULONG Access, ULONG SubType);
    
    
    /**************************************************************************\
    * SetValidValues (flag)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_I4 and subtype to WIA_PROP_FLAG.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   validFlags   - combination of all valid flags
    *
    \**************************************************************************/
    
    HRESULT SetValidValues(INT index, LONG defaultValue, LONG currentValue, LONG validFlags);
    
    
    /**************************************************************************\
    * SetValidValues (signed long, range)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_I4 and subtype to WIA_PROP_RANGE.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   minValue     - minimum value for the range
    *   maxValue     - maximum value for the range
    *   stepValue    - step value for the range
    *
    \**************************************************************************/
    
    HRESULT SetValidValues(INT index, LONG defaultValue, LONG currentValue,
                           LONG minValue, LONG maxValue, LONG stepValue);
    
    
    /**************************************************************************\
    * SetValidValues (signed long, list)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_I4 and subtype to WIA_PROP_LIST.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   numValues    - number of values in the list
    *   pValues      - pointer to the value list (must be valid until SendToWia
    *                  is called)
    *
    \**************************************************************************/
    
    HRESULT SetValidValues(INT index, LONG defaultValue, LONG currentValue,
                           INT numValues, PLONG pValues);
    
    
    /**************************************************************************\
    * SetValidValues (BSTR, list)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_BSTR and subtype to WIA_PROP_LIST.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   numValues    - number of values in the list
    *   pValues      - pointer to the value list (must be valid until SendToWia
    *                  is called)
    *
    \**************************************************************************/
    
    HRESULT SetValidValues(INT index, BSTR defaultValue, BSTR currentValue,
                           INT numValues, BSTR *pValues);
    
    
    /**************************************************************************\
    * SetValidValues (float, range)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_R4 and subtype to WIA_PROP_RANGE.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   minValue     - minimum value for the range
    *   maxValue     - maximum value for the range
    *   stepValue    - step value for the range
    *
    \**************************************************************************/
    
    HRESULT SetValidValues(INT index, FLOAT defaultValue, FLOAT currentValue,
                           FLOAT minValue, FLOAT maxValue, FLOAT stepValue);
    
    
    /**************************************************************************\
    * SetValidValues (float, list)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_R4 and subtype to WIA_PROP_LIST.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   numValues    - number of values in the list
    *   pValues      - pointer to the value list (must be valid until SendToWia
    *                  is called)
    *
    \**************************************************************************/
    
    HRESULT SetValidValues(INT index, FLOAT defaultValue, FLOAT currentValue,
                           INT numValues, PFLOAT pValues);
    
    
    /**************************************************************************\
    * SetValidValues (CLSID, list)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_CLSID and subtype to WIA_PROP_LIST.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   numValues    - number of values in the list
    *   pValues      - pointer to the value list (must be valid until SendToWia
    *                  is called)
    *
    \**************************************************************************/
    
    HRESULT SetValidValues(INT index, CLSID *defaultValue, CLSID *currentValue,
                           INT numValues, CLSID **pValues);
    
    
    /**************************************************************************\
    * SetCurrentValue (signed long)
    *
    *   Sets the current value for a property. Also sets the type to VT_I4.
    *
    * Arguments:
    *   index  - the property index, from DefineProperty
    *   value  - current setting of this property on the device
    *
    \**************************************************************************/
    
    HRESULT SetCurrentValue(INT index, LONG value);
    
    
    /**************************************************************************\
    * SetCurrentValue (BSTR)
    *
    *   Sets the current value for a property. Also sets the type to VT_BSTR.
    *
    * Arguments:
    *   index  - the property index, from DefineProperty
    *   value  - current setting of this property on the device
    *            (must be valid until SendToWia is called)
    *
    \**************************************************************************/
    
    HRESULT SetCurrentValue(INT index, BSTR value);
    
    
    /**************************************************************************\
    * SetCurrentValue (float)
    *
    *   Sets the current value for a property. Also sets the type to VT_R4.
    *
    * Arguments:
    *   index  - the property index, from DefineProperty
    *   value  - current setting of this property on the device
    *
    \**************************************************************************/
    
    HRESULT SetCurrentValue(INT index, FLOAT value);
    
    
    /**************************************************************************\
    * SetCurrentValue (CLSID)
    *
    *   Sets the current value for a property. Also sets the type to VT_CLSID.
    *
    * Arguments:
    *   index  - the property index, from DefineProperty
    *   value  - current setting of this property on the device
    *            (must be valid until SendToWia is called)
    *
    \**************************************************************************/
    
    HRESULT SetCurrentValue(INT index, CLSID *pValue);
    
    
    /**************************************************************************\
    * SetCurrentValue (SYSTEMTIME)
    *
    *   Sets the current value for a property. Also sets the type to
    *   VT_UI2 | VT_VECTOR.
    *
    * Arguments:
    *   index  - the property index, from DefineProperty
    *   value  - current setting of this property on the device
    *            (must be valid until SendToWia is called)
    *
    \**************************************************************************/
    
    HRESULT SetCurrentValue(INT index, PSYSTEMTIME value);
    
    
    /**************************************************************************\
    * SetCurrentValue (byte array)
    *
    *   Sets the current value for a property. Also sets the type to
    *   VT_UI1 | VT_VECTOR.
    *
    * Arguments:
    *   index  - the property index, from DefineProperty
    *   value  - pointer to current setting of this property on the device
    *            (must be valid until SendToWia is called)
    *
    \**************************************************************************/
    
    HRESULT SetCurrentValue(INT index, BYTE *value, INT size);

    
    /**************************************************************************\
    * GetPropId
    *
    *   Returns the property id given a property index.
    *
    \**************************************************************************/
    
    PROPID GetPropId(INT index) { return m_pId[index]; }
    
    
    /**************************************************************************\
    * LookupPropId
    *
    *   Finds the property index given a property ID.
    *
    \**************************************************************************/
    
    INT LookupPropId(PROPID PropId);
};


/**************************************************************************\
* wiauGetDrvItemContext
*
*   This helper function gets the driver item context, and optionally
*   return the driver item
*
* Arguments:
*
*   pWiasContext - pointer to the item context
*   ppItemCtx    - location to store pointer to driver item context
*   ppDrvItem    - location to store pointer to driver item (can be NULL)
*
\**************************************************************************/

HRESULT _stdcall wiauGetDrvItemContext(BYTE *pWiasContext, VOID **ppItemCtx, IWiaDrvItem **ppDrvItem = NULL);


/**************************************************************************\
* wiauSetImageItemSize
*
*   Calulates the size and width in bytes for an image based on the current
*   WIA_IPA_FORMAT setting, and writes the new values to the appropriate
*   properties. If the format is not BMP, this function assumes that the
*   value passed in lSize is correct for the current format.
*
* Arguments:
*
*   pWiasContext    - pointer to item context
*   lWidth          - width of the image in pixels
*   lHeight         - height of the image in lines
*   lDepth          - depth of the image in bits
*   lSize           - size of the image as stored on the device
*   pwszExt         - optional pointer to the 3 letter extension for the
*                     item's native format (if this is NULL, the extension
*                     property won't be updated)
*
\**************************************************************************/

HRESULT _stdcall wiauSetImageItemSize(BYTE *pWiasContext, LONG lWidth, LONG lHeight, LONG lDepth,
                             LONG lSize, PWSTR pwszExt = NULL);


/**************************************************************************\
* wiauPropsInPropSpec
*
*   Returns true if one or more of the property ids in pProps are
*   contained in pPropSpecs.
*
* Arguments:
*
*   NumPropSpecs - number of property specs in the array
*   pPropSpecs   - the property specs array
*   NumProps     - number of property ids to search for
*   pProps       - pointer to the array of property ids to search for
*
\**************************************************************************/

BOOL _stdcall wiauPropsInPropSpec(LONG NumPropSpecs, const PROPSPEC *pPropSpecs, int NumProps, PROPID *pProps);


/**************************************************************************\
* wiauPropInPropSpec
*
*   Returns true if the PropId property ID is in the passed pPropSpecs
*   array. Optionally will return the index of where the ID was found.
*
* Arguments:
*
*   NumPropSpecs - number of property specs in the array
*   pPropSpecs   - the property specs array
*   PropId       - property id to search for
*   pIdx         - optional pointer to the location to store the index
*
\**************************************************************************/

BOOL _stdcall wiauPropInPropSpec(LONG NumPropSpecs, const PROPSPEC *pPropSpecs, PROPID PropId, int *pIdx = NULL);


/**************************************************************************\
* wiauGetValidFormats
*
*   Calls drvGetWiaFormatInfo and makes a list of valid formats given
*   a tymed value. Caller is responsible for freeing the format array
*   with []delete.
*
* Arguments:
*
*   pDrv          - Pointer to WIA minidriver object (use "this")
*   pWiasContext  - WIA service context
*   TymedValue    - tymed value to search for
*   pNumFormats   - pointer to value to receive number of formats
*   ppFormatArray - pointer to a location to receive array address
*
\**************************************************************************/

HRESULT _stdcall wiauGetValidFormats(IWiaMiniDrv *pDrv, BYTE *pWiasContext, LONG TymedValue,
                            int *pNumFormats, GUID **ppFormatArray);

/**************************************************************************\
* wiauGetResourceString
*
*   This helper gets a resource string and returns it as a BSTR
*
* Arguments:
*
*   hInst       - Handle to module instance
*   lResourceID - Resource ID of the target BSTR value
*   pbstrStr    - Location to store the retrieved string (caller must
*                 free this string with SysFreeString())
*
\**************************************************************************/
HRESULT _stdcall wiauGetResourceString(HINSTANCE hInst, LONG lResourceID, BSTR *pbstrStr);


/**************************************************************************\
* wiauRegOpenDataW
*
*   Opens the DeviceData key. Call this function only in the STI Initialize
*   function. Call RegCloseKey when finished.
*
* Arguments:
*
*   hkeyAncestor    - HKey of parent (use hkey passed into Initialize)
*   phkeyDeviceData - Location to store opened hkey
*
\**************************************************************************/
HRESULT _stdcall wiauRegOpenDataW(HKEY hkeyAncestor, HKEY *phkeyDeviceData);


/**************************************************************************\
* wiauRegOpenDataA
*
*   Opens the DeviceData key. Call this function only in the STI Initialize
*   function. Call RegCloseKey when finished.
*
* Arguments:
*
*   hkeyAncestor    - HKey of parent (use hkey passed into Initialize)
*   phkeyDeviceData - Location to store opened hkey
*
\**************************************************************************/
HRESULT _stdcall wiauRegOpenDataA(HKEY hkeyAncestor, HKEY *phkeyDeviceData);


/**************************************************************************\
* wiauRegGetStrW
*
*   Use to get string value from the DeviceData section of the registry.
*
* Arguments:
*
*   hkey          - Use hkey returned from wiauRegOpenData
*   pwszValueName - Name of registry entry
*   pwszValue     - Location to store returned string
*   pdwLength     - Size of location in bytes
*
\**************************************************************************/
HRESULT _stdcall wiauRegGetStrW(HKEY hkKey, PCWSTR pwszValueName, PWSTR pwszValue, DWORD *pdwLength);


/**************************************************************************\
* wiauRegGetStrA
*
*   Use to get string value from the DeviceData section of the registry.
*
* Arguments:
*
*   hkey          - Use hkey returned from wiauRegOpenData
*   pszValueName  - Name of registry entry
*   pszValue      - Location to store returned string
*   pdwLength     - Size of location in bytes
*
\**************************************************************************/
HRESULT _stdcall wiauRegGetStrA(HKEY hkKey, PCSTR pszValueName, PSTR pszValue, DWORD *pdwLength);


/**************************************************************************\
* wiauRegGetDwordW
*
*   Use to get DWORD value from the DeviceData section of the registry.
*
* Arguments:
*
*   hkey          - Use hkey returned from wiauRegOpenData
*   pwszValueName - Name of registry entry
*   pdwValue      - Location to store returned DWORD
*
\**************************************************************************/
HRESULT _stdcall wiauRegGetDwordW(HKEY hkKey, PCWSTR pwszValueName, DWORD *pdwValue);


/**************************************************************************\
* wiauRegGetDwordA
*
*   Use to get DWORD value from the DeviceData section of the registry.
*
* Arguments:
*
*   hkey          - Use hkey returned from wiauRegOpenData
*   pszValueName  - Name of registry entry
*   pdwValue      - Location to store returned DWORD
*
\**************************************************************************/
HRESULT _stdcall wiauRegGetDwordA(HKEY hkKey, PCSTR pszValueName, DWORD *pdwValue);


/**************************************************************************\
* WiauStrW2C
*
*   Converts a wide character string to an ANSI character string
*
* Arguments:
*   pwszSrc - wide character string to be converted
*   pszDst  - location to store the ANSI conversion
*   iSize   - size of the buffer pointed to by pszDst, in bytes
*
\**************************************************************************/

HRESULT _stdcall wiauStrW2C(WCHAR *pwszSrc, CHAR *pszDst, INT iSize);


/**************************************************************************\
* WiauStrC2W
*
*   Converts an ANSI character string to a wide character string
*
* Arguments:
*   pszSrc  - ANSI string to convert
*   wpszDst - location to store the wide string
*   iSize   - size of the buffer pointed to by wpszDst, in bytes
*
\**************************************************************************/
HRESULT _stdcall wiauStrC2W(CHAR *pszSrc, WCHAR *pwszDst, INT iSize);


/**************************************************************************\
* WiauStrW2W
*
*   Copies a wide character string to another wide character string
*
* Arguments:
*   pwszSrc - wide character string to be copied
*   pwszDst - location to copy to
*   iSize   - size of the buffer pointed to by pwszDst, in bytes
*
\**************************************************************************/

HRESULT _stdcall wiauStrW2W(WCHAR *pwszSrc, WCHAR *pwszDst, INT iSize);


/**************************************************************************\
* WiauStrC2C
*
*   Copies an ANSI character string to another ANSI character string
*
* Arguments:
*   pszSrc - ANSI string to be copied
*   pszDst - location to copy to
*   iSize  - size of the buffer pointed to by pszDst, in bytes
*
\**************************************************************************/

HRESULT _stdcall wiauStrC2C(CHAR *pszSrc, CHAR *pszDst, INT iSize);


#ifdef UNICODE

#define wiauRegOpenData wiauRegOpenDataW
#define wiauRegGetStr wiauRegGetStrW
#define wiauRegGetDword wiauRegGetDwordW

#define wiauStrT2C wiauStrW2C
#define wiauStrC2T wiauStrC2W
#define wiauStrT2W wiauStrW2W
#define wiauStrW2T wiauStrW2W
#define WIAU_DEBUG_TSTR "S"

#else

#define wiauRegOpenData wiauRegOpenDataA
#define wiauRegGetStr wiauRegGetStrA
#define wiauRegGetDword wiauRegGetDwordA

#define wiauStrT2C wiauStrC2C
#define wiauStrC2T wiauStrC2C
#define wiauStrT2W wiauStrC2W
#define wiauStrW2T wiauStrW2C
#define WIAU_DEBUG_TSTR "s"

#endif // UNICODE


/**************************************************************************\
* WIA Debugging
*
*   Definitions for debug messages. To use WIA debugging:
*   1. Set registry HKLM\System\CurrentControlSet\Control\StillImage\Debug\<ModuleName>,
*      DWORD value "DebugFlags" to the combination of the WIAUDBG_* flags
*      desired. The application and possibly the WIA service will need to be
*      restarted to pick up the new settings. The key is auto created the
*      first time the module is executed. (Note: <ModuleName> above is the
*      name of the DLL or EXE, e.g. wiavusd.dll has a registry key of
*      "HKLM\System\CurrentControlSet\Control\StillImage\Debug\wiavusd.dll".)
*   2. Or in the debugger, set g_dwDebugFlags to the combination of the
*      WIAUDBG_* flags desired. This can be done anytime during the debug
*      session.
*   3. From the module, call wiauDbgSetFlags(<flags>), where <flags> is the
*      combination of the WIAUDBG_* flags desired.
*
*   Messages will be logged to the debugger and the file
*   %systemroot%\\wiadebug.log, unless the WIAUDBG_DONT_LOG_* flags are set.
*   Setting both flags will turn off all messages.
*
*   All strings should be ASCII. Use %S in the format string to print a
*   Unicode string.
*
\**************************************************************************/

#define _STIDEBUG_H_ // WIA debugging is incompatible with stidebug.h, so don't include it

//
// Predefined debug flags
//

const DWORD WIAUDBG_ERRORS                = 0x00000001;
const DWORD WIAUDBG_WARNINGS              = 0x00000002;
const DWORD WIAUDBG_TRACES                = 0x00000004;
const DWORD WIAUDBG_FNS                   = 0x00000008;  // Function entry and exit
const DWORD WIAUDBG_DUMP                  = 0x00000010;  // Dump data
const DWORD WIAUDBG_PRINT_TIME            = 0x08000000;  // Prints time for each message
const DWORD WIAUDBG_PRINT_INFO            = 0x10000000;  // Turns on thread, file, line info
const DWORD WIAUDBG_DONT_LOG_TO_DEBUGGER  = 0x20000000;
const DWORD WIAUDBG_DONT_LOG_TO_FILE      = 0x40000000;
const DWORD WIAUDBG_BREAK_ON_ERRORS       = 0x80000000;  // Do DebugBreak on errors

//
// Don't log at all
//
const DWORD WIAUDBG_DONT_LOG = WIAUDBG_DONT_LOG_TO_FILE | WIAUDBG_DONT_LOG_TO_DEBUGGER;

//
// Set default flags
//
#ifdef DEBUG
const DWORD WIAUDBG_DEFAULT_FLAGS = WIAUDBG_ERRORS;
#else
const DWORD WIAUDBG_DEFAULT_FLAGS = WIAUDBG_DONT_LOG;
#endif

//
// FormatMessage flags
//
const DWORD WIAUDBG_MFMT_FLAGS = FORMAT_MESSAGE_IGNORE_INSERTS |
                                 FORMAT_MESSAGE_FROM_SYSTEM |
                                 FORMAT_MESSAGE_MAX_WIDTH_MASK;

#ifdef __cplusplus
extern "C" {
#endif

//
// WIA Debugging has very little overhead and should be put into retail
// code for drivers. If it's really desired to remove it, define NO_WIA_DEBUG.
//

#ifdef NO_WIA_DEBUG

#define g_dwDebugFlags 0
#define wiauDbgInit(a)
#define wiauDbgHelper(a,b,c,d)
#define wiauDbgHelper2  wiauNull3
#define wiauDbgFlags    wiauNull4
#define wiauDbgError    wiauNull2
#define wiauDbgErrorHr  wiauNull3hr
#define wiauDbgWarning  wiauNull2
#define wiauDbgTrace    wiauNull2
#define wiauDbgDump     wiauNull2
#define wiauDbgSetFlags(a) 0
#define wiauDbgLegacyError      wiauNull1
#define wiauDbgLegacyWarning    wiauNull1
#define wiauDbgLegacyTrace      wiauNull1
#define wiauDbgLegacyError2     wiauNull2h
#define wiauDbgLegacyTrace2     wiauNull2h
#define wiauDbgLegacyHresult2   wiauNullHHr

inline void wiauNull1(LPCSTR a, ...) {}
inline void wiauNull2(LPCSTR a, LPCSTR b,...) {}
inline void wiauNull2h(HINSTANCE hInstance, LPCSTR b,...) {}
inline void wiauNull3(LPCSTR a, LPCSTR b, LPCSTR c, ...) {}
inline void wiauNull3hr(HRESULT a, LPCSTR b, LPCSTR c, ...) {}
inline void wiauNull4(DWORD a, LPCSTR b, LPCSTR c, LPCSTR d, ...) {}
inline void wiauNullHHr(HINSTANCE hInstance, HRESULT hr) {}


#else // NO_WIA_DEBUG

extern DWORD  g_dwDebugFlags; 
extern HANDLE g_hDebugFile;
extern DWORD  g_dwDebugFileSizeLimit;
extern BOOL   g_bDebugInited;


/**************************************************************************\
* wiauDbgInit
*
*   Call to initialize WIA debugging. If it's not called, all DLLs will
*   inherit the debug flags of the process that creates them.
*
* Arguments:
*
*   hInstance - DLL instance handle
*
\**************************************************************************/

void __stdcall wiauDbgInit(HINSTANCE hInstance);
void __stdcall wiauDbgHelper(LPCSTR prefix, LPCSTR fname, LPCSTR fmt, va_list marker);
void __stdcall wiauDbgHelper2(LPCSTR prefix, LPCSTR fname, LPCSTR fmt, ...);

inline void __stdcall wiauDbgFlags(DWORD flags, LPCSTR prefix,
                                   LPCSTR fname, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and the flag is enabled
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & flags)) {

        va_start(marker, fmt);
        wiauDbgHelper(prefix, fname, fmt, marker);
        va_end(marker);
    }
}

inline void __stdcall wiauDbgError(LPCSTR fname, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and error messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_ERRORS)) {

        va_start(marker, fmt);
        wiauDbgHelper("ERROR ", fname, fmt, marker);
        va_end(marker);
    }

    if (g_dwDebugFlags & WIAUDBG_BREAK_ON_ERRORS) {
        DebugBreak();
    }
}

inline void __stdcall wiauDbgErrorHr(HRESULT hr, LPCSTR fname, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and error messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_ERRORS)) {

        va_start(marker, fmt);
        wiauDbgHelper("ERROR ", fname, fmt, marker);
        va_end(marker);

        CHAR szError[MAX_PATH]; \
        if(!FormatMessageA(WIAUDBG_MFMT_FLAGS, NULL, hr, 0, szError, MAX_PATH, NULL))
        {
            strcpy(szError, "Unknown HRESULT");
        }
        wiauDbgHelper2("ERROR ", fname, "HRESULT = 0x%08x, %s", hr, szError);
    }

    if (g_dwDebugFlags & WIAUDBG_BREAK_ON_ERRORS) {
        DebugBreak();
    }
}

inline void __stdcall wiauDbgWarning(LPCSTR fname, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and warning messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_WARNINGS)) {

        va_start(marker, fmt);
        wiauDbgHelper("WARN  ", fname, fmt, marker);
        va_end(marker);
    }
}

inline void __stdcall wiauDbgTrace(LPCSTR fname, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and trace messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_TRACES)) {

        va_start(marker, fmt);
        wiauDbgHelper("      ", fname, fmt, marker);
        va_end(marker);
    }
}

inline void __stdcall wiauDbgDump(LPCSTR fname, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and trace messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_DUMP)) {

        va_start(marker, fmt);
        wiauDbgHelper("      ", fname, fmt, marker);
        va_end(marker);
    }
}

inline DWORD __stdcall wiauDbgSetFlags(DWORD flags)
{
    DWORD dwOld = g_dwDebugFlags;
    g_dwDebugFlags = flags;
    return dwOld;
}


inline void __stdcall wiauDbgLegacyError(LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and error messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_ERRORS)) {

        va_start(marker, fmt);
        wiauDbgHelper("ERROR ", "", fmt, marker);
        va_end(marker);
    }

    if (g_dwDebugFlags & WIAUDBG_BREAK_ON_ERRORS) {
        DebugBreak();
    }
}

inline void __stdcall wiauDbgLegacyWarning(LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and warning messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_WARNINGS)) {

        va_start(marker, fmt);
        wiauDbgHelper("WARN  ", "", fmt, marker);
        va_end(marker);
    }
}

inline void __stdcall wiauDbgLegacyTrace(LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and trace messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_TRACES)) {

        va_start(marker, fmt);
        wiauDbgHelper("      ", "", fmt, marker);
        va_end(marker);
    }
}

inline void __stdcall wiauDbgLegacyError2(HINSTANCE hInstance, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and error messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_ERRORS)) {

        va_start(marker, fmt);
        wiauDbgHelper("ERROR ", "", fmt, marker);
        va_end(marker);
    }

    if (g_dwDebugFlags & WIAUDBG_BREAK_ON_ERRORS) {
        DebugBreak();
    }
}

inline void __stdcall wiauDbgLegacyTrace2(HINSTANCE hInstance, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and trace messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_TRACES)) {

        va_start(marker, fmt);
        wiauDbgHelper("      ", "", fmt, marker);
        va_end(marker);
    }
}

inline void __stdcall wiauDbgLegacyHresult2(HINSTANCE hInstance, HRESULT hr)
{
    wiauDbgErrorHr(hr, "", "");
}

#endif // NO_WIA_DEBUG


//
// Macros for mapping the old WIA logging to the new system
//
#ifdef WIA_MAP_OLD_DEBUG

#define CWiaLogProc
#define WIAS_LOGPROC(x, y, z, fname) CWiauDbgFn __CWiauDbgFnObject(fname)
#define WIAS_LERROR(x,y,params) wiauDbgLegacyError ## params
#define WIAS_LWARNING(x,y,params) wiauDbgLegacyWarning ## params
#define WIAS_LTRACE(x,y,z,params) wiauDbgLegacyTrace ## params
#define WIAS_LHRESULT(x,y) wiauDbgErrorHr(y, "", "")

#define WIAS_TRACE(x) wiauDbgLegacyTrace2 ## x
#define WIAS_ERROR(x) wiauDbgLegacyError2 ## x
#define WIAS_HRESULT(x) wiauDbgLegacyHresult2 ## x
#define WIAS_ASSERT(x, y) \
        if (!(y)) { \
            WIAS_ERROR((x, (char*) TEXT("ASSERTION FAILED: %hs(%d): %hs"), __FILE__,__LINE__,#x)); \
            DebugBreak(); \
        }
        
#endif // WIA_MAP_OLD_DEBUG


//
// Macros for checking return values and common error conditions
//

#define REQUIRE_SUCCESS(hr, fname, msg) \
    if (FAILED(hr)) { \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgErrorHr(hr, fname, msg); \
        goto Cleanup; \
    }

#define REQUIRE_OK(hr, fname, msg) \
    if ((hr) != S_OK) { \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgErrorHr(hr, fname, msg); \
        goto Cleanup; \
    }

#define REQUIRE_ARGS(args, hr, fname) \
    if (args) { \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgError(fname, "Invalid arg"); \
        hr = E_INVALIDARG; \
        goto Cleanup; \
    }

#define REQUIRE_ALLOC(var, hr, fname) \
    if (!(var)) { \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgError(fname, "Memory allocation failed on " #var); \
        hr = E_OUTOFMEMORY; \
        goto Cleanup; \
    }

#define REQUIRE_FILEHANDLE(handle, hr, fname, msg) \
    if ((handle) == NULL || (handle) == INVALID_HANDLE_VALUE) { \
        hr = HRESULT_FROM_WIN32(::GetLastError()); \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgErrorHr(hr, fname, msg); \
        goto Cleanup; \
    }

#define REQUIRE_FILEIO(ret, hr, fname, msg) \
    if (!(ret)) { \
        hr = HRESULT_FROM_WIN32(::GetLastError()); \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgErrorHr(hr, fname, msg); \
        goto Cleanup; \
    }

#define REQUIRE_WIN32(err, hr, fname, msg) \
    if ((err) != ERROR_SUCCESS) { \
        hr = HRESULT_FROM_WIN32(err); \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgErrorHr(hr, fname, msg); \
        goto Cleanup; \
    }


//
// Macro and class for entry/exit point tracing
//

#ifdef __cplusplus

#ifdef NO_WIA_DEBUG

#define DBG_FN(fname)

#else // NO_WIA_DEBUG

#define DBG_FN(fname) CWiauDbgFn __CWiauDbgFnObject(fname)

class CWiauDbgFn {
public:

    CWiauDbgFn(LPCSTR fname)
    { 
        m_fname = fname;
        m_threadId = GetCurrentThreadId();
        wiauDbgFlags(WIAUDBG_FNS, "      ", m_fname, "Entering, thread 0x%x (%d)",
                     m_threadId, m_threadId);

    } 
    
    ~CWiauDbgFn() 
    { 
        wiauDbgFlags(WIAUDBG_FNS, "      ", m_fname, "Exiting, thread 0x%x (%d)",
                     m_threadId, m_threadId);
    }

private:
    LPCSTR m_fname;
    DWORD  m_threadId;
};
#endif // NO_WIA_DEBUG

}

#else // __cplusplus

#define DBG_FN(fname) wiauDbgFlags(WIAUDBG_FNS, "      ", fname, "Entering");
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\qv2kux\qv2kux.c ===
//----------------- Original Sig ------------------------
/*++
Copyright (c) 1991-1999  Microsoft Corporation

Module Name:
    fpfilter.c
--*/


#define INITGUID

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"
#include "usbdi.h"
#include "usbdlib.h"

//
// Bit Flag Macros
//

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   (((Flags) & (Bit)) != 0)

//
// Remove lock
//
#define REMLOCK_TAG 'QV2K'
#define REMLOCK_MAXIMUM 1      // Max minutes system allows lock to be held
#define REMLOCK_HIGHWATER 250  // Max number of irps holding lock at one time

//
// Device Extension
//

typedef struct _FDO_EXTENSION {
    ULONG           Signature;
    PDEVICE_OBJECT  Fdo;                    // Back pointer to Fdo
    PDEVICE_OBJECT  Pdo;                    // Not Used
    PDEVICE_OBJECT  Ldo;                    // Lower Device Object
    PDEVICE_OBJECT  PhysicalDeviceObject;   // Not Used
    KEVENT          SyncEvent;              // for ForwardIrpSynchronous
} FDO_EXTENSION, *PFDO_EXTENSION;

#define FDO_EXTENSION_SIZE sizeof(FDO_EXTENSION)


//
// Function declarations
//

NTSTATUS    DriverEntry                 ( IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
NTSTATUS    QV2KUX_AddDevice            ( IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT PhysicalDeviceObject);
VOID        QV2KUX_Unload               ( IN PDRIVER_OBJECT DriverObject );
NTSTATUS    QV2KUX_ForwardIrpSynchronous( IN PDEVICE_OBJECT Fdo, IN PIRP Irp);
NTSTATUS    QV2KUX_DispatchPnp          ( IN PDEVICE_OBJECT Fdo, IN PIRP Irp);
NTSTATUS    QV2KUX_DispatchPower        ( IN PDEVICE_OBJECT Fdo, IN PIRP Irp);
NTSTATUS    QV2KUX_StartDevice          ( IN PDEVICE_OBJECT Fdo, IN PIRP Irp);
NTSTATUS    QV2KUX_RemoveDevice         ( IN PDEVICE_OBJECT Fdo, IN PIRP Irp);
NTSTATUS    QV2KUX_SendToNextDriver     ( IN PDEVICE_OBJECT Fdo, IN PIRP Irp);
NTSTATUS    QV2KUX_Internal_IOCTL       ( IN PDEVICE_OBJECT Fdo, IN PIRP Irp);
NTSTATUS    QV2KUX_IrpCompletion        ( IN PDEVICE_OBJECT Fdo, IN PIRP Irp, IN PVOID Context);
VOID        QV2KUX_SyncFilterWithLdo    ( IN PDEVICE_OBJECT Fdo, IN PDEVICE_OBJECT Ldo);

#if DBG

#define DEBUG_BUFFER_LENGTH 256

ULONG QV2KUX_Debug = 0;
UCHAR QV2KUX_DebugBuffer[DEBUG_BUFFER_LENGTH];

VOID        QV2KUX_DebugPrint( ULONG DebugPrintLevel, PCCHAR DebugMessage, ...);

#define DebugPrint(x)   QV2KUX_DebugPrint x

#else

#define DebugPrint(x)

#endif


NTSTATUS    DriverEntry( IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
/*++

Routine Description:
    Gg[|Cg

Arguments:
    DriverObject - The disk performance driver object.
    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:
    STATUS_SUCCESS

--*/
{

    ULONG               ulIndex;
    PDRIVER_DISPATCH  * dispatch;

    // SoCpX
    for (ulIndex = 0, dispatch = DriverObject->MajorFunction;
         ulIndex <= IRP_MJ_MAXIMUM_FUNCTION;
         ulIndex++, dispatch++) {

        *dispatch = QV2KUX_SendToNextDriver;
    }

    // LX
    DriverObject->MajorFunction[IRP_MJ_POWER]                   = QV2KUX_DispatchPower;
    DriverObject->DriverUnload                                  = QV2KUX_Unload;

    //Kv
    DriverObject->MajorFunction[IRP_MJ_PNP]                     = QV2KUX_DispatchPnp;
    DriverObject->DriverExtension->AddDevice                    = QV2KUX_AddDevice;

    // I
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = QV2KUX_Internal_IOCTL;
    return(STATUS_SUCCESS);

} // end DriverEntry()

#define FILTER_DEVICE_PROPOGATE_FLAGS            0
#define FILTER_DEVICE_PROPOGATE_CHARACTERISTICS (FILE_REMOVABLE_MEDIA |  \
                                                 FILE_READ_ONLY_DEVICE | \
                                                 FILE_FLOPPY_DISKETTE    \
                                                 )

VOID    QV2KUX_SyncFilterWithLdo( IN PDEVICE_OBJECT Fdo, IN PDEVICE_OBJECT Ldo)
{
    ULONG                   propFlags;

    //
    // Propogate all useful flags from target to QV2KUX_. MountMgr will look
    // at the QV2KUX_ object capabilities to figure out if the disk is
    // a removable and perhaps other things.
    //
    propFlags = Ldo->Flags & FILTER_DEVICE_PROPOGATE_FLAGS;
    SET_FLAG(Fdo->Flags, propFlags);

    propFlags = Ldo->Characteristics & FILTER_DEVICE_PROPOGATE_CHARACTERISTICS;
    SET_FLAG(Fdo->Characteristics, propFlags);
}

NTSTATUS    QV2KUX_AddDevice( IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT PhysicalDeviceObject)
/*++
Routine Description:
    DeviceObjectDeviceExtension
    vOAPDOFDOgp

Arguments:
    DriverObject - Disk performance driver object.
    PhysicalDeviceObject - Physical Device Object from the underlying layered driver

Return Value:
    NTSTATUS
--*/

{
    NTSTATUS                status;
    PDEVICE_OBJECT          Fdo;
    PFDO_EXTENSION       fdoExtension;
    PIRP                    irp;

    // Create a filter device object for this device (partition).
    DebugPrint((2, "QV2KUX_AddDevice: Driver %p Device %p\n", DriverObject, PhysicalDeviceObject));

    status = IoCreateDevice(DriverObject, FDO_EXTENSION_SIZE, NULL, FILE_DEVICE_BUS_EXTENDER, 0, FALSE, &Fdo);

    if (!NT_SUCCESS(status)) {
       DebugPrint((1, "QV2KUX_AddDevice: Cannot create Fdo\n"));
       return status;
    }

    SET_FLAG(Fdo->Flags, DO_DIRECT_IO);

    fdoExtension = Fdo->DeviceExtension;

    RtlZeroMemory(fdoExtension, FDO_EXTENSION_SIZE);
    fdoExtension->Signature = 'QV2K';
    fdoExtension->Fdo = Fdo;
    fdoExtension->PhysicalDeviceObject = PhysicalDeviceObject;

    // hCo
    fdoExtension->Ldo = IoAttachDeviceToDeviceStack(Fdo, PhysicalDeviceObject);

    if (fdoExtension->Ldo == NULL) {
        IoDeleteDevice(Fdo);
        DebugPrint((1, "QV2KUX_AddDevice: Unable to attach %X to target %X\n", Fdo, PhysicalDeviceObject));
        return STATUS_NO_SUCH_DEVICE;
    }

    // ForwardIrpSynchronousgp
    KeInitializeEvent(&fdoExtension->SyncEvent,  NotificationEvent, FALSE);

    // default to DO_POWER_PAGABLE
    SET_FLAG(Fdo->Flags,  DO_POWER_PAGABLE);

    // Clear the DO_DEVICE_INITIALIZING flag
    CLEAR_FLAG(Fdo->Flags, DO_DEVICE_INITIALIZING);

    return STATUS_SUCCESS;

} // end QV2KUX_AddDevice()


NTSTATUS    QV2KUX_DispatchPnp(IN PDEVICE_OBJECT Fdo, IN PIRP Irp)
/*++

Routine Description:
    Dispatch for PNP

Arguments:
    Fdo    - Supplies the device object.
    Irp    - Supplies the I/O request packet.

Return Value:
    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;
    PFDO_EXTENSION   fdoExtension = Fdo->DeviceExtension;
    BOOLEAN lockHeld;
    BOOLEAN irpCompleted;

    DebugPrint((2, "QV2KUX_DispatchPnp: Device %X Irp %X\n", Fdo, Irp));

    irpCompleted = FALSE;

    switch(irpSp->MinorFunction) {
        case IRP_MN_START_DEVICE:   status = QV2KUX_StartDevice(Fdo, Irp); break;
        case IRP_MN_REMOVE_DEVICE:  status = QV2KUX_RemoveDevice(Fdo, Irp); break;
        default:  status = QV2KUX_SendToNextDriver(Fdo, Irp); irpCompleted = TRUE; break;
    }

    if (! irpCompleted) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;

} // end QV2KUX_DispatchPnp()


NTSTATUS    QV2KUX_IrpCompletion( IN PDEVICE_OBJECT Fdo, IN PIRP Irp, IN PVOID Context)
/*++

Routine Description:

    Forwarded IRP completion routine. Set an event and return
    STATUS_MORE_PROCESSING_REQUIRED. Irp forwarder will wait on this
    event and then re-complete the irp after cleaning up.

Arguments:
    Fdo is the device object of the WMI driver
    Irp is the WMI irp that was just completed
    Context is a PKEVENT that forwarder will wait on

Return Value:

    STATUS_MORE_PORCESSING_REQUIRED

--*/

{
    PKEVENT Event = (PKEVENT) Context;

    UNREFERENCED_PARAMETER(Fdo);
    UNREFERENCED_PARAMETER(Irp);

    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);

    // IrpgACompletionm
    return(STATUS_MORE_PROCESSING_REQUIRED);

} // end QV2KUX_IrpCompletion()


NTSTATUS    QV2KUX_StartDevice( IN PDEVICE_OBJECT Fdo, IN PIRP Irp)
/*++

Routine Description:
    This routine is called when a Pnp Start Irp is received.
    It will schedule a completion routine to initialize and register with WMI.

Arguments:
    Fdo - a pointer to the device object
    Irp - a pointer to the irp

Return Value:
    Status of processing the Start Irp

--*/
{
    PFDO_EXTENSION   fdoExtension = Fdo->DeviceExtension;
    KEVENT              event;
    NTSTATUS            status;

    status = QV2KUX_ForwardIrpSynchronous(Fdo, Irp);
    QV2KUX_SyncFilterWithLdo(Fdo, fdoExtension->Ldo);
    return status;
}


NTSTATUS    QV2KUX_RemoveDevice( IN PDEVICE_OBJECT Fdo, IN PIRP Irp)
/*++

Routine Description:
    This routine is called when the device is to be removed.
    It will de-register itself from WMI first, detach itself from the
    stack before deleting itself.

Arguments:
    Fdo - a pointer to the device object
    Irp - a pointer to the irp

Return Value:
    Status of removing the device

--*/
{
    NTSTATUS            status;
    PFDO_EXTENSION   fdoExtension = Fdo->DeviceExtension;

    status = QV2KUX_ForwardIrpSynchronous(Fdo, Irp);

    IoDetachDevice(fdoExtension->Ldo);
    IoDeleteDevice(Fdo);

    return status;
}


NTSTATUS    QV2KUX_SendToNextDriver( IN PDEVICE_OBJECT Fdo, IN PIRP Irp)
/*++

Routine Description:
    This routine sends the Irp to the next driver in line
    when the Irp is not processed by this driver.

Arguments:
    Fdo
    Irp

Return Value:
    NTSTATUS

--*/
{
    PFDO_EXTENSION   fdoExtension = Fdo->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(fdoExtension->Ldo, Irp);

} // end QV2KUX_SendToNextDriver()


NTSTATUS    QV2KUX_DispatchPower( IN PDEVICE_OBJECT Fdo, IN PIRP Irp)
{
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);

    return PoCallDriver(fdoExtension->Ldo, Irp);

} // end QV2KUX_DispatchPower


NTSTATUS    QV2KUX_ForwardIrpSynchronous( IN PDEVICE_OBJECT Fdo, IN PIRP Irp)
/*++

Routine Description:
    This routine sends the Irp to the next driver in line
    when the Irp needs to be processed by the lower drivers
    prior to being processed by this one.

Arguments:
    Fdo
    Irp

Return Value:
    NTSTATUS

--*/
{
    PFDO_EXTENSION   fdoExtension = Fdo->DeviceExtension;
    NTSTATUS status;

    //CxgNA
    KeClearEvent(&fdoExtension->SyncEvent);
    //IrpStackRs[
    IoCopyCurrentIrpStackLocationToNext(Irp);
    // IrpCompletion
    IoSetCompletionRoutine(Irp, QV2KUX_IrpCompletion, &fdoExtension->SyncEvent, TRUE, TRUE, TRUE);

    // call the next lower device
    status = IoCallDriver(fdoExtension->Ldo, Irp);

    // wait for the actual completion
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&fdoExtension->SyncEvent, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;

} // end QV2KUX_ForwardIrpSynchronous()



VOID    QV2KUX_Unload( IN PDRIVER_OBJECT DriverObject)
/*++
Routine Description:
    Free all the allocated resources, etc.

Arguments:
    DriverObject - pointer to a driver object.

Return Value:
    VOID.

--*/
{
    return;
}

NTSTATUS    QV2KUX_Internal_IOCTL(IN PDEVICE_OBJECT Fdo, IN PIRP Irp)
{
    PFDO_EXTENSION  fdoExtension = Fdo->DeviceExtension;

    NTSTATUS            ntStatus;
    PIO_STACK_LOCATION  IrpSp;
    PURB        urb;
    PUCHAR      IoBuffer;
    USHORT      length;
    UCHAR       subclass;

    if (fdoExtension->Signature != 'QV2K') return QV2KUX_SendToNextDriver(Fdo,Irp);

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    urb = IrpSp->Parameters.Others.Argument1;
    if (!urb) return QV2KUX_SendToNextDriver(Fdo,Irp);
    if (urb->UrbHeader.Function != URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE) 
        return QV2KUX_SendToNextDriver(Fdo,Irp);
    // P USB_DEVICE_DESCRIPTOR_TYPE Length = 0x12;
    // Q USB_CONFIGURATION_DESCRIPTOR_TYPE LENGHT = 0x9
    // R USB_CONFIGURATION_DESCRIPTOR_TYPE LENGHT = interface,endpoint descriptor
    if (urb->UrbControlDescriptorRequest.TransferBufferLength <= 0x12)
        return QV2KUX_SendToNextDriver(Fdo,Irp);
    // R
    DebugPrint((0,"URB Get All of Configuration Descriptor \n"));

    ntStatus = QV2KUX_ForwardIrpSynchronous(Fdo,Irp);

    if (NT_SUCCESS(ntStatus)) {
        IoBuffer = (UCHAR *)urb->UrbControlDescriptorRequest.TransferBuffer;
        length = (USHORT)urb->UrbControlDescriptorRequest.TransferBufferLength;
        while(length >= 9) {
            //InterfaceDescriptor
            if (*(IoBuffer+1) == 4) {
                subclass = *(IoBuffer+6);
                DebugPrint((0,"QV2K_IntIoctl: SubCrass = %d \n",subclass));
                if (*(IoBuffer+6) == 6) *(IoBuffer+6) = 5;
            }
            length -= *IoBuffer;
            IoBuffer += *IoBuffer;
        }
    }
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return ntStatus;
}

#if DBG

VOID
QV2KUX_DebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:
    Debug print for all QV2KUX_

Arguments:
    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:
    None

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);


    if ((DebugPrintLevel <= (QV2KUX_Debug & 0x0000ffff)) ||
        ((1 << (DebugPrintLevel + 15)) & QV2KUX_Debug)) {

        _vsnprintf(QV2KUX_DebugBuffer, DEBUG_BUFFER_LENGTH, DebugMessage, ap);

        DbgPrint(QV2KUX_DebugBuffer);
    }

    va_end(ap);

}
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\scsiscan\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   byronc, coopp, keisuket, vlads
#
#Date:
#   2-Feb-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     StillImage kernel mode driver
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=scsiscan
TARGETTYPE=DRIVER
TARGETPATH=$(OBJ_DIR)

SOURCES=..\class.c     \
        ..\scsiscan.c  \
        ..\scsiscan.rc \
        ..\debug.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\scsiscan\private.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    private.h

Abstract:

    Prototypes and definitions for the scsi scanner device driver.

Author:

    Ray Patrick (raypat)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#ifndef _SCSISCAN_PRIAVATE_
#define _SCSISCAN_PRIAVATE_


// Includes
#include "debug.h"
#include "scsiscan.h"


// Defines

#define MAXIMUM_RETRIES     4
#define SCSISCAN_TIMEOUT    600

#define SRB SCSI_REQUEST_BLOCK
#define PSRB PSCSI_REQUEST_BLOCK

#ifndef ARRAYSIZE
 #define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#endif

// Typedefs

typedef struct _SCSISCAN_DEVICE_EXTENSION {
    ULONG                       Signature;
    PDEVICE_OBJECT              pStackDeviceObject;
    PDEVICE_OBJECT              pPhysicalDeviceObject;
    ULONG                       SrbFlags;
    UCHAR                       PortNumber;
    ULONG                       TimeOutValue;
    ULONG                       ErrorCount;
    ULONG                       SelecTimeoutCount;
    ULONG                       LastSrbError;
    ULONG                       DeviceInstance;
    ULONG                       PnpDeviceNumber;
    USHORT                      DeviceFlags;
    PSTORAGE_ADAPTER_DESCRIPTOR pAdapterDescriptor;
    UNICODE_STRING              DeviceName;
    //UNICODE_STRING              SymbolicLinkName;

    KEVENT                      PendingIoEvent;
    ULONG                       PendingIoCount;
    BOOLEAN                     AcceptingRequests;
    PVOID                       DeviceLock;
    ULONG                       OpenInstanceCount;
    PIRP                        pPowerIrp;
    DEVICE_POWER_STATE          CurrentDevicePowerState;

    //
    // Records whether we actually created the symbolic link name
    // at driver load time.  If we didn't create it, we won't try
    // to distroy it when we unload.
    //
    BOOLEAN         CreatedSymbolicLink;

    //
    // This points to the symbolic link name that was
    // linked to the actual nt device name.
    //
    UNICODE_STRING  SymbolicLinkName;

    //
    // This points to the class name used to create the
    // device and the symbolic link.  We carry this
    // around for a short while...
    UNICODE_STRING  ClassName;

    //
    // Name of the device interface
    //
    UNICODE_STRING  InterfaceNameString;

} SCSISCAN_DEVICE_EXTENSION, *PSCSISCAN_DEVICE_EXTENSION;

typedef struct _TRANSFER_CONTEXT {
    ULONG              Signature;
    PSCSISCAN_CMD      pCmd;
    SRB                Srb;
    PUCHAR             pTransferBuffer;
    ULONG              TransferLength;
    LONG               RemainingTransferLength;
    LONG               NBytesTransferred;
    ULONG              RetryCount;
    PUCHAR             pSenseBuffer;
    PMDL               pSenseMdl;
    PMDL               pSrbStatusMdl;
} TRANSFER_CONTEXT, *PTRANSFER_CONTEXT;

typedef struct _COMPLETION_CONTEXT {
        ULONG                           Signature;
    PDEVICE_OBJECT      pDeviceObject;
    SRB                 Srb;
}COMPLETION_CONTEXT, *PCOMPLETION_CONTEXT;

#ifdef _WIN64
// For 32bit client on 64bit OS.
typedef struct _SCSISCAN_CMD_32 {
    ULONG               Reserved1;
    ULONG               Size;
    ULONG               SrbFlags;
    UCHAR               CdbLength;
    UCHAR               SenseLength;
    UCHAR               Reserved2;
    UCHAR               Reserved3;
    ULONG               TransferLength;
    UCHAR               Cdb[16];    
    UCHAR * POINTER_32  pSrbStatus;
    UCHAR * POINTER_32  pSenseBuffer;
} SCSISCAN_CMD_32, *PSCSISCAN_CMD_32;
#endif // _WIN64

//
// Prototypes
//
NTSTATUS
DriverEntry(                                                    // in scsiscan.c
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS SSPnp (                                                // in scsiscan.c
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

NTSTATUS
SSPnpAddDevice(                                                 // in scsiscan.c
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDevice
    );

NTSTATUS
SSOpen(                                                                 // in scsiscan.c
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
SSClose(                                                        // in scsiscan.c
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
SSReadWrite(                                                    // in scsiscan.c
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
SSDeviceControl(                                                // in scsiscan.c
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
SSGetInfo(                                                              // in scsiscan.c
    IN  PDEVICE_OBJECT pDeviceObject,
    IN  ULONG ControlCode,
    OUT PVOID *ppv
    );


VOID
SSSendScannerRequest(                                   // in scsiscan.c
        PDEVICE_OBJECT pDeviceObject,
        PIRP pIrp,
        PTRANSFER_CONTEXT pTransferContext,
        BOOLEAN Retry
        );

NTSTATUS
SSReadWriteIoComplete(                                  // in scsiscan.c
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    );

NTSTATUS
SSIoctlIoComplete(                                              // in scsiscan.c
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    );

NTSTATUS
SSDeviceControl(                                                // in scsiscan.c
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    );


VOID
SSAdjustTransferSize(                                   // in scsiscan.c
    PSCSISCAN_DEVICE_EXTENSION  pde,
    PTRANSFER_CONTEXT pTransferContext
    );


PTRANSFER_CONTEXT                                               // in scsiscan.c
SSBuildTransferContext(
    PSCSISCAN_DEVICE_EXTENSION  pde,
    PIRP                        pIrp,
    PSCSISCAN_CMD               pCmd,
    ULONG                       CmdLength,
    PMDL                        pTransferMdl,
    BOOLEAN                     AllowMultipleTransfer
    );

NTSTATUS                                                                // in scsiscan.c
SSCreateSymbolicLink(
    PSCSISCAN_DEVICE_EXTENSION  pde
    );

NTSTATUS                                                                // in scsiscan.c
SSDestroySymbolicLink(
    PSCSISCAN_DEVICE_EXTENSION  pde
    );

VOID                                    // in scsiscan.c
SSIncrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
    );

LONG                                    // in scsiscan.c
SSDecrementIoCount(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS                                // in scsiscan.c
SSDeferIrpCompletion(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    );


NTSTATUS                                // in scsiscan.c
SSPower(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    );

VOID                                    // in scsiscan.c
SSUnload(
    IN PDRIVER_OBJECT pDriverObject
    );

VOID
SSSetTransferLengthToCdb(
    PCDB  pCdb,
    ULONG TransferLength
    );                                  // in scsiscan.c

NTSTATUS
SSCallNextDriverSynch(
    IN PSCSISCAN_DEVICE_EXTENSION   pde,
    IN PIRP                         pIrp
    );


NTSTATUS
ClassGetDescriptor(                                             // in class.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTORAGE_PROPERTY_ID PropertyId,
    OUT PVOID *pDescriptor
    );

BOOLEAN
ClassInterpretSenseInfo(                                // in class.c
    IN PDEVICE_OBJECT pDeviceObject,
    IN PSRB pSrb,
    IN UCHAR MajorFunctionCode,
    IN ULONG IoDeviceCode,
    IN ULONG RetryCount,
    OUT NTSTATUS *Status
    );

VOID                                                                    // in class.c
ClassReleaseQueue(
    IN PDEVICE_OBJECT pDeviceObject
    );

NTSTATUS
ClassAsynchronousCompletion(            // in class.c
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp,
    PCOMPLETION_CONTEXT pContext
    );

NTSTATUS
ClassGetInfo(                          // in class.c
    IN PDEVICE_OBJECT pDeviceObject,
    OUT PSCSISCAN_INFO pTargetInfo
    );

NTSTATUS
ScsiScanHandleInterface(
    PDEVICE_OBJECT      DeviceObject,
    PUNICODE_STRING     InterfaceName,
    BOOLEAN             Create
    );

#endif // _SCSISCAN_PRIAVATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\scsiscan\class.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:
    class.c

Abstract:
    Contains a subset of routines in classpnp.sys.

Author:
    Ray Patrick (raypat)

Environment:
    kernel mode only

Notes:

Revision History:

--*/
#include <stdio.h>
#include "stddef.h"
#include "wdm.h"
#include "scsi.h"
#include "ntddstor.h"
#include "ntddscsi.h"
#include "scsiscan.h"
#include "private.h"
#include "debug.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ClassGetDescriptor)
#pragma alloc_text(PAGE, ClassGetInfo)
#endif

NTSTATUS
ClassGetDescriptor(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PSTORAGE_PROPERTY_ID pPropertyId,
    OUT PSTORAGE_DESCRIPTOR_HEADER *pDescriptor
    )
/*++

Routine Description:
    This routine will perform a query for the specified property id and will
    allocate a non-paged buffer to store the data in.  It is the responsibility
    of the caller to ensure that this buffer is freed.

    This routine must be run at IRQL_PASSIVE_LEVEL

Arguments:
    pDeviceObject - the device to query
    pDescriptor   - a location to store a pointer to the buffer we allocate

Return Value:
    Status
    if status is unsuccessful *DeviceInfo will be set to 0

--*/
{
    PIRP                       pIrp;
    PKEVENT                    pEvent = NULL;
    STORAGE_PROPERTY_QUERY     Query;
    ULONG                      Buffer[2];
    PSTORAGE_DESCRIPTOR_HEADER pLocalDescriptor = NULL;
    ULONG                      Length;
    IO_STATUS_BLOCK            StatusBlock;
    NTSTATUS                   Status;
    UCHAR                      Pass;

    //
    // Set the descriptor pointer to NULL and
    // Initialize the event we're going to wait on.
    //

    *pDescriptor = NULL;
    pEvent = MyAllocatePool(NonPagedPool, sizeof(KEVENT));

    if(pEvent == NULL) {
        DebugTrace(MAX_TRACE,("ClassGetDescriptor: Unable to allocate event\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        return Status;
    }
    KeInitializeEvent(pEvent, SynchronizationEvent, FALSE);

    Pass = 0;

    __try {

        //
        // Retrieve the property page
        //

        do {

            RtlZeroMemory(&Query, sizeof(STORAGE_PROPERTY_QUERY));
            Query.PropertyId = *pPropertyId;
            Query.QueryType = PropertyStandardQuery;

            switch( Pass ) {
                case 0:

                    //
                    // On the first pass we just want to get the first few
                    // bytes of the descriptor so we can read it's size
                    //

                    pLocalDescriptor = (PVOID) &Buffer[0];
                    Length = sizeof(ULONG) * 2;
                    break;

                case 1:

                    //
                    // This time we know how much data there is so we can
                    // allocate a buffer of the correct size
                    //

                    Length = ((PSTORAGE_DESCRIPTOR_HEADER) pLocalDescriptor)->Size;
                    pLocalDescriptor = MyAllocatePool(NonPagedPool, Length);
                    if (pLocalDescriptor == NULL) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        DebugTrace(MAX_TRACE,
                                         ("ClassGetDescriptor: unable to get memory for descriptor (%d bytes)\n",
                                          Length));
                        __leave;
                    }
                    break;
            }

            //
            // Build the query irp and wait for it to complete (if necessary)
            //

            pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_STORAGE_QUERY_PROPERTY,
                pDeviceObject,
                &Query,
                sizeof(STORAGE_PROPERTY_QUERY),
                pLocalDescriptor,
                Length,
                FALSE,
                pEvent,
                &StatusBlock);

            if (pIrp == NULL) {
                DebugTrace(MAX_TRACE,("ClassGetDescriptor: unable to allocate irp\n"));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;
            }

            Status = IoCallDriver(pDeviceObject, pIrp);

            if (Status == STATUS_PENDING) {
                KeWaitForSingleObject(pEvent,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);

                Status = StatusBlock.Status;
            }

            if (!NT_SUCCESS(Status)) {
                DebugTrace(MAX_TRACE,
                                 ("ClassGetDescriptor: error %#08lx trying to query properties\n",
                                  Status));
                __leave;
            }

        } while (Pass++ != 1);

    } __finally {

        MyFreePool(pEvent);

        if(NT_SUCCESS(Status)){
            *pDescriptor = pLocalDescriptor;
        } else {
            if( (Pass != 0)
             && (NULL != pLocalDescriptor) )
            {
                MyFreePool(pLocalDescriptor);
                pLocalDescriptor = NULL;
            }
        } // if(NT_SUCCESS(Status))
    }
    return Status;
}


BOOLEAN
ClassInterpretSenseInfo(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PSRB pSrb,
    IN UCHAR MajorFunctionCode,
    IN ULONG IoDeviceCode,
    IN ULONG RetryCount,
    OUT NTSTATUS *Status
    )
/*++

Routine Description:
    This routine interprets the data returned from the SCSI
    request sense. It determines the status to return in the
    IRP and whether this request can be retried.

Arguments:
    pDeviceObject - Supplies the device object associated with this request.
    pSrb - Supplies the scsi request block which failed.
    MajorFunctionCode - Supplies the function code to be used for logging.
    IoDeviceCode - Supplies the device code to be used for logging.
    Status - Returns the status for the request.

Return Value:
    BOOLEAN TRUE: Drivers should retry this request.
            FALSE: Drivers should not retry this request.

--*/
{
    PSCSISCAN_DEVICE_EXTENSION      pde;
    PSENSE_DATA                     pSenseBuffer;
    BOOLEAN                         Retry;
    BOOLEAN                         LogError;
    ULONG                           BadSector;
    ULONG                           UniqueId;
    NTSTATUS                        LogStatus;
    ULONG                           ReadSector;
    ULONG                           Index;
    PIO_ERROR_LOG_PACKET            pErrorLogEntry;

    pde = (PSCSISCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pSenseBuffer = pSrb -> SenseInfoBuffer;
    Retry = TRUE;
    LogError = FALSE;
    BadSector = 0;

    //
    // Check that request sense buffer is valid.
    //

    if (pSrb -> SrbStatus & SRB_STATUS_AUTOSENSE_VALID &&
        pSrb -> SenseInfoBufferLength >= offsetof(SENSE_DATA, CommandSpecificInformation)) {
        DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Error code is %x\n",
                                    pSenseBuffer -> ErrorCode));
        DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Sense key is %x\n",
                                    pSenseBuffer -> SenseKey));
        DebugTrace(MAX_TRACE,( "ScsiScannerInterpretSenseInfo: Additional sense code is %x\n",
                                     pSenseBuffer -> AdditionalSenseCode));
        DebugTrace(MAX_TRACE,( "ScsiScannerInterpretSenseInfo: Additional sense code qualifier is %x\n",
                                     pSenseBuffer -> AdditionalSenseCodeQualifier));

        //
        // Zero the additional sense code and additional sense code qualifier
        // if they were not returned by the device.
        //

        ReadSector = pSenseBuffer -> AdditionalSenseLength +
            offsetof(SENSE_DATA, AdditionalSenseLength);

        if (ReadSector > pSrb -> SenseInfoBufferLength) {
            ReadSector = pSrb -> SenseInfoBufferLength;
        }

        if (ReadSector <= offsetof(SENSE_DATA, AdditionalSenseCode)) {
            pSenseBuffer -> AdditionalSenseCode = 0;
        }

        if (ReadSector <= offsetof(SENSE_DATA, AdditionalSenseCodeQualifier)) {
            pSenseBuffer -> AdditionalSenseCodeQualifier = 0;
        }

        switch (pSenseBuffer -> SenseKey & 0xf) {

            case SCSI_SENSE_NOT_READY:
                DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Device not ready\n"));
                *Status = STATUS_DEVICE_NOT_READY;

                switch (pSenseBuffer -> AdditionalSenseCode) {

                    case SCSI_ADSENSE_LUN_NOT_READY:
                        DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Lun not ready\n"));

                        switch (pSenseBuffer -> AdditionalSenseCodeQualifier) {
                            case SCSI_SENSEQ_BECOMING_READY:

                                DebugTrace(MAX_TRACE,( "ScsiScannerInterpretSenseInfo:"
                                    " In process of becoming ready\n"));
                                break;

                            case SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED:
                                DebugTrace(MAX_TRACE,( "ScsiScannerInterpretSenseInfo:"
                                    " Manual intervention required\n"));
                                *Status = STATUS_NO_MEDIA_IN_DEVICE;
                                Retry = FALSE;
                                break;

                            case SCSI_SENSEQ_FORMAT_IN_PROGRESS:
                                DebugTrace(MAX_TRACE,( "ScsiScannerInterpretSenseInfo: Format in progress\n"));
                                Retry = FALSE;
                                break;

                            case SCSI_SENSEQ_INIT_COMMAND_REQUIRED:

                            default:
                                DebugTrace(MAX_TRACE,( "ScsiScannerInterpretSenseInfo:"
                                    " Initializing command required\n"));
                                break;

                        } // end switch (pSenseBuffer -> AdditionalSenseCodeQualifier)
                        break;

                    case SCSI_ADSENSE_NO_MEDIA_IN_DEVICE:
                        DebugTrace(MAX_TRACE,(
                            "ScsiScannerInterpretSenseInfo:"
                            " No Media in device.\n"));
                        *Status = STATUS_NO_MEDIA_IN_DEVICE;
                        Retry = FALSE;
                        break;

                } // end switch (pSenseBuffer -> AdditionalSenseCode)
                break;

        case SCSI_SENSE_DATA_PROTECT:
            DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Media write protected\n"));
            *Status = STATUS_MEDIA_WRITE_PROTECTED;
            Retry = FALSE;
            break;

        case SCSI_SENSE_MEDIUM_ERROR:
            DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Bad media\n"));
            *Status = STATUS_DEVICE_DATA_ERROR;
            Retry = FALSE;
            LogError = TRUE;
            UniqueId = 256;
            LogStatus = IO_ERR_BAD_BLOCK;
            break;

        case SCSI_SENSE_HARDWARE_ERROR:
            DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Hardware error\n"));
            *Status = STATUS_IO_DEVICE_ERROR;
            LogError = TRUE;
            UniqueId = 257;
            LogStatus = IO_ERR_CONTROLLER_ERROR;
            break;

        case SCSI_SENSE_ILLEGAL_REQUEST:
            DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Illegal SCSI request\n"));
            *Status = STATUS_INVALID_DEVICE_REQUEST;
            switch (pSenseBuffer -> AdditionalSenseCode) {

                case SCSI_ADSENSE_ILLEGAL_COMMAND:
                    DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Illegal command\n"));
                    Retry = FALSE;
                    break;

                case SCSI_ADSENSE_ILLEGAL_BLOCK:
                    DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Illegal block address\n"));
                    *Status = STATUS_NONEXISTENT_SECTOR;
                    Retry = FALSE;
                    break;

                case SCSI_ADSENSE_INVALID_LUN:
                    DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Invalid LUN\n"));
                    *Status = STATUS_NO_SUCH_DEVICE;
                    Retry = FALSE;
                    break;

                case SCSI_ADSENSE_MUSIC_AREA:
                    DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Music area\n"));
                    Retry = FALSE;
                    break;

                case SCSI_ADSENSE_DATA_AREA:
                    DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Data area\n"));
                    Retry = FALSE;
                    break;

                case SCSI_ADSENSE_VOLUME_OVERFLOW:
                    DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Volume overflow\n"));
                    Retry = FALSE;
                    break;

                case SCSI_ADSENSE_INVALID_CDB:
                    DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Invalid CDB\n"));
                    Retry = FALSE;
                    break;

            } // end switch (pSenseBuffer -> AdditionalSenseCode)
            break;

        case SCSI_SENSE_UNIT_ATTENTION:
            switch (pSenseBuffer -> AdditionalSenseCode) {
                case SCSI_ADSENSE_MEDIUM_CHANGED:
                    DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Media changed\n"));
                    break;

                case SCSI_ADSENSE_BUS_RESET:
                    DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Bus reset\n"));
                    break;

                default:
                    DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Unit attention\n"));
                    break;

            } // end  switch (pSenseBuffer -> AdditionalSenseCode)
            *Status = STATUS_IO_DEVICE_ERROR;
            break;

        case SCSI_SENSE_ABORTED_COMMAND:
            DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Command aborted\n"));
            *Status = STATUS_IO_DEVICE_ERROR;
            break;

       case SCSI_SENSE_RECOVERED_ERROR:
            DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Recovered error\n"));
            *Status = STATUS_SUCCESS;
            Retry = FALSE;
            LogError = TRUE;
            UniqueId = 258;

            switch(pSenseBuffer -> AdditionalSenseCode) {
                case SCSI_ADSENSE_SEEK_ERROR:
                case SCSI_ADSENSE_TRACK_ERROR:
                    LogStatus = IO_ERR_SEEK_ERROR;
                    break;

                case SCSI_ADSENSE_REC_DATA_NOECC:
                case SCSI_ADSENSE_REC_DATA_ECC:
                    LogStatus = IO_RECOVERED_VIA_ECC;
                    break;

                default:
                    LogStatus = IO_ERR_CONTROLLER_ERROR;
                    break;

            } // end switch(pSenseBuffer -> AdditionalSenseCode)

            if (pSenseBuffer -> IncorrectLength) {
                DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Incorrect length detected.\n"));
                *Status = STATUS_INVALID_BLOCK_LENGTH ;
            }
            break;

        case SCSI_SENSE_NO_SENSE:

            //
            // Check other indicators.
            //

            if (pSenseBuffer -> IncorrectLength) {
                DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Incorrect length detected.\n"));
                *Status = STATUS_INVALID_BLOCK_LENGTH ;
                Retry   = FALSE;
            } else {
                DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: No specific sense key\n"));
                *Status = STATUS_IO_DEVICE_ERROR;
                Retry   = TRUE;
            }
            break;

        default:
            DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Unrecognized sense code\n"));
            *Status = STATUS_IO_DEVICE_ERROR;
            break;

        } // end switch (pSenseBuffer -> SenseKey & 0xf)

        //
        // Try to determine the bad sector from the inquiry data.
        //

        if ((((PCDB)pSrb -> Cdb) -> CDB10.OperationCode == SCSIOP_READ ||
            ((PCDB)pSrb -> Cdb) -> CDB10.OperationCode == SCSIOP_VERIFY ||
            ((PCDB)pSrb -> Cdb) -> CDB10.OperationCode == SCSIOP_WRITE)) {

            for (Index = 0; Index < 4; Index++) {
                BadSector = (BadSector << 8) | pSenseBuffer -> Information[Index];
            }

            ReadSector = 0;
            for (Index = 0; Index < 4; Index++) {
                ReadSector = (ReadSector << 8) | pSrb -> Cdb[Index+2];
            }

            Index = (((PCDB)pSrb -> Cdb) -> CDB10.TransferBlocksMsb << 8) |
                ((PCDB)pSrb -> Cdb) -> CDB10.TransferBlocksLsb;

            //
            // Make sure the bad sector is within the read sectors.
            //

            if (!(BadSector >= ReadSector && BadSector < ReadSector + Index)) {
                BadSector = ReadSector;
            }
        }

    } else {

        //
        // Request sense buffer not valid. No sense information
        // to pinpoint the error. Return general request fail.
        //

        DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Request sense info not valid. SrbStatus %2x\n",
                    SRB_STATUS(pSrb -> SrbStatus)));
        Retry = TRUE;

        switch (SRB_STATUS(pSrb -> SrbStatus)) {
        case SRB_STATUS_INVALID_LUN:
        case SRB_STATUS_INVALID_TARGET_ID:
        case SRB_STATUS_NO_DEVICE:
        case SRB_STATUS_NO_HBA:
        case SRB_STATUS_INVALID_PATH_ID:
            *Status = STATUS_NO_SUCH_DEVICE;
            Retry = FALSE;
            break;

        case SRB_STATUS_COMMAND_TIMEOUT:
        case SRB_STATUS_ABORTED:
        case SRB_STATUS_TIMEOUT:

            //
            // Update the error count for the device.
            //

            pde -> ErrorCount++;
            *Status = STATUS_IO_TIMEOUT;
            break;

       case SRB_STATUS_SELECTION_TIMEOUT:

           //
           // Avoid reporting too much if device seems to be not connected
           //
           if (pde->LastSrbError != SRB_STATUS_SELECTION_TIMEOUT) {
               LogError = TRUE;
           }

            LogStatus = IO_ERR_NOT_READY;
            UniqueId = 260;
            *Status = STATUS_DEVICE_NOT_CONNECTED;
            Retry = FALSE;
            break;

        case SRB_STATUS_DATA_OVERRUN:
            *Status = STATUS_DATA_OVERRUN;
            Retry = FALSE;
            break;

        case SRB_STATUS_PHASE_SEQUENCE_FAILURE:

            //
            // Update the error count for the device.
            //

            pde -> ErrorCount++;
            *Status = STATUS_IO_DEVICE_ERROR;

            //
            // If there was phase sequence error then limit the number of
            // retries.
            //

            if (RetryCount > 1 ) {
                Retry = FALSE;
            }
            break;

        case SRB_STATUS_REQUEST_FLUSHED:
            *Status = STATUS_IO_DEVICE_ERROR;
            break;

        case SRB_STATUS_INVALID_REQUEST:

            //
            // An invalid request was attempted.
            //

            *Status = STATUS_INVALID_DEVICE_REQUEST;
            Retry = FALSE;
            break;

        case SRB_STATUS_UNEXPECTED_BUS_FREE:
        case SRB_STATUS_PARITY_ERROR:

            //
            // Update the error count for the device.
            //

            pde -> ErrorCount++;

            //
            // Fall through to below.
            //

        case SRB_STATUS_BUS_RESET:
            *Status = STATUS_IO_DEVICE_ERROR;
            break;

        case SRB_STATUS_ERROR:
            *Status = STATUS_IO_DEVICE_ERROR;
            if (pSrb -> ScsiStatus == 0) {

                //
                // This is some strange return code.  Update the error
                // count for the device.
                //

                pde -> ErrorCount++;
            }

            if (pSrb -> ScsiStatus == SCSISTAT_BUSY) {
                *Status = STATUS_DEVICE_NOT_READY;
            }

            if (pSrb -> ScsiStatus == SCSISTAT_RESERVATION_CONFLICT) {
                *Status = STATUS_DEVICE_BUSY;
                Retry = FALSE;
            }
            break;

        default:
            LogError = TRUE;
            LogStatus = IO_ERR_CONTROLLER_ERROR;
            UniqueId = 259;
            *Status = STATUS_IO_DEVICE_ERROR;
            break;

        }

        //
        // If the error count has exceeded the error limit, then disable
        // any tagged queuing, multiple requests per lu queueing
        // and sychronous data transfers.
        //

        if (pde -> ErrorCount == 4) {

            //
            // Clearing the no queue freeze flag prevents the port driver
            // from sending multiple requests per logical unit.
            //

            pde -> SrbFlags &= ~(SRB_FLAGS_QUEUE_ACTION_ENABLE |
                               SRB_FLAGS_NO_QUEUE_FREEZE);

            pde -> SrbFlags |= SRB_FLAGS_DISABLE_SYNCH_TRANSFER;
            DebugTrace(MAX_TRACE,( "ScsiScannerInterpretSenseInfo: Too many errors disabling tagged queuing and synchronous data tranfers.\n"));

        } else if (pde -> ErrorCount == 8) {

            //
            // If a second threshold is reached, disable disconnects.
            //

            //pde -> SrbFlags |= SRB_FLAGS_DISABLE_DISCONNECT;
            DebugTrace(MAX_TRACE,( "ScsiScannerInterpretSenseInfo: Too many errors disabling disconnects.\n"));
        }
    }

    //
    // Log an error if necessary.
    //
    pde->LastSrbError = SRB_STATUS(pSrb -> SrbStatus);

    if (LogError) {
        pErrorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
            pDeviceObject,
            sizeof(IO_ERROR_LOG_PACKET) + 5 * sizeof(ULONG));

        if (NULL == pErrorLogEntry) {

            //
            // Return if no packet could be allocated.
            //

            return Retry;

        }

        if (Retry && RetryCount < MAXIMUM_RETRIES) {
            pErrorLogEntry -> FinalStatus = STATUS_SUCCESS;
        } else {
            pErrorLogEntry -> FinalStatus = *Status;
        }

        //
        // Calculate the device offset if there is a geometry.
        //

        pErrorLogEntry -> ErrorCode = LogStatus;
        pErrorLogEntry -> SequenceNumber = 0;
        pErrorLogEntry -> MajorFunctionCode = MajorFunctionCode;
        pErrorLogEntry -> IoControlCode = IoDeviceCode;
        pErrorLogEntry -> RetryCount = (UCHAR) RetryCount;
        pErrorLogEntry -> UniqueErrorValue = UniqueId;
        pErrorLogEntry -> DumpDataSize = 6 * sizeof(ULONG);
        pErrorLogEntry -> DumpData[0] = pSrb -> PathId;
        pErrorLogEntry -> DumpData[1] = pSrb -> TargetId;
        pErrorLogEntry -> DumpData[2] = pSrb -> Lun;
        pErrorLogEntry -> DumpData[3] = 0;
        pErrorLogEntry -> DumpData[4] = pSrb -> SrbStatus << 8 | pSrb -> ScsiStatus;

        if (pSenseBuffer != NULL) {
            pErrorLogEntry -> DumpData[5] = pSenseBuffer -> SenseKey << 16 |
                                     pSenseBuffer -> AdditionalSenseCode << 8 |
                                     pSenseBuffer -> AdditionalSenseCodeQualifier;

        }
        //
        // Write the error log packet.
        //

        IoWriteErrorLogEntry(pErrorLogEntry);
    }

    return Retry;

} // end ScsiScannerInterpretSenseInfo()



VOID
ClassReleaseQueue(
    IN PDEVICE_OBJECT pDeviceObject
    )

/*++

Routine Description:
    This routine issues an internal device control command
    to the port driver to release a frozen queue. The call
    is issued asynchronously as ClassReleaseQueue will be invoked
    from the IO completion DPC (and will have no context to
    wait for a synchronous call to complete).

Arguments:
    pDeviceObject - The functional device object for the device with the frozen queue.

Return Value:
    None.

--*/
{
    PIO_STACK_LOCATION              pIrpStack;
    PIRP                            pIrp;
    PSCSISCAN_DEVICE_EXTENSION      pde;
    PCOMPLETION_CONTEXT             pContext;
    PSCSI_REQUEST_BLOCK             pSrb;
    KIRQL                           CurrentIrql;


    DebugTrace(MAX_TRACE,("Release Queue \n"));

    //
    // Get our device extension.
    //

    pde = (PSCSISCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    //
    // Allocate context from nonpaged pool.
    //

    pContext = MyAllocatePool(NonPagedPool,
                               sizeof(COMPLETION_CONTEXT));
    if(NULL == pContext){
        DebugTrace(MAX_TRACE,("ClassReleaseQueue: ERROR!! Couldn't allocate context memory.\n"));
        goto ClassReleaseQueue_return;
    } // if(NULL == pContext)
    pContext -> Signature = 'pmoC';

    //
    // Save the device object in the context for use by the completion
    // routine.
    //

    pContext->pDeviceObject = pDeviceObject;
    pSrb = &(pContext->Srb);

    //
    // Zero out srb.
    //

    RtlZeroMemory(pSrb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Write length to SRB.
    //

    pSrb->Length = SCSI_REQUEST_BLOCK_SIZE;

    //
    // specify release queue command.
    //

    pSrb->Function = SRB_FUNCTION_RELEASE_QUEUE;

    //
    // Build the asynchronous request to be sent to the port driver.
    //

    pIrp = IoAllocateIrp(pDeviceObject->StackSize, FALSE);

    if (pIrp != NULL ) {

        IoSetCompletionRoutine(pIrp,
                               (PIO_COMPLETION_ROUTINE)ClassAsynchronousCompletion,
                               pContext,
                               TRUE,
                               TRUE,
                               TRUE);

        pIrpStack = IoGetNextIrpStackLocation(pIrp);

        pIrpStack->MajorFunction = IRP_MJ_SCSI;

        pSrb->OriginalRequest = pIrp;

        //
        // Store the SRB address in next stack for port driver.
        //

        pIrpStack->Parameters.Scsi.Srb = pSrb;

        //
        // Since this routine can cause outstanding requests to be completed, and
        // calling a completion routine at < DISPATCH_LEVEL is dangerous (if they
        // call IoStartNextPacket we will bugcheck) raise up to dispatch level before
        // issuing the request
        //

        CurrentIrql = KeGetCurrentIrql();

        if(CurrentIrql < DISPATCH_LEVEL) {
            KeRaiseIrql(DISPATCH_LEVEL, &CurrentIrql);
            IoCallDriver(pde->pStackDeviceObject, pIrp);
            KeLowerIrql(CurrentIrql);
        } else {
            IoCallDriver(pde->pStackDeviceObject, pIrp);
        }

    }
    else {

        DebugTrace(MAX_TRACE,("ScsiScanner Couldn't allocate IRP \n"));

        //
        // Free context if we are bailing out
        //
        if (pContext) {
            MyFreePool(pContext);
            pContext = NULL;
        }

        // return STATUS_INSUFFICIENT_RESOURCES;
    }

ClassReleaseQueue_return:
    return;

} // end ClassReleaseQueue()



NTSTATUS
ClassAsynchronousCompletion(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp,
    PCOMPLETION_CONTEXT pContext
    )
/*++

Routine Description:
    This routine is called when an asynchronous I/O request
    which was issused by the class driver completes.  Examples of such requests
    are release queue or START UNIT. This routine releases the queue if
    necessary.  It then frees the context and the IRP.

Arguments:
    pDeviceObject - The device object for the logical unit; however since this
                    is the top stack location the value is NULL.
    pIrp          - Supplies a pointer to the Irp to be processed.
    pContext      - Supplies the context to be used to process this request.

Return Value:
    None.

--*/

{
    PSCSI_REQUEST_BLOCK pSrb;

    pSrb = &(pContext->Srb);

    //
    // If this is an execute srb, then check the return status and make sure.
    // the queue is not frozen.
    //

    if (pSrb->Function == SRB_FUNCTION_EXECUTE_SCSI) {

        //
        // Check for a frozen queue.
        //

        if (pSrb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {

            //
            // Unfreeze the queue getting the device object from the context.
            //

            ClassReleaseQueue(pContext->pDeviceObject);
        }
    }

    //
    // Free the context and the Irp.
    //

    if (pIrp->MdlAddress != NULL) {
        MmUnlockPages(pIrp->MdlAddress);
        IoFreeMdl(pIrp->MdlAddress);
        pIrp->MdlAddress = NULL;
    }

    if (pContext) {
        MyFreePool(pContext);
    }

    IoFreeIrp(pIrp);

    //
    // Indicate the I/O system should stop processing the Irp completion.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // ClassAsynchronousCompletion()



NTSTATUS
ClassGetInfo(
    IN PDEVICE_OBJECT pDeviceObject,
    OUT PSCSISCAN_INFO pTargetInfo
    )
/*++

Routine Description:
    This routine will get target device information such as SCSI ID, LUN, and
    PortNumber. It calls portdriver with IOCTL_SCSI_GET_ADDRESS to retrieve
    required data. Caller has to have allocated the data buffer beforehand.

    This routine must be run at IRQL_PASSIVE_LEVEL

Arguments:
    pDeviceObject - the device to query
    pTargetInfo   - a location to store the data of target SCSI device

Return Value:
    Status

--*/
{
    PIRP                       pIrp = NULL;
    PKEVENT                    pEvent = NULL;
    PSCSI_ADDRESS              pLocalInfo = NULL;

    IO_STATUS_BLOCK            StatusBlock;
    NTSTATUS                   Status ;

    //
    // Set the descriptor pointer to NULL and
    // Initialize the event we're going to wait on.
    //

    pEvent =  NULL;
    pLocalInfo = NULL;

    pEvent = MyAllocatePool(NonPagedPool, sizeof(KEVENT));
    if(pEvent == NULL) {
        DebugTrace(MAX_TRACE,("ClassGetInfo: Unable to allocate event\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    pLocalInfo = MyAllocatePool(NonPagedPool, sizeof(SCSI_ADDRESS));
    if(pLocalInfo == NULL) {
        DebugTrace(MAX_TRACE,("ClassGetInfo: Unable to allocate local buffer\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    KeInitializeEvent(pEvent, SynchronizationEvent, FALSE);

    __try {

        //
        // Build irp and wait for it to complete (if necessary)
        //

        pIrp = IoBuildDeviceIoControlRequest(
                   IOCTL_SCSI_GET_ADDRESS,                // IOCTL code
                   pDeviceObject,                         // DeviceObject to be called
                   NULL,                                  // input buffer
                   0,                                     // size of input buffer
                   pLocalInfo,                            // output buffer
                   sizeof(SCSI_ADDRESS),                  // size of output buffer
                   FALSE,                                 // IRP_MJ_DEVICE_CONTROL
                   pEvent,                                // event is called when completion
                   &StatusBlock);                         // IO status block

        if (pIrp == NULL) {
            DebugTrace(MAX_TRACE,("ClassGetInfo: unable to allocate irp\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
        }

        Status = IoCallDriver(pDeviceObject, pIrp);

        if (Status == STATUS_PENDING) {
            KeWaitForSingleObject(pEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
            Status = StatusBlock.Status;
        }

        if (!NT_SUCCESS(Status)) {
            DebugTrace(MAX_TRACE,
                             ("ClassGetInfo: error %#08lx\n",
                              Status));
            __leave;
        }
    } __finally {
        if(NT_SUCCESS(Status)) {
            pTargetInfo->PortNumber = pLocalInfo->PortNumber;
            pTargetInfo->PathId = pLocalInfo->PathId;
            pTargetInfo->TargetId = pLocalInfo->TargetId;
            pTargetInfo->Lun = pLocalInfo->Lun;
        }

    }

Cleanup:

    //
    // Release resources
    //
    if (pEvent) {
        MyFreePool(pEvent);
        pEvent = NULL;

    }

    if (pLocalInfo) {
        MyFreePool(pLocalInfo);
        pLocalInfo = NULL;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\scsiscan\scsiscan.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    scsiscan.c

Abstract:

    The scsi scanner class driver translates IRPs to SRBs with embedded CDBs
    and sends them to its devices through the port driver.

Author:

    Ray Patrick (raypat)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//
// Include
//

#define INITGUID

#include <stdio.h>
#include "stddef.h"
#include "wdm.h"
#include "scsi.h"
#include "ntddstor.h"
#include "ntddscsi.h"
#include "scsiscan.h"
#include "private.h"
#include <wiaintfc.h>
#include "debug.h"

#include <initguid.h>
#include <devguid.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, SSPnp)
#pragma alloc_text(PAGE, SSPnpAddDevice)
#pragma alloc_text(PAGE, SSOpen)
#pragma alloc_text(PAGE, SSClose)
#pragma alloc_text(PAGE, SSReadWrite)
#pragma alloc_text(PAGE, SSDeviceControl)
#pragma alloc_text(PAGE, SSAdjustTransferSize)
#pragma alloc_text(PAGE, SSBuildTransferContext)
#pragma alloc_text(PAGE, SSCreateSymbolicLink)
#pragma alloc_text(PAGE, SSDestroySymbolicLink)
#pragma alloc_text(PAGE, SSUnload)
#endif

DEFINE_GUID(GUID_STI_DEVICE, 0xF6CBF4C0L, 0xCC61, 0x11D0, 0x84, 0xE5, 0x00, 0xA0, 0xC9, 0x27, 0x65, 0x27);

//
// Globals
//

ULONG NextDeviceInstance = 0;

#if DBG
 ULONG SCSISCAN_DebugTraceLevel = MAX_TRACE;
#endif

#define DBG_DEVIOCTL 1

#ifdef _WIN64
BOOLEAN
IoIs32bitProcess(
    IN PIRP Irp
    );
#endif // _WIN64


//
// Function
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine initializes the scanner class driver. The driver
    opens the port driver by name and then receives configuration
    information used to attach to the scanner devices.

Arguments:

    DriverObject

Return Value:

    NT Status

--*/
{

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("DriverEntry: Enter...\n"));

    MyDebugInit(RegistryPath);

    //
    // Set up the device driver entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_READ]            = SSReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE]           = SSReadWrite;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = SSDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = SSOpen;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = SSClose;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = SSPnp;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = SSPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER]           = SSPower;
    DriverObject->DriverUnload                          = SSUnload;
    DriverObject->DriverExtension->AddDevice            = SSPnpAddDevice;

    DebugTrace(TRACE_PROC_LEAVE,("DriverEntry: Leaving... Status=STATUS_SUCCESS\n"));
    return STATUS_SUCCESS;

} // end DriverEntry



NTSTATUS
SSPnpAddDevice(
    IN PDRIVER_OBJECT pDriverObject,
    IN PDEVICE_OBJECT pPhysicalDeviceObject
    )
/*++

Routine Description:

    This routine is called to create a new instance of the device.

Arguments:

    pDriverObject - pointer to the driver object for this instance of SS
    pPhysicalDeviceObject - pointer to the device object that represents the scanner
    on the scsi bus.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    UCHAR                       aName[64];
    ANSI_STRING                 ansiName;
    UNICODE_STRING              uName;
    PDEVICE_OBJECT              pDeviceObject = NULL;
    NTSTATUS                    Status;
    PSCSISCAN_DEVICE_EXTENSION  pde;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("SSPnpAddDevice: Enter...\n"));

    //
    // Check arguments.
    //

    if( (NULL == pDriverObject)
     || (NULL == pPhysicalDeviceObject) )
    {
        DebugTrace(TRACE_ERROR,("SSPnpAddDevice: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("SSPnpAddDevice: Leaving.. Status = 0x%x.\n", Status));
        return Status;
    }

    //
    // Create the Functional Device Object (FDO) for this device.
    //

    _snprintf(aName, sizeof(aName), "\\Device\\Scanner%d",NextDeviceInstance);
    aName[ARRAYSIZE(aName)-1] = '\0';
    RtlInitAnsiString(&ansiName, aName);
    DebugTrace(TRACE_STATUS,("SSPnpAddDevice: Create device object %s\n", aName));
    RtlAnsiStringToUnicodeString(&uName, &ansiName, TRUE);

    //
    // Create device object for this scanner.
    //

    Status = IoCreateDevice(pDriverObject,
                            sizeof(SCSISCAN_DEVICE_EXTENSION),
                            &uName,
                            FILE_DEVICE_SCANNER,
                            0,
                            FALSE,
                            &pDeviceObject);

    RtlFreeUnicodeString(&uName);

    if (!NT_SUCCESS(Status)) {
        DebugTrace(TRACE_ERROR,("SSPnpAddDevice: ERROR!! Can't create device object\n"));
        DEBUG_BREAKPOINT();
        return Status;
    }

    //
    // Indicate that IRPs should include MDLs and it's pawer pagable.
    //

    pDeviceObject->Flags |=  DO_DIRECT_IO;
    pDeviceObject->Flags |=  DO_POWER_PAGABLE;

    //
    // Initialize Device Extention
    //

    pde = (PSCSISCAN_DEVICE_EXTENSION)(pDeviceObject -> DeviceExtension);
    RtlZeroMemory(pde, sizeof(SCSISCAN_DEVICE_EXTENSION));

    //
    // Attach our new FDO to the PDO (Physical Device Object).
    //

    pde -> pStackDeviceObject = IoAttachDeviceToDeviceStack(pDeviceObject,
                                                            pPhysicalDeviceObject);
    if (NULL == pde -> pStackDeviceObject) {
        DebugTrace(MIN_TRACE,("Cannot attach FDO to PDO.\n"));
        DEBUG_BREAKPOINT();
        IoDeleteDevice( pDeviceObject );
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Remember the PDO in our device extension.
    //

    pde -> pPhysicalDeviceObject = pPhysicalDeviceObject;

    //
    // Remember the DeviceInstance number.
    //

    pde -> DeviceInstance = NextDeviceInstance;

    //
    // Reset SRB error status
    //

    pde->LastSrbError = 0L;

    //
    // Disable synchronous transfer for scanner requests.
    // Disable QueueFreeze in case of any error.
    //

    pde -> SrbFlags = SRB_FLAGS_DISABLE_SYNCH_TRANSFER | SRB_FLAGS_NO_QUEUE_FREEZE ;

    //
    // Set timeout value in seconds.
    //

    pde -> TimeOutValue = SCSISCAN_TIMEOUT;

    //
    // Handle exporting interface
    //

    Status = ScsiScanHandleInterface(
        pPhysicalDeviceObject,
        &pde->InterfaceNameString,
        TRUE
        );

    //
    // Each time AddDevice gets called, we advance the global DeviceInstance variable.
    //

    NextDeviceInstance++;

    //
    // Finishing initialize.
    //

    pDeviceObject -> Flags &= ~DO_DEVICE_INITIALIZING;

    DebugTrace(TRACE_PROC_LEAVE,("SSPnpAddDevice: Leaving... Status=STATUS_SUCCESS\n"));
    return STATUS_SUCCESS;

} // end SSPnpAddDevice()


NTSTATUS SSPnp (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   )
/*++

Routine Description:

    This routine handles all PNP irps.

Arguments:

    pDevciceObject - represents a scsi scanner device
    pIrp - PNP irp

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                      Status;
    PSCSISCAN_DEVICE_EXTENSION    pde;
    PIO_STACK_LOCATION            pIrpStack;
    STORAGE_PROPERTY_ID           PropertyId;
    KEVENT                        event;
    PDEVICE_CAPABILITIES          pCaps;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("SSPnp: Enter...\n"));

    Status = STATUS_SUCCESS;

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("SSPnp: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("SSPnp: Leaving.. Status = 0x%x.\n", Status));
        return Status;
    }

    pde         = (PSCSISCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pIrpStack   = IoGetCurrentIrpStackLocation( pIrp );

    switch (pIrpStack -> MajorFunction) {

        case IRP_MJ_SYSTEM_CONTROL:
            DebugTrace(TRACE_STATUS,("SSPnp: IRP_MJ_SYSTEM_CONTROL\n"));

            //
            // Just passing down IRP to the next layer.
            //

            IoCopyCurrentIrpStackLocationToNext( pIrp );
            Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);
            return Status;
            break;

        case IRP_MJ_PNP:
            DebugTrace(TRACE_STATUS,("SSPnp: IRP_MJ_PNP\n"));
            switch (pIrpStack->MinorFunction) {

                case IRP_MN_QUERY_CAPABILITIES:
                    DebugTrace(TRACE_STATUS,("SSPnp: IRP_MN_QUERY_CAPABILITIES\n"));

                    pCaps = pIrpStack -> Parameters.DeviceCapabilities.Capabilities;

                    //
                    // fill in the structure with non-controversial values
                    //

                    pCaps -> D1Latency = 10;
                    pCaps -> D2Latency = 10;
                    pCaps -> D3Latency = 10;

                    //
                    // Set SurpriseRemoval OK for SBP2 devices.
                    //
                    
                    pCaps->SurpriseRemovalOK = TRUE;
                    pCaps->Removable = TRUE;

                    //
                    // Call down synchronously.
                    //

                    pIrp -> IoStatus.Status = STATUS_SUCCESS;
                    Status = SSCallNextDriverSynch(pde, pIrp);
                    if(!NT_SUCCESS(Status)){
                        DebugTrace(TRACE_ERROR,("SSPnp: ERROR!! Call down failed\n Status=0x%x", Status));
                    }

                    //
                    // Complete IRP.
                    //

                    IoCompleteRequest( pIrp, IO_NO_INCREMENT );
                    return Status;


                case IRP_MN_START_DEVICE:
                    DebugTrace(TRACE_STATUS,("SSPnp: IRP_MN_START_DEVICE\n"));

                    //
                    // Initialize PendingIoEvent.  Set the number of pending i/o requests for this device to 1.
                    // When this number falls to zero, it is okay to remove, or stop the device.
                    //

                    pde -> PendingIoCount = 0;
                    KeInitializeEvent(&pde -> PendingIoEvent, NotificationEvent, FALSE);
                    SSIncrementIoCount(pDeviceObject);

                    //
                    // First, let the port driver start the device. Simply passing down IRP.
                    //

                    Status = SSCallNextDriverSynch(pde, pIrp);
                    if(!NT_SUCCESS(Status)){
                        DebugTrace(TRACE_ERROR,("SSPnp: ERROR!! Call down failed\n Status=0x%x", Status));
                        break;
                    }

                    //
                    // The port driver has started the device.  It is time for
                    // us to do some initialization and create symbolic links
                    // for the device.
                    //

                    //
                    // Call port driver to get adapter capabilities.
                    //

                    PropertyId = StorageAdapterProperty;
                    pde -> pAdapterDescriptor = NULL;
                    Status = ClassGetDescriptor(pde -> pStackDeviceObject,
                                                &PropertyId,
                                                &(pde -> pAdapterDescriptor));
                    if(!NT_SUCCESS(Status)) {
                        DebugTrace(TRACE_ERROR, ("SSPnp: ERROR!! unable to retrieve adapter descriptor.\n"
                            "[%#08lx]\n", Status));
                        DEBUG_BREAKPOINT();
                        if (NULL != pde -> pAdapterDescriptor) {
                            MyFreePool( pde -> pAdapterDescriptor);
                            pde -> pAdapterDescriptor = NULL;
                        }
                        break;
                    }

                    //
                    // Create the symbolic link for this device.
                    //

                    Status = SSCreateSymbolicLink( pde );
                    if (!NT_SUCCESS(Status)) {
                        DebugTrace(TRACE_ERROR, ("SSPnp: ERROR!! Can't create symbolic link.\n"));
                        DEBUG_BREAKPOINT();
                        if (NULL != pde -> pAdapterDescriptor) {
                            MyFreePool( pde -> pAdapterDescriptor);
                            pde -> pAdapterDescriptor = NULL;
                        }
                        break;
                    }

                    //
                    // Indicate device is now ready.
                    //

                    pde -> DeviceLock = 0;
                    pde -> OpenInstanceCount = 0;
                    pde -> AcceptingRequests = TRUE;
                    pIrp -> IoStatus.Status = Status;
                    pIrp -> IoStatus.Information = 0;

                    pde -> LastSrbError = 0L;

                    IoCompleteRequest( pIrp, IO_NO_INCREMENT );
                    return Status;
                    break;

                case IRP_MN_REMOVE_DEVICE:
                    DebugTrace(TRACE_STATUS,("SSPnp: IRP_MN_REMOVE_DEVICE\n"));

                    //
                    // Forward remove message to lower driver.
                    //

                    IoCopyCurrentIrpStackLocationToNext(pIrp);
                    pIrp -> IoStatus.Status = STATUS_SUCCESS;

                    Status = SSCallNextDriverSynch(pde, pIrp);
                    if(!NT_SUCCESS(Status)){
                        DebugTrace(TRACE_ERROR,("SSPnp: ERROR!! Call down failed\n Status=0x%x", Status));
                    }

                    if (pde -> AcceptingRequests) {
                        pde -> AcceptingRequests = FALSE;
                        SSDestroySymbolicLink( pde );
                    }

                    ScsiScanHandleInterface(pde-> pPhysicalDeviceObject,
                                            &pde->InterfaceNameString,
                                            FALSE);

#ifndef _CHICAGO_
                    if (pde->InterfaceNameString.Buffer != NULL) {
                        IoSetDeviceInterfaceState(&pde->InterfaceNameString,FALSE);
                    }
#endif // !_CHICAGO_
                    //
                    // wait for any io requests pending in our driver to
                    // complete before finishing the remove
                    //

                    SSDecrementIoCount(pDeviceObject);
                    KeWaitForSingleObject(&pde -> PendingIoEvent, Suspended, KernelMode,
                                          FALSE,NULL);

                    if (pde -> pAdapterDescriptor) {
                        MyFreePool(pde -> pAdapterDescriptor);
                        pde -> pAdapterDescriptor = NULL;
                    }

                    IoDetachDevice(pde -> pStackDeviceObject);
                    IoDeleteDevice (pDeviceObject);
                    Status = STATUS_SUCCESS;
                    pIrp -> IoStatus.Status = Status;
                    pIrp -> IoStatus.Information = 0;
                    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
                    return Status;
                    break;

            case IRP_MN_STOP_DEVICE:
                    DebugTrace(TRACE_STATUS,("SSPnp: IRP_MN_STOP_DEVICE\n"));

                    //
                    // Indicate device is not ready.
                    //

                    ASSERT(pde -> AcceptingRequests);
                    pde -> AcceptingRequests = FALSE;

                    //
                    // Remove symbolic link.
                    //

                    SSDestroySymbolicLink( pde );

#ifndef _CHICAGO_
                    if (pde->InterfaceNameString.Buffer != NULL) {
                        IoSetDeviceInterfaceState(&pde->InterfaceNameString,FALSE);
                    }
#endif // !_CHICAGO_

                    //
                    // Let the port driver stop the device.
                    //

                    pIrp -> IoStatus.Status = STATUS_SUCCESS;

                    Status = SSCallNextDriverSynch(pde, pIrp);
                    if(!NT_SUCCESS(Status)){
                        DebugTrace(TRACE_ERROR,("SSPnp: ERROR!! Call down failed\n Status=0x%x", Status));
                    }

                    //
                    // wait for any io requests pending in our driver to
                    // complete before finishing the remove
                    //

                    SSDecrementIoCount(pDeviceObject);
                    KeWaitForSingleObject(&pde -> PendingIoEvent, Suspended, KernelMode,
                                          FALSE,NULL);
                    //
                    // Free Adapter Descriptor
                    //

                    if(pde -> pAdapterDescriptor){
                        MyFreePool(pde -> pAdapterDescriptor);
                        pde -> pAdapterDescriptor = NULL;

                    } else {
                        DebugTrace(TRACE_ERROR,("SSPnp: ERROR!! AdapterDescriptor doesn't exist.\n"));
                        DEBUG_BREAKPOINT();
                    }

                    Status = STATUS_SUCCESS;
                    pIrp -> IoStatus.Status = Status;
                    pIrp -> IoStatus.Information = 0;
                    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
                    return Status;
                    break;

            case IRP_MN_QUERY_STOP_DEVICE:
                    DebugTrace(TRACE_STATUS,("SSPnp: IRP_MN_QUERY_STOP_DEVICE\n"));
                    pIrp->IoStatus.Status = STATUS_SUCCESS;
                    break;

            case IRP_MN_QUERY_REMOVE_DEVICE:
                    DebugTrace(TRACE_STATUS,("SSPnp: IRP_MN_QUERY_REMOVE_DEVICE\n"));
                    pIrp->IoStatus.Status = STATUS_SUCCESS;
                    break;

            case IRP_MN_CANCEL_STOP_DEVICE:
                    DebugTrace(TRACE_STATUS,("SSPnp: IRP_MN_CANCEL_STOP_DEVICE\n"));
                    pIrp->IoStatus.Status = STATUS_SUCCESS;
                    break;

            case IRP_MN_CANCEL_REMOVE_DEVICE:
                    DebugTrace(TRACE_STATUS,("SSPnp: IRP_MN_CANCEL_REMOVE_DEVICE\n"));
                    pIrp->IoStatus.Status = STATUS_SUCCESS;
                    break;

            case IRP_MN_SURPRISE_REMOVAL:
                    DebugTrace(TRACE_STATUS,("SSPnp: IRP_MN_SURPRISE_REMOVAL\n"));
                    pIrp->IoStatus.Status = STATUS_SUCCESS;
                    break;

                default:
                    DebugTrace(TRACE_STATUS,("SSPnp: Minor PNP message received, MinFunction = %x\n",
                                                pIrpStack->MinorFunction));
                    break;

            } /* case MinorFunction, MajorFunction == IRP_MJ_PNP_POWER  */

            ASSERT(Status == STATUS_SUCCESS);
            if (!NT_SUCCESS(Status)) {
                pIrp -> IoStatus.Status = Status;
                IoCompleteRequest( pIrp, IO_NO_INCREMENT );

                DebugTrace(TRACE_PROC_LEAVE,("SSPnp: Leaving(w/ Error)... Status=%x\n", Status));
                return Status;
            }

            //
            // Passing down IRP
            //

            IoCopyCurrentIrpStackLocationToNext(pIrp);
            Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);
            DebugTrace(TRACE_PROC_LEAVE,("SSPnp: Leaving... Status=%x\n", Status));
            return Status;
            break; // IRP_MJ_PNP

        default:
            DebugTrace(TRACE_WARNING,("SSPnp: WARNING!! Not handled Major PNP IOCTL.\n"));
            pIrp -> IoStatus.Status = STATUS_INVALID_PARAMETER;
            IoCompleteRequest( pIrp, IO_NO_INCREMENT );
            DebugTrace(TRACE_PROC_LEAVE,("SSPnp: Leaving... Status=STATUS_INVALID_PARAMETER\n", Status));
            return Status;

    } /* case MajorFunction */

} // end SSPnp()


NTSTATUS
SSOpen(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine is called to establish a connection to the device
    class driver. It does no more than return STATUS_SUCCESS.

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Open request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                    Status;
    PSCSISCAN_DEVICE_EXTENSION  pde;
    PIO_STACK_LOCATION          pIrpStack;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("SSOpen: Enter...\n"));

    Status = STATUS_SUCCESS;

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("SSOpen: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("SSOpen: Leaving.. Status = 0x%x.\n", Status));
        return Status;
    }

    pde         = (PSCSISCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pIrpStack   = IoGetCurrentIrpStackLocation( pIrp );

    //
    // Increment pending IO count
    //

    SSIncrementIoCount( pDeviceObject );

    //
    // Initialize IoStatus
    //

    Status = STATUS_SUCCESS;

    pIrp -> IoStatus.Information = 0;
    pIrp -> IoStatus.Status = Status;

    //
    // Save instance-count to the context in file object.
    //

    (ULONG)(UINT_PTR)(pIrpStack -> FileObject -> FsContext) = InterlockedIncrement(&pde -> OpenInstanceCount);

    //
    // Check if device is not going away, in which case fail open request.
    //

    if (pde -> AcceptingRequests == FALSE) {
        DebugTrace(TRACE_STATUS,("SSOpen: Device doesn't exist.\n"));
        Status = STATUS_DELETE_PENDING;

        pIrp -> IoStatus.Information = 0;
        pIrp -> IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        SSDecrementIoCount(pDeviceObject);

        DebugTrace(TRACE_PROC_LEAVE,("SSOpen: Leaving... Status=STATUS_DELETE_PENDING\n"));
        return Status;
    }

    //
    // Decrement pending IO count
    //

    SSDecrementIoCount(pDeviceObject);

    //
    // Passing down IRP.
    //

    IoSkipCurrentIrpStackLocation( pIrp );
    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

    DebugTrace(TRACE_PROC_LEAVE,("SSOpen: Leaving... Status=%x\n", Status));
    return Status;

} // end SSOpen()


NTSTATUS
SSClose(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
/*++

Routine Description:

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Open request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                    Status;
    PSCSISCAN_DEVICE_EXTENSION  pde;
    PIO_STACK_LOCATION          pIrpStack;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("SSClose: Enter...\n"));

    Status = STATUS_SUCCESS;

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("SSClose: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("SSClose: Leaving.. Status = 0x%x.\n", Status));
        return Status;
    }

    pde = (PSCSISCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    //
    // Increment pending IO count
    //

    SSIncrementIoCount( pDeviceObject );

    //
    // Clear instance-count in context
    //

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pIrpStack -> FileObject -> FsContext = 0;

    //
    // Initialize IoStatus
    //

    pIrp -> IoStatus.Information = 0;
    pIrp -> IoStatus.Status = Status;

    //
    // Decrement pending IO count
    //

    SSDecrementIoCount(pDeviceObject);

    //
    // Passing down IRP
    //

    IoSkipCurrentIrpStackLocation( pIrp );
    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

    DebugTrace(TRACE_PROC_LEAVE,("SSClose: Leaving... Status=%x\n", Status));
    return Status;

} // end SSClose()



NTSTATUS
SSDeviceControl(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
/*++

Routine Description:
    This function allows a user mode client to send CDBs to the device.

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Open request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    PIO_STACK_LOCATION          pIrpStack;
    PIO_STACK_LOCATION          pNextIrpStack;
    ULONG                       IoControlCode;
    ULONG                       OldTimeout;
    PSCSISCAN_DEVICE_EXTENSION  pde;
    PTRANSFER_CONTEXT           pTransferContext = NULL;
    PMDL                        pMdl = NULL;
    NTSTATUS                    Status;
    PVOID                       Owner;
    PULONG                      pTimeOut;
    PCDB                        pCdb;
    PVOID                       pUserBuffer;

    BOOLEAN                     fLockedSenseBuffer, fLockedSRBStatus;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("SSDeviceControl: Enter...\n"));

    Status = STATUS_SUCCESS;

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("SSDeviceControl: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("SSDeviceControl: Leaving.. Status = 0x%x.\n", Status));
        return Status;
    }

    SSIncrementIoCount( pDeviceObject );

    pde = (PSCSISCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    //
    // Validate state of the device
    //

    if (pde -> AcceptingRequests == FALSE) {
        DebugTrace(TRACE_WARNING,("SSDeviceControl: WARNING!! Device's been stopped/removed!\n"));
        Status = STATUS_DELETE_PENDING;
        pIrp -> IoStatus.Information = 0;
        goto SSDeviceControl_Complete;
    }

    //
    // Indicate that MDLs are not locked yet
    //

    fLockedSenseBuffer = fLockedSRBStatus = FALSE;

    //
    // Get context pointers
    //

    pIrpStack     = IoGetCurrentIrpStackLocation( pIrp );
    pNextIrpStack = IoGetNextIrpStackLocation( pIrp );
    IoControlCode = pIrpStack->Parameters.DeviceIoControl.IoControlCode;

    //
    // Get owner of device (0 = locked, >0 if someone has it locked)
    //

    Owner = InterlockedCompareExchangePointer(&pde -> DeviceLock,
                                              NULL,
                                              NULL);

    if (Owner != NULL) {
        if (Owner != pIrpStack -> FileObject -> FsContext) {
            DebugTrace(TRACE_WARNING,("SSDeviceControl: WARNING!! Device is already locked\n"));
            Status = STATUS_DEVICE_BUSY;
            pIrp -> IoStatus.Information = 0;
            goto SSDeviceControl_Complete;
        }
    }

    switch (IoControlCode) {

        case IOCTL_SCSISCAN_SET_TIMEOUT:
            DebugTrace(TRACE_STATUS,("SSDeviceControl: SCSISCAN_SET_TIMEOUT\n"));

            //
            // Get pointer of timeout buffer.
            //

            pTimeOut = pIrp -> AssociatedIrp.SystemBuffer;

            //
            // Validate size of the input parameter
            //

            if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(pde -> TimeOutValue) ) {
                DebugTrace(TRACE_WARNING,("SSDeviceControl: WARNING!! Buffer too small\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto SSDeviceControl_Complete;
            }

            OldTimeout = *pTimeOut;
            OldTimeout = InterlockedExchange(&pde -> TimeOutValue, *pTimeOut );

            DebugTrace(TRACE_STATUS,("SSDeviceControl: Timeout %d->%d\n",OldTimeout, *pTimeOut));

            pIrp -> IoStatus.Information = 0;

            //
            // If caller wanted to get old timeout value back - give it to him.
            // Ideally we should've require nonNULL value for output buffer, but it had not been speced
            // and now we can't change compatibility.
            //

            if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(OldTimeout) ) {
                *pTimeOut = OldTimeout;
                pIrp -> IoStatus.Information = sizeof(OldTimeout) ;
            }

            Status = STATUS_SUCCESS;
            goto SSDeviceControl_Complete;

        case IOCTL_SCSISCAN_LOCKDEVICE:
            DebugTrace(TRACE_STATUS,("SSDeviceControl: IOCTL_SCSISCAN_LOCKDEVICE\n"));

            //
            // Lock device
            //

            Status = STATUS_DEVICE_BUSY;
            if (NULL == InterlockedCompareExchangePointer(&pde -> DeviceLock,
                                                          pIrpStack -> FileObject -> FsContext,
                                                          NULL)) {
                Status = STATUS_SUCCESS;
            }
            goto SSDeviceControl_Complete;

        case IOCTL_SCSISCAN_UNLOCKDEVICE:
            DebugTrace(TRACE_STATUS,("SSDeviceControl: IOCTL_SCSISCAN_UNLOCKDEVICE\n"));

            //
            // Unlock device
            //

            Status = STATUS_DEVICE_BUSY;
            if (pIrpStack -> FileObject -> FsContext ==
                InterlockedCompareExchangePointer(&pde -> DeviceLock,
                                                  NULL,
                                                  pIrpStack -> FileObject -> FsContext)) {
                Status = STATUS_SUCCESS;
            }
            goto SSDeviceControl_Complete;

        case IOCTL_SCSISCAN_CMD:
        {
            SCSISCAN_CMD    LocalScsiscanCmd;
            PSCSISCAN_CMD   pCmd;

            DebugTrace(TRACE_STATUS,("SSDeviceControl: IOCTL_SCSISCAN_CMD\n"));

            //
            // Check input buffer size.
            //
            
#ifdef _WIN64
            if(IoIs32bitProcess(pIrp)){
                PSCSISCAN_CMD_32    pScsiscanCmd32;
                
                if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SCSISCAN_CMD_32) ) {
                    DebugTrace(TRACE_WARNING,("SSDeviceControl: WARNING!! Buffer too small\n"));
                    Status = STATUS_INVALID_PARAMETER;
                    goto SSDeviceControl_Complete;
                }
                
                //
                // Copy parameters from 32bit IOCTL buffer.
                //
                
                pCmd = &LocalScsiscanCmd;
                RtlZeroMemory(pCmd, sizeof(SCSISCAN_CMD));
                pScsiscanCmd32 = pIrp -> AssociatedIrp.SystemBuffer;

                pCmd -> Size            = pScsiscanCmd32 -> Size;
                pCmd -> SrbFlags        = pScsiscanCmd32 -> SrbFlags;
                pCmd -> CdbLength       = pScsiscanCmd32 -> CdbLength;
                pCmd -> SenseLength     = pScsiscanCmd32 -> SenseLength;
                pCmd -> TransferLength  = pScsiscanCmd32 -> TransferLength;
                pCmd -> pSrbStatus      = (PUCHAR)pScsiscanCmd32 -> pSrbStatus;
                pCmd -> pSenseBuffer    = (PUCHAR)pScsiscanCmd32 -> pSenseBuffer;

                RtlCopyMemory(pCmd -> Cdb, pScsiscanCmd32 -> Cdb, 16); // 16 = CDB buffer size.

            }  else { // if(IoIs32bitProcess(pIrp))
#endif // _WIN64

            if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SCSISCAN_CMD) ) {
                DebugTrace(TRACE_WARNING,("SSDeviceControl: WARNING!! Buffer too small\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto SSDeviceControl_Complete;
            }

            pCmd = pIrp -> AssociatedIrp.SystemBuffer;

#ifdef _WIN64
            } // if(IoIs32bitProcess(pIrp))
#endif // _WIN64

            //
            // Issue SCSI command
            //

            #if DBG_DEVIOCTL
            {
                PCDB    pCdb;

                pCdb = (PCDB)pCmd -> Cdb;
                DebugTrace(TRACE_STATUS,("SSDeviceControl: CDB->ControlCode = %d  \n",pCdb->CDB6GENERIC.OperationCode));
            }
            #endif

            pTransferContext = SSBuildTransferContext(pde,
                                                      pIrp,
                                                      pCmd,
                                                      pIrpStack -> Parameters.DeviceIoControl.InputBufferLength,
                                                      pIrp -> MdlAddress,
                                                      TRUE
                                                      );
            if (NULL == pTransferContext) {
                DebugTrace(TRACE_ERROR,("SSDeviceControl: ERROR!! Can't create transfer context!\n"));
                DEBUG_BREAKPOINT();
                Status = STATUS_INVALID_PARAMETER;
                goto SSDeviceControl_Complete;
            }

            //
            // Fill in transfer length in the CDB.
            //

            if(10 == pCmd -> CdbLength){

                //
                // Currently Scsiscan only supports flagmentation of 10bytes CDB.
                //

                SSSetTransferLengthToCdb((PCDB)pCmd -> Cdb, pTransferContext -> TransferLength);

            } else if (6 != pCmd -> CdbLength){

                //
                // If CdbLength is not 6 or 10 and transfer size exceeds adapter limit, SCSISCAN cannot handle it.
                //

                if(pTransferContext -> TransferLength != pCmd -> TransferLength){
                    DebugTrace(TRACE_WARNING,("SSDeviceControl: WARNING!! TransferLength (CDB !=6 or 10) exceeds limits!\n"));
                    Status = STATUS_INVALID_PARAMETER;
                    goto SSDeviceControl_Complete;
                }
            }

            //
            // Create system address for the user's sense buffer (if any).
            //

            if (pCmd -> SenseLength) {

                pTransferContext -> pSenseMdl = MmCreateMdl(NULL,
                                                            pCmd -> pSenseBuffer,
                                                            pCmd -> SenseLength);

                if (NULL == pTransferContext -> pSenseMdl) {
                    DebugTrace(TRACE_ERROR,("SSDeviceControl: ERROR!! Can't create MDL for sense buffer!\n"));
                    DEBUG_BREAKPOINT();

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto SSDeviceControl_Error_With_Status;
                }

                //
                // Probe and lock the pages associated with the
                // caller's buffer for write access , using processor mode of the requestor
                // Nb: Probing may cause an exception
                //

                try{

                    MmProbeAndLockPages(pTransferContext -> pSenseMdl,
                                        pIrp -> RequestorMode,
                                        IoModifyAccess
                                        );

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    //
                    // Invalid sense buffer pointer.
                    //

                    DebugTrace(TRACE_WARNING,("SSDeviceControl: WARNING!! Sense Buffer validation failed\n"));
                    Status = GetExceptionCode();

                    pIrp -> IoStatus.Information = 0;
                    goto SSDeviceControl_Error_With_Status;
                }  // except

                //
                // Indicate we succesfully locked sense buffer
                //

                fLockedSenseBuffer = TRUE;

                //
                // Get system address of sense buffer
                //

                pTransferContext -> pSenseMdl -> MdlFlags |= MDL_MAPPING_CAN_FAIL;
                pTransferContext -> pSenseBuffer =
                                     MmGetSystemAddressForMdl(pTransferContext -> pSenseMdl);

                if (NULL == pTransferContext -> pSenseBuffer) {

                    //
                    // Error with MmGetSystemAddressForMdl
                    //

                    DebugTrace(TRACE_ERROR,("SSDeviceControl: ERROR!! Can't get system address for sense buffer!\n"));
                    DEBUG_BREAKPOINT();

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto SSDeviceControl_Error_With_Status;
                }
            }

            //
            // Create system address for the user's srb status byte.
            //

            pMdl = MmCreateMdl(NULL,
                               pCmd -> pSrbStatus,
                               sizeof(UCHAR)
                               );
            if (NULL == pMdl) {
                DebugTrace(TRACE_ERROR,("SSDeviceControl: ERROR!! Can't create MDL for pSrbStatus!\n"));
                DEBUG_BREAKPOINT();

                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto SSDeviceControl_Error_With_Status;
            }

            //
            // Probe and lock the pages associated with the caller's
            // buffer for write access , using processor mode of the requestor
            // Nb: Probing may cause an exception
            //

            try{
                MmProbeAndLockPages(pMdl,
                                    pIrp -> RequestorMode,
                                    IoModifyAccess);

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // Invalid SRB status buffer pointer.
                //

                DebugTrace(TRACE_WARNING,("SSDeviceControl: WARNING!! SRB Status Buffer validation failed\n"));
                Status = GetExceptionCode();

                pIrp -> IoStatus.Information = 0;
                goto SSDeviceControl_Error_With_Status;
            } // except

            //
            // Indicate we successfully locked SRB status
            //

            fLockedSRBStatus = TRUE;

            //
            // Replace pSrbStatus with the address gotten from MmGetSystemAddressForMdl.
            //

            pMdl -> MdlFlags |= MDL_MAPPING_CAN_FAIL;
            pCmd -> pSrbStatus =  MmGetSystemAddressForMdl(pMdl);

            if (NULL == pCmd -> pSrbStatus) {

                //
                // Error with MmGetSystemAddressForMdl
                //

                DebugTrace(TRACE_ERROR,("SSDeviceControl: ERROR!! Can't get system address for pSrbStatus!\n"));
                DEBUG_BREAKPOINT();

                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto SSDeviceControl_Error_With_Status;
            }

            //
            // Save Mdl for pSrbStatus
            //

            pTransferContext -> pSrbStatusMdl = pMdl;

            break;
        } // case IOCTL_SCSISCAN_CMD:

        case IOCTL_SCSISCAN_GET_INFO:
            DebugTrace(TRACE_STATUS,("SSDeviceControl: IOCTL_SCSISCAN_GET_INFO\n"));

            //
            // Get and return SCSI information block for the scanner device
            //

            if (sizeof(SCSISCAN_INFO) != pIrpStack->Parameters.DeviceIoControl.OutputBufferLength) {

                //
                // Incorrect output buffer size
                //

                DebugTrace(TRACE_WARNING,("SSDeviceControl: WARNING!! Output buffer size is wrong!\n"));

                Status = STATUS_INVALID_PARAMETER;
                goto SSDeviceControl_Error_With_Status;
            }

            if (sizeof(SCSISCAN_INFO) > MmGetMdlByteCount(pIrp->MdlAddress)) {

                //
                // buffer size is short
                //

                DebugTrace(TRACE_WARNING,("SSDeviceControl: WARNING!! Output buffer size is wrong!\n"));

                Status = STATUS_INVALID_PARAMETER;
                goto SSDeviceControl_Error_With_Status;
            }

            pIrp->MdlAddress->MdlFlags |= MDL_MAPPING_CAN_FAIL;
            pUserBuffer =  MmGetSystemAddressForMdl(pIrp->MdlAddress);
            if(NULL == pUserBuffer){
                DebugTrace(TRACE_ERROR,("SSDeviceControl: ERROR!! MmGetSystemAddressForMdl failed!\n"));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto SSDeviceControl_Complete;
            }

            Status = ClassGetInfo(pde -> pStackDeviceObject, pUserBuffer);
                goto SSDeviceControl_Complete;

        default:

            //
            // Unsupported IOCTL code - pass down.
            //

            DebugTrace(TRACE_STATUS,("SSDeviceControl: Passing down unsupported IOCTL(0x%x)!\n", IoControlCode));

            IoSkipCurrentIrpStackLocation(pIrp);
            Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);
            return Status;
    }

    //
    // Pass request down and mark as pending
    //

    IoMarkIrpPending(pIrp);
    IoSetCompletionRoutine(pIrp, SSIoctlIoComplete, pTransferContext, TRUE, TRUE, FALSE);
    SSSendScannerRequest(pDeviceObject, pIrp, pTransferContext, FALSE);

    DebugTrace(TRACE_PROC_LEAVE,("SSDeviceControl: Leaving... Status=STATUS_PENDING\n"));
    return STATUS_PENDING;

    //
    // Cleanup
    //

SSDeviceControl_Error_With_Status:

    //
    // Clean up if something went wrong when allocating resources
    //

    if (pMdl) {
        if (fLockedSRBStatus) {
            MmUnlockPages(pMdl);
        }

        IoFreeMdl(pMdl);

        if (pTransferContext) {
            pTransferContext -> pSrbStatusMdl = NULL;
        }
    }

    if (pTransferContext) {
        if (pTransferContext -> pSenseMdl) {
            if ( fLockedSenseBuffer ) {
                MmUnlockPages(pTransferContext -> pSenseMdl);
            }

            IoFreeMdl(pTransferContext -> pSenseMdl);

            pTransferContext -> pSenseMdl = NULL;
            pTransferContext -> pSenseBuffer = NULL;
        }
    }


SSDeviceControl_Complete:

    //
    // Everything seems to be OK - complet I/O request
    //

    pIrp -> IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    SSDecrementIoCount(pDeviceObject);

    DebugTrace(TRACE_PROC_LEAVE,("SSDeviceControl: Leaving... Status=%x\n",Status));
    return Status;

}   // end SSDeviceControl()



NTSTATUS
SSReadWrite(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This is the entry called by the I/O system for scanner IO.

Arguments:

    DeviceObject - the system object for the device.
    Irp - IRP involved.

Return Value:

    NT Status

--*/
{
    NTSTATUS                      Status;
    PIO_STACK_LOCATION            pIrpStack;
    PSCSISCAN_DEVICE_EXTENSION    pde;
    PTRANSFER_CONTEXT             pTransferContext;
    PMDL                          pMdl;
    PSCSISCAN_CMD                 pCmd;
    PCDB                          pCdb;
    PVOID                         Owner;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("SSReadWrite: Enter...\n"));
    
    Status  = STATUS_SUCCESS;
    pCmd    = NULL;

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("SSReadWrite: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("SSReadWrite: Leaving.. Status = 0x%x.\n", Status));
        return Status;
    }

    pde         = (PSCSISCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pIrpStack   = IoGetCurrentIrpStackLocation( pIrp );

    //
    // Incremet pending IO count.
    //

    SSIncrementIoCount( pDeviceObject );

    //
    // Validate state of the device
    //

    if (pde -> AcceptingRequests == FALSE) {
        DebugTrace(TRACE_WARNING,("SSReadWrite: WARNING!! Device is already stopped/removed!\n"));

        Status = STATUS_DELETE_PENDING;
        pIrp -> IoStatus.Information = 0;
        goto SSReadWrite_Complete;
    }

#if DBG
    if (pIrpStack -> MajorFunction == IRP_MJ_READ) {
        DebugTrace(TRACE_STATUS,("SSReadWrite: Read request received\n"));
    } else {
        DebugTrace(TRACE_STATUS,("SSReadWrite: Write request received\n"));
    }
#endif

    //
    // Check if device is locked.
    //

    Owner = InterlockedCompareExchangePointer(&pde -> DeviceLock,
                                              pIrpStack -> FileObject -> FsContext,
                                              pIrpStack -> FileObject -> FsContext);
    if (Owner != 0) {
        if (Owner != pIrpStack -> FileObject -> FsContext) {
            DebugTrace(TRACE_WARNING,("SSReadWrite: WARNING!! Device is locked\n"));

            Status = STATUS_DEVICE_BUSY;
            pIrp -> IoStatus.Information = 0;
            goto SSReadWrite_Complete;
        }
    }


    pMdl = pIrp -> MdlAddress;

    //
    // Allocate a SCSISCAN_CMD structure and initialize it.
    //

    pCmd = MyAllocatePool(NonPagedPool, sizeof(SCSISCAN_CMD));
    if (NULL == pCmd) {
        DebugTrace(TRACE_CRITICAL, ("SSReadWrite: ERROR!! cannot allocated SCSISCAN_CMD structure\n"));
        DEBUG_BREAKPOINT();
        pIrp->IoStatus.Information = 0;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto SSReadWrite_Complete;
    }

    memset(pCmd,0, sizeof(SCSISCAN_CMD));

    //
    // Fill out SCSISCAN_CMD structure.
    //

#if DBG
    pCmd -> Reserved1      = 'dmCS';
#endif
    pCmd -> Size           = sizeof(SCSISCAN_CMD);
    pCmd -> SrbFlags       = SRB_FLAGS_DATA_IN;
    pCmd -> CdbLength      = 6;
    pCmd -> SenseLength    = SENSE_BUFFER_SIZE;
    pCmd -> TransferLength = pIrpStack->Parameters.Read.Length;
    pCmd -> pSenseBuffer   = NULL;

    //
    // Point pSrbStatus to a reserved field in the SCSISCAN_CMD structure.
    // The ReadFile / WriteFile code path never looks at it, but BuildTransferContext
    // will complain if this pointer is NULL.
    //

    pCmd -> pSrbStatus     = &(pCmd -> Reserved2);

    //
    // Set READ command anyways.
    //

    pCdb = (PCDB)pCmd -> Cdb;
    pCdb -> CDB6READWRITE.OperationCode = SCSIOP_READ6;

    //
    // Set WRITE command if WriteFile called this function.
    //

    if (pIrpStack -> MajorFunction == IRP_MJ_WRITE) {
        pCmd -> SrbFlags = SRB_FLAGS_DATA_OUT;
        pCdb -> CDB6READWRITE.OperationCode = SCSIOP_WRITE6;
    }

    //
    // Allocate a sense buffer.
    //

    pCmd -> pSenseBuffer = MyAllocatePool(NonPagedPool, SENSE_BUFFER_SIZE);
    if (NULL == pCmd -> pSenseBuffer) {
        DebugTrace(TRACE_CRITICAL, ("SSReadWrite: ERROR!! Cannot allocate sense buffer\n"));
        DEBUG_BREAKPOINT();
        pIrp->IoStatus.Information = 0;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto SSReadWrite_Complete;
    }

#if DBG
    *(PULONG)(pCmd ->pSenseBuffer) = 'sneS';
#endif

    //
    // Build a transfer context.
    //

    pTransferContext = SSBuildTransferContext(pde, pIrp, pCmd, sizeof(SCSISCAN_CMD), pMdl, TRUE);
    if (NULL == pTransferContext) {
        DebugTrace(TRACE_ERROR,("SSReadWrite: ERROR!! Can't create transfer context!\n"));
        DEBUG_BREAKPOINT();

        MyFreePool(pCmd -> pSenseBuffer);
        MyFreePool(pCmd);
        pCmd = NULL;

        pIrp -> IoStatus.Information = 0;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto SSReadWrite_Complete;
    }

    //
    // Fill in transfer length in the CDB.
    //

    pCdb -> PRINT.TransferLength[2] = ((PFOUR_BYTE)&(pTransferContext -> TransferLength)) -> Byte0;
    pCdb -> PRINT.TransferLength[1] = ((PFOUR_BYTE)&(pTransferContext -> TransferLength)) -> Byte1;
    pCdb -> PRINT.TransferLength[0] = ((PFOUR_BYTE)&(pTransferContext -> TransferLength)) -> Byte2;

    //
    // Save retry count in transfer context.
    //

    pTransferContext -> RetryCount = MAXIMUM_RETRIES;

    //
    // Mark IRP with status pending.
    //

    IoMarkIrpPending(pIrp);

    //
    // Set the completion routine and issue scanner request.
    //

    IoSetCompletionRoutine(pIrp, SSReadWriteIoComplete, pTransferContext, TRUE, TRUE, FALSE);
    SSSendScannerRequest(pDeviceObject, pIrp, pTransferContext, FALSE);

    DebugTrace(TRACE_PROC_LEAVE,("SSReadWrite: Leaving... Status=STATUS_PENDING\n"));
    return STATUS_PENDING;


SSReadWrite_Complete:

    //
    // Free allocated command and sense buffers
    //

    if (pCmd ) {
        if (pCmd -> pSenseBuffer) {
            MyFreePool(pCmd -> pSenseBuffer);
        }
        MyFreePool(pCmd);
        pCmd = NULL;
    }

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    SSDecrementIoCount( pDeviceObject );

    DebugTrace(TRACE_PROC_LEAVE,("SSReadWrite: Leaving... Status=%x\n",Status));
    return Status;


} // end SSReadWrite()


PTRANSFER_CONTEXT
SSBuildTransferContext(
    PSCSISCAN_DEVICE_EXTENSION  pde,
    PIRP                        pIrp,
    PSCSISCAN_CMD               pCmd,
    ULONG                       CmdLength,
    PMDL                        pTransferMdl,
    BOOLEAN                     AllowMultipleTransfer
    )
/*++

Routine Description:

Arguments:

Return Value:

    NULL if error

--*/
{
    PMDL                        pSenseMdl;
    PTRANSFER_CONTEXT           pTransferContext;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("SSBuildTransferContext: Enter...\n"));

    //
    // Initialize pointer
    //

    pTransferContext = NULL;
    pSenseMdl        = NULL;

    //
    // Validate the SCSISCAN_CMD structure.
    //

    if ( (0 == pCmd -> CdbLength)               ||
         (pCmd -> CdbLength > sizeof(pCmd -> Cdb)) ) 
    {
        DebugTrace(TRACE_WARNING,("SSBuildTransferContext: WARNING!! Badly formed SCSISCAN_CMD struture!\n"));
        goto BuildTransferContext_Error;
    }

#ifdef _WIN64
    if(IoIs32bitProcess(pIrp)){
        if(pCmd -> Size != sizeof(SCSISCAN_CMD_32)) {
            DebugTrace(TRACE_WARNING,("SSBuildTransferContext: WARNING!! Badly formed SCSISCAN_CMD_32 struture!\n"));
            goto BuildTransferContext_Error;
        }
     } else { // if(IoIs32bitProcess(pIrp))
#endif // _WIN64
    if(pCmd -> Size != sizeof(SCSISCAN_CMD)){
        DebugTrace(TRACE_WARNING,("SSBuildTransferContext: WARNING!! Badly formed SCSISCAN_CMD struture!\n"));
        goto BuildTransferContext_Error;
    }

#ifdef _WIN64
    } // if(IoIs32bitProcess(pIrp))
#endif // _WIN64


    //
    // Verify that pSrbStatus is non-zero.
    //

    if (NULL == pCmd -> pSrbStatus) {
        DebugTrace(TRACE_WARNING,("SSBuildTransferContext: WARNING!! NULL pointer for pSrbStatus!\n"));
        goto BuildTransferContext_Error;
    }

#if DBG
    pCmd -> Reserved1      = 'dmCS';
#endif

    //
    // Verify that if TransferLength is non-zero, a transfer direction has also been specified.
    //

    if (0 != pCmd -> TransferLength) {
        if (0 == (pCmd -> SrbFlags & (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT))) {
            DebugTrace(TRACE_WARNING,("SSBuildTransferContext: WARNING!! Transfer length specified w/ no direction!\n"));
            goto BuildTransferContext_Error;
        }
    }

    //
    // Verify that if the direction bits have been set, a transfer length has also be specified.
    //

    if (0 != (pCmd -> SrbFlags & (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT))) {
        if (0 == pCmd -> TransferLength) {
            DebugTrace(TRACE_WARNING,("SSBuildTransferContext: WARNING!! Direction bits is set w/ 0 transfer size!\n"));
            goto BuildTransferContext_Error;
        }
    }

    //
    // Verify that if TransferLength is non-zero, then an associated MDL has also been specified.
    // Also, verify that the transfer length does not exceed the transfer buffer size.
    //


    if (0 != pCmd -> TransferLength) {
        if (NULL == pTransferMdl) {
            DebugTrace(TRACE_WARNING,("SSBuildTransferContext: WARNING!! Non-zero transfer length w/ NULL buffer!\n"));
            goto BuildTransferContext_Error;
        }
        if (pCmd -> TransferLength > MmGetMdlByteCount(pTransferMdl)) {
            DebugTrace(TRACE_WARNING,("SSBuildTransferContext: WARNING!! Transfer length exceeds buffer size!\n"));
            goto BuildTransferContext_Error;
        }
    }

    //
    // Verify that if SenseLength is non-zero, then pSenseBuffer is non-zero as well.
    //

    if (pCmd -> SenseLength) {
        if (NULL == pCmd -> pSenseBuffer) {
            DebugTrace(TRACE_WARNING,("SSBuildTransferContext: WARNING!! Non-zero sense length w/ NULL buffer!\n"));
            goto BuildTransferContext_Error;
        }

        if (pCmd -> SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE) {
            DebugTrace(TRACE_STATUS,("SSBuildTransferContext: Autosense disabled with NON-null sense buffer.\n"));
        }
    }

    //
    // Allocate transfer context
    //

    pTransferContext = MyAllocatePool(NonPagedPool, sizeof(TRANSFER_CONTEXT));
    if (NULL == pTransferContext) {
        DebugTrace(TRACE_CRITICAL,("SSBuildTransferContext: ERROR!! Failed to allocate transfer context\n"));
        DEBUG_BREAKPOINT();
        return NULL;
    }


    memset(pTransferContext, 0, sizeof(TRANSFER_CONTEXT));
#if DBG
    pTransferContext -> Signature = 'refX';
#endif
    pTransferContext -> pCmd = pCmd;

    if (pCmd -> TransferLength) {

#ifdef WINNT
        pTransferContext -> pTransferBuffer = MmGetMdlVirtualAddress(pTransferMdl);
#else
        pTransferContext -> pTransferBuffer = MmGetSystemAddressForMdl(pTransferMdl);
#endif
        if(NULL == pTransferContext -> pTransferBuffer){
            DebugTrace(TRACE_ERROR,("SSBuildTransferContext: ERROR!! Failed to create address for MDL.\n"));
            DEBUG_BREAKPOINT();
            goto BuildTransferContext_Error;
        }

        pTransferContext -> RemainingTransferLength = pCmd -> TransferLength;
        pTransferContext -> TransferLength = pCmd -> TransferLength;

        //
        // Adjust the transfer size to work within the limits of the hardware.  Fail if the transfer is too
        // big and the caller doesn't want the transfer to be split up.
        //

        SSAdjustTransferSize( pde, pTransferContext );

        if (pTransferContext -> RemainingTransferLength !=
            (LONG)pTransferContext -> TransferLength) {
            if (!AllowMultipleTransfer) {
                DebugTrace(TRACE_WARNING,("SSBuildTransferContext: WARNING!! Transfer exceeds hardware limits!\n"));
                goto BuildTransferContext_Error;
            }
        }
    }

    pTransferContext -> pSenseBuffer = pCmd -> pSenseBuffer;

    DebugTrace(TRACE_PROC_LEAVE,("SSBuildTransferContext: Leaving... Return=%x\n",pTransferContext));
    return pTransferContext;


BuildTransferContext_Error:
    if (pTransferContext) {
        MyFreePool( pTransferContext );
    }
    DebugTrace(TRACE_PROC_LEAVE,("SSBuildTransferContext: Leaving... Return=NULL\n"));
    return NULL;
}   // end SSBuildTransferContext()



VOID
SSAdjustTransferSize(
    PSCSISCAN_DEVICE_EXTENSION  pde,
    PTRANSFER_CONTEXT pTransferContext
    )
/*++

Routine Description:
    This is the entry called by the I/O system for scanner IO.

Arguments:

Return Value:

    NT Status

--*/
{
    ULONG MaxTransferLength;
    ULONG nTransferPages;

    PAGED_CODE();

    MaxTransferLength = pde -> pAdapterDescriptor -> MaximumTransferLength;

    //
    // Make sure the transfer size does not exceed the limitations of the underlying hardware.
    // If so, we will break the transfer up into chunks.
    //

    if (pTransferContext -> TransferLength > MaxTransferLength) {
        DebugTrace(TRACE_STATUS,("Request size (0x%x) greater than maximum (0x%x)\n",
                                    pTransferContext -> TransferLength,
                                    MaxTransferLength));
        pTransferContext -> TransferLength = MaxTransferLength;
    }

    //
    // Calculate number of pages in this transfer.
    //

    nTransferPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
        pTransferContext -> pTransferBuffer,
        pTransferContext -> TransferLength);

    if (nTransferPages > pde -> pAdapterDescriptor -> MaximumPhysicalPages) {
        DebugTrace(TRACE_STATUS,("Request number of pages (0x%x) greater than maximum (0x%x).\n",
                                    nTransferPages,
                                    pde -> pAdapterDescriptor -> MaximumPhysicalPages));

        //
        // Calculate maximum bytes to transfer that gaurantees that
        // we will not exceed the maximum number of page breaks,
        // assuming that the transfer may not be page alligned.
        //

        pTransferContext -> TransferLength = (pde -> pAdapterDescriptor -> MaximumPhysicalPages - 1) * PAGE_SIZE;
    }
} // end SSAdjustTransferSize()


VOID
SSSetTransferLengthToCdb(
    PCDB  pCdb,
    ULONG TransferLength
    )
/*++

Routine Description:
    Set transfer length to CDB due to its SCSI command.

Arguments:
    pCdb            -   pointer to CDB
    TransferLength  -   size of data to transfer
Return Value:

    none

--*/
{

    switch (pCdb->SEEK.OperationCode) {

        case 0x24:                  // Scanner SetWindow command
        case SCSIOP_READ_CAPACITY:  // Scanner GetWindow command
        case SCSIOP_READ:           // Scanner Read command
        case SCSIOP_WRITE:          // Scanner Send Command
        default:                    // All other commands
        {
            pCdb -> SEEK.Reserved2[2] = ((PFOUR_BYTE)&TransferLength) -> Byte0;
            pCdb -> SEEK.Reserved2[1] = ((PFOUR_BYTE)&TransferLength) -> Byte1;
            pCdb -> SEEK.Reserved2[0] = ((PFOUR_BYTE)&TransferLength) -> Byte2;

            break;
        }

        case 0x34       :           // Scanner GetDataBufferStatus Command
        {
            pCdb -> SEEK.Reserved2[2] = ((PFOUR_BYTE)&TransferLength) -> Byte0;
            pCdb -> SEEK.Reserved2[1] = ((PFOUR_BYTE)&TransferLength) -> Byte1;

            break;
        }

    }

} // end SSSetTransferLengthToCdb()

VOID
SSSendScannerRequest(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp,
    PTRANSFER_CONTEXT pTransferContext,
    BOOLEAN Retry
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{
    PSCSISCAN_DEVICE_EXTENSION      pde;
    PIO_STACK_LOCATION              pIrpStack;
    PIO_STACK_LOCATION              pNextIrpStack;
    PSRB                            pSrb;
    PCDB                            pCdb;
    PSCSISCAN_CMD                   pCmd;

    DebugTrace(TRACE_PROC_ENTER,("SendScannerRequest pirp=0x%p TransferBuffer=0x%p\n", pIrp, pTransferContext->pTransferBuffer));

    pde = (PSCSISCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pNextIrpStack = IoGetNextIrpStackLocation( pIrp );
    ASSERT(pTransferContext);
    pSrb = &(pTransferContext -> Srb);
    ASSERT(pSrb);
    pCmd = pTransferContext -> pCmd;
    ASSERT(pCmd);

    //
    // Write length to SRB.
    //

    pSrb -> Length = SCSI_REQUEST_BLOCK_SIZE;

    //
    // Set up IRP Address.
    //

    pSrb -> OriginalRequest = pIrp;

    pSrb -> Function = SRB_FUNCTION_EXECUTE_SCSI;

    pSrb -> DataBuffer = pTransferContext -> pTransferBuffer;

    //
    // Save byte count of transfer in SRB Extension.
    //

    pSrb -> DataTransferLength = pTransferContext -> TransferLength;

    //
    // Initialize the queue actions field.
    //

    pSrb -> QueueAction = SRB_SIMPLE_TAG_REQUEST;

    //
    // Queue sort key is not used.
    //

    pSrb -> QueueSortKey = 0;

    //
    // Indicate auto request sense by specifying buffer and size.
    //

    pSrb -> SenseInfoBuffer = pTransferContext -> pSenseBuffer;
    pSrb -> SenseInfoBufferLength = pCmd -> SenseLength;

    //
    // Set timeout value in seconds.
    //

    pSrb -> TimeOutValue = pde -> TimeOutValue;

    //
    // Zero status fields
    //


    pSrb -> SrbStatus = pSrb -> ScsiStatus = 0;
    pSrb -> NextSrb = 0;

    //
    // Get pointer to CDB in SRB.
    //

    pCdb = (PCDB)(pSrb -> Cdb);

    //
    // Set length of CDB.
    //

    pSrb -> CdbLength = pCmd -> CdbLength;

    //
    // Copy the user's CDB into our private CDB.
    //

    RtlCopyMemory(pCdb, pCmd -> Cdb, pCmd -> CdbLength);

    //
    // Set the srb flags.
    //

    pSrb -> SrbFlags = pCmd -> SrbFlags;

    //
    // Or in the default flags from the device object.
    //

    pSrb -> SrbFlags |= pde -> SrbFlags;

    if (Retry) {
                // Disable synchronous data transfers and
                // disable tagged queuing. This fixes some errors.

                DebugTrace(TRACE_STATUS,("SscsiScan :: Retrying \n"));

                //
                // Original code also added disable disconnect flag to SRB.
                // That action would lock SCSI bus and in a case when paging drive is
                // located on the same bus and scanner is taking long timeouts ( for example
                // when it is mechanically locked) memory manager would hit timeout and
                // bugcheck.
                //
                // pSrb -> SrbFlags |= SRB_FLAGS_DISABLE_DISCONNECT |
                //

                pSrb -> SrbFlags |= SRB_FLAGS_DISABLE_SYNCH_TRANSFER;
                pSrb -> SrbFlags &= ~SRB_FLAGS_QUEUE_ACTION_ENABLE;

                DebugTrace(TRACE_STATUS,("SSSendScannerRequest: Retry branch .Srb flags=(0x%x) \n", pSrb -> SrbFlags));

                pSrb -> QueueTag = SP_UNTAGGED;
    }

    //
    // Set up major SCSI function.
    //

    pNextIrpStack -> MajorFunction = IRP_MJ_SCSI;

    //
    // Save SRB address in next stack for port driver.
    //

    pNextIrpStack -> Parameters.Scsi.Srb = pSrb;

    //
    // Print out SRB fields
    //

    // DebugTrace(MAX_TRACE,("SSSendScannerRequest: SRB ready. Flags=(%#X)Func=(%#x) DataLen=%d \nDataBuffer(16)=[%16s] \n",
     DebugTrace(TRACE_STATUS,("SSSendScannerRequest: SRB ready. Flags=(%#X)Func=(%#x) DataLen=%d \nDataBuffer(16)=[%lx] \n",
                         pSrb -> SrbFlags ,pSrb -> Function,
                         pSrb -> DataTransferLength,
                         pSrb -> DataBuffer));

    IoCallDriver(pde -> pStackDeviceObject, pIrp);

} // end SSSendScannerRequest()


NTSTATUS
SSReadWriteIoComplete(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PTRANSFER_CONTEXT pTransferContext
    )
/*++

Routine Description:
    This routine executes when the port driver has completed a request.
    It looks at the SRB status in the completing SRB and if not success
    it checks for valid request sense buffer information. If valid, the
    info is used to update status with more precise message of type of
    error. This routine deallocates the SRB.

Arguments:
    pDeviceObject - Supplies the device object which represents the logical
        unit.
    pIrp - Supplies the Irp which has completed.

Return Value:
    NT status

--*/
{
    PIO_STACK_LOCATION              pIrpStack;
    PIO_STACK_LOCATION              pNextIrpStack;
    NTSTATUS                        Status;
    BOOLEAN                         Retry;
    PSRB                            pSrb;
    UCHAR                           SrbStatus;
    PCDB                            pCdb;
    PSCSISCAN_CMD                   pCmd;

    DebugTrace(TRACE_PROC_ENTER,("ReadWriteIoComplete: Enter... IRP 0x%p.\n", pIrp));

    ASSERT(NULL != pTransferContext);

    //
    // Initialize local.
    //
    
    Retry           = FALSE;
    pCdb            = NULL;
    pCmd            = NULL;

    pIrpStack       = IoGetCurrentIrpStackLocation(pIrp);
    pNextIrpStack   = IoGetNextIrpStackLocation(pIrp);

    Status = pIrp->IoStatus.Status;
    pSrb = &(pTransferContext -> Srb);
    SrbStatus = SRB_STATUS(pSrb -> SrbStatus);

    if( (SrbStatus != SRB_STATUS_SUCCESS)
     || (STATUS_SUCCESS != Status) )
    {
        DebugTrace(TRACE_ERROR,("ReadWriteIoComplete: ERROR!! Irp error. 0x%p SRB status:0x%p\n", Status, pSrb -> SrbStatus));

        //
        // Release the queue if it is frozen.
        //

        if (pSrb -> SrbStatus & SRB_STATUS_QUEUE_FROZEN) {
            DebugTrace(TRACE_ERROR,("ReadWriteIoComplete: Release queue. IRP 0x%p.\n", pIrp));
           ClassReleaseQueue(pDeviceObject);
        }

        Retry = ClassInterpretSenseInfo(
                                        pDeviceObject,
                                        pSrb,
                                        pNextIrpStack->MajorFunction,
                                        0,
                                        MAXIMUM_RETRIES - ((ULONG)(UINT_PTR)pIrpStack->Parameters.Others.Argument4),
                                        &Status);

        if (Retry && pTransferContext -> RetryCount--) {
            DebugTrace(TRACE_STATUS,("ReadWriteIoComplete: Retry request 0x%p TransferBuffer=0x%p \n",
                                        pIrp,pTransferContext->pTransferBuffer));
            IoSetCompletionRoutine(pIrp, SSReadWriteIoComplete, pTransferContext, TRUE, TRUE, FALSE);
            SSSendScannerRequest(pDeviceObject, pIrp, pTransferContext, TRUE);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        //
        // If status is overrun, ignore it to support some bad devices.
        //
        

        if (SRB_STATUS_DATA_OVERRUN == SrbStatus) {
            DebugTrace(TRACE_WARNING,("ReadWriteIoComplete: WARNING!! Data overrun IRP=0x%p. Ignoring...\n", pIrp));
            pTransferContext -> NBytesTransferred += pSrb -> DataTransferLength;
            Status = STATUS_SUCCESS;

        } else {
            DebugTrace(TRACE_STATUS,("ReadWriteIoComplete: Request failed. IRP 0x%p.\n", pIrp));
//            DEBUG_BREAKPOINT();
            pTransferContext -> NBytesTransferred = 0;
            Status = STATUS_IO_DEVICE_ERROR;
        }

    } else {

        pTransferContext -> NBytesTransferred += pSrb -> DataTransferLength;
        pTransferContext -> RemainingTransferLength -= pSrb -> DataTransferLength;
        pTransferContext -> pTransferBuffer += pSrb -> DataTransferLength;
        if (pTransferContext -> RemainingTransferLength > 0) {

            if ((LONG)(pTransferContext -> TransferLength) > pTransferContext -> RemainingTransferLength) {
                pTransferContext -> TransferLength = pTransferContext -> RemainingTransferLength;
                pCmd = pTransferContext -> pCmd;
                pCdb = (PCDB)pCmd -> Cdb;
                pCdb -> PRINT.TransferLength[2] = ((PFOUR_BYTE)&(pTransferContext -> TransferLength)) -> Byte0;
                pCdb -> PRINT.TransferLength[1] = ((PFOUR_BYTE)&(pTransferContext -> TransferLength)) -> Byte1;
                pCdb -> PRINT.TransferLength[0] = ((PFOUR_BYTE)&(pTransferContext -> TransferLength)) -> Byte2;
            }

            IoSetCompletionRoutine(pIrp, SSReadWriteIoComplete, pTransferContext, TRUE, TRUE, FALSE);
            SSSendScannerRequest(pDeviceObject, pIrp, pTransferContext, FALSE);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        Status = STATUS_SUCCESS;
    }

    pIrp -> IoStatus.Information = pTransferContext -> NBytesTransferred;

    MyFreePool(pTransferContext -> pCmd -> pSenseBuffer);
    MyFreePool(pTransferContext -> pCmd);
    MyFreePool(pTransferContext);

    pIrp -> IoStatus.Status = Status;

    SSDecrementIoCount( pDeviceObject );

    return Status;

} // end SSReadWriteIoComplete()



NTSTATUS
SSIoctlIoComplete(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PTRANSFER_CONTEXT pTransferContext
    )
/*++

Routine Description:
    This routine executes when an DevIoctl request has completed.

Arguments:
    pDeviceObject - Supplies the device object which represents the logical
        unit.
    pIrp - Supplies the Irp which has completed.
    pTransferContext - pointer to info about the request.

Return Value:
    NT status

--*/
{
    PIO_STACK_LOCATION              pIrpStack;
    NTSTATUS                        Status;
    PSRB                            pSrb;
    PSCSISCAN_CMD                   pCmd;
    PCDB                            pCdb;


    DebugTrace(TRACE_PROC_ENTER,("IoctlIoComplete: Enter... IRP=0x%p\n", pIrp));

    ASSERT(NULL != pTransferContext);

    pIrpStack   = IoGetCurrentIrpStackLocation(pIrp);
    pSrb        = &(pTransferContext -> Srb);
    pCmd        = pTransferContext -> pCmd;

    ASSERT(NULL != pCmd);

    pCdb        = NULL;
    Status = pIrp->IoStatus.Status;

    //
    // Copy the SRB Status back into the user's SCSISCAN_CMD buffer.
    //

    *(pCmd -> pSrbStatus) = pSrb -> SrbStatus;

    //
    // If an error occurred on this transfer, release the frozen queue if necessary.
    //

    if( (SRB_STATUS(pSrb -> SrbStatus) != SRB_STATUS_SUCCESS) 
     || (STATUS_SUCCESS != Status) )
    {
        DebugTrace(TRACE_ERROR,("IoctlIoComplete: ERROR!! Irp error. Status=0x%x SRB status:0x%x\n", Status, pSrb -> SrbStatus));

        if (pSrb -> SrbStatus & SRB_STATUS_QUEUE_FROZEN) {
            DebugTrace(TRACE_ERROR,("IoctlIoComplete: Release queue. IRP  0x%p.\n", pIrp));
           ClassReleaseQueue(pDeviceObject);
        }
    } else {
        pTransferContext -> NBytesTransferred += pSrb -> DataTransferLength;
        pTransferContext -> RemainingTransferLength -= pSrb -> DataTransferLength;
        pTransferContext -> pTransferBuffer += pSrb -> DataTransferLength;
        if (pTransferContext -> RemainingTransferLength > 0) {

            if ((LONG)(pTransferContext -> TransferLength) > pTransferContext -> RemainingTransferLength) {
                pTransferContext -> TransferLength = pTransferContext -> RemainingTransferLength;
                pCmd = pTransferContext -> pCmd;
                pCdb = (PCDB)pCmd -> Cdb;

                //
                // SCSISCAN only supports 10bytes CDB fragmentation.
                //

                ASSERT(pCmd->CdbLength == 10);

                //
                // Fill in transfer length in the CDB.
                //

                SSSetTransferLengthToCdb((PCDB)pCmd -> Cdb, pTransferContext -> TransferLength);

            }

            IoSetCompletionRoutine(pIrp, SSIoctlIoComplete, pTransferContext, TRUE, TRUE, FALSE);
            SSSendScannerRequest(pDeviceObject, pIrp, pTransferContext, FALSE);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // Clean up and return.
    //

    if (pTransferContext -> pSrbStatusMdl) {
        MmUnlockPages(pTransferContext -> pSrbStatusMdl);
        IoFreeMdl(pTransferContext -> pSrbStatusMdl);

        //pTransferContext -> pSrbStatusMdl = NULL;
    }

    if (pTransferContext -> pSenseMdl) {
        MmUnlockPages(pTransferContext -> pSenseMdl);
        IoFreeMdl(pTransferContext -> pSenseMdl);

        //pTransferContext -> pSenseMdl = NULL;
    }

    pIrp -> IoStatus.Information = pTransferContext -> NBytesTransferred;
    pIrp -> IoStatus.Status = Status;

    MyFreePool(pTransferContext);

    SSDecrementIoCount( pDeviceObject );

    return Status;

} // end SSIoctlIoComplete()


NTSTATUS
SSCreateSymbolicLink(
    PSCSISCAN_DEVICE_EXTENSION  pde
    )
{

    NTSTATUS                      Status;
    UNICODE_STRING                uName;
    UNICODE_STRING                uName2;
    ANSI_STRING                   ansiName;
    CHAR                          aName[32];
    HANDLE                        hSwKey;

    PAGED_CODE();

    //
    // Create the symbolic link for this device.
    //

    _snprintf(aName, sizeof(aName), "\\Device\\Scanner%d",pde -> DeviceInstance);
    aName[ARRAYSIZE(aName)-1] = '\0';
    RtlInitAnsiString(&ansiName, aName);
    RtlAnsiStringToUnicodeString(&uName, &ansiName, TRUE);

    _snprintf(aName, sizeof(aName), "\\DosDevices\\Scanner%d",pde -> DeviceInstance);
    aName[ARRAYSIZE(aName)-1] = '\0';
    RtlInitAnsiString(&ansiName, aName);
    RtlAnsiStringToUnicodeString(&(pde -> SymbolicLinkName), &ansiName, TRUE);

    Status = IoCreateSymbolicLink( &(pde -> SymbolicLinkName), &uName );

    RtlFreeUnicodeString( &uName );

    if (STATUS_SUCCESS != Status ) {
        DebugTrace(MIN_TRACE,("Cannot create symbolic link.\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_NOT_SUPPORTED;
        return Status;
    }

    //
    // Now, stuff the symbolic link into the CreateFileName key so that STI can find the device.
    //

    IoOpenDeviceRegistryKey( pde -> pPhysicalDeviceObject,
                             PLUGPLAY_REGKEY_DRIVER, KEY_WRITE, &hSwKey);

    RtlInitUnicodeString(&uName,L"CreateFileName");
    _snprintf(aName, sizeof(aName), "\\\\.\\Scanner%d",pde -> DeviceInstance);
    aName[ARRAYSIZE(aName)-1] = '\0';
    RtlInitAnsiString(&ansiName, aName);
    RtlAnsiStringToUnicodeString(&uName2, &ansiName, TRUE);
    ZwSetValueKey(hSwKey,&uName,0,REG_SZ,uName2.Buffer,uName2.Length);
    RtlFreeUnicodeString( &uName2 );

    return STATUS_SUCCESS;
}


NTSTATUS
SSDestroySymbolicLink(
    PSCSISCAN_DEVICE_EXTENSION  pde
    )
{

    UNICODE_STRING                uName;
    UNICODE_STRING                uName2;
    ANSI_STRING                   ansiName;
    CHAR                          aName[32];
    HANDLE                        hSwKey;

    PAGED_CODE();

    DebugTrace(MIN_TRACE,("DestroySymbolicLink\n"));

    //
    // Delete the symbolic link to this device.
    //

    IoDeleteSymbolicLink( &(pde -> SymbolicLinkName) );

    //
    // Remove the CreateFile name from the s/w key.
    //

    IoOpenDeviceRegistryKey( pde -> pPhysicalDeviceObject,
                             PLUGPLAY_REGKEY_DRIVER, KEY_WRITE, &hSwKey);

    RtlInitUnicodeString(&uName,L"CreateFileName");
    memset(aName, 0, sizeof(aName));
    RtlInitAnsiString(&ansiName, aName);
    RtlAnsiStringToUnicodeString(&uName2, &ansiName, TRUE);
    ZwSetValueKey(hSwKey,&uName,0,REG_SZ,uName2.Buffer,uName2.Length);
    RtlFreeUnicodeString( &uName2 );
    RtlFreeUnicodeString( &(pde -> SymbolicLinkName) );

    ZwClose(hSwKey);

    return STATUS_SUCCESS;

}


VOID
SSIncrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    PSCSISCAN_DEVICE_EXTENSION  pde;

    pde = (PSCSISCAN_DEVICE_EXTENSION)(pDeviceObject -> DeviceExtension);
    InterlockedIncrement(&pde -> PendingIoCount);
}


LONG
SSDecrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    PSCSISCAN_DEVICE_EXTENSION  pde;
    LONG                        ioCount;

    pde = (PSCSISCAN_DEVICE_EXTENSION)(pDeviceObject -> DeviceExtension);

    ioCount = InterlockedDecrement(&pde -> PendingIoCount);

    DebugTrace(TRACE_STATUS,("Pending io count = %x\n",ioCount));

    if (0 == ioCount) {
        KeSetEvent(&pde -> PendingIoEvent,
                   1,
                   FALSE);
    }

    return ioCount;
}


NTSTATUS
SSDeferIrpCompletion(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    pDeviceObject - Pointer to the device object for the class device.

    pIrp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT pEvent = Context;

    KeSetEvent(pEvent,
               1,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;

}


NTSTATUS
SSPower(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    )
/*++

Routine Description:

    Process the Power IRPs sent to the PDO for this device.

Arguments:

    pDeviceObject - pointer to the functional device object (FDO) for this device.
    pIrp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
{
    NTSTATUS                        Status;
    PSCSISCAN_DEVICE_EXTENSION      pde;
    PIO_STACK_LOCATION              pIrpStack;
    BOOLEAN                         hookIt = FALSE;

    PAGED_CODE();
    
    Status = STATUS_SUCCESS;

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("SSPower: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("SSPower: Leaving.. Status = 0x%x.\n", Status));
        return Status;
    }

    SSIncrementIoCount( pDeviceObject );

    pde       = (PSCSISCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    switch (pIrpStack -> MinorFunction) {
        case IRP_MN_SET_POWER:
            DebugTrace(MIN_TRACE,("IRP_MN_SET_POWER\n"));
            PoStartNextPowerIrp(pIrp);
            IoSkipCurrentIrpStackLocation(pIrp);
            Status = PoCallDriver(pde -> pStackDeviceObject, pIrp);
            SSDecrementIoCount(pDeviceObject);
            break; /* IRP_MN_QUERY_POWER */

        case IRP_MN_QUERY_POWER:
            DebugTrace(MIN_TRACE,("IRP_MN_QUERY_POWER\n"));
            PoStartNextPowerIrp(pIrp);
            IoSkipCurrentIrpStackLocation(pIrp);
            Status = PoCallDriver(pde -> pStackDeviceObject, pIrp);
            SSDecrementIoCount(pDeviceObject);
            break; /* IRP_MN_QUERY_POWER */

        default:
            DebugTrace(MIN_TRACE,("Unknown power message (%x)\n",pIrpStack->MinorFunction));
            PoStartNextPowerIrp(pIrp);
            IoSkipCurrentIrpStackLocation(pIrp);
            Status = PoCallDriver(pde -> pStackDeviceObject, pIrp);
            SSDecrementIoCount(pDeviceObject);

    } /* irpStack->MinorFunction */

    return Status;
}


VOID
SSUnload(
    IN PDRIVER_OBJECT pDriverObject
    )
/*++

Routine Description:

    This routine is called when the driver is unloaded.

Arguments:
    pDriverObject - Pointer to the driver object.evice object for the class device.

Return Value:
    none.

--*/
{
    PAGED_CODE();

    DebugTrace(MIN_TRACE,("Driver unloaded.\n"));
}


NTSTATUS
ScsiScanHandleInterface(
    PDEVICE_OBJECT      DeviceObject,
    PUNICODE_STRING     InterfaceName,
    BOOLEAN             Create
    )
/*++

Routine Description:

Arguments:

    DeviceObject    - Supplies the device object.

Return Value:

    None.

--*/
{

    NTSTATUS           Status;


    Status = STATUS_SUCCESS;

#ifndef _CHICAGO_

    if (Create) {

        Status=IoRegisterDeviceInterface(
            DeviceObject,
            &GUID_DEVINTERFACE_IMAGE,
            NULL,
            InterfaceName
            );

        DebugTrace(TRACE_STATUS,("Called IoRegisterDeviceInterface . Returned=0x%X\n",Status));

        if (NT_SUCCESS(Status)) {

            IoSetDeviceInterfaceState(
                InterfaceName,
                TRUE
                );

            DebugTrace(TRACE_STATUS,("Called IoSetDeviceInterfaceState(TRUE) . \n"));


        }

    } else {

        if (InterfaceName->Buffer != NULL) {

            IoSetDeviceInterfaceState(
                InterfaceName,
                FALSE
                );

            DebugTrace(TRACE_STATUS,("Called IoSetDeviceInterfaceState(FALSE) . \n"));

            RtlFreeUnicodeString(
                InterfaceName
                );

            InterfaceName->Buffer = NULL;

        }

    }

#endif // !_CHICAGO_

    return Status;

}

NTSTATUS
SSCallNextDriverSynch(
    IN PSCSISCAN_DEVICE_EXTENSION   pde,
    IN PIRP                         pIrp
)
/*++

Routine Description:

    Calls lower driver and waits for result

Arguments:

    DeviceExtension - pointer to device extension
    Irp - pointer to IRP

Return Value:

    none.

--*/
{
    KEVENT          Event;
    PIO_STACK_LOCATION IrpStack;
    NTSTATUS        Status;

    DebugTrace(TRACE_PROC_ENTER,("SSCallNextDriverSynch: Enter..\n"));

    IrpStack = IoGetCurrentIrpStackLocation(pIrp);

    //
    // Copy IRP stack to the next.
    //

    IoCopyCurrentIrpStackLocationToNext(pIrp);

    //
    // Initialize synchronizing event.
    //

    KeInitializeEvent(&Event,
                      SynchronizationEvent,
                      FALSE);

    //
    // Set completion routine
    //

    IoSetCompletionRoutine(pIrp,
                           SSDeferIrpCompletion,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // Call down
    //

    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

    if (Status == STATUS_PENDING) {

        //
        // Waiting for the completion.
        //

        DebugTrace(TRACE_STATUS,("SSCallNextDriverSynch: STATUS_PENDING. Wait for event.\n"));
        KeWaitForSingleObject(&Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        Status = pIrp -> IoStatus.Status;
    }

    //
    // Return
    //

    DebugTrace(TRACE_PROC_LEAVE,("SSCallNextDriverSynch: Leaving.. Status = %x\n", Status));
    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\scsiscan\debug.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Prototypes and definitions for debugging.

Author: 

    Keisuke Tsuchida (KeisukeT)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#ifndef __MYDEBUG__
#define __MYDEBUG__

//
// Driver specific difinition
//


#define NAME_DRIVER             "Scsican.sys: "     // Prefix of output message. (Should be driver name)
#define NAME_POOLTAG            'SITS'              // Pool tag for this driver.
#define MAXNUM_POOL             100                 // Maximum number of pool. (# of alloc - # of free)
#define MAX_DUMPSIZE            1024                // Maximum bytes to dump.

//
// Defines
//

#define REG_DEBUGLEVEL          L"DebugTraceLevel"
#define MAX_TEMPBUF             256

// Bit mask for trace level and flags
#define BITMASK_TRACE_LEVEL     0x0000000f
#define BITMASK_TRACE_FLAG      0x00000ff0
#define BITMASK_DEBUG_FLAG      0x0000f000

// Basic trace level 
#define NO_TRACE                0                   // Shows nothing.
#define MIN_TRACE               1                   // Shows only error or warning.
#define MAX_TRACE               2                   // Shows progress and status.
#define ULTRA_TRACE             3                   // Shows progress and status in retail.
#define NEVER_TRACE             4                   // Never show this unless specific bit is set.

// Trace flag to enable specific message spew. (1=on)
#define TRACE_FLAG_PROC          0x10                // Show message when entering process.(1=on)
#define TRACE_FLAG_RET           0x20                // Show message when leaving process.(1=on)
#define TRACE_FLAG_DUMP_READ     0x40                // Show user buffer when read.
#define TRACE_FLAG_DUMP_WRITE    0x80                // Show user buffer when write.

// Conbination of trace level and flag.
#define TRACE_PROC_ENTER        ULTRA_TRACE | TRACE_FLAG_PROC     // Entering procedure.
#define TRACE_PROC_LEAVE        ULTRA_TRACE | TRACE_FLAG_RET      // Leaving procedure.
#define TRACE_CRITICAL          MIN_TRACE                         // Critical error. Spew always.
#define TRACE_ERROR             MIN_TRACE                         // Error.
#define TRACE_WARNING           MIN_TRACE                         // Possible wrong behavior.
//#define TRACE_DUMP_DATA         NEVER_TRACE | TRACE_FLAG_DUMP     // Dump transaction data.
#define TRACE_DEVICE_DATA       MAX_TRACE                         // Show device data.
#define TRACE_STATUS            MAX_TRACE                         // Show status.

// Debug flag to enable/disable  DEBUG_BREAKPOINT()
#define DEBUG_FLAG_DISABLE      0x1000                          // Disable DEBUG_BREAK. (1=disable)
#define DEBUG_PROC_BREAK        0x2000                          // Stop at the beginning of each procedure.


//
// Macro
//


#if DBG

 //
 // Macro for debug output
 //
 // Note: If trace level is higher than DebugTraceLevel or specific bit is set, 
 //       debug message will be shown.
 //

extern ULONG DebugTraceLevel;
 #define DebugTrace(_t_, _x_) {                                                                 \
            if ( ((DebugTraceLevel & BITMASK_TRACE_LEVEL) >= (_t_ & BITMASK_TRACE_LEVEL )) ||   \
                 (DebugTraceLevel & BITMASK_TRACE_FLAG & (_t_)) ) {                             \
                DbgPrint(NAME_DRIVER);                                                          \
                DbgPrint _x_ ;                                                                  \
            }                                                                                   \
            if( (DebugTraceLevel & DEBUG_PROC_BREAK & (_t_)) &&                                 \
                (DebugTraceLevel & TRACE_FLAG_PROC) )  {                                        \
                DEBUG_BREAKPOINT();                                                             \
            }                                                                                   \
          }

 //
 // Macro for BreakPoint
 //

 #define DEBUG_BREAKPOINT() {                                              \
           if (DebugTraceLevel & DEBUG_FLAG_DISABLE) {                     \
               DbgPrint(NAME_DRIVER);                                      \
               DbgPrint("*** Hit DEBUG_BREAKPOINT ***\n");                 \
           } else {                                                        \
               DbgBreakPoint();                                            \
           }                                                               \
         }

#else    // DBG
 #define DEBUG_BREAKPOINT()
 #define DebugTrace(_t_, _x_)
#endif   // DBG


//
// Prototypes
//


#ifdef ORIGINAL_POOLTRACK

PVOID
MyAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG     ulNumberOfBytes
);

VOID
MyFreePool(
    IN PVOID     pvAddress
);

#else       // ORIGINAL_POOLTRACK
 #define MyAllocatePool(a, b)   ExAllocatePoolWithTag(a, b, NAME_POOLTAG)
 #define MyFreePool(a)          ExFreePool(a)
#endif      // ORIGINAL_POOLTRACK

VOID
MyDebugInit(
    IN  PUNICODE_STRING pRegistryPath
);

VOID
MyDumpMemory(
    PUCHAR  pDumpBuffer,
    ULONG   dwSize,
    BOOLEAN bRead
);

#endif //  __MYDEBUG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\scsiscan\debug.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    debug.c

Abstract:

    Common code for debugging.

Author: 

    Keisuke Tsuchida (KeisukeT)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//
// Includes
//

#include "stddef.h"
#include "wdm.h"
#include "debug.h"

//
// Globals
//

ULONG   DebugTraceLevel = MIN_TRACE | DEBUG_FLAG_DISABLE;
// ULONG  DebugTraceLevel = MAX_TRACE | DEBUG_FLAG_DISABLE | TRACE_PROC_ENTER | TRACE_PROC_LEAVE;
LONG    AllocateCount = 0;
ULONG   DebugDumpMax    = MAX_DUMPSIZE;

#ifdef ORIGINAL_POOLTRACK

PVOID
MyAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG     ulNumberOfBytes
)
/*++

Routine Description:

    Wrapper for pool allocation. Use tag to avoid heap corruption.

Arguments:

    PoolType - type of pool memory to allocate
    ulNumberOfBytes - number of bytes to allocate

Return Value:

    Pointer to the allocated memory

--*/
{
    PVOID pvRet;

    DebugTrace(TRACE_PROC_ENTER,("MyAllocatePool: Enter.. Size = %d\n", ulNumberOfBytes));

    pvRet = ExAllocatePoolWithTag(PoolType,
                                  ulNumberOfBytes,
                                  NAME_POOLTAG);

#if DBG
    if(NULL == pvRet){
        DebugTrace(TRACE_ERROR,("MyAllocatePool: ERROR!! Cannot allocate pool.\n"));
    } else {
        if(++AllocateCount > MAXNUM_POOL){
            DebugTrace(TRACE_WARNING,("MyAllocatePool: WARNING!! Allocate called %dtimes more than Free\n", MAXNUM_POOL));
        }
        DebugTrace(TRACE_STATUS,("MyAllocatePool: Count = %d\n", AllocateCount));
    }
#endif // DBG

    DebugTrace(TRACE_PROC_LEAVE,("MyAllocatePool: Leaving.. pvRet = %x\n", pvRet));
    return pvRet;
}


VOID
MyFreePool(
    IN PVOID     pvAddress
)
/*++

Routine Description:

    Wrapper for pool free. Check tag to avoid heap corruption

Arguments:

    pvAddress - Pointer to the allocated memory

Return Value:

    none.

--*/
{

    DebugTrace(TRACE_PROC_ENTER,("USFreePool: Enter..\n"));

#if DBG
    {
        ULONG ulTag;
    
        ulTag = *((PULONG)pvAddress-1);
//        if( (NAME_POOLTAG == ulTag) || (DebugTraceLevel & TRACE_IGNORE_TAG) ){
        if(NAME_POOLTAG == ulTag){
            if(--AllocateCount < 0){
                DebugTrace(TRACE_WARNING,("MyFreePool: Warning!! Free called more than Allocate.\n"));
            }
        } else {
            DebugTrace(TRACE_WARNING,("MyFreePool: WARNING!! tag = %c%c%c%c\n",
                                        ((PUCHAR)&ulTag)[0],
                                        ((PUCHAR)&ulTag)[1],
                                        ((PUCHAR)&ulTag)[2],
                                        ((PUCHAR)&ulTag)[3]  ));
        }
    }
#endif // DBG

    ExFreePool(pvAddress);

    DebugTrace(TRACE_PROC_LEAVE,("MyFreePool: Leaving.. Return = NONE\n"));
}
#endif // ORIGINAL_POOLTRACK


VOID
MyDebugInit(
    IN  PUNICODE_STRING pRegistryPath
)
/*++

Routine Description:

    Read DebugTraceLevel key from driver's registry if exists.

Arguments:

    pRegistryPath   -   pointer to a unicode string representing the path
                        to driver-specific key in the registry

Return Value:

    none.

--*/
{

    HANDLE                          hDriverRegistry;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    UNICODE_STRING                  unicodeKeyName;
    ULONG                           DataSize;
    PKEY_VALUE_PARTIAL_INFORMATION  pValueInfo;
    NTSTATUS                        Status;
    
    DebugTrace(TRACE_PROC_ENTER,("MyDebugInit: Enter... \n"));
    
    //
    // Initialize local variables.
    //
    
    Status          = STATUS_SUCCESS;
    hDriverRegistry = NULL;
    pValueInfo      = NULL;
    DataSize        = 0;

    //
    // Initialize object attribute and open registry key.
    //
    
    RtlZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));
    InitializeObjectAttributes(&ObjectAttributes,
                               pRegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    
    Status = ZwOpenKey(&hDriverRegistry,
                       KEY_READ,
                       &ObjectAttributes);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR,("MyDebugInit: ERROR!! Can't open driver registry key.\n"));
        goto MyDebugInit_return;
    }
    
    //
    // Read "DebugTraceLevel" key.
    //

    DebugTrace(TRACE_CRITICAL,("MyDebugInit: Query %wZ\\%ws.\n", pRegistryPath, REG_DEBUGLEVEL));

    //
    // Query required size.
    //
    
    RtlInitUnicodeString(&unicodeKeyName, REG_DEBUGLEVEL);
    Status = ZwQueryValueKey(hDriverRegistry,
                             &unicodeKeyName,
                             KeyValuePartialInformation,
                             NULL,
                             0,
                             &DataSize);
    if( (Status != STATUS_BUFFER_OVERFLOW)
     && (Status != STATUS_BUFFER_TOO_SMALL)
     && (Status != STATUS_SUCCESS) )
    {
        if(Status == STATUS_OBJECT_NAME_NOT_FOUND){
            DebugTrace(TRACE_STATUS,("MyDebugInit: DebugTraceLevel doesn't exist. Use default(0x%x).\n", DebugTraceLevel));
        } else {
            DebugTrace(TRACE_ERROR,("MyDebugInit: ERROR!! ZwQueryValueKey failed. Status=0x%x\n", Status));
        }
        goto MyDebugInit_return;
    }
    
    //
    // Check size of data.
    //
    
    if (MAX_TEMPBUF < DataSize) {
        DebugTrace(TRACE_ERROR, ("MyDebugInit: ERROR!! DataSize (0x%x) is too big.\n", DataSize));
        goto MyDebugInit_return;
    }

    if (0 == DataSize) {
        DebugTrace(TRACE_ERROR, ("MyDebugInit: ERROR!! Cannot retrieve required data size.\n"));
        goto MyDebugInit_return;
    }

    //
    // Allocate memory for temp buffer. size +2 for NULL.
    //

    pValueInfo = MyAllocatePool(NonPagedPool, DataSize+2);
    if(NULL == pValueInfo){
        DebugTrace(TRACE_CRITICAL, ("MyDebugInit: ERROR!! Buffer allocate failed.\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto MyDebugInit_return;
    }
    RtlZeroMemory(pValueInfo, DataSize+2);

    //
    // Query specified value.
    //
    
    Status = ZwQueryValueKey(hDriverRegistry,
                             &unicodeKeyName,
                             KeyValuePartialInformation,
                             pValueInfo,
                             DataSize,
                             &DataSize);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR, ("MyDebugInit: ERROR!! ZwQueryValueKey failed.\n"));
        goto MyDebugInit_return;
    }
    
    //
    // Set DebugTraceLevel.
    //
    
    DebugTraceLevel = *((PULONG)pValueInfo->Data);
    DebugTrace(TRACE_CRITICAL, ("MyDebugInit: Reg-key found. DebugTraceLevel=0x%x.\n", *((PULONG)pValueInfo->Data)));

MyDebugInit_return:

    //
    // Clean up.
    //
    
    if(pValueInfo){
        MyFreePool(pValueInfo);
    }
    
    if(NULL != hDriverRegistry){
        ZwClose(hDriverRegistry);
    }

    DebugTrace(TRACE_PROC_LEAVE,("MyDebugInit: Leaving... Status=0x%x, Ret=VOID.\n", Status));
    return;
}

#if DBG

VOID
MyDumpMemory(
    PUCHAR  pDumpBuffer,
    ULONG   dwSize,
    BOOLEAN bRead
)
{
    NTSTATUS    Status;
    ULONG       ulCounter;
    ULONG       ulMaxSize;

    //
    // Check the flag first.
    //

    if(bRead){
        if(!(DebugTraceLevel & TRACE_FLAG_DUMP_READ)){
            return;
        }
    } else { // if(bRead)
        if(!(DebugTraceLevel & TRACE_FLAG_DUMP_WRITE)){
            return;
        }
    } // if(bRead)

    DebugTrace(TRACE_PROC_ENTER,("MyDebugDump: Enter... \n"));
        
    //
    // Initialize local.
    //
        
    Status          = STATUS_SUCCESS;
    ulCounter       = 0;
    ulMaxSize       = DebugDumpMax;
    
    //
    // Check the arguments.
    //
        
    if(NULL == pDumpBuffer){
        DebugTrace(TRACE_WARNING,("MyDebugDump: WARNING!! pDumpBuffer = NULL \n"));
        Status = STATUS_INVALID_PARAMETER_1;
        goto MyDumpMemory_return;
    }

    if(0 == dwSize){
        DebugTrace(TRACE_STATUS,("MyDebugDump: WARNING!! dwSize = 0 \n"));
        Status = STATUS_INVALID_PARAMETER_2;
        goto MyDumpMemory_return;
    }

    if(bRead){
        DebugTrace(TRACE_ERROR,("MyDebugDump: Received buffer. Size=0x%x.\n", dwSize));
    } else {
        DebugTrace(TRACE_ERROR,("MyDebugDump: Passing buffer. Size=0x%x.\n", dwSize));
    }

/*
    //
    // Probe the buffer.
    //

    try {
        ProbeForRead(pDumpBuffer,
                     dwSize,
                     sizeof(UCHAR));
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        DebugTrace(TRACE_ERROR,("MyDebugDump: Buffer pointer (0x%x) is invalid. Status=0x%x\n", pDumpBuffer, Status));
        goto MyDumpMemory_return;
    } // except
*/
    //
    // Max dump size = 1k;
    //
    
    ulMaxSize = min(ulMaxSize , dwSize);

    //
    // Dump the buffer.
    //
    
    for(ulCounter = 0; ulCounter < ulMaxSize; ulCounter++){
        if(0 == (ulCounter & 0xfF)){
            DbgPrint("\n");
            DbgPrint(NAME_DRIVER);
            DbgPrint("           +0 +1 +2 +3 +4 +5 +6 +7   +8 +9 +a +b +c +d +e +f\n");
            DbgPrint(NAME_DRIVER);
            DbgPrint("------------------------------------------------------------\n");
        }

        if(0 == (ulCounter & 0xf)){
            DbgPrint(NAME_DRIVER);
            DbgPrint("%p :", pDumpBuffer+ulCounter);
        }

        DbgPrint(" %02x", *(pDumpBuffer+ulCounter));

        if(0x7 == (ulCounter & 0xf)){
            DbgPrint(" -");
        }

        if(0xf == (ulCounter & 0xf)){
            DbgPrint("\n");
        }
    }

    DbgPrint("\n");
    DbgPrint(NAME_DRIVER);
    DbgPrint("------------------------------------------------------------\n\n");

MyDumpMemory_return:
    DebugTrace(TRACE_PROC_LEAVE,("MyDebugDump: Leaving... Status=0x%x, Ret=VOID.\n", Status));
    return;

} // MyDumpMemory(

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\serscan\rdwr.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    rdwr.c

Abstract:

    This module contains the code for a serial imaging devices
    suport class driver.

Author:

    Vlad Sadovsky    vlads              10-April-1998

Environment:

    Kernel mode

Revision History :

    vlads           04/10/1998      Created first draft

--*/

#include "serscan.h"
#include "serlog.h"

#if DBG
extern ULONG SerScanDebugLevel;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SerScanReadWrite)
#endif


NTSTATUS
SerScanReadWrite(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for read and write requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS              - Success.
    STATUS_PENDING              - Request pending.
    STATUS_INVALID_PARAMETER    - Invalid parameter.

--*/

{
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension;

    PAGED_CODE();

    Extension = DeviceObject->DeviceExtension;

    //
    // Call down to the parent but don't wait...we'll get an IoCompletion callback.
    //
    Status = SerScanCallParent(Extension,
                               Irp,
                               NO_WAIT,
                               SerScanCompleteIrp);

    DebugDump(SERIRPPATH,
              ("SerScan: [Read/Write] After CallParent Status = %x\n",
              Status));

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\serscan\pnppwr.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This module contains the code for a serial imaging devices driver
    supporting PnP functionality

Author:

    Vlad Sadovsky    vlads              10-April-1998

Environment:

    Kernel mode

Revision History :

    vlads           04/10/1998      Created first draft

--*/

#include "serscan.h"
#include "serlog.h"

//#include <ntpoapi.h>

extern ULONG SerScanDebugLevel;

extern  const PHYSICAL_ADDRESS PhysicalZero ;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SerScanPnp)
#pragma alloc_text(PAGE, SerScanPower)
#endif

NTSTATUS
SerScanPnp (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   )
/*++

Routine Description:

    This routine handles all PNP IRPs, dispatching them as appropriate .

Arguments:

    pDeviceObject           - represents a device

    pIrp                    - PNP Irp

Return Value:

    STATUS_SUCCESS          - if successful.
    STATUS_UNSUCCESSFUL     - otherwise.

--*/
{
    NTSTATUS                        Status ;
    PDEVICE_EXTENSION               Extension;
    PIO_STACK_LOCATION              pIrpStack;
    PVOID                           pObject;
    ULONG                           NewReferenceCount;
    NTSTATUS                        ReturnStatus;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    Extension = pDeviceObject->DeviceExtension;

    Status = STATUS_SUCCESS;

    DebugDump(SERINITDEV,("Entering PnP Dispatcher\n"));

    switch (pIrpStack->MinorFunction) {

        case IRP_MN_START_DEVICE:

            //
            // Initialize PendingIoEvent.  Set the number of pending i/o requests for this device to 1.
            // When this number falls to zero, it is okay to remove, or stop the device.
            //

            DebugDump(SERINITDEV,("Entering Start Device \n"));

            KeInitializeEvent(&Extension -> PdoStartEvent, SynchronizationEvent, FALSE);

            IoCopyCurrentIrpStackLocationToNext(pIrp);

            Status = WaitForLowerDriverToCompleteIrp(
                                        Extension->LowerDevice,
                                        pIrp,
                                        &Extension->PdoStartEvent);

            if (!NT_SUCCESS(Status)) {

                pIrp->IoStatus.Status      = Status;
                pIrp->IoStatus.Information = 0;

                IoCompleteRequest(pIrp, IO_NO_INCREMENT);
                return (Status);

            }

            #ifdef CREATE_SYMBOLIC_NAME

            //
            // Now setup the symbolic link for windows.
            //

            Status = IoCreateUnprotectedSymbolicLink(&Extension->SymbolicLinkName, &Extension->ClassName);

            if (NT_SUCCESS(Status)) {

                // We were able to create the symbolic link, so record this
                // value in the extension for cleanup at unload time.

                Extension->CreatedSymbolicLink = TRUE;

                // Write out the result of the symbolic link to the registry.

                Status = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP,
                                               L"Serial Scanners",
                                               Extension->ClassName.Buffer,
                                               REG_SZ,
                                               Extension->SymbolicLinkName.Buffer,
                                               Extension->SymbolicLinkName.Length + sizeof(WCHAR));
                if (!NT_SUCCESS(Status)) {

                    //
                    // It didn't work.  Just go to cleanup.
                    //

                    DebugDump(SERERRORS,
                              ("SerScan: Couldn't create the device map entry\n"
                               "--------  for port %wZ\n",
                               &Extension->ClassName));

                    SerScanLogError(pDeviceObject->DriverObject,
                                    pDeviceObject,
                                    PhysicalZero,
                                    PhysicalZero,
                                    0,
                                    0,
                                    0,
                                    6,
                                    Status,
                                    SER_NO_DEVICE_MAP_CREATED);
                }

            } else {

                //
                // Couldn't create the symbolic link.
                //

                Extension->CreatedSymbolicLink = FALSE;

                ExFreePool(Extension->SymbolicLinkName.Buffer);
                Extension->SymbolicLinkName.Buffer = NULL;

                DebugDump(SERERRORS,
                          ("SerScan: Couldn't create the symbolic link\n"
                           "--------  for port %wZ\n",
                           &Extension->ClassName));

                SerScanLogError(pDeviceObject->DriverObject,
                                pDeviceObject,
                                PhysicalZero,
                                PhysicalZero,
                                0,
                                0,
                                0,
                                5,
                                Status,
                                SER_NO_SYMLINK_CREATED);

            }

            #endif

            ExFreePool(Extension->ClassName.Buffer);
            Extension->ClassName.Buffer = NULL;

            //
            // Ignore status of link registry write  - always succeed
            //

            //
            // Clear InInit flag to indicate device object can be used
            //
            pDeviceObject->Flags &= ~(DO_DEVICE_INITIALIZING);

            pIrp->IoStatus.Status      = Status;
            pIrp->IoStatus.Information = 0;

            IoCompleteRequest(pIrp, IO_NO_INCREMENT);
            return (Status);

            break;

        case IRP_MN_QUERY_REMOVE_DEVICE:
            //
            //  Always pass to lower device in stack after indicating that we don't object
            //
            DebugDump(SERALWAYS,("IRP_MN_QUERY_REMOVE_DEVICE\n"));

            Extension->Removing = TRUE;

            IoCopyCurrentIrpStackLocationToNext( pIrp );
            return (IoCallDriver(Extension->LowerDevice, pIrp));

            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            //
            //  Always pass to lower device in stack , reset indicator as somebody canceled
            //
            DebugDump(SERALWAYS,("IRP_MN_CANCEL_REMOVE_DEVICE\n"));

            Extension->Removing = FALSE;

            //
            // Kill symbolic link
            //
            if (Extension->CreatedSymbolicLink) {
                IoDeleteSymbolicLink(&Extension->SymbolicLinkName);
                Extension->CreatedSymbolicLink = FALSE;
            }

            IoCopyCurrentIrpStackLocationToNext( pIrp );
            return (IoCallDriver(Extension->LowerDevice, pIrp));

            break;


        case IRP_MN_SURPRISE_REMOVAL:
            //
            // Should not ever happen with us, but still process
            //

            DebugDump(SERALWAYS,("IRP_MN_SURPRISE_REMOVAL\n"));

            Extension->Removing = TRUE;

            //
            //  Get rid of the symbolic link
            //
            SerScanHandleSymbolicLink(
                Extension->Pdo,
                &Extension->InterfaceNameString,
                FALSE
                );

            #ifdef USE_EXECUTIVE_RESOURCE
            ExAcquireResourceExclusiveLite(
                &Extension->Resource,
                TRUE
                );
            #else
            ExAcquireFastMutex(&Extension->Mutex);
            #endif

            pObject = InterlockedExchangePointer(&Extension->AttachedFileObject,NULL);
            if (pObject) {
                ObDereferenceObject(pObject);
            }

            pObject = InterlockedExchangePointer(&Extension->AttachedDeviceObject,NULL);
            if (pObject) {
                ObDereferenceObject(pObject);
            }

            #ifdef USE_EXECUTIVE_RESOURCE
            ExReleaseResourceLite(&Extension->Resource);
            #else
            ExReleaseFastMutex(&Extension->Mutex);
            #endif

            IoCopyCurrentIrpStackLocationToNext( pIrp );
            return (IoCallDriver(Extension->LowerDevice, pIrp));


            break;

        case IRP_MN_REMOVE_DEVICE:

            DebugDump(SERALWAYS,("IRP_MN_REMOVE_DEVICE\n"));

            DebugDump(SERINITDEV,("Entering PnP Remove Device\n"));


            //
            // Stop new requests - device is being removed
            //
            Extension->Removing = TRUE;

            //
            //  Get rid of the symbolic link
            //
            SerScanHandleSymbolicLink(
                Extension->Pdo,
                &Extension->InterfaceNameString,
                FALSE
                );


            #ifdef USE_EXECUTIVE_RESOURCE
            ExAcquireResourceExclusiveLite(
                &Extension->Resource,
                TRUE
                );
            #else
            ExAcquireFastMutex(&Extension->Mutex);
            #endif

            pObject = InterlockedExchangePointer(&Extension->AttachedFileObject,NULL);
            if (pObject) {
                ObDereferenceObject(pObject);
            }

            pObject = InterlockedExchangePointer(&Extension->AttachedDeviceObject,NULL);
            if (pObject) {
                ObDereferenceObject(pObject);
            }

            #ifdef USE_EXECUTIVE_RESOURCE
            ExReleaseResourceLite(&Extension->Resource);
            #else
            ExReleaseFastMutex(&Extension->Mutex);
            #endif

            //
            // Send IRP down to lower device
            //
            IoCopyCurrentIrpStackLocationToNext( pIrp );
            ReturnStatus = IoCallDriver(Extension->LowerDevice, pIrp);

            //
            // Decrement ref count
            //
            NewReferenceCount = InterlockedDecrement(&Extension->ReferenceCount);

            if (NewReferenceCount != 0) {
                //
                // Wait for any io requests pending in our driver to
                // complete before finishing the remove
                //
                KeWaitForSingleObject(&Extension -> RemoveEvent,
                                      Suspended,
                                      KernelMode,
                                      FALSE,
                                      NULL);
            }

            // ASSERT(&Extension->ReferenceCount == 0);
            #ifdef USE_EXECUTIVE_RESOURCE
            ExDeleteResourceLite(&Extension->Resource);
            #endif

            DebugDump(SERALWAYS,("IRP_MN_QUERY_REMOVE_DEVICE - Calling IoDeleteDevice - gone\n"));

            IoDetachDevice(Extension->LowerDevice);

            //
            // Free allocated resource.
            //
            
            if(NULL != Extension->ClassName.Buffer){
                ExFreePool(Extension->ClassName.Buffer);
            } // if(NULL != Extension->ClassName.Buffer)

            if(NULL != Extension->SymbolicLinkName.Buffer){
                ExFreePool(Extension->SymbolicLinkName.Buffer);
            } // if(NULL != Extension->SymbolicLinkName.Buffer)

            IoDeleteDevice(pDeviceObject);

            return ReturnStatus;

            break;

        case IRP_MN_STOP_DEVICE:
            //
            // Pass down
            //
            DebugDump(SERALWAYS,("IRP_MN_STOP_DEVICE\n"));

            IoCopyCurrentIrpStackLocationToNext( pIrp );
            return (IoCallDriver(Extension->LowerDevice, pIrp));

            break;

        case IRP_MN_QUERY_STOP_DEVICE:
            //
            // Check open counts
            //
            DebugDump(SERALWAYS,("IRP_MN_QUERY_STOP_DEVICE\n"));

            if (Extension->OpenCount > 0 ) {
                DebugDump(SERALWAYS,("Rejecting QUERY_STOP_DEVICE\n"));

                pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

                IoCompleteRequest(pIrp, IO_NO_INCREMENT);

                return STATUS_UNSUCCESSFUL;
            }

            IoCopyCurrentIrpStackLocationToNext( pIrp );
            return (IoCallDriver(Extension->LowerDevice, pIrp));

            break;


        case IRP_MN_CANCEL_STOP_DEVICE:
            //
            // Nothing to do here, but pass to lower
            //
            DebugDump(SERALWAYS,("IRP_MN_CANCEL_STOP_DEVICE\n"));

            IoCopyCurrentIrpStackLocationToNext( pIrp );
            return (IoCallDriver(Extension->LowerDevice, pIrp));

            break;


        case IRP_MN_QUERY_CAPABILITIES:
            {

                ULONG   i;
                KEVENT  WaitEvent;

                //
                // Send this down to the PDO first
                //

                KeInitializeEvent(&WaitEvent, SynchronizationEvent, FALSE);

                IoCopyCurrentIrpStackLocationToNext(pIrp);

                Status=WaitForLowerDriverToCompleteIrp(
                    Extension->LowerDevice,
                    pIrp,
                    &WaitEvent
                    );

                pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

                for (i = PowerSystemUnspecified; i < PowerSystemMaximum;   i++) {

                    Extension->SystemPowerStateMap[i]=PowerDeviceD3;
                }

                for (i = PowerSystemUnspecified; i < PowerSystemHibernate;  i++) {

                    Extension->SystemPowerStateMap[i]=pIrpStack->Parameters.DeviceCapabilities.Capabilities->DeviceState[i];
                }

                Extension->SystemPowerStateMap[PowerSystemWorking]=PowerDeviceD0;

                Extension->SystemWake=pIrpStack->Parameters.DeviceCapabilities.Capabilities->SystemWake;
                Extension->DeviceWake=pIrpStack->Parameters.DeviceCapabilities.Capabilities->DeviceWake;

                IoCompleteRequest(
                    pIrp,
                    IO_NO_INCREMENT
                    );
                return Status;
            }

            break;

        default:

            //
            // Unknown function - pass down
            //
            DebugDump(SERALWAYS,("Passing Pnp Irp down. MnFunc=%x ,  status = %x\n",pIrpStack->MinorFunction, Status));

            IoCopyCurrentIrpStackLocationToNext( pIrp );
            return (IoCallDriver(Extension->LowerDevice, pIrp));

            break;
    }

    //
    // Complete the IRP...
    //

    if (!NT_SUCCESS(Status)) {
        pIrp -> IoStatus.Status = Status;
        pIrp->IoStatus.Information = 0;
        IoCompleteRequest( pIrp, IO_NO_INCREMENT );
    }
    else {

        DebugDump(SERALWAYS,("Passing Pnp Irp down,  status = %x\n", Status));

        IoCopyCurrentIrpStackLocationToNext(pIrp);
        Status = IoCallDriver(Extension->LowerDevice, pIrp);
    }

    return( Status );

}


VOID
DevicePowerCompleteRoutine(
    PDEVICE_OBJECT    DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{

    return;
}


NTSTATUS
SerScanPower(
        IN PDEVICE_OBJECT pDeviceObject,
        IN PIRP           pIrp
    )
/*++

Routine Description:

    Process the Power IRPs sent to the PDO for this device.

Arguments:

    pDeviceObject - pointer to the functional device object (FDO) for this device.
    pIrp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
{
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension = pDeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    POWER_STATE         PowerState;

    PAGED_CODE();

    Status     = STATUS_SUCCESS;

    switch (pIrpStack->MinorFunction) {

        case IRP_MN_SET_POWER:

            if (pIrpStack->Parameters.Power.Type == SystemPowerState) {
                //
                //  system power state change
                //
                //
                //  request the change in device power state based on systemstate map
                //
                PowerState.DeviceState=Extension->SystemPowerStateMap[pIrpStack->Parameters.Power.State.SystemState];

                PoRequestPowerIrp(
                    Extension->Pdo,
                    IRP_MN_SET_POWER,
                    PowerState,
                    DevicePowerCompleteRoutine,
                    pIrp,
                    NULL
                    );


            }  else {
                //
                //  changing device state
                //
                PoSetPowerState(
                    Extension->Pdo,
                    pIrpStack->Parameters.Power.Type,
                    pIrpStack->Parameters.Power.State
                    );

            }

            break;

        case IRP_MN_QUERY_POWER:

            pIrp->IoStatus.Status = STATUS_SUCCESS;

            break;

        default:

            break;

    }

    PoStartNextPowerIrp(pIrp);

    IoSkipCurrentIrpStackLocation(pIrp);

    Status=PoCallDriver(Extension->LowerDevice, pIrp);

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\serscan\open.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    serscan.c

Abstract:

    This module contains the code for a serial imaging devices driver
    Open and Create routines

Author:

    Vlad Sadovsky    vlads              10-April-1998

Environment:

    Kernel mode

Revision History :

    vlads           04/10/1998      Created first draft

--*/

#include "serscan.h"
#include "serlog.h"

#if DBG
extern ULONG SerScanDebugLevel;
#endif

NTSTATUS
SerScanCreateOpen(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for a create requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS  - Success.
    !STATUS_SUCCESS - Failure.

--*/

{
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension;
    PIO_STACK_LOCATION  IrpSp;
    PFILE_OBJECT        FileObject;

    PAGED_CODE();

    Extension = DeviceObject->DeviceExtension;

    //
    // From the FileObject determine what mode we are running in.
    //
    // If FileObject->DeviceObject == DeviceObject, the user opened our device
    // and we will process each of the callbacks (Filter mode).
    //
    // If FileObject->DeviceObject != DeviceObject, the user opened PORTx
    // and we will get out of the way (PassThrough mode).
    //

    IrpSp      = IoGetCurrentIrpStackLocation (Irp);
    FileObject = IrpSp->FileObject;

    // ASSERT (FileObject == NULL);

    //
    // Are the DeviceObjects equal...
    //
    Extension->PassThrough = !(FileObject->DeviceObject == DeviceObject);

    //
    // Call down to the parent and wait on the CreateOpen IRP to complete...
    //
    Status = SerScanCallParent(Extension,
                               Irp,
                               WAIT,
                               NULL);

    DebugDump(SERIRPPATH,
              ("SerScan: [CreateOpen] After CallParent Status = %x\n",
              Status));

    //
    // WORKWORK:  If we are in filter mode, we'll connect here...
    //

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}

NTSTATUS
SerScanClose(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for a close requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS  - Success.

--*/

{
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension;

    PAGED_CODE();

    Extension = DeviceObject->DeviceExtension;

    //
    // Call down to the parent and wait on the Close IRP to complete...
    //
    Status = SerScanCallParent(Extension,
                               Irp,
                               WAIT,
                               NULL);

    DebugDump(SERIRPPATH,
              ("SerScan: [Close] After CallParent Status = %x\n",
              Status));

    //
    // WORKWORK:  If we are in filter mode we need to disconnect here...
    //

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\serscan\ioctl.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    rdwr.c

Abstract:

    This module contains the code for a serial imaging devices driver.
    I/O control routine

Author:

    Vlad Sadovsky    vlads              10-April-1998

Environment:

    Kernel mode

Revision History :

    vlads           04/10/1998      Created first draft

--*/

#include "serscan.h"
#include "serlog.h"

#if DBG
extern ULONG SerScanDebugLevel;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SerScanDeviceControl)
#endif

NTSTATUS
SerScanDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for device control requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS              - Success.
    STATUS_PENDING              - Request pending.
    STATUS_BUFFER_TOO_SMALL     - Buffer too small.
    STATUS_INVALID_PARAMETER    - Invalid io control request.

--*/

{
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension;

    PAGED_CODE();

    Extension = DeviceObject->DeviceExtension;

    //
    // Call down to the parent but don't wait...we'll get an IoCompletion callback.
    //
    Status = SerScanCallParent(Extension,
                               Irp,
                               NO_WAIT,
                               SerScanCompleteIrp);

    DebugDump(SERIRPPATH,
              ("SerScan: [Cleanup] After CallParent Status = %x\n",
              Status));

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\serscan\serscan.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    serscan.c

Abstract:

    This module contains the code for a serial imaging devices
    suport class driver.

Author:

    Vlad Sadovsky    vlads              10-April-1998

Environment:

    Kernel mode

Revision History :

    vlads           04/10/1998      Created first draft

--*/

#include "serscan.h"
#include "serlog.h"

#include <initguid.h>

#include <devguid.h>
#include <wiaintfc.h>

#if DBG
ULONG SerScanDebugLevel = -1;
#endif

const PHYSICAL_ADDRESS PhysicalZero = {0};

//
// Keep track of the number of Serial port devices created...
//
ULONG g_NumPorts = 0;

//
// Definition of OpenCloseMutex.
//
extern ULONG OpenCloseReferenceCount = 1;
extern PFAST_MUTEX OpenCloseMutex = NULL;

//
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, SerScanAddDevice)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is called at system initialization time to initialize
    this driver.

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS          - We could initialize at least one device.
    STATUS_NO_SUCH_DEVICE   - We could not in itialize even one device.

--*/

{

    int     i;

    PAGED_CODE();

    #if DBG
    DebugDump(SERINITDEV,("Entering DriverEntry\n"));
    #endif

    //
    // Initialize the Driver Object with driver's entry points
    //
    DriverObject->DriverExtension->AddDevice              = SerScanAddDevice;

    DriverObject->DriverUnload = SerScanUnload;

    #ifdef DEAD_CODE
    for (i=0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {

        DriverObject->MajorFunction[i]= SerScanPassThrough;
    }
    #endif

    DriverObject->MajorFunction[IRP_MJ_CREATE]            = SerScanCreateOpen;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]             = SerScanClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]    = SerScanDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]               = SerScanPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER]             = SerScanPower;

    //
    // Following are possibly not needed, keep them here to allow
    // easier tracing in when debugging. All of them resort to pass-through
    // behaviour
    //
    #ifdef DEAD_CODE

    DriverObject->MajorFunction[IRP_MJ_CLEANUP]           = SerScanCleanup;
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] = SerScanQueryInformationFile;
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]   = SerScanSetInformationFile;

    #endif

    DriverObject->MajorFunction[IRP_MJ_READ]              = SerScanPassThrough;
    DriverObject->MajorFunction[IRP_MJ_WRITE]             = SerScanPassThrough;

    return STATUS_SUCCESS;

}


NTSTATUS
SerScanAddDevice(
    IN PDRIVER_OBJECT pDriverObject,
    IN PDEVICE_OBJECT pPhysicalDeviceObject
    )
/*++

Routine Description:

    This routine is called to create a new instance of the device.
    It creates FDO and attaches it to PDO

Arguments:

    pDriverObject           - pointer to the driver object for this instance of port.

    pPhysicalDeviceObject   - pointer to the device object that represents the port.

Return Value:

    STATUS_SUCCESS          - if successful.
    STATUS_UNSUCCESSFUL     - otherwise.

--*/
{
    UNICODE_STRING      ClassName;
    UNICODE_STRING      LinkName;
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension;
    PDEVICE_OBJECT      pDeviceObject;

    PAGED_CODE();


    DebugDump(SERINITDEV,("Entering AddDevice\n"));

    //
    // Get the Class and Link names.
    //

    if (!SerScanMakeNames (g_NumPorts, &ClassName, &LinkName)) {

        SerScanLogError(pDriverObject,
                        NULL,
                        PhysicalZero,
                        PhysicalZero,
                        0,
                        0,
                        0,
                        1,
                        STATUS_SUCCESS,
                        SER_INSUFFICIENT_RESOURCES);

        DebugDump(SERERRORS,("SerScan: Could not form Unicode name strings.\n"));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Create the device object for this device.
    //

    Status = IoCreateDevice(pDriverObject,
                            sizeof(DEVICE_EXTENSION),
                            &ClassName,
                            FILE_DEVICE_SCANNER,
                            0,
                            TRUE,
                            &pDeviceObject);


    if (!NT_SUCCESS(Status)) {

        ExFreePool(ClassName.Buffer);
        ExFreePool(LinkName.Buffer);

        SerScanLogError(pDriverObject,
                        NULL,
                        PhysicalZero,
                        PhysicalZero,
                        0,
                        0,
                        0,
                        9,
                        STATUS_SUCCESS,
                        SER_INSUFFICIENT_RESOURCES);

        DebugDump(SERERRORS, ("SERPORT:  Could not create a device for %d\n", g_NumPorts));

        return Status;
    }

    //
    // The device object has a pointer to an area of non-paged
    // pool allocated for this device.  This will be the device
    // extension.
    //

    Extension = pDeviceObject->DeviceExtension;

    //
    // Zero all of the memory associated with the device
    // extension.
    //

    RtlZeroMemory(Extension, sizeof(DEVICE_EXTENSION));

    //
    // Get a "back pointer" to the device object.
    //

    Extension->DeviceObject = pDeviceObject;

    Extension->Pdo = pPhysicalDeviceObject;

    Extension->AttachedDeviceObject = NULL;
    Extension->AttachedFileObject = NULL;

    //
    // Setup buffered I/O
    //
    pDeviceObject->Flags |= DO_BUFFERED_IO;

    //
    // Indicate our power code is pageable
    //
    pDeviceObject->Flags |= DO_POWER_PAGABLE;

    //
    // Attach our new Device to our parents stack.
    //
    Extension->LowerDevice = IoAttachDeviceToDeviceStack(
                                  pDeviceObject,
                                  pPhysicalDeviceObject);

    if (NULL == Extension->LowerDevice) {

        ExFreePool(ClassName.Buffer);
        ExFreePool(LinkName.Buffer);

        IoDeleteDevice(pDeviceObject);

        return STATUS_UNSUCCESSFUL;
    }

    Extension->ClassName        = ClassName;
    Extension->SymbolicLinkName = LinkName;

    Status = SerScanHandleSymbolicLink(
        pPhysicalDeviceObject,
        &Extension->InterfaceNameString,
        TRUE
        );

    //
    // We have created the device, so increment the counter
    // that keeps track.
    //
    g_NumPorts++;

    //
    // Initiliaze the rest of device extension
    //
    Extension->ReferenceCount = 1;

    Extension->Removing = FALSE;

    Extension->OpenCount = 0;

    KeInitializeEvent(&Extension->RemoveEvent,
                      NotificationEvent,
                      FALSE
                      );

    // ExInitializeResourceLite(&Extension->Resource);
    ExInitializeFastMutex(&Extension->Mutex);

    //
    // Clear InInit flag to indicate device object can be used
    //
    pDeviceObject->Flags &= ~(DO_DEVICE_INITIALIZING);


    return STATUS_SUCCESS;

}

BOOLEAN
SerScanMakeNames(
    IN  ULONG           SerialPortNumber,
    OUT PUNICODE_STRING ClassName,
    OUT PUNICODE_STRING LinkName
    )

/*++

Routine Description:

    This routine generates the names \Device\SerScanN.

    This routine will allocate pool so that the buffers of
    these unicode strings need to be eventually freed.

Arguments:

    SerialPortNumber  - Supplies the serial port number.

    ClassName           - Returns the class name.

    LinkName            - Returns the link name.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    UNICODE_STRING  Prefix;
    UNICODE_STRING  Digits;
    UNICODE_STRING  LinkPrefix;
    UNICODE_STRING  LinkDigits;
    WCHAR           DigitsBuffer[10];
    WCHAR           LinkDigitsBuffer[10];
    UNICODE_STRING  ClassSuffix;
    UNICODE_STRING  LinkSuffix;
    NTSTATUS        Status;

    //
    // Put together local variables for constructing names.
    //

    RtlInitUnicodeString(&Prefix, L"\\Device\\");
    RtlInitUnicodeString(&LinkPrefix, L"\\DosDevices\\");

    //
    // WORKWORK: Change the name to be device specific.
    //
    RtlInitUnicodeString(&ClassSuffix, SERSCAN_NT_SUFFIX);
    RtlInitUnicodeString(&LinkSuffix, SERSCAN_LINK_NAME);

    Digits.Length        = 0;
    Digits.MaximumLength = 20;
    Digits.Buffer        = DigitsBuffer;

    LinkDigits.Length        = 0;
    LinkDigits.MaximumLength = 20;
    LinkDigits.Buffer        = LinkDigitsBuffer;

    Status = RtlIntegerToUnicodeString(SerialPortNumber, 10, &Digits);
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    Status = RtlIntegerToUnicodeString(SerialPortNumber + 1, 10, &LinkDigits);
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    //
    // Make the class name.
    //

    ClassName->Length = 0;
    ClassName->MaximumLength = Prefix.Length + ClassSuffix.Length +
                               Digits.Length + sizeof(WCHAR);

    ClassName->Buffer = ExAllocatePool(PagedPool, ClassName->MaximumLength);
    if (!ClassName->Buffer) {
        return FALSE;
    }

    RtlZeroMemory(ClassName->Buffer, ClassName->MaximumLength);
    RtlAppendUnicodeStringToString(ClassName, &Prefix);
    RtlAppendUnicodeStringToString(ClassName, &ClassSuffix);
    RtlAppendUnicodeStringToString(ClassName, &Digits);

    //
    // Make the link name.
    //

    LinkName->Length = 0;
    LinkName->MaximumLength = LinkPrefix.Length + LinkSuffix.Length +
                              LinkDigits.Length + sizeof(WCHAR);

    LinkName->Buffer = ExAllocatePool(PagedPool, LinkName->MaximumLength);
    if (!LinkName->Buffer) {
        ExFreePool(ClassName->Buffer);
        return FALSE;
    }

    RtlZeroMemory(LinkName->Buffer, LinkName->MaximumLength);
    RtlAppendUnicodeStringToString(LinkName, &LinkPrefix);
    RtlAppendUnicodeStringToString(LinkName, &LinkSuffix);
    RtlAppendUnicodeStringToString(LinkName, &LinkDigits);

    return TRUE;
}


NTSTATUS
SerScanCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for a cleanup requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS  - Success.

--*/

{
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension;

    Extension = DeviceObject->DeviceExtension;

    //
    // Call down to the parent and wait on the Cleanup IRP to complete...
    //
    Status = SerScanCallParent(Extension,
                               Irp,
                               WAIT,
                               NULL);

    DebugDump(SERIRPPATH,
              ("SerScan: [Cleanup] After CallParent Status = %x\n",
              Status));

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}

VOID
SerScanCancelRequest(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel any request in the Serial driver.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension;

    Extension = DeviceObject->DeviceExtension;

    //
    // Call down to the parent and wait on the Cleanup IRP to complete...
    //
    Status = SerScanCallParent(Extension,
                               Irp,
                               WAIT,
                               NULL);

    DebugDump(SERIRPPATH,
              ("SerScan: [Cleanup] After CallParent Status = %x\n",
              Status));

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return;
}


NTSTATUS
SerScanQueryInformationFile(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is used to query the end of file information on
    the opened Serial port.  Any other file information request
    is retured with an invalid parameter.

    This routine always returns an end of file of 0.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS              - Success.
    STATUS_INVALID_PARAMETER    - Invalid file information request.
    STATUS_BUFFER_TOO_SMALL     - Buffer too small.

--*/

{
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension;

    Extension = DeviceObject->DeviceExtension;

    Status = SerScanCallParent(Extension,
                               Irp,
                               WAIT,
                               NULL);

    DebugDump(SERIRPPATH,
              ("SerScan: [Cleanup] After CallParent Status = %x\n",
              Status));

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}


NTSTATUS
SerScanSetInformationFile(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is used to set the end of file information on
    the opened Serial port.  Any other file information request
    is retured with an invalid parameter.

    This routine always ignores the actual end of file since
    the query information code always returns an end of file of 0.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS              - Success.
    STATUS_INVALID_PARAMETER    - Invalid file information request.

--*/

{
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension;

    Extension = DeviceObject->DeviceExtension;

    Status = SerScanCallParent(Extension,
                               Irp,
                               WAIT,
                               NULL);

    DebugDump(SERIRPPATH,
              ("SerScan: [Cleanup] After CallParent Status = %x\n",
              Status));

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}

VOID
SerScanUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )

/*++

Routine Description:

    This routine loops through the device list and cleans up after
    each of the devices.

Arguments:

    DriverObject    - Supplies the driver object.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT      CurrentDevice;
    PDEVICE_OBJECT      NextDevice;
    PDEVICE_EXTENSION   Extension;

    DebugDump(SERUNLOAD,
              ("SerScan: In SerUnload\n"));

    CurrentDevice = DriverObject->DeviceObject;
    while (NULL != CurrentDevice){

        Extension = CurrentDevice->DeviceExtension;


        if(NULL != Extension->SymbolicLinkName.Buffer){
            if (Extension->CreatedSymbolicLink) {
                IoDeleteSymbolicLink(&Extension->SymbolicLinkName);

                RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP,
                                       L"Serial Scanners",
                                       Extension->SymbolicLinkName.Buffer);
            } // if (Extension->CreatedSymbolicLink) 

            ExFreePool(Extension->SymbolicLinkName.Buffer);
            Extension->SymbolicLinkName.Buffer = NULL;
        } // if(NULL != Extension->SymbolicLinkName.Buffer)

        if(NULL != Extension->ClassName.Buffer){
            ExFreePool(Extension->ClassName.Buffer);
            Extension->ClassName.Buffer = NULL;
        } // if(NULL != Extension->ClassName.Buffer)

        NextDevice = CurrentDevice->NextDevice;
        IoDeleteDevice(CurrentDevice);

        CurrentDevice = NextDevice;
    } // while (CurrentDevice = DriverObject->DeviceObject)

}

NTSTATUS
SerScanHandleSymbolicLink(
    PDEVICE_OBJECT      DeviceObject,
    PUNICODE_STRING     InterfaceName,
    BOOLEAN             Create
    )
/*++

Routine Description:

Arguments:

    DriverObject    - Supplies the driver object.

Return Value:

    None.

--*/
{

    NTSTATUS           Status;

    Status = STATUS_SUCCESS;

    if (Create) {

        Status=IoRegisterDeviceInterface(
            DeviceObject,
            &GUID_DEVINTERFACE_IMAGE,
            NULL,
            InterfaceName
            );

        DebugDump(SERINITDEV,("Called IoRegisterDeviceInterface . Returned=0x%X\n",Status));


        if (NT_SUCCESS(Status)) {

            IoSetDeviceInterfaceState(
                InterfaceName,
                TRUE
                );

            DebugDump(SERINITDEV,("Called IoSetDeviceInterfaceState(TRUE) . \n"));

        }

    } else {

        if (InterfaceName->Buffer != NULL) {

            IoSetDeviceInterfaceState(
                InterfaceName,
                FALSE
                );

            DebugDump(SERINITDEV,("Called IoSetDeviceInterfaceState(FALSE) . \n"));

            RtlFreeUnicodeString(
                InterfaceName
                );

            InterfaceName->Buffer = NULL;
        }

    }

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\serscan\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   byronc, coopp, keisuket, vlads
#
#Date:
#   2-Feb-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     WIA kernel mode driver
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=serscan
TARGETTYPE=DRIVER
TARGETPATH=$(OBJ_DIR)

SOURCES=..\serscan.c   \
        ..\util.c      \
        ..\pnppwr.c    \
        ..\open.c      \
        ..\rdwr.c      \
        ..\ioctl.c     \
        ..\serlog.mc   \
        ..\serscan.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\serscan\serscan.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name :

    serscan.h

Abstract:

    Type definitions and data for the serial imaging driver.

Author:


Revision History:

--*/

#include "wdm.h"
//#include <ntddk.h>
#include <ntddser.h>

#if DBG
#define SERALWAYS             ((ULONG)0x00000000)
#define SERCONFIG             ((ULONG)0x00000001)
#define SERUNLOAD             ((ULONG)0x00000002)
#define SERINITDEV            ((ULONG)0x00000004)
#define SERIRPPATH            ((ULONG)0x00000008)
#define SERSTARTER            ((ULONG)0x00000010)
#define SERPUSHER             ((ULONG)0x00000020)
#define SERERRORS             ((ULONG)0x00000040)
#define SERTHREAD             ((ULONG)0x00000080)
#define SERDEFERED            ((ULONG)0x00000100)

extern ULONG SerScanDebugLevel;

#define DebugDump(LEVEL,STRING) \
        do { \
            ULONG _level = (LEVEL); \
            if ((_level == SERALWAYS)||(SerScanDebugLevel & _level)) { \
                DbgPrint ("SERSCAN.SYS:"); \
                DbgPrint STRING; \
            } \
        } while (0)

//
// macro for doing INT 3 (or non-x86 equivalent)
//

#if _X86_
#define DEBUG_BREAKPOINT() _asm int 3;
#else
#define DEBUG_BREAKPOINT() DbgBreakPoint()
#endif

#else
#define DEBUG_BREAKPOINT()
#define DebugDump(LEVEL,STRING) do {NOTHING;} while (0)
#endif


#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'SerC')
#endif

//
// For the above directory, the serial port will
// use the following name as the suffix of the serial
// ports for that directory.  It will also append
// a number onto the end of the name.  That number
// will start at 1.
//
#define SERSCAN_LINK_NAME L"SERSCAN"

//
// This is the  class name.
//
#define SERSCAN_NT_SUFFIX L"serscan"


#define SERIAL_DATA_OFFSET 0
#define SERIAL_STATUS_OFFSET 1
#define SERIAL_CONTROL_OFFSET 2
#define SERIAL_REGISTER_SPAN 3

typedef struct _DEVICE_EXTENSION {

    //
    // Points to the device object that contains
    // this device extension.
    //
    PDEVICE_OBJECT DeviceObject;

    //
    //
    //
    PDEVICE_OBJECT Pdo;

    //
    // Points to the lower in stack  device object that this device is
    // connected to.
    //
    PDEVICE_OBJECT LowerDevice;

    //
    // To connect to lower object when opening
    //
    PDEVICE_OBJECT   AttachedDeviceObject;
    PFILE_OBJECT     AttachedFileObject;

    //
    //
    //
    PVOID          SerclassContext;
    ULONG          HardwareCapabilities;

    //
    // Records whether we actually created the symbolic link name
    // at driver load time.  If we didn't create it, we won't try
    // to distroy it when we unload.
    //
    BOOLEAN         CreatedSymbolicLink;

    //
    // This points to the symbolic link name that was
    // linked to the actual nt device name.
    //
    UNICODE_STRING  SymbolicLinkName;

    //
    // This points to the class name used to create the
    // device and the symbolic link.  We carry this
    // around for a short while...
    UNICODE_STRING  ClassName;

    //
    //
    //
    UNICODE_STRING  InterfaceNameString;


    //
    // This tells us whether we are in a passthrough
    // or filtering mode.
    BOOLEAN         PassThrough;

    //
    // Number of opens on this device
    //
    ULONG          OpenCount;
    //
    // Access control
    //
    // ERESOURCE       Resource;
    FAST_MUTEX      Mutex;

    KSPIN_LOCK      SpinLock;

    //
    // Life span control
    //
    LONG            ReferenceCount;
    BOOLEAN         Removing;

    KEVENT          RemoveEvent;
    KEVENT          PdoStartEvent;

    //KEVENT          PendingIoEvent;
    //ULONG           PendingIoCount;

    DEVICE_POWER_STATE  SystemPowerStateMap[PowerSystemMaximum];

    SYSTEM_POWER_STATE SystemWake;
    DEVICE_POWER_STATE DeviceWake;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Bit Definitions in the status register.
//

#define SER_STATUS_NOT_ERROR   0x08  //not error on device
#define SER_STATUS_SLCT        0x10  //device is selected (on-line)
#define SER_STATUS_PE          0x20  //paper empty
#define SER_STATUS_NOT_ACK     0x40  //not acknowledge (data transfer was not ok)
#define SER_STATUS_NOT_BUSY    0x80  //operation in progress

//
//  Bit Definitions in the control register.
//

#define SER_CONTROL_STROBE      0x01 //to read or write data
#define SER_CONTROL_AUTOFD      0x02 //to autofeed continuous form paper
#define SER_CONTROL_NOT_INIT    0x04 //begin an initialization routine
#define SER_CONTROL_SLIN        0x08 //to select the device
#define SER_CONTROL_IRQ_ENB     0x10 //to enable interrupts
#define SER_CONTROL_DIR         0x20 //direction = read
#define SER_CONTROL_WR_CONTROL  0xc0 //the 2 highest bits of the control
                                     // register must be 1
#define StoreData(RegisterBase,DataByte)                            \
{                                                                   \
    PUCHAR _Address = RegisterBase;                                 \
    UCHAR _Control;                                                 \
    _Control = GetControl(_Address);                                \
    ASSERT(!(_Control & SER_CONTROL_STROBE));                       \
    StoreControl(                                                   \
        _Address,                                                   \
        (UCHAR)(_Control & ~(SER_CONTROL_STROBE | SER_CONTROL_DIR)) \
        );                                                          \
    WRITE_PORT_UCHAR(                                               \
        _Address+SERIAL_DATA_OFFSET,                              \
        (UCHAR)DataByte                                             \
        );                                                          \
    KeStallExecutionProcessor((ULONG)1);                            \
    StoreControl(                                                   \
        _Address,                                                   \
        (UCHAR)((_Control | SER_CONTROL_STROBE) & ~SER_CONTROL_DIR) \
        );                                                          \
    KeStallExecutionProcessor((ULONG)1);                            \
    StoreControl(                                                   \
        _Address,                                                   \
        (UCHAR)(_Control & ~(SER_CONTROL_STROBE | SER_CONTROL_DIR)) \
        );                                                          \
    KeStallExecutionProcessor((ULONG)1);                            \
    StoreControl(                                                   \
        _Address,                                                   \
        (UCHAR)_Control                                             \
        );                                                          \
}

#define GetControl(RegisterBase) \
    (READ_PORT_UCHAR((RegisterBase)+SERIAL_CONTROL_OFFSET))

#define StoreControl(RegisterBase,ControlByte)  \
{                                               \
    WRITE_PORT_UCHAR(                           \
        (RegisterBase)+SERIAL_CONTROL_OFFSET, \
        (UCHAR)ControlByte                      \
        );                                      \
}

#define GetStatus(RegisterBase) \
    (READ_PORT_UCHAR((RegisterBase)+SERIAL_STATUS_OFFSET))


//
// Macros
//

//
// Prototypes
//
NTSTATUS
SerScanCreateOpen(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
SerScanClose(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
SerScanCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
SerScanReadWrite(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
SerScanDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
SerScanQueryInformationFile(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
SerScanSetInformationFile(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
SerScanPower(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    );

VOID
SerScanUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );

NTSTATUS
SerScanHandleSymbolicLink(
    PDEVICE_OBJECT      DeviceObject,
    PUNICODE_STRING     InterfaceName,
    BOOLEAN             Create
    );

NTSTATUS
SerScanPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

NTSTATUS
SerScanAddDevice(
    IN PDRIVER_OBJECT pDriverObject,
    IN PDEVICE_OBJECT pPhysicalDeviceObject
    );

NTSTATUS
SerScanPnp (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

BOOLEAN
SerScanMakeNames(
    IN  ULONG           SerialPortNumber,
    OUT PUNICODE_STRING ClassName,
    OUT PUNICODE_STRING LinkName
    );

VOID
SerScanLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  PHYSICAL_ADDRESS    P1,
    IN  PHYSICAL_ADDRESS    P2,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    );

NTSTATUS
SerScanSynchCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PKEVENT          Event
    );

NTSTATUS
SerScanCompleteIrp(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

#define WAIT        1
#define NO_WAIT     0

NTSTATUS
SerScanCallParent(
    IN PDEVICE_EXTENSION        Extension,
    IN PIRP                     Irp,
    IN BOOLEAN                  Wait,
    IN PIO_COMPLETION_ROUTINE   CompletionRoutine
    );

NTSTATUS
SerScanQueueIORequest(
    IN PDEVICE_EXTENSION Extension,
    IN PIRP              Irp
    );

VOID
SSIncrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
    );

LONG
SSDecrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
    );

NTSTATUS
WaitForLowerDriverToCompleteIrp(
   PDEVICE_OBJECT    TargetDeviceObject,
   PIRP              Irp,
   PKEVENT           Event
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\serscan\util.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module contains the code for a serial imaging devices driver
    miscellaneous utility functions


Author:

    Vlad Sadovsky    vlads              10-April-1998

Environment:

    Kernel mode

Revision History :

    vlads           04/10/1998      Created first draft

--*/

#include "serscan.h"
#include "serlog.h"

#if DBG
extern ULONG SerScanDebugLevel;
#endif



NTSTATUS
SerScanSynchCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PKEVENT          Event
    )

/*++

Routine Description:

    This routine is for use with synchronous IRP processing.
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DriverObject - Pointer to driver object created by system.

    Irp          - Irp that just completed

    Event        - Event we'll signal to say Irp is done

Return Value:

    None.

--*/

{

    KeSetEvent((PKEVENT) Event, 0, FALSE);

    return (STATUS_MORE_PROCESSING_REQUIRED);

}

NTSTATUS
SerScanCompleteIrp(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )

/*++

Routine Description:

    This routine is for use with synchronous IRP processing.
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DriverObject - Pointer to driver object created by system.

    Irp          - Irp that just completed

    Event        - Event we'll signal to say Irp is done

Return Value:

    None.

--*/

{

    NTSTATUS    Status;

    //
    // WORKWORK  Do any post IO processing here...
    //

    if (Irp->PendingReturned) {

        IoMarkIrpPending (Irp);
    }

    Status = Irp->IoStatus.Status;

    return (Status);

}

NTSTATUS
SerScanCallParent(
    IN PDEVICE_EXTENSION        Extension,
    IN PIRP                     pIrp,
    IN BOOLEAN                  Wait,
    IN PIO_COMPLETION_ROUTINE   CompletionRoutine
    )

/*++

Routine Description:

    This routine will call the next driver in the WDM chain

Arguments:

    Extension    - Device Extension.

    Irp          - Irp to call parent with.

Return Value:

    NTSTATUS.

--*/

{
    PIO_STACK_LOCATION              pIrpStack;
    PIO_STACK_LOCATION              pNextIrpStack;
    KEVENT                          Event;
    PVOID                           Context;
    NTSTATUS                        Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    Context = NULL;

    //
    // Prepare to call down to the parent with the I/O Request...
    //

    pNextIrpStack = IoGetNextIrpStackLocation(pIrp);
    pNextIrpStack->MajorFunction = pIrpStack->MajorFunction;
    pNextIrpStack->MinorFunction = pIrpStack->MinorFunction;

    RtlCopyMemory(&pNextIrpStack->Parameters,
                  &pIrpStack->Parameters,
                  sizeof(pIrpStack->Parameters.Others));

    if (Wait) {

        KeInitializeEvent(&Event, NotificationEvent, FALSE);

        CompletionRoutine = SerScanSynchCompletionRoutine;
        Context = (PVOID)&Event;

    }

    IoSetCompletionRoutine(
        pIrp,
        CompletionRoutine,
        Context,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Call down to our parent
    //

    Status = IoCallDriver(Extension->LowerDevice, pIrp);

    if (Wait && Status == STATUS_PENDING) {

        //
        // Still pending, wait for the IRP to complete
        //

        KeWaitForSingleObject(&Event, Suspended, KernelMode, FALSE, NULL);

        Status = pIrp->IoStatus.Status;

    }

    return Status;
}



VOID
SerScanLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  PHYSICAL_ADDRESS    P1,
    IN  PHYSICAL_ADDRESS    P2,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DriverObject        - Supplies a pointer to the driver object for the
                            device.

    DeviceObject        - Supplies a pointer to the device object associated
                            with the device that had the error, early in
                            initialization, one may not yet exist.

    P1,P2               - Supplies the physical addresses for the controller
                            ports involved with the error if they are available
                            and puts them through as dump data.

    SequenceNumber      - Supplies a ulong value that is unique to an IRP over
                            the life of the irp in this driver - 0 generally
                            means an error not associated with an irp.

    MajorFunctionCode   - Supplies the major function code of the irp if there
                            is an error associated with it.

    RetryCount          - Supplies the number of times a particular operation
                            has been retried.

    UniqueErrorValue    - Supplies a unique long word that identifies the
                            particular call to this function.

    FinalStatus         - Supplies the final status given to the irp that was
                            associated with this error.  If this log entry is
                            being made during one of the retries this value
                            will be STATUS_SUCCESS.

    SpecificIOStatus    - Supplies the IO status for this particular error.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET    ErrorLogEntry;
    PVOID                   ObjectToUse;
    SHORT                   DumpToAllocate;

    if (ARGUMENT_PRESENT(DeviceObject)) {

        ObjectToUse = DeviceObject;

    } else {

        ObjectToUse = DriverObject;

    }

    DumpToAllocate = 0;

    if (P1.LowPart != 0 || P1.HighPart != 0) {
        DumpToAllocate = (SHORT) sizeof(PHYSICAL_ADDRESS);
    }

    if (P2.LowPart != 0 || P2.HighPart != 0) {
        DumpToAllocate += (SHORT) sizeof(PHYSICAL_ADDRESS);
    }

    ErrorLogEntry = IoAllocateErrorLogEntry(ObjectToUse,
            (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) + DumpToAllocate));

    if (!ErrorLogEntry) {
        return;
    }

    ErrorLogEntry->ErrorCode         = SpecificIOStatus;
    ErrorLogEntry->SequenceNumber    = SequenceNumber;
    ErrorLogEntry->MajorFunctionCode = MajorFunctionCode;
    ErrorLogEntry->RetryCount        = RetryCount;
    ErrorLogEntry->UniqueErrorValue  = UniqueErrorValue;
    ErrorLogEntry->FinalStatus       = FinalStatus;
    ErrorLogEntry->DumpDataSize      = DumpToAllocate;

    if (DumpToAllocate) {

        RtlCopyMemory((PUCHAR)ErrorLogEntry->DumpData, &P1, sizeof(PHYSICAL_ADDRESS));

        if (DumpToAllocate > sizeof(PHYSICAL_ADDRESS)) {

            RtlCopyMemory(((PUCHAR) ErrorLogEntry->DumpData) +
                          sizeof(PHYSICAL_ADDRESS), &P2,
                          sizeof(PHYSICAL_ADDRESS));
        }
    }

    IoWriteErrorLogEntry(ErrorLogEntry);
}


NTSTATUS
SerScanPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

    DriverObject    - Supplies the driver object.

Return Value:

    None.

--*/
{

    PDEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    PDEVICE_OBJECT    AttachedDevice=Extension->AttachedDeviceObject;

    if (AttachedDevice != NULL) {

        //IoCopyCurrentIrpStackLocationToNext( Irp );

        IoSkipCurrentIrpStackLocation(Irp);

        return IoCallDriver(
                   AttachedDevice,
                   Irp
                   );
    } else {

        Irp->IoStatus.Status = STATUS_PORT_DISCONNECTED;
        Irp->IoStatus.Information=0L;

        IoCompleteRequest(
            Irp,
            IO_NO_INCREMENT
            );

        return STATUS_PORT_DISCONNECTED;

    }

}



VOID
RemoveReferenceAndCompleteRequest(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp,
    NTSTATUS          StatusToReturn
    )

{

    PDEVICE_EXTENSION    Extension=(PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    LONG                 NewReferenceCount;

    NewReferenceCount=InterlockedDecrement(&Extension->ReferenceCount);

    if (NewReferenceCount == 0) {
        //
        //  device is being removed, set event
        //

        KeSetEvent(
            &Extension->RemoveEvent,
            0,
            FALSE
            );

    }

    Irp->IoStatus.Status = StatusToReturn;

    IoCompleteRequest(
        Irp,
        IO_SERIAL_INCREMENT
        );

    return;


}

NTSTATUS
CheckStateAndAddReference(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    )
{

    PDEVICE_EXTENSION    Extension=(PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    KIRQL                OldIrql;

    InterlockedIncrement(&Extension->ReferenceCount);

    if (Extension->Removing) {
        //
        //  driver not accepting requests already
        //
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

        if (irpSp->MajorFunction == IRP_MJ_POWER) {

            PoStartNextPowerIrp(Irp);
        }

        RemoveReferenceAndCompleteRequest(
            DeviceObject,
            Irp,
            STATUS_UNSUCCESSFUL
            );

        return STATUS_UNSUCCESSFUL;

    }

    //InterlockedIncrement(&Extension->PendingIoCount);

    return STATUS_SUCCESS;

}

VOID
RemoveReference(
    PDEVICE_OBJECT    DeviceObject
    )

{
    PDEVICE_EXTENSION    Extension=(PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    LONG                 NewReferenceCount;

    NewReferenceCount=InterlockedDecrement(&Extension->ReferenceCount);

    if (NewReferenceCount == 0) {
        //
        //  device is being removed, set event
        //
        KeSetEvent(
            &Extension->RemoveEvent,
            0,
            FALSE
            );

    }

    return;

}


NTSTATUS
WaitForLowerDriverToCompleteIrp(
   PDEVICE_OBJECT    TargetDeviceObject,
   PIRP              Irp,
   PKEVENT           Event
   )
{
    NTSTATUS         Status;

    KeResetEvent(Event);

    IoSetCompletionRoutine(
                 Irp,
                 SerScanSynchCompletionRoutine,
                 Event,
                 TRUE,
                 TRUE,
                 TRUE
                 );

    Status = IoCallDriver(TargetDeviceObject, Irp);

    if (Status == STATUS_PENDING) {

         KeWaitForSingleObject(
             Event,
             Executive,
             KernelMode,
             FALSE,
             NULL
             );
    }

    return Irp->IoStatus.Status;

}

#ifdef DEAD_CODE

VOID
SSIncrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
    )
/*++

Routine Description:

    Performs interlocked increment of pending i/o counter.

Arguments:

    Device Object

Return Value:

    None

--*/
{

    PDEVICE_EXTENSION               Extension;

    Extension = (PDEVICE_EXTENSION)(pDeviceObject -> DeviceExtension);

    InterlockedIncrement(&Extension -> PendingIoCount);
}


LONG
SSDecrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
    )
/*++

Routine Description:

    Performs interlocked decrement of i/o counter and when it eaches zero
    initiates device object destruction

Arguments:

    Device Object

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION           Extension;
    LONG                        ioCount;

    Extension = (PDEVICE_EXTENSION)(pDeviceObject -> DeviceExtension);

    ioCount = InterlockedDecrement(&Extension -> PendingIoCount);

    if (0 == ioCount) {
        KeSetEvent(&Extension -> PendingIoEvent,1,FALSE);
    }

    return ioCount;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\usbscan\debug.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    debug.c

Abstract:

    Common code for debugging.

Author: 

    Keisuke Tsuchida (KeisukeT)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//
// Includes
//

#include "stddef.h"
#include "wdm.h"
#include "debug.h"

//
// Globals
//

ULONG   DebugTraceLevel = MIN_TRACE | DEBUG_FLAG_DISABLE;
// ULONG  DebugTraceLevel = MAX_TRACE | DEBUG_FLAG_DISABLE | TRACE_PROC_ENTER | TRACE_PROC_LEAVE;
LONG    AllocateCount = 0;
ULONG   DebugDumpMax    = MAX_DUMPSIZE;

PVOID
MyAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG     ulNumberOfBytes
)
/*++

Routine Description:

    Wrapper for pool allocation. Use tag to avoid heap corruption.

Arguments:

    PoolType - type of pool memory to allocate
    ulNumberOfBytes - number of bytes to allocate

Return Value:

    Pointer to the allocated memory

--*/
{
    PVOID pvRet;

    DebugTrace(TRACE_PROC_ENTER,("MyAllocatePool: Enter.. Size = %d\n", ulNumberOfBytes));

    pvRet = ExAllocatePoolWithTag(PoolType,
                                  ulNumberOfBytes,
                                  NAME_POOLTAG);

#if DBG
    if(NULL == pvRet){
        DebugTrace(TRACE_ERROR,("MyAllocatePool: ERROR!! Cannot allocate pool.\n"));
    } else {
        if(++AllocateCount > MAXNUM_POOL){
            DebugTrace(TRACE_WARNING,("MyAllocatePool: WARNING!! Allocate called %dtimes more than Free\n", MAXNUM_POOL));
        }
        DebugTrace(TRACE_STATUS,("MyAllocatePool: Count = %d\n", AllocateCount));
    }
#endif // DBG

    DebugTrace(TRACE_PROC_LEAVE,("MyAllocatePool: Leaving.. pvRet = %x\n", pvRet));
    return pvRet;
}


VOID
MyFreePool(
    IN PVOID     pvAddress
)
/*++

Routine Description:

    Wrapper for pool free. Check tag to avoid heap corruption

Arguments:

    pvAddress - Pointer to the allocated memory

Return Value:

    none.

--*/
{

    DebugTrace(TRACE_PROC_ENTER,("USFreePool: Enter..\n"));

#if DBG
    {
        ULONG ulTag;
    
        ulTag = *((PULONG)pvAddress-1);
//        if( (NAME_POOLTAG == ulTag) || (DebugTraceLevel & TRACE_IGNORE_TAG) ){
        if(NAME_POOLTAG == ulTag){
            if(--AllocateCount < 0){
                DebugTrace(TRACE_WARNING,("MyFreePool: Warning!! Free called more than Allocate.\n"));
            }
        } else {
            DebugTrace(TRACE_WARNING,("MyFreePool: WARNING!! tag = %c%c%c%c\n",
                                        ((PUCHAR)&ulTag)[0],
                                        ((PUCHAR)&ulTag)[1],
                                        ((PUCHAR)&ulTag)[2],
                                        ((PUCHAR)&ulTag)[3]  ));
        }
    }
#endif

    ExFreePool(pvAddress);

    DebugTrace(TRACE_PROC_LEAVE,("MyFreePool: Leaving.. Return = NONE\n"));
}


#if DBG
VOID
MyDebugInit(
    IN  PUNICODE_STRING pRegistryPath
)
/*++

Routine Description:

    Read DebugTraceLevel key from driver's registry if exists.

Arguments:

    pRegistryPath   -   pointer to a unicode string representing the path
                        to driver-specific key in the registry

Return Value:

    none.

--*/
{

    HANDLE                          hDriverRegistry;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    UNICODE_STRING                  unicodeKeyName;
    ULONG                           DataSize;
    PKEY_VALUE_PARTIAL_INFORMATION  pValueInfo;
    NTSTATUS                        Status;
    
    DebugTrace(TRACE_PROC_ENTER,("MyDebugInit: Enter... \n"));
    
    //
    // Initialize local variables.
    //
    
    Status          = STATUS_SUCCESS;
    hDriverRegistry = NULL;
    pValueInfo      = NULL;
    DataSize        = 0;

    //
    // Initialize object attribute and open registry key.
    //
    
    RtlZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));
    InitializeObjectAttributes(&ObjectAttributes,
                               pRegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    
    Status = ZwOpenKey(&hDriverRegistry,
                       KEY_READ,
                       &ObjectAttributes);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR,("MyDebugInit: ERROR!! Can't open driver registry key.\n"));
        goto MyDebugInit_return;
    }
    
    //
    // Read "DebugTraceLevel" key.
    //

    DebugTrace(TRACE_CRITICAL,("MyDebugInit: Query %wZ\\%ws.\n", pRegistryPath, REG_DEBUGLEVEL));

    //
    // Query required size.
    //
    
    RtlInitUnicodeString(&unicodeKeyName, REG_DEBUGLEVEL);
    Status = ZwQueryValueKey(hDriverRegistry,
                             &unicodeKeyName,
                             KeyValuePartialInformation,
                             NULL,
                             0,
                             &DataSize);
    if( (Status != STATUS_BUFFER_OVERFLOW)
     && (Status != STATUS_BUFFER_TOO_SMALL)
     && (Status != STATUS_SUCCESS) )
    {
        if(Status == STATUS_OBJECT_NAME_NOT_FOUND){
            DebugTrace(TRACE_STATUS,("MyDebugInit: DebugTraceLevel doesn't exist. Use default(0x%x).\n", DebugTraceLevel));
        } else {
            DebugTrace(TRACE_ERROR,("MyDebugInit: ERROR!! ZwQueryValueKey failed. Status=0x%x\n", Status));
        }
        goto MyDebugInit_return;
    }
    
    //
    // Check size of data.
    //
    
    if (MAX_TEMPBUF < DataSize) {
        DebugTrace(TRACE_ERROR, ("MyDebugInit: ERROR!! DataSize (0x%x) is too big.\n", DataSize));
        goto MyDebugInit_return;
    }

    if (0 == DataSize) {
        DebugTrace(TRACE_ERROR, ("MyDebugInit: ERROR!! Cannot retrieve required data size.\n"));
        goto MyDebugInit_return;
    }

    //
    // Allocate memory for temp buffer. size +2 for NULL.
    //

    pValueInfo = MyAllocatePool(NonPagedPool, DataSize+2);
    if(NULL == pValueInfo){
        DebugTrace(TRACE_CRITICAL, ("MyDebugInit: ERROR!! Buffer allocate failed.\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto MyDebugInit_return;
    }
    RtlZeroMemory(pValueInfo, DataSize+2);

    //
    // Query specified value.
    //
    
    Status = ZwQueryValueKey(hDriverRegistry,
                             &unicodeKeyName,
                             KeyValuePartialInformation,
                             pValueInfo,
                             DataSize,
                             &DataSize);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR, ("MyDebugInit: ERROR!! ZwQueryValueKey failed.\n"));
        goto MyDebugInit_return;
    }
    
    //
    // Set DebugTraceLevel.
    //
    
    DebugTraceLevel = *((PULONG)pValueInfo->Data);
    DebugTrace(TRACE_CRITICAL, ("MyDebugInit: Reg-key found. DebugTraceLevel=0x%x.\n", *((PULONG)pValueInfo->Data)));

MyDebugInit_return:

    //
    // Clean up.
    //
    
    if(pValueInfo){
        MyFreePool(pValueInfo);
    }
    
    if(NULL != hDriverRegistry){
        ZwClose(hDriverRegistry);
    }

    DebugTrace(TRACE_PROC_LEAVE,("MyDebugInit: Leaving... Status=0x%x, Ret=VOID.\n", Status));
    return;
}

VOID
MyDumpMemory(
    PUCHAR  pDumpBuffer,
    ULONG   dwSize,
    BOOLEAN bRead
)
{
    NTSTATUS    Status;
    ULONG       ulCounter;
    ULONG       ulMaxSize;

    //
    // Check the flag first.
    //

    if(bRead){
        if(!(DebugTraceLevel & TRACE_FLAG_DUMP_READ)){
            return;
        }
    } else { // if(bRead)
        if(!(DebugTraceLevel & TRACE_FLAG_DUMP_WRITE)){
            return;
        }
    } // if(bRead)

    DebugTrace(TRACE_PROC_ENTER,("MyDebugDump: Enter... \n"));
        
    //
    // Initialize local.
    //
        
    Status          = STATUS_SUCCESS;
    ulCounter       = 0;
    ulMaxSize       = DebugDumpMax;
    
    //
    // Check the arguments.
    //
        
    if(NULL == pDumpBuffer){
        DebugTrace(TRACE_WARNING,("MyDebugDump: WARNING!! pDumpBuffer = NULL \n"));
        Status = STATUS_INVALID_PARAMETER_1;
        goto MyDumpMemory_return;
    }

    if(0 == dwSize){
        DebugTrace(TRACE_STATUS,("MyDebugDump: WARNING!! dwSize = 0 \n"));
        Status = STATUS_INVALID_PARAMETER_2;
        goto MyDumpMemory_return;
    }

    if(bRead){
        DebugTrace(TRACE_ERROR,("MyDebugDump: Received buffer. Size=0x%x.\n", dwSize));
    } else {
        DebugTrace(TRACE_ERROR,("MyDebugDump: Passing buffer. Size=0x%x.\n", dwSize));
    }

/*
    //
    // Probe the buffer.
    //

    try {
        ProbeForRead(pDumpBuffer,
                     dwSize,
                     sizeof(UCHAR));
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        DebugTrace(TRACE_ERROR,("MyDebugDump: Buffer pointer (0x%x) is invalid. Status=0x%x\n", pDumpBuffer, Status));
        goto MyDumpMemory_return;
    } // except
*/
    //
    // Max dump size = 1k;
    //
    
    ulMaxSize = min(ulMaxSize , dwSize);

    //
    // Dump the buffer.
    //
    
    for(ulCounter = 0; ulCounter < ulMaxSize; ulCounter++){
        if(0 == (ulCounter & 0xfF)){
            DbgPrint("\n");
            DbgPrint(NAME_DRIVER);
            DbgPrint("           +0 +1 +2 +3 +4 +5 +6 +7   +8 +9 +a +b +c +d +e +f\n");
            DbgPrint(NAME_DRIVER);
            DbgPrint("------------------------------------------------------------\n");
        }

        if(0 == (ulCounter & 0xf)){
            DbgPrint(NAME_DRIVER);
            DbgPrint("%p :", pDumpBuffer+ulCounter);
        }

        DbgPrint(" %02x", *(pDumpBuffer+ulCounter));

        if(0x7 == (ulCounter & 0xf)){
            DbgPrint(" -");
        }

        if(0xf == (ulCounter & 0xf)){
            DbgPrint("\n");
        }
    }

    DbgPrint("\n");
    DbgPrint(NAME_DRIVER);
    DbgPrint("------------------------------------------------------------\n\n");

MyDumpMemory_return:
    DebugTrace(TRACE_PROC_LEAVE,("MyDebugDump: Leaving... Status=0x%x, Ret=VOID.\n", Status));
    return;

} // MyDumpMemory(

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\serscan\chicago\serlog.h ===
#ifndef _SERLOG_
#define _SERLOG_

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: SER_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Not enough memory was available to allocate internal storage needed for the device %1.
//
#define SER_INSUFFICIENT_RESOURCES       ((NTSTATUS)0xC0040001L)

//
// MessageId: SER_NO_SYMLINK_CREATED
//
// MessageText:
//
//  Unable to create the symbolic link for %1.
//
#define SER_NO_SYMLINK_CREATED           ((NTSTATUS)0x80040002L)

//
// MessageId: SER_NO_DEVICE_MAP_CREATED
//
// MessageText:
//
//  Unable to create the device map entry for %1.
//
#define SER_NO_DEVICE_MAP_CREATED        ((NTSTATUS)0x80040003L)

//
// MessageId: SER_CANT_FIND_PORT_DRIVER
//
// MessageText:
//
//  Unable to get device object pointer for port object.
//
#define SER_CANT_FIND_PORT_DRIVER        ((NTSTATUS)0xC0040004L)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\usbscan\ioctl.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ioctl.c

Abstract:

Author:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include <stdio.h>
#include <stddef.h>
#include <wdm.h>
#include <usbscan.h>
#include "usbd_api.h"
#include "private.h"
//#include "missdef.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USDeviceControl)
#pragma alloc_text(PAGE, USReadWriteRegisters)
#pragma alloc_text(PAGE, USCancelPipe)
#pragma alloc_text(PAGE, USAbortResetPipe)
#endif

#ifdef _WIN64
BOOLEAN
IoIs32bitProcess(
    IN PIRP Irp
    );
#endif // _WIN64

NTSTATUS
USDeviceControl(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
/*++

Routine Description:

Arguments:
    pDeviceObject - Device object for a device.
    pIrp          - DEVICE IOCTL irp

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    PIO_STACK_LOCATION          pIrpStack;
    PIO_STACK_LOCATION          pNextIrpStack;
    PFILE_OBJECT                fileObject;
    PUSBSCAN_FILE_CONTEXT       pFileContext;
    ULONG                       IoControlCode;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    NTSTATUS                    Status;
    PDRV_VERSION                pVersion;
    PDEVICE_DESCRIPTOR          pDesc;
    PUSBSCAN_GET_DESCRIPTOR     pGetDesc;
    PUSBSCAN_PIPE_CONFIGURATION pPipeConfig;
    PVOID                       pBuffer;

    IO_BLOCK                    LocalIoBlock;
    IO_BLOCK_EX                 LocalIoBlockEx;
    PIO_BLOCK                   pIoBlock;
    PIO_BLOCK_EX                pIoBlockEx;

    ULONG                       InLength;
    ULONG                       OutLength;
    BOOLEAN                     fRead = FALSE;
    BOOLEAN                     fAbort = TRUE;
    ULONG                       i;
    PURB                        pUrb;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USDeviceControl: Enter...\n"));

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("USDeviceControl: Leaving.. Status = %x.\n", Status));
        return Status;
    }

    //
    // Indicates I/O processing increase.
    //

    USIncrementIoCount( pDeviceObject );

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    if (FALSE == pde -> AcceptingRequests) {
        DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! IOCTL issued after device stopped/removed!\n"));
        Status = STATUS_DELETE_PENDING;
        pIrp -> IoStatus.Status = Status;
        pIrp -> IoStatus.Information = 0;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        goto USDeviceControl_return;
    }

    //
    // Check device power state.
    //

    if (PowerDeviceD0 != pde -> CurrentDevicePowerState) {
        DebugTrace(TRACE_WARNING,("USDeviceControl: WARNING!! Device is suspended.\n"));
        Status = STATUS_DELETE_PENDING;
        pIrp -> IoStatus.Status = Status;
        pIrp -> IoStatus.Information = 0;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        goto USDeviceControl_return;
    }


    pIrpStack       = IoGetCurrentIrpStackLocation( pIrp );
    pNextIrpStack   = IoGetNextIrpStackLocation( pIrp );
    IoControlCode   = pIrpStack->Parameters.DeviceIoControl.IoControlCode;

    InLength        = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
    OutLength       = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    pBuffer         = pIrp -> AssociatedIrp.SystemBuffer;

    fileObject      = pIrpStack->FileObject;
    pFileContext    = fileObject->FsContext;

    DebugTrace(TRACE_STATUS,("USDeviceControl: Control code 0x%x = ", IoControlCode));

    switch (IoControlCode) {

        case IOCTL_GET_VERSION:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_GET_VERSION\n"));

            if (OutLength < sizeof(DRV_VERSION) ) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Buffer(0x%x) too small(<0x%x)\n", OutLength, sizeof(DRV_VERSION)));
                DEBUG_BREAKPOINT();
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            pVersion            = (PDRV_VERSION)pBuffer;
            pVersion->major     = 1;
            pVersion->minor     = 0;
            pVersion->internal  = 0;

            pIrp -> IoStatus.Information = sizeof(DRV_VERSION);

            Status = STATUS_SUCCESS;
            break;

        case IOCTL_CANCEL_IO:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_CANCEL_IO\n"));
            fAbort = TRUE;

            //
            // Falling through to the next case, this is intentional. We want to reset pipe when
            // cancel requested
            //

        case IOCTL_RESET_PIPE:
            if(IOCTL_RESET_PIPE == IoControlCode){
                DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_RESET_PIPE\n"));
                fAbort = FALSE;
            }

            //
            // Validate buffer size
            //

            if (InLength < sizeof(PIPE_TYPE) ) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Pipe type buffer (0x%x bytes) too small\n" ,InLength));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            Status = USCancelPipe(pDeviceObject,
                                  pIrp,
                                  *(PIPE_TYPE*)pBuffer,
                                  fAbort);
            break;

        case IOCTL_WAIT_ON_DEVICE_EVENT:
        {
            ULONG   Index;
            ULONG   Timeout;
            PULONG  pTimeout;


            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_WAIT_ON_DEVICE_EVENT\n"));

            Index = USGetPipeIndexToUse(pDeviceObject,
                                        pIrp,
                                        pde -> IndexInterrupt);

            if (OutLength < pde -> PipeInfo[Index].MaximumPacketSize) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! User buffer(0x%x) too small(<)\n"
                                        , OutLength
                                        , pde -> PipeInfo[Index].MaximumPacketSize));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Copy timeout value from file context.
            //

            Timeout = pFileContext->TimeoutEvent;

            //
            // If timeout value is 0, then never timeout.
            //

            if(0 == Timeout){
                pTimeout = NULL;
            } else {
                DebugTrace(TRACE_STATUS,("USDeviceControl: Timeout is set to 0x%x sec.\n", Timeout));
                pTimeout = &Timeout;
            }

            Status = USTransfer(pDeviceObject,
                                pIrp,
                                Index,
                                pIrp -> AssociatedIrp.SystemBuffer,
                                NULL,
                                pde  -> PipeInfo[Index].MaximumPacketSize,
                                pTimeout);

            //
            // IRP should be completed in USTransfer or its completion routine.
            //

            goto USDeviceControl_return;
        }

        case IOCTL_READ_REGISTERS:
            fRead = TRUE;
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_READ_REGISTERS\n"));

        case IOCTL_WRITE_REGISTERS:{

            if (IOCTL_WRITE_REGISTERS == IoControlCode) {
                DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_WRITE_REGISTERS\n"));
                fRead = FALSE;
            }
#ifdef _WIN64
            
            if(IoIs32bitProcess(pIrp)){
                PIO_BLOCK_32    pIoBlock32;

                if (InLength < sizeof(IO_BLOCK_32) ) {
                    DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Invalid input 32bit buffer size(0x%x<0x%x)\n"
                                            , InLength,
                                            sizeof(IO_BLOCK_32)));
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                // Copy all parameters from 32bit structure.
                //
                
                pIoBlock32  = (PIO_BLOCK_32)pBuffer;
                pIoBlock    = &LocalIoBlock;

                pIoBlock -> uOffset = pIoBlock32 -> uOffset;
                pIoBlock -> uLength = pIoBlock32 -> uLength;
                pIoBlock -> pbyData = pIoBlock32 -> pbyData;
                pIoBlock -> uIndex  = pIoBlock32 -> uIndex;

            } else { // if(IoIs32bitProcess(pIrp))
#endif // _WIN64

            if (InLength < sizeof(IO_BLOCK) ) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Invalid input buffer size(0x%x<0x%x)\n"
                                        , InLength,
                                        sizeof(IO_BLOCK)));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
            pIoBlock = (PIO_BLOCK)pBuffer;

#ifdef _WIN64
            } // if(IoIs32bitProcess(pIrp))
#endif // _WIN64 

            if(TRUE == fRead){

                //
                // Check the size of Output buffer.
                //

                if (OutLength < pIoBlock -> uLength) {
                    DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Out buffer(0x%x) too small(<0x%x)\n"
                                            , OutLength
                                            , pIoBlock -> uLength));
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                } // if (OutLength < pIoBlock -> uLength)
            } // if(TRUE == fRead)

            pIrp -> IoStatus.Information = pIoBlock -> uLength;

            //
            // Caller gives us a pointer, embedded into IOCTL buffer. If call is made from
            // user-mode , we need to validate that given pointer is readable.
            //

            if (pIrp->RequestorMode != KernelMode) {

                try {
                    ProbeForRead(pIoBlock->pbyData,
                                 pIoBlock -> uLength,
                                 sizeof(UCHAR));

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    DebugTrace(TRACE_ERROR,("USDeviceControl: Read/Write registers  buffer pointer is invalid\n"));
                    DEBUG_BREAKPOINT();

                    Status = GetExceptionCode();

                    pIrp -> IoStatus.Information = 0;
                    break;
                } // except
            } // !kernelmode

            //
            // Now go to worker function
            //

            Status = USReadWriteRegisters(pDeviceObject,
                                          pIoBlock,
                                          fRead,
                                          InLength);
            if (STATUS_SUCCESS != Status) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! USReadWriteRegisters failed\n"));
                DEBUG_BREAKPOINT();
                pIrp -> IoStatus.Information = 0;
            }
            break;
        } // case IOCTL_WRITE_REGISTERS:
        case IOCTL_GET_CHANNEL_ALIGN_RQST:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_GET_CHANNEL_ALIGN_REQUEST\n"));

            if (OutLength < sizeof(CHANNEL_INFO) ) {

                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Buffer(0x%x) too small(<0x%x)\n"
                                        , OutLength
                                        ,sizeof(CHANNEL_INFO)));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            pIoBlock = (PIO_BLOCK)pBuffer;
            RtlZeroMemory((PCHANNEL_INFO)pIoBlock, sizeof(CHANNEL_INFO));

            for (i = 0; i < pde -> NumberOfPipes; i++) {

                //
                // Have to check which pipe to use
                //

                ULONG Index;
                Index = USGetPipeIndexToUse(pDeviceObject,
                                            pIrp,
                                            i);
                switch (pde -> PipeInfo[Index].PipeType) {
                    case USB_ENDPOINT_TYPE_INTERRUPT:
                        ((PCHANNEL_INFO)pIoBlock)->EventChannelSize = pde -> PipeInfo[Index].MaximumPacketSize;
                        break;
                    case USB_ENDPOINT_TYPE_BULK:
                        if (pde -> pEndpointDescriptor[Index].bEndpointAddress & BULKIN_FLAG) {
                            ((PCHANNEL_INFO)pIoBlock) -> uReadDataAlignment  = pde -> PipeInfo[Index].MaximumPacketSize;
                        } else {
                            ((PCHANNEL_INFO)pIoBlock) -> uWriteDataAlignment = pde -> PipeInfo[Index].MaximumPacketSize;
                        }
                        break;
                }
            }
            pIrp -> IoStatus.Information = sizeof(CHANNEL_INFO);
            Status = STATUS_SUCCESS;
            break;

        case IOCTL_GET_DEVICE_DESCRIPTOR:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_GET_DEVICE_DESCRIPTOR\n"));

            if (OutLength < sizeof(DEVICE_DESCRIPTOR)) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Out buffer(0x%x) is too small(<0x%x)\n"
                                        , OutLength
                                        , sizeof(DEVICE_DESCRIPTOR)));
                Status = STATUS_INVALID_PARAMETER_6;
                break;
            }

            pDesc = (PDEVICE_DESCRIPTOR)pBuffer;
            pDesc -> usVendorId   = pde -> pDeviceDescriptor -> idVendor;
            pDesc -> usProductId  = pde -> pDeviceDescriptor -> idProduct;
            pDesc -> usBcdDevice  = pde -> pDeviceDescriptor -> bcdDevice;

            DebugTrace(TRACE_STATUS,("USDeviceControl: Vendor ID:%d\n", pDesc -> usVendorId));
            DebugTrace(TRACE_STATUS,("USDeviceControl: Product ID:%d\n", pDesc -> usProductId));
            DebugTrace(TRACE_STATUS,("USDeviceControl: BcdDevice:%d\n", pDesc -> usBcdDevice));

            pIrp -> IoStatus.Information = sizeof(DEVICE_DESCRIPTOR);
            Status = STATUS_SUCCESS;
            break;


        case IOCTL_GET_USB_DESCRIPTOR:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_GET_USB_DESCRIPTOR\n"));

            if (OutLength < sizeof(USBSCAN_GET_DESCRIPTOR)) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Out buffer(0x%x) is too small(<0x%x)\n"
                                        , OutLength
                                        , sizeof(USBSCAN_GET_DESCRIPTOR)));
                Status = STATUS_INVALID_PARAMETER_6;
                break;
            }

            pGetDesc = (PUSBSCAN_GET_DESCRIPTOR)pBuffer;
            pUrb = USAllocatePool(NonPagedPool,
                                  sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
            if (NULL == pUrb) {
                DebugTrace(TRACE_CRITICAL,("USDeviceControl: ERROR!! Can't allocate control descriptor URB.\n"));
                DEBUG_BREAKPOINT();
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

#ifdef DEBUG
            switch(pGetDesc -> DescriptorType){
                case USB_DEVICE_DESCRIPTOR_TYPE:
                    DebugTrace(TRACE_STATUS,("USDeviceControl: USB_DEVICE_DESCRIPTOR_TYPE\n"));
                    break;
                case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                    DebugTrace(TRACE_STATUS,("USDeviceControl: USB_CONFIGURATION_DESCRIPTOR_TYPE\n"));
                    break;
                case USB_STRING_DESCRIPTOR_TYPE:
                    DebugTrace(TRACE_STATUS,("USDeviceControl: USB_STRING_DESCRIPTOR_TYPE\n"));
                    break;
                default:
                    DebugTrace(TRACE_WARNING,("USDeviceControl: WARNING!! 0x%x = Undefined.\n", pGetDesc -> DescriptorType));
                    Status = STATUS_INVALID_PARAMETER_3;

                    USFreePool(pUrb);
                    pUrb = NULL;
                    pIrp -> IoStatus.Information = 0;
                    goto USDeviceControl_return;
            }
            DebugTrace(TRACE_STATUS, ("USDeviceControl: Index         :%d\n",pGetDesc -> Index));
            DebugTrace(TRACE_STATUS, ("USDeviceControl: LanguageID    :%d\n", pGetDesc -> LanguageId));
#endif //DEBUG

            UsbBuildGetDescriptorRequest(pUrb,
                                         (USHORT)sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         pGetDesc -> DescriptorType,
                                         pGetDesc -> Index,
                                         pGetDesc -> LanguageId,
                                         pBuffer,
                                         NULL,
                                         OutLength,
                                         NULL);

            Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);
#ifdef DEBUG
            if ( (STATUS_SUCCESS == Status)
//           &&  (USB_DEVICE_DESCRIPTOR_TYPE == pGetDesc -> DescriptorType)
            )
            {
                PUSB_DEVICE_DESCRIPTOR pDeviceDescriptor;
                pDeviceDescriptor = (PUSB_DEVICE_DESCRIPTOR)pBuffer;
                DebugTrace(TRACE_STATUS,("USDeviceControl: Device Descriptor = %x, len %x\n",
                                           pDeviceDescriptor,
                                           pUrb->UrbControlDescriptorRequest.TransferBufferLength));

                DebugTrace(TRACE_STATUS,("USDeviceControl: USBSCAN Device Descriptor:\n"));
                DebugTrace(TRACE_STATUS,("USDeviceControl: -------------------------\n"));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bLength            %d\n",   pDeviceDescriptor->bLength));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bDescriptorType    0x%x\n", pDeviceDescriptor->bDescriptorType));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bcdUSB             0x%x\n", pDeviceDescriptor->bcdUSB));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bDeviceClass       0x%x\n", pDeviceDescriptor->bDeviceClass));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bDeviceSubClass    0x%x\n", pDeviceDescriptor->bDeviceSubClass));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bDeviceProtocol    0x%x\n", pDeviceDescriptor->bDeviceProtocol));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bMaxPacketSize0    0x%x\n", pDeviceDescriptor->bMaxPacketSize0));
                DebugTrace(TRACE_STATUS,("USDeviceControl: idVendor           0x%x\n", pDeviceDescriptor->idVendor));
                DebugTrace(TRACE_STATUS,("USDeviceControl: idProduct          0x%x\n", pDeviceDescriptor->idProduct));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bcdDevice          0x%x\n", pDeviceDescriptor->bcdDevice));
                DebugTrace(TRACE_STATUS,("USDeviceControl: iManufacturer      0x%x\n", pDeviceDescriptor->iManufacturer));
                DebugTrace(TRACE_STATUS,("USDeviceControl: iProduct           0x%x\n", pDeviceDescriptor->iProduct));
                DebugTrace(TRACE_STATUS,("USDeviceControl: iSerialNumber      0x%x\n", pDeviceDescriptor->iSerialNumber));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bNumConfigurations 0x%x\n", pDeviceDescriptor->bNumConfigurations));

            } else {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR! Status = %d\n", Status));
            }

#endif //DEBUG

            USFreePool(pUrb);
            pUrb = NULL;
            pIrp -> IoStatus.Information = ((PUSB_DEVICE_DESCRIPTOR)pBuffer)->bLength;
            break;

        case IOCTL_SEND_USB_REQUEST:
        {

            //
            // Generic pass-through mechanism for USB vendor requests.
            //

            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_SEND_USB_REQUEST\n"));

            //
            // Validate length parameters.
            //

#ifdef _WIN64
            
            if(IoIs32bitProcess(pIrp)){
                PIO_BLOCK_EX_32 pIoBlockEx32;

                if (InLength < sizeof(IO_BLOCK_EX_32) ) {
                    DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Invalid input 32bit buffer size(0x%x<0x%x)\n"
                                            , InLength,
                                            sizeof(IO_BLOCK_EX_32)));
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                // Copy all parameters from 32bit structure.
                //
                
                pIoBlockEx32    = (PIO_BLOCK_EX_32)pBuffer;
                pIoBlockEx      = &LocalIoBlockEx;

                pIoBlockEx -> uOffset               = pIoBlockEx32 -> uOffset;
                pIoBlockEx -> uLength               = pIoBlockEx32 -> uLength;
                pIoBlockEx -> pbyData               = pIoBlockEx32 -> pbyData;
                pIoBlockEx -> uIndex                = pIoBlockEx32 -> uIndex;
                pIoBlockEx -> bRequest              = pIoBlockEx32 -> bRequest;
                pIoBlockEx -> bmRequestType         = pIoBlockEx32 -> bmRequestType;
                pIoBlockEx -> fTransferDirectionIn  = pIoBlockEx32 -> fTransferDirectionIn;

            } else { // if(IoIs32bitProcess(pIrp))
#endif // _WIN64

            if (InLength < sizeof(IO_BLOCK_EX) ) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! I/O buffer(0x%x) too small(<0x%x)\n"
                                        , InLength
                                        , sizeof(IO_BLOCK_EX)));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            pIoBlockEx = (PIO_BLOCK_EX)pBuffer;

#ifdef _WIN64
            } // if(IoIs32bitProcess(pIrp))
#endif // _WIN64 

            if (pIoBlockEx->fTransferDirectionIn) {

                //
                // Check output buffer length is valid.
                //

                if (OutLength < pIoBlockEx -> uLength) {
                    DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! OutLength too small\n"));
                    DEBUG_BREAKPOINT();
                    Status = STATUS_INVALID_PARAMETER;
                    pIrp -> IoStatus.Information = 0;
                    break;
                }
                pIrp -> IoStatus.Information = pIoBlockEx -> uLength;

            } else {

                //
                // No output to the caller.
                //

                pIrp -> IoStatus.Information = 0;
            }

            //
            // Validate user buffer.
            //

            if (pIrp->RequestorMode != KernelMode) {

                try {
                    ProbeForRead(pIoBlockEx->pbyData,
                                 pIoBlockEx->uLength,
                                 sizeof(UCHAR));

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    DebugTrace(TRACE_ERROR,("USDeviceControl: User buffer pointer is invalid\n"));

                    Status = GetExceptionCode();

                    pIrp -> IoStatus.Information = 0;
                    break;
                } // except
            } // !kernelmode

            //
            // Now go to worker function
            //

            Status = USPassThruUSBRequest(pDeviceObject,
                                          (PIO_BLOCK_EX)pBuffer,
                                          InLength,
                                          OutLength
                                          );

            if (STATUS_SUCCESS != Status) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! USPassThruUSBRequest failed\n"));
                DEBUG_BREAKPOINT();
                pIrp -> IoStatus.Information = 0;
            }

            break;

        } // case IOCTL_SEND_USB_REQUEST:
        
        case IOCTL_SEND_USB_REQUEST_PTP:
        {

            //
            // Generic pass-through mechanism for USB vendor requests.
            //

            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_SEND_USB_REQUEST_PTP\n"));

            //
            // Validate length parameters.
            //

#ifdef _WIN64
            
            if(IoIs32bitProcess(pIrp)){
                PIO_BLOCK_EX_32 pIoBlockEx32;

                if (InLength < sizeof(IO_BLOCK_EX_32) ) {
                    DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Invalid input 32bit buffer size(0x%x<0x%x)\n"
                                            , InLength,
                                            sizeof(IO_BLOCK_EX_32)));
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                // Copy all parameters from 32bit structure.
                //
                
                pIoBlockEx32    = (PIO_BLOCK_EX_32)pBuffer;
                pIoBlockEx      = &LocalIoBlockEx;

                pIoBlockEx -> uOffset               = pIoBlockEx32 -> uOffset;
                pIoBlockEx -> uLength               = pIoBlockEx32 -> uLength;
                pIoBlockEx -> pbyData               = pIoBlockEx32 -> pbyData;
                pIoBlockEx -> uIndex                = pIoBlockEx32 -> uIndex;
                pIoBlockEx -> bRequest              = pIoBlockEx32 -> bRequest;
                pIoBlockEx -> bmRequestType         = pIoBlockEx32 -> bmRequestType;
                pIoBlockEx -> fTransferDirectionIn  = pIoBlockEx32 -> fTransferDirectionIn;

            } else { // if(IoIs32bitProcess(pIrp))
#endif // _WIN64

            if (InLength < sizeof(IO_BLOCK_EX) ) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! I/O buffer(0x%x) too small(<0x%x)\n"
                                        , InLength
                                        , sizeof(IO_BLOCK_EX)));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            pIoBlockEx = (PIO_BLOCK_EX)pBuffer;

#ifdef _WIN64
            } // if(IoIs32bitProcess(pIrp))
#endif // _WIN64 

            if (pIoBlockEx->fTransferDirectionIn) {

                //
                // Check output buffer length is valid.
                //

                if (OutLength < pIoBlockEx -> uLength) {
                    DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! OutLength too small\n"));
                    DEBUG_BREAKPOINT();
                    Status = STATUS_INVALID_PARAMETER;
                    pIrp -> IoStatus.Information = 0;
                    break;
                }
                pIrp -> IoStatus.Information = pIoBlockEx -> uLength;

            } else {

                //
                // No output to the caller.
                //

                pIrp -> IoStatus.Information = 0;
            }

            //
            // Validate user buffer.
            //

            if (pIrp->RequestorMode != KernelMode) {

                try {
                    ProbeForRead(pIoBlockEx->pbyData,
                                 pIoBlockEx->uLength,
                                 sizeof(UCHAR));

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    DebugTrace(TRACE_ERROR,("USDeviceControl: User buffer pointer is invalid\n"));

                    Status = GetExceptionCode();

                    pIrp -> IoStatus.Information = 0;
                    break;
                } // except
            } // !kernelmode

            //
            // Now go to worker function
            //

            Status = USPassThruUSBRequestPTP(pDeviceObject,
                                             (PIO_BLOCK_EX)pBuffer,
                                             InLength,
                                             OutLength);

            if (STATUS_SUCCESS != Status) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! USPassThruUSBRequestPTP failed\n"));
                DEBUG_BREAKPOINT();
                pIrp -> IoStatus.Information = 0;
            }

            break;

        } // case IOCTL_SEND_USB_REQUEST_PTP:

        case IOCTL_GET_PIPE_CONFIGURATION:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_GET_PIPE_CONFIGURATION\n"));

            //
            // Check output buffer length
            //

            if (OutLength < sizeof(USBSCAN_PIPE_CONFIGURATION)) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! GetPipeConfig buffer(0x%x) too small(<0x%x)\n"
                                        , OutLength
                                        , sizeof(USBSCAN_PIPE_CONFIGURATION)));
                Status = STATUS_INVALID_PARAMETER_6;
                break;
            }

            //
            // Copy Pipe configuration to user buffer.
            //

            pPipeConfig = (PUSBSCAN_PIPE_CONFIGURATION)pBuffer;
            RtlZeroMemory(pPipeConfig, sizeof(USBSCAN_PIPE_CONFIGURATION));

            pPipeConfig->NumberOfPipes = pde->NumberOfPipes;
            for(i=0; i < pPipeConfig->NumberOfPipes; i++){
                pPipeConfig->PipeInfo[i].MaximumPacketSize = pde->PipeInfo[i].MaximumPacketSize;
                pPipeConfig->PipeInfo[i].EndpointAddress = pde->PipeInfo[i].EndpointAddress;
                pPipeConfig->PipeInfo[i].Interval = pde->PipeInfo[i].Interval;
                pPipeConfig->PipeInfo[i].PipeType = pde->PipeInfo[i].PipeType;
            }

            pIrp -> IoStatus.Information = sizeof(USBSCAN_PIPE_CONFIGURATION);
            Status = STATUS_SUCCESS;
            break;


        case IOCTL_SET_TIMEOUT:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_SET_TIMEOUT\n"));

            //
            // Make sure input buffer size is big enough.
            //

            if(sizeof(USBSCAN_TIMEOUT) > InLength){

                //
                // Incorrect Input buffer size.
                //

                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Invalid input buffer size\n"));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Copy timeout value.
            //

            pFileContext -> TimeoutRead     = ((PUSBSCAN_TIMEOUT)pBuffer) -> TimeoutRead;
            pFileContext -> TimeoutWrite    = ((PUSBSCAN_TIMEOUT)pBuffer) -> TimeoutWrite;
            pFileContext -> TimeoutEvent    = ((PUSBSCAN_TIMEOUT)pBuffer) -> TimeoutEvent;

            pIrp -> IoStatus.Information = 0;

            Status = STATUS_SUCCESS;
            break;

        default:
            DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Unsupported IOCTL\n"));
            Status = STATUS_NOT_SUPPORTED;
            break;
    }


    pIrp -> IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

USDeviceControl_return:
    USDecrementIoCount(pDeviceObject);
    DebugTrace(TRACE_PROC_LEAVE,("USDeviceControl: Leaving.. Status = 0x%x\n", Status));
    return Status;


} // end USDeviceControl()



NTSTATUS
USReadWriteRegisters(
   IN   PDEVICE_OBJECT  pDeviceObject,
   IN   PIO_BLOCK       pIoBlock,
   IN   BOOLEAN         fRead,
   IN   ULONG           IoBlockSize
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PURB                        pUrb;
    ULONG                       siz;
    UCHAR                       Request;
    PVOID                       pBuffer = NULL;
    //USHORT                      uIndex;
    unsigned                   uIndex;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USReadWriteRegisters: Enter..\n"));

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    //
    // Allocate URB
    //

    siz = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
    pUrb = USAllocatePool(NonPagedPool, siz);
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USReadWriteRegisters: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USReadWriteRegisters_return;
    }

    RtlZeroMemory(pUrb, siz);

    //
    // Setup URB
    //

    Request  = REGISTER_AREA;
    if (pIoBlock -> uLength > 1) {
        DebugTrace(TRACE_STATUS,("USReadWriteRegisters: ULength > 1, turning on automatic increment\n"));
        Request |= OPCODE_SEQ_TRANSFER;           // automatic address increment after the read
    } else {
        Request |= OPCODE_SINGLE_ADDR_TRANSFER;   // no address increment after the read
    }

    //
    // Reading registers will read into pIoBlock itself.
    //

    pBuffer = pIoBlock;

    //
    // If we are writing registers, then we need to make a copy of the
    // register block into a non-paged block of memory before handing it off
    // to usbd.
    //

    if (!fRead) {
        DebugTrace(TRACE_STATUS,("USReadWriteRegisters: Write request, allocating non-paged reg buffer, len = %d\n",pIoBlock->uLength));
        pBuffer = USAllocatePool(NonPagedPool, pIoBlock->uLength);
        if (NULL == pBuffer) {
            DebugTrace(TRACE_CRITICAL,("USReadWriteRegisters: ERROR!! cannot allocate write reg buffer\n"));
            DEBUG_BREAKPOINT();
            USFreePool(pUrb);
            pUrb = NULL;
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto USReadWriteRegisters_return;
        }

        //
        // Caller gives us a pointer, embedded into IOCTL buffer. We need to
        // validate that given pointer is readable.
        //

        try{
            RtlCopyMemory(pBuffer,
                          pIoBlock->pbyData,
                          pIoBlock->uLength);

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // Caller buffer is not valid, or worse..
            //

            DebugTrace(TRACE_ERROR,("USReadWriteRegisters: ERROR!! Copying caller buffer failed.\n"));
            DEBUG_BREAKPOINT();
            Status = GetExceptionCode();

            //
            // Clear allocated pool
            //

            USFreePool(pUrb);
            USFreePool(pBuffer);
            pUrb = NULL;
            pBuffer = NULL;

            goto USReadWriteRegisters_return;
        }

    }

    //
    // If the IoBlock is new style (Intel has added a uIndex field to the end of it),
    // then make sure we pass the corrected uIndex value to usbd.
    //

    uIndex = 0;
    if (IoBlockSize == sizeof(IO_BLOCK)) {
        DebugTrace(TRACE_STATUS,("USReadWriteRegisters: New (intel) style IoBlock -- setting uIndex to pIoBlock -> uIndex\n"));
        uIndex = pIoBlock -> uIndex;
    }


    UsbBuildVendorClassSpecificCommand(pUrb,
                                       fRead ? USBD_TRANSFER_DIRECTION_IN : 0,
                                       pIoBlock->uLength,
                                       pBuffer,
                                       NULL,
                                       fRead ? 0xc0 : 0x40,
                                       Request,
                                       (SHORT)pIoBlock->uOffset,
                                       (USHORT)uIndex);

    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

    if (!fRead) {
        DebugTrace(TRACE_STATUS,("USReadWriteRegisters: freeing temp reg buffer\n"));
        USFreePool(pBuffer);
        pBuffer = NULL;
    }

    USFreePool(pUrb);
    pUrb = NULL;

USReadWriteRegisters_return:
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR,("USReadWriteRegisters: ERROR!! Still had unfreed pointer. Free it...\n"));

        if(pUrb){
            USFreePool(pUrb);
        }
        if( (pBuffer)
         && (!fRead ) )
        {
            USFreePool(pBuffer);
        }
    }
    DebugTrace(TRACE_PROC_LEAVE,("USReadWriteRegisters: Leaving.. Status = 0x%x\n", Status));
    return Status;
}


NTSTATUS
USCancelPipe(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp,
    IN PIPE_TYPE        PipeType,
    IN BOOLEAN          fAbort          // TRUE = Abort, FALSE = Reset
)
/*++

Routine Description:

    Cansel URB or reset pipe. If PipeType is PIPE_ALL, it applies to every pipes a device has.
    If not, it applies to only one default pipe even if a device supports multipul same type of pipes.

Arguments:
    pDeviceObject   -   Pointer to Device Object
    pIrp            -   Can be NULL if PipeType is ALL_PIPE
    PipeType        -   Specifies type of pipe
    fAbort          -   Specifies type of operation

Return Value:

    Returns status
--*/
{
    NTSTATUS                    Status, temp;
    PUSBSCAN_DEVICE_EXTENSION   pde;

    PAGED_CODE();

//    DebugTrace(TRACE_PROC_ENTER,("USCancelPipe: Enter.. - "));

    Status = STATUS_SUCCESS;
    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    switch (PipeType) {

        case EVENT_PIPE:

            DebugTrace(TRACE_STATUS,("USCancelPipe: EVENT_PIPE\n"));

            if(NULL == pIrp){
                DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! pIrp not valid\n"));
                break;
            }

            if (-1 == pde -> IndexInterrupt) {
                DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! Interrupt pipe not valid\n"));
                DEBUG_BREAKPOINT();
                Status = STATUS_NOT_SUPPORTED;
                break;
            }

            Status = USAbortResetPipe(pDeviceObject,
                                      USGetPipeIndexToUse(pDeviceObject, pIrp, pde -> IndexInterrupt),
                                      fAbort);
            DebugTrace(TRACE_STATUS,("Event Pipe aborted/reset, Status = 0x%x\n",Status));
            break;

        case READ_DATA_PIPE:

            DebugTrace(TRACE_STATUS,("USCancelPipe: READ_DATA_PIPE\n"));

            if(NULL == pIrp){
                DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! pIrp not valid\n"));
                break;
            }

            if (-1 == pde -> IndexBulkIn) {
                DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! bulk-in pipe not valid\n"));
                DEBUG_BREAKPOINT();
                Status = STATUS_NOT_SUPPORTED;
                break;
            }
            Status = USAbortResetPipe(pDeviceObject,
                                      USGetPipeIndexToUse(pDeviceObject, pIrp, pde -> IndexBulkIn),
                                      fAbort);
            DebugTrace(TRACE_STATUS,("USCancelPipe: Read Pipe aborted/reset, Status = 0x%x\n",Status));
            break;

        case WRITE_DATA_PIPE:

            DebugTrace(TRACE_STATUS,("USCancelPipe: WRITE_DATA_PIPE\n"));

            if(NULL == pIrp){
                DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! pIrp not valid\n"));
                break;
            }

            if (-1 == pde -> IndexBulkOut) {
                DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! bulk-out pipe not valid\n"));
                DEBUG_BREAKPOINT();
                Status = STATUS_NOT_SUPPORTED;
                break;
            }
            Status = USAbortResetPipe(pDeviceObject,
                                      USGetPipeIndexToUse(pDeviceObject, pIrp, pde -> IndexBulkOut),
                                      fAbort);
            DebugTrace(TRACE_STATUS,("Write Pipe aborted/reset, Status = 0x%x\n",Status));
            break;

        case ALL_PIPE:
        {
            ULONG i;

            DebugTrace(TRACE_STATUS,("USCancelPipe: ALL_PIPE\n"));

            for(i=0; i < pde -> NumberOfPipes; i++){
                temp = USAbortResetPipe(pDeviceObject, i, fAbort);
                // DebugTrace(TRACE_STATUS,("USCancelPipe: pipe[%d] aborted/reset, Status = 0x%x\n", i, temp));
                if(STATUS_SUCCESS != temp){
                    Status = temp;
                }
            }
            break;
        }

        default:

            DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! INVALID_PIPE\n"));

            Status = STATUS_INVALID_PARAMETER;
            break;
    }

    DebugTrace(TRACE_PROC_LEAVE,("USCancelPipe: Leaving.. Status = 0x%x\n", Status));
    return Status;
}


NTSTATUS
USAbortResetPipe(
    IN PDEVICE_OBJECT pDeviceObject,
    IN ULONG uIndex,
    IN BOOLEAN fAbort       // TRUE = Abort, FALSE = Reset
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    NTSTATUS                    StatusReset = STATUS_SUCCESS;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PURB                        pUrb;
    ULONG                       siz;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USAbortResetPipe: Enter... \n"));

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pUrb = NULL;

    //
    // Allocate URB
    //

    siz = sizeof(struct _URB_PIPE_REQUEST);
    pUrb = USAllocatePool(NonPagedPool, siz);
    if (NULL == pUrb) {
        DebugTrace(TRACE_ERROR,("USAbortResetPipe: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USAbortResetPipe_return;
    }
    RtlZeroMemory(pUrb, siz);

    if (fAbort) {

        DebugTrace(TRACE_STATUS,("USAbortResetPipe: Aborting pipe[%d]\n", uIndex));

        //
        // Issue abort pipe call to USBD.
        //

        UsbBuildAbortPipeRequest(pUrb,
                                 siz,
                                 pde -> PipeInfo[uIndex].PipeHandle);

        Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

        if (STATUS_SUCCESS != Status) {
            DebugTrace(TRACE_ERROR,("USAbortResetPipe: ERROR!! Abort pipe failed. Status = 0x%x\n",Status));
            goto USAbortResetPipe_return;
        }

        UsbBuildResetPipeRequest(pUrb,
                                 siz,
                                 pde -> PipeInfo[uIndex].PipeHandle);

        StatusReset = USBSCAN_CallUSBD(pDeviceObject, pUrb);

        if (STATUS_SUCCESS != StatusReset) {
            DebugTrace(TRACE_ERROR,("USAbortResetPipe: ERROR!! resetting pipe. Status = 0x%x\n",StatusReset));
            goto USAbortResetPipe_return;
        }


    } else {

        DebugTrace(TRACE_STATUS,("Reseting pipe[%d]\n", uIndex));

        //
        // Issue reset pipe call to USBD.
        //

        UsbBuildResetPipeRequest(pUrb,
                                 siz,
                                 pde -> PipeInfo[uIndex].PipeHandle);

        Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

        if (STATUS_SUCCESS != Status) {
            DebugTrace(TRACE_ERROR,("USAbortResetPipe: ERROR!! Reset pipe failed. Status = 0x%x\n",Status));
            goto USAbortResetPipe_return;
        }
    }

USAbortResetPipe_return:
    //
    // Clean up.
    //

    if(pUrb){
        USFreePool(pUrb);
    }

    DebugTrace(TRACE_PROC_LEAVE,("USAbortResetPipe: Leaving.. Status = 0x%x\n", Status));
    return Status;
}

NTSTATUS
USPassThruUSBRequest(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIO_BLOCK_EX     pIoBlockEx,
    IN ULONG            InLength,
    IN ULONG            OutLength
)
/*++

Routine Description:

    Implements generic pass-thru for vendor request to USBD

Arguments:

    pDeviceObject   -   Device object
    pIoBlockEx      -   Pointer to I/O block as described in USBSCAN.H, passed from user mode client
    InLength        -   In length from IRP
    OutLength       -   Out length from IRP

Return Value:

    NTSTATUS type

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PURB                        pUrb;
    ULONG                       siz;
    PVOID                       pBuffer;
    BOOLEAN                     fDirectionIn;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USPassThruUSBRequest: Enter..\n"));

    //
    // Initialize local variable.
    //

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    Status  = STATUS_SUCCESS;
    pUrb    = NULL;
    pBuffer = NULL;
    fDirectionIn = TRUE;

    //
    // Allocate memory for URB
    //

    siz = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
    pUrb = USAllocatePool(NonPagedPool, siz);
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USPassThruUSBRequest: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USPassThruUSBRequest_return;
    }

    RtlZeroMemory(pUrb, siz);

    //
    // Setup URB
    //

    pBuffer = pIoBlockEx;

    //
    // If we are writing data, then we need to make a copy of the
    // register block into a non-paged block of memory before handing it off
    // to usbd.
    //

    if (!pIoBlockEx->fTransferDirectionIn) {

        DebugTrace(TRACE_STATUS,("USPassThruUSBRequest: Write request, allocating non-paged buffer, len = %d\n",pIoBlockEx->uLength));

        fDirectionIn = FALSE;

        if ( pIoBlockEx->uLength ) {

            pBuffer = USAllocatePool(NonPagedPool, pIoBlockEx->uLength);
            if (NULL == pBuffer) {

                DebugTrace(TRACE_CRITICAL,("USPassThruUSBRequest: ERROR!! cannot allocate write buffer"));
                DEBUG_BREAKPOINT();

                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto USPassThruUSBRequest_return;
            }

            //
            // Caller gives us a pointer, embedded into IOCTL buffer. We need to
            // validate that given pointer is readable.
            //

            try{
                RtlCopyMemory(pBuffer,
                              pIoBlockEx->pbyData,
                              pIoBlockEx->uLength);

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // Caller buffer is not valid, or worse..
                //

                DebugTrace(TRACE_ERROR,("USPassThruUSBRequest: ERROR!! Copying caller buffer failed.\n"));
                DEBUG_BREAKPOINT();
                Status = GetExceptionCode();

                goto USPassThruUSBRequest_return;
            }


        } else {

            //
            // Zero length buffer used for Write , IHV claim that's useful.
            //

            pBuffer = NULL;
        } // if ( pIoBlockEx->uLength )
    }

    UsbBuildVendorClassSpecificCommand(pUrb,
                                       pIoBlockEx->fTransferDirectionIn ? USBD_TRANSFER_DIRECTION_IN : 0,
                                       pIoBlockEx->uLength,
                                       pBuffer,
                                       NULL,
                                       pIoBlockEx->bmRequestType,
                                       pIoBlockEx->bRequest,
                                       (SHORT)pIoBlockEx->uOffset,
                                       (USHORT)pIoBlockEx -> uIndex
                                       );

    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

USPassThruUSBRequest_return:

    //
    // Clean up.
    //

    if(NULL != pUrb){
        DebugTrace(TRACE_STATUS,("USPassThruUSBRequest: Free USB Request Block.\n"));
            USFreePool(pUrb);
        }

    if( (!fDirectionIn)
     && (NULL != pBuffer) )
    {
        DebugTrace(TRACE_STATUS,("USPassThruUSBRequest: Free temp buffer.\n"));
            USFreePool(pBuffer);
        }

    DebugTrace(TRACE_PROC_LEAVE,("USPassThruUSBRequest: Leaving.. Status = 0x%x\n", Status));
    return Status;

}

NTSTATUS
USPassThruUSBRequestPTP(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIO_BLOCK_EX     pIoBlockEx,
    IN ULONG            InLength,
    IN ULONG            OutLength
)
/*++

Routine Description:

    Implements generic pass-thru for vendor request to USBD

Arguments:

    pDeviceObject   -   Device object
    pIoBlockEx      -   Pointer to I/O block as described in USBSCAN.H, passed from user mode client
    InLength        -   In length from IRP
    OutLength       -   Out length from IRP

Return Value:

    NTSTATUS type

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PURB                        pUrb;
    ULONG                       siz;
    PVOID                       pBuffer;
    BOOLEAN                     fDirectionIn;
    USHORT                      usUsbFunction;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USPassThruUSBRequest: Enter..\n"));

    //
    // Initialize local variable.
    //

    pde             = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    Status          = STATUS_SUCCESS;
    pUrb            = NULL;
    pBuffer         = NULL;
    fDirectionIn    = TRUE;
    usUsbFunction   = 0;

    //
    // Allocate memory for URB
    //

    siz = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
    pUrb = USAllocatePool(NonPagedPool, siz);
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USPassThruUSBRequest: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USPassThruUSBRequest_return;
    }

    RtlZeroMemory(pUrb, siz);

    //
    // Setup URB
    //

    pBuffer = pIoBlockEx;

    //
    // If we are writing data, then we need to make a copy of the
    // register block into a non-paged block of memory before handing it off
    // to usbd.
    //

    if (!pIoBlockEx->fTransferDirectionIn) {

        DebugTrace(TRACE_STATUS,("USPassThruUSBRequest: Write request, allocating non-paged buffer, len = %d\n",pIoBlockEx->uLength));

        fDirectionIn = FALSE;

        if ( pIoBlockEx->uLength ) {

            pBuffer = USAllocatePool(NonPagedPool, pIoBlockEx->uLength);
            if (NULL == pBuffer) {

                DebugTrace(TRACE_CRITICAL,("USPassThruUSBRequest: ERROR!! cannot allocate write buffer"));
                DEBUG_BREAKPOINT();

                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto USPassThruUSBRequest_return;
            }

            //
            // Caller gives us a pointer, embedded into IOCTL buffer. We need to
            // validate that given pointer is readable.
            //

            try{
                RtlCopyMemory(pBuffer,
                              pIoBlockEx->pbyData,
                              pIoBlockEx->uLength);

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // Caller buffer is not valid, or worse..
                //

                DebugTrace(TRACE_ERROR,("USPassThruUSBRequest: ERROR!! Copying caller buffer failed.\n"));
                DEBUG_BREAKPOINT();
                Status = GetExceptionCode();

                goto USPassThruUSBRequest_return;
            }


        } else {

            //
            // Zero length buffer used for Write , IHV claim that's useful.
            //

            pBuffer = NULL;
        } // if ( pIoBlockEx->uLength )
    }

    //
    // Set proper USB funtion depends on bmRequestType.
    //
    
    if(0xa1 == pIoBlockEx->bmRequestType){          // USB_PTPREQUEST_TYPE_IN: Class/Interface Device to Host.
        usUsbFunction = URB_FUNCTION_CLASS_INTERFACE;
    } else if(0x21 == pIoBlockEx->bmRequestType){   // USB_PTPREQUEST_TYPE_OUT: Class/Interface Host to Device.
        usUsbFunction = URB_FUNCTION_CLASS_INTERFACE;
    } else {                                        // Default.
        usUsbFunction = URB_FUNCTION_VENDOR_DEVICE;
    }

    UsbBuildVendorClassSpecificCommandPTP(usUsbFunction,
                                          pUrb,
                                          pIoBlockEx->fTransferDirectionIn ? USBD_TRANSFER_DIRECTION_IN : 0,
                                          pIoBlockEx->uLength,
                                          pBuffer,
                                          NULL,
                                          pIoBlockEx->bmRequestType,
                                          pIoBlockEx->bRequest,
                                          (SHORT)pIoBlockEx->uOffset,
                                          (USHORT)pIoBlockEx -> uIndex);

    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

USPassThruUSBRequest_return:

    //
    // Clean up.
    //

    if(NULL != pUrb){
        DebugTrace(TRACE_STATUS,("USPassThruUSBRequest: Free USB Request Block.\n"));
            USFreePool(pUrb);
        }

    if( (!fDirectionIn)
     && (NULL != pBuffer) )
    {
        DebugTrace(TRACE_STATUS,("USPassThruUSBRequest: Free temp buffer.\n"));
            USFreePool(pBuffer);
        }

    DebugTrace(TRACE_PROC_LEAVE,("USPassThruUSBRequest: Leaving.. Status = 0x%x\n", Status));
    return Status;

} // USPassThruUSBRequestPTP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\usbscan\debug.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    debug.h

Abstract:

    Prototypes and definitions for debugging.

Author: 

    Keisuke Tsuchida (KeisukeT)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#ifndef __MYDEBUG__
#define __MYDEBUG__

//
// Driver specific difinition
//


#define NAME_DRIVER             "USBscan.SYs: "    // Prefix of output message. (Should be driver name)
#define NAME_POOLTAG            'UITS'              // Pool tag for this driver.
#define MAXNUM_POOL             100                 // Maximum number of pool. (# of alloc - # of free)
#define MAX_DUMPSIZE            1024                // Maximum bytes to dump.

//
// Defines
//

#define REG_DEBUGLEVEL          L"DebugTraceLevel"
#define MAX_TEMPBUF             256

// Bit mask for trace level and flags
#define BITMASK_TRACE_LEVEL     0x0000000f
#define BITMASK_TRACE_FLAG      0x00000ff0
#define BITMASK_DEBUG_FLAG      0x0000f000

// Basic trace level 
#define NO_TRACE                0                   // Shows nothing.
#define MIN_TRACE               1                   // Shows only error or warning.
#define MAX_TRACE               2                   // Shows progress and status.
#define ULTRA_TRACE             3                   // Shows progress and status in retail.
#define NEVER_TRACE             4                   // Never show this unless specific bit is set.

// Trace flag to enable specific message spew. (1=on)
#define TRACE_FLAG_PROC          0x10                // Show message when entering process.(1=on)
#define TRACE_FLAG_RET           0x20                // Show message when leaving process.(1=on)
#define TRACE_FLAG_DUMP_READ     0x40                // Show user buffer when read.
#define TRACE_FLAG_DUMP_WRITE    0x80                // Show user buffer when write.

// Conbination of trace level and flag.
#define TRACE_PROC_ENTER        ULTRA_TRACE | TRACE_FLAG_PROC     // Entering procedure.
#define TRACE_PROC_LEAVE        ULTRA_TRACE | TRACE_FLAG_RET      // Leaving procedure.
#define TRACE_CRITICAL          MIN_TRACE                         // Critical error. Spew always.
#define TRACE_ERROR             MIN_TRACE                         // Error.
#define TRACE_WARNING           MIN_TRACE                         // Possible wrong behavior.
//#define TRACE_DUMP_DATA         NEVER_TRACE | TRACE_FLAG_DUMP     // Dump transaction data.
#define TRACE_DEVICE_DATA       MAX_TRACE                         // Show device data.
#define TRACE_STATUS            MAX_TRACE                         // Show status.

// Debug flag to enable/disable  DEBUG_BREAKPOINT()
#define DEBUG_FLAG_DISABLE      0x1000                          // Disable DEBUG_BREAK. (1=disable)
#define DEBUG_PROC_BREAK        0x2000                          // Stop at the beginning of each procedure.


//
// Macro
//

#if DBG

 //
 // Macro for debug output
 //
 // Note: If trace level is higher than DebugTraceLevel or specific bit is set, 
 //       debug message will be shown.
 //

extern ULONG DebugTraceLevel;
 #define DebugTrace(_t_, _x_) {                                                                 \
            if ( ((DebugTraceLevel & BITMASK_TRACE_LEVEL) >= (_t_ & BITMASK_TRACE_LEVEL )) ||   \
                 (DebugTraceLevel & BITMASK_TRACE_FLAG & (_t_)) ) {                             \
                DbgPrint(NAME_DRIVER);                                                          \
                DbgPrint _x_ ;                                                                  \
            }                                                                                   \
            if( (DebugTraceLevel & DEBUG_PROC_BREAK & (_t_)) &&                                 \
                (DebugTraceLevel & TRACE_FLAG_PROC) )  {                                        \
                DEBUG_BREAKPOINT();                                                             \
            }                                                                                   \
          }

 //
 // Macro for BreakPoint
 //

 #define DEBUG_BREAKPOINT() {                                              \
           if (DebugTraceLevel & DEBUG_FLAG_DISABLE) {                     \
               DbgPrint(NAME_DRIVER);                                      \
               DbgPrint("*** Hit DEBUG_BREAKPOINT ***\n");                 \
           } else {                                                        \
               DbgBreakPoint();                                            \
           }                                                               \
         }

#else    // DBG
 #define DEBUG_BREAKPOINT()
 #define DebugTrace(_t_, _x_)
#endif   // DBG


//
// Prototypes
//


PVOID
MyAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG     ulNumberOfBytes
);

VOID
MyFreePool(
    IN PVOID     pvAddress
);

VOID
MyDebugInit(
    IN  PUNICODE_STRING pRegistryPath
);


VOID
MyDumpMemory(
    PUCHAR  pDumpBuffer,
    ULONG   dwSize,
    BOOLEAN bRead
);

#endif //  __MYDEBUG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\serscan\winnt\serlog.h ===
#ifndef _SERLOG_
#define _SERLOG_

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: SER_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Not enough memory was available to allocate internal storage needed for the device %1.
//
#define SER_INSUFFICIENT_RESOURCES       ((NTSTATUS)0xC0040001L)

//
// MessageId: SER_NO_SYMLINK_CREATED
//
// MessageText:
//
//  Unable to create the symbolic link for %1.
//
#define SER_NO_SYMLINK_CREATED           ((NTSTATUS)0x80040002L)

//
// MessageId: SER_NO_DEVICE_MAP_CREATED
//
// MessageText:
//
//  Unable to create the device map entry for %1.
//
#define SER_NO_DEVICE_MAP_CREATED        ((NTSTATUS)0x80040003L)

//
// MessageId: SER_CANT_FIND_PORT_DRIVER
//
// MessageText:
//
//  Unable to get device object pointer for port object.
//
#define SER_CANT_FIND_PORT_DRIVER        ((NTSTATUS)0xC0040004L)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\usbscan\private.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    private.h

Abstract:

    Prototypes and definitions for the usb scanner device driver.

Author:

Environment:

    kernel mode only

Notes:

Revision History:
--*/

//
// Includes
//

#include "debug.h"

//
// Defines
//

#ifndef max
 #define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
 #define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#ifndef ARRAYSIZE
 #define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#endif

#define TAG_USBSCAN             0x55495453                  // "STIU"
#define TAG_USBD                0x44425355                  // "USBD"

#define USBSCAN_OBJECTNAME_A    "\\\\.\\Usbscan"
#define USBSCAN_OBJECTNAME_W    L"\\\\.\\Usbscan"
#define USBSCAN_REG_CREATEFILE  L"CreateFileName"

#define USBSCAN_TIMEOUT_READ    120                         // 120 sec
#define USBSCAN_TIMEOUT_WRITE   120                         // 120 sec
#define USBSCAN_TIMEOUT_EVENT   0                           // no timeout
#define USBSCAN_TIMEOUT_OTHER   120                         // 120 sec

#define USBSCAN_REG_TIMEOUT_READ    L"TimeoutRead"
#define USBSCAN_REG_TIMEOUT_WRITE   L"TimeoutWrite"
#define USBSCAN_REG_TIMEOUT_EVENT   L"TimeoutEvent"

#define USBSCAN_MAX_CREATEFILENAME  64                      // 64 characters

//
// Private IOCTL to workaround #446466 (Whistler)
//

#define IOCTL_SEND_USB_REQUEST_PTP  CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+20,METHOD_BUFFERED,FILE_ANY_ACCESS)

//
// Pipe buffer structure for the read pipe only.
//

typedef struct _PIPEBUFFER {
    PUCHAR  pStartBuffer;
    PUCHAR  pBuffer;
    PUCHAR  pNextByte;
    ULONG   RemainingData;
    KEVENT  ReadSyncEvent;
} PIPEBUFFER, *PPIPEBUFFER;


//
// Device Extension
//

typedef struct _USBSCAN_DEVICE_EXTENSION {

    PDEVICE_OBJECT                  pStackDeviceObject;
    PDEVICE_OBJECT                  pPhysicalDeviceObject;
    ULONG                           DeviceInstance;
    UNICODE_STRING                  DeviceName;
    UNICODE_STRING                  SymbolicLinkName;
    KEVENT                          PendingIoEvent;
    ULONG                           PendingIoCount;
    ULONG                           AcceptingRequests;
    ULONG                           Stopped;

    //
    // USB descriptors from the device
    //

    PUSB_DEVICE_DESCRIPTOR          pDeviceDescriptor;
    PUSB_CONFIGURATION_DESCRIPTOR   pConfigurationDescriptor;
    PUSB_INTERFACE_DESCRIPTOR       pInterfaceDescriptor;
    PUSB_ENDPOINT_DESCRIPTOR        pEndpointDescriptor;

    USBD_CONFIGURATION_HANDLE       ConfigurationHandle;
    USBD_PIPE_INFORMATION           PipeInfo[MAX_NUM_PIPES];
    ULONG                           NumberOfPipes;
    ULONG                           IndexBulkIn;
    ULONG                           IndexBulkOut;
    ULONG                           IndexInterrupt;

    //
    // Name of the device interface
    //
    UNICODE_STRING  InterfaceNameString;

    //
    // Read pipe buffer
    //

    PIPEBUFFER                      ReadPipeBuffer[MAX_NUM_PIPES];

    //
    // Power management variables
    //

    PIRP                            pPowerIrp;
    DEVICE_CAPABILITIES             DeviceCapabilities;
    DEVICE_POWER_STATE              CurrentDevicePowerState;

} USBSCAN_DEVICE_EXTENSION, *PUSBSCAN_DEVICE_EXTENSION;

typedef struct _TRANSFER_CONTEXT {
    ULONG               RemainingTransferLength;
    ULONG               ChunkSize;
    ULONG               NBytesTransferred;
    PUCHAR              pTransferBuffer;
    PUCHAR              pOriginalTransferBuffer;
    PMDL                pTransferMdl;
    ULONG               PipeIndex;
    PURB                pUrb;
    BOOLEAN             fDestinedForReadBuffer;
    BOOLEAN             fNextReadBlocked;
    PIRP                pThisIrp;
    PDEVICE_OBJECT      pDeviceObject;
    LARGE_INTEGER       Timeout;
    KDPC                TimerDpc;
    KTIMER              Timer;
} TRANSFER_CONTEXT, *PTRANSFER_CONTEXT;

typedef struct _USBSCAN_FILE_CONTEXT {
    LONG            PipeIndex;
    ULONG           TimeoutRead;
    ULONG           TimeoutWrite;
    ULONG           TimeoutEvent;
} USBSCAN_FILE_CONTEXT, *PUSBSCAN_FILE_CONTEXT;

typedef struct _USBSCAN_PACKTES {
    PIRP    pIrp;
    ULONG   TimeoutCounter;
    BOOLEAN bCompleted;
    LIST_ENTRY  PacketsEntry;
} USBSCAN_PACKETS, *PUSBSCAN_PACKETS;

#ifdef _WIN64
typedef struct _IO_BLOCK_32 {
    IN      unsigned            uOffset;
    IN      unsigned            uLength;
    IN OUT  CHAR * POINTER_32   pbyData;
    IN      unsigned            uIndex;
} IO_BLOCK_32, *PIO_BLOCK_32;

typedef struct _IO_BLOCK_EX_32 {
    IN      unsigned            uOffset;
    IN      unsigned            uLength;
    IN OUT  CHAR * POINTER_32   pbyData;
    IN      unsigned            uIndex;
    IN      UCHAR               bRequest;               // Specific request
    IN      UCHAR               bmRequestType;          // Bitmap - charateristics of request
    IN      UCHAR               fTransferDirectionIn;   // TRUE - Device-->Host; FALSE - Host-->Device
} IO_BLOCK_EX_32, *PIO_BLOCK_EX_32;
#endif // _WIN64

//
// prototypes
//

NTSTATUS                                // in usbscan.c
DriverEntry(
        IN PDRIVER_OBJECT  DriverObject,
        IN PUNICODE_STRING RegistryPath
);

VOID                                    // in usbscan.c
USUnload(
        IN PDRIVER_OBJECT DriverObject
);

VOID                                    // in usbscan.c
USIncrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
);

LONG                                    // in usbscan.c
USDecrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
);

NTSTATUS                                // in usbscan.c
USDeferIrpCompletion(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp,
    IN PVOID          Context
);

NTSTATUS                                // in usbscan.c
USCreateSymbolicLink(
    PUSBSCAN_DEVICE_EXTENSION  pde
);

NTSTATUS                                // in usbscan.c
USDestroySymbolicLink(
    PUSBSCAN_DEVICE_EXTENSION  pde
);

NTSTATUS                                // in usbscan.c
USPnp(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
);

NTSTATUS                                // in usbscan.c
USPnpAddDevice(
    IN PDRIVER_OBJECT     pDriverObject,
    IN OUT PDEVICE_OBJECT pPhysicalDeviceObject
);

NTSTATUS                                // in usbscan.c
USGetUSBDeviceDescriptor(
    IN PDEVICE_OBJECT pDeviceObject
);

NTSTATUS                                // in usbscan.c
USBSCAN_CallUSBD(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PURB pUrb
);

NTSTATUS                                // in usbscan.c
USConfigureDevice(
    IN PDEVICE_OBJECT pDeviceObject
);

NTSTATUS                                // in usbscan.c
USUnConfigureDevice(
    IN PDEVICE_OBJECT pDeviceObject
);

NTSTATUS                                // in usbscan.c
UsbScanReadDeviceRegistry(
    IN  PUSBSCAN_DEVICE_EXTENSION   pExtension,
    IN  PCWSTR                      pKeyName,
    OUT PVOID                       *ppvData
    );

NTSTATUS                                // in usbscan.c
UsbScanWriteDeviceRegistry(
    IN PUSBSCAN_DEVICE_EXTENSION    pExtension,
    IN PCWSTR                       pKeyName,
    IN ULONG                        Type,
    IN PVOID                        pvData,
    IN ULONG                        DataSize
    );

PURB
USCreateConfigurationRequest(
    IN PUSB_CONFIGURATION_DESCRIPTOR    ConfigurationDescriptor,
    IN OUT PUSHORT                      Siz
    );

#ifdef ORIGINAL_POOLTRACK
PVOID                                   // in usbscan.c
USAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG     ulNumberOfBytes
    );

VOID                                    // in usbscan.c
USFreePool(
    IN PVOID     pvAddress
    );

#else       // ORIGINAL_POOLTRACK
 #define USAllocatePool(a, b)   ExAllocatePoolWithTag(a, b, NAME_POOLTAG)
 #define USFreePool(a)          ExFreePool(a)
#endif      // ORIGINAL_POOLTRACK

NTSTATUS                                // in ioctl.c
USDeviceControl(
        IN PDEVICE_OBJECT pDeviceObject,
        IN PIRP pIrp
    );

NTSTATUS                                // in ioctl.c
USReadWriteRegisters(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIO_BLOCK      pIoBlock,
    IN BOOLEAN        fRead,
    IN ULONG          IoBlockSize
    );

NTSTATUS                               // in ioctl.c
USPassThruUSBRequest(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIO_BLOCK_EX     pIoBlockEx,
    IN ULONG            InLength,
    IN ULONG            OutLength
    );

NTSTATUS                               // in ioctl.c
USPassThruUSBRequestPTP(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIO_BLOCK_EX     pIoBlockEx,
    IN ULONG            InLength,
    IN ULONG            OutLength
    );


NTSTATUS                                // in ioctl.c
USCancelPipe(
        IN PDEVICE_OBJECT   pDeviceObject,
        IN PIRP             pIrp,
        IN PIPE_TYPE        PipeType,
        IN BOOLEAN          fAbort
    );

NTSTATUS                                // in ioctl.c
USAbortResetPipe(
        IN PDEVICE_OBJECT pDeviceObject,
        IN ULONG uIndex,
    IN BOOLEAN fAbort
    );

NTSTATUS                                // in ocrw.c
USOpen(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS                                // in ocrw.c
USClose(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS                                // in ocrw.c
USFlush(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS                                // in ocrw.c
USRead(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS                                // in ocrw.c
USWrite(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS                                // in ocrw.c
USTransfer(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp,
    IN ULONG            PipeIndex,
    IN PVOID            pBuffer,
    IN PMDL             pMdl,
    IN ULONG            TransferSize,
    IN PULONG           pTimeout
    );

NTSTATUS                                // in ocrw.c
USTransferComplete(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp,
    IN PTRANSFER_CONTEXT    pTransferContext
    );

VOID                                    // in ocrw.c
USCancelIrp(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    );

NTSTATUS                                // in ocrw.c
USEnqueueIrp(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PUSBSCAN_PACKETS     pPackets
    );

PUSBSCAN_PACKETS                        // in ocrw.c
USDequeueIrp(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

VOID                                    // in ocrw.c
USWaitThread(
    IN PVOID pTransferContext
    );

ULONG
USGetPipeIndexToUse(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp,
    IN ULONG                PipeIndex
    );

VOID
USTimerDpc(
    IN PKDPC    pDpc,
    IN PVOID    pIrp,
    IN PVOID    SystemArgument1,
    IN PVOID    SystemArgument2
    );


NTSTATUS                                // in power.c
USPower(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    );


NTSTATUS                                // in power.c
USPoRequestCompletion(
    IN PDEVICE_OBJECT       pPdo,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIO_STATUS_BLOCK     pIoStatus
    );

USPowerIrpComplete(                     // in power.c
    IN PDEVICE_OBJECT pPdo,
    IN PIRP           pIrp,
    IN PDEVICE_OBJECT pDeviceObject
);

NTSTATUS                                // in power.c
USSetDevicePowerState(
    IN PDEVICE_OBJECT pDeviceObject,
    IN DEVICE_POWER_STATE DeviceState,
    IN PBOOLEAN pHookIt
);

NTSTATUS
USCallNextDriverSynch(
    IN  PUSBSCAN_DEVICE_EXTENSION  pde,
    IN  PIRP              pIrp
    );


NTSTATUS
UsbScanHandleInterface(
    PDEVICE_OBJECT      DeviceObject,
    PUNICODE_STRING     InterfaceName,
    BOOLEAN             Create
    );



VOID
UsbScanLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\usbscan\power.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    power.c

Abstract:

Author:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include <stdio.h>
#include "stddef.h"
#include "wdm.h"
#include "usbscan.h"
#include "usbd_api.h"
#include "private.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USPower)
#endif


NTSTATUS
USPower(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    )
/*++

Routine Description:
    Process the Power IRPs sent to the PDO for this device.

Arguments:
    pDeviceObject - pointer to the functional device object (FDO) for this device.
    pIrp          - pointer to an I/O Request Packet

Return Value:
    NT status code

--*/
{
    NTSTATUS                        Status;
    PUSBSCAN_DEVICE_EXTENSION       pde;
    PIO_STACK_LOCATION              pIrpStack;
    BOOLEAN                         hookIt = FALSE;
    POWER_STATE                     powerState;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USPower: Enter... \n"));

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("USPower: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("USPower: Leaving.. Status = %x.\n", Status));
        return Status;
    }

    USIncrementIoCount(pDeviceObject);

    pde       = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    Status    = STATUS_SUCCESS;

    switch (pIrpStack -> MinorFunction) {
        case IRP_MN_SET_POWER:
            DebugTrace(TRACE_STATUS,("USPower: IRP_MN_SET_POWER\n"));

            switch (pIrpStack -> Parameters.Power.Type) {
                case SystemPowerState:
                    DebugTrace(TRACE_STATUS,("USPower: SystemPowerState\n"));

                    //
                    // find the device power state equivalent to the given system state
                    //

                    DebugTrace(TRACE_STATUS,("USPower: Set Power, SystemPowerState (%d)\n",
                                               pIrpStack -> Parameters.Power.State.SystemState));
                    if (pIrpStack -> Parameters.Power.State.SystemState == PowerSystemWorking) {
                        powerState.DeviceState = PowerDeviceD0;

                    } else if (/* pde ->EnabledForWakeup */ FALSE) {

                        DebugTrace(TRACE_STATUS,("USPower: USBSCAN always enabled for wakeup\n"));
                        powerState.DeviceState = pde ->
                            DeviceCapabilities.DeviceState[pIrpStack->Parameters.Power.State.SystemState];

                    } else {

                        //
                        // wakeup not enabled, just go in to the 'OFF' state.
                        //

                        powerState.DeviceState = PowerDeviceD3;

                    } //irpStack->Parameters.Power.State.SystemState

                    //
                    // are we already in this state?
                    //

                    if (powerState.DeviceState != pde -> CurrentDevicePowerState) {

                        //
                        // No, request that we be put into this state
                        //

                        DebugTrace(TRACE_STATUS,("USPower: Requesting powerstate %d\n",
                            powerState.DeviceState));

                        IoMarkIrpPending(pIrp);
                        pde -> pPowerIrp = pIrp;
                        Status = PoRequestPowerIrp(pde -> pPhysicalDeviceObject,
                            IRP_MN_SET_POWER,
                            powerState,
                            USPoRequestCompletion,
                            pDeviceObject,
                            NULL);

                        if (!NT_SUCCESS(Status)) {

                            //
                            // Allocation failed, we must complete the IRP
                            // ourselves.
                            //
                            PoStartNextPowerIrp(pIrp);
                            IoCompleteRequest(pIrp, IO_NO_INCREMENT);
                            USDecrementIoCount(pDeviceObject);
                        }

                        //
                        // We marked the IRP pending, so we must return
                        // STATUS_PENDING (our caller will examine
                        // Irp->IoStatus.Status)
                        //
                        Status = STATUS_PENDING;

                    } else {

                        //
                        // Yes, just pass it on
                        //

                        IoCopyCurrentIrpStackLocationToNext(pIrp);
                        PoStartNextPowerIrp(pIrp);
                        Status = PoCallDriver(pde -> pStackDeviceObject, pIrp);
                        USDecrementIoCount(pDeviceObject);
                    }
                    break;

                case DevicePowerState:
                    DebugTrace(TRACE_STATUS,("USPower: DevicePowerState\n"));

                    Status = USSetDevicePowerState(pDeviceObject,
                        pIrpStack -> Parameters.Power.State.DeviceState,
                        &hookIt);

                    IoCopyCurrentIrpStackLocationToNext(pIrp);

                    if (hookIt) {
                        DebugTrace(TRACE_STATUS,("USPower: Set PowerIrp Completion Routine\n"));
                        IoSetCompletionRoutine(pIrp,
                                               USPowerIrpComplete,
                                               // always pass FDO to completion routine
                                               pDeviceObject,
                                               hookIt,
                                               hookIt,
                                               hookIt);
                    }
                    PoStartNextPowerIrp(pIrp);
                    Status = PoCallDriver(pde ->pStackDeviceObject, pIrp);
                    if (!hookIt) {
                        USDecrementIoCount(pDeviceObject);
                    }
                    break;

            } /* case irpStack->Parameters.Power.Type */
            break; /* IRP_MN_SET_POWER */


        case IRP_MN_QUERY_POWER:
            DebugTrace(TRACE_STATUS,("USPower: IRP_MN_QUERY_POWER\n"));
            IoCopyCurrentIrpStackLocationToNext(pIrp);
            PoStartNextPowerIrp(pIrp);
            Status = PoCallDriver(pde -> pStackDeviceObject, pIrp);
            USDecrementIoCount(pDeviceObject);

            break; /* IRP_MN_QUERY_POWER */

        default:
            DebugTrace(TRACE_STATUS,("USPower: Unknown power message (%x)\n",pIrpStack->MinorFunction));
            IoCopyCurrentIrpStackLocationToNext(pIrp);
            PoStartNextPowerIrp(pIrp);
            Status = PoCallDriver(pde -> pStackDeviceObject, pIrp);
            USDecrementIoCount(pDeviceObject);

    } /* pIrpStack -> MinorFunction */


    DebugTrace(TRACE_PROC_LEAVE,("USPower: Leaving... Status = 0x%x\n", Status));
    return Status;
}


NTSTATUS
USPoRequestCompletion(
    IN PDEVICE_OBJECT       pPdo,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PDEVICE_OBJECT       pDeviceObject,                      
    IN PIO_STATUS_BLOCK     pIoStatus
    )
/*++

Routine Description:
    This routine is called when the port driver completes an IRP.

Arguments:

Return Value:
    The function value is the final status from the operation.

--*/
{
    NTSTATUS                    Status;    
    PUSBSCAN_DEVICE_EXTENSION   pde;                    
    PIRP                        pIrp;

    DebugTrace(TRACE_PROC_ENTER,("USPoRequestCompletion: Enter...\n"));    
  
    pde    = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;    
    pIrp   = pde -> pPowerIrp;
    Status = pIoStatus -> Status;

    IoCopyCurrentIrpStackLocationToNext(pIrp);      
    PoStartNextPowerIrp(pIrp);
    PoCallDriver(pde -> pStackDeviceObject, pIrp);   
    USDecrementIoCount(pDeviceObject);                 

    DebugTrace(TRACE_PROC_LEAVE,("USPoRequestCompletion: Leaving... Status = 0x%x\n", Status));
    return Status;
}


USPowerIrpComplete(
    IN PDEVICE_OBJECT pPdo,
    IN PIRP           pIrp,
    IN PDEVICE_OBJECT pDeviceObject
    )
/*++

Routine Description:
    This routine is called when the port driver completes an IRP.

Arguments:

Return Value:
    The function value is the final status from the operation.

--*/
{
    NTSTATUS                    Status;    
    PUSBSCAN_DEVICE_EXTENSION   pde;                    
    PIO_STACK_LOCATION          pIrpStack;    

    DebugTrace(TRACE_PROC_ENTER,("USPowerIrpComplete: Enter...\n"));    
  
    pde    = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    Status = STATUS_SUCCESS;

    if (pIrp -> PendingReturned) {
        IoMarkIrpPending(pIrp);
    }

    pIrpStack = IoGetCurrentIrpStackLocation (pIrp);

    ASSERT(pIrpStack -> MajorFunction == IRP_MJ_POWER);
    ASSERT(pIrpStack -> MinorFunction == IRP_MN_SET_POWER);
    ASSERT(pIrpStack -> Parameters.Power.Type == DevicePowerState);
    ASSERT(pIrpStack -> Parameters.Power.State.DeviceState == PowerDeviceD0);

    pde -> AcceptingRequests = TRUE;
    pde -> CurrentDevicePowerState = PowerDeviceD0;

    pIrp -> IoStatus.Status = Status;
    USDecrementIoCount(pDeviceObject); 

    DebugTrace(TRACE_PROC_LEAVE,("USPowerIrpComplete: Leaving... Status = 0x%x\n", Status));
    return Status;
}


NTSTATUS
USSetDevicePowerState(
    IN PDEVICE_OBJECT pDeviceObject,
    IN DEVICE_POWER_STATE DeviceState,
    IN PBOOLEAN pHookIt
    )
/*++

Routine Description:

Arguments:
    pDeviceObject - Pointer to the device object for the class device.
    DeviceState - Device specific power state to set the device in to.

Return Value:

--*/
{
    NTSTATUS                    Status;    
    PUSBSCAN_DEVICE_EXTENSION   pde;                    

    DebugTrace(TRACE_PROC_ENTER,("USSetDevicePowerState: Enter...\n"));    
  
    pde    = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    Status = STATUS_SUCCESS;

    switch (DeviceState) {
    case PowerDeviceD3:

//        ASSERT(pde -> AcceptingRequests);
//        pde -> AcceptingRequests = FALSE;

//        USCancelPipe(pDeviceObject, ALL_PIPE, TRUE);
        
//        pde -> CurrentDevicePowerState = DeviceState;
//        break;

    case PowerDeviceD1:
    case PowerDeviceD2:
#if DBG    
        if (DeviceState) {
            DebugTrace(TRACE_STATUS,("USSetDevicePowerState: PowerDeviceD3 (OFF)\n"));                 
        } else {
            DebugTrace(TRACE_STATUS,("USSetDevicePowerState: PowerDeviceD1/D2 (SUSPEND)\n"));      
        }
#endif   
        USCancelPipe(pDeviceObject, NULL, ALL_PIPE, TRUE);
        //
        // power states D1,D2 translate to USB suspend
        // D3 transltes to OFF

        pde -> CurrentDevicePowerState = DeviceState;
        break;

    case PowerDeviceD0:
        DebugTrace(TRACE_STATUS,("USSetDevicePowerState: PowerDeviceD0 (ON)\n"));

        //
        // finish the rest in the completion routine
        //

        *pHookIt = TRUE;

        // pass on to PDO
        
        break;

    default:

        DebugTrace(TRACE_WARNING,("USSetDevicePowerState: Bogus DeviceState = %x\n", DeviceState));
    }

    DebugTrace(TRACE_PROC_LEAVE,("USSetDevicePowerState: Leaving... Status = 0x%x\n", Status));
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\usbscan\ocrw.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ocrw.c

Abstract:

Author:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include <stdio.h>
#include "stddef.h"
#include "wdm.h"
#include "usbscan.h"
#include "usbd_api.h"
#include "private.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USOpen)
#pragma alloc_text(PAGE, USClose)
#pragma alloc_text(PAGE, USFlush)
#pragma alloc_text(PAGE, USRead)
#pragma alloc_text(PAGE, USWrite)
#pragma alloc_text(PAGE, USGetPipeIndexToUse)
#pragma alloc_text(PAGE, USTransfer)
#endif

NTSTATUS
USOpen(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
/*++

Routine Description:

    This routine is called to establish a connection to the device
    class driver. It does no more than return STATUS_SUCCESS.

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Open request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                        Status;
    PUSBSCAN_DEVICE_EXTENSION       pde;
    PFILE_OBJECT                    fileObject;
    PUSBSCAN_FILE_CONTEXT           pFileContext;
    PIO_STACK_LOCATION              irpStack;
    PKEY_VALUE_PARTIAL_INFORMATION  pValueInfo;
    ULONG                           nameLen, ix;

    PAGED_CODE();
    DebugTrace(TRACE_PROC_ENTER,("USOpen: Enter..\n"));

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("USOpen: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("USOpen: Leaving.. Status = %x.\n", Status));
        return Status;
    }

    //
    // Increment I/O processing counter.
    //
    
    USIncrementIoCount( pDeviceObject );

    //
    // Initialize locals.
    //
    
    pde         = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    irpStack    = IoGetCurrentIrpStackLocation (pIrp);
    fileObject  = irpStack->FileObject;
    pValueInfo  = NULL;

    Status      = STATUS_SUCCESS;

    //
    // Initialize file context.
    //
    
    fileObject->FsContext = NULL;
    
    //
    // Check if it's accepting requests.
    //
    
    if (FALSE == pde -> AcceptingRequests) {
        DebugTrace(TRACE_WARNING,("USOpen: WARNING!! Device isn't accepting request.\n"));
        Status = STATUS_DELETE_PENDING;
        goto USOpen_return;
    }

    //
    // Check device power state.
    //
    
    if (PowerDeviceD0 != pde -> CurrentDevicePowerState) {
        DebugTrace(TRACE_WARNING,("USOpen: WARNING!! Device is suspended.\n"));
        Status = STATUS_DELETE_PENDING;
        goto USOpen_return;
    }

    //
    // Allocate file context buffer.
    //

    pFileContext = USAllocatePool(NonPagedPool, sizeof(USBSCAN_FILE_CONTEXT));
    if(NULL == pFileContext){
        DebugTrace(TRACE_CRITICAL,("USOpen: ERROR!! Can't allocate file context\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USOpen_return;
    }
    RtlZeroMemory(pFileContext, sizeof(USBSCAN_FILE_CONTEXT));
    
    //
    // Set allocated buffer to the context.
    //

    fileObject->FsContext = pFileContext;

    //
    // Check the length of CreateFile name to see if pipe is specified by prefix.
    //
    
    nameLen     = fileObject->FileName.Length;
    DebugTrace(TRACE_STATUS,("USOpen: CreateFile name=%ws, Length=%d.\n", fileObject->FileName.Buffer, nameLen));

    if (0 == nameLen) {

        //
        // Use default pipe
        //
        
        pFileContext->PipeIndex = -1;

    } else {

        //
        // Pipe number must be '\' + one digit , like '\0'.
        // length would be 4.
        //

        if( (4 != nameLen)
         || (fileObject->FileName.Buffer[1] < (WCHAR) '0')
         || (fileObject->FileName.Buffer[1] > (WCHAR) '9') )
        {
            DebugTrace(TRACE_ERROR,("USOpen: ERROR!! Invalid CreateFile Name\n"));
            Status = STATUS_INVALID_PARAMETER;
        } else {
            pFileContext->PipeIndex = (LONG)(fileObject->FileName.Buffer[1] - (WCHAR) '0');

            //
            // Check if pipe index is lower than maximum
            //

            if(pFileContext->PipeIndex > (LONG)pde->NumberOfPipes){
                DebugTrace(TRACE_ERROR,("USOpen: ERROR!! Invalid pipe index(0x%x). Use default.\n", pFileContext->PipeIndex));
                pFileContext->PipeIndex = -1;
                Status = STATUS_INVALID_PARAMETER;
            }
        }
    }

    //
    // Read default timeout value from registry. If not exist, then set default.
    //
    
    // Timeout for Read.
    Status = UsbScanReadDeviceRegistry(pde,
                                       USBSCAN_REG_TIMEOUT_READ,
                                       &pValueInfo);
    if(NT_SUCCESS(Status)){
        if(NULL != pValueInfo){
            pFileContext->TimeoutRead = *((PULONG)pValueInfo->Data);
            USFreePool(pValueInfo);
            pValueInfo = NULL;
        } else {
            DebugTrace(TRACE_ERROR,("USOpen: ERROR!! UsbScanReadDeviceRegistry(1) succeeded but pValueInfo is NULL.\n"));
            pFileContext->TimeoutRead = USBSCAN_TIMEOUT_READ;
        }
    } else {
        pFileContext->TimeoutRead = USBSCAN_TIMEOUT_READ;
    }
    DebugTrace(TRACE_STATUS,("USOpen: Default Read timeout=0x%xsec.\n", pFileContext->TimeoutRead));

    // Timeout for Write.
    Status = UsbScanReadDeviceRegistry(pde,
                                       USBSCAN_REG_TIMEOUT_WRITE,
                                       &pValueInfo);
    if(NT_SUCCESS(Status)){
        if(NULL != pValueInfo){
            pFileContext->TimeoutWrite = *((PULONG)pValueInfo->Data);
            USFreePool(pValueInfo);
            pValueInfo = NULL;
        } else {
            DebugTrace(TRACE_ERROR,("USOpen: ERROR!! UsbScanReadDeviceRegistry(2) succeeded but pValueInfo is NULL.\n"));
            pFileContext->TimeoutRead = USBSCAN_TIMEOUT_WRITE;
        }
    } else {
        pFileContext->TimeoutWrite = USBSCAN_TIMEOUT_WRITE;

    }
    DebugTrace(TRACE_STATUS,("USOpen: Default Write timeout=0x%xsec.\n", pFileContext->TimeoutWrite));

    // Timeout for Event.
    Status = UsbScanReadDeviceRegistry(pde,
                                       USBSCAN_REG_TIMEOUT_EVENT,
                                       &pValueInfo);
    if(NT_SUCCESS(Status)){
        if(NULL != pValueInfo){
            pFileContext->TimeoutEvent = *((PULONG)pValueInfo->Data);
            USFreePool(pValueInfo);
            pValueInfo = NULL;
        } else {
            DebugTrace(TRACE_ERROR,("USOpen: ERROR!! UsbScanReadDeviceRegistry(3) succeeded but pValueInfo is NULL.\n"));
            pFileContext->TimeoutRead = USBSCAN_TIMEOUT_EVENT;
        }
    } else {
        pFileContext->TimeoutEvent = USBSCAN_TIMEOUT_EVENT;
    }
    DebugTrace(TRACE_STATUS,("USOpen: Default Event timeout=0x%xsec.\n", pFileContext->TimeoutEvent));
    
    //
    // Return successfully.
    //
    
    Status      = STATUS_SUCCESS;

USOpen_return:

    pIrp -> IoStatus.Information = 0;
    pIrp -> IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    USDecrementIoCount(pDeviceObject);
    DebugTrace(TRACE_PROC_LEAVE,("USOpen: Leaving.. Status = %x.\n", Status));
    return Status;

} // end USOpen()

NTSTATUS
USFlush(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
/*++

Routine Description:

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Close request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                   Status;
    PUSBSCAN_DEVICE_EXTENSION  pde;
    ULONG                      i;

    PAGED_CODE();
    DebugTrace(TRACE_PROC_ENTER,("USFlush: Enter..\n"));

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("USFlush: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("USFlush: Leaving.. Status = %x.\n", Status));
        return Status;
    }

    USIncrementIoCount( pDeviceObject );

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    Status = STATUS_SUCCESS;
    for(i = 0; i < pde->NumberOfPipes; i++){
        if( (pde->PipeInfo[i].PipeType == UsbdPipeTypeBulk)
         && (pde->PipeInfo[i].EndpointAddress & BULKIN_FLAG) )
        {
            DebugTrace(TRACE_STATUS,("USFlush: Flushing Buffer[%d].\n",i));

            if (pde->ReadPipeBuffer[i].RemainingData > 0) {
                    DebugTrace(TRACE_STATUS,("USFlush: Buffer[%d] 0x%p -> 0x%p.\n",
                                                    i,
                                                    pde->ReadPipeBuffer[i].pBuffer,
                                                    pde->ReadPipeBuffer[i].pStartBuffer));
                    pde->ReadPipeBuffer[i].pBuffer = pde->ReadPipeBuffer[i].pStartBuffer;
                    pde->ReadPipeBuffer[i].RemainingData = 0;
            }
        }
    }

    pIrp -> IoStatus.Information = 0;
    pIrp -> IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    USDecrementIoCount(pDeviceObject);
    DebugTrace(TRACE_PROC_LEAVE,("USFlush: Leaving.. Status = %x.\n", Status));
    return Status;

} // end USFlush()


NTSTATUS
USClose(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
/*++

Routine Description:

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Close request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                    Status;
    PFILE_OBJECT                fileObject;
    PUSBSCAN_FILE_CONTEXT       pFileContext;
    PIO_STACK_LOCATION          pIrpStack;

    PAGED_CODE();
    DebugTrace(TRACE_PROC_ENTER,("USClose: Enter..\n"));

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("USClose: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("USClose: Leaving.. Status = %x.\n", Status));
        return Status;
    }

    USIncrementIoCount( pDeviceObject );

    //
    // Initialize locals.
    //
    
    pIrpStack       = IoGetCurrentIrpStackLocation (pIrp);
    fileObject      = pIrpStack->FileObject;
    pFileContext    = fileObject->FsContext;

    //
    // Free context buffer.
    //
    
    ASSERT(NULL != pFileContext);
    USFreePool(pFileContext);
    pFileContext = NULL;

    //
    // Complete.
    //
    
    Status      = STATUS_SUCCESS;

    pIrp -> IoStatus.Information = 0;
    pIrp -> IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    USDecrementIoCount(pDeviceObject);
    DebugTrace(TRACE_PROC_LEAVE,("USClose: Leaving.. Status = %x.\n", Status));
    return Status;

} // end USClose()


NTSTATUS
USRead(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
/*++

Routine Description:

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Read request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PIO_STACK_LOCATION          pIrpStack;
    PFILE_OBJECT                fileObject;
    PUSBSCAN_FILE_CONTEXT       pFileContext;
    ULONG                       Timeout;
    PULONG                      pTimeout;

    PAGED_CODE();
    DebugTrace(TRACE_PROC_ENTER,("USRead: Enter..\n"));

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("USRead: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("USRead: Leaving.. Status = %x.\n", Status));
        return Status;
    }

    ASSERT(pIrp -> MdlAddress);

    USIncrementIoCount( pDeviceObject );

    //
    // Initialize locals.
    //
    
    pde             = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    //
    // Check if it's accepting requests.
    //
    
    if (pde -> AcceptingRequests == FALSE) {
        DebugTrace(TRACE_ERROR,("USRead: ERROR!! Read issued after device stopped/removed!\n"));
        Status = STATUS_FILE_CLOSED;
        pIrp -> IoStatus.Information = 0;
        pIrp -> IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        goto USRead_return;
    }

    //
    // Check device power state.
    //
    
    if (PowerDeviceD0 != pde -> CurrentDevicePowerState) {
        DebugTrace(TRACE_WARNING,("USRead: WARNING!! Device is suspended.\n"));
        Status = STATUS_FILE_CLOSED;
        pIrp -> IoStatus.Information = 0;
        pIrp -> IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        goto USRead_return;
    }

    pIrpStack       = IoGetCurrentIrpStackLocation (pIrp);
    fileObject      = pIrpStack->FileObject;
    pFileContext    = fileObject->FsContext;

    //
    // Copy timeout value for Read from file context.
    //
    
    Timeout = pFileContext->TimeoutRead;
    
    //
    // If timeout value is 0, then never timeout.
    //
    
    if(0 == Timeout){
        pTimeout = NULL;
    } else {
        DebugTrace(TRACE_STATUS,("USRead: Timeout is set to 0x%x sec.\n", Timeout));
        pTimeout = &Timeout;
    }

    //
    // Call worker funciton.
    //
    
    Status = USTransfer(pDeviceObject,
                        pIrp,
                        pde -> IndexBulkIn,
                        NULL,
                        pIrp -> MdlAddress,
                        pIrpStack -> Parameters.Read.Length,
                        pTimeout);
    //
    // IRP should be completed in USTransfer or its completion routine.
    //

USRead_return:
    USDecrementIoCount(pDeviceObject);
    DebugTrace(TRACE_PROC_LEAVE,("USRead: Leaving.. Status = %x.\n", Status));
    return Status;
}


NTSTATUS
USWrite(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
/*++

Routine Description:

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Write request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PIO_STACK_LOCATION          pIrpStack;
    PFILE_OBJECT                fileObject;
    PUSBSCAN_FILE_CONTEXT       pFileContext;
    ULONG                       Timeout;
    PULONG                      pTimeout;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USWrite: Enter..\n"));

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("USWrite: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("USWrite: Leaving.. Status = %x.\n", Status));
        return Status;
    }

    USIncrementIoCount( pDeviceObject );

    //
    // Initialize locals.
    //
    
    pde             = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    //
    // Check if it's accepting requests.
    //

    if (pde -> AcceptingRequests == FALSE) {
        DebugTrace(TRACE_ERROR,("USWrite: ERROR!! Write issued after device stopped/removed!\n"));
        Status = STATUS_FILE_CLOSED;
        pIrp -> IoStatus.Information = 0;
        pIrp -> IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        goto USWrite_return;
    }

    //
    // Check device power state.
    //
    
    if (PowerDeviceD0 != pde -> CurrentDevicePowerState) {
        DebugTrace(TRACE_WARNING,("USWrite: WARNING!! Device is suspended.\n"));
        Status = STATUS_FILE_CLOSED;
        pIrp -> IoStatus.Information = 0;
        pIrp -> IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        goto USWrite_return;
    }

    pIrpStack       = IoGetCurrentIrpStackLocation (pIrp);
    fileObject      = pIrpStack->FileObject;
    pFileContext    = fileObject->FsContext;

    //
    // Copy timeout value for Write from file context.
    //
    
    Timeout = pFileContext->TimeoutWrite;
    
    //
    // If timeout value is 0, then never timeout.
    //
    
    if(0 == Timeout){
        pTimeout = NULL;
    } else {
        DebugTrace(TRACE_STATUS,("USWrite: Timeout is set to 0x%x sec.\n", Timeout));
        pTimeout = &Timeout;
    }

    //
    // Call worker funciton.
    //

#if DBG
{
    PUCHAR  pDumpBuf = NULL;

    if (NULL != pIrp -> MdlAddress) {
        pIrp -> MdlAddress -> MdlFlags |= MDL_MAPPING_CAN_FAIL;
        pDumpBuf = MmGetSystemAddressForMdl(pIrp -> MdlAddress);
    }

    if(NULL != pDumpBuf){
        MyDumpMemory(pDumpBuf,
                     pIrpStack -> Parameters.Write.Length,
                     FALSE);
    }
}
#endif // DBG



    Status = USTransfer(pDeviceObject,
                        pIrp,
                        pde -> IndexBulkOut,
                        NULL,
                        pIrp -> MdlAddress,
                        pIrpStack -> Parameters.Write.Length,
                        pTimeout);

    //
    // IRP should be completed in USTransfer or its completion routine.
    //
    
USWrite_return:
    USDecrementIoCount(pDeviceObject);
    DebugTrace(TRACE_PROC_LEAVE,("USWrite: Leaving.. Status = %x.\n", Status));
    return Status;
}


NTSTATUS
USTransfer(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp,
    IN ULONG            Index,
    IN PVOID            pBuffer,        //  Either pBuffer or pMdl
    IN PMDL             pMdl,           //  must be passed in.
    IN ULONG            TransferSize,
    IN PULONG           pTimeout
)
/*++

Routine Description:

Arguments:
    pDeviceObject   - Device object for a device.
    pOrigianlIrp    - Original IRP to Read/Write.

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PIO_STACK_LOCATION          pNextIrpStack;
    PTRANSFER_CONTEXT           pTransferContext;
    PURB                        pUrb;
    PUSBSCAN_PACKETS            pPackets;
    ULONG                       siz = 0;
    ULONG                       MaxPacketSize;
    ULONG                       MaxTransferSize;
    ULONG                       PipeIndex;
    BOOLEAN                     fNextReadBlocked;
    BOOLEAN                     fBulkIn;
    BOOLEAN                     fNeedCompletion;
    
    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USTransfer: Enter..\n"));

    //
    // Initialize status etc..
    //
    
    Status = STATUS_SUCCESS;
    fNeedCompletion = TRUE;

    pde                 = NULL;
    pNextIrpStack       = NULL;
    pTransferContext    = NULL;
    pUrb                = NULL;
    pPackets            = NULL;;

    //
    // Check the arguments.
    //

    if( (NULL == pIrp)
     || (   (NULL == pBuffer)
         && (NULL == pMdl)  
         && (0 != TransferSize) )
     || (Index > MAX_NUM_PIPES) )
    {
        DebugTrace(TRACE_ERROR,("USTransfer: ERROR!! Invalid argment.\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto USTransfer_return;
    }

    //
    // Initialize status etc..
    //
    
    pIrp -> IoStatus.Information = 0;
    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    pNextIrpStack = IoGetNextIrpStackLocation(pIrp);

    //
    // Pickup PipeIndex to use
    //

    PipeIndex = USGetPipeIndexToUse(pDeviceObject,
                                    pIrp,
                                    Index);

    DebugTrace(TRACE_STATUS,("USTransfer: Transfer [pipe %d] called. size = %d, pBuffer = 0x%p, Mdl = 0x%p \n",
                               PipeIndex,
                               TransferSize,
                               pBuffer,
                               pMdl
                    ));

    MaxTransferSize = pde -> PipeInfo[PipeIndex].MaximumTransferSize;
    MaxPacketSize   = pde -> PipeInfo[PipeIndex].MaximumPacketSize;

    fBulkIn = ((pde->PipeInfo[PipeIndex].PipeType == UsbdPipeTypeBulk)
                && (pde->PipeInfo[PipeIndex].EndpointAddress & BULKIN_FLAG));

#if DBG
    if (TransferSize > MaxTransferSize) {
        DebugTrace(TRACE_STATUS,("USTransfer: Transfer > max transfer size.\n"));
    }
#endif

    ASSERT(PipeIndex <= MAX_NUM_PIPES);

    fNextReadBlocked = FALSE;

    if (fBulkIn) {

        //
        // Get exclusive access to each read buffer by using event
        //

        DebugTrace(TRACE_STATUS,("USTransfer: Waiting for Sync event for Pipe %d...\n", PipeIndex));

        if(NULL != pTimeout){
            LARGE_INTEGER  Timeout;
            
            Timeout = RtlConvertLongToLargeInteger(-10*1000*1000*(*pTimeout));
            Status = KeWaitForSingleObject(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, Executive, KernelMode, FALSE, &Timeout);
        } else {
            Status = KeWaitForSingleObject(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, Executive, KernelMode, FALSE, 0);
        }
        
        if(STATUS_SUCCESS != Status){
            KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
            DebugTrace(TRACE_ERROR,("USTransfer: ERROR!! KeWaitForSingleObject() failed. Status=0x%x.\n", Status));
            if(STATUS_TIMEOUT == Status){
                Status = STATUS_IO_TIMEOUT;
            } else {
                Status = STATUS_UNSUCCESSFUL;
            }
            goto USTransfer_return;
        } // if(STATUS_SUCCESS != Status)

        DebugTrace(TRACE_STATUS,("USTransfer: Get access to Pipe %d !!\n", PipeIndex));

        fNextReadBlocked = TRUE;

        //
        // If there is remaining data in the read pipe buffer, copy it into the irp transfer buffer.
        // Update the irp transfer pointer, number of bytes left to transfer, the read pipe buffer pointer
        // and the remaining number of bytes left in the read pipe buffer.
        //

        if (pde -> ReadPipeBuffer[PipeIndex].RemainingData > 0) {
            DebugTrace(TRACE_STATUS,("USTransfer: Copying %d buffered bytes into irp\n",
                                        pde -> ReadPipeBuffer[PipeIndex].RemainingData));
            siz = min(pde -> ReadPipeBuffer[PipeIndex].RemainingData, TransferSize);
            if (NULL == pBuffer) {

                //
                // There's no buffer. Try to use Mdl instead.
                //

                if(NULL == pMdl){

                    //
                    // Error: Both Buffer and Mdl are NULL.
                    //

                    Status = STATUS_INVALID_PARAMETER;
                    KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
                    DebugTrace(TRACE_ERROR,("USTransfer: ERROR!! Both Buffer&Mdl=NULL.\n"));
                    goto USTransfer_return;

                } else {
                    pMdl->MdlFlags |= MDL_MAPPING_CAN_FAIL;
                    pBuffer = MmGetSystemAddressForMdl(pMdl);
                    if(NULL == pBuffer){
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
                        DebugTrace(TRACE_ERROR,("USTransfer: ERROR!! MmGetSystemAddressForMdl failed.\n"));
                        goto USTransfer_return;
                    }
                    
                    pMdl = NULL;
                }
            }
            ASSERT(siz > 0);
            ASSERT(pBuffer);
            ASSERT(pde -> ReadPipeBuffer[PipeIndex].pBuffer);
            RtlCopyMemory(pBuffer,pde -> ReadPipeBuffer[PipeIndex].pBuffer, siz);
            pde -> ReadPipeBuffer[PipeIndex].pBuffer += siz;
            pde -> ReadPipeBuffer[PipeIndex].RemainingData -= siz;
            ASSERT((LONG)pde -> ReadPipeBuffer[PipeIndex].RemainingData >= 0);
            if (0 == pde -> ReadPipeBuffer[PipeIndex].RemainingData) {
                DebugTrace(TRACE_STATUS,("USTransfer: read buffer emptied.\n"));
                pde -> ReadPipeBuffer[PipeIndex].pBuffer = pde -> ReadPipeBuffer[PipeIndex].pStartBuffer;
            }
            (PUCHAR)(pBuffer) += siz;
            TransferSize -= siz;
            ASSERT((LONG)TransferSize >= 0);

            // If the read irp was completely satisfied from data in the read buffer, then
            // unblock the next pending read and return success.

            if (0 == TransferSize) {
                pIrp -> IoStatus.Information = siz;
                Status = STATUS_SUCCESS;
                KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
                DebugTrace(TRACE_STATUS,("USTransfer: Irp satisfied from ReadBuffer.\n"));
                goto USTransfer_return;
            }
        } // if (pde -> ReadPipeBuffer[PipeIndex].RemainingData > 0)

        //
        // If this read is an integer number of usb packets, it will not affect
        // the state of the read buffer.  Unblock the next waiting read in this case.
        //

        if (0 == TransferSize % MaxPacketSize) {
            DebugTrace(MAX_TRACE,("USTransfer: Unblocking next read.\n"));
            KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
            fNextReadBlocked = FALSE;
        }
    } // if (fBulkIn) 

    //
    // Allocate and initialize Transfer Context
    //

    pTransferContext = USAllocatePool(NonPagedPool, sizeof(TRANSFER_CONTEXT));
    if (NULL == pTransferContext) {
        DebugTrace(TRACE_CRITICAL,("USTransfer: ERROR!! cannot allocated Transfer Context\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        if (fNextReadBlocked) {
            KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
        }
        goto USTransfer_return;
    }
    RtlZeroMemory(pTransferContext, sizeof(TRANSFER_CONTEXT));

    //
    // Allocate and initialize URB
    //

    pUrb = USAllocatePool(NonPagedPool, sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER));
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USTransfer: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        if (fNextReadBlocked) {
            KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
        }
        goto USTransfer_return;
    }
    RtlZeroMemory(pUrb, sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER));

    ASSERT(pUrb);
    ASSERT(pTransferContext);

    pTransferContext -> fDestinedForReadBuffer  = FALSE;
    pTransferContext -> fNextReadBlocked        = fNextReadBlocked;
    pTransferContext -> RemainingTransferLength = TransferSize;
    pTransferContext -> ChunkSize               = TransferSize;
    pTransferContext -> PipeIndex               = PipeIndex;
    pTransferContext -> pTransferBuffer         = pBuffer;
    pTransferContext -> pTransferMdl            = pMdl;
    pTransferContext -> NBytesTransferred       = siz;
    pTransferContext -> pUrb                    = pUrb;
    pTransferContext -> pThisIrp                = pIrp;
    pTransferContext -> pDeviceObject           = pDeviceObject;

    //
    // IF the transfer is > MaxTransferSize, OR
    // IF the transfer is not a multiple of a USB packet AND it is a read transfer THEN
    //   Check if we have been passed an MDL.  If so, we need to turn it into a pointer so
    //     that we can advance it when the transfer is broken up into smaller transfers.
    //

    if( (pTransferContext -> ChunkSize > MaxTransferSize) 
     || ( (0 != pTransferContext -> ChunkSize % MaxPacketSize) 
       && (fBulkIn) ) )
    {
        if (NULL == pTransferContext -> pTransferBuffer) {
            DebugTrace(TRACE_STATUS,("USTransfer: Converting MDL to buffer pointer.\n"));
            ASSERT(pTransferContext -> pTransferMdl);
            pTransferContext -> pTransferMdl ->MdlFlags |= MDL_MAPPING_CAN_FAIL;

            pTransferContext -> pTransferBuffer = MmGetSystemAddressForMdl(pTransferContext -> pTransferMdl);
            pTransferContext -> pTransferMdl = NULL;
            ASSERT(pTransferContext -> pTransferBuffer);
            if(NULL == pTransferContext -> pTransferBuffer){
                Status = STATUS_INSUFFICIENT_RESOURCES;
                if (fNextReadBlocked) {
                    KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
                }
                goto USTransfer_return;
            }
        }
    }

    //
    // If chunksize is bigger than MaxTransferSize, then set it to MaxTransferSize.  The
    // transfer completion routine will issue additional transfers until the total size has
    // been transferred.
    //

    if (pTransferContext -> ChunkSize > MaxTransferSize) {
        pTransferContext -> ChunkSize = MaxTransferSize;
    }

    if (fBulkIn) {

        //
        // If this read is smaller than a USB packet, then issue a request for a
        // whole usb packet and make sure it goes into the read buffer first.
        //

        if (pTransferContext -> ChunkSize < MaxPacketSize) {
            DebugTrace(TRACE_STATUS,("USTransfer: Request is < packet size - transferring whole packet into read buffer.\n"));
            pTransferContext -> fDestinedForReadBuffer = TRUE;
            pTransferContext -> pOriginalTransferBuffer = pTransferContext -> pTransferBuffer;  // save off original transfer ptr.
            pTransferContext -> pTransferBuffer = pde -> ReadPipeBuffer[PipeIndex].pBuffer;
            pTransferContext -> ChunkSize = MaxPacketSize;
        }

        //
        // Truncate the size of the read to an integer number of packets.  If necessary,
        // the completion routine will handle any fractional remaining packets (with the read buffer).
        //

        pTransferContext -> ChunkSize = (pTransferContext -> ChunkSize / MaxPacketSize) * MaxPacketSize;
    }

//    ASSERT(pTransferContext -> RemainingTransferLength);
//    ASSERT((pTransferContext -> pTransferBuffer) || (pTransferContext -> pTransferMdl));
    ASSERT(pTransferContext -> pUrb);

    //
    // Initialize URB
    //

    UsbBuildInterruptOrBulkTransferRequest(pUrb,
                                           sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
                                           pde ->PipeInfo[PipeIndex].PipeHandle,
                                           pTransferContext -> pTransferBuffer,
                                           pTransferContext -> pTransferMdl,
                                           pTransferContext -> ChunkSize,
                                           USBD_SHORT_TRANSFER_OK,
                                           NULL);

    //
    // Setup stack location for lower driver
    //

    pNextIrpStack -> MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    pNextIrpStack -> MinorFunction = 0;
    pNextIrpStack -> Parameters.DeviceIoControl.IoControlCode = (ULONG)IOCTL_INTERNAL_USB_SUBMIT_URB;
    pNextIrpStack -> Parameters.Others.Argument1 = pUrb;

    if(NULL != pTimeout){
        pTransferContext -> Timeout = RtlConvertLongToLargeInteger(-10*1000*1000*(*pTimeout));

        //
        // Initialize timer and DPC.
        //

        KeInitializeTimer(&(pTransferContext->Timer));
        KeInitializeDpc(&(pTransferContext->TimerDpc),
                        (PKDEFERRED_ROUTINE)USTimerDpc,
                        (PVOID)pIrp);
        //
        // Enqueue timer object for timeout.
        //
        
        DebugTrace(TRACE_STATUS,("USTransfer: Set timeout(0x%x x 100n sec).\n", -(pTransferContext -> Timeout.QuadPart)));
        if(KeSetTimer(&(pTransferContext->Timer),
                      pTransferContext -> Timeout,
                      &(pTransferContext->TimerDpc)))
        {
            DebugTrace(TRACE_ERROR,("USTransfer: Timer object already exist.\n"));
        }
        
    } else {
        DebugTrace(TRACE_STATUS,("USTransfer: No timeout for this IRP.\n"));
    }

    //
    // Increment processing I/O count, will be decremented in completion.
    //

    USIncrementIoCount( pDeviceObject );

    //
    // Mark pending to IRP.
    //
    
    IoMarkIrpPending(pIrp);

    //
    // Set Completion Routine.
    //
    
    IoSetCompletionRoutine(pIrp,
                           USTransferComplete,
                           pTransferContext,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // Call down.
    //

    fNeedCompletion = FALSE;
    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);
    if(STATUS_PENDING != Status){
        DebugTrace(TRACE_ERROR,("USTransfer: ERROR!! Lower driver returned 0x%x.\n", Status));
    }

    //
    // Must return STATUS_PENDING.
    //

    Status = STATUS_PENDING;

USTransfer_return:

    if(fNeedCompletion){
        if(NULL != pIrp){
            DebugTrace(TRACE_STATUS,("USTransfer: Completeing IRP now.\n"));
            
            //
            // Error or data satisfied from buffer.
            //
            
            pIrp->IoStatus.Status = Status;
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        } // if(NULL != pIrp)
        
        if(NULL != pUrb){
            USFreePool(pUrb);
        }
        if(NULL != pTransferContext){
            USFreePool(pTransferContext);
        }
    }
    
    DebugTrace(TRACE_PROC_LEAVE,("USTransfer: Leaving.. Status = 0x%x.\n", Status));
    return Status;
}

NTSTATUS
USTransferComplete(
    IN PDEVICE_OBJECT       pPassedDeviceObject,
    IN PIRP                 pIrp,
    IN PTRANSFER_CONTEXT    pTransferContext
)
/*++

Routine Description:

Arguments:
    pPassedDeviceObject - Device object for a device.
    pIrp                - Read/write request packet
    pTransferContext    - context info for transfer

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                    Status;
    PIO_STACK_LOCATION          pIrpStack;
    PIO_STACK_LOCATION          pNextIrpStack;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PDEVICE_OBJECT              pDeviceObject;
    PURB                        pUrb;
    ULONG                       CompletedTransferLength;
    NTSTATUS                    CompletedTransferStatus;
    ULONG                       MaxPacketSize;
    BOOLEAN                     fShortTransfer = FALSE;
    BOOLEAN                     fBulkIn;
    ULONG                       PipeIndex;

    DebugTrace(TRACE_PROC_ENTER,("USTransferComplete: Enter.. - called. irp = 0x%p\n",pIrp));

    ASSERT(pIrp);
    ASSERT(pTransferContext);

    Status = pIrp -> IoStatus.Status;
    pIrp -> IoStatus.Information = 0;

    if(NULL == pPassedDeviceObject){
        pDeviceObject = pTransferContext->pDeviceObject;
    } else {
        pDeviceObject = pPassedDeviceObject;
    }

    pIrpStack     = IoGetCurrentIrpStackLocation(pIrp);
    pNextIrpStack = IoGetNextIrpStackLocation(pIrp);

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    PipeIndex = pTransferContext -> PipeIndex;
    MaxPacketSize =  pde -> PipeInfo[PipeIndex].MaximumPacketSize;

    fBulkIn = ((pde->PipeInfo[PipeIndex].PipeType == UsbdPipeTypeBulk)
            && (pde->PipeInfo[PipeIndex].EndpointAddress & BULKIN_FLAG));

    pUrb = pTransferContext -> pUrb;
    CompletedTransferLength = pUrb -> UrbBulkOrInterruptTransfer.TransferBufferLength;
    CompletedTransferStatus = pUrb -> UrbBulkOrInterruptTransfer.Hdr.Status;

    if( (STATUS_SUCCESS == CompletedTransferStatus) 
     && (STATUS_SUCCESS == Status) )
    {

        if (CompletedTransferLength < pTransferContext -> ChunkSize) {
            DebugTrace(TRACE_STATUS,("USTransferComplete: Short transfer received. Length = %d, ChunkSize = %d\n",
                                       CompletedTransferLength, pTransferContext -> ChunkSize));
            fShortTransfer = TRUE;
        }

        //
        // If this transfer went into the read buffer, then this should be the final read
        // of either a multipart larger read, or a single very small read (< single usb packet).
        // In either case, we need to copy the appropriate amount of data into the user's irp, update the
        // read buffer variables, and complete the user's irp.
        //

        if (pTransferContext -> fDestinedForReadBuffer) {
            DebugTrace(TRACE_STATUS,("USTransferComplete: Read transfer completed. size = %d\n", CompletedTransferLength));
            ASSERT(CompletedTransferLength <= MaxPacketSize);
            ASSERT(pTransferContext -> pOriginalTransferBuffer);
            ASSERT(pTransferContext -> pTransferBuffer);
            ASSERT(pde -> ReadPipeBuffer[PipeIndex].pBuffer == pTransferContext -> pTransferBuffer);
            ASSERT(pTransferContext -> RemainingTransferLength < MaxPacketSize);

            pde -> ReadPipeBuffer[PipeIndex].RemainingData = CompletedTransferLength;
            CompletedTransferLength = min(pTransferContext -> RemainingTransferLength,
                                 pde -> ReadPipeBuffer[PipeIndex].RemainingData);
            ASSERT(CompletedTransferLength < MaxPacketSize);
            RtlCopyMemory(pTransferContext -> pOriginalTransferBuffer,
                          pde -> ReadPipeBuffer[PipeIndex].pBuffer,
                          CompletedTransferLength);
            pde -> ReadPipeBuffer[PipeIndex].pBuffer += CompletedTransferLength;
            pde -> ReadPipeBuffer[PipeIndex].RemainingData -= CompletedTransferLength;

            if (0 == pde -> ReadPipeBuffer[PipeIndex].RemainingData) {
                DebugTrace(TRACE_STATUS,("USTransferComplete: Read buffer emptied.\n"));
                pde -> ReadPipeBuffer[PipeIndex].pBuffer = pde -> ReadPipeBuffer[PipeIndex].pStartBuffer;
            }
            pTransferContext -> pTransferBuffer = pTransferContext -> pOriginalTransferBuffer;
        }

        //
        // Update the number of bytes transferred, remaining bytes to transfer
        // and advance the transfer buffer pointer appropriately.
        //

        pTransferContext -> NBytesTransferred += CompletedTransferLength;
        if (pTransferContext -> pTransferBuffer) {
            pTransferContext -> pTransferBuffer += CompletedTransferLength;
        }
        pTransferContext -> RemainingTransferLength -= CompletedTransferLength;

        //
        // If there is still data to transfer and the previous transfer was NOT a
        // short transfer, then issue another request to move the next chunk of data.
        //

        if (pTransferContext -> RemainingTransferLength > 0) {
            if (!fShortTransfer) {

                DebugTrace(TRACE_STATUS,("USTransferComplete: Queuing next chunk. RemainingSize = %d, pBuffer = 0x%p\n",
                                           pTransferContext -> RemainingTransferLength,
                                           pTransferContext -> pTransferBuffer
                                          ));

                if (pTransferContext -> RemainingTransferLength < pTransferContext -> ChunkSize) {
                    pTransferContext -> ChunkSize = pTransferContext -> RemainingTransferLength;
                }

                //
                // Reinitialize URB
                //
                // If the next transfer is < than 1 packet, change it's destination to be
                // the read buffer.  When this transfer completes, the appropriate amount of data will be
                // copied out of the read buffer and into the user's irp.  Left over data in the read buffer
                // will be available for subsequent reads.
                //

                if (fBulkIn) {
                    if (pTransferContext -> ChunkSize < MaxPacketSize) {
                        pTransferContext -> fDestinedForReadBuffer = TRUE;
                        pTransferContext -> pOriginalTransferBuffer = pTransferContext -> pTransferBuffer;
                        pTransferContext -> pTransferBuffer = pde -> ReadPipeBuffer[PipeIndex].pBuffer;
                        pTransferContext -> ChunkSize = MaxPacketSize;
                    }
                    pTransferContext -> ChunkSize = (pTransferContext -> ChunkSize / MaxPacketSize) * MaxPacketSize;
                }

                ASSERT(pTransferContext -> ChunkSize >= MaxPacketSize);
                ASSERT(0 == pTransferContext -> ChunkSize % MaxPacketSize);
                UsbBuildInterruptOrBulkTransferRequest(pUrb,
                    sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
                    pde -> PipeInfo[PipeIndex].PipeHandle,
                    pTransferContext -> pTransferBuffer,
                    NULL,
                    pTransferContext -> ChunkSize,
                    USBD_SHORT_TRANSFER_OK,
                    NULL);
                IoSetCompletionRoutine(pIrp,
                                       USTransferComplete,
                                       pTransferContext,
                                       TRUE,
                                       TRUE,
                                       FALSE);

                //
                // Setup stack location for lower driver
                //

                pNextIrpStack -> MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                pNextIrpStack -> MinorFunction = 0;
                pNextIrpStack -> Parameters.DeviceIoControl.IoControlCode = (ULONG)IOCTL_INTERNAL_USB_SUBMIT_URB;
                pNextIrpStack -> Parameters.Others.Argument1 = pUrb;

                IoCallDriver(pde -> pStackDeviceObject, pIrp);
                Status = STATUS_MORE_PROCESSING_REQUIRED;
                goto USTransferComplete_return;

            } // if (!fShortTransfer) 
        } // if (pTransferContext -> RemainingTransferLength > 0)

        DebugTrace(TRACE_STATUS,("USTransferComplete: Completing transfer request. nbytes transferred = %d, irp = 0x%p\n",
                                   pTransferContext -> NBytesTransferred, pIrp));

        pIrp -> IoStatus.Information = pTransferContext -> NBytesTransferred;

#if DBG
        {
            PUCHAR  pDumpBuf = NULL;

            if(NULL != pTransferContext -> pTransferBuffer){
                pDumpBuf = pTransferContext -> pTransferBuffer;
            } else if (NULL != pTransferContext -> pTransferMdl) {
                pTransferContext -> pTransferMdl ->MdlFlags |= MDL_MAPPING_CAN_FAIL;
                pDumpBuf = MmGetSystemAddressForMdl(pTransferContext -> pTransferMdl);
            }

            if(NULL != pDumpBuf){
                MyDumpMemory(pDumpBuf,
                             pTransferContext -> NBytesTransferred,
                             TRUE);
            }
        }
#endif // DBG

    } else {

        DebugTrace(TRACE_ERROR,("USTransferComplete: ERROR!! Transfer error. USB status = 0x%X, status = 0x%X\n",
                                    CompletedTransferStatus, 
                                    Status));
        if (USBD_STATUS_CANCELED == CompletedTransferStatus) {
            Status = STATUS_CANCELLED;
        }
    }

    //
    // Running here means IRP is completed.
    //

    pIrp -> IoStatus.Status = Status;

    if (pTransferContext -> fNextReadBlocked) {
        KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
    }

    //
    // Dequeue timer object if exist.
    //

    if( (0 != pTransferContext -> Timeout.QuadPart)
     && (!KeReadStateTimer(&(pTransferContext->Timer))) )
    {
        KeCancelTimer(&(pTransferContext->Timer));
    }

    //
    // Clean-up
    //

    if(pTransferContext->pUrb){
        USFreePool(pTransferContext->pUrb);
    }
    USDecrementIoCount(pTransferContext->pDeviceObject);
    USFreePool(pTransferContext);

USTransferComplete_return:
    DebugTrace(TRACE_PROC_LEAVE,("USTransferComplete: Leaving.. Status=%x.\n", Status));
    return Status;
}


ULONG
USGetPipeIndexToUse(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp,
    IN ULONG                PipeIndex
)
/*++

Routine Description:

Arguments:
    pDeviceObject    - Device object for a device.
    pIrp             - request packet
    PipeIndex        - Default pipe to use

Return Value:
    ULONG - PipeIndex to use

--*/
{
    PIO_STACK_LOCATION          pIrpStack;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PFILE_OBJECT                fileObject;
    PUSBSCAN_FILE_CONTEXT       pFileContext;
    LONG                        StoredIndex;
    ULONG                       IndexToUse;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USGetPipeIndexToUse: Enter..\n"));

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    pIrpStack       = IoGetCurrentIrpStackLocation (pIrp);
    fileObject      = pIrpStack->FileObject;
    pFileContext    = fileObject->FsContext;

    ASSERT(NULL != pFileContext);

    StoredIndex     = pFileContext->PipeIndex;

    if( (StoredIndex >= 0) && (StoredIndex < MAX_NUM_PIPES) ){
        if(pde->PipeInfo[PipeIndex].PipeType == pde->PipeInfo[StoredIndex].PipeType){
            IndexToUse = (ULONG)StoredIndex;
        } else {
            IndexToUse = PipeIndex;
        }
    } else {
        if(-1 != StoredIndex){
            DebugTrace(TRACE_WARNING,("USGetPipeIndexToUse: WARINING!! Specified pipe index(0x%X) is incorrect. Using default." ,StoredIndex));
        }
        IndexToUse = PipeIndex;
    }
    DebugTrace(TRACE_PROC_LEAVE,("USGetPipeIndexToUse: Leaving.. passed=%d, returning=%d.\n",PipeIndex, IndexToUse));
    return IndexToUse;
}

VOID
USTimerDpc(
    IN PKDPC    pDpc,
    IN PVOID    pIrp,
    IN PVOID    SystemArgument1,
    IN PVOID    SystemArgument2
    )
/*++

Routine Description:

DPC callback routine for timer.

Arguments:
    pDpc            -   Pointer to DPC object.
    pIrp            -   Passed context.
    SystemArgument1 -   system reserved.
    SystemArgument2 -   system reserved.

Return Value:
    VOID

--*/
{
    DebugTrace(TRACE_WARNING,("USTimerDpc: IRP(0x%x) timeout.\n", pIrp));
    IoCancelIrp((PIRP)pIrp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\usbscan\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   byronc, coopp, keisuket, vlads
#
#Date:
#   2-Feb-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     StillImage kernel mode driver
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=usbscan
TARGETTYPE=DRIVER
TARGETPATH=$(OBJ_DIR)

TARGETLIBS=$(DDK_LIB_PATH)\usbd.lib

SOURCES= ..\usbscan.c \
         ..\ocrw.c  \
         ..\ioctl.c \
         ..\power.c \
         ..\usbscan.rc \
         ..\debug.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\usbscn9x\debug.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2001

Module Name:

    debug.c

Abstract:

    Common code for debugging.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//
// Includes
//

#include "stddef.h"
#include "wdm.h"
#include "debug.h"

//
// Globals
//

ULONG   DebugTraceLevel = MIN_TRACE | DEBUG_FLAG_DISABLE;
// ULONG  DebugTraceLevel = MAX_TRACE | DEBUG_FLAG_DISABLE | TRACE_PROC_ENTER | TRACE_PROC_LEAVE;
LONG    AllocateCount = 0;
ULONG   DebugDumpMax    = MAX_DUMPSIZE;

PVOID
MyAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG     ulNumberOfBytes
)
/*++

Routine Description:

    Wrapper for pool allocation. Use tag to avoid heap corruption.

Arguments:

    PoolType - type of pool memory to allocate
    ulNumberOfBytes - number of bytes to allocate

Return Value:

    Pointer to the allocated memory

--*/
{
    PVOID pvRet;

    DebugTrace(TRACE_PROC_ENTER,("MyAllocatePool: Enter.. Size = %d\n", ulNumberOfBytes));

    pvRet = ExAllocatePoolWithTag(PoolType,
                                  ulNumberOfBytes,
                                  NAME_POOLTAG);

#if DBG
    if(NULL == pvRet){
        DebugTrace(TRACE_ERROR,("MyAllocatePool: ERROR!! Cannot allocate pool.\n"));
    } else {
        if(++AllocateCount > MAXNUM_POOL){
            DebugTrace(TRACE_WARNING,("MyAllocatePool: WARNING!! Allocate called %dtimes more than Free\n", MAXNUM_POOL));
        }
        DebugTrace(TRACE_STATUS,("MyAllocatePool: Count = %d\n", AllocateCount));
    }
#endif // DBG

    DebugTrace(TRACE_PROC_LEAVE,("MyAllocatePool: Leaving.. pvRet = %x\n", pvRet));
    return pvRet;
}


VOID
MyFreePool(
    IN PVOID     pvAddress
)
/*++

Routine Description:

    Wrapper for pool free. Check tag to avoid heap corruption

Arguments:

    pvAddress - Pointer to the allocated memory

Return Value:

    none.

--*/
{

    DebugTrace(TRACE_PROC_ENTER,("USFreePool: Enter..\n"));

#if DBG
    {
        ULONG ulTag;
    
        ulTag = *((PULONG)pvAddress-1);
//        if( (NAME_POOLTAG == ulTag) || (DebugTraceLevel & TRACE_IGNORE_TAG) ){
        if(NAME_POOLTAG == ulTag){
            if(--AllocateCount < 0){
                DebugTrace(TRACE_WARNING,("MyFreePool: Warning!! Free called more than Allocate.\n"));
            }
        } else {
            DebugTrace(TRACE_WARNING,("MyFreePool: WARNING!! tag = %c%c%c%c\n",
                                        ((PUCHAR)&ulTag)[0],
                                        ((PUCHAR)&ulTag)[1],
                                        ((PUCHAR)&ulTag)[2],
                                        ((PUCHAR)&ulTag)[3]  ));
        }
    }
#endif

    ExFreePool(pvAddress);

    DebugTrace(TRACE_PROC_LEAVE,("MyFreePool: Leaving.. Return = NONE\n"));
}


#if DBG
VOID
MyDebugInit(
    IN  PUNICODE_STRING pRegistryPath
)
/*++

Routine Description:

    Read DebugTraceLevel key from driver's registry if exists.

Arguments:

    pRegistryPath   -   pointer to a unicode string representing the path
                        to driver-specific key in the registry

Return Value:

    none.

--*/
{

    HANDLE                          hDriverRegistry;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    UNICODE_STRING                  unicodeKeyName;
    ULONG                           DataSize;
    PKEY_VALUE_PARTIAL_INFORMATION  pValueInfo;
    NTSTATUS                        Status;
    
    DebugTrace(TRACE_PROC_ENTER,("MyDebugInit: Enter... \n"));
    
    //
    // Initialize local variables.
    //
    
    Status          = STATUS_SUCCESS;
    hDriverRegistry = NULL;
    pValueInfo      = NULL;
    DataSize        = 0;

    //
    // Initialize object attribute and open registry key.
    //
    
    RtlZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));
    InitializeObjectAttributes(&ObjectAttributes,
                               pRegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    
    Status = ZwOpenKey(&hDriverRegistry,
                       KEY_READ,
                       &ObjectAttributes);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR,("MyDebugInit: ERROR!! Can't open driver registry key.\n"));
        goto MyDebugInit_return;
    }
    
    //
    // Read "DebugTraceLevel" key.
    //

    DebugTrace(TRACE_CRITICAL,("MyDebugInit: Query %wZ\\%ws.\n", pRegistryPath, REG_DEBUGLEVEL));

    //
    // Query required size.
    //
    
    RtlInitUnicodeString(&unicodeKeyName, REG_DEBUGLEVEL);
    Status = ZwQueryValueKey(hDriverRegistry,
                             &unicodeKeyName,
                             KeyValuePartialInformation,
                             NULL,
                             0,
                             &DataSize);
    if( (Status != STATUS_BUFFER_OVERFLOW)
     && (Status != STATUS_BUFFER_TOO_SMALL)
     && (Status != STATUS_SUCCESS) )
    {
        if(Status == STATUS_OBJECT_NAME_NOT_FOUND){
            DebugTrace(TRACE_STATUS,("MyDebugInit: DebugTraceLevel doesn't exist. Use default(0x%x).\n", DebugTraceLevel));
        } else {
            DebugTrace(TRACE_ERROR,("MyDebugInit: ERROR!! ZwQueryValueKey failed. Status=0x%x\n", Status));
        }
        goto MyDebugInit_return;
    }
    
    //
    // Check size of data.
    //
    
    if (MAX_TEMPBUF < DataSize) {
        DebugTrace(TRACE_ERROR, ("MyDebugInit: ERROR!! DataSize (0x%x) is too big.\n", DataSize));
        goto MyDebugInit_return;
    }

    if (0 == DataSize) {
        DebugTrace(TRACE_ERROR, ("MyDebugInit: ERROR!! Cannot retrieve required data size.\n"));
        goto MyDebugInit_return;
    }

    //
    // Allocate memory for temp buffer. size +2 for NULL.
    //

    pValueInfo = MyAllocatePool(NonPagedPool, DataSize+2);
    if(NULL == pValueInfo){
        DebugTrace(TRACE_CRITICAL, ("MyDebugInit: ERROR!! Buffer allocate failed.\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto MyDebugInit_return;
    }
    RtlZeroMemory(pValueInfo, DataSize+2);

    //
    // Query specified value.
    //
    
    Status = ZwQueryValueKey(hDriverRegistry,
                             &unicodeKeyName,
                             KeyValuePartialInformation,
                             pValueInfo,
                             DataSize,
                             &DataSize);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR, ("MyDebugInit: ERROR!! ZwQueryValueKey failed.\n"));
        goto MyDebugInit_return;
    }
    
    //
    // Set DebugTraceLevel.
    //
    
    DebugTraceLevel = *((PULONG)pValueInfo->Data);
    DebugTrace(TRACE_CRITICAL, ("MyDebugInit: Reg-key found. DebugTraceLevel=0x%x.\n", *((PULONG)pValueInfo->Data)));

MyDebugInit_return:

    //
    // Clean up.
    //
    
    if(pValueInfo){
        MyFreePool(pValueInfo);
    }
    
    if(NULL != hDriverRegistry){
        ZwClose(hDriverRegistry);
    }

    DebugTrace(TRACE_PROC_LEAVE,("MyDebugInit: Leaving... Status=0x%x, Ret=VOID.\n", Status));
    return;
}

VOID
MyDumpMemory(
    PUCHAR  pDumpBuffer,
    ULONG   dwSize,
    BOOLEAN bRead
)
{
    NTSTATUS    Status;
    ULONG       ulCounter;
    ULONG       ulMaxSize;

    //
    // Check the flag first.
    //

    if(bRead){
        if(!(DebugTraceLevel & TRACE_FLAG_DUMP_READ)){
            return;
        }
    } else { // if(bRead)
        if(!(DebugTraceLevel & TRACE_FLAG_DUMP_WRITE)){
            return;
        }
    } // if(bRead)

    DebugTrace(TRACE_PROC_ENTER,("MyDebugDump: Enter... \n"));
        
    //
    // Initialize local.
    //
        
    Status          = STATUS_SUCCESS;
    ulCounter       = 0;
    ulMaxSize       = DebugDumpMax;
    
    //
    // Check the arguments.
    //
        
    if(NULL == pDumpBuffer){
        DebugTrace(TRACE_WARNING,("MyDebugDump: WARNING!! pDumpBuffer = NULL \n"));
        Status = STATUS_INVALID_PARAMETER_1;
        goto MyDumpMemory_return;
    }

    if(0 == dwSize){
        DebugTrace(TRACE_STATUS,("MyDebugDump: WARNING!! dwSize = 0 \n"));
        Status = STATUS_INVALID_PARAMETER_2;
        goto MyDumpMemory_return;
    }

    if(bRead){
        DebugTrace(TRACE_ERROR,("MyDebugDump: Received buffer. Size=0x%x.\n", dwSize));
    } else {
        DebugTrace(TRACE_ERROR,("MyDebugDump: Passing buffer. Size=0x%x.\n", dwSize));
    }

/*
    //
    // Probe the buffer.
    //

    try {
        ProbeForRead(pDumpBuffer,
                     dwSize,
                     sizeof(UCHAR));
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        DebugTrace(TRACE_ERROR,("MyDebugDump: Buffer pointer (0x%x) is invalid. Status=0x%x\n", pDumpBuffer, Status));
        goto MyDumpMemory_return;
    } // except
*/
    //
    // Max dump size = 1k;
    //
    
    ulMaxSize = min(ulMaxSize , dwSize);

    //
    // Dump the buffer.
    //
    
    for(ulCounter = 0; ulCounter < ulMaxSize; ulCounter++){
        if(0 == (ulCounter & 0xfF)){
            DbgPrint("\n");
            DbgPrint(NAME_DRIVER);
            DbgPrint("           +0 +1 +2 +3 +4 +5 +6 +7   +8 +9 +a +b +c +d +e +f\n");
            DbgPrint(NAME_DRIVER);
            DbgPrint("------------------------------------------------------------\n");
        }

        if(0 == (ulCounter & 0xf)){
            DbgPrint(NAME_DRIVER);
            DbgPrint("%p :", pDumpBuffer+ulCounter);
        }

        DbgPrint(" %02x", *(pDumpBuffer+ulCounter));

        if(0x7 == (ulCounter & 0xf)){
            DbgPrint(" -");
        }

        if(0xf == (ulCounter & 0xf)){
            DbgPrint("\n");
        }
    }

    DbgPrint("\n");
    DbgPrint(NAME_DRIVER);
    DbgPrint("------------------------------------------------------------\n\n");

MyDumpMemory_return:
    DebugTrace(TRACE_PROC_LEAVE,("MyDebugDump: Leaving... Status=0x%x, Ret=VOID.\n", Status));
    return;

} // MyDumpMemory(

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\usbscan\usbd_api.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    usbd_api.h

Abstract:
Function prototype and definition used to build USB request.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "usbdi.h"
#include "usbdlib.h"


#define OPCODE_SEQ_TRANSFER             0x00    // 00000000b
#define OPCODE_SINGLE_ADDR_TRANSFER     0x08    // 00001000b
#define REGISTER_AREA                   0x04
#define BLOCK                           TRUE
#define DONT_BLOCK                      FALSE

//
// Macros for building URB requests
//

#define UsbBuildSetFeatureDeviceRequest(        \
urb,                                            \
length,                                         \
link,                                           \
featureSelector,                                \
index) {                                        \
       (urb)->UrbHeader.Function =  URB_FUNCTION_SET_FEATURE_TO_DEVICE;     \
       (urb)->UrbHeader.Length = (length);                                  \
       (urb)->UrbControlFeatureRequest.UrbLink = (link);                    \
       (urb)->UrbControlFeatureRequest.FeatureSelector = (featureSelector); \
       (urb)->UrbControlFeatureRequest.Index = (index);                     \
}

#define UsbBuildAbortPipeRequest(               \
urb,                                            \
length,                                         \
handle) {                                       \
        (urb)->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;    \
        (urb)->UrbHeader.Length = (USHORT)length;               \
        (urb)->UrbPipeRequest.PipeHandle = handle;              \
}

#define UsbBuildResetPipeRequest(               \
urb,                                            \
length,                                         \
handle) {                                       \
        (urb)->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;    \
        (urb)->UrbHeader.Length = (USHORT)length;               \
        (urb)->UrbPipeRequest.PipeHandle = handle;              \
}

#define UsbBuildVendorClassSpecificCommand(     \
urb,                                            \
transferFlags,                                  \
bufLength,                                      \
transferBuf,                                    \
transferMdl,                                    \
requestType,                                    \
request,                                        \
value,                                          \
index ) {                                       \
        (urb)->UrbHeader.Function = URB_FUNCTION_VENDOR_DEVICE;                         \
        (urb)->UrbHeader.Length = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);  \
        (urb)->UrbControlVendorClassRequest.TransferFlags = transferFlags;              \
        (urb)->UrbControlVendorClassRequest.TransferBufferLength = bufLength;           \
        (urb)->UrbControlVendorClassRequest.TransferBuffer = transferBuf;               \
        (urb)->UrbControlVendorClassRequest.TransferBufferMDL = transferMdl;            \
        (urb)->UrbControlVendorClassRequest.RequestTypeReservedBits = requestType;      \
        (urb)->UrbControlVendorClassRequest.Request = request;                          \
        (urb)->UrbControlVendorClassRequest.Value = value;                              \
        (urb)->UrbControlVendorClassRequest.Index = index;                              \
}

#define UsbBuildVendorClassSpecificCommandPTP(  \
command,                                        \
urb,                                            \
transferFlags,                                  \
bufLength,                                      \
transferBuf,                                    \
transferMdl,                                    \
requestType,                                    \
request,                                        \
value,                                          \
index ) {                                       \
        (urb)->UrbHeader.Function = command;                                            \
        (urb)->UrbHeader.Length = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);  \
        (urb)->UrbControlVendorClassRequest.TransferFlags = transferFlags;              \
        (urb)->UrbControlVendorClassRequest.TransferBufferLength = bufLength;           \
        (urb)->UrbControlVendorClassRequest.TransferBuffer = transferBuf;               \
        (urb)->UrbControlVendorClassRequest.TransferBufferMDL = transferMdl;            \
        (urb)->UrbControlVendorClassRequest.RequestTypeReservedBits = requestType;      \
        (urb)->UrbControlVendorClassRequest.Request = request;                          \
        (urb)->UrbControlVendorClassRequest.Value = value;                              \
        (urb)->UrbControlVendorClassRequest.Index = index;                              \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\usbscan\usbscan.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    usbscan.c

Abstract:

Author:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include <wdm.h>
#include <stdio.h>
#include <usbscan.h>
#include <usbd_api.h>
#include "private.h"
#include <initguid.h>
#include <devguid.h>


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, USPnpAddDevice)
#pragma alloc_text(PAGE, USPnp)
#pragma alloc_text(PAGE, USCreateSymbolicLink)
#pragma alloc_text(PAGE, USDestroySymbolicLink)
#pragma alloc_text(PAGE, USGetUSBDeviceDescriptor)
#pragma alloc_text(PAGE, USConfigureDevice)
#pragma alloc_text(PAGE, USUnConfigureDevice)
#pragma alloc_text(PAGE, USUnload)
#endif

// Globals

ULONG NextDeviceInstance = 0;

#if DBG
ULONG USBSCAN_DebugTraceLevel = MIN_TRACE;
ULONG USBSCAN_PnPTest = 0;
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT pDriverObject,
    IN PUNICODE_STRING pRegistryPath
)
{
/*++

   Routine Description:
   Installable driver initialization entry point.
   This is where the driver is called when the driver is being loaded
   by the I/O system.

   Arguments:
   DriverObject - pointer to the driver object
   RegistryPath - pointer to a unicode string representing the path
   to driver-specific key in the registry

   Return Value:
   STATUS_SUCCESS       if successful,
   STATUS_UNSUCCESSFUL  otherwise

   -- */

    NTSTATUS    Status;
    
    PAGED_CODE();

    DebugTrace((MIN_TRACE | TRACE_FLAG_PROC),("DriverEntry called. Driver reg=%wZ\n",pRegistryPath));

    //
    // Initialize local.
    //

    Status = STATUS_SUCCESS;

    //
    // Check arguments.
    //
    
    if( (NULL == pDriverObject)
     || (NULL == pRegistryPath) )
    {
        DebugTrace(TRACE_ERROR,("DriverEntry: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto DriverEntry_return;
    }

#if DBG
    MyDebugInit(pRegistryPath);
#endif // DBG

    pDriverObject -> MajorFunction[IRP_MJ_READ]            = USRead;
    pDriverObject -> MajorFunction[IRP_MJ_WRITE]           = USWrite;
    pDriverObject -> MajorFunction[IRP_MJ_DEVICE_CONTROL]  = USDeviceControl;
    pDriverObject -> MajorFunction[IRP_MJ_CREATE]          = USOpen;
    pDriverObject -> MajorFunction[IRP_MJ_CLOSE]           = USClose;
    pDriverObject -> MajorFunction[IRP_MJ_PNP_POWER]       = USPnp;
    pDriverObject -> MajorFunction[IRP_MJ_FLUSH_BUFFERS]   = USFlush;
    pDriverObject -> MajorFunction[IRP_MJ_POWER]           = USPower;
    pDriverObject -> MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = USPnp;
    pDriverObject -> DriverExtension -> AddDevice          = USPnpAddDevice;
    pDriverObject -> DriverUnload                          = USUnload;

DriverEntry_return:

    return Status;
}

NTSTATUS
USPnpAddDevice(
    IN PDRIVER_OBJECT pDriverObject,
    IN OUT PDEVICE_OBJECT pPhysicalDeviceObject
)

/*++

Routine Description:

    This routine is called to create a new instance of the device.

Arguments:

    pDriverObject - pointer to the driver object for this instance of SS
    pPhysicalDeviceObject - pointer to the device object that represents the scanner
    on the scsi bus.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    UCHAR                       aName[64];
    ANSI_STRING                 ansiName;
    UNICODE_STRING              uName;
    PDEVICE_OBJECT              pDeviceObject = NULL;
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USPnpAddDevice: Enter..\n"));

    //
    // Initialize local.
    //
    
    RtlZeroMemory(&uName, sizeof(uName));

    //
    // Check arguments.
    //

    if( (NULL == pDriverObject)
     || (NULL == pPhysicalDeviceObject) )
    {
        DebugTrace(TRACE_ERROR,("USPnpAddDevice: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("USPnpAddDevice: Leaving.. Status = %x.\n", Status));
        return Status;
    }

    //
    // Create the Functional Device Object (FDO) for this device.
    //

    _snprintf(aName, ARRAYSIZE(aName), "\\Device\\Usbscan%d",NextDeviceInstance);
    aName[ARRAYSIZE(aName)-1] = '\0';
    RtlInitAnsiString(&ansiName, aName);

    //
    // Show device object name.
    //

    DebugTrace(TRACE_STATUS,("USPnpAddDevice: Create device object %s\n", aName));

    //
    // Allocates Unicode string.
    //

    Status = RtlAnsiStringToUnicodeString(&uName, &ansiName, TRUE);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_CRITICAL,("USPnpAddDevice: ERROR!! Can't alloc buffer for Unicode\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USPnpAddDevice_return;
    }

    //
    // Create device object for this scanner.
    //

    Status = IoCreateDevice(pDriverObject,
                            sizeof(USBSCAN_DEVICE_EXTENSION),
                            &uName,
                            FILE_DEVICE_SCANNER,
                            0,
                            FALSE,
                            &pDeviceObject);

    if (!NT_SUCCESS(Status)) {
        DebugTrace(TRACE_ERROR,("USPnpAddDevice: ERROR!! Can't create device object\n"));
        DEBUG_BREAKPOINT();
        goto USPnpAddDevice_return;
    }

    //
    // Device object was successfully created.
    // Free Unicode string used for device creation.
    //

    RtlFreeUnicodeString(&uName);
    uName.Buffer = NULL;

    //
    // Initialize Device Extension.
    //

    pde = (PUSBSCAN_DEVICE_EXTENSION)(pDeviceObject -> DeviceExtension);
    RtlZeroMemory(pde, sizeof(USBSCAN_DEVICE_EXTENSION));

    //
    // Initialize PendingIoEvent.  Set the number of pending i/o requests for this device to 1.
    // When this number falls to zero, it is okay to remove, or stop the device.
    //

    pde -> PendingIoCount = 0;
    pde -> Stopped = FALSE;
    KeInitializeEvent(&pde -> PendingIoEvent, NotificationEvent, FALSE);

    //
    // Indicate that IRPs should include MDLs.
    //

    pDeviceObject->Flags |= DO_DIRECT_IO;

    //
    // indicate our power code is pagable
    //

    pDeviceObject->Flags |= DO_POWER_PAGABLE;

    //
    // Attach our new FDO to the PDO (Physical Device Object).
    //

    pde -> pStackDeviceObject = IoAttachDeviceToDeviceStack(pDeviceObject,
                                                            pPhysicalDeviceObject);
    if (NULL == pde -> pStackDeviceObject) {
        DebugTrace(TRACE_ERROR,("USPnpAddDevice: ERROR!! Cannot attach FDO to PDO.\n"));
        DEBUG_BREAKPOINT();
        IoDeleteDevice( pDeviceObject );
        Status = STATUS_NOT_SUPPORTED;
        goto USPnpAddDevice_return;
    }

    //
    // Remember the PDO in our device extension.
    //

    pde -> pPhysicalDeviceObject = pPhysicalDeviceObject;

    //
    // Remember the DeviceInstance number.
    //

    pde -> DeviceInstance = NextDeviceInstance;

    //
    // Handle exporting interface
    //

    Status = UsbScanHandleInterface(
        pPhysicalDeviceObject,
        &pde->InterfaceNameString,
        TRUE
        );

    //
    // Each time AddDevice gets called, we advance the global DeviceInstance variable.
    //

    NextDeviceInstance++;

    //
    // Set initial device power state as online.
    //

    pde -> CurrentDevicePowerState = PowerDeviceD0;

    //
    // Finish initializing.
    //

    pDeviceObject -> Flags &= ~DO_DEVICE_INITIALIZING;

USPnpAddDevice_return:

    if(NULL != uName.Buffer){
        RtlFreeUnicodeString(&uName);
    }

    DebugTrace(TRACE_PROC_LEAVE,("USPnpAddDevice: Leaving.. Status = 0x%x\n", Status));
    return Status;

} // end USAddDevice()


NTSTATUS USPnp(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
)
/*++

Routine Description:

    This routine handles all PNP irps.

Arguments:

    pDeviceObject - represents a scanner device
    pIrp - PNP irp

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PIO_STACK_LOCATION          pIrpStack;
    KEVENT                      event;
    PDEVICE_CAPABILITIES        pCaps;
    ULONG                       bTemp;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USPnp: Enter..\n"));

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("USPnp: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("USPnp: Leaving.. Status = %x.\n", Status));
        return Status;
    }

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    Status = pIrp -> IoStatus.Status;

//  DbgPrint("USPnP: Major=0x%x, Minor=0x%x\n",
//           pIrpStack -> MajorFunction,
//           pIrpStack->MinorFunction);

    switch (pIrpStack -> MajorFunction) {

        case IRP_MJ_SYSTEM_CONTROL:
            DebugTrace(TRACE_STATUS,("USPnp: IRP_MJ_SYSTEM_CONTROL\n"));

            //
            // Simply passing down the IRP.
            //

            DebugTrace(TRACE_STATUS,("USPnp: Simply passing down the IRP\n"));

            IoCopyCurrentIrpStackLocationToNext( pIrp );
            Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);
            break;

        case IRP_MJ_PNP:
            DebugTrace(TRACE_STATUS,("USPnp: IRP_MJ_PNP\n"));
            switch (pIrpStack->MinorFunction) {

                case IRP_MN_QUERY_CAPABILITIES:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MJ_QUERY_CAPS\n"));

                    //
                    // Call downlevel driver first to fill capabilities structure
                    // Then add our specific capabilities
                    //

                    DebugTrace(TRACE_STATUS,("USPnp: Call down to get capabilities\n"));

                    pIrp->IoStatus.Status = STATUS_SUCCESS;
                    Status = USCallNextDriverSynch(pde, pIrp);

                    if(!NT_SUCCESS(Status)){
                        DebugTrace(TRACE_ERROR,("USPnp: ERROR!! Call down failed. Status=0x%x\n", Status));
                        IoCompleteRequest( pIrp, IO_NO_INCREMENT );
                        goto USPnP_return;
                    }

                    //
                    // Set SurpriseRemoval OK
                    //

                    pCaps = pIrpStack -> Parameters.DeviceCapabilities.Capabilities;
                    pCaps->SurpriseRemovalOK = TRUE;
                    pCaps->Removable = TRUE;

                    //
                    // Set returning status.
                    //

                    Status = STATUS_SUCCESS;
                    pIrp -> IoStatus.Status = Status;
                    pIrp -> IoStatus.Information = 0;

                    IoCompleteRequest( pIrp, IO_NO_INCREMENT );
                    goto USPnP_return;

                    break;


                case IRP_MN_START_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MJ_START_DEVICE\n"));

                    pde -> Stopped = FALSE;
                    USIncrementIoCount(pDeviceObject);

                    //
                    // First, let the port driver start the device.
                    //

                    Status = USCallNextDriverSynch(pde, pIrp);
                    if(!NT_SUCCESS(Status)){

                        //
                        // Lower layer failed to start device.
                        //

                        DebugTrace(TRACE_ERROR,("USPnp: ERROR!! Lower layer failed to start device. Status=0x%x\n", Status));
                        break;
                    }

                    //
                    // The port driver has started the device.  It is time for
                    // us to do some initialization and create symbolic links
                    // for the device.
                    //
                    // Get the device descriptor and save it in our
                    // device extension.
                    //

                    Status = USGetUSBDeviceDescriptor(pDeviceObject);
                    if(!NT_SUCCESS(Status)){

                        //
                        // GetDescriptor failed.
                        //

                        DebugTrace(TRACE_ERROR,("USPnp: ERROR!! Cannot get DeviceDescriptor.\n"));
                        DEBUG_BREAKPOINT();
                        break;
                    }

                    //
                    // Configure the device.
                    //

                    Status = USConfigureDevice(pDeviceObject);
#if DBG
                    //DEBUG_BREAKPOINT();
                    if (USBSCAN_PnPTest) {
                        Status = STATUS_UNSUCCESSFUL;
                    }
#endif

                    if (!NT_SUCCESS(Status)) {
                        DebugTrace(TRACE_ERROR,("USPnp: ERROR!! Can't configure the device.\n"));
                        DEBUG_BREAKPOINT();
                        break;
                    }

                    //
                    // Create the symbolic link for this device.
                    //

                    Status = USCreateSymbolicLink( pde );
#if DBG
                    //DEBUG_BREAKPOINT();
                    if (USBSCAN_PnPTest) {
                        Status = STATUS_UNSUCCESSFUL;
                    }
#endif
                    if (!NT_SUCCESS(Status)) {
                        DebugTrace(TRACE_ERROR, ("USPnp: ERROR!! Can't create symbolic link.\n"));
                        DEBUG_BREAKPOINT();
                        break;
                    }

                    //
                    // Initialize the synchronize read event.  This event is used the serialze
                    // i/o requests to the read pipe if the request size is NOT a usb packet multiple.
                    //

                    {
                        ULONG i;
                        for(i = 0; i < pde->NumberOfPipes; i++){
                            if( (pde->PipeInfo[i].PipeType == UsbdPipeTypeBulk)
                             && (pde->PipeInfo[i].EndpointAddress & BULKIN_FLAG) )
                            {
                                DebugTrace(TRACE_STATUS,("USPnp: Initializing event for Pipe[%d]\n", i));
                                KeInitializeEvent(&pde -> ReadPipeBuffer[i].ReadSyncEvent, SynchronizationEvent, TRUE);
                            }
                        }
                    }

                    //
                    // Indicate device is now ready.
                    //

                    pde -> AcceptingRequests = TRUE;

                    //
                    // Set return status.
                    //

                    pIrp -> IoStatus.Status = Status;
                    pIrp -> IoStatus.Information = 0;

                    IoCompleteRequest( pIrp, IO_NO_INCREMENT );
                    goto USPnP_return;

                case IRP_MN_REMOVE_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_REMOVE_DEVICE\n"));

                    //
                    // Prohivit further request.
                    //

                    bTemp = (ULONG)InterlockedExchange((PULONG)&(pde -> AcceptingRequests),
                                                       (LONG)FALSE );

                    //
                    // Wait for any io requests pending in our driver to
                    // complete before proceeding the remove.
                    //

                    if (!pde -> Stopped ) {
                        USDecrementIoCount(pDeviceObject);
                    }

                    KeWaitForSingleObject(&pde -> PendingIoEvent,
                                          Suspended,
                                          KernelMode,
                                          FALSE,NULL);

                    //
                    // Is this device stopped/removed before?
                    //

                    if (bTemp) {

                        //
                        // Delete symbolic link.
                        //

                        USDestroySymbolicLink( pde );

                        //
                        // Abort all pipes.
                        //

                        USCancelPipe(pDeviceObject, NULL, ALL_PIPE, TRUE);
                    }

                    //
                    // Disable device interface.
                    //

                    UsbScanHandleInterface(pde->pPhysicalDeviceObject,
                                           &pde->InterfaceNameString,
                                           FALSE);

                    //
                    // Forward remove message to lower driver.
                    //

                    IoCopyCurrentIrpStackLocationToNext(pIrp);
                    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

                    //
                    // Free allocated memory.
                    //

                    if (pde -> pDeviceDescriptor) {
                        USFreePool(pde -> pDeviceDescriptor);
                        pde -> pDeviceDescriptor = NULL;
                    }

                    if (pde -> pConfigurationDescriptor) {
                        USFreePool(pde -> pConfigurationDescriptor);
                        pde -> pConfigurationDescriptor = NULL;
                    }

                    //
                    // Free allocated buffer(s)
                    //
                    {
                        ULONG i;
                        for(i = 0; i < pde->NumberOfPipes; i++){
                            if(pde->ReadPipeBuffer[i].pStartBuffer){
                                USFreePool(pde->ReadPipeBuffer[i].pStartBuffer);
                                pde->ReadPipeBuffer[i].pStartBuffer = NULL;
                                pde->ReadPipeBuffer[i].pBuffer = NULL;
                            }
                        }
                    }

                    //
                    // Detatch device object from stack.
                    //

                    IoDetachDevice(pde -> pStackDeviceObject);

                    //
                    // Delete device object
                    //

                    IoDeleteDevice (pDeviceObject);
                    pDeviceObject = NULL;

                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_REMOVE_DEVICE complete\n"));
                    goto USPnP_return;

                case IRP_MN_STOP_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_STOP_DEVICE\n"));

                    //
                    // Indicate device is stopped.
                    //

                    pde -> Stopped = TRUE;
                    bTemp = (ULONG)InterlockedExchange((PULONG)&(pde -> AcceptingRequests),
                                                       (LONG)FALSE );

                    if (bTemp) {

                        //
                        // Delete symbolic link.
                        //

                        USDestroySymbolicLink( pde );

                        //
                        // Abort all pipes.
                        //

                        USCancelPipe(pDeviceObject, NULL, ALL_PIPE, TRUE);

                        //
                        // Set device into unconfigured state.
                        //

                        USUnConfigureDevice(pDeviceObject);

                    } //(pde -> AcceptingRequests)

#ifndef _CHICAGO_
                    //
                    // Disable device interface.
                    //

                    if (pde->InterfaceNameString.Buffer != NULL) {
                        IoSetDeviceInterfaceState(&pde->InterfaceNameString,FALSE);
                    }
#endif // _CHICAGO_

                    //
                    // Let the port driver stop the device.
                    //

                    IoCopyCurrentIrpStackLocationToNext(pIrp);
                    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

                    //
                    // wait for any io requests pending in our driver to
                    // complete before finishing the remove
                    //

                    USDecrementIoCount(pDeviceObject);
                    KeWaitForSingleObject(&pde -> PendingIoEvent, Suspended, KernelMode,
                                          FALSE,NULL);

                    ASSERT(pde -> pDeviceDescriptor);
                    ASSERT(pde -> pConfigurationDescriptor);

                    if (pde -> pDeviceDescriptor) {
                        USFreePool(pde -> pDeviceDescriptor);
                        pde -> pDeviceDescriptor = NULL;
                    }

                    if (pde -> pConfigurationDescriptor) {
                        USFreePool(pde -> pConfigurationDescriptor);
                        pde -> pConfigurationDescriptor = NULL;
                    }

                    //
                    // Free allocated buffer(s)
                    //
                    {
                        ULONG i;
                        for(i = 0; i < pde->NumberOfPipes; i++){
                            if(pde->ReadPipeBuffer[i].pBuffer){
                                USFreePool(pde->ReadPipeBuffer[i].pBuffer);
                                pde->ReadPipeBuffer[i].pBuffer = NULL;
                            }
                        }
                    }

                    goto USPnP_return;

                case IRP_MN_QUERY_INTERFACE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_INTERFACE\n"));
                    break;

                case IRP_MN_QUERY_RESOURCES:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_RESOURCES\n"));
                    break;

                case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_RESOURCE_REQUIREMENTS\n"));
                    break;

                case IRP_MN_QUERY_DEVICE_TEXT:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_DEVICE_TEXT\n"));
                    break;

//                case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
//                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_LEGACY_BUS_INFORMATION\n"));
//                    break;

                case IRP_MN_QUERY_STOP_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_STOP_DEVICE\n"));
                    break;

                case IRP_MN_QUERY_REMOVE_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_REMOVE_DEVICE\n"));
                    break;

                case IRP_MN_CANCEL_STOP_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_CANCEL_STOP_DEVICE\n"));
                    break;

                case IRP_MN_CANCEL_REMOVE_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_CANCEL_REMOVE_DEVICE\n"));
                    break;

                case IRP_MN_QUERY_DEVICE_RELATIONS:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_DEVICE_RELATIONS\n"));
                    break;

                case IRP_MN_SURPRISE_REMOVAL:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_SURPRISE_REMOVAL\n"));

                    //
                    // Indicate interface is stopped
                    //

                    UsbScanHandleInterface(pde->pPhysicalDeviceObject,
                                           &pde->InterfaceNameString,
                                           FALSE);

                    break;

                default:
                    DebugTrace(TRACE_STATUS,("USPnp: Minor PNP message. MinorFunction = 0x%x\n",pIrpStack->MinorFunction));
                    break;

            } /* case MinorFunction, MajorFunction == IRP_MJ_PNP_POWER  */

            //
            // Passing down IRP
            //

            IoCopyCurrentIrpStackLocationToNext(pIrp);
            Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

            DebugTrace(TRACE_STATUS,("USPnp: Passed Pnp Irp down,  status = %x\n", Status));

            if(!NT_SUCCESS(Status)){
                DebugTrace(TRACE_WARNING,("USPnp: WARNING!! IRP Status failed,  status = %x\n", Status));
                // DEBUG_BREAKPOINT();
            }
            break; // IRP_MJ_PNP

        default:
            DebugTrace(TRACE_STATUS,("USPnp: Major PNP IOCTL not handled\n"));
            Status = STATUS_INVALID_PARAMETER;
            pIrp -> IoStatus.Status = Status;
            IoCompleteRequest( pIrp, IO_NO_INCREMENT );
            goto USPnP_return;

    } /* case MajorFunction */


USPnP_return:
    DebugTrace(TRACE_PROC_LEAVE,("USPnP: Leaving.. Status = 0x%x\n", Status));
    return Status;

} // end USPnp()



NTSTATUS
USCreateSymbolicLink(
    PUSBSCAN_DEVICE_EXTENSION  pde
)
/*++

Routine Description:
    This routine create the symbolic link for the device.

Arguments:
    pde - pointer to device extension

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                      Status;
    UNICODE_STRING                uName;
    UNICODE_STRING                uName2;
    ANSI_STRING                   ansiName;
    CHAR                          aName[64];
    HANDLE                        hSwKey;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USCreateSymbolicLink: Enter..\n"));


    //
    // Initialize
    //

    Status = STATUS_SUCCESS;
    RtlZeroMemory(&uName, sizeof(UNICODE_STRING));
    RtlZeroMemory(&uName2, sizeof(UNICODE_STRING));
    RtlZeroMemory(&ansiName, sizeof(ANSI_STRING));
    hSwKey = NULL;


    //
    // Create the symbolic link for this device.
    //

    _snprintf(aName, ARRAYSIZE(aName), "\\Device\\Usbscan%d",pde -> DeviceInstance);
    aName[ARRAYSIZE(aName)-1] = '\0';
    RtlInitAnsiString(&ansiName, aName);

    Status = RtlAnsiStringToUnicodeString(&uName, &ansiName, TRUE);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_CRITICAL,("USCreateSymbolicLink: ERROR!! Cannot allocate buffer for Unicode srting\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USCreateSymbolicLink_return;
    }

    _snprintf(aName, ARRAYSIZE(aName), "\\DosDevices\\Usbscan%d",pde -> DeviceInstance);
    aName[ARRAYSIZE(aName)-1] = '\0';
    RtlInitAnsiString(&ansiName, aName);

    Status = RtlAnsiStringToUnicodeString(&(pde -> SymbolicLinkName), &ansiName, TRUE);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_CRITICAL,("USCreateSymbolicLink: ERROR!! Cannot allocate buffer for Unicode srting\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USCreateSymbolicLink_return;
    }

    //
    // Create Sympolic link.
    //

    Status = IoCreateSymbolicLink( &(pde -> SymbolicLinkName), &uName );

    RtlFreeUnicodeString( &uName );
    uName.Buffer = NULL;

    if (STATUS_SUCCESS != Status ) {
        DebugTrace(TRACE_ERROR,("USCreateSymbolicLink: ERROR!! Cannot create symbolic link.\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_NOT_SUPPORTED;
        goto USCreateSymbolicLink_return;
    }

    //
    // Now, stuff the symbolic link into the CreateFileName key so that STI can find the device.
    //

    IoOpenDeviceRegistryKey( pde -> pPhysicalDeviceObject,
                             PLUGPLAY_REGKEY_DRIVER, KEY_WRITE, &hSwKey);

    //
    // Create CreateFile name. ("\\.\UsbscanX")
    //

    RtlInitUnicodeString(&uName,USBSCAN_REG_CREATEFILE);    // L"CreateFileName"
    _snprintf(aName, ARRAYSIZE(aName), "%s%d", USBSCAN_OBJECTNAME_A, pde -> DeviceInstance); // "\\\\.\\Usbscan%d"
    aName[ARRAYSIZE(aName)-1] = '\0';
    RtlInitAnsiString(&ansiName, aName);
    Status = RtlAnsiStringToUnicodeString(&uName2, &ansiName, TRUE);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_CRITICAL,("USCreateSymbolicLink: ERROR!! Cannot allocate buffer for Unicode srting\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USCreateSymbolicLink_return;
    }

    //
    // Set CreateFile name to the registry.
    //

    ZwSetValueKey(hSwKey,&uName,0,REG_SZ,uName2.Buffer,uName2.Length);

    //
    // uName is not allocated. Just zero it.
    //

    RtlZeroMemory(&uName, sizeof(UNICODE_STRING));

USCreateSymbolicLink_return:

    if(NULL != hSwKey){
        ZwClose(hSwKey);
    }

    if(NULL != uName.Buffer){
        RtlFreeUnicodeString( &uName );
    }

    if(NULL != uName2.Buffer){
        RtlFreeUnicodeString( &uName2 );
    }

    DebugTrace(TRACE_PROC_LEAVE,("USCreateSymbolicLink: Leaving.. Status = 0x%x\n", Status));
    return Status;

}  // end USCreateSymbolicLink()


NTSTATUS
USDestroySymbolicLink(
    PUSBSCAN_DEVICE_EXTENSION  pde
)
/*++

Routine Description:
    This routine removes the symbolic link for the device.

Arguments:
    pde - pointer to device extension

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    UNICODE_STRING                uName;
    UNICODE_STRING                uName2;
    UNICODE_STRING                uNumber;
    ANSI_STRING                   ansiName;
    CHAR                          aName[64];
    HANDLE                        hSwKey;
    WCHAR                         wsCreateFileName[USBSCAN_MAX_CREATEFILENAME];
    ULONG                         ulBufLength, ulRetLength;
    NTSTATUS                      Status;
    PVOID                         pvNumber;
    ULONG                         ulNumber;
    const WCHAR                   wcsObjectName[] = USBSCAN_OBJECTNAME_W;   // L"\\\\.\\Usbscan"
    ULONG                         uiObjectNameLen = wcslen(wcsObjectName) * sizeof(WCHAR) ;

    PAGED_CODE();


    DebugTrace(TRACE_PROC_ENTER,("USDestroySymbolicLink: Enter..\n"));

    //
    // Delete the symbolic link to this device.
    //

    IoDeleteSymbolicLink( &(pde -> SymbolicLinkName) );

    //
    // Remove the CreateFile name from the s/w key, if it's created by this device object.
    //

    Status = IoOpenDeviceRegistryKey( pde -> pPhysicalDeviceObject,
                                      PLUGPLAY_REGKEY_DRIVER,
                                      KEY_ALL_ACCESS,
                                      &hSwKey);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_ERROR,("USDestroySymbolicLink: ERROR!! IoOpenDeviceRegistryKey Failed\n"));
        DEBUG_BREAKPOINT();
        goto USDestroySymbolicLink_return;
    }

    RtlInitUnicodeString(&uName,USBSCAN_REG_CREATEFILE); // L"CreateFileName"
    memset(aName, 0, sizeof(aName));
    RtlInitAnsiString(&ansiName, aName);
    Status = RtlAnsiStringToUnicodeString(&uName2, &ansiName, TRUE);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_CRITICAL,("USDestroySymbolicLink: ERROR!! Cannot allocate buffer for Unicode srting\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USDestroySymbolicLink_return;
    }

    //
    // Check if this CreateFile name is created by this device object.
    //

    //
    // Query CreateFile name from the registry.
    //

    ulBufLength = sizeof(wsCreateFileName);
    Status = ZwQueryValueKey(hSwKey,
                             &uName,
                             KeyValuePartialInformation,
                             (PVOID)wsCreateFileName,
                             ulBufLength,
                             &ulRetLength);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_ERROR,("USDestroySymbolicLink: ERROR!! Cannot query registry.\n"));
        RtlFreeUnicodeString( &uName2 );
        uName2.Buffer = NULL;
        goto USDestroySymbolicLink_return;
    }

    //
    // Make sure the buffer is NULL terminated.
    //

    wsCreateFileName[ARRAYSIZE(wsCreateFileName)-1] = L'\0';

    if (NULL != wsCreateFileName){
        DebugTrace(TRACE_STATUS,("USDestroySymbolicLink: CreateFileName=%ws, DeviceInstance=%d.\n",
                                    ((PKEY_VALUE_PARTIAL_INFORMATION)wsCreateFileName)->Data,
                                    pde -> DeviceInstance));

        //
        // Get instance number of CreteFile name.
        //

        pvNumber = wcsstr((const wchar_t *)((PKEY_VALUE_PARTIAL_INFORMATION)wsCreateFileName)->Data, wcsObjectName);
        if(NULL != pvNumber){

            //
            //  Move pointer forward. (sizeof(L"\\\\.\\Usbscan") == 22)
            //

//            if( ((PKEY_VALUE_PARTIAL_INFORMATION)wsCreateFileName)->DataLength > sizeof(wcsObjectName) ){
//              (PCHAR)pvNumber += sizeof(wcsObjectName);

            if( ((PKEY_VALUE_PARTIAL_INFORMATION)wsCreateFileName)->DataLength > uiObjectNameLen ){
                (PCHAR)pvNumber += uiObjectNameLen;
            } else {
                DebugTrace(TRACE_ERROR,("USDestroySymbolicLink: ERROR!! CreateFile name too short.\n"));
                RtlFreeUnicodeString( &uName2 );
                uName2.Buffer = NULL;
                ZwClose(hSwKey);
                goto USDestroySymbolicLink_return;
            }

            //
            // Translate X of UsbscanX to integer.
            //

            RtlInitUnicodeString(&uNumber, pvNumber);
            Status = RtlUnicodeStringToInteger(&uNumber,
                                               10,
                                               &ulNumber);
            if(STATUS_SUCCESS != Status){
                DebugTrace(TRACE_ERROR,("USDestroySymbolicLink: ERROR!! RtlUnicodeStringToInteger failed.\n"));
                RtlFreeUnicodeString( &uName2 );
                uName2.Buffer = NULL;
                ZwClose(hSwKey);
                goto USDestroySymbolicLink_return;
            }

            //
            // See if this CreateFile name is made by this instance.
            //

            if(ulNumber == pde -> DeviceInstance){

                //
                // Delete CreateFile name in the registry.
                //

                DebugTrace(TRACE_STATUS,("USDestroySymbolicLink: Deleting %ws%d\n",
                                            wcsObjectName,
                                            ulNumber));
                ZwSetValueKey(hSwKey,&uName,0,REG_SZ,uName2.Buffer,uName2.Length);
            } else {

                //
                // CreateFile name is created by other instance.
                //

                DebugTrace(TRACE_STATUS,("USDestroySymbolicLink: CreateFile name is created by other instance.\n"));
            }
        } else { // (NULL != pvNumber)

            //
            // "Usbscan" was not found in CreateFile name.
            //

            DebugTrace(TRACE_WARNING,("USDestroySymbolicLink: WARNING!! Didn't find \"Usbscan\" in CreateFileName\n"));
        }
    } else { // (NULL != wsCreateFileName)

        //
        // Query CreateFile name returned NULL.
        //

        DebugTrace(TRACE_WARNING,("USDestroySymbolicLink: WARNING!! CreateFileName=NULL\n"));
    }

    //
    // Free allocated memory.
    //

    RtlFreeUnicodeString( &uName2 );

    //
    // Close registry.
    //

    ZwClose(hSwKey);


USDestroySymbolicLink_return:

    //
    // Free allocated string buffer in DeviceObject.
    //

    RtlFreeUnicodeString( &(pde -> SymbolicLinkName) );

    DebugTrace(TRACE_PROC_LEAVE,("USDestroySymbolicLink: Leaving.. Status = 0x%x\n",Status));
    return Status;

} // end USDestroySymbolicLink()


NTSTATUS
USGetUSBDeviceDescriptor(
    IN PDEVICE_OBJECT pDeviceObject
)
/*++

Routine Description:
   Retrieves the USB device descriptor and stores it in the device
   extension. This descriptor contains product info and
   endpoint 0 (default pipe) info.

Arguments:
    pDeviceObject - pointer to device object

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    PUSBSCAN_DEVICE_EXTENSION   pde;
    NTSTATUS                    Status;
    PUSB_DEVICE_DESCRIPTOR      pDeviceDescriptor;
    PURB                        pUrb;
    ULONG                       siz;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USGetUSBDeviceDescriptor: Enter..\n"));

    pde = pDeviceObject->DeviceExtension;

    //
    // Allocate pool for URB.
    //

    pUrb = USAllocatePool(NonPagedPool,
                          sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USGetUSBDeviceDescriptor: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USGetUSBDeviceDescriptor_return;
    }

    //
    // Allocate pool for Descriptor.
    //

    siz = sizeof(USB_DEVICE_DESCRIPTOR);
    pDeviceDescriptor = USAllocatePool(NonPagedPool, siz);

    if (NULL == pDeviceDescriptor) {
        DebugTrace(TRACE_CRITICAL,("USGetUSBDeviceDescriptor: ERROR!! cannot allocated device descriptor\n"));
        DEBUG_BREAKPOINT();
        USFreePool(pUrb);
        pUrb = NULL;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USGetUSBDeviceDescriptor_return;
    }

    //
    // Do Macro to set parameter for GetDescriptor to URB.
    //

    UsbBuildGetDescriptorRequest(pUrb,
                                 (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                 USB_DEVICE_DESCRIPTOR_TYPE,
                                 0,
                                 0,
                                 pDeviceDescriptor,
                                 NULL,
                                 siz,
                                 NULL);

    //
    // Call down.
    //

    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

#if DBG
    //DEBUG_BREAKPOINT();
    if (USBSCAN_PnPTest) {
        Status = STATUS_UNSUCCESSFUL;
    }
#endif

    if (STATUS_SUCCESS == Status) {

        //
        // Show device descriptor.
        //

        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: Device Descriptor = %x, len %x\n",
                                   pDeviceDescriptor,
                                   pUrb->UrbControlDescriptorRequest.TransferBufferLength));

        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: USBSCAN Device Descriptor:\n"));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: -------------------------\n"));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bLength            %d\n",   pDeviceDescriptor -> bLength));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bDescriptorType    0x%x\n", pDeviceDescriptor -> bDescriptorType));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bcdUSB             0x%x\n", pDeviceDescriptor -> bcdUSB));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bDeviceClass       0x%x\n", pDeviceDescriptor -> bDeviceClass));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bDeviceSubClass    0x%x\n", pDeviceDescriptor -> bDeviceSubClass));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bDeviceProtocol    0x%x\n", pDeviceDescriptor -> bDeviceProtocol));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bMaxPacketSize0    0x%x\n", pDeviceDescriptor -> bMaxPacketSize0));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: idVendor           0x%x\n", pDeviceDescriptor -> idVendor));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: idProduct          0x%x\n", pDeviceDescriptor -> idProduct));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bcdDevice          0x%x\n", pDeviceDescriptor -> bcdDevice));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: iManufacturer      0x%x\n", pDeviceDescriptor -> iManufacturer));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: iProduct           0x%x\n", pDeviceDescriptor -> iProduct));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: iSerialNumber      0x%x\n", pDeviceDescriptor -> iSerialNumber));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bNumConfigurations 0x%x\n", pDeviceDescriptor -> bNumConfigurations));

        //
        // Save pointer to device descriptor in our device extension
        //

        pde -> pDeviceDescriptor = pDeviceDescriptor;

    } else { // (STATUS_SUCCESS == Status)

        //
        // Error returned from lower driver.
        //

        DebugTrace(TRACE_ERROR,("USGetUSBDeviceDescriptor: ERROR!! Cannot get device descriptor. (%x)\n", Status));
        USFreePool(pDeviceDescriptor);
        pDeviceDescriptor = NULL;
    } // (STATUS_SUCCESS == Status)

    USFreePool(pUrb);
    pUrb = NULL;

USGetUSBDeviceDescriptor_return:

    DebugTrace(TRACE_PROC_LEAVE,("USGetUSBDeviceDescriptor: Leaving.. Status = 0x%x\n", Status));
    return Status;
} // end USGetUSBDeviceDescriptor()



NTSTATUS
USDeferIrpCompletion(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
)
/*++

Routine Description:
    This routine is called when the port driver completes an IRP.

Arguments:

    pDeviceObject - Pointer to the device object for the class device.
    pIrp - Irp completed.
    Context - Driver defined context.

Return Value:
    The function value is the final status from the operation.

--*/
{
    PKEVENT pEvent = Context;

    DebugTrace(TRACE_PROC_ENTER,("USDeferIrpCompletion: Enter..\n"));
    KeSetEvent(pEvent, 1, FALSE);
    DebugTrace(TRACE_PROC_LEAVE,("USDeferIrpCompletion: Leaving.. Status = STATUS_MORE_PROCESSING_REQUIRED\n"));
    return STATUS_MORE_PROCESSING_REQUIRED;

} // end USDeferIrpCompletion()


VOID
USIncrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUSBSCAN_DEVICE_EXTENSION  pde;

    DebugTrace(TRACE_PROC_ENTER,("USIncrementIoCount: Enter..\n"));

    pde = (PUSBSCAN_DEVICE_EXTENSION)(pDeviceObject -> DeviceExtension);
    ASSERT((LONG)pde -> PendingIoCount >= 0);
    InterlockedIncrement(&pde -> PendingIoCount);

    DebugTrace(TRACE_PROC_LEAVE,("USIncrementIoCount: Leaving.. IoCount=0x%x, Status=VOID\n", pde -> PendingIoCount));

} // end USIncrementIoCount()


LONG
USDecrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUSBSCAN_DEVICE_EXTENSION  pde;
    LONG                        ioCount;

    DebugTrace(TRACE_PROC_ENTER,("USDecrementIoCount: Enter..\n"));

    pde = (PUSBSCAN_DEVICE_EXTENSION)(pDeviceObject -> DeviceExtension);
    ASSERT(pde ->PendingIoCount >= 1);

    ioCount = InterlockedDecrement(&pde -> PendingIoCount);

    if (0 == ioCount) {
        KeSetEvent(&pde -> PendingIoEvent,
                   1,
                   FALSE);
    }

    DebugTrace(TRACE_PROC_LEAVE,("USDecrementIoCount: Leaving.. IoCount(=Ret)=0x%x\n", ioCount));
    return ioCount;
} // end USDecrementIoCount()


NTSTATUS
USBSCAN_CallUSBD(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PURB pUrb
)
/*++

Routine Description:
    Passes a URB to the USBD class driver

Arguments:
    pDeviceObject - pointer to the device object
    pUrb - pointer to Urb request block

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PIRP                        pIrp;
    KEVENT                      eventTimeout;
    IO_STATUS_BLOCK             ioStatus;
    PIO_STACK_LOCATION          pNextStack;
    LARGE_INTEGER               Timeout;
    KEVENT                      eventSync;

    DebugTrace(TRACE_PROC_ENTER,("USBSCAN_CallUSBD: Enter..\n"));

    pde = pDeviceObject -> DeviceExtension;

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&eventTimeout, NotificationEvent, FALSE);
    KeInitializeEvent(&eventSync, SynchronizationEvent, FALSE);

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_SUBMIT_URB,
                pde -> pStackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &eventTimeout,
                &ioStatus);

    if(NULL == pIrp){
        DebugTrace(TRACE_CRITICAL,("USBSCAN_CallUSBD: ERROR!! cannot allocated IRP\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USBSCAN_CallUSBD_return;
    }

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    pNextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(pNextStack != NULL);

    //
    // pass the URB to the USB driver stack
    //

    pNextStack -> Parameters.Others.Argument1 = pUrb;

    //
    // Set completion routine
    //

    IoSetCompletionRoutine(pIrp,
                           USDeferIrpCompletion,
                           &eventSync,
                           TRUE,
                           TRUE,
                           TRUE);

    DebugTrace(TRACE_STATUS,("USBSCAN_CallUSBD: calling USBD\n"));

    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

    DebugTrace(TRACE_STATUS,("USBSCAN_CallUSBD: return from IoCallDriver USBD %x\n", Status));

    if (Status == STATUS_PENDING) {
        DebugTrace(TRACE_STATUS,("USBSCAN_CallUSBD: Wait for single object\n"));

        //
        // Set timeout in case bad device not responding.
        //

        Timeout = RtlConvertLongToLargeInteger(-10*1000*1000*(USBSCAN_TIMEOUT_OTHER));
        Status = KeWaitForSingleObject(
                       &eventSync,
                       Suspended,
                       KernelMode,
                       FALSE,
                       &Timeout);
        if(STATUS_TIMEOUT == Status){

            NTSTATUS    LocalStatus;

            DebugTrace(TRACE_ERROR,("USBSCAN_CallUSBD: ERROR!! call timeout. Now canceling IRP...\n"));

            //
            // Cancel IRP.
            //

            IoCancelIrp(pIrp);

            //
            // Make sure the IRP gets completed.
            //

            LocalStatus = KeWaitForSingleObject(&eventSync,
                                                Suspended,
                                                KernelMode,
                                                FALSE,
                                                NULL);

            DebugTrace(TRACE_STATUS,("USBSCAN_CallUSBD: Canceled status = 0x%x.\n", LocalStatus));

            //
            // Set proper state in IRP.
            //
            
            Status = STATUS_IO_TIMEOUT;
            pIrp->IoStatus.Status = Status;

        } else {
            DebugTrace(TRACE_STATUS,("USBSCAN_CallUSBD: Wait for single object, returned 0x%x\n", Status));
        }
    } // if (Status == STATUS_PENDING)

    //
    // Free the IRP.
    //

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

USBSCAN_CallUSBD_return:
    DebugTrace(TRACE_PROC_LEAVE, ("USBSCAN_CallUSBD: Leaving.. URB Status = 0x%x, Status = 0x%x\n",
                                 pUrb -> UrbHeader.Status,
                                 Status));
    return Status;

} // end USBSCAN_CallUSBD()


NTSTATUS
USConfigureDevice(
    IN PDEVICE_OBJECT pDeviceObject
)
/*++

Routine Description:
    Initializes a given instance of the device on the USB and selects the
    configuration.

Arguments:
    pDeviceObject - pointer to the device object

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{

    NTSTATUS                      Status;
    PUSBSCAN_DEVICE_EXTENSION     pde;
    PURB                          pUrb;
    ULONG                         siz;
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor;
    PUSB_INTERFACE_DESCRIPTOR     pInterfaceDescriptor;
    PUSB_ENDPOINT_DESCRIPTOR      pEndpointDescriptor;
    PUSB_COMMON_DESCRIPTOR        pCommonDescriptor;
    PUSBD_INTERFACE_INFORMATION   pInterface;
    UCHAR                         AlternateSetting;
    UCHAR                         InterfaceNumber;
    USHORT                        length;
    ULONG                         i;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USConfigureDevice: Enter..\n"));

    //
    // Initialize local variable.
    //

    pConfigurationDescriptor    = NULL;
    pInterfaceDescriptor        = NULL;
    pEndpointDescriptor         = NULL;
    pCommonDescriptor           = NULL;
    pInterface                  = NULL;
    pUrb                        = NULL;

    siz                 = 0;
    AlternateSetting    = 0;
    InterfaceNumber     = 0;
    length              = 0;

    pde = pDeviceObject -> DeviceExtension;
    Status = STATUS_UNSUCCESSFUL;

    //
    // First configure the device
    //

    pUrb = USAllocatePool(NonPagedPool,
                          sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USConfigureDevice: ERROR!! Can't allocate control descriptor URB.\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USConfigureDevice_return;
    }

    siz = sizeof(USB_CONFIGURATION_DESCRIPTOR);


get_config_descriptor_retry:

    pConfigurationDescriptor = USAllocatePool(NonPagedPool, siz);
    if (NULL == pConfigurationDescriptor) {
        DebugTrace(TRACE_CRITICAL,("USConfigureDevice: ERROR!! Can't allocate configuration descriptor.\n"));
        DEBUG_BREAKPOINT();

        USFreePool(pUrb);
        pUrb = NULL;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USConfigureDevice_return;
    }

    //
    // Initialize buffers by 0
    //

    RtlZeroMemory(pConfigurationDescriptor, siz);
    RtlZeroMemory(pUrb, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    UsbBuildGetDescriptorRequest(pUrb,
                                 (USHORT)sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                 USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                 0,
                                 0,
                                 pConfigurationDescriptor,
                                 NULL,
                                 siz,
                                 NULL);

    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

    DebugTrace(TRACE_STATUS,("USConfigureDevice: URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE Status = %x\n", Status));
    DebugTrace(TRACE_STATUS,("USConfigureDevice: Configuration Descriptor = %x, len = %x\n",
                               pConfigurationDescriptor,
                               pUrb -> UrbControlDescriptorRequest.TransferBufferLength));


    //
    // if we got some data see if it was enough.
    //
    // NOTE: we may get an error in URB because of buffer overrun
    //

    if ( (pUrb -> UrbControlDescriptorRequest.TransferBufferLength > 0) &&
         (pConfigurationDescriptor -> wTotalLength > siz)) {

        DebugTrace(TRACE_WARNING,("USConfigureDevice: WARNING!! Data is incomplete. Fetch descriptor again...\n"));

        siz = pConfigurationDescriptor -> wTotalLength;
        USFreePool(pConfigurationDescriptor);
        pConfigurationDescriptor = NULL;
        goto get_config_descriptor_retry;
    }

    USFreePool(pUrb);
    pUrb = NULL;

    //
    // We have the configuration descriptor for the configuration
    // we want.  Save it in our device extension.
    //

    pde -> pConfigurationDescriptor = pConfigurationDescriptor;

    //
    // Now we issue the select configuration command to get
    // the pipes associated with this configuration.
    //

    pUrb = USCreateConfigurationRequest(pConfigurationDescriptor, &length);
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USConfigureDevice: ERROR!! Can't allocate select configuration urb.\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USConfigureDevice_return;
    }

    //
    // Get the Interface descriptors.
    //

    pInterfaceDescriptor = USBD_ParseConfigurationDescriptorEx(pConfigurationDescriptor,
                                                               pConfigurationDescriptor,
                                                               -1,
                                                               0,
                                                               -1,
                                                               -1,
                                                               -1);

    if(NULL == pInterfaceDescriptor){
        DebugTrace(TRACE_CRITICAL,("USConfigureDevice: ERROR!! Can't get Interface descriptor.\n"));
        USFreePool(pUrb);
        pUrb = NULL;
        Status = STATUS_UNSUCCESSFUL;
        goto USConfigureDevice_return;
    }

    //
    // Get the Endpoint descriptors.
    //

    pCommonDescriptor = USBD_ParseDescriptors(pConfigurationDescriptor,
                                              pConfigurationDescriptor->wTotalLength,
                                              pInterfaceDescriptor,
                                              USB_ENDPOINT_DESCRIPTOR_TYPE);
    if(NULL == pCommonDescriptor){
        DebugTrace(TRACE_CRITICAL,("USConfigureDevice: ERROR!! Can't get Endpoint descriptor.\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto USConfigureDevice_return;
    }

    ASSERT(USB_ENDPOINT_DESCRIPTOR_TYPE == pCommonDescriptor->bDescriptorType);
    pEndpointDescriptor = (PUSB_ENDPOINT_DESCRIPTOR)pCommonDescriptor;

    //
    // save these pointers is our device extension.
    //

    pde -> pInterfaceDescriptor = pInterfaceDescriptor;
    pde -> pEndpointDescriptor  = pEndpointDescriptor;

    //
    // Set the max transfer size for each BULK endpoint to 64K.
    // Also, search through the set of endpoints and find the pipe index for our
    // bulk-in, interrupt, and optionally bulk-out pipes.
    //

    pde -> IndexBulkIn    = -1;
    pde -> IndexBulkOut   = -1;
    pde -> IndexInterrupt = -1;

    pInterface = &(pUrb -> UrbSelectConfiguration.Interface);

    for (i=0; i < pInterfaceDescriptor -> bNumEndpoints; i++) {

        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: End point[%d] descriptor\n", i));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: bLength          : 0x%X\n", pEndpointDescriptor[i].bLength));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: bDescriptorType  : 0x%X\n", pEndpointDescriptor[i].bDescriptorType));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: bEndpointAddress : 0x%X\n", pEndpointDescriptor[i].bEndpointAddress));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: bmAttributes     : 0x%X\n", pEndpointDescriptor[i].bmAttributes));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: wMaxPacketSize   : 0x%X\n", pEndpointDescriptor[i].wMaxPacketSize));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: bInterval        : 0x%X\n", pEndpointDescriptor[i].bInterval));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: \n"));

        if (USB_ENDPOINT_TYPE_BULK == pEndpointDescriptor[i].bmAttributes) {
            pInterface -> Pipes[i].MaximumTransferSize = 64*1024;
            if (pEndpointDescriptor[i].bEndpointAddress & BULKIN_FLAG) {    // if input endpoint
                pde -> IndexBulkIn = i;
            } else {
                pde -> IndexBulkOut = i;
            }
        } else if (USB_ENDPOINT_TYPE_INTERRUPT == pEndpointDescriptor[i].bmAttributes) {
            pde -> IndexInterrupt = i;
        }
    }

    //
    // Select the default configuration.
    //

    UsbBuildSelectConfigurationRequest(pUrb, length, pConfigurationDescriptor);
    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);
    if (STATUS_SUCCESS != Status) {
        DebugTrace(TRACE_ERROR,("USConfigureDevice: ERROR!! Selecting default configuration. Status = %x\n", Status));

        USFreePool(pUrb);
        pUrb = NULL;
        Status = STATUS_IO_DEVICE_ERROR;
        goto USConfigureDevice_return;
    }

    //
    // Save the configuration handle in our device extension.
    //

    pde -> ConfigurationHandle = pUrb -> UrbSelectConfiguration.ConfigurationHandle;

    //
    // Insure that this device won't overflow our PipeInfo structure.
    //

    if (pInterfaceDescriptor -> bNumEndpoints > MAX_NUM_PIPES) {
        DebugTrace(TRACE_ERROR,("USConfigureDevice: ERROR!! Too many endpoints for this driver! # endpoints = %d\n",
                                    pInterfaceDescriptor -> bNumEndpoints));
//        DEBUG_BREAKPOINT();
        USFreePool(pUrb);
        pUrb = NULL;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USConfigureDevice_return;
    }

    //
    // Save pipe configurations in our device extension
    //

    pde -> NumberOfPipes = pInterfaceDescriptor -> bNumEndpoints;

    for (i=0; i < pInterfaceDescriptor -> bNumEndpoints; i++) {
        pde -> PipeInfo[i] = pInterface -> Pipes[i];

        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: Pipe[%d] information\n", i));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: MaximumPacketSize : 0x%X\n", pde -> PipeInfo[i].MaximumPacketSize));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: EndpointAddress   : 0x%X\n", pde -> PipeInfo[i].EndpointAddress));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: Interval          : 0x%X\n", pde -> PipeInfo[i].Interval));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: PipeType          : 0x%X\n", pde -> PipeInfo[i].PipeType));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: PipeHandle        : 0x%X\n", pde -> PipeInfo[i].PipeHandle));

        //
        // Initialize the read pipe buffer if type is Bulk-In.
        //

        if( (pde->PipeInfo[i].PipeType == UsbdPipeTypeBulk)
         && (pde->PipeInfo[i].EndpointAddress & BULKIN_FLAG) )
        {

            DebugTrace(TRACE_STATUS,("USConfigureDevice: Alocates buffer for Pipe[%d]\n", i));

            pde -> ReadPipeBuffer[i].RemainingData = 0;
            pde -> ReadPipeBuffer[i].pBuffer = USAllocatePool(NonPagedPool, 2 * (pde -> PipeInfo[i].MaximumPacketSize));
            if (NULL == pde -> ReadPipeBuffer[i].pBuffer) {
                DebugTrace(TRACE_CRITICAL,("USConfigureDevice: Cannot allocate bulk-in buffer.\n"));
                DEBUG_BREAKPOINT();
                Status = STATUS_INSUFFICIENT_RESOURCES;
                USFreePool(pUrb);
                pUrb = NULL;
                goto USConfigureDevice_return;
            }
            pde -> ReadPipeBuffer[i].pStartBuffer = pde -> ReadPipeBuffer[i].pBuffer;
        } else {
            pde -> ReadPipeBuffer[i].pBuffer = NULL;
        }
    }

    USFreePool(pUrb);
    pUrb = NULL;

USConfigureDevice_return:
    DebugTrace(TRACE_PROC_LEAVE,("USConfigureDevice: Leaving.. Status = %x\n", Status));
    return Status;
}


NTSTATUS
USUnConfigureDevice(
    IN PDEVICE_OBJECT pDeviceObject
)
/*++

Routine Description:

Arguments:
    pDeviceObject - pointer to the device object

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                      Status;
    PURB                          pUrb;
    ULONG                         siz;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USUnConfigureDevice: Enter..\n"));

    siz = sizeof(struct _URB_SELECT_CONFIGURATION);
    pUrb = USAllocatePool(NonPagedPool, siz);
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USUnConfigureDevice: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USUnConfigureDevice_return;
    }
    RtlZeroMemory(pUrb, siz);

    //
    // Send the select configuration urb with a NULL pointer for the configuration
    // handle, this closes the configuration and puts the device in the 'unconfigured'
    // state.
    //

    UsbBuildSelectConfigurationRequest(pUrb, (USHORT)siz, NULL);
    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);
    DebugTrace(TRACE_STATUS,("USUnConfigureDevice: Device Configuration Closed status = %x usb status = %x.\n",
                               Status, pUrb->UrbHeader.Status));

    USFreePool(pUrb);
    pUrb = NULL;

USUnConfigureDevice_return:
    DebugTrace(TRACE_PROC_LEAVE,("USUnConfigureDevice: Leaving.. Status = %x\n", Status));
    return Status;
}


VOID
USUnload(
    IN PDRIVER_OBJECT pDriverObject
)
/*++

   Routine Description:
   Unload routine. The routine is called when the driver is unloaded.
   Release every resource allocated in relation with the driver object.

   Arguments:
   pDriverObject - pointer to the driver object

   Return Value:
   None

   -- */
{
    PAGED_CODE();
    
    if(NULL == pDriverObject){
        DebugTrace(TRACE_ERROR,("UsbScanUnload: ERROR!! pDriverObject is NULL\n"));
    } // if(NULL == pDriverObject)

    DebugTrace((MIN_TRACE | TRACE_FLAG_PROC),("UsbScanUnload(0x%X);\n", pDriverObject));

} // end USUnload()


NTSTATUS
USCallNextDriverSynch(
    IN PUSBSCAN_DEVICE_EXTENSION  pde,
    IN PIRP              pIrp
)
/*++

Routine Description:

    Calls lower driver and waits for result

Arguments:

    DeviceExtension - pointer to device extension
    Irp - pointer to IRP

Return Value:

    none.

--*/
{
    KEVENT          Event;
    PIO_STACK_LOCATION IrpStack;
    NTSTATUS        Status;

    DebugTrace(TRACE_PROC_ENTER,("USCallNextDriverSynch: Enter..\n"));

    IrpStack = IoGetCurrentIrpStackLocation(pIrp);

    //
    // Copy IRP stack to the next.
    //

    IoCopyCurrentIrpStackLocationToNext(pIrp);

    //
    // Initialize synchronizing event.
    //

    KeInitializeEvent(&Event,
                      SynchronizationEvent,
                      FALSE);

    //
    // Set completion routine
    //

    IoSetCompletionRoutine(pIrp,
                           USDeferIrpCompletion,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // Call down
    //

    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

    if (Status == STATUS_PENDING) {

        //
        // Waiting for the completion.
        //

        DebugTrace(TRACE_STATUS,("USCallNextDriverSynch: STATUS_PENDING. Wait for event.\n"));
        KeWaitForSingleObject(&Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        Status = pIrp -> IoStatus.Status;
    }

    //
    // Return
    //

    DebugTrace(TRACE_PROC_LEAVE,("USCallNextDriverSynch: Leaving.. Status = %x\n", Status));
    return (Status);
}

NTSTATUS
UsbScanHandleInterface(
    PDEVICE_OBJECT      DeviceObject,
    PUNICODE_STRING     InterfaceName,
    BOOLEAN             Create
    )
/*++

Routine Description:

Arguments:

    DeviceObject    - Supplies the device object.

Return Value:

    None.

--*/
{

    NTSTATUS           Status;

    DebugTrace(TRACE_PROC_ENTER,("UsbScanHandleInterface: Enter..\n"));

    Status = STATUS_SUCCESS;

#ifndef _CHICAGO_

    if (Create) {

        Status=IoRegisterDeviceInterface(
            DeviceObject,
            &GUID_DEVCLASS_IMAGE,
            NULL,
            InterfaceName
            );
        DebugTrace(TRACE_STATUS,("Called IoRegisterDeviceInterface . Returned=0x%X\n",Status));

        if (NT_SUCCESS(Status)) {

            IoSetDeviceInterfaceState(
                InterfaceName,
                TRUE
                );

            DebugTrace(TRACE_STATUS,("Called IoSetDeviceInterfaceState(TRUE) . \n"));
        }
    } else {

        if (InterfaceName->Buffer != NULL) {

            Status = IoSetDeviceInterfaceState(
                        InterfaceName,
                        FALSE
                        );

            RtlFreeUnicodeString(
                InterfaceName
                );

            InterfaceName->Buffer = NULL;
        }
    }

#endif // !_CHICAGO_

    DebugTrace(TRACE_PROC_LEAVE,("IoRegisterDeviceInterface: Leaving... Status=0x%X\n",Status));
    return Status;

}

NTSTATUS
UsbScanReadDeviceRegistry(
    IN  PUSBSCAN_DEVICE_EXTENSION   pExtension,
    IN  PCWSTR                      pKeyName,
    OUT PVOID                       *ppvData
    )
/*++

Routine Description:

    This routine open registry for this device and query a value specified
    by key name. This routine allocate non-paged memory and return its pointer.
    Caller must free returned pointer.

Arguments:

    pExtension  - pointer to device extension
    pKeyName    - pointer to a wide string specify key name
    ppvData     - pointer to the queried data pointer allocated by this routine

Return Value:
    STATUS_SUCCESS              - if success,
    STATUS_INVALID_PARAMETER    - if passed argument is invalid,

--*/

{
    NTSTATUS                        Status;
    HANDLE                          hRegKey;
    PVOID                           pvBuffer;
    ULONG                           DataSize;
    PVOID                           pvRetData;
    UNICODE_STRING                  unicodeKeyName;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER, ("UsbScanReadDeviceRegistry: Entering...\n"));

    //
    // Initialize status
    //

    Status = STATUS_SUCCESS;

    hRegKey = NULL;
    pvBuffer = NULL;
    pvRetData = NULL;
    DataSize = 0;

    //
    // Check the arguments
    //

    if( (NULL == pExtension)
     || (NULL == pKeyName)
     || (NULL == ppvData) )
    {
        DebugTrace(TRACE_ERROR, ("UsbScanReadDeviceRegistry: ERROR!! Invalid argument.\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto UsbScanReadDeviceRegistry_return;
    }

    //
    // Open device registry.
    //

    Status = IoOpenDeviceRegistryKey(pExtension->pPhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     KEY_READ,
                                     &hRegKey);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR, ("UsbScanReadDeviceRegistry: ERROR!! IoOpenDeviceRegistryKey failed.\n"));
        goto UsbScanReadDeviceRegistry_return;
    }

    //
    // Query required size.
    //

    RtlInitUnicodeString(&unicodeKeyName, pKeyName);
    Status = ZwQueryValueKey(hRegKey,
                             &unicodeKeyName,
                             KeyValuePartialInformation,
                             NULL,
                             0,
                             &DataSize);
    if(0 == DataSize){
        if(STATUS_OBJECT_NAME_NOT_FOUND == Status){
            DebugTrace(TRACE_STATUS, ("UsbScanReadDeviceRegistry: Reg-key \"%wZ\" doesn't exist.\n", &unicodeKeyName));
        } else {
            DebugTrace(TRACE_ERROR, ("UsbScanReadDeviceRegistry: ERROR!! Cannot retrieve reqired data size of %wZ. Status=0x%x\n",
                                     &unicodeKeyName ,
                                     Status));
        }
        goto UsbScanReadDeviceRegistry_return;
    }

    //
    // Allocate memory for temp buffer. size +2 for NULL.
    //

    pvBuffer = USAllocatePool(NonPagedPool, DataSize+2);
    if(NULL == pvBuffer){
        DebugTrace(TRACE_CRITICAL, ("UsbScanReadDeviceRegistry: ERROR!! Buffer allocate failed.\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto UsbScanReadDeviceRegistry_return;
    }
    RtlZeroMemory(pvBuffer, DataSize+sizeof(WCHAR));

    //
    // Query specified value.
    //

    DebugTrace(TRACE_STATUS, ("UsbScanReadDeviceRegistry: Query \"%wZ\".\n", &unicodeKeyName));
    Status = ZwQueryValueKey(hRegKey,
                             &unicodeKeyName,
                             KeyValuePartialInformation,
                             pvBuffer,
                             DataSize,
                             &DataSize);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR, ("UsbScanReadDeviceRegistry: ERROR!! ZwQueryValueKey failed. Status=0x%x\n", Status));
        goto UsbScanReadDeviceRegistry_return;
    }

UsbScanReadDeviceRegistry_return:
    if(!NT_SUCCESS(Status)){

        //
        // This routine failed.
        //

        if(pvRetData){
            USFreePool(pvRetData);
        }
        *ppvData = NULL;
    } else {

        //
        // This routine succeeded.
        //

        *ppvData = pvBuffer;
    }

    //
    // Clean-up.
    //

    if(hRegKey){
        ZwClose(hRegKey);
    }
    DebugTrace(TRACE_PROC_LEAVE, ("UsbScanReadDeviceRegistry: Leaving... Status=0x%x\n", Status));
    return Status;
}


NTSTATUS
UsbScanWriteDeviceRegistry(
    IN PUSBSCAN_DEVICE_EXTENSION    pExtension,
    IN PCWSTR                       pKeyName,
    IN ULONG                        Type,
    IN PVOID                        pvData,
    IN ULONG                        DataSize
    )
/*++

Routine Description:

    This routine open registry for this device and set a value specified
    by key name.

Arguments:

    pExtension  - pointer to device extension
    pKeyName    - pointer to a wide string specify key name
    Type        - specifies the type of data to be written
    pvData      - pointer to a caller allocated buffer containing data
    DataSize    - specifies the size in bytes of the data buffer

Return Value:
    STATUS_SUCCESS              - if success,
    STATUS_INVALID_PARAMETER    - if passed argument is invalid,

--*/

{
    NTSTATUS                        Status;
    HANDLE                          hRegKey;
    UNICODE_STRING                  unicodeKeyName;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER, ("UsbScanWriteDeviceRegistry: Entering...\n"));

    //
    // Initialize status
    //

    Status = STATUS_SUCCESS;

    hRegKey = NULL;

    //
    // Check the arguments
    //

    if( (NULL == pExtension)
     || (NULL == pKeyName)
     || (NULL == pvData)
     || (0 == DataSize) )
    {
        DebugTrace(TRACE_ERROR, ("UsbScanWriteDeviceRegistry: ERROR!! Invalid argument.\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto UsbScanWriteDeviceRegistry_return;
    }

    //
    // Open device registry.
    //

    Status = IoOpenDeviceRegistryKey(pExtension->pPhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     KEY_ALL_ACCESS,
                                     &hRegKey);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR, ("UsbScanWriteDeviceRegistry: ERROR!! IoOpenDeviceRegistryKey failed.\n"));
        goto UsbScanWriteDeviceRegistry_return;
    }

    //
    // Set specified value.
    //

    RtlInitUnicodeString(&unicodeKeyName, pKeyName);
    DebugTrace(TRACE_STATUS, ("UsbScanWriteDeviceRegistry: Setting \"%wZ\".\n", &unicodeKeyName));
    Status = ZwSetValueKey(hRegKey,
                           &unicodeKeyName,
                           0,
                           Type,
                           pvData,
                           DataSize);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR, ("UsbScanWriteDeviceRegistry: ERROR!! ZwSetValueKey failed. Status = 0x%x\n", Status));
        goto UsbScanWriteDeviceRegistry_return;
    }

UsbScanWriteDeviceRegistry_return:

    //
    // Clean-up.
    //

    if(hRegKey){
        ZwClose(hRegKey);
    }
    DebugTrace(TRACE_PROC_LEAVE, ("UsbScanWriteDeviceRegistry: Leaving... Status=0x%x\n", Status));
    return Status;
} // UsbScanWriteDeviceRegistry()

PURB
USCreateConfigurationRequest(
    IN PUSB_CONFIGURATION_DESCRIPTOR    ConfigurationDescriptor,
    IN OUT PUSHORT                      Siz
    )
/*++

Routine Description:

Arguments:

Return Value:

    Pointer to initailized select_configuration urb.

--*/
{
    PURB urb = NULL;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    PUSBD_INTERFACE_LIST_ENTRY interfaceList, tmp;
    LONG numberOfInterfaces, interfaceNumber, i;

    PAGED_CODE();
    DebugTrace(TRACE_PROC_ENTER, ("USCreateConfigurationRequest: Entering...\n"));

    //
    // build a request structure and call the new api
    //

    numberOfInterfaces = ConfigurationDescriptor->bNumInterfaces;

    tmp = interfaceList = USAllocatePool(PagedPool, sizeof(USBD_INTERFACE_LIST_ENTRY) * (numberOfInterfaces+1));

    //
    // just grab the first alt setting we find for each interface
    //

    i = interfaceNumber = 0;

    while (i< numberOfInterfaces) {

        interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(ConfigurationDescriptor,
                                                                  ConfigurationDescriptor,
                                                                  -1,
                                                                  0, // assume alt setting zero here
                                                                  -1,
                                                                  -1,
                                                                  -1);

        ASSERT(interfaceDescriptor != NULL);

        if (interfaceDescriptor) {
            interfaceList->InterfaceDescriptor =
                interfaceDescriptor;
            interfaceList++;
            i++;
        } else {
            // could not find the requested interface descriptor
            // bail, we will prorblay crash somewhere in the
            // client driver.

            goto USCreateConfigurationRequest_return;
        }

        interfaceNumber++;
    }

    //
    // terminate the list
    //
    interfaceList->InterfaceDescriptor = NULL;

    urb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor, tmp);

USCreateConfigurationRequest_return:

    ExFreePool(tmp);

    if (urb) {
        *Siz = urb->UrbHeader.Length;
    }

    DebugTrace(TRACE_PROC_LEAVE, ("USCreateConfigurationRequest: Leaving... Ret=0x%x\n", urb));
    return urb;

} // USCreateConfigurationRequest()

VOID
UsbScanLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DriverObject        - Supplies a pointer to the driver object for the
                            device.

    DeviceObject        - Supplies a pointer to the device object associated
                            with the device that had the error, early in
                            initialization, one may not yet exist.

    SequenceNumber      - Supplies a ulong value that is unique to an IRP over
                            the life of the irp in this driver - 0 generally
                            means an error not associated with an irp.

    MajorFunctionCode   - Supplies the major function code of the irp if there
                            is an error associated with it.

    RetryCount          - Supplies the number of times a particular operation
                            has been retried.

    UniqueErrorValue    - Supplies a unique long word that identifies the
                            particular call to this function.

    FinalStatus         - Supplies the final status given to the irp that was
                            associated with this error.  If this log entry is
                            being made during one of the retries this value
                            will be STATUS_SUCCESS.

    SpecificIOStatus    - Supplies the IO status for this particular error.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET    ErrorLogEntry;
    PVOID                   ObjectToUse;
    SHORT                   DumpToAllocate;

    if (ARGUMENT_PRESENT(DeviceObject)) {

        ObjectToUse = DeviceObject;

    } else {

        ObjectToUse = DriverObject;

    }

    DumpToAllocate = 0;

    ErrorLogEntry = IoAllocateErrorLogEntry(ObjectToUse,
            (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) + DumpToAllocate));

    if (!ErrorLogEntry) {
        return;
    }

    ErrorLogEntry->ErrorCode         = SpecificIOStatus;
    ErrorLogEntry->SequenceNumber    = SequenceNumber;
    ErrorLogEntry->MajorFunctionCode = MajorFunctionCode;
    ErrorLogEntry->RetryCount        = RetryCount;
    ErrorLogEntry->UniqueErrorValue  = UniqueErrorValue;
    ErrorLogEntry->FinalStatus       = FinalStatus;
    ErrorLogEntry->DumpDataSize      = DumpToAllocate;

    if (DumpToAllocate) {

        // If needed - add more to parameter list and move memory here
        //RtlCopyMemory(ErrorLogEntry->DumpData, &P1, sizeof(PHYSICAL_ADDRESS));

    }

    IoWriteErrorLogEntry(ErrorLogEntry);

}



#ifdef ORIGINAL_POOLTRACK

int NumberOfAllocate = 0;

PVOID
USAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG     ulNumberOfBytes
)
/*++

Routine Description:

    Wrapper for pool allocation. Use tag to avoid heap corruption.

Arguments:

    PoolType - type of pool memory to allocate
    ulNumberOfBytes - number of bytes to allocate

Return Value:

    Pointer to the allocated memory

--*/
{
    PVOID pvRet;

    DebugTrace(TRACE_PROC_ENTER,("USAllocatePool: Enter.. Size = %d\n", ulNumberOfBytes));

    pvRet = ExAllocatePoolWithTag(PoolType,
                                  ulNumberOfBytes,
                                  TAG_USBSCAN);

    NumberOfAllocate++;
    DebugTrace(TRACE_PROC_LEAVE,("USAllocatePool: Leaving.. pvRet = %x, Count=%d\n", pvRet, NumberOfAllocate));
    return pvRet;

}


VOID
USFreePool(
    IN PVOID     pvAddress
)
/*++

Routine Description:

    Wrapper for pool free. Check tag to avoid heap corruption

Arguments:

    pvAddress - Pointer to the allocated memory

Return Value:

    none.

--*/
{

    ULONG ulTag;

    DebugTrace(TRACE_PROC_ENTER,("USFreePool: Enter..\n"));

    ulTag = *((PULONG)pvAddress-1);

    if( (TAG_USBSCAN == ulTag) || (TAG_USBD == ulTag) ){
        DebugTrace(TRACE_STATUS,("USFreePool: Free memory. tag = %c%c%c%c\n",
                                        ((PUCHAR)&ulTag)[0],
                                        ((PUCHAR)&ulTag)[1],
                                        ((PUCHAR)&ulTag)[2],
                                        ((PUCHAR)&ulTag)[3]  ))
    } else {
        DebugTrace(TRACE_WARNING,("USFreePool: WARNING!! Free memory. tag = %c%c%c%c\n",
                                        ((PUCHAR)&ulTag)[0],
                                        ((PUCHAR)&ulTag)[1],
                                        ((PUCHAR)&ulTag)[2],
                                        ((PUCHAR)&ulTag)[3]  ))
    }

    ExFreePool(pvAddress);

    NumberOfAllocate--;
    DebugTrace(TRACE_PROC_LEAVE,("USFreePool: Leaving.. Status = VOID, Count=%d\n", NumberOfAllocate));
}

#endif   // ORIGINAL_POOLTRACK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\usbscn9x\debug.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2001

Module Name:

    debug.h

Abstract:

    Prototypes and definitions for debugging.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#ifndef __MYDEBUG__
#define __MYDEBUG__

//
// Driver specific difinition
//


#define NAME_DRIVER             "USBscan.sys: "     // Prefix of output message. (Should be driver name)
#define NAME_POOLTAG            'UITS'              // Pool tag for this driver.
#define MAXNUM_POOL             100                 // Maximum number of pool. (# of alloc - # of free)
#define MAX_DUMPSIZE            1024                // Maximum bytes to dump.

//
// Defines
//

#define REG_DEBUGLEVEL          L"DebugTraceLevel"
#define MAX_TEMPBUF             256

// Bit mask for trace level and flags
#define BITMASK_TRACE_LEVEL     0x0000000f
#define BITMASK_TRACE_FLAG      0x00000ff0
#define BITMASK_DEBUG_FLAG      0x0000f000

// Basic trace level 
#define NO_TRACE                0                   // Shows nothing.
#define MIN_TRACE               1                   // Shows only error or warning.
#define MAX_TRACE               2                   // Shows progress and status.
#define ULTRA_TRACE             3                   // Shows progress and status in retail.
#define NEVER_TRACE             4                   // Never show this unless specific bit is set.

// Trace flag to enable specific message spew. (1=on)
#define TRACE_FLAG_PROC          0x10                // Show message when entering process.(1=on)
#define TRACE_FLAG_RET           0x20                // Show message when leaving process.(1=on)
#define TRACE_FLAG_DUMP_READ     0x40                // Show user buffer when read.
#define TRACE_FLAG_DUMP_WRITE    0x80                // Show user buffer when write.

// Conbination of trace level and flag.
#define TRACE_PROC_ENTER        ULTRA_TRACE | TRACE_FLAG_PROC     // Entering procedure.
#define TRACE_PROC_LEAVE        ULTRA_TRACE | TRACE_FLAG_RET      // Leaving procedure.
#define TRACE_CRITICAL          MIN_TRACE                         // Critical error. Spew always.
#define TRACE_ERROR             MIN_TRACE                         // Error.
#define TRACE_WARNING           MIN_TRACE                         // Possible wrong behavior.
//#define TRACE_DUMP_DATA         NEVER_TRACE | TRACE_FLAG_DUMP     // Dump transaction data.
#define TRACE_DEVICE_DATA       MAX_TRACE                         // Show device data.
#define TRACE_STATUS            MAX_TRACE                         // Show status.

// Debug flag to enable/disable  DEBUG_BREAKPOINT()
#define DEBUG_FLAG_DISABLE      0x1000                          // Disable DEBUG_BREAK. (1=disable)
#define DEBUG_PROC_BREAK        0x2000                          // Stop at the beginning of each procedure.


//
// Macro
//

#if DBG

 //
 // Macro for debug output
 //
 // Note: If trace level is higher than DebugTraceLevel or specific bit is set, 
 //       debug message will be shown.
 //

extern ULONG DebugTraceLevel;
 #define DebugTrace(_t_, _x_) {                                                                 \
            if ( ((DebugTraceLevel & BITMASK_TRACE_LEVEL) >= (_t_ & BITMASK_TRACE_LEVEL )) ||   \
                 (DebugTraceLevel & BITMASK_TRACE_FLAG & (_t_)) ) {                             \
                DbgPrint(NAME_DRIVER);                                                          \
                DbgPrint _x_ ;                                                                  \
            }                                                                                   \
            if( (DebugTraceLevel & DEBUG_PROC_BREAK & (_t_)) &&                                 \
                (DebugTraceLevel & TRACE_FLAG_PROC) )  {                                        \
                DEBUG_BREAKPOINT();                                                             \
            }                                                                                   \
          }

 //
 // Macro for BreakPoint
 //

 #define DEBUG_BREAKPOINT() {                                              \
           if (DebugTraceLevel & DEBUG_FLAG_DISABLE) {                     \
               DbgPrint(NAME_DRIVER);                                      \
               DbgPrint("*** Hit DEBUG_BREAKPOINT ***\n");                 \
           } else {                                                        \
               DbgBreakPoint();                                            \
           }                                                               \
         }

#else    // DBG
 #define DEBUG_BREAKPOINT()
 #define DebugTrace(_t_, _x_)
#endif   // DBG


//
// Prototypes
//


PVOID
MyAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG     ulNumberOfBytes
);

VOID
MyFreePool(
    IN PVOID     pvAddress
);

VOID
MyDebugInit(
    IN  PUNICODE_STRING pRegistryPath
);


VOID
MyDumpMemory(
    PUCHAR  pDumpBuffer,
    ULONG   dwSize,
    BOOLEAN bRead
);

#endif //  __MYDEBUG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\usbscn9x\ioctl.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 2001

Module Name:

    ioctl.c

Abstract:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include <stdio.h>
#include <stddef.h>
#include <wdm.h>
#include <usbscan.h>
#include "usbd_api.h"
#include "private.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USDeviceControl)
#pragma alloc_text(PAGE, USReadWriteRegisters)
#pragma alloc_text(PAGE, USCancelPipe)
#pragma alloc_text(PAGE, USAbortResetPipe)
#endif

#ifdef _WIN64
BOOLEAN
IoIs32bitProcess(
    IN PIRP Irp
    );
#endif // _WIN64

NTSTATUS
USDeviceControl(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
/*++

Routine Description:

Arguments:
    pDeviceObject - Device object for a device.
    pIrp          - DEVICE IOCTL irp

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    PIO_STACK_LOCATION          pIrpStack;
    PIO_STACK_LOCATION          pNextIrpStack;
    PFILE_OBJECT                fileObject;
    PUSBSCAN_FILE_CONTEXT       pFileContext;
    ULONG                       IoControlCode;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    NTSTATUS                    Status;
    PDRV_VERSION                pVersion;
    PDEVICE_DESCRIPTOR          pDesc;
    PUSBSCAN_GET_DESCRIPTOR     pGetDesc;
    PUSBSCAN_PIPE_CONFIGURATION pPipeConfig;
    PVOID                       pBuffer;

    IO_BLOCK                    LocalIoBlock;
    IO_BLOCK_EX                 LocalIoBlockEx;
    PIO_BLOCK                   pIoBlock;
    PIO_BLOCK_EX                pIoBlockEx;

    ULONG                       InLength;
    ULONG                       OutLength;
    BOOLEAN                     fRead = FALSE;
    BOOLEAN                     fAbort = TRUE;
    ULONG                       i;
    PURB                        pUrb;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USDeviceControl: Enter.. - \n"));

    //
    // Indicates I/O processing increase.
    //

    USIncrementIoCount( pDeviceObject );

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    if (FALSE == pde -> AcceptingRequests) {
        DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! IOCTL issued after device stopped/removed!\n"));
        Status = STATUS_DELETE_PENDING;
        pIrp -> IoStatus.Status = Status;
        pIrp -> IoStatus.Information = 0;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        goto USDeviceControl_return;
    }

    //
    // Check device power state.
    //

    if (PowerDeviceD0 != pde -> CurrentDevicePowerState) {
        DebugTrace(TRACE_WARNING,("USDeviceControl: WARNING!! Device is suspended.\n"));
        Status = STATUS_DELETE_PENDING;
        pIrp -> IoStatus.Status = Status;
        pIrp -> IoStatus.Information = 0;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        goto USDeviceControl_return;
    }


    pIrpStack       = IoGetCurrentIrpStackLocation( pIrp );
    pNextIrpStack   = IoGetNextIrpStackLocation( pIrp );
    IoControlCode   = pIrpStack->Parameters.DeviceIoControl.IoControlCode;

    InLength        = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
    OutLength       = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    pBuffer         = pIrp -> AssociatedIrp.SystemBuffer;

    fileObject      = pIrpStack->FileObject;
    pFileContext    = fileObject->FsContext;

    DebugTrace(TRACE_STATUS,("USDeviceControl: Control code 0x%x = ", IoControlCode));

    switch (IoControlCode) {

        case IOCTL_GET_VERSION:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_GET_VERSION\n"));

            if (OutLength < sizeof(DRV_VERSION) ) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Buffer(0x%x) too small(<0x%x)\n", OutLength, sizeof(DRV_VERSION)));
                DEBUG_BREAKPOINT();
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            pVersion            = (PDRV_VERSION)pBuffer;
            pVersion->major     = 1;
            pVersion->minor     = 0;
            pVersion->internal  = 0;

            pIrp -> IoStatus.Information = sizeof(DRV_VERSION);

            Status = STATUS_SUCCESS;
            break;

        case IOCTL_CANCEL_IO:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_CANCEL_IO\n"));
            fAbort = TRUE;

            //
            // Falling through to the next case, this is intentional. We want to reset pipe when
            // cancel requested
            //

        case IOCTL_RESET_PIPE:
            if(IOCTL_RESET_PIPE == IoControlCode){
                DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_RESET_PIPE\n"));
                fAbort = FALSE;
            }

            //
            // Validate buffer size
            //

            if (InLength < sizeof(PIPE_TYPE) ) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Pipe type buffer (0x%x bytes) too small\n" ,InLength));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            Status = USCancelPipe(pDeviceObject,
                                  pIrp,
                                  *(PIPE_TYPE*)pBuffer,
                                  fAbort);
            break;

        case IOCTL_WAIT_ON_DEVICE_EVENT:
        {
            ULONG   Index;
            ULONG   Timeout;
            PULONG  pTimeout;


            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_WAIT_ON_DEVICE_EVENT\n"));

            Index = USGetPipeIndexToUse(pDeviceObject,
                                        pIrp,
                                        pde -> IndexInterrupt);

            if (OutLength < pde -> PipeInfo[Index].MaximumPacketSize) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! User buffer(0x%x) too small(<)\n"
                                        , OutLength
                                        , pde -> PipeInfo[Index].MaximumPacketSize));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Copy timeout value from file context.
            //

            Timeout = pFileContext->TimeoutEvent;

            //
            // If timeout value is 0, then never timeout.
            //

            if(0 == Timeout){
                pTimeout = NULL;
            } else {
                DebugTrace(TRACE_STATUS,("USDeviceControl: Timeout is set to 0x%x sec.\n", Timeout));
                pTimeout = &Timeout;
            }

            Status = USTransfer(pDeviceObject,
                                pIrp,
                                Index,
                                pIrp -> AssociatedIrp.SystemBuffer,
                                NULL,
                                pde  -> PipeInfo[Index].MaximumPacketSize,
                                pTimeout);

            //
            // IRP should be completed in USTransfer or its completion routine.
            //

            goto USDeviceControl_return;
        }

        case IOCTL_READ_REGISTERS:
            fRead = TRUE;
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_READ_REGISTERS\n"));

        case IOCTL_WRITE_REGISTERS:{

            if (IOCTL_WRITE_REGISTERS == IoControlCode) {
                DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_WRITE_REGISTERS\n"));
                fRead = FALSE;
            }
#ifdef _WIN64
            
            if(IoIs32bitProcess(pIrp)){
                PIO_BLOCK_32    pIoBlock32;

                if (InLength < sizeof(IO_BLOCK_32) ) {
                    DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Invalid input 32bit buffer size(0x%x<0x%x)\n"
                                            , InLength,
                                            sizeof(IO_BLOCK_32)));
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                // Copy all parameters from 32bit structure.
                //
                
                pIoBlock32  = (PIO_BLOCK_32)pBuffer;
                pIoBlock    = &LocalIoBlock;

                pIoBlock -> uOffset = pIoBlock32 -> uOffset;
                pIoBlock -> uLength = pIoBlock32 -> uLength;
                pIoBlock -> pbyData = pIoBlock32 -> pbyData;
                pIoBlock -> uIndex  = pIoBlock32 -> uIndex;

            } else { // if(IoIs32bitProcess(pIrp))
#endif // _WIN64

            if (InLength < sizeof(IO_BLOCK) ) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Invalid input buffer size(0x%x<0x%x)\n"
                                        , InLength,
                                        sizeof(IO_BLOCK)));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
            pIoBlock = (PIO_BLOCK)pBuffer;

#ifdef _WIN64
            } // if(IoIs32bitProcess(pIrp))
#endif // _WIN64 

            if(TRUE == fRead){

                //
                // Check the size of Output buffer.
                //

                if (OutLength < pIoBlock -> uLength) {
                    DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Out buffer(0x%x) too small(<0x%x)\n"
                                            , OutLength
                                            , pIoBlock -> uLength));
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                } // if (OutLength < pIoBlock -> uLength)
            } // if(TRUE == fRead)

            pIrp -> IoStatus.Information = pIoBlock -> uLength;

            //
            // Caller gives us a pointer, embedded into IOCTL buffer. If call is made from
            // user-mode , we need to validate that given pointer is readable.
            //

            if (pIrp->RequestorMode != KernelMode) {

                try {
                    ProbeForRead(pIoBlock->pbyData,
                                 pIoBlock -> uLength,
                                 sizeof(UCHAR));

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    DebugTrace(TRACE_ERROR,("USDeviceControl: Read/Write registers  buffer pointer is invalid\n"));
                    DEBUG_BREAKPOINT();

                    Status = GetExceptionCode();

                    pIrp -> IoStatus.Information = 0;
                    break;
                } // except
            } // !kernelmode

            //
            // Now go to worker function
            //

            Status = USReadWriteRegisters(pDeviceObject,
                                          pIoBlock,
                                          fRead,
                                          InLength);
            if (STATUS_SUCCESS != Status) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! USReadWriteRegisters failed\n"));
                DEBUG_BREAKPOINT();
                pIrp -> IoStatus.Information = 0;
            }
            break;
        } // case IOCTL_WRITE_REGISTERS:
        case IOCTL_GET_CHANNEL_ALIGN_RQST:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_GET_CHANNEL_ALIGN_REQUEST\n"));

            if (OutLength < sizeof(CHANNEL_INFO) ) {

                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Buffer(0x%x) too small(<0x%x)\n"
                                        , OutLength
                                        ,sizeof(CHANNEL_INFO)));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            pIoBlock = (PIO_BLOCK)pBuffer;
            RtlZeroMemory((PCHANNEL_INFO)pIoBlock, sizeof(CHANNEL_INFO));

            for (i = 0; i < pde -> NumberOfPipes; i++) {

                //
                // Have to check which pipe to use
                //

                ULONG Index;
                Index = USGetPipeIndexToUse(pDeviceObject,
                                            pIrp,
                                            i);
                switch (pde -> PipeInfo[Index].PipeType) {
                    case USB_ENDPOINT_TYPE_INTERRUPT:
                        ((PCHANNEL_INFO)pIoBlock)->EventChannelSize = pde -> PipeInfo[Index].MaximumPacketSize;
                        break;
                    case USB_ENDPOINT_TYPE_BULK:
                        if (pde -> pEndpointDescriptor[Index].bEndpointAddress & BULKIN_FLAG) {
                            ((PCHANNEL_INFO)pIoBlock) -> uReadDataAlignment  = pde -> PipeInfo[Index].MaximumPacketSize;
                        } else {
                            ((PCHANNEL_INFO)pIoBlock) -> uWriteDataAlignment = pde -> PipeInfo[Index].MaximumPacketSize;
                        }
                        break;
                }
            }
            pIrp -> IoStatus.Information = sizeof(CHANNEL_INFO);
            Status = STATUS_SUCCESS;
            break;

        case IOCTL_GET_DEVICE_DESCRIPTOR:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_GET_DEVICE_DESCRIPTOR\n"));

            if (OutLength < sizeof(DEVICE_DESCRIPTOR)) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Out buffer(0x%x) is too small(<0x%x)\n"
                                        , OutLength
                                        , sizeof(DEVICE_DESCRIPTOR)));
                Status = STATUS_INVALID_PARAMETER_6;
                break;
            }

            pDesc = (PDEVICE_DESCRIPTOR)pBuffer;
            pDesc -> usVendorId   = pde -> pDeviceDescriptor -> idVendor;
            pDesc -> usProductId  = pde -> pDeviceDescriptor -> idProduct;
            pDesc -> usBcdDevice  = pde -> pDeviceDescriptor -> bcdDevice;

            DebugTrace(TRACE_STATUS,("USDeviceControl: Vendor ID:%d\n", pDesc -> usVendorId));
            DebugTrace(TRACE_STATUS,("USDeviceControl: Product ID:%d\n", pDesc -> usProductId));
            DebugTrace(TRACE_STATUS,("USDeviceControl: BcdDevice:%d\n", pDesc -> usBcdDevice));

            pIrp -> IoStatus.Information = sizeof(DEVICE_DESCRIPTOR);
            Status = STATUS_SUCCESS;
            break;


        case IOCTL_GET_USB_DESCRIPTOR:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_GET_USB_DESCRIPTOR\n"));

            if (OutLength < sizeof(USBSCAN_GET_DESCRIPTOR)) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Out buffer(0x%x) is too small(<0x%x)\n"
                                        , OutLength
                                        , sizeof(USBSCAN_GET_DESCRIPTOR)));
                Status = STATUS_INVALID_PARAMETER_6;
                break;
            }

            pGetDesc = (PUSBSCAN_GET_DESCRIPTOR)pBuffer;
            pUrb = USAllocatePool(NonPagedPool,
                                  sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
            if (NULL == pUrb) {
                DebugTrace(TRACE_CRITICAL,("USDeviceControl: ERROR!! Can't allocate control descriptor URB.\n"));
                DEBUG_BREAKPOINT();
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

#ifdef DEBUG
            switch(pGetDesc -> DescriptorType){
                case USB_DEVICE_DESCRIPTOR_TYPE:
                    DebugTrace(TRACE_STATUS,("USDeviceControl: USB_DEVICE_DESCRIPTOR_TYPE\n"));
                    break;
                case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                    DebugTrace(TRACE_STATUS,("USDeviceControl: USB_CONFIGURATION_DESCRIPTOR_TYPE\n"));
                    break;
                case USB_STRING_DESCRIPTOR_TYPE:
                    DebugTrace(TRACE_STATUS,("USDeviceControl: USB_STRING_DESCRIPTOR_TYPE\n"));
                    break;
                default:
                    DebugTrace(TRACE_WARNING,("USDeviceControl: WARNING!! 0x%x = Undefined.\n", pGetDesc -> DescriptorType));
                    Status = STATUS_INVALID_PARAMETER_3;

                    USFreePool(pUrb);
                    pUrb = NULL;
                    pIrp -> IoStatus.Information = 0;
                    goto USDeviceControl_return;
            }
            DebugTrace(TRACE_STATUS, ("USDeviceControl: Index         :%d\n",pGetDesc -> Index));
            DebugTrace(TRACE_STATUS, ("USDeviceControl: LanguageID    :%d\n", pGetDesc -> LanguageId));
#endif //DEBUG

            UsbBuildGetDescriptorRequest(pUrb,
                                         (USHORT)sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         pGetDesc -> DescriptorType,
                                         pGetDesc -> Index,
                                         pGetDesc -> LanguageId,
                                         pBuffer,
                                         NULL,
                                         OutLength,
                                         NULL);

            Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);
#ifdef DEBUG
            if ( (STATUS_SUCCESS == Status)
//           &&  (USB_DEVICE_DESCRIPTOR_TYPE == pGetDesc -> DescriptorType)
            )
            {
                PUSB_DEVICE_DESCRIPTOR pDeviceDescriptor;
                pDeviceDescriptor = (PUSB_DEVICE_DESCRIPTOR)pBuffer;
                DebugTrace(TRACE_STATUS,("USDeviceControl: Device Descriptor = %x, len %x\n",
                                           pDeviceDescriptor,
                                           pUrb->UrbControlDescriptorRequest.TransferBufferLength));

                DebugTrace(TRACE_STATUS,("USDeviceControl: USBSCAN Device Descriptor:\n"));
                DebugTrace(TRACE_STATUS,("USDeviceControl: -------------------------\n"));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bLength            %d\n",   pDeviceDescriptor->bLength));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bDescriptorType    0x%x\n", pDeviceDescriptor->bDescriptorType));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bcdUSB             0x%x\n", pDeviceDescriptor->bcdUSB));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bDeviceClass       0x%x\n", pDeviceDescriptor->bDeviceClass));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bDeviceSubClass    0x%x\n", pDeviceDescriptor->bDeviceSubClass));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bDeviceProtocol    0x%x\n", pDeviceDescriptor->bDeviceProtocol));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bMaxPacketSize0    0x%x\n", pDeviceDescriptor->bMaxPacketSize0));
                DebugTrace(TRACE_STATUS,("USDeviceControl: idVendor           0x%x\n", pDeviceDescriptor->idVendor));
                DebugTrace(TRACE_STATUS,("USDeviceControl: idProduct          0x%x\n", pDeviceDescriptor->idProduct));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bcdDevice          0x%x\n", pDeviceDescriptor->bcdDevice));
                DebugTrace(TRACE_STATUS,("USDeviceControl: iManufacturer      0x%x\n", pDeviceDescriptor->iManufacturer));
                DebugTrace(TRACE_STATUS,("USDeviceControl: iProduct           0x%x\n", pDeviceDescriptor->iProduct));
                DebugTrace(TRACE_STATUS,("USDeviceControl: iSerialNumber      0x%x\n", pDeviceDescriptor->iSerialNumber));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bNumConfigurations 0x%x\n", pDeviceDescriptor->bNumConfigurations));

            } else {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR! Status = %d\n", Status));
            }

#endif //DEBUG

            USFreePool(pUrb);
            pUrb = NULL;
            pIrp -> IoStatus.Information = ((PUSB_DEVICE_DESCRIPTOR)pBuffer)->bLength;
            break;

        case IOCTL_SEND_USB_REQUEST:
        {

            //
            // Generic pass-through mechanism for USB vendor requests.
            //

            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_SEND_USB_REQUEST\n"));

            //
            // Validate length parameters.
            //

#ifdef _WIN64
            
            if(IoIs32bitProcess(pIrp)){
                PIO_BLOCK_EX_32 pIoBlockEx32;

                if (InLength < sizeof(IO_BLOCK_EX_32) ) {
                    DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Invalid input 32bit buffer size(0x%x<0x%x)\n"
                                            , InLength,
                                            sizeof(IO_BLOCK_EX_32)));
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                // Copy all parameters from 32bit structure.
                //
                
                pIoBlockEx32    = (PIO_BLOCK_EX_32)pBuffer;
                pIoBlockEx      = &LocalIoBlockEx;

                pIoBlockEx -> uOffset               = pIoBlockEx32 -> uOffset;
                pIoBlockEx -> uLength               = pIoBlockEx32 -> uLength;
                pIoBlockEx -> pbyData               = pIoBlockEx32 -> pbyData;
                pIoBlockEx -> uIndex                = pIoBlockEx32 -> uIndex;
                pIoBlockEx -> bRequest              = pIoBlockEx32 -> bRequest;
                pIoBlockEx -> bmRequestType         = pIoBlockEx32 -> bmRequestType;
                pIoBlockEx -> fTransferDirectionIn  = pIoBlockEx32 -> fTransferDirectionIn;

            } else { // if(IoIs32bitProcess(pIrp))
#endif // _WIN64

            if (InLength < sizeof(IO_BLOCK_EX) ) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! I/O buffer(0x%x) too small(<0x%x)\n"
                                        , InLength
                                        , sizeof(IO_BLOCK_EX)));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            pIoBlockEx = (PIO_BLOCK_EX)pBuffer;

#ifdef _WIN64
            } // if(IoIs32bitProcess(pIrp))
#endif // _WIN64 

            if (pIoBlockEx->fTransferDirectionIn) {

                //
                // Check output buffer length is valid.
                //

                if (OutLength < pIoBlockEx -> uLength) {
                    DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! OutLength too small\n"));
                    DEBUG_BREAKPOINT();
                    Status = STATUS_INVALID_PARAMETER;
                    pIrp -> IoStatus.Information = 0;
                    break;
                }
                pIrp -> IoStatus.Information = pIoBlockEx -> uLength;

            } else {

                //
                // No output to the caller.
                //

                pIrp -> IoStatus.Information = 0;
            }

            //
            // Validate user buffer.
            //

            if (pIrp->RequestorMode != KernelMode) {

                try {
                    ProbeForRead(pIoBlockEx->pbyData,
                                 pIoBlockEx->uLength,
                                 sizeof(UCHAR));

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    DebugTrace(TRACE_ERROR,("USDeviceControl: User buffer pointer is invalid\n"));

                    Status = GetExceptionCode();

                    pIrp -> IoStatus.Information = 0;
                    break;
                } // except
            } // !kernelmode

            //
            // Now go to worker function
            //

            Status = USPassThruUSBRequest(pDeviceObject,
                                          (PIO_BLOCK_EX)pBuffer,
                                          InLength,
                                          OutLength
                                          );

            if (STATUS_SUCCESS != Status) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! USPassThruUSBRequest failed\n"));
                DEBUG_BREAKPOINT();
                pIrp -> IoStatus.Information = 0;
            }

            break;

        } // case IOCTL_SEND_USB_REQUEST:
        
        case IOCTL_SEND_USB_REQUEST_PTP:
        {

            //
            // Generic pass-through mechanism for USB vendor requests.
            //

            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_SEND_USB_REQUEST_PTP\n"));

            //
            // Validate length parameters.
            //

#ifdef _WIN64
            
            if(IoIs32bitProcess(pIrp)){
                PIO_BLOCK_EX_32 pIoBlockEx32;

                if (InLength < sizeof(IO_BLOCK_EX_32) ) {
                    DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Invalid input 32bit buffer size(0x%x<0x%x)\n"
                                            , InLength,
                                            sizeof(IO_BLOCK_EX_32)));
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                // Copy all parameters from 32bit structure.
                //
                
                pIoBlockEx32    = (PIO_BLOCK_EX_32)pBuffer;
                pIoBlockEx      = &LocalIoBlockEx;

                pIoBlockEx -> uOffset               = pIoBlockEx32 -> uOffset;
                pIoBlockEx -> uLength               = pIoBlockEx32 -> uLength;
                pIoBlockEx -> pbyData               = pIoBlockEx32 -> pbyData;
                pIoBlockEx -> uIndex                = pIoBlockEx32 -> uIndex;
                pIoBlockEx -> bRequest              = pIoBlockEx32 -> bRequest;
                pIoBlockEx -> bmRequestType         = pIoBlockEx32 -> bmRequestType;
                pIoBlockEx -> fTransferDirectionIn  = pIoBlockEx32 -> fTransferDirectionIn;

            } else { // if(IoIs32bitProcess(pIrp))
#endif // _WIN64

            if (InLength < sizeof(IO_BLOCK_EX) ) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! I/O buffer(0x%x) too small(<0x%x)\n"
                                        , InLength
                                        , sizeof(IO_BLOCK_EX)));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            pIoBlockEx = (PIO_BLOCK_EX)pBuffer;

#ifdef _WIN64
            } // if(IoIs32bitProcess(pIrp))
#endif // _WIN64 

            if (pIoBlockEx->fTransferDirectionIn) {

                //
                // Check output buffer length is valid.
                //

                if (OutLength < pIoBlockEx -> uLength) {
                    DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! OutLength too small\n"));
                    DEBUG_BREAKPOINT();
                    Status = STATUS_INVALID_PARAMETER;
                    pIrp -> IoStatus.Information = 0;
                    break;
                }
                pIrp -> IoStatus.Information = pIoBlockEx -> uLength;

            } else {

                //
                // No output to the caller.
                //

                pIrp -> IoStatus.Information = 0;
            }

            //
            // Validate user buffer.
            //

            if (pIrp->RequestorMode != KernelMode) {

                try {
                    ProbeForRead(pIoBlockEx->pbyData,
                                 pIoBlockEx->uLength,
                                 sizeof(UCHAR));

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    DebugTrace(TRACE_ERROR,("USDeviceControl: User buffer pointer is invalid\n"));

                    Status = GetExceptionCode();

                    pIrp -> IoStatus.Information = 0;
                    break;
                } // except
            } // !kernelmode

            //
            // Now go to worker function
            //

            Status = USPassThruUSBRequestPTP(pDeviceObject,
                                             (PIO_BLOCK_EX)pBuffer,
                                             InLength,
                                             OutLength);

            if (STATUS_SUCCESS != Status) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! USPassThruUSBRequestPTP failed\n"));
                DEBUG_BREAKPOINT();
                pIrp -> IoStatus.Information = 0;
            }

            break;

        } // case IOCTL_SEND_USB_REQUEST_PTP:

        case IOCTL_GET_PIPE_CONFIGURATION:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_GET_PIPE_CONFIGURATION\n"));

            //
            // Check output buffer length
            //

            if (OutLength < sizeof(USBSCAN_PIPE_CONFIGURATION)) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! GetPipeConfig buffer(0x%x) too small(<0x%x)\n"
                                        , OutLength
                                        , sizeof(USBSCAN_PIPE_CONFIGURATION)));
                Status = STATUS_INVALID_PARAMETER_6;
                break;
            }

            //
            // Copy Pipe configuration to user buffer.
            //

            pPipeConfig = (PUSBSCAN_PIPE_CONFIGURATION)pBuffer;
            RtlZeroMemory(pPipeConfig, sizeof(USBSCAN_PIPE_CONFIGURATION));

            pPipeConfig->NumberOfPipes = pde->NumberOfPipes;
            for(i=0; i < pPipeConfig->NumberOfPipes; i++){
                pPipeConfig->PipeInfo[i].MaximumPacketSize = pde->PipeInfo[i].MaximumPacketSize;
                pPipeConfig->PipeInfo[i].EndpointAddress = pde->PipeInfo[i].EndpointAddress;
                pPipeConfig->PipeInfo[i].Interval = pde->PipeInfo[i].Interval;
                pPipeConfig->PipeInfo[i].PipeType = pde->PipeInfo[i].PipeType;
            }

            pIrp -> IoStatus.Information = sizeof(USBSCAN_PIPE_CONFIGURATION);
            Status = STATUS_SUCCESS;
            break;


        case IOCTL_SET_TIMEOUT:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_SET_TIMEOUT\n"));

            //
            // Make sure input buffer size is big enough.
            //

            if(sizeof(USBSCAN_TIMEOUT) > InLength){

                //
                // Incorrect Input buffer size.
                //

                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Invalid input buffer size\n"));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Copy timeout value.
            //

            pFileContext -> TimeoutRead     = ((PUSBSCAN_TIMEOUT)pBuffer) -> TimeoutRead;
            pFileContext -> TimeoutWrite    = ((PUSBSCAN_TIMEOUT)pBuffer) -> TimeoutWrite;
            pFileContext -> TimeoutEvent    = ((PUSBSCAN_TIMEOUT)pBuffer) -> TimeoutEvent;

            pIrp -> IoStatus.Information = 0;

            Status = STATUS_SUCCESS;
            break;

        default:
            DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Unsupported IOCTL\n"));
            Status = STATUS_NOT_SUPPORTED;
            break;
    }


    pIrp -> IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

USDeviceControl_return:
    USDecrementIoCount(pDeviceObject);
    DebugTrace(TRACE_PROC_LEAVE,("USDeviceControl: Leaving.. Status = 0x%x\n", Status));
    return Status;


} // end USDeviceControl()



NTSTATUS
USReadWriteRegisters(
   IN   PDEVICE_OBJECT  pDeviceObject,
   IN   PIO_BLOCK       pIoBlock,
   IN   BOOLEAN         fRead,
   IN   ULONG           IoBlockSize
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PURB                        pUrb;
    ULONG                       siz;
    UCHAR                       Request;
    PVOID                       pBuffer = NULL;
    //USHORT                      uIndex;
    unsigned                   uIndex;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USReadWriteRegisters: Enter..\n"));

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    //
    // Allocate URB
    //

    siz = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
    pUrb = USAllocatePool(NonPagedPool, siz);
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USReadWriteRegisters: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USReadWriteRegisters_return;
    }

    RtlZeroMemory(pUrb, siz);

    //
    // Setup URB
    //

    Request  = REGISTER_AREA;
    if (pIoBlock -> uLength > 1) {
        DebugTrace(TRACE_STATUS,("USReadWriteRegisters: ULength > 1, turning on automatic increment\n"));
        Request |= OPCODE_SEQ_TRANSFER;           // automatic address increment after the read
    } else {
        Request |= OPCODE_SINGLE_ADDR_TRANSFER;   // no address increment after the read
    }

    //
    // Reading registers will read into pIoBlock itself.
    //

    pBuffer = pIoBlock;

    //
    // If we are writing registers, then we need to make a copy of the
    // register block into a non-paged block of memory before handing it off
    // to usbd.
    //

    if (!fRead) {
        DebugTrace(TRACE_STATUS,("USReadWriteRegisters: Write request, allocating non-paged reg buffer, len = %d\n",pIoBlock->uLength));
        pBuffer = USAllocatePool(NonPagedPool, pIoBlock->uLength);
        if (NULL == pBuffer) {
            DebugTrace(TRACE_CRITICAL,("USReadWriteRegisters: ERROR!! cannot allocate write reg buffer\n"));
            DEBUG_BREAKPOINT();
            USFreePool(pUrb);
            pUrb = NULL;
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto USReadWriteRegisters_return;
        }

        //
        // Caller gives us a pointer, embedded into IOCTL buffer. We need to
        // validate that given pointer is readable.
        //

        try{
            RtlCopyMemory(pBuffer,
                          pIoBlock->pbyData,
                          pIoBlock->uLength);

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // Caller buffer is not valid, or worse..
            //

            DebugTrace(TRACE_ERROR,("USReadWriteRegisters: ERROR!! Copying caller buffer failed.\n"));
            DEBUG_BREAKPOINT();
            Status = GetExceptionCode();

            //
            // Clear allocated pool
            //

            USFreePool(pUrb);
            USFreePool(pBuffer);
            pUrb = NULL;
            pBuffer = NULL;

            goto USReadWriteRegisters_return;
        }

    }

    //
    // If the IoBlock is new style (Intel has added a uIndex field to the end of it),
    // then make sure we pass the corrected uIndex value to usbd.
    //

    uIndex = 0;
    if (IoBlockSize == sizeof(IO_BLOCK)) {
        DebugTrace(TRACE_STATUS,("USReadWriteRegisters: New (intel) style IoBlock -- setting uIndex to pIoBlock -> uIndex\n"));
        uIndex = pIoBlock -> uIndex;
    }


    UsbBuildVendorClassSpecificCommand(pUrb,
                                       fRead ? USBD_TRANSFER_DIRECTION_IN : 0,
                                       pIoBlock->uLength,
                                       pBuffer,
                                       NULL,
                                       fRead ? 0xc0 : 0x40,
                                       Request,
                                       (SHORT)pIoBlock->uOffset,
                                       (USHORT)uIndex);

    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

    if (!fRead) {
        DebugTrace(TRACE_STATUS,("USReadWriteRegisters: freeing temp reg buffer\n"));
        USFreePool(pBuffer);
        pBuffer = NULL;
    }

    USFreePool(pUrb);
    pUrb = NULL;

USReadWriteRegisters_return:
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR,("USReadWriteRegisters: ERROR!! Still had unfreed pointer. Free it...\n"));

        if(pUrb){
            USFreePool(pUrb);
        }
        if( (pBuffer)
         && (!fRead ) )
        {
            USFreePool(pBuffer);
        }
    }
    DebugTrace(TRACE_PROC_LEAVE,("USReadWriteRegisters: Leaving.. Status = 0x%x\n", Status));
    return Status;
}


NTSTATUS
USCancelPipe(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp,
    IN PIPE_TYPE        PipeType,
    IN BOOLEAN          fAbort          // TRUE = Abort, FALSE = Reset
)
/*++

Routine Description:

    Cansel URB or reset pipe. If PipeType is PIPE_ALL, it applies to every pipes a device has.
    If not, it applies to only one default pipe even if a device supports multipul same type of pipes.

Arguments:
    pDeviceObject   -   Pointer to Device Object
    pIrp            -   Can be NULL if PipeType is ALL_PIPE
    PipeType        -   Specifies type of pipe
    fAbort          -   Specifies type of operation

Return Value:

    Returns status
--*/
{
    NTSTATUS                    Status, temp;
    PUSBSCAN_DEVICE_EXTENSION   pde;

    PAGED_CODE();

//    DebugTrace(TRACE_PROC_ENTER,("USCancelPipe: Enter.. - "));

    Status = STATUS_SUCCESS;
    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    switch (PipeType) {

        case EVENT_PIPE:

            DebugTrace(TRACE_STATUS,("USCancelPipe: EVENT_PIPE\n"));

            if(NULL == pIrp){
                DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! pIrp not valid\n"));
                break;
            }

            if (-1 == pde -> IndexInterrupt) {
                DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! Interrupt pipe not valid\n"));
                DEBUG_BREAKPOINT();
                Status = STATUS_NOT_SUPPORTED;
                break;
            }

            Status = USAbortResetPipe(pDeviceObject,
                                      USGetPipeIndexToUse(pDeviceObject, pIrp, pde -> IndexInterrupt),
                                      fAbort);
            DebugTrace(TRACE_STATUS,("Event Pipe aborted/reset, Status = 0x%x\n",Status));
            break;

        case READ_DATA_PIPE:

            DebugTrace(TRACE_STATUS,("USCancelPipe: READ_DATA_PIPE\n"));

            if(NULL == pIrp){
                DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! pIrp not valid\n"));
                break;
            }

            if (-1 == pde -> IndexBulkIn) {
                DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! bulk-in pipe not valid\n"));
                DEBUG_BREAKPOINT();
                Status = STATUS_NOT_SUPPORTED;
                break;
            }
            Status = USAbortResetPipe(pDeviceObject,
                                      USGetPipeIndexToUse(pDeviceObject, pIrp, pde -> IndexBulkIn),
                                      fAbort);
            DebugTrace(TRACE_STATUS,("USCancelPipe: Read Pipe aborted/reset, Status = 0x%x\n",Status));
            break;

        case WRITE_DATA_PIPE:

            DebugTrace(TRACE_STATUS,("USCancelPipe: WRITE_DATA_PIPE\n"));

            if(NULL == pIrp){
                DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! pIrp not valid\n"));
                break;
            }

            if (-1 == pde -> IndexBulkOut) {
                DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! bulk-out pipe not valid\n"));
                DEBUG_BREAKPOINT();
                Status = STATUS_NOT_SUPPORTED;
                break;
            }
            Status = USAbortResetPipe(pDeviceObject,
                                      USGetPipeIndexToUse(pDeviceObject, pIrp, pde -> IndexBulkOut),
                                      fAbort);
            DebugTrace(TRACE_STATUS,("Write Pipe aborted/reset, Status = 0x%x\n",Status));
            break;

        case ALL_PIPE:
        {
            ULONG i;

            DebugTrace(TRACE_STATUS,("USCancelPipe: ALL_PIPE\n"));

            for(i=0; i < pde -> NumberOfPipes; i++){
                temp = USAbortResetPipe(pDeviceObject, i, fAbort);
                // DebugTrace(TRACE_STATUS,("USCancelPipe: pipe[%d] aborted/reset, Status = 0x%x\n", i, temp));
                if(STATUS_SUCCESS != temp){
                    Status = temp;
                }
            }
            break;
        }

        default:

            DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! INVALID_PIPE\n"));

            Status = STATUS_INVALID_PARAMETER;
            break;
    }

    DebugTrace(TRACE_PROC_LEAVE,("USCancelPipe: Leaving.. Status = 0x%x\n", Status));
    return Status;
}


NTSTATUS
USAbortResetPipe(
    IN PDEVICE_OBJECT pDeviceObject,
    IN ULONG uIndex,
    IN BOOLEAN fAbort       // TRUE = Abort, FALSE = Reset
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    NTSTATUS                    StatusReset = STATUS_SUCCESS;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PURB                        pUrb;
    ULONG                       siz;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USAbortResetPipe: Enter... \n"));

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pUrb = NULL;

    //
    // Allocate URB
    //

    siz = sizeof(struct _URB_PIPE_REQUEST);
    pUrb = USAllocatePool(NonPagedPool, siz);
    if (NULL == pUrb) {
        DebugTrace(TRACE_ERROR,("USAbortResetPipe: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USAbortResetPipe_return;
    }
    RtlZeroMemory(pUrb, siz);

    if (fAbort) {

        DebugTrace(TRACE_STATUS,("USAbortResetPipe: Aborting pipe[%d]\n", uIndex));

        //
        // Issue abort pipe call to USBD.
        //

        UsbBuildAbortPipeRequest(pUrb,
                                 siz,
                                 pde -> PipeInfo[uIndex].PipeHandle);

        Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

        if (STATUS_SUCCESS != Status) {
            DebugTrace(TRACE_ERROR,("USAbortResetPipe: ERROR!! Abort pipe failed. Status = 0x%x\n",Status));
            goto USAbortResetPipe_return;
        }

        UsbBuildResetPipeRequest(pUrb,
                                 siz,
                                 pde -> PipeInfo[uIndex].PipeHandle);

        StatusReset = USBSCAN_CallUSBD(pDeviceObject, pUrb);

        if (STATUS_SUCCESS != StatusReset) {
            DebugTrace(TRACE_ERROR,("USAbortResetPipe: ERROR!! resetting pipe. Status = 0x%x\n",StatusReset));
            goto USAbortResetPipe_return;
        }


    } else {

        DebugTrace(TRACE_STATUS,("Reseting pipe[%d]\n", uIndex));

        //
        // Issue reset pipe call to USBD.
        //

        UsbBuildResetPipeRequest(pUrb,
                                 siz,
                                 pde -> PipeInfo[uIndex].PipeHandle);

        Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

        if (STATUS_SUCCESS != Status) {
            DebugTrace(TRACE_ERROR,("USAbortResetPipe: ERROR!! Reset pipe failed. Status = 0x%x\n",Status));
            goto USAbortResetPipe_return;
        }
    }

USAbortResetPipe_return:
    //
    // Clean up.
    //

    if(pUrb){
        USFreePool(pUrb);
    }

    DebugTrace(TRACE_PROC_LEAVE,("USAbortResetPipe: Leaving.. Status = 0x%x\n", Status));
    return Status;
}

NTSTATUS
USPassThruUSBRequest(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIO_BLOCK_EX     pIoBlockEx,
    IN ULONG            InLength,
    IN ULONG            OutLength
)
/*++

Routine Description:

    Implements generic pass-thru for vendor request to USBD

Arguments:

    pDeviceObject   -   Device object
    pIoBlockEx      -   Pointer to I/O block as described in USBSCAN.H, passed from user mode client
    InLength        -   In length from IRP
    OutLength       -   Out length from IRP

Return Value:

    NTSTATUS type

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PURB                        pUrb;
    ULONG                       siz;
    PVOID                       pBuffer;
    BOOLEAN                     fDirectionIn;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USPassThruUSBRequest: Enter..\n"));

    //
    // Initialize local variable.
    //

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    Status  = STATUS_SUCCESS;
    pUrb    = NULL;
    pBuffer = NULL;
    fDirectionIn = TRUE;

    //
    // Allocate memory for URB
    //

    siz = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
    pUrb = USAllocatePool(NonPagedPool, siz);
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USPassThruUSBRequest: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USPassThruUSBRequest_return;
    }

    RtlZeroMemory(pUrb, siz);

    //
    // Setup URB
    //

    pBuffer = pIoBlockEx;

    //
    // If we are writing data, then we need to make a copy of the
    // register block into a non-paged block of memory before handing it off
    // to usbd.
    //

    if (!pIoBlockEx->fTransferDirectionIn) {

        DebugTrace(TRACE_STATUS,("USPassThruUSBRequest: Write request, allocating non-paged buffer, len = %d\n",pIoBlockEx->uLength));

        fDirectionIn = FALSE;

        if ( pIoBlockEx->uLength ) {

            pBuffer = USAllocatePool(NonPagedPool, pIoBlockEx->uLength);
            if (NULL == pBuffer) {

                DebugTrace(TRACE_CRITICAL,("USPassThruUSBRequest: ERROR!! cannot allocate write buffer"));
                DEBUG_BREAKPOINT();

                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto USPassThruUSBRequest_return;
            }

            //
            // Caller gives us a pointer, embedded into IOCTL buffer. We need to
            // validate that given pointer is readable.
            //

            try{
                RtlCopyMemory(pBuffer,
                              pIoBlockEx->pbyData,
                              pIoBlockEx->uLength);

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // Caller buffer is not valid, or worse..
                //

                DebugTrace(TRACE_ERROR,("USPassThruUSBRequest: ERROR!! Copying caller buffer failed.\n"));
                DEBUG_BREAKPOINT();
                Status = GetExceptionCode();

                goto USPassThruUSBRequest_return;
            }


        } else {

            //
            // Zero length buffer used for Write , IHV claim that's useful.
            //

            pBuffer = NULL;
        } // if ( pIoBlockEx->uLength )
    }

    UsbBuildVendorClassSpecificCommand(pUrb,
                                       pIoBlockEx->fTransferDirectionIn ? USBD_TRANSFER_DIRECTION_IN : 0,
                                       pIoBlockEx->uLength,
                                       pBuffer,
                                       NULL,
                                       pIoBlockEx->bmRequestType,
                                       pIoBlockEx->bRequest,
                                       (SHORT)pIoBlockEx->uOffset,
                                       (USHORT)pIoBlockEx -> uIndex
                                       );

    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

USPassThruUSBRequest_return:

    //
    // Clean up.
    //

    if(NULL != pUrb){
        DebugTrace(TRACE_STATUS,("USPassThruUSBRequest: Free USB Request Block.\n"));
            USFreePool(pUrb);
        }

    if( (!fDirectionIn)
     && (NULL != pBuffer) )
    {
        DebugTrace(TRACE_STATUS,("USPassThruUSBRequest: Free temp buffer.\n"));
            USFreePool(pBuffer);
        }

    DebugTrace(TRACE_PROC_LEAVE,("USPassThruUSBRequest: Leaving.. Status = 0x%x\n", Status));
    return Status;

}

NTSTATUS
USPassThruUSBRequestPTP(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIO_BLOCK_EX     pIoBlockEx,
    IN ULONG            InLength,
    IN ULONG            OutLength
)
/*++

Routine Description:

    Implements generic pass-thru for vendor request to USBD

Arguments:

    pDeviceObject   -   Device object
    pIoBlockEx      -   Pointer to I/O block as described in USBSCAN.H, passed from user mode client
    InLength        -   In length from IRP
    OutLength       -   Out length from IRP

Return Value:

    NTSTATUS type

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PURB                        pUrb;
    ULONG                       siz;
    PVOID                       pBuffer;
    BOOLEAN                     fDirectionIn;
    USHORT                      usUsbFunction;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USPassThruUSBRequest: Enter..\n"));

    //
    // Initialize local variable.
    //

    pde             = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    Status          = STATUS_SUCCESS;
    pUrb            = NULL;
    pBuffer         = NULL;
    fDirectionIn    = TRUE;
    usUsbFunction   = 0;

    //
    // Allocate memory for URB
    //

    siz = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
    pUrb = USAllocatePool(NonPagedPool, siz);
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USPassThruUSBRequest: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USPassThruUSBRequest_return;
    }

    RtlZeroMemory(pUrb, siz);

    //
    // Setup URB
    //

    pBuffer = pIoBlockEx;

    //
    // If we are writing data, then we need to make a copy of the
    // register block into a non-paged block of memory before handing it off
    // to usbd.
    //

    if (!pIoBlockEx->fTransferDirectionIn) {

        DebugTrace(TRACE_STATUS,("USPassThruUSBRequest: Write request, allocating non-paged buffer, len = %d\n",pIoBlockEx->uLength));

        fDirectionIn = FALSE;

        if ( pIoBlockEx->uLength ) {

            pBuffer = USAllocatePool(NonPagedPool, pIoBlockEx->uLength);
            if (NULL == pBuffer) {

                DebugTrace(TRACE_CRITICAL,("USPassThruUSBRequest: ERROR!! cannot allocate write buffer"));
                DEBUG_BREAKPOINT();

                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto USPassThruUSBRequest_return;
            }

            //
            // Caller gives us a pointer, embedded into IOCTL buffer. We need to
            // validate that given pointer is readable.
            //

            try{
                RtlCopyMemory(pBuffer,
                              pIoBlockEx->pbyData,
                              pIoBlockEx->uLength);

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // Caller buffer is not valid, or worse..
                //

                DebugTrace(TRACE_ERROR,("USPassThruUSBRequest: ERROR!! Copying caller buffer failed.\n"));
                DEBUG_BREAKPOINT();
                Status = GetExceptionCode();

                goto USPassThruUSBRequest_return;
            }


        } else {

            //
            // Zero length buffer used for Write , IHV claim that's useful.
            //

            pBuffer = NULL;
        } // if ( pIoBlockEx->uLength )
    }

    //
    // Set proper USB funtion depends on bmRequestType.
    //
    
    if(0xa1 == pIoBlockEx->bmRequestType){          // USB_PTPREQUEST_TYPE_IN: Class/Interface Device to Host.
        usUsbFunction = URB_FUNCTION_CLASS_INTERFACE;
    } else if(0x21 == pIoBlockEx->bmRequestType){   // USB_PTPREQUEST_TYPE_OUT: Class/Interface Host to Device.
        usUsbFunction = URB_FUNCTION_CLASS_INTERFACE;
    } else {                                        // Default.
        usUsbFunction = URB_FUNCTION_VENDOR_DEVICE;
    }

    UsbBuildVendorClassSpecificCommandPTP(usUsbFunction,
                                          pUrb,
                                          pIoBlockEx->fTransferDirectionIn ? USBD_TRANSFER_DIRECTION_IN : 0,
                                          pIoBlockEx->uLength,
                                          pBuffer,
                                          NULL,
                                          pIoBlockEx->bmRequestType,
                                          pIoBlockEx->bRequest,
                                          (SHORT)pIoBlockEx->uOffset,
                                          (USHORT)pIoBlockEx -> uIndex);

    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

USPassThruUSBRequest_return:

    //
    // Clean up.
    //

    if(NULL != pUrb){
        DebugTrace(TRACE_STATUS,("USPassThruUSBRequest: Free USB Request Block.\n"));
            USFreePool(pUrb);
        }

    if( (!fDirectionIn)
     && (NULL != pBuffer) )
    {
        DebugTrace(TRACE_STATUS,("USPassThruUSBRequest: Free temp buffer.\n"));
            USFreePool(pBuffer);
        }

    DebugTrace(TRACE_PROC_LEAVE,("USPassThruUSBRequest: Leaving.. Status = 0x%x\n", Status));
    return Status;

} // USPassThruUSBRequestPTP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\usbscn9x\ocrw.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2001

Module Name:

    ocrw.c

Abstract:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include <stdio.h>
#include "stddef.h"
#include "wdm.h"
#include "usbscan.h"
#include "usbd_api.h"
#include "private.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USOpen)
#pragma alloc_text(PAGE, USClose)
#pragma alloc_text(PAGE, USFlush)
#pragma alloc_text(PAGE, USRead)
#pragma alloc_text(PAGE, USWrite)
#pragma alloc_text(PAGE, USGetPipeIndexToUse)
#pragma alloc_text(PAGE, USTransfer)
#endif

NTSTATUS
USOpen(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
/*++

Routine Description:

    This routine is called to establish a connection to the device
    class driver. It does no more than return STATUS_SUCCESS.

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Open request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                        Status;
    PUSBSCAN_DEVICE_EXTENSION       pde;
    PFILE_OBJECT                    fileObject;
    PUSBSCAN_FILE_CONTEXT           pFileContext;
    PIO_STACK_LOCATION              irpStack;
    PKEY_VALUE_PARTIAL_INFORMATION  pValueInfo;
    ULONG                           nameLen, ix;

    PAGED_CODE();
    DebugTrace(TRACE_PROC_ENTER,("USOpen: Enter..\n",pIrp));

    //
    // Increment I/O processing counter.
    //
    
    USIncrementIoCount( pDeviceObject );

    //
    // Initialize locals.
    //
    
    pde         = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    irpStack    = IoGetCurrentIrpStackLocation (pIrp);
    fileObject  = irpStack->FileObject;
    pValueInfo  = NULL;

    Status      = STATUS_SUCCESS;

    //
    // Initialize file context.
    //
    
    fileObject->FsContext = NULL;
    
    //
    // Check if it's accepting requests.
    //
    
    if (FALSE == pde -> AcceptingRequests) {
        DebugTrace(TRACE_WARNING,("USOpen: WARNING!! Device isn't accepting request.\n"));
        Status = STATUS_DELETE_PENDING;
        goto USOpen_return;
    }

    //
    // Check device power state.
    //
    
    if (PowerDeviceD0 != pde -> CurrentDevicePowerState) {
        DebugTrace(TRACE_WARNING,("USOpen: WARNING!! Device is suspended.\n"));
        Status = STATUS_DELETE_PENDING;
        goto USOpen_return;
    }

    //
    // Allocate file context buffer.
    //

    pFileContext = USAllocatePool(NonPagedPool, sizeof(USBSCAN_FILE_CONTEXT));
    if(NULL == pFileContext){
        DebugTrace(TRACE_CRITICAL,("USOpen: ERROR!! Can't allocate file context\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USOpen_return;
    }
    RtlZeroMemory(pFileContext, sizeof(USBSCAN_FILE_CONTEXT));
    
    //
    // Set allocated buffer to the context.
    //

    fileObject->FsContext = pFileContext;

    //
    // Check the length of CreateFile name to see if pipe is specified by prefix.
    //
    
    nameLen     = fileObject->FileName.Length;
    DebugTrace(TRACE_STATUS,("USOpen: CreateFile name=%ws, Length=%d.\n", fileObject->FileName.Buffer, nameLen));

    if (0 == nameLen) {

        //
        // Use default pipe
        //
        
        pFileContext->PipeIndex = -1;

    } else {

        //
        // Pipe number must be '\' + one digit , like '\0'.
        // length would be 4.
        //

        if( (4 != nameLen)
         || (fileObject->FileName.Buffer[1] < (WCHAR) '0')
         || (fileObject->FileName.Buffer[1] > (WCHAR) '9') )
        {
            DebugTrace(TRACE_ERROR,("USOpen: ERROR!! Invalid CreateFile Name\n"));
            Status = STATUS_INVALID_PARAMETER;
        } else {
            pFileContext->PipeIndex = (LONG)(fileObject->FileName.Buffer[1] - (WCHAR) '0');

            //
            // Check if pipe index is lower than maximum
            //

            if(pFileContext->PipeIndex > (LONG)pde->NumberOfPipes){
                DebugTrace(TRACE_ERROR,("USOpen: ERROR!! Invalid pipe index(0x%x). Use default.\n", pFileContext->PipeIndex));
                pFileContext->PipeIndex = -1;
                Status = STATUS_INVALID_PARAMETER;
            }
        }
    }

    //
    // Read default timeout value from registry. If not exist, then set default.
    //
    
    // Timeout for Read.
    Status = UsbScanReadDeviceRegistry(pde,
                                       USBSCAN_REG_TIMEOUT_READ,
                                       &pValueInfo);
    if(NT_SUCCESS(Status)){
        if(NULL != pValueInfo){
            pFileContext->TimeoutRead = *((PULONG)pValueInfo->Data);
            USFreePool(pValueInfo);
            pValueInfo = NULL;
        } else {
            DebugTrace(TRACE_ERROR,("USOpen: ERROR!! UsbScanReadDeviceRegistry(1) succeeded but pValueInfo is NULL.\n"));
            pFileContext->TimeoutRead = USBSCAN_TIMEOUT_READ;
        }
    } else {
        pFileContext->TimeoutRead = USBSCAN_TIMEOUT_READ;
    }
    DebugTrace(TRACE_STATUS,("USOpen: Default Read timeout=0x%xsec.\n", pFileContext->TimeoutRead));

    // Timeout for Write.
    Status = UsbScanReadDeviceRegistry(pde,
                                       USBSCAN_REG_TIMEOUT_WRITE,
                                       &pValueInfo);
    if(NT_SUCCESS(Status)){
        if(NULL != pValueInfo){
            pFileContext->TimeoutWrite = *((PULONG)pValueInfo->Data);
            USFreePool(pValueInfo);
            pValueInfo = NULL;
        } else {
            DebugTrace(TRACE_ERROR,("USOpen: ERROR!! UsbScanReadDeviceRegistry(2) succeeded but pValueInfo is NULL.\n"));
            pFileContext->TimeoutRead = USBSCAN_TIMEOUT_WRITE;
        }
    } else {
        pFileContext->TimeoutWrite = USBSCAN_TIMEOUT_WRITE;

    }
    DebugTrace(TRACE_STATUS,("USOpen: Default Write timeout=0x%xsec.\n", pFileContext->TimeoutWrite));

    // Timeout for Event.
    Status = UsbScanReadDeviceRegistry(pde,
                                       USBSCAN_REG_TIMEOUT_EVENT,
                                       &pValueInfo);
    if(NT_SUCCESS(Status)){
        if(NULL != pValueInfo){
            pFileContext->TimeoutEvent = *((PULONG)pValueInfo->Data);
            USFreePool(pValueInfo);
            pValueInfo = NULL;
        } else {
            DebugTrace(TRACE_ERROR,("USOpen: ERROR!! UsbScanReadDeviceRegistry(3) succeeded but pValueInfo is NULL.\n"));
            pFileContext->TimeoutRead = USBSCAN_TIMEOUT_EVENT;
        }
    } else {
        pFileContext->TimeoutEvent = USBSCAN_TIMEOUT_EVENT;
    }
    DebugTrace(TRACE_STATUS,("USOpen: Default Event timeout=0x%xsec.\n", pFileContext->TimeoutEvent));
    
    //
    // Return successfully.
    //
    
    Status      = STATUS_SUCCESS;

USOpen_return:

    pIrp -> IoStatus.Information = 0;
    pIrp -> IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    USDecrementIoCount(pDeviceObject);
    DebugTrace(TRACE_PROC_LEAVE,("USOpen: Leaving.. Status = %x.\n", Status));
    return Status;

} // end USOpen()

NTSTATUS
USFlush(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
/*++

Routine Description:

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Close request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                   Status;
    PUSBSCAN_DEVICE_EXTENSION  pde;
    ULONG                      i;

    PAGED_CODE();
    DebugTrace(TRACE_PROC_ENTER,("USFlush: Enter..\n",pIrp));

    USIncrementIoCount( pDeviceObject );

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    Status = STATUS_SUCCESS;
    for(i = 0; i < pde->NumberOfPipes; i++){
        if( (pde->PipeInfo[i].PipeType == UsbdPipeTypeBulk)
         && (pde->PipeInfo[i].EndpointAddress & BULKIN_FLAG) )
        {
            DebugTrace(TRACE_STATUS,("USFlush: Flushing Buffer[%d].\n",i));

            if (pde->ReadPipeBuffer[i].RemainingData > 0) {
                    DebugTrace(TRACE_STATUS,("USFlush: Buffer[%d] 0x%p -> 0x%p.\n",
                                                    i,
                                                    pde->ReadPipeBuffer[i].pBuffer,
                                                    pde->ReadPipeBuffer[i].pStartBuffer));
                    pde->ReadPipeBuffer[i].pBuffer = pde->ReadPipeBuffer[i].pStartBuffer;
                    pde->ReadPipeBuffer[i].RemainingData = 0;
            }
        }
    }

    pIrp -> IoStatus.Information = 0;
    pIrp -> IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    USDecrementIoCount(pDeviceObject);
    DebugTrace(TRACE_PROC_LEAVE,("USFlush: Leaving.. Status = %x.\n", Status));
    return Status;

} // end USFlush()


NTSTATUS
USClose(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
/*++

Routine Description:

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Close request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                    Status;
    PFILE_OBJECT                fileObject;
    PUSBSCAN_FILE_CONTEXT       pFileContext;
    PIO_STACK_LOCATION          pIrpStack;

    PAGED_CODE();
    DebugTrace(TRACE_PROC_ENTER,("USClose: Enter..\n",pIrp));

    USIncrementIoCount( pDeviceObject );

    //
    // Initialize locals.
    //
    
    pIrpStack       = IoGetCurrentIrpStackLocation (pIrp);
    fileObject      = pIrpStack->FileObject;
    pFileContext    = fileObject->FsContext;

    //
    // Free context buffer.
    //
    
    ASSERT(NULL != pFileContext);
    USFreePool(pFileContext);
    pFileContext = NULL;

    //
    // Complete.
    //
    
    Status      = STATUS_SUCCESS;

    pIrp -> IoStatus.Information = 0;
    pIrp -> IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    USDecrementIoCount(pDeviceObject);
    DebugTrace(TRACE_PROC_LEAVE,("USClose: Leaving.. Status = %x.\n", Status));
    return Status;

} // end USClose()


NTSTATUS
USRead(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
/*++

Routine Description:

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Read request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PIO_STACK_LOCATION          pIrpStack;
    PFILE_OBJECT                fileObject;
    PUSBSCAN_FILE_CONTEXT       pFileContext;
    ULONG                       Timeout;
    PULONG                      pTimeout;

    PAGED_CODE();
    DebugTrace(TRACE_PROC_ENTER,("USRead: Enter..\n",pIrp));
//    DebugTrace(TRACE_ERROR,("USRead: Enter.. size=0x%x\n",pIrpStack -> Parameters.Write.Length));

    ASSERT(pIrp -> MdlAddress);

    USIncrementIoCount( pDeviceObject );

    //
    // Initialize locals.
    //
    
    pde             = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    //
    // Check if it's accepting requests.
    //
    
    if (pde -> AcceptingRequests == FALSE) {
        DebugTrace(TRACE_ERROR,("USRead: ERROR!! Read issued after device stopped/removed!\n"));
        Status = STATUS_FILE_CLOSED;
        pIrp -> IoStatus.Information = 0;
        pIrp -> IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        goto USRead_return;
    }

    //
    // Check device power state.
    //
    
    if (PowerDeviceD0 != pde -> CurrentDevicePowerState) {
        DebugTrace(TRACE_WARNING,("USRead: WARNING!! Device is suspended.\n"));
        Status = STATUS_FILE_CLOSED;
        pIrp -> IoStatus.Information = 0;
        pIrp -> IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        goto USRead_return;
    }

    pIrpStack       = IoGetCurrentIrpStackLocation (pIrp);
    fileObject      = pIrpStack->FileObject;
    pFileContext    = fileObject->FsContext;

    //
    // Copy timeout value for Read from file context.
    //
    
    Timeout = pFileContext->TimeoutRead;
    
    //
    // If timeout value is 0, then never timeout.
    //
    
    if(0 == Timeout){
        pTimeout = NULL;
    } else {
        DebugTrace(TRACE_STATUS,("USRead: Timeout is set to 0x%x sec.\n", Timeout));
        pTimeout = &Timeout;
    }

    //
    // Call worker funciton.
    //
    
    Status = USTransfer(pDeviceObject,
                        pIrp,
                        pde -> IndexBulkIn,
                        NULL,
                        pIrp -> MdlAddress,
                        pIrpStack -> Parameters.Read.Length,
                        pTimeout);
    //
    // IRP should be completed in USTransfer or its completion routine.
    //

USRead_return:
    USDecrementIoCount(pDeviceObject);
    DebugTrace(TRACE_PROC_LEAVE,("USRead: Leaving.. Status = %x.\n", Status));
    return Status;
}


NTSTATUS
USWrite(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
/*++

Routine Description:

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Write request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PIO_STACK_LOCATION          pIrpStack;
    PFILE_OBJECT                fileObject;
    PUSBSCAN_FILE_CONTEXT       pFileContext;
    ULONG                       Timeout;
    PULONG                      pTimeout;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USWrite: Enter..\n",pIrp));
//    DebugTrace(TRACE_ERROR,("USWrite: Enter.. size=0x%x\n",pIrpStack -> Parameters.Write.Length));

//    ASSERT(pIrp -> MdlAddress);

    USIncrementIoCount( pDeviceObject );

    //
    // Initialize locals.
    //
    
    pde             = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    //
    // Check if it's accepting requests.
    //

    if (pde -> AcceptingRequests == FALSE) {
        DebugTrace(TRACE_ERROR,("USWrite: ERROR!! Write issued after device stopped/removed!\n"));
        Status = STATUS_FILE_CLOSED;
        pIrp -> IoStatus.Information = 0;
        pIrp -> IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        goto USWrite_return;
    }

    //
    // Check device power state.
    //
    
    if (PowerDeviceD0 != pde -> CurrentDevicePowerState) {
        DebugTrace(TRACE_WARNING,("USWrite: WARNING!! Device is suspended.\n"));
        Status = STATUS_FILE_CLOSED;
        pIrp -> IoStatus.Information = 0;
        pIrp -> IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        goto USWrite_return;
    }

    pIrpStack       = IoGetCurrentIrpStackLocation (pIrp);
    fileObject      = pIrpStack->FileObject;
    pFileContext    = fileObject->FsContext;

    //
    // Copy timeout value for Write from file context.
    //
    
    Timeout = pFileContext->TimeoutWrite;
    
    //
    // If timeout value is 0, then never timeout.
    //
    
    if(0 == Timeout){
        pTimeout = NULL;
    } else {
        DebugTrace(TRACE_STATUS,("USWrite: Timeout is set to 0x%x sec.\n", Timeout));
        pTimeout = &Timeout;
    }

    //
    // Call worker funciton.
    //

#if DBG
{
    PUCHAR  pDumpBuf = NULL;

    if (NULL != pIrp -> MdlAddress) {
        pIrp -> MdlAddress -> MdlFlags |= MDL_MAPPING_CAN_FAIL;
        pDumpBuf = MmGetSystemAddressForMdl(pIrp -> MdlAddress);
    }

    if(NULL != pDumpBuf){
        MyDumpMemory(pDumpBuf,
                     pIrpStack -> Parameters.Write.Length,
                     FALSE);
    }
}
#endif // DBG



    Status = USTransfer(pDeviceObject,
                        pIrp,
                        pde -> IndexBulkOut,
                        NULL,
                        pIrp -> MdlAddress,
                        pIrpStack -> Parameters.Write.Length,
                        pTimeout);

    //
    // IRP should be completed in USTransfer or its completion routine.
    //
    
USWrite_return:
    USDecrementIoCount(pDeviceObject);
    DebugTrace(TRACE_PROC_LEAVE,("USWrite: Leaving.. Status = %x.\n", Status));
    return Status;
}


NTSTATUS
USTransfer(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp,
    IN ULONG            Index,
    IN PVOID            pBuffer,        //  Either pBuffer or pMdl
    IN PMDL             pMdl,           //  must be passed in.
    IN ULONG            TransferSize,
    IN PULONG           pTimeout
)
/*++

Routine Description:

Arguments:
    pDeviceObject   - Device object for a device.
    pOrigianlIrp    - Original IRP to Read/Write.

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PIO_STACK_LOCATION          pNextIrpStack;
    PTRANSFER_CONTEXT           pTransferContext;
    PURB                        pUrb;
    PUSBSCAN_PACKETS            pPackets;
    ULONG                       siz = 0;
    ULONG                       MaxPacketSize;
    ULONG                       MaxTransferSize;
    ULONG                       PipeIndex;
    BOOLEAN                     fNextReadBlocked;
    BOOLEAN                     fBulkIn;
    BOOLEAN                     fNeedCompletion;
    
    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USTransfer: Enter..\n"));

    //
    // Initialize status etc..
    //
    
    Status = STATUS_SUCCESS;
    fNeedCompletion = TRUE;

    pde                 = NULL;
    pNextIrpStack       = NULL;
    pTransferContext    = NULL;
    pUrb                = NULL;
    pPackets            = NULL;;

    //
    // Check the arguments.
    //

    if( (NULL == pIrp)
     || (   (NULL == pBuffer)
         && (NULL == pMdl)  
         && (0 != TransferSize) )
     || (Index > MAX_NUM_PIPES) )
    {
        DebugTrace(TRACE_ERROR,("USTransfer: ERROR!! Invalid argment.\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto USTransfer_return;
    }

    //
    // Initialize status etc..
    //
    
    pIrp -> IoStatus.Information = 0;
    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    pNextIrpStack = IoGetNextIrpStackLocation(pIrp);

    //
    // Pickup PipeIndex to use
    //

    PipeIndex = USGetPipeIndexToUse(pDeviceObject,
                                    pIrp,
                                    Index);

    DebugTrace(TRACE_STATUS,("USTransfer: Transfer [pipe %d] called. size = %d, pBuffer = 0x%p, Mdl = 0x%p \n",
                               PipeIndex,
                               TransferSize,
                               pBuffer,
                               pMdl
                    ));

    MaxTransferSize = pde -> PipeInfo[PipeIndex].MaximumTransferSize;
    MaxPacketSize   = pde -> PipeInfo[PipeIndex].MaximumPacketSize;

    fBulkIn = ((pde->PipeInfo[PipeIndex].PipeType == UsbdPipeTypeBulk)
                && (pde->PipeInfo[PipeIndex].EndpointAddress & BULKIN_FLAG));

#if DBG
    if (TransferSize > MaxTransferSize) {
        DebugTrace(TRACE_STATUS,("USTransfer: Transfer > max transfer size.\n"));
    }
#endif

    ASSERT(PipeIndex <= MAX_NUM_PIPES);

    fNextReadBlocked = FALSE;

    if (fBulkIn) {

        //
        // Get exclusive access to each read buffer by using event
        //

        DebugTrace(TRACE_STATUS,("USTransfer: Waiting for Sync event for Pipe %d...\n", PipeIndex));

        if(NULL != pTimeout){
            LARGE_INTEGER  Timeout;
            
            Timeout = RtlConvertLongToLargeInteger(-10*1000*1000*(*pTimeout));
            Status = KeWaitForSingleObject(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, Executive, KernelMode, FALSE, &Timeout);
        } else {
            Status = KeWaitForSingleObject(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, Executive, KernelMode, FALSE, 0);
        }
        
        if(STATUS_SUCCESS != Status){
            KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
            DebugTrace(TRACE_ERROR,("USTransfer: ERROR!! KeWaitForSingleObject() failed. Status=0x%x.\n", Status));
            goto USTransfer_return;
        }

        DebugTrace(TRACE_STATUS,("USTransfer: Get access to Pipe %d !!\n", PipeIndex));

        fNextReadBlocked = TRUE;

        //
        // If there is remaining data in the read pipe buffer, copy it into the irp transfer buffer.
        // Update the irp transfer pointer, number of bytes left to transfer, the read pipe buffer pointer
        // and the remaining number of bytes left in the read pipe buffer.
        //

        if (pde -> ReadPipeBuffer[PipeIndex].RemainingData > 0) {
            DebugTrace(TRACE_STATUS,("USTransfer: Copying %d buffered bytes into irp\n",
                                        pde -> ReadPipeBuffer[PipeIndex].RemainingData));
            siz = min(pde -> ReadPipeBuffer[PipeIndex].RemainingData, TransferSize);
            if (NULL == pBuffer) {

                //
                // There's no buffer. Try to use Mdl instead.
                //

                if(NULL == pMdl){

                    //
                    // Error: Both Buffer and Mdl are NULL.
                    //

                    Status = STATUS_INVALID_PARAMETER;
                    KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
                    DebugTrace(TRACE_ERROR,("USTransfer: ERROR!! Both Buffer&Mdl=NULL.\n"));
                    goto USTransfer_return;

                } else {
                    pMdl->MdlFlags |= MDL_MAPPING_CAN_FAIL;
                    pBuffer = MmGetSystemAddressForMdl(pMdl);
                    if(NULL == pBuffer){
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
                        DebugTrace(TRACE_ERROR,("USTransfer: ERROR!! MmGetSystemAddressForMdl failed.\n"));
                        goto USTransfer_return;
                    }
                    
                    pMdl = NULL;
                }
            }
            ASSERT(siz > 0);
            ASSERT(pBuffer);
            ASSERT(pde -> ReadPipeBuffer[PipeIndex].pBuffer);
            RtlCopyMemory(pBuffer,pde -> ReadPipeBuffer[PipeIndex].pBuffer, siz);
            pde -> ReadPipeBuffer[PipeIndex].pBuffer += siz;
            pde -> ReadPipeBuffer[PipeIndex].RemainingData -= siz;
            ASSERT((LONG)pde -> ReadPipeBuffer[PipeIndex].RemainingData >= 0);
            if (0 == pde -> ReadPipeBuffer[PipeIndex].RemainingData) {
                DebugTrace(TRACE_STATUS,("USTransfer: read buffer emptied.\n"));
                pde -> ReadPipeBuffer[PipeIndex].pBuffer = pde -> ReadPipeBuffer[PipeIndex].pStartBuffer;
            }
            (PUCHAR)(pBuffer) += siz;
            TransferSize -= siz;
            ASSERT((LONG)TransferSize >= 0);

            // If the read irp was completely satisfied from data in the read buffer, then
            // unblock the next pending read and return success.

            if (0 == TransferSize) {
                pIrp -> IoStatus.Information = siz;
                Status = STATUS_SUCCESS;
                KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
                DebugTrace(TRACE_STATUS,("USTransfer: Irp satisfied from ReadBuffer.\n"));
                goto USTransfer_return;
            }
        } // if (pde -> ReadPipeBuffer[PipeIndex].RemainingData > 0)

        //
        // If this read is an integer number of usb packets, it will not affect
        // the state of the read buffer.  Unblock the next waiting read in this case.
        //

        if (0 == TransferSize % MaxPacketSize) {
            DebugTrace(MAX_TRACE,("USTransfer: Unblocking next read.\n"));
            KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
            fNextReadBlocked = FALSE;
        }
    } // if (fBulkIn) 

    //
    // Allocate and initialize Transfer Context
    //

    pTransferContext = USAllocatePool(NonPagedPool, sizeof(TRANSFER_CONTEXT));
    if (NULL == pTransferContext) {
        DebugTrace(TRACE_CRITICAL,("USTransfer: ERROR!! cannot allocated Transfer Context\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        if (fNextReadBlocked) {
            KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
        }
        goto USTransfer_return;
    }
    RtlZeroMemory(pTransferContext, sizeof(TRANSFER_CONTEXT));

    //
    // Allocate and initialize URB
    //

    pUrb = USAllocatePool(NonPagedPool, sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER));
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USTransfer: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        if (fNextReadBlocked) {
            KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
        }
        goto USTransfer_return;
    }
    RtlZeroMemory(pUrb, sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER));

    ASSERT(pUrb);
    ASSERT(pTransferContext);

    pTransferContext -> fDestinedForReadBuffer  = FALSE;
    pTransferContext -> fNextReadBlocked        = fNextReadBlocked;
    pTransferContext -> RemainingTransferLength = TransferSize;
    pTransferContext -> ChunkSize               = TransferSize;
    pTransferContext -> PipeIndex               = PipeIndex;
    pTransferContext -> pTransferBuffer         = pBuffer;
    pTransferContext -> pTransferMdl            = pMdl;
    pTransferContext -> NBytesTransferred       = siz;
    pTransferContext -> pUrb                    = pUrb;
    pTransferContext -> pThisIrp                = pIrp;
    pTransferContext -> pDeviceObject           = pDeviceObject;

    //
    // IF the transfer is > MaxTransferSize, OR
    // IF the transfer is not a multiple of a USB packet AND it is a read transfer THEN
    //   Check if we have been passed an MDL.  If so, we need to turn it into a pointer so
    //     that we can advance it when the transfer is broken up into smaller transfers.
    //

    if( (pTransferContext -> ChunkSize > MaxTransferSize) 
     || ( (0 != pTransferContext -> ChunkSize % MaxPacketSize) 
       && (fBulkIn) ) )
    {
        if (NULL == pTransferContext -> pTransferBuffer) {
            DebugTrace(TRACE_STATUS,("USTransfer: Converting MDL to buffer pointer.\n"));
            ASSERT(pTransferContext -> pTransferMdl);
            pTransferContext -> pTransferMdl ->MdlFlags |= MDL_MAPPING_CAN_FAIL;

            pTransferContext -> pTransferBuffer = MmGetSystemAddressForMdl(pTransferContext -> pTransferMdl);
            pTransferContext -> pTransferMdl = NULL;
            ASSERT(pTransferContext -> pTransferBuffer);
            if(NULL == pTransferContext -> pTransferBuffer){
                Status = STATUS_INSUFFICIENT_RESOURCES;
                if (fNextReadBlocked) {
                    KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
                }
                goto USTransfer_return;
            }
        }
    }

    //
    // If chunksize is bigger than MaxTransferSize, then set it to MaxTransferSize.  The
    // transfer completion routine will issue additional transfers until the total size has
    // been transferred.
    //

    if (pTransferContext -> ChunkSize > MaxTransferSize) {
        pTransferContext -> ChunkSize = MaxTransferSize;
    }

    if (fBulkIn) {

        //
        // If this read is smaller than a USB packet, then issue a request for a
        // whole usb packet and make sure it goes into the read buffer first.
        //

        if (pTransferContext -> ChunkSize < MaxPacketSize) {
            DebugTrace(TRACE_STATUS,("USTransfer: Request is < packet size - transferring whole packet into read buffer.\n"));
            pTransferContext -> fDestinedForReadBuffer = TRUE;
            pTransferContext -> pOriginalTransferBuffer = pTransferContext -> pTransferBuffer;  // save off original transfer ptr.
            pTransferContext -> pTransferBuffer = pde -> ReadPipeBuffer[PipeIndex].pBuffer;
            pTransferContext -> ChunkSize = MaxPacketSize;
        }

        //
        // Truncate the size of the read to an integer number of packets.  If necessary,
        // the completion routine will handle any fractional remaining packets (with the read buffer).
        //

        pTransferContext -> ChunkSize = (pTransferContext -> ChunkSize / MaxPacketSize) * MaxPacketSize;
    }

//    ASSERT(pTransferContext -> RemainingTransferLength);
//    ASSERT((pTransferContext -> pTransferBuffer) || (pTransferContext -> pTransferMdl));
    ASSERT(pTransferContext -> pUrb);

    //
    // Initialize URB
    //

    UsbBuildInterruptOrBulkTransferRequest(pUrb,
                                           sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
                                           pde ->PipeInfo[PipeIndex].PipeHandle,
                                           pTransferContext -> pTransferBuffer,
                                           pTransferContext -> pTransferMdl,
                                           pTransferContext -> ChunkSize,
                                           USBD_SHORT_TRANSFER_OK,
                                           NULL);

    //
    // Setup stack location for lower driver
    //

    pNextIrpStack -> MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    pNextIrpStack -> MinorFunction = 0;
    pNextIrpStack -> Parameters.DeviceIoControl.IoControlCode = (ULONG)IOCTL_INTERNAL_USB_SUBMIT_URB;
    pNextIrpStack -> Parameters.Others.Argument1 = pUrb;

    if(NULL != pTimeout){
        pTransferContext -> Timeout = RtlConvertLongToLargeInteger(-10*1000*1000*(*pTimeout));

        //
        // Initialize timer and DPC.
        //

        KeInitializeTimer(&(pTransferContext->Timer));
        KeInitializeDpc(&(pTransferContext->TimerDpc),
                        (PKDEFERRED_ROUTINE)USTimerDpc,
                        (PVOID)pIrp);
        //
        // Enqueue timer object for timeout.
        //
        
        DebugTrace(TRACE_STATUS,("USTransfer: Set timeout(0x%x x 100n sec).\n", -(pTransferContext -> Timeout.QuadPart)));
        if(KeSetTimer(&(pTransferContext->Timer),
                      pTransferContext -> Timeout,
                      &(pTransferContext->TimerDpc)))
        {
            DebugTrace(TRACE_ERROR,("USTransfer: Timer object already exist.\n"));
        }
        
    } else {
        DebugTrace(TRACE_STATUS,("USTransfer: No timeout for this IRP.\n"));
    }

    //
    // Increment processing I/O count, will be decremented in completion.
    //

    USIncrementIoCount( pDeviceObject );

    //
    // Mark pending to IRP.
    //
    
    IoMarkIrpPending(pIrp);

    //
    // Set Completion Routine.
    //
    
    IoSetCompletionRoutine(pIrp,
                           USTransferComplete,
                           pTransferContext,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // Call down.
    //

    fNeedCompletion = FALSE;
    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);
    if(STATUS_PENDING != Status){
        DebugTrace(TRACE_ERROR,("USTransfer: ERROR!! Lower driver returned 0x%x.\n", Status));
    }

    //
    // Must return STATUS_PENDING.
    //

    Status = STATUS_PENDING;

USTransfer_return:

    if(fNeedCompletion){
        DebugTrace(TRACE_STATUS,("USTransfer: Completeing IRP now.\n"));
        
        //
        // Error or data satisfied from buffer.
        //
        
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        if(NULL != pUrb){
            USFreePool(pUrb);
        }
        if(NULL != pTransferContext){
            USFreePool(pTransferContext);
        }
    }
    
    DebugTrace(TRACE_PROC_LEAVE,("USTransfer: Leaving.. Status = 0x%x.\n", Status));
    return Status;
}

NTSTATUS
USTransferComplete(
    IN PDEVICE_OBJECT       pPassedDeviceObject,
    IN PIRP                 pIrp,
    IN PTRANSFER_CONTEXT    pTransferContext
)
/*++

Routine Description:

Arguments:
    pPassedDeviceObject - Device object for a device.
    pIrp                - Read/write request packet
    pTransferContext    - context info for transfer

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                    Status;
    PIO_STACK_LOCATION          pIrpStack;
    PIO_STACK_LOCATION          pNextIrpStack;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PDEVICE_OBJECT              pDeviceObject;
    PURB                        pUrb;
    ULONG                       CompletedTransferLength;
    NTSTATUS                    CompletedTransferStatus;
    ULONG                       MaxPacketSize;
    BOOLEAN                     fShortTransfer = FALSE;
    BOOLEAN                     fBulkIn;
    ULONG                       PipeIndex;

    DebugTrace(TRACE_PROC_ENTER,("USTransferComplete: Enter.. - called. irp = 0x%p\n",pIrp));

    ASSERT(pIrp);
    ASSERT(pTransferContext);

    Status = pIrp -> IoStatus.Status;
    pIrp -> IoStatus.Information = 0;

    if(NULL == pPassedDeviceObject){
        pDeviceObject = pTransferContext->pDeviceObject;
    } else {
        pDeviceObject = pPassedDeviceObject;
    }

    pIrpStack     = IoGetCurrentIrpStackLocation(pIrp);
    pNextIrpStack = IoGetNextIrpStackLocation(pIrp);

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    PipeIndex = pTransferContext -> PipeIndex;
    MaxPacketSize =  pde -> PipeInfo[PipeIndex].MaximumPacketSize;

    fBulkIn = ((pde->PipeInfo[PipeIndex].PipeType == UsbdPipeTypeBulk)
            && (pde->PipeInfo[PipeIndex].EndpointAddress & BULKIN_FLAG));

    pUrb = pTransferContext -> pUrb;
    CompletedTransferLength = pUrb -> UrbBulkOrInterruptTransfer.TransferBufferLength;
    CompletedTransferStatus = pUrb -> UrbBulkOrInterruptTransfer.Hdr.Status;

    if( (STATUS_SUCCESS == CompletedTransferStatus) 
     && (STATUS_SUCCESS == Status) )
    {

        if (CompletedTransferLength < pTransferContext -> ChunkSize) {
            DebugTrace(TRACE_STATUS,("USTransferComplete: Short transfer received. Length = %d, ChunkSize = %d\n",
                                       CompletedTransferLength, pTransferContext -> ChunkSize));
            fShortTransfer = TRUE;
        }

        //
        // If this transfer went into the read buffer, then this should be the final read
        // of either a multipart larger read, or a single very small read (< single usb packet).
        // In either case, we need to copy the appropriate amount of data into the user's irp, update the
        // read buffer variables, and complete the user's irp.
        //

        if (pTransferContext -> fDestinedForReadBuffer) {
            DebugTrace(TRACE_STATUS,("USTransferComplete: Read transfer completed. size = %d\n", CompletedTransferLength));
            ASSERT(CompletedTransferLength <= MaxPacketSize);
            ASSERT(pTransferContext -> pOriginalTransferBuffer);
            ASSERT(pTransferContext -> pTransferBuffer);
            ASSERT(pde -> ReadPipeBuffer[PipeIndex].pBuffer == pTransferContext -> pTransferBuffer);
            ASSERT(pTransferContext -> RemainingTransferLength < MaxPacketSize);

            pde -> ReadPipeBuffer[PipeIndex].RemainingData = CompletedTransferLength;
            CompletedTransferLength = min(pTransferContext -> RemainingTransferLength,
                                 pde -> ReadPipeBuffer[PipeIndex].RemainingData);
            ASSERT(CompletedTransferLength < MaxPacketSize);
            RtlCopyMemory(pTransferContext -> pOriginalTransferBuffer,
                          pde -> ReadPipeBuffer[PipeIndex].pBuffer,
                          CompletedTransferLength);
            pde -> ReadPipeBuffer[PipeIndex].pBuffer += CompletedTransferLength;
            pde -> ReadPipeBuffer[PipeIndex].RemainingData -= CompletedTransferLength;

            if (0 == pde -> ReadPipeBuffer[PipeIndex].RemainingData) {
                DebugTrace(TRACE_STATUS,("USTransferComplete: Read buffer emptied.\n"));
                pde -> ReadPipeBuffer[PipeIndex].pBuffer = pde -> ReadPipeBuffer[PipeIndex].pStartBuffer;
            }
            pTransferContext -> pTransferBuffer = pTransferContext -> pOriginalTransferBuffer;
        }

        //
        // Update the number of bytes transferred, remaining bytes to transfer
        // and advance the transfer buffer pointer appropriately.
        //

        pTransferContext -> NBytesTransferred += CompletedTransferLength;
        if (pTransferContext -> pTransferBuffer) {
            pTransferContext -> pTransferBuffer += CompletedTransferLength;
        }
        pTransferContext -> RemainingTransferLength -= CompletedTransferLength;

        //
        // If there is still data to transfer and the previous transfer was NOT a
        // short transfer, then issue another request to move the next chunk of data.
        //

        if (pTransferContext -> RemainingTransferLength > 0) {
            if (!fShortTransfer) {

                DebugTrace(TRACE_STATUS,("USTransferComplete: Queuing next chunk. RemainingSize = %d, pBuffer = 0x%p\n",
                                           pTransferContext -> RemainingTransferLength,
                                           pTransferContext -> pTransferBuffer
                                          ));

                if (pTransferContext -> RemainingTransferLength < pTransferContext -> ChunkSize) {
                    pTransferContext -> ChunkSize = pTransferContext -> RemainingTransferLength;
                }

                //
                // Reinitialize URB
                //
                // If the next transfer is < than 1 packet, change it's destination to be
                // the read buffer.  When this transfer completes, the appropriate amount of data will be
                // copied out of the read buffer and into the user's irp.  Left over data in the read buffer
                // will be available for subsequent reads.
                //

                if (fBulkIn) {
                    if (pTransferContext -> ChunkSize < MaxPacketSize) {
                        pTransferContext -> fDestinedForReadBuffer = TRUE;
                        pTransferContext -> pOriginalTransferBuffer = pTransferContext -> pTransferBuffer;
                        pTransferContext -> pTransferBuffer = pde -> ReadPipeBuffer[PipeIndex].pBuffer;
                        pTransferContext -> ChunkSize = MaxPacketSize;
                    }
                    pTransferContext -> ChunkSize = (pTransferContext -> ChunkSize / MaxPacketSize) * MaxPacketSize;
                }

                ASSERT(pTransferContext -> ChunkSize >= MaxPacketSize);
                ASSERT(0 == pTransferContext -> ChunkSize % MaxPacketSize);
                UsbBuildInterruptOrBulkTransferRequest(pUrb,
                    sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
                    pde -> PipeInfo[PipeIndex].PipeHandle,
                    pTransferContext -> pTransferBuffer,
                    NULL,
                    pTransferContext -> ChunkSize,
                    USBD_SHORT_TRANSFER_OK,
                    NULL);
                IoSetCompletionRoutine(pIrp,
                                       USTransferComplete,
                                       pTransferContext,
                                       TRUE,
                                       TRUE,
                                       FALSE);

                //
                // Setup stack location for lower driver
                //

                pNextIrpStack -> MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                pNextIrpStack -> MinorFunction = 0;
                pNextIrpStack -> Parameters.DeviceIoControl.IoControlCode = (ULONG)IOCTL_INTERNAL_USB_SUBMIT_URB;
                pNextIrpStack -> Parameters.Others.Argument1 = pUrb;

                IoCallDriver(pde -> pStackDeviceObject, pIrp);
                Status = STATUS_MORE_PROCESSING_REQUIRED;
                goto USTransferComplete_return;

            } // if (!fShortTransfer) 
        } // if (pTransferContext -> RemainingTransferLength > 0)

        DebugTrace(TRACE_STATUS,("USTransferComplete: Completing transfer request. nbytes transferred = %d, irp = 0x%p\n",
                                   pTransferContext -> NBytesTransferred, pIrp));

        pIrp -> IoStatus.Information = pTransferContext -> NBytesTransferred;

#if DBG
        {
            PUCHAR  pDumpBuf = NULL;

            if(NULL != pTransferContext -> pTransferBuffer){
                pDumpBuf = pTransferContext -> pTransferBuffer;
            } else if (NULL != pTransferContext -> pTransferMdl) {
                pTransferContext -> pTransferMdl ->MdlFlags |= MDL_MAPPING_CAN_FAIL;
                pDumpBuf = MmGetSystemAddressForMdl(pTransferContext -> pTransferMdl);
            }

            if(NULL != pDumpBuf){
                MyDumpMemory(pDumpBuf,
                             pTransferContext -> NBytesTransferred,
                             TRUE);
            }
        }
#endif // DBG

    } else {

        DebugTrace(TRACE_ERROR,("USTransferComplete: ERROR!! Transfer error. USB status = 0x%X, status = 0x%X\n",
                                    CompletedTransferStatus, 
                                    Status));
        if (USBD_STATUS_CANCELED == CompletedTransferStatus) {
            Status = STATUS_CANCELLED;
        }
    }

    //
    // Running here means IRP is completed.
    //

    pIrp -> IoStatus.Status = Status;

    if (pTransferContext -> fNextReadBlocked) {
        KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
    }

    //
    // Dequeue timer object if exist.
    //

    if( (0 != pTransferContext -> Timeout.QuadPart)
     && (!KeReadStateTimer(&(pTransferContext->Timer))) )
    {
        KeCancelTimer(&(pTransferContext->Timer));
    }

    //
    // Clean-up
    //

    if(pTransferContext->pUrb){
        USFreePool(pTransferContext->pUrb);
    }
    USDecrementIoCount(pTransferContext->pDeviceObject);
    USFreePool(pTransferContext);

USTransferComplete_return:
    DebugTrace(TRACE_PROC_LEAVE,("USTransferComplete: Leaving.. Status=%x.\n", Status));
    return Status;
}


ULONG
USGetPipeIndexToUse(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp,
    IN ULONG                PipeIndex
)
/*++

Routine Description:

Arguments:
    pDeviceObject    - Device object for a device.
    pIrp             - request packet
    PipeIndex        - Default pipe to use

Return Value:
    ULONG - PipeIndex to use

--*/
{
    PIO_STACK_LOCATION          pIrpStack;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PFILE_OBJECT                fileObject;
    PUSBSCAN_FILE_CONTEXT       pFileContext;
    LONG                        StoredIndex;
    ULONG                       IndexToUse;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USGetPipeIndexToUse: Enter..\n"));

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    pIrpStack       = IoGetCurrentIrpStackLocation (pIrp);
    fileObject      = pIrpStack->FileObject;
    pFileContext    = fileObject->FsContext;

    ASSERT(NULL != pFileContext);

    StoredIndex     = pFileContext->PipeIndex;

    if( (StoredIndex >= 0) && (StoredIndex < MAX_NUM_PIPES) ){
        if(pde->PipeInfo[PipeIndex].PipeType == pde->PipeInfo[StoredIndex].PipeType){
            IndexToUse = (ULONG)StoredIndex;
        } else {
            IndexToUse = PipeIndex;
        }
    } else {
        if(-1 != StoredIndex){
            DebugTrace(TRACE_WARNING,("USGetPipeIndexToUse: WARINING!! Specified pipe index(0x%X) is incorrect. Using default." ,StoredIndex));
        }
        IndexToUse = PipeIndex;
    }
    DebugTrace(TRACE_PROC_LEAVE,("USGetPipeIndexToUse: Leaving.. passed=%d, returning=%d.\n",PipeIndex, IndexToUse));
    return IndexToUse;
}

VOID
USTimerDpc(
    IN PKDPC    pDpc,
    IN PVOID    pIrp,
    IN PVOID    SystemArgument1,
    IN PVOID    SystemArgument2
    )
/*++

Routine Description:

DPC callback routine for timer.

Arguments:
    pDpc            -   Pointer to DPC object.
    pIrp            -   Passed context.
    SystemArgument1 -   system reserved.
    SystemArgument2 -   system reserved.

Return Value:
    VOID

--*/
{
    DebugTrace(TRACE_WARNING,("USTimerDpc: IRP(0x%x) timeout.\n", pIrp));
    IoCancelIrp((PIRP)pIrp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\usbscn9x\power.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2001

Module Name:

    power.c

Abstract:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include <stdio.h>
#include "stddef.h"
#include "wdm.h"
#include "usbscan.h"
#include "usbd_api.h"
#include "private.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USPower)
#endif


NTSTATUS
USPower(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    )
/*++

Routine Description:
    Process the Power IRPs sent to the PDO for this device.

Arguments:
    pDeviceObject - pointer to the functional device object (FDO) for this device.
    pIrp          - pointer to an I/O Request Packet

Return Value:
    NT status code

--*/
{
    NTSTATUS                        Status;
    PUSBSCAN_DEVICE_EXTENSION       pde;
    PIO_STACK_LOCATION              pIrpStack;
    BOOLEAN                         hookIt = FALSE;
    POWER_STATE                     powerState;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USPower: Enter... \n"));

    USIncrementIoCount(pDeviceObject);

    pde       = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    Status    = STATUS_SUCCESS;

    switch (pIrpStack -> MinorFunction) {
        case IRP_MN_SET_POWER:
        {
            DebugTrace(TRACE_STATUS,("USPower: IRP_MN_SET_POWER\n"));

            switch (pIrpStack -> Parameters.Power.Type) {
                case SystemPowerState:
                {
                    DebugTrace(TRACE_STATUS,("USPower: SystemPowerState (0x%x)\n",pIrpStack->Parameters.Power.State.SystemState));
                    
                    //
                    // Let lower layer know S IRP, we'll catch on the way up.
                    //

                    IoMarkIrpPending(pIrp);
                    IoCopyCurrentIrpStackLocationToNext(pIrp);
                    IoSetCompletionRoutine(pIrp,
                                           USSystemPowerIrpComplete,
                                           // always pass FDO to completion routine
                                           pDeviceObject,
                                           TRUE,
                                           TRUE,
                                           TRUE);

                    PoCallDriver(pde ->pStackDeviceObject, pIrp);
                    Status = STATUS_PENDING;
                    goto USPower_return;
                } // case SystemPowerState:

                case DevicePowerState:
                {
                    DebugTrace(TRACE_STATUS,("USPower: DevicePowerState\n"));

                    Status = USSetDevicePowerState(pDeviceObject,
                                                   pIrpStack -> Parameters.Power.State.DeviceState,
                                                   &hookIt);


                    if (hookIt) {
                        DebugTrace(TRACE_STATUS,("USPower: Set PowerIrp Completion Routine\n"));
                        IoCopyCurrentIrpStackLocationToNext(pIrp);
                        IoSetCompletionRoutine(pIrp,
                                               USDevicePowerIrpComplete,
                                               // always pass FDO to completion routine
                                               pDeviceObject,
                                               hookIt,
                                               hookIt,
                                               hookIt);
                    } else {
                        PoStartNextPowerIrp(pIrp);
                        IoSkipCurrentIrpStackLocation(pIrp);
                    }

                    Status = PoCallDriver(pde ->pStackDeviceObject, pIrp);
                    if (!hookIt) {
                        USDecrementIoCount(pDeviceObject);
                    }

                    goto USPower_return;

                } // case DevicePowerState:
            } /* case irpStack->Parameters.Power.Type */

            break; /* IRP_MN_SET_POWER */

        } // case IRP_MN_SET_POWER:
        
        case IRP_MN_QUERY_POWER:
        {
            DebugTrace(TRACE_STATUS,("USPower: IRP_MN_QUERY_POWER\n"));
            
            if(PowerDeviceD3 == pde -> DeviceCapabilities.DeviceState[pIrpStack->Parameters.Power.State.SystemState]){
                
                //
                // We're going down to D3 state, which we can't wake from. Cancel WaitWakeIRP.
                //

                USDisarmWake(pde);
            } // if(PowerDeviceD3 == pde -> DeviceCapabilities.DeviceState[irpStack->Parameters.Power.State.SystemState])
            
            PoStartNextPowerIrp(pIrp);
            IoSkipCurrentIrpStackLocation(pIrp);
            Status = PoCallDriver(pde -> pStackDeviceObject, pIrp);
            USDecrementIoCount(pDeviceObject);

            break; /* IRP_MN_QUERY_POWER */

        } // case IRP_MN_QUERY_POWER:
        case IRP_MN_WAIT_WAKE:
        {

            LONG    oldWakeState;

            DebugTrace(TRACE_STATUS,("USPower: IRP_MN_WAIT_WAKE\n"));

            pde->pWakeIrp = pIrp;

             //
             // Now we're armed.
             //
             
            oldWakeState = InterlockedCompareExchange(&pde->WakeState,
                                                      WAKESTATE_ARMED,
                                                      WAKESTATE_WAITING);

            if(WAKESTATE_WAITING_CANCELLED == oldWakeState){

                //
                // We got disarmed, finish up and complete the IRP
                //

                pde->WakeState = WAKESTATE_COMPLETING;
                pIrp->IoStatus.Status = STATUS_CANCELLED;
                IoCompleteRequest(pIrp, IO_NO_INCREMENT );
                Status = STATUS_CANCELLED;
                USDecrementIoCount(pDeviceObject);
                break;
            } // if(WAKESTATE_WAITING_CANCELLED == oldWakeState)

            // We went from WAITING to ARMED. Set a completion routine and forward
            // the IRP. Note that our completion routine might complete the IRP
            // asynchronously, so we mark the IRP pending

            IoMarkIrpPending(pIrp);
            IoCopyCurrentIrpStackLocationToNext(pIrp);
            IoSetCompletionRoutine(pIrp,
                                   USWaitWakeIoCompletionRoutine,
                                   NULL,
                                   TRUE,
                                   TRUE,
                                   TRUE );

            PoCallDriver(pde->pStackDeviceObject, pIrp);
            Status = STATUS_PENDING;
            USDecrementIoCount(pDeviceObject);
            break;
        } // case IRP_MN_WAIT_WAKE:

        default:
            DebugTrace(TRACE_STATUS,("USPower: Unknown power message (%x)\n",pIrpStack->MinorFunction));
            PoStartNextPowerIrp(pIrp);
            IoSkipCurrentIrpStackLocation(pIrp);
            Status = PoCallDriver(pde -> pStackDeviceObject, pIrp);
            USDecrementIoCount(pDeviceObject);

    } /* pIrpStack -> MinorFunction */

USPower_return:

    DebugTrace(TRACE_PROC_LEAVE,("USPower: Leaving... Status = 0x%x\n", Status));
    return Status;
} // USPower()


NTSTATUS
USPoRequestCompletion(
    IN PDEVICE_OBJECT       pPdo,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIO_STATUS_BLOCK     pIoStatus
    )
/*++

Routine Description:
    This routine is called when the port driver completes an IRP.

Arguments:

Return Value:
    The function value is the final status from the operation.

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PIRP                        pIrp;

    DebugTrace(TRACE_PROC_ENTER,("USPoRequestCompletion: Enter...\n"));

    //
    // Initialize local.
    //

    pde    = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pIrp   = pde -> pPowerIrp;
    Status = pIoStatus -> Status;

    //
    // Copy status from D IRP to S IRP.
    //

    pIrp->IoStatus.Status = pIoStatus->Status;

    //
    // Complete S IRP.
    //

    PoStartNextPowerIrp(pIrp);
    IoCompleteRequest(pIrp, IO_NO_INCREMENT );
    USDecrementIoCount(pDeviceObject);

    DebugTrace(TRACE_PROC_LEAVE,("USPoRequestCompletion: Leaving... Status = 0x%x\n", Status));
    return Status;

} // USPoRequestCompletion()

NTSTATUS
USDevicePowerIrpComplete(
    IN PDEVICE_OBJECT pPdo,
    IN PIRP           pIrp,
    IN PDEVICE_OBJECT pDeviceObject
    )
/*++

Routine Description:
    This routine is called when the port driver completes SetD0 IRP.

Arguments:

Return Value:
    The function value is the final status from the operation.

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PIO_STACK_LOCATION          pIrpStack;

    DebugTrace(TRACE_PROC_ENTER,("USDevicePowerIrpComplete: Enter...\n"));

    pde    = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    Status = STATUS_SUCCESS;

    if (pIrp -> PendingReturned) {
        IoMarkIrpPending(pIrp);
    } // if (pIrp -> PendingReturned) 

    pIrpStack = IoGetCurrentIrpStackLocation (pIrp);

    ASSERT(pIrpStack -> MajorFunction == IRP_MJ_POWER);
    ASSERT(pIrpStack -> MinorFunction == IRP_MN_SET_POWER);
    ASSERT(pIrpStack -> Parameters.Power.Type == DevicePowerState);
    ASSERT(pIrpStack -> Parameters.Power.State.DeviceState == PowerDeviceD0);

    //
    // This completion is called only for D0 IRP.
    //

    pde->CurrentDevicePowerState    = PowerDeviceD0;
    pde->AcceptingRequests          = TRUE;

    //
    // Now power is on. Rearm for wakeup.
    //

    USQueuePassiveLevelCallback(pde->pOwnDeviceObject, USPassiveLevelReArmCallbackWorker);

    //
    // Ready for next D IRP.
    //

    PoStartNextPowerIrp(pIrp);

    //
    // Leaving...
    //

    USDecrementIoCount(pDeviceObject);
    DebugTrace(TRACE_PROC_LEAVE,("USDevicePowerIrpComplete: Leaving... Status = 0x%x\n", Status));
    return Status;
} // USDevicePowerIrpComplete()


NTSTATUS
USSystemPowerIrpComplete(
    IN PDEVICE_OBJECT pPdo,
    IN PIRP           pIrp,
    IN PDEVICE_OBJECT pDeviceObject
    )
/*++

Routine Description:
    This routine is called when the port driver completes SetD0 IRP.

Arguments:

Return Value:
    The function value is the final status from the operation.

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PIO_STACK_LOCATION          pIrpStack;
    POWER_STATE                 powerState;

    DebugTrace(TRACE_PROC_ENTER,("USSystemPowerIrpComplete: Enter... IRP(0x%p)\n", pIrp));

    //
    // Initialize local.
    //
    

    pde         = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    Status      = pIrp->IoStatus.Status;
    pIrpStack   = IoGetCurrentIrpStackLocation (pIrp);

    ASSERT(pIrpStack -> MajorFunction == IRP_MJ_POWER);
    ASSERT(pIrpStack -> MinorFunction == IRP_MN_SET_POWER);
    ASSERT(pIrpStack -> Parameters.Power.Type == SystemPowerState);

    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_STATUS,("USSystemPowerIrpComplete: IRP failed (0x%x).\n", Status));
        Status = STATUS_SUCCESS;
        USDecrementIoCount(pDeviceObject);

        goto USSystemPowerIrpComplete_return;
    } // if(!NT_SUCCESS(Status))

    //
    // Now Request D IRP based on what we got.
    //

    if(TRUE == pde ->bEnabledForWakeup){
        DebugTrace(TRACE_STATUS,("USSystemPowerIrpComplete: We have remote wakeup support, getting powerState from table.\n"));

        //
        // We support wakeup, we'll just follow device stated set by PDO.
        //

        powerState.DeviceState = pde -> DeviceCapabilities.DeviceState[pIrpStack->Parameters.Power.State.SystemState];
    } else { // if(TRUE == pde ->EnabledForWakeup)

        DebugTrace(TRACE_STATUS,("USSystemPowerIrpComplete: We don't have remote wakeup support.\n"));

        //
        // We don't support remote wake, we're in D0 only when PowerSystemWorking.
        //

        if(PowerSystemWorking == pIrpStack -> Parameters.Power.State.SystemState){
            DebugTrace(TRACE_STATUS,("USSystemPowerIrpComplete: PowerSystemWorking is requested, powering up to D0.\n"));
            powerState.DeviceState = PowerDeviceD0;
        } else {  // if(PowerSystemWorking == pIrpStack -> Parameters.Power.State.SystemState)
            DebugTrace(TRACE_STATUS,("USSystemPowerIrpComplete: Going other than PowerSystemWorking, turning off the device to D3.\n"));
            powerState.DeviceState = PowerDeviceD3;
        }
    } // else(TRUE == pde ->EnabledForWakeup)

    //
    // are we already in this state?
    //

    if(powerState.DeviceState != pde -> CurrentDevicePowerState){

        //
        // No, request that we be put into this state
        //

        DebugTrace(TRACE_STATUS,("USSystemPowerIrpComplete: Requesting DevicePowerState(0x%x).\n", powerState.DeviceState));

        pde -> pPowerIrp = pIrp;
        Status = PoRequestPowerIrp(pde -> pPhysicalDeviceObject,
                                   IRP_MN_SET_POWER,
                                   powerState,
                                   USPoRequestCompletion,
                                   pDeviceObject,
                                   NULL);

        if(NT_SUCCESS(Status)){
            
            //
            // D IRP is successfully requested. S IRP will be completed in D IRP completion routine together.
            //

            Status = STATUS_MORE_PROCESSING_REQUIRED;

        } else { // if(NT_SUCCESS(Status))
            DebugTrace(TRACE_WARNING,("USSystemPowerIrpComplete: WARNING!! DevicePowerState(0x%x) request failed..\n", powerState.DeviceState));
            PoStartNextPowerIrp(pIrp);
            Status = STATUS_SUCCESS;
            USDecrementIoCount(pDeviceObject);
        }

    } else { // if(powerState.DeviceState != pde -> CurrentDevicePowerState)
    
        //
        // We're already in this device state, no need to issue D IRP.
        //

        PoStartNextPowerIrp(pIrp);
        Status = STATUS_SUCCESS;
        USDecrementIoCount(pDeviceObject);

    } // else(powerState.DeviceState != pde -> CurrentDevicePowerState)

USSystemPowerIrpComplete_return:

    DebugTrace(TRACE_PROC_LEAVE,("USSystemPowerIrpComplete: Leaving... Status = 0x%x\n", Status));
    return Status;
} // USSystemPowerIrpComplete()


NTSTATUS
USSetDevicePowerState(
    IN PDEVICE_OBJECT pDeviceObject,
    IN DEVICE_POWER_STATE DeviceState,
    IN PBOOLEAN pHookIt
    )
/*++

Routine Description:

Arguments:
    pDeviceObject - Pointer to the device object for the class device.
    DeviceState - Device specific power state to set the device in to.

Return Value:

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    POWER_STATE                 PowerState;

    DebugTrace(TRACE_PROC_ENTER,("USSetDevicePowerState: Enter...\n"));

    pde    = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    Status = STATUS_SUCCESS;

    switch (DeviceState){
        case PowerDeviceD3:

    //        ASSERT(pde -> AcceptingRequests);
    //        pde -> AcceptingRequests = FALSE;

    //        USCancelPipe(pDeviceObject, ALL_PIPE, TRUE);

    //        pde -> CurrentDevicePowerState = DeviceState;
    //        break;

        case PowerDeviceD1:
        case PowerDeviceD2:
    #if DBG
            if(PowerDeviceD3 == DeviceState){
                DebugTrace(TRACE_STATUS,("USSetDevicePowerState: PowerDeviceD3 (OFF)\n"));
            } else { // if(PowerDeviceD3 == DeviceState)
                DebugTrace(TRACE_STATUS,("USSetDevicePowerState: PowerDeviceD1/D2 (SUSPEND)\n"));
            } // else(PowerDeviceD3 == DeviceState)
    #endif
            USCancelPipe(pDeviceObject, NULL, ALL_PIPE, TRUE);
            //
            // power states D1,D2 translate to USB suspend
            // D3 transltes to OFF

            pde -> CurrentDevicePowerState = DeviceState;
            break;

        case PowerDeviceD0:
            DebugTrace(TRACE_STATUS,("USSetDevicePowerState: PowerDeviceD0 (ON)\n"));

            //
            // finish the rest in the completion routine
            //

            *pHookIt = TRUE;

            // pass on to PDO

            break;

        default:

            DebugTrace(TRACE_WARNING,("USSetDevicePowerState: Bogus DeviceState = %x\n", DeviceState));
    } // switch (DeviceState)

    DebugTrace(TRACE_PROC_LEAVE,("USSetDevicePowerState: Leaving... Status = 0x%x\n", Status));
    return Status;
} // USSetDevicePowerState()

NTSTATUS
USWaitWakeIoCompletionRoutine(
    PDEVICE_OBJECT   pDeviceObject,
    PIRP             pIrp,
    PVOID            pContext
    )
{

    PUSBSCAN_DEVICE_EXTENSION   pde;
    LONG                        oldWakeState;
    NTSTATUS                    Status;

    DebugTrace(TRACE_PROC_ENTER,("USWaitWakeIoCompletionRoutine: Enter...\n"));

    //
    // Initialize local.
    //

    pde             = (PUSBSCAN_DEVICE_EXTENSION) pDeviceObject->DeviceExtension;
    oldWakeState    = 0;
    Status          = STATUS_SUCCESS;

    // Advance the state to completing
    oldWakeState = InterlockedExchange( &pde->WakeState, WAKESTATE_COMPLETING );
    if(WAKESTATE_ARMED == oldWakeState){
        // Normal case, IoCancelIrp isnft being called. Note that we already
        // marked the IRP pending in our dispatch routine
        Status = STATUS_SUCCESS;
        goto USWaitWakeIoCompletionRoutine_return;
    } else { // if(WAKESTATE_ARMED == oldWakeState)
        if(WAKESTATE_ARMING_CANCELLED != oldWakeState){
            DebugTrace(TRACE_ERROR,("USWaitWakeIoCompletionRoutine: ERROR!! wake IRP is completed but oldState(0x%x) isn't ARMED/CALCELLED.", oldWakeState));
        } else { // if(WAKESTATE_ARMING_CANCELLED != oldWakeState)
            DebugTrace(TRACE_STATUS,("USWaitWakeIoCompletionRoutine: WakeIRP is canceled.\n"));
        }
        // IoCancelIrp is being called RIGHT NOW. The disarm code will try
        // to put back the WAKESTATE_ARMED state. It will then see our
        // WAKESTATE_COMPLETED value, and complete the IRP itself!

        Status = STATUS_MORE_PROCESSING_REQUIRED;
        goto USWaitWakeIoCompletionRoutine_return;

    } // else(WAKESTATE_ARMED == oldWakeState)

USWaitWakeIoCompletionRoutine_return:

    DebugTrace(TRACE_PROC_LEAVE,("USWaitWakeIoCompletionRoutine: Leaving... Status = 0x%x\n", Status));
    return Status;
} // USWaitWakeIoCompletionRoutine(
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\debug.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    debug.h

Abstract:

    Prototypes and definitions for debugging.

Author: 

    Keisuke Tsuchida (KeisukeT)

Environment:

    user mode only

Notes:

Revision History:

--*/

#ifndef __MYDEBUG__
#define __MYDEBUG__

//
// Include custom debug header.
//
#include <windows.h>
#include <coredbg.h>
//
// Driver specific definition
//


#define NAME_DRIVER             TEXT("STI_CI.DLL: ")    // Prefix of output message. (Should be driver name)
#define REGVAL_DEBUGLEVEL       TEXT("STICIDebugLevel") // Debug trace level for this binary.

//
// Defines
//

#define MAX_TEMPBUF             256


// Bit mask for trace level and flags
#define BITMASK_TRACE_LEVEL     0x0000000f
#define BITMASK_TRACE_FLAG      0x00000ff0
#define BITMASK_DEBUG_FLAG      0x0000f000

// Basic trace level 
#define NO_TRACE                0                   // Shows nothing.
#define MIN_TRACE               1                   // Shows only error or warning.
#define MAX_TRACE               2                   // Shows progress and status.
#define ULTRA_TRACE             3                   // Shows progress and status in retail.
#define NEVER_TRACE             4                   // Never show this unless specific bit is set.

// Trace flag to enable specific message spew. (1=on)
#define TRACE_FLAG_PROC          0x010              // Show message when entering process.(1=on)
#define TRACE_FLAG_RET           0x020              // Show message when leaving process.(1=on)
#define TRACE_FLAG_DUMP          0x040              // Show transaction data dump.
#define TRACE_IGNORE_TAG         0x080              // Disable tag check (1=disabled).
#define TRACE_MESSAGEBOX         0x100              // Show MessageBox instead of debug spew.

// Conbination of trace level and flag.
#define TRACE_PROC_ENTER        ULTRA_TRACE | TRACE_FLAG_PROC     // Entering procedure.
#define TRACE_PROC_LEAVE        ULTRA_TRACE | TRACE_FLAG_RET      // Leaving procedure.
#define TRACE_CRITICAL          MIN_TRACE                         // Critical error. Spew always.
#define TRACE_ERROR             MIN_TRACE                         // Error.
#define TRACE_WARNING           MIN_TRACE                         // Possible wrong behavior.
#define TRACE_DUMP_DATA         NEVER_TRACE | TRACE_FLAG_DUMP     // Dump transaction data.
#define TRACE_DEVICE_DATA       MAX_TRACE                         // Show device data.
#define TRACE_STATUS            MAX_TRACE                         // Show status.

// Debug flag to enable/disable  DEBUG_BREAKPOINT()
#define DEBUG_FLAG_DISABLE      0x1000                          // Disable DEBUG_BREAK. (1=disable)
#define DEBUG_PROC_BREAK        0x2000                          // Stop at the beginning of each procedure.



//
// Prototypes
//


VOID
MyDebugInit(
    VOID
    );

void __cdecl
DbgPrint(
    LPSTR lpstrMessage,
    ...
    );

void __cdecl
DbgPrint(
    LPWSTR lpstrMessage,
    ...
    );

//
// Macro
//

 #define DebugTrace(_t_, _x_) {                                                                 \
            if((TRACE_ERROR & BITMASK_TRACE_LEVEL) == (_t_ & BITMASK_TRACE_LEVEL )){            \
                DBG_ERR(_x_);                                                                   \
            } else if((TRACE_WARNING & BITMASK_TRACE_LEVEL) == (_t_ & BITMASK_TRACE_LEVEL )){   \
                DBG_WRN(_x_);                                                                   \
            } else if((TRACE_STATUS & BITMASK_TRACE_LEVEL) == (_t_ & BITMASK_TRACE_LEVEL )){    \
                DBG_TRC(_x_);                                                                   \
            } else if( (_t_ & TRACE_FLAG_PROC) || (_t_ & TRACE_FLAG_RET )){                     \
                DBG_TRC(_x_);                                                                   \
            }                                                                                   \
        }

#if DBG

 //
 // Macro for BreakPoint
 //

 #define DEBUG_BREAKPOINT() {                                              \
           if (DebugTraceLevel & DEBUG_FLAG_DISABLE) {                     \
               DbgPrint(NAME_DRIVER);                                      \
               DbgPrint("*** Hit DEBUG_BREAKPOINT ***\r\n");                 \
           } else {                                                        \
               DebugBreak();                                               \
           }                                                               \
         }

#else   // DBG

 #define DEBUG_BREAKPOINT() 

#endif  // DBG



//
// Original debug macro.
//

#if ORIGINAL_DEBUG
#if DBG

 //
 // Macro for debug output
 //
 // Note: If trace level is higher than DebugTraceLevel or specific bit is set, 
 //       debug message will be shown.
 //

 #define DebugTrace(_t_, _x_) {                                                                 \
            if ( ((DebugTraceLevel & BITMASK_TRACE_LEVEL) >= (_t_ & BITMASK_TRACE_LEVEL )) ||   \
                 (DebugTraceLevel & BITMASK_TRACE_FLAG & (_t_)) ) {                             \
                DbgPrint(NAME_DRIVER);                                                          \
                DbgPrint _x_ ;                                                                  \
            }                                                                                   \
            if( (DebugTraceLevel & DEBUG_PROC_BREAK & (_t_)) &&                                 \
                (DebugTraceLevel & TRACE_FLAG_PROC) )  {                                        \
                DEBUG_BREAKPOINT();                                                             \
            }                                                                                   \
          }


#else    // DBG
 #define DebugTrace(_t_, _x_)   
#endif   // DBG
#endif  // ORIGINAL_DEBUG

//
// Obsolete
//

#define Report(_x_)  

#endif //  __MYDEBUG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\debug.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    debug.c

Abstract:

    Common code for debugging.

Author:

    Keisuke Tsuchida (KeisukeT)

Environment:

   uesr mode only

Notes:

Revision History:

--*/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Includes
//
#include "stddef.h"
#include "debug.h"
#include <stiregi.h>

//
// Globals
//

ULONG   DebugTraceLevel = MIN_TRACE | DEBUG_FLAG_DISABLE;
//ULONG  DebugTraceLevel = MAX_TRACE | DEBUG_FLAG_DISABLE | TRACE_PROC_ENTER | TRACE_PROC_LEAVE;

TCHAR   acErrorBuffer[MAX_TEMPBUF];


//
// Function
//


VOID
MyDebugInit()
/*++

Routine Description:

    Read DebugTraceLevel key from registry if exists.

Arguments:

    none.

Return Value:

    none.

--*/
{

    HKEY            hkRegistry;
    LONG            Err;
    DWORD           dwType;
    DWORD           dwSize;
    ULONG           ulBuffer;

    DebugTrace(TRACE_PROC_ENTER,("MyDebugInit: Enter... \r\n"));

    //
    // Initialize local variables.
    //

    hkRegistry      = NULL;
    Err             = 0;
    dwSize          = sizeof(ulBuffer);

    //
    // Open registry key.
    //

    Err = RegOpenKey(HKEY_LOCAL_MACHINE,
                     REGSTR_PATH_STICONTROL_W,
                     &hkRegistry);
    if(ERROR_SUCCESS != Err){
        DebugTrace(TRACE_STATUS,("MyDebugInit: Can't open %ws. Err=0x%x.\r\n", REGSTR_PATH_STICONTROL_W, Err));
        goto MyDebugInit_return;
    }

    Err = RegQueryValueEx(hkRegistry,
                          REGVAL_DEBUGLEVEL,
                          NULL,
                          &dwType,
                          (LPBYTE)&ulBuffer,
                          &dwSize);
    if(ERROR_SUCCESS != Err){
        DebugTrace(TRACE_STATUS,("MyDebugInit: Can't get %ws\\%ws value. Err=0x%x.\r\n", REGSTR_PATH_STICONTROL_W, REGVAL_DEBUGLEVEL, Err));
        goto MyDebugInit_return;
    }

    DebugTraceLevel = ulBuffer;
    DebugTrace(TRACE_CRITICAL, ("MyDebugInit: Reg-key found. DebugTraceLevel=0x%x.\r\n", DebugTraceLevel));

MyDebugInit_return:

    //
    // Clean up.
    //

    if(NULL != hkRegistry){
        RegCloseKey(hkRegistry);
    }

    DebugTrace(TRACE_PROC_LEAVE,("MyDebugInit: Leaving... Ret=VOID.\r\n"));
    return;
}

void __cdecl
DbgPrint(
    LPSTR lpstrMessage,
    ...
    )
{

    va_list list;

    va_start(list,lpstrMessage);

    wvsprintfA((LPSTR)acErrorBuffer, lpstrMessage, list);

    if(DebugTraceLevel & TRACE_MESSAGEBOX){
        MessageBoxA(NULL, (LPSTR)acErrorBuffer, "", MB_OK);
    }
#if DBG
    OutputDebugStringA((LPCSTR)acErrorBuffer);
#endif // DBG

    va_end(list);
}

void __cdecl
DbgPrint(
    LPWSTR lpstrMessage,
    ...
    )
{

    va_list list;

    va_start(list,lpstrMessage);

    wvsprintfW(acErrorBuffer, lpstrMessage, list);

    if(DebugTraceLevel & TRACE_MESSAGEBOX){
        MessageBoxW(NULL, acErrorBuffer, L"", MB_OK);
    }
#if DBG
    OutputDebugStringW(acErrorBuffer);
#endif // DBG

    va_end(list);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\usbscn9x\private.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    private.h

Abstract:

    Prototypes and definitions for the usb scanner device driver.

Author:

Environment:

    kernel mode only

Notes:

Revision History:
--*/

//
// Includes
//

#include "debug.h"

//
// Defines
//

#ifndef max
 #define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
 #define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#define TAG_USBSCAN             0x55495453                  // "STIU"
#define TAG_USBD                0x44425355                  // "USBD"

#define USBSCAN_OBJECTNAME_A    "\\\\.\\Usbscan"
#define USBSCAN_OBJECTNAME_W    L"\\\\.\\Usbscan"
#define USBSCAN_REG_CREATEFILE  L"CreateFileName"

#define USBSCAN_TIMEOUT_READ    120                         // 120 sec
#define USBSCAN_TIMEOUT_WRITE   120                         // 120 sec
#define USBSCAN_TIMEOUT_EVENT   0                           // no timeout
#define USBSCAN_TIMEOUT_OTHER   120                         // 120 sec

#define USBSCAN_REG_TIMEOUT_READ    L"TimeoutRead"
#define USBSCAN_REG_TIMEOUT_WRITE   L"TimeoutWrite"
#define USBSCAN_REG_TIMEOUT_EVENT   L"TimeoutEvent"

//
// Private IOCTL to workaround #446466 (Whistler)
//

#define IOCTL_SEND_USB_REQUEST_PTP  CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+20,METHOD_BUFFERED,FILE_ANY_ACCESS)

//
// Wake state
//

typedef enum {
    // No outstanding Wait-Wake IRP
    WAKESTATE_DISARMED          = 1,
    // Wait-Wake IRP requested, not yet seen
    WAKESTATE_WAITING           = 2,
    // Wait-Wake cancelled before IRP seen again
    WAKESTATE_WAITING_CANCELLED = 3,
    // Wait-Wake IRP seen and forwarded. Device is *probably* armed
    WAKESTATE_ARMED             = 4,
    // Wait-Wake IRP seen and cancelled. Hasn't reached completion yet
    WAKESTATE_ARMING_CANCELLED  = 5,
    // Wait-Wake IRP has passed the completion routine
    WAKESTATE_COMPLETING        = 7
} WAKESTATE;


//
// Pipe buffer structure for the read pipe only.
//

typedef struct _PIPEBUFFER {
    PUCHAR  pStartBuffer;
    PUCHAR  pBuffer;
    PUCHAR  pNextByte;
    ULONG   RemainingData;
    KEVENT  ReadSyncEvent;
} PIPEBUFFER, *PPIPEBUFFER;


//
// Device Extension
//

typedef struct _USBSCAN_DEVICE_EXTENSION {

    PDEVICE_OBJECT                  pOwnDeviceObject;
    PDEVICE_OBJECT                  pStackDeviceObject;
    PDEVICE_OBJECT                  pPhysicalDeviceObject;
    ULONG                           DeviceInstance;
    UNICODE_STRING                  DeviceName;
    UNICODE_STRING                  SymbolicLinkName;
    KEVENT                          PendingIoEvent;
    ULONG                           PendingIoCount;
    BOOLEAN                         AcceptingRequests;
    BOOLEAN                         Stopped;

    //
    // Remote wakeup support.
    //

    KEVENT                          WakeCompletedEvent;
    LONG                            WakeState;
    PIRP                            pWakeIrp;
    BOOLEAN                         bEnabledForWakeup;

    //
    // USB descriptors from the device
    //

    PUSB_DEVICE_DESCRIPTOR          pDeviceDescriptor;
    PUSB_CONFIGURATION_DESCRIPTOR   pConfigurationDescriptor;
    PUSB_INTERFACE_DESCRIPTOR       pInterfaceDescriptor;
    PUSB_ENDPOINT_DESCRIPTOR        pEndpointDescriptor;

    USBD_CONFIGURATION_HANDLE       ConfigurationHandle;
    USBD_PIPE_INFORMATION           PipeInfo[MAX_NUM_PIPES];
    ULONG                           NumberOfPipes;
    ULONG                           IndexBulkIn;
    ULONG                           IndexBulkOut;
    ULONG                           IndexInterrupt;

    //
    // Name of the device interface
    //
    UNICODE_STRING  InterfaceNameString;

    //
    // Read pipe buffer
    //

    PIPEBUFFER                      ReadPipeBuffer[MAX_NUM_PIPES];

    //
    // Power management variables
    //

    PIRP                            pPowerIrp;
    DEVICE_CAPABILITIES             DeviceCapabilities;
    DEVICE_POWER_STATE              CurrentDevicePowerState;

    //
    // For MP safe contention management.
    //

    KSPIN_LOCK                      SpinLock;

} USBSCAN_DEVICE_EXTENSION, *PUSBSCAN_DEVICE_EXTENSION;

typedef struct _TRANSFER_CONTEXT {
    ULONG               RemainingTransferLength;
    ULONG               ChunkSize;
    ULONG               NBytesTransferred;
    PUCHAR              pTransferBuffer;
    PUCHAR              pOriginalTransferBuffer;
    PMDL                pTransferMdl;
    ULONG               PipeIndex;
    PURB                pUrb;
    BOOLEAN             fDestinedForReadBuffer;
    BOOLEAN             fNextReadBlocked;
    PIRP                pThisIrp;
    PDEVICE_OBJECT      pDeviceObject;
    LARGE_INTEGER       Timeout;
    KDPC                TimerDpc;
    KTIMER              Timer;
} TRANSFER_CONTEXT, *PTRANSFER_CONTEXT;

typedef struct _USBSCAN_FILE_CONTEXT {
    LONG            PipeIndex;
    ULONG           TimeoutRead;
    ULONG           TimeoutWrite;
    ULONG           TimeoutEvent;
} USBSCAN_FILE_CONTEXT, *PUSBSCAN_FILE_CONTEXT;

typedef struct _USBSCAN_PACKTES {
    PIRP    pIrp;
    ULONG   TimeoutCounter;
    BOOLEAN bCompleted;
    LIST_ENTRY  PacketsEntry;
} USBSCAN_PACKETS, *PUSBSCAN_PACKETS;

#ifdef _WIN64
typedef struct _IO_BLOCK_32 {
    IN      unsigned            uOffset;
    IN      unsigned            uLength;
    IN OUT  CHAR * POINTER_32   pbyData;
    IN      unsigned            uIndex;
} IO_BLOCK_32, *PIO_BLOCK_32;

typedef struct _IO_BLOCK_EX_32 {
    IN      unsigned            uOffset;
    IN      unsigned            uLength;
    IN OUT  CHAR * POINTER_32   pbyData;
    IN      unsigned            uIndex;
    IN      UCHAR               bRequest;               // Specific request
    IN      UCHAR               bmRequestType;          // Bitmap - charateristics of request
    IN      UCHAR               fTransferDirectionIn;   // TRUE - Device-->Host; FALSE - Host-->Device
} IO_BLOCK_EX_32, *PIO_BLOCK_EX_32;
#endif // _WIN64

//
// prototypes
//

NTSTATUS                                // in usbscan9x.c
DriverEntry(
        IN PDRIVER_OBJECT  DriverObject,
        IN PUNICODE_STRING RegistryPath
);

VOID                                    // in usbscan9x.c
USUnload(
        IN PDRIVER_OBJECT DriverObject
);

VOID                                    // in usbscan9x.c
USIncrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
);

LONG                                    // in usbscan9x.c
USDecrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
);

NTSTATUS                                // in usbscan9x.c
USDeferIrpCompletion(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp,
    IN PVOID          Context
);

NTSTATUS                                // in usbscan9x.c
USCreateSymbolicLink(
    PUSBSCAN_DEVICE_EXTENSION  pde
);

NTSTATUS                                // in usbscan9x.c
USDestroySymbolicLink(
    PUSBSCAN_DEVICE_EXTENSION  pde
);

NTSTATUS                                // in usbscan9x.c
USPnp(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
);

NTSTATUS                                // in usbscan9x.c
USPnpAddDevice(
    IN PDRIVER_OBJECT     pDriverObject,
    IN OUT PDEVICE_OBJECT pPhysicalDeviceObject
);

NTSTATUS                                // in usbscan9x.c
USGetUSBDeviceDescriptor(
    IN PDEVICE_OBJECT pDeviceObject
);

NTSTATUS                                // in usbscan9x.c
USBSCAN_CallUSBD(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PURB pUrb
);

NTSTATUS                                // in usbscan9x.c
USConfigureDevice(
    IN PDEVICE_OBJECT pDeviceObject
);

NTSTATUS                                // in usbscan9x.c
USUnConfigureDevice(
    IN PDEVICE_OBJECT pDeviceObject
);

NTSTATUS                                // in usbscan9x.c
USGetDeviceCapability(
    IN PUSBSCAN_DEVICE_EXTENSION    pde
    );

NTSTATUS                                // in usbscan9x.c
UsbScanReadDeviceRegistry(
    IN  PUSBSCAN_DEVICE_EXTENSION   pExtension,
    IN  PCWSTR                      pKeyName,
    OUT PVOID                       *ppvData
    );

NTSTATUS                                // in usbscan9x.c
UsbScanWriteDeviceRegistry(
    IN PUSBSCAN_DEVICE_EXTENSION    pExtension,
    IN PCWSTR                       pKeyName,
    IN ULONG                        Type,
    IN PVOID                        pvData,
    IN ULONG                        DataSize
    );

PURB
USCreateConfigurationRequest(
    IN PUSB_CONFIGURATION_DESCRIPTOR    ConfigurationDescriptor,
    IN OUT PUSHORT                      Siz
    );

NTSTATUS
USWaitWakeIoCompletionRoutine(
    PDEVICE_OBJECT   pDeviceObject,
    PIRP             pIrp,
    PVOID            pContext
    );

BOOLEAN
USArmForWake(
    PUSBSCAN_DEVICE_EXTENSION   pde,
    POWER_STATE                 SystemState
    );


VOID
USDisarmWake(
    PUSBSCAN_DEVICE_EXTENSION  pde
    );

VOID
USWaitWakePoCompletionRoutine(
    PDEVICE_OBJECT      pDeviceObject,
    UCHAR               MinorFunction,
    POWER_STATE         State,
    PVOID               pContext,
    PIO_STATUS_BLOCK    pIoStatus
    );

VOID
USInitializeWakeState(
    PUSBSCAN_DEVICE_EXTENSION  pde
    );

VOID
USQueuePassiveLevelCallback(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIO_WORKITEM_ROUTINE pCallbackFunction
    );

VOID
USPassiveLevelReArmCallbackWorker(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PVOID            pContext
    );

LONG
MyInterlockedOr(
    PKSPIN_LOCK     pSpinLock,
    LONG volatile   *Destination,
    LONG            Value
    );

#ifdef ORIGINAL_POOLTRACK
PVOID                                   // in usbscan9x.c
USAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG     ulNumberOfBytes
    );

VOID                                    // in usbscan9x.c
USFreePool(
    IN PVOID     pvAddress
    );

#else       // ORIGINAL_POOLTRACK
 #define USAllocatePool(a, b)   ExAllocatePoolWithTag(a, b, NAME_POOLTAG)
 #define USFreePool(a)          ExFreePool(a)
#endif      // ORIGINAL_POOLTRACK


NTSTATUS                                // in ioctl.c
USDeviceControl(
        IN PDEVICE_OBJECT pDeviceObject,
        IN PIRP pIrp
    );

NTSTATUS                                // in ioctl.c
USReadWriteRegisters(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIO_BLOCK      pIoBlock,
    IN BOOLEAN        fRead,
    IN ULONG          IoBlockSize
    );

NTSTATUS                               // in ioctl.c
USPassThruUSBRequest(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIO_BLOCK_EX     pIoBlockEx,
    IN ULONG            InLength,
    IN ULONG            OutLength
    );

NTSTATUS                               // in ioctl.c
USPassThruUSBRequestPTP(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIO_BLOCK_EX     pIoBlockEx,
    IN ULONG            InLength,
    IN ULONG            OutLength
    );


NTSTATUS                                // in ioctl.c
USCancelPipe(
        IN PDEVICE_OBJECT   pDeviceObject,
        IN PIRP             pIrp,
        IN PIPE_TYPE        PipeType,
        IN BOOLEAN          fAbort
    );

NTSTATUS                                // in ioctl.c
USAbortResetPipe(
        IN PDEVICE_OBJECT pDeviceObject,
        IN ULONG uIndex,
    IN BOOLEAN fAbort
    );

NTSTATUS                                // in ocrw.c
USOpen(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS                                // in ocrw.c
USClose(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS                                // in ocrw.c
USFlush(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS                                // in ocrw.c
USRead(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS                                // in ocrw.c
USWrite(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS                                // in ocrw.c
USTransfer(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp,
    IN ULONG            PipeIndex,
    IN PVOID            pBuffer,
    IN PMDL             pMdl,
    IN ULONG            TransferSize,
    IN PULONG           pTimeout
    );

NTSTATUS                                // in ocrw.c
USTransferComplete(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp,
    IN PTRANSFER_CONTEXT    pTransferContext
    );

VOID                                    // in ocrw.c
USCancelIrp(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    );

NTSTATUS                                // in ocrw.c
USEnqueueIrp(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PUSBSCAN_PACKETS     pPackets
    );

PUSBSCAN_PACKETS                        // in ocrw.c
USDequeueIrp(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

VOID                                    // in ocrw.c
USWaitThread(
    IN PVOID pTransferContext
    );

ULONG
USGetPipeIndexToUse(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp,
    IN ULONG                PipeIndex
    );

VOID
USTimerDpc(
    IN PKDPC    pDpc,
    IN PVOID    pIrp,
    IN PVOID    SystemArgument1,
    IN PVOID    SystemArgument2
    );


NTSTATUS                                // in power.c
USPower(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    );


NTSTATUS                                // in power.c
USPoRequestCompletion(
    IN PDEVICE_OBJECT       pPdo,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIO_STATUS_BLOCK     pIoStatus
    );

NTSTATUS                                // in power.c
USSetDevicePowerState(
    IN PDEVICE_OBJECT pDeviceObject,
    IN DEVICE_POWER_STATE DeviceState,
    IN PBOOLEAN pHookIt
    );

NTSTATUS
USSystemPowerIrpComplete(
    IN PDEVICE_OBJECT pPdo,
    IN PIRP           pIrp,
    IN PDEVICE_OBJECT pDeviceObject
    );


NTSTATUS
USDevicePowerIrpComplete(
    IN PDEVICE_OBJECT pPdo,
    IN PIRP           pIrp,
    IN PDEVICE_OBJECT pDeviceObject
    );


NTSTATUS
USCallNextDriverSynch(
    IN  PUSBSCAN_DEVICE_EXTENSION  pde,
    IN  PIRP              pIrp
    );


NTSTATUS
UsbScanHandleInterface(
    PDEVICE_OBJECT      DeviceObject,
    PUNICODE_STRING     InterfaceName,
    BOOLEAN             Create
    );



VOID
UsbScanLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\usbscn9x\usbd_api.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2001

Module Name:

    usbd_api.h

Abstract:
Function prototype and definition used to build USB request.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "usbdi.h"
#include "usbdlib.h"


#define OPCODE_SEQ_TRANSFER             0x00    // 00000000b
#define OPCODE_SINGLE_ADDR_TRANSFER     0x08    // 00001000b
#define REGISTER_AREA                   0x04
#define BLOCK                           TRUE
#define DONT_BLOCK                      FALSE

//
// Macros for building URB requests
//

#define UsbBuildSetFeatureDeviceRequest(        \
urb,                                            \
length,                                         \
link,                                           \
featureSelector,                                \
index) {                                        \
       (urb)->UrbHeader.Function =  URB_FUNCTION_SET_FEATURE_TO_DEVICE;     \
       (urb)->UrbHeader.Length = (length);                                  \
       (urb)->UrbControlFeatureRequest.UrbLink = (link);                    \
       (urb)->UrbControlFeatureRequest.FeatureSelector = (featureSelector); \
       (urb)->UrbControlFeatureRequest.Index = (index);                     \
}

#define UsbBuildAbortPipeRequest(               \
urb,                                            \
length,                                         \
handle) {                                       \
        (urb)->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;    \
        (urb)->UrbHeader.Length = (USHORT)length;               \
        (urb)->UrbPipeRequest.PipeHandle = handle;              \
}

#define UsbBuildResetPipeRequest(               \
urb,                                            \
length,                                         \
handle) {                                       \
        (urb)->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;    \
        (urb)->UrbHeader.Length = (USHORT)length;               \
        (urb)->UrbPipeRequest.PipeHandle = handle;              \
}

#define UsbBuildVendorClassSpecificCommand(     \
urb,                                            \
transferFlags,                                  \
bufLength,                                      \
transferBuf,                                    \
transferMdl,                                    \
requestType,                                    \
request,                                        \
value,                                          \
index ) {                                       \
        (urb)->UrbHeader.Function = URB_FUNCTION_VENDOR_DEVICE;                         \
        (urb)->UrbHeader.Length = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);  \
        (urb)->UrbControlVendorClassRequest.TransferFlags = transferFlags;              \
        (urb)->UrbControlVendorClassRequest.TransferBufferLength = bufLength;           \
        (urb)->UrbControlVendorClassRequest.TransferBuffer = transferBuf;               \
        (urb)->UrbControlVendorClassRequest.TransferBufferMDL = transferMdl;            \
        (urb)->UrbControlVendorClassRequest.RequestTypeReservedBits = requestType;      \
        (urb)->UrbControlVendorClassRequest.Request = request;                          \
        (urb)->UrbControlVendorClassRequest.Value = value;                              \
        (urb)->UrbControlVendorClassRequest.Index = index;                              \
}

#define UsbBuildVendorClassSpecificCommandPTP(  \
command,                                        \
urb,                                            \
transferFlags,                                  \
bufLength,                                      \
transferBuf,                                    \
transferMdl,                                    \
requestType,                                    \
request,                                        \
value,                                          \
index ) {                                       \
        (urb)->UrbHeader.Function = command;                                            \
        (urb)->UrbHeader.Length = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);  \
        (urb)->UrbControlVendorClassRequest.TransferFlags = transferFlags;              \
        (urb)->UrbControlVendorClassRequest.TransferBufferLength = bufLength;           \
        (urb)->UrbControlVendorClassRequest.TransferBuffer = transferBuf;               \
        (urb)->UrbControlVendorClassRequest.TransferBufferMDL = transferMdl;            \
        (urb)->UrbControlVendorClassRequest.RequestTypeReservedBits = requestType;      \
        (urb)->UrbControlVendorClassRequest.Request = request;                          \
        (urb)->UrbControlVendorClassRequest.Value = value;                              \
        (urb)->UrbControlVendorClassRequest.Index = index;                              \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\cistr.h ===
/******************************************************************************

  Header File:  string.h

  This defines our locally-owned version of a string class.  I swear this has
  to be the 5th or 6h time I've done one, but each time someone else owns the
  code, so here we go again...

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  Change History:
  01-08-97  Bob Kjelgaard
  01-30-97  Bob Kjelgaard   Added features to aid port extraction for plug and play.
  07-05-97  Tim Wells       Ported to NT

******************************************************************************/

#if !defined(COSMIC_STRINGS)

#define COSMIC_STRINGS

class CString {

    LPTSTR   m_lpstr;

public:

    void Empty() {

        if (m_lpstr) {

            delete m_lpstr;
        }

        m_lpstr = NULL;
    }

    CString() {

        m_lpstr = NULL;

    }

    ~CString() {

        Empty();
    }

    CString(LPCTSTR lpstrRef);
    CString(const CString& csRef);

    BOOL IsEmpty() const { return !m_lpstr || !*m_lpstr; }

    const CString&  operator =(const CString& csRef);
    const CString&  operator =(LPCTSTR lpstrRef);

    operator LPCTSTR() const { return m_lpstr; }
    operator LPTSTR() { return m_lpstr; }

    void GetContents(HWND hwnd);             //  Get Window Text

    void FromTable(unsigned uid);            //  Load from resource

    void Load(ATOM at, BOOL bGlobal = TRUE); //  Load from atom

    void Load(HINF    hInf = INVALID_HANDLE_VALUE, 
              LPCTSTR lpstrSection = NULL, 
              LPCTSTR lpstrKeyword = NULL,
              DWORD   dwFieldIndex = 1,
              LPCTSTR lpstrDefault = NULL);

    void Load(HKEY hk, LPCTSTR lpstrKeyword);

    void MakeSystemPath (LPCTSTR lpstrFilename);

    void Store(HKEY hk, LPCTSTR lpstrKey, LPCTSTR lpstrType = NULL);

    DWORD Decode();

    friend CString  operator + (const CString& cs1, const CString& cs2);
    friend CString  operator + (const CString& cs1, LPCTSTR lpstr2);
    friend CString  operator + (LPCTSTR lpstr1,const CString& cs2);
};

class CStringArray {

    unsigned    m_ucItems, m_ucMax, m_uGrowBy;

    CString     *m_pcsContents, m_csEmpty;

public:

    CStringArray(unsigned m_uGrowby = 10);

    ~CStringArray();

    void        CStringArray::Cleanup();
    
    unsigned    Count() const { return m_ucItems; }

    void        Add(LPCTSTR lpstr);

    CString&    operator[](unsigned u);

    //  Split a string into an array, using a defined separator

    void        Tokenize(LPTSTR lpstr, TCHAR cSeparator);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\kernel\usbscn9x\usbscn9x.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    usbscn9x.c

Abstract:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include <wdm.h>
#include <stdio.h>
#include <usbscan.h>
#include <usbd_api.h>
#include "private.h"

#include <initguid.h>
#include <wiaintfc.h>


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, USPnpAddDevice)
#pragma alloc_text(PAGE, USPnp)
#pragma alloc_text(PAGE, USCreateSymbolicLink)
#pragma alloc_text(PAGE, USDestroySymbolicLink)
#pragma alloc_text(PAGE, USGetUSBDeviceDescriptor)
#pragma alloc_text(PAGE, USConfigureDevice)
#pragma alloc_text(PAGE, USUnConfigureDevice)
#pragma alloc_text(PAGE, USUnload)
#endif

// Globals

ULONG NextDeviceInstance = 0;

#if DBG
ULONG USBSCAN_DebugTraceLevel = MIN_TRACE;
ULONG USBSCAN_PnPTest = 0;
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT pDriverObject,
    IN PUNICODE_STRING pRegistryPath
)
{
/*++

   Routine Description:
   Installable driver initialization entry point.
   This is where the driver is called when the driver is being loaded
   by the I/O system.

   Arguments:
   DriverObject - pointer to the driver object
   RegistryPath - pointer to a unicode string representing the path
   to driver-specific key in the registry

   Return Value:
   STATUS_SUCCESS       if successful,
   STATUS_UNSUCCESSFUL  otherwise

   -- */

    PAGED_CODE();

    DebugTrace((MIN_TRACE | TRACE_FLAG_PROC),("DriverEntry called. Driver reg=%wZ\n",pRegistryPath));

#if DBG
    MyDebugInit(pRegistryPath);
#endif // DBG

    pDriverObject -> MajorFunction[IRP_MJ_READ]            = USRead;
    pDriverObject -> MajorFunction[IRP_MJ_WRITE]           = USWrite;
    pDriverObject -> MajorFunction[IRP_MJ_DEVICE_CONTROL]  = USDeviceControl;
    pDriverObject -> MajorFunction[IRP_MJ_CREATE]          = USOpen;
    pDriverObject -> MajorFunction[IRP_MJ_CLOSE]           = USClose;
    pDriverObject -> MajorFunction[IRP_MJ_PNP_POWER]       = USPnp;
    pDriverObject -> MajorFunction[IRP_MJ_FLUSH_BUFFERS]   = USFlush;
    pDriverObject -> MajorFunction[IRP_MJ_POWER]           = USPower;
    pDriverObject -> MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = USPnp;
    pDriverObject -> DriverExtension -> AddDevice          = USPnpAddDevice;
    pDriverObject -> DriverUnload                          = USUnload;

    return STATUS_SUCCESS;
}

NTSTATUS
USPnpAddDevice(
    IN PDRIVER_OBJECT pDriverObject,
    IN OUT PDEVICE_OBJECT pPhysicalDeviceObject
)

/*++

Routine Description:

    This routine is called to create a new instance of the device.

Arguments:

    pDriverObject - pointer to the driver object for this instance of SS
    pPhysicalDeviceObject - pointer to the device object that represents the scanner
    on the scsi bus.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    UCHAR                       aName[64];
    ANSI_STRING                 ansiName;
    UNICODE_STRING              uName;
    PDEVICE_OBJECT              pDeviceObject = NULL;
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USPnpAddDevice: Enter..\n"));

    //
    // Create the Functional Device Object (FDO) for this device.
    //

    sprintf(aName,"\\Device\\Usbscan%d",NextDeviceInstance);
    RtlInitAnsiString(&ansiName, aName);

    //
    // Show device object name.
    //

    DebugTrace(TRACE_STATUS,("USPnpAddDevice: Create device object %s\n", aName));

    //
    // Allocates Unicode string.
    //

    Status = RtlAnsiStringToUnicodeString(&uName, &ansiName, TRUE);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_CRITICAL,("USPnpAddDevice: ERROR!! Can't alloc buffer for Unicode\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USPnpAddDevice_return;
    }

    //
    // Create device object for this scanner.
    //

    Status = IoCreateDevice(pDriverObject,
                            sizeof(USBSCAN_DEVICE_EXTENSION),
                            &uName,
                            FILE_DEVICE_SCANNER,
                            0,
                            FALSE,
                            &pDeviceObject);

    if (!NT_SUCCESS(Status)) {
        DebugTrace(TRACE_ERROR,("USPnpAddDevice: ERROR!! Can't create device object\n"));
        DEBUG_BREAKPOINT();
        goto USPnpAddDevice_return;
    }

    //
    // Device object was successfully created.
    // Free Unicode string used for device creation.
    //

    RtlFreeUnicodeString(&uName);
    uName.Buffer = NULL;

    //
    // Initialize Device Extension.
    //

    pde = (PUSBSCAN_DEVICE_EXTENSION)(pDeviceObject -> DeviceExtension);
    RtlZeroMemory(pde, sizeof(USBSCAN_DEVICE_EXTENSION));

    //
    // Save own device object.
    //

    pde -> pOwnDeviceObject = pDeviceObject;

    //
    // Initialize PendingIoEvent.  Set the number of pending i/o requests for this device to 1.
    // When this number falls to zero, it is okay to remove, or stop the device.
    //

    pde -> PendingIoCount = 0;
    pde -> Stopped = FALSE;
    KeInitializeEvent(&pde -> PendingIoEvent, NotificationEvent, FALSE);

    //
    // Indicate that IRPs should include MDLs.
    //

    pDeviceObject->Flags |= DO_DIRECT_IO;

    //
    // indicate our power code is pagable
    //

    pDeviceObject->Flags |= DO_POWER_PAGABLE;

    //
    // Attach our new FDO to the PDO (Physical Device Object).
    //

    pde -> pStackDeviceObject = IoAttachDeviceToDeviceStack(pDeviceObject,
                                                            pPhysicalDeviceObject);
    if (NULL == pde -> pStackDeviceObject) {
        DebugTrace(TRACE_ERROR,("USPnpAddDevice: ERROR!! Cannot attach FDO to PDO.\n"));
        DEBUG_BREAKPOINT();
        IoDeleteDevice( pDeviceObject );
        Status = STATUS_NOT_SUPPORTED;
        goto USPnpAddDevice_return;
    }

    //
    // Remember the PDO in our device extension.
    //

    pde -> pPhysicalDeviceObject = pPhysicalDeviceObject;

    //
    // Remember the DeviceInstance number.
    //

    pde -> DeviceInstance = NextDeviceInstance;

    //
    // Handle exporting interface
    //

    Status = UsbScanHandleInterface(
        pPhysicalDeviceObject,
        &pde->InterfaceNameString,
        TRUE
        );

    //
    // Each time AddDevice gets called, we advance the global DeviceInstance variable.
    //

    NextDeviceInstance++;

    //
    // Set initial device power state as online.
    //

    pde -> CurrentDevicePowerState = PowerDeviceD0;
    
    //
    // Initialize spinlock.
    //

    KeInitializeSpinLock(&pde->SpinLock);
    
    //
    // Initialize wake state.
    //

    USInitializeWakeState(pde);

    //
    // Will see device capability on START_DEVICE.
    //

    pde -> bEnabledForWakeup = FALSE;

    //
    // Finish initializing.
    //

    pDeviceObject -> Flags &= ~DO_DEVICE_INITIALIZING;

USPnpAddDevice_return:

    if(NULL != uName.Buffer){
        RtlFreeUnicodeString(&uName);
    }

    DebugTrace(TRACE_PROC_LEAVE,("USPnpAddDevice: Leaving.. Status = 0x%x\n", Status));
    return Status;

} // end USAddDevice()


NTSTATUS USPnp(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
)
/*++

Routine Description:

    This routine handles all PNP irps.

Arguments:

    pDeviceObject - represents a scanner device
    pIrp - PNP irp

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PIO_STACK_LOCATION          pIrpStack;
    KEVENT                      event;
    PDEVICE_CAPABILITIES        pCaps;
    LONG                        bTemp;
    POWER_STATE                 PowerState;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USPnp: Enter..\n"));

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    Status = pIrp -> IoStatus.Status;

//  DbgPrint("USPnP: Major=0x%x, Minor=0x%x\n",
//           pIrpStack -> MajorFunction,
//           pIrpStack->MinorFunction);

    switch (pIrpStack -> MajorFunction) {

        case IRP_MJ_SYSTEM_CONTROL:
            DebugTrace(TRACE_STATUS,("USPnp: IRP_MJ_SYSTEM_CONTROL\n"));

            //
            // Simply passing down the IRP.
            //

            DebugTrace(TRACE_STATUS,("USPnp: Simply passing down the IRP\n"));

            IoCopyCurrentIrpStackLocationToNext( pIrp );
            Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);
            break;

        case IRP_MJ_PNP:
            DebugTrace(TRACE_STATUS,("USPnp: IRP_MJ_PNP\n"));
            switch (pIrpStack->MinorFunction) {

                case IRP_MN_QUERY_CAPABILITIES:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MJ_QUERY_CAPS\n"));

                    //
                    // Call downlevel driver first to fill capabilities structure
                    // Then add our specific capabilities
                    //

                    DebugTrace(TRACE_STATUS,("USPnp: Call down to get capabilities\n"));

                    pIrp->IoStatus.Status = STATUS_SUCCESS;
                    Status = USCallNextDriverSynch(pde, pIrp);

                    if(!NT_SUCCESS(Status)){
                        DebugTrace(TRACE_ERROR,("USPnp: ERROR!! Call down failed. Status=0x%x\n", Status));
                        IoCompleteRequest( pIrp, IO_NO_INCREMENT );
                        goto USPnP_return;
                    }

                    //
                    // Set SurpriseRemoval OK
                    //

                    pCaps = pIrpStack -> Parameters.DeviceCapabilities.Capabilities;
                    pCaps->SurpriseRemovalOK = TRUE;
                    pCaps->Removable = TRUE;

                    //
                    // Setup remote wakeup state.
                    //

                    DebugTrace(TRACE_STATUS,("USPnp: DeviceState[PowerSystemUnspecified]=0x%x.\n",pCaps->DeviceState[PowerSystemUnspecified]));
                    DebugTrace(TRACE_STATUS,("USPnp: DeviceState[PowerSystemWorking]    =0x%x.\n",pCaps->DeviceState[PowerSystemWorking]));
                    DebugTrace(TRACE_STATUS,("USPnp: DeviceState[PowerSystemSleeping1]  =0x%x.\n",pCaps->DeviceState[PowerSystemSleeping1]));
                    DebugTrace(TRACE_STATUS,("USPnp: DeviceState[PowerSystemSleeping2]  =0x%x.\n",pCaps->DeviceState[PowerSystemSleeping2]));
                    DebugTrace(TRACE_STATUS,("USPnp: DeviceState[PowerSystemSleeping3]  =0x%x.\n",pCaps->DeviceState[PowerSystemSleeping3]));
                    DebugTrace(TRACE_STATUS,("USPnp: DeviceState[PowerSystemHibernate]  =0x%x.\n",pCaps->DeviceState[PowerSystemHibernate]));
                    DebugTrace(TRACE_STATUS,("USPnp: DeviceState[PowerSystemShutdown]   =0x%x.\n",pCaps->DeviceState[PowerSystemShutdown]));
                    DebugTrace(TRACE_STATUS,("USPnp: DeviceState[PowerSystemMaximum]    =0x%x.\n",pCaps->DeviceState[PowerSystemMaximum]));

                    DebugTrace(TRACE_STATUS,("USPnp: Lower stack set DeviceWake(0x%x) SystemWake(0x%x)\n.", pCaps->DeviceWake, pCaps->SystemWake));
                    
                    //
                    // Set returning status.
                    //

                    Status = STATUS_SUCCESS;
                    pIrp -> IoStatus.Status = Status;
                    pIrp -> IoStatus.Information = 0;

                    IoCompleteRequest( pIrp, IO_NO_INCREMENT );
                    goto USPnP_return;

                    break;


                case IRP_MN_START_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MJ_START_DEVICE\n"));

                    pde -> Stopped = FALSE;
                    USIncrementIoCount(pDeviceObject);

                    //
                    // First, let the port driver start the device.
                    //

                    Status = USCallNextDriverSynch(pde, pIrp);
                    if(!NT_SUCCESS(Status)){

                        //
                        // Lower layer failed to start device.
                        //

                        DebugTrace(TRACE_ERROR,("USPnp: ERROR!! Lower layer failed to start device. Status=0x%x\n", Status));
                        break;
                    }

                    //
                    // The port driver has started the device.  It is time for
                    // us to do some initialization and create symbolic links
                    // for the device.
                    //
                    // Get the device descriptor and save it in our
                    // device extension.
                    //

                    Status = USGetUSBDeviceDescriptor(pDeviceObject);
                    if(!NT_SUCCESS(Status)){

                        //
                        // GetDescriptor failed.
                        //

                        DebugTrace(TRACE_ERROR,("USPnp: ERROR!! Cannot get DeviceDescriptor.\n"));
                        DEBUG_BREAKPOINT();
                        break;
                    }

                    //
                    // Configure the device.
                    //

                    Status = USConfigureDevice(pDeviceObject);
#if DBG
                    //DEBUG_BREAKPOINT();
                    if (USBSCAN_PnPTest) {
                        Status = STATUS_UNSUCCESSFUL;
                    }
#endif

                    if (!NT_SUCCESS(Status)) {
                        DebugTrace(TRACE_ERROR,("USPnp: ERROR!! Can't configure the device.\n"));
                        DEBUG_BREAKPOINT();
                        break;
                    }

                    //
                    // Create the symbolic link for this device.
                    //

                    Status = USCreateSymbolicLink( pde );
#if DBG
                    //DEBUG_BREAKPOINT();
                    if (USBSCAN_PnPTest) {
                        Status = STATUS_UNSUCCESSFUL;
                    }
#endif
                    if (!NT_SUCCESS(Status)) {
                        DebugTrace(TRACE_ERROR, ("USPnp: ERROR!! Can't create symbolic link.\n"));
                        DEBUG_BREAKPOINT();
                        break;
                    }

                    //
                    // Initialize the synchronize read event.  This event is used the serialze
                    // i/o requests to the read pipe if the request size is NOT a usb packet multiple.
                    //

                    {
                        ULONG i;
                        for(i = 0; i < pde->NumberOfPipes; i++){
                            if( (pde->PipeInfo[i].PipeType == UsbdPipeTypeBulk)
                             && (pde->PipeInfo[i].EndpointAddress & BULKIN_FLAG) )
                            {
                                DebugTrace(TRACE_STATUS,("USPnp: Initializing event for Pipe[%d]\n", i));
                                KeInitializeEvent(&pde -> ReadPipeBuffer[i].ReadSyncEvent, SynchronizationEvent, TRUE);
                            }
                        }
                    }

                    
                    //
                    // Get device capability.
                    //

                    Status = USGetDeviceCapability(pde);
                    if(!NT_SUCCESS(Status)){
                        DebugTrace(TRACE_ERROR, ("USPnp: ERROR!! Unable to get Capability of this device. Status=0x%x.\n", Status));
                        break;
                    } // if(!NT_SUCCESS(Status))

                    //
                    // Arm for wake if device is capable.
                    //
                    
                    if(TRUE == pde->bEnabledForWakeup){
                        PowerState.SystemState = pde -> DeviceCapabilities.SystemWake;
                        USArmForWake(pde, PowerState);
                    } // if(TRUE == pde->bEnabledForWakeup)

                    //
                    // Indicate device is now ready.
                    //

                    pde -> AcceptingRequests = TRUE;

                    //
                    // Set return status.
                    //

                    pIrp -> IoStatus.Status = Status;
                    pIrp -> IoStatus.Information = 0;

                    IoCompleteRequest( pIrp, IO_NO_INCREMENT );
                    goto USPnP_return;

                case IRP_MN_REMOVE_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_REMOVE_DEVICE\n"));

                    //
                    // Prohivit further request.
                    //

                    bTemp = (LONG)InterlockedExchange((PULONG)&(pde -> AcceptingRequests),
                                                      (LONG)FALSE );

                    //
                    // Wait for any io requests pending in our driver to
                    // complete before proceeding the remove.
                    //

                    if (!pde -> Stopped ) {
                        USDecrementIoCount(pDeviceObject);
                    }

                    //
                    // Disarm remote wakeup.
                    //

                    USDisarmWake(pde);

                    KeWaitForSingleObject(&pde -> PendingIoEvent,
                                          Suspended,
                                          KernelMode,
                                          FALSE,NULL);

                    //
                    // Is this device stopped/removed before?
                    //

                    if (bTemp) {

                        //
                        // Delete symbolic link.
                        //

                        USDestroySymbolicLink( pde );

                        //
                        // Abort all pipes.
                        //

                        USCancelPipe(pDeviceObject, NULL, ALL_PIPE, TRUE);
                    }

                    //
                    // Disable device interface.
                    //

                    UsbScanHandleInterface(pde->pPhysicalDeviceObject,
                                           &pde->InterfaceNameString,
                                           FALSE);

                    //
                    // Forward remove message to lower driver.
                    //

                    IoCopyCurrentIrpStackLocationToNext(pIrp);
                    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

                    //
                    // Free allocated memory.
                    //

                    if (pde -> pDeviceDescriptor) {
                        USFreePool(pde -> pDeviceDescriptor);
                        pde -> pDeviceDescriptor = NULL;
                    }

                    if (pde -> pConfigurationDescriptor) {
                        USFreePool(pde -> pConfigurationDescriptor);
                        pde -> pConfigurationDescriptor = NULL;
                    }

                    //
                    // Free allocated buffer(s)
                    //
                    {
                        ULONG i;
                        for(i = 0; i < pde->NumberOfPipes; i++){
                            if(pde->ReadPipeBuffer[i].pStartBuffer){
                                USFreePool(pde->ReadPipeBuffer[i].pStartBuffer);
                                pde->ReadPipeBuffer[i].pStartBuffer = NULL;
                                pde->ReadPipeBuffer[i].pBuffer = NULL;
                            }
                        }
                    }

                    //
                    // Detatch device object from stack.
                    //

                    IoDetachDevice(pde -> pStackDeviceObject);

                    //
                    // Delete device object
                    //

                    IoDeleteDevice (pDeviceObject);
                    pDeviceObject = NULL;

                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_REMOVE_DEVICE complete\n"));
                    goto USPnP_return;

                case IRP_MN_STOP_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_STOP_DEVICE\n"));

                    //
                    // Indicate device is stopped.
                    //

                    pde -> Stopped = TRUE;

                    if (pde -> AcceptingRequests) {

                        //
                        // Disarm remote wakeup.
                        //

                        USDisarmWake(pde);

                        //
                        // No more requests are allowed.
                        //

                        pde -> AcceptingRequests = FALSE;

                        //
                        // Delete symbolic link.
                        //

                        USDestroySymbolicLink( pde );

                        //
                        // Abort all pipes.
                        //

                        USCancelPipe(pDeviceObject, NULL, ALL_PIPE, TRUE);

                        //
                        // Set device into unconfigured state.
                        //

                        USUnConfigureDevice(pDeviceObject);

                    } //(pde -> AcceptingRequests)

#ifndef _CHICAGO_
                    //
                    // Disable device interface.
                    //

                    if (pde->InterfaceNameString.Buffer != NULL) {
                        IoSetDeviceInterfaceState(&pde->InterfaceNameString,FALSE);
                    }
#endif // _CHICAGO_

                    //
                    // Let the port driver stop the device.
                    //

                    IoCopyCurrentIrpStackLocationToNext(pIrp);
                    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

                    //
                    // wait for any io requests pending in our driver to
                    // complete before finishing the remove
                    //

                    USDecrementIoCount(pDeviceObject);
                    KeWaitForSingleObject(&pde -> PendingIoEvent, Suspended, KernelMode,
                                          FALSE,NULL);

                    ASSERT(pde -> pDeviceDescriptor);
                    ASSERT(pde -> pConfigurationDescriptor);

                    if (pde -> pDeviceDescriptor) {
                        USFreePool(pde -> pDeviceDescriptor);
                        pde -> pDeviceDescriptor = NULL;
                    }

                    if (pde -> pConfigurationDescriptor) {
                        USFreePool(pde -> pConfigurationDescriptor);
                        pde -> pConfigurationDescriptor = NULL;
                    }

                    //
                    // Free allocated buffer(s)
                    //
                    {
                        ULONG i;
                        for(i = 0; i < pde->NumberOfPipes; i++){
                            if(pde->ReadPipeBuffer[i].pBuffer){
                                USFreePool(pde->ReadPipeBuffer[i].pBuffer);
                                pde->ReadPipeBuffer[i].pBuffer = NULL;
                            }
                        }
                    }

                    goto USPnP_return;

                case IRP_MN_QUERY_INTERFACE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_INTERFACE\n"));
                    break;

                case IRP_MN_QUERY_RESOURCES:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_RESOURCES\n"));
                    break;

                case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_RESOURCE_REQUIREMENTS\n"));
                    break;

                case IRP_MN_QUERY_DEVICE_TEXT:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_DEVICE_TEXT\n"));
                    break;

//                case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
//                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_LEGACY_BUS_INFORMATION\n"));
//                    break;

                case IRP_MN_QUERY_STOP_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_STOP_DEVICE\n"));
                    break;

                case IRP_MN_QUERY_REMOVE_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_REMOVE_DEVICE\n"));
                    break;

                case IRP_MN_CANCEL_STOP_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_CANCEL_STOP_DEVICE\n"));
                    break;

                case IRP_MN_CANCEL_REMOVE_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_CANCEL_REMOVE_DEVICE\n"));
                    break;

                case IRP_MN_QUERY_DEVICE_RELATIONS:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_DEVICE_RELATIONS\n"));
                    break;

                case IRP_MN_SURPRISE_REMOVAL:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_SURPRISE_REMOVAL\n"));

                    //
                    // Indicate interface is stopped
                    //

                    UsbScanHandleInterface(pde->pPhysicalDeviceObject,
                                           &pde->InterfaceNameString,
                                           FALSE);

                    break;

                default:
                    DebugTrace(TRACE_STATUS,("USPnp: Minor PNP message. MinorFunction = 0x%x\n",pIrpStack->MinorFunction));
                    break;

            } /* case MinorFunction, MajorFunction == IRP_MJ_PNP_POWER  */

            //
            // Passing down IRP
            //

            IoCopyCurrentIrpStackLocationToNext(pIrp);
            Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

            DebugTrace(TRACE_STATUS,("USPnp: Passed Pnp Irp down,  status = %x\n", Status));

            if(!NT_SUCCESS(Status)){
                DebugTrace(TRACE_WARNING,("USPnp: WARNING!! IRP Status failed,  status = %x\n", Status));
                // DEBUG_BREAKPOINT();
            }
            break; // IRP_MJ_PNP

        default:
            DebugTrace(TRACE_STATUS,("USPnp: Major PNP IOCTL not handled\n"));
            Status = STATUS_INVALID_PARAMETER;
            pIrp -> IoStatus.Status = Status;
            IoCompleteRequest( pIrp, IO_NO_INCREMENT );
            goto USPnP_return;

    } /* case MajorFunction */


USPnP_return:
    DebugTrace(TRACE_PROC_LEAVE,("USPnP: Leaving.. Status = 0x%x\n", Status));
    return Status;

} // end USPnp()



NTSTATUS
USCreateSymbolicLink(
    PUSBSCAN_DEVICE_EXTENSION  pde
)
/*++

Routine Description:
    This routine create the symbolic link for the device.

Arguments:
    pde - pointer to device extension

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                      Status;
    UNICODE_STRING                uName;
    UNICODE_STRING                uName2;
    ANSI_STRING                   ansiName;
    CHAR                          aName[32];
    HANDLE                        hSwKey;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USCreateSymbolicLink: Enter..\n"));


    //
    // Initialize
    //

    Status = STATUS_SUCCESS;
    RtlZeroMemory(&uName, sizeof(UNICODE_STRING));
    RtlZeroMemory(&uName2, sizeof(UNICODE_STRING));
    RtlZeroMemory(&ansiName, sizeof(ANSI_STRING));
    hSwKey = NULL;


    //
    // Create the symbolic link for this device.
    //

    sprintf(aName,"\\Device\\Usbscan%d",pde -> DeviceInstance);
    RtlInitAnsiString(&ansiName, aName);

    Status = RtlAnsiStringToUnicodeString(&uName, &ansiName, TRUE);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_CRITICAL,("USCreateSymbolicLink: ERROR!! Cannot allocate buffer for Unicode srting\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USCreateSymbolicLink_return;
    }

    sprintf(aName,"\\DosDevices\\Usbscan%d",pde -> DeviceInstance);
    RtlInitAnsiString(&ansiName, aName);

    Status = RtlAnsiStringToUnicodeString(&(pde -> SymbolicLinkName), &ansiName, TRUE);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_CRITICAL,("USCreateSymbolicLink: ERROR!! Cannot allocate buffer for Unicode srting\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USCreateSymbolicLink_return;
    }

    //
    // Create Sympolic link.
    //

    Status = IoCreateSymbolicLink( &(pde -> SymbolicLinkName), &uName );

    RtlFreeUnicodeString( &uName );
    uName.Buffer = NULL;

    if (STATUS_SUCCESS != Status ) {
        DebugTrace(TRACE_ERROR,("USCreateSymbolicLink: ERROR!! Cannot create symbolic link.\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_NOT_SUPPORTED;
        goto USCreateSymbolicLink_return;
    }

    //
    // Now, stuff the symbolic link into the CreateFileName key so that STI can find the device.
    //

    IoOpenDeviceRegistryKey( pde -> pPhysicalDeviceObject,
                             PLUGPLAY_REGKEY_DRIVER, KEY_WRITE, &hSwKey);

    //
    // Create CreateFile name. ("\\.\UsbscanX")
    //

    RtlInitUnicodeString(&uName,USBSCAN_REG_CREATEFILE);    // L"CreateFileName"
    sprintf(aName, "%s%d", USBSCAN_OBJECTNAME_A, pde -> DeviceInstance); // "\\\\.\\Usbscan%d"
    RtlInitAnsiString(&ansiName, aName);
    Status = RtlAnsiStringToUnicodeString(&uName2, &ansiName, TRUE);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_CRITICAL,("USCreateSymbolicLink: ERROR!! Cannot allocate buffer for Unicode srting\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USCreateSymbolicLink_return;
    }

    //
    // Set CreateFile name to the registry.
    //

    ZwSetValueKey(hSwKey,&uName,0,REG_SZ,uName2.Buffer,uName2.Length);

    //
    // uName is not allocated. Just zero it.
    //

    RtlZeroMemory(&uName, sizeof(UNICODE_STRING));

USCreateSymbolicLink_return:

    if(NULL != hSwKey){
        ZwClose(hSwKey);
    }

    if(NULL != uName.Buffer){
        RtlFreeUnicodeString( &uName );
    }

    if(NULL != uName2.Buffer){
        RtlFreeUnicodeString( &uName2 );
    }

    DebugTrace(TRACE_PROC_LEAVE,("USCreateSymbolicLink: Leaving.. Status = 0x%x\n", Status));
    return Status;

}  // end USCreateSymbolicLink()


NTSTATUS
USDestroySymbolicLink(
    PUSBSCAN_DEVICE_EXTENSION  pde
)
/*++

Routine Description:
    This routine removes the symbolic link for the device.

Arguments:
    pde - pointer to device extension

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    UNICODE_STRING                uName;
    UNICODE_STRING                uName2;
    UNICODE_STRING                uNumber;
    ANSI_STRING                   ansiName;
    CHAR                          aName[32];
    HANDLE                        hSwKey;
    WCHAR                         wsCreateFileName[64];
    ULONG                         ulBufLength, ulRetLength;
    NTSTATUS                      Status;
    PVOID                         pvNumber;
    ULONG                         ulNumber;
    const WCHAR                   wcsObjectName[] = USBSCAN_OBJECTNAME_W;   // L"\\\\.\\Usbscan"
    ULONG                         uiObjectNameLen = wcslen(wcsObjectName) * sizeof(WCHAR) ;

    PAGED_CODE();


    DebugTrace(TRACE_PROC_ENTER,("USDestroySymbolicLink: Enter..\n"));

    //
    // Delete the symbolic link to this device.
    //

    IoDeleteSymbolicLink( &(pde -> SymbolicLinkName) );

    //
    // Remove the CreateFile name from the s/w key, if it's created by this device object.
    //

    Status = IoOpenDeviceRegistryKey( pde -> pPhysicalDeviceObject,
                                      PLUGPLAY_REGKEY_DRIVER,
                                      KEY_ALL_ACCESS,
                                      &hSwKey);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_ERROR,("USDestroySymbolicLink: ERROR!! IoOpenDeviceRegistryKey Failed\n"));
        DEBUG_BREAKPOINT();
        goto USDestroySymbolicLink_return;
    }

    RtlInitUnicodeString(&uName,USBSCAN_REG_CREATEFILE); // L"CreateFileName"
    memset(aName, 0, sizeof(aName));
    RtlInitAnsiString(&ansiName, aName);
    Status = RtlAnsiStringToUnicodeString(&uName2, &ansiName, TRUE);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_CRITICAL,("USDestroySymbolicLink: ERROR!! Cannot allocate buffer for Unicode srting\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USDestroySymbolicLink_return;
    }

    //
    // Check if this CreateFile name is created by this device object.
    //

    //
    // Query CreateFile name from the registry.
    //

    ulBufLength = sizeof(wsCreateFileName);
    Status = ZwQueryValueKey(hSwKey,
                             &uName,
                             KeyValuePartialInformation,
                             (PVOID)wsCreateFileName,
                             ulBufLength,
                             &ulRetLength);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_ERROR,("USDestroySymbolicLink: ERROR!! Cannot query registry.\n"));
        RtlFreeUnicodeString( &uName2 );
        uName2.Buffer = NULL;
        goto USDestroySymbolicLink_return;
    }

    if (NULL != wsCreateFileName){
        DebugTrace(TRACE_STATUS,("USDestroySymbolicLink: CreateFileName=%ws, DeviceInstance=%d.\n",
                                    ((PKEY_VALUE_PARTIAL_INFORMATION)wsCreateFileName)->Data,
                                    pde -> DeviceInstance));

        //
        // Get instance number of CreteFile name.
        //

        pvNumber = wcsstr((const wchar_t *)((PKEY_VALUE_PARTIAL_INFORMATION)wsCreateFileName)->Data, wcsObjectName);
        if(NULL != pvNumber){

            //
            //  Move pointer forward. (sizeof(L"\\\\.\\Usbscan") == 22)
            //

//            if( ((PKEY_VALUE_PARTIAL_INFORMATION)wsCreateFileName)->DataLength > sizeof(wcsObjectName) ){
//              (PCHAR)pvNumber += sizeof(wcsObjectName);

            if( ((PKEY_VALUE_PARTIAL_INFORMATION)wsCreateFileName)->DataLength > uiObjectNameLen ){
                (PCHAR)pvNumber += uiObjectNameLen;
            } else {
                DebugTrace(TRACE_ERROR,("USDestroySymbolicLink: ERROR!! CreateFile name too short.\n"));
                RtlFreeUnicodeString( &uName2 );
                uName2.Buffer = NULL;
                ZwClose(hSwKey);
                goto USDestroySymbolicLink_return;
            }

            //
            // Translate X of UsbscanX to integer.
            //

            RtlInitUnicodeString(&uNumber, pvNumber);
            Status = RtlUnicodeStringToInteger(&uNumber,
                                               10,
                                               &ulNumber);
            if(STATUS_SUCCESS != Status){
                DebugTrace(TRACE_ERROR,("USDestroySymbolicLink: ERROR!! RtlUnicodeStringToInteger failed.\n"));
                RtlFreeUnicodeString( &uName2 );
                uName2.Buffer = NULL;
                ZwClose(hSwKey);
                goto USDestroySymbolicLink_return;
            }

            //
            // See if this CreateFile name is made by this instance.
            //

            if(ulNumber == pde -> DeviceInstance){

                //
                // Delete CreateFile name in the registry.
                //

                DebugTrace(TRACE_STATUS,("USDestroySymbolicLink: Deleting %ws%d\n",
                                            wcsObjectName,
                                            ulNumber));
                ZwSetValueKey(hSwKey,&uName,0,REG_SZ,uName2.Buffer,uName2.Length);
            } else {

                //
                // CreateFile name is created by other instance.
                //

                DebugTrace(TRACE_STATUS,("USDestroySymbolicLink: CreateFile name is created by other instance.\n"));
            }
        } else { // (NULL != pvNumber)

            //
            // "Usbscan" was not found in CreateFile name.
            //

            DebugTrace(TRACE_WARNING,("USDestroySymbolicLink: WARNING!! Didn't find \"Usbscan\" in CreateFileName\n"));
        }
    } else { // (NULL != wsCreateFileName)

        //
        // Query CreateFile name returned NULL.
        //

        DebugTrace(TRACE_WARNING,("USDestroySymbolicLink: WARNING!! CreateFileName=NULL\n"));
    }

    //
    // Free allocated memory.
    //

    RtlFreeUnicodeString( &uName2 );

    //
    // Close registry.
    //

    ZwClose(hSwKey);


USDestroySymbolicLink_return:

    //
    // Free allocated string buffer in DeviceObject.
    //

    RtlFreeUnicodeString( &(pde -> SymbolicLinkName) );

    DebugTrace(TRACE_PROC_LEAVE,("USDestroySymbolicLink: Leaving.. Status = 0x%x\n",Status));
    return Status;

} // end USDestroySymbolicLink()


NTSTATUS
USGetUSBDeviceDescriptor(
    IN PDEVICE_OBJECT pDeviceObject
)
/*++

Routine Description:
   Retrieves the USB device descriptor and stores it in the device
   extension. This descriptor contains product info and
   endpoint 0 (default pipe) info.

Arguments:
    pDeviceObject - pointer to device object

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    PUSBSCAN_DEVICE_EXTENSION   pde;
    NTSTATUS                    Status;
    PUSB_DEVICE_DESCRIPTOR      pDeviceDescriptor;
    PURB                        pUrb;
    ULONG                       siz;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USGetUSBDeviceDescriptor: Enter..\n"));

    pde = pDeviceObject->DeviceExtension;

    //
    // Allocate pool for URB.
    //

    pUrb = USAllocatePool(NonPagedPool,
                          sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USGetUSBDeviceDescriptor: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USGetUSBDeviceDescriptor_return;
    }

    //
    // Allocate pool for Descriptor.
    //

    siz = sizeof(USB_DEVICE_DESCRIPTOR);
    pDeviceDescriptor = USAllocatePool(NonPagedPool, siz);

    if (NULL == pDeviceDescriptor) {
        DebugTrace(TRACE_CRITICAL,("USGetUSBDeviceDescriptor: ERROR!! cannot allocated device descriptor\n"));
        DEBUG_BREAKPOINT();
        USFreePool(pUrb);
        pUrb = NULL;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USGetUSBDeviceDescriptor_return;
    }

    //
    // Do Macro to set parameter for GetDescriptor to URB.
    //

    UsbBuildGetDescriptorRequest(pUrb,
                                 (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                 USB_DEVICE_DESCRIPTOR_TYPE,
                                 0,
                                 0,
                                 pDeviceDescriptor,
                                 NULL,
                                 siz,
                                 NULL);

    //
    // Call down.
    //

    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

#if DBG
    //DEBUG_BREAKPOINT();
    if (USBSCAN_PnPTest) {
        Status = STATUS_UNSUCCESSFUL;
    }
#endif

    if (STATUS_SUCCESS == Status) {

        //
        // Show device descriptor.
        //

        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: Device Descriptor = %x, len %x\n",
                                   pDeviceDescriptor,
                                   pUrb->UrbControlDescriptorRequest.TransferBufferLength));

        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: USBSCAN Device Descriptor:\n"));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: -------------------------\n"));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bLength            %d\n",   pDeviceDescriptor -> bLength));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bDescriptorType    0x%x\n", pDeviceDescriptor -> bDescriptorType));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bcdUSB             0x%x\n", pDeviceDescriptor -> bcdUSB));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bDeviceClass       0x%x\n", pDeviceDescriptor -> bDeviceClass));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bDeviceSubClass    0x%x\n", pDeviceDescriptor -> bDeviceSubClass));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bDeviceProtocol    0x%x\n", pDeviceDescriptor -> bDeviceProtocol));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bMaxPacketSize0    0x%x\n", pDeviceDescriptor -> bMaxPacketSize0));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: idVendor           0x%x\n", pDeviceDescriptor -> idVendor));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: idProduct          0x%x\n", pDeviceDescriptor -> idProduct));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bcdDevice          0x%x\n", pDeviceDescriptor -> bcdDevice));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: iManufacturer      0x%x\n", pDeviceDescriptor -> iManufacturer));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: iProduct           0x%x\n", pDeviceDescriptor -> iProduct));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: iSerialNumber      0x%x\n", pDeviceDescriptor -> iSerialNumber));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bNumConfigurations 0x%x\n", pDeviceDescriptor -> bNumConfigurations));

        //
        // Save pointer to device descriptor in our device extension
        //

        pde -> pDeviceDescriptor = pDeviceDescriptor;

    } else { // (STATUS_SUCCESS == Status)

        //
        // Error returned from lower driver.
        //

        DebugTrace(TRACE_ERROR,("USGetUSBDeviceDescriptor: ERROR!! Cannot get device descriptor. (%x)\n", Status));
        USFreePool(pDeviceDescriptor);
        pDeviceDescriptor = NULL;
    } // (STATUS_SUCCESS == Status)

    USFreePool(pUrb);
    pUrb = NULL;

USGetUSBDeviceDescriptor_return:

    DebugTrace(TRACE_PROC_LEAVE,("USGetUSBDeviceDescriptor: Leaving.. Status = 0x%x\n", Status));
    return Status;
} // end USGetUSBDeviceDescriptor()



NTSTATUS
USDeferIrpCompletion(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
)
/*++

Routine Description:
    This routine is called when the port driver completes an IRP.

Arguments:

    pDeviceObject - Pointer to the device object for the class device.
    pIrp - Irp completed.
    Context - Driver defined context.

Return Value:
    The function value is the final status from the operation.

--*/
{
    PKEVENT pEvent = Context;

    DebugTrace(TRACE_PROC_ENTER,("USDeferIrpCompletion: Enter..\n"));
    KeSetEvent(pEvent, 1, FALSE);
    DebugTrace(TRACE_PROC_LEAVE,("USDeferIrpCompletion: Leaving.. Status = STATUS_MORE_PROCESSING_REQUIRED\n"));
    return STATUS_MORE_PROCESSING_REQUIRED;

} // end USDeferIrpCompletion()


VOID
USIncrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUSBSCAN_DEVICE_EXTENSION  pde;

    DebugTrace(TRACE_PROC_ENTER,("USIncrementIoCount: Enter..\n"));

    pde = (PUSBSCAN_DEVICE_EXTENSION)(pDeviceObject -> DeviceExtension);
    ASSERT((LONG)pde -> PendingIoCount >= 0);
    InterlockedIncrement(&pde -> PendingIoCount);

    DebugTrace(TRACE_PROC_LEAVE,("USIncrementIoCount: Leaving.. IoCount=0x%x, Status=VOID\n", pde -> PendingIoCount));

} // end USIncrementIoCount()


LONG
USDecrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUSBSCAN_DEVICE_EXTENSION  pde;
    LONG                        ioCount;

    DebugTrace(TRACE_PROC_ENTER,("USDecrementIoCount: Enter..\n"));

    pde = (PUSBSCAN_DEVICE_EXTENSION)(pDeviceObject -> DeviceExtension);
    ASSERT(pde ->PendingIoCount >= 1);

    ioCount = InterlockedDecrement(&pde -> PendingIoCount);

    if (0 == ioCount) {
        KeSetEvent(&pde -> PendingIoEvent,
                   1,
                   FALSE);
    }

    DebugTrace(TRACE_PROC_LEAVE,("USDecrementIoCount: Leaving.. IoCount(=Ret)=0x%x\n", ioCount));
    return ioCount;
} // end USDecrementIoCount()


NTSTATUS
USBSCAN_CallUSBD(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PURB pUrb
)
/*++

Routine Description:
    Passes a URB to the USBD class driver

Arguments:
    pDeviceObject - pointer to the device object
    pUrb - pointer to Urb request block

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PIRP                        pIrp;
    KEVENT                      eventTimeout;
    IO_STATUS_BLOCK             ioStatus;
    PIO_STACK_LOCATION          pNextStack;
    LARGE_INTEGER               Timeout;
    KEVENT                      eventSync;

    DebugTrace(TRACE_PROC_ENTER,("USBSCAN_CallUSBD: Enter..\n"));

    pde = pDeviceObject -> DeviceExtension;

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&eventTimeout, NotificationEvent, FALSE);
    KeInitializeEvent(&eventSync, SynchronizationEvent, FALSE);

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_SUBMIT_URB,
                pde -> pStackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &eventTimeout,
                &ioStatus);

    if(NULL == pIrp){
        DebugTrace(TRACE_CRITICAL,("USBSCAN_CallUSBD: ERROR!! cannot allocated IRP\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USBSCAN_CallUSBD_return;
    }

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    pNextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(pNextStack != NULL);

    //
    // pass the URB to the USB driver stack
    //

    pNextStack -> Parameters.Others.Argument1 = pUrb;

    //
    // Set completion routine
    //

    IoSetCompletionRoutine(pIrp,
                           USDeferIrpCompletion,
                           &eventSync,
                           TRUE,
                           TRUE,
                           TRUE);

    DebugTrace(TRACE_STATUS,("USBSCAN_CallUSBD: calling USBD\n"));

    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

    DebugTrace(TRACE_STATUS,("USBSCAN_CallUSBD: return from IoCallDriver USBD %x\n", Status));

    if (Status == STATUS_PENDING) {
        DebugTrace(TRACE_STATUS,("USBSCAN_CallUSBD: Wait for single object\n"));

        //
        // Set timeout in case bad device not responding.
        //

        Timeout = RtlConvertLongToLargeInteger(-10*1000*1000*(USBSCAN_TIMEOUT_OTHER));
        Status = KeWaitForSingleObject(
                       &eventSync,
                       Suspended,
                       KernelMode,
                       FALSE,
                       &Timeout);
        if(STATUS_TIMEOUT == Status){

            NTSTATUS    LocalStatus;

            DebugTrace(TRACE_ERROR,("USBSCAN_CallUSBD: ERROR!! call timeout. Now canceling IRP...\n"));

            //
            // Cancel IRP.
            //

            IoCancelIrp(pIrp);

            //
            // Make sure the IRP gets completed.
            //

            LocalStatus = KeWaitForSingleObject(&eventSync,
                                                Suspended,
                                                KernelMode,
                                                FALSE,
                                                NULL);

            DebugTrace(TRACE_STATUS,("USBSCAN_CallUSBD: Canceled status = 0x%x.\n", LocalStatus));

        } else {
            DebugTrace(TRACE_STATUS,("USBSCAN_CallUSBD: Wait for single object, returned 0x%x\n", Status));
        }
    } // if (Status == STATUS_PENDING)

    //
    // Free the IRP.
    //

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

USBSCAN_CallUSBD_return:
    DebugTrace(TRACE_PROC_LEAVE, ("USBSCAN_CallUSBD: Leaving.. URB Status = 0x%x, Status = 0x%x\n",
                                 pUrb -> UrbHeader.Status,
                                 Status));
    return Status;

} // end USBSCAN_CallUSBD()


NTSTATUS
USConfigureDevice(
    IN PDEVICE_OBJECT pDeviceObject
)
/*++

Routine Description:
    Initializes a given instance of the device on the USB and selects the
    configuration.

Arguments:
    pDeviceObject - pointer to the device object

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{

    NTSTATUS                      Status;
    PUSBSCAN_DEVICE_EXTENSION     pde;
    PURB                          pUrb;
    ULONG                         siz;
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor;
    PUSB_INTERFACE_DESCRIPTOR     pInterfaceDescriptor;
    PUSB_ENDPOINT_DESCRIPTOR      pEndpointDescriptor;
    PUSB_COMMON_DESCRIPTOR        pCommonDescriptor;
    PUSBD_INTERFACE_INFORMATION   pInterface;
    UCHAR                         AlternateSetting;
    UCHAR                         InterfaceNumber;
    USHORT                        length;
    ULONG                         i;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USConfigureDevice: Enter..\n"));

    //
    // Initialize local variable.
    //

    pConfigurationDescriptor    = NULL;
    pInterfaceDescriptor        = NULL;
    pEndpointDescriptor         = NULL;
    pCommonDescriptor           = NULL;
    pInterface                  = NULL;
    pUrb                        = NULL;

    siz                 = 0;
    AlternateSetting    = 0;
    InterfaceNumber     = 0;
    length              = 0;

    pde = pDeviceObject -> DeviceExtension;
    Status = STATUS_UNSUCCESSFUL;

    //
    // First configure the device
    //

    pUrb = USAllocatePool(NonPagedPool,
                          sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USConfigureDevice: ERROR!! Can't allocate control descriptor URB.\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USConfigureDevice_return;
    }

    siz = sizeof(USB_CONFIGURATION_DESCRIPTOR);


get_config_descriptor_retry:

    pConfigurationDescriptor = USAllocatePool(NonPagedPool, siz);
    if (NULL == pConfigurationDescriptor) {
        DebugTrace(TRACE_CRITICAL,("USConfigureDevice: ERROR!! Can't allocate configuration descriptor.\n"));
        DEBUG_BREAKPOINT();

        USFreePool(pUrb);
        pUrb = NULL;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USConfigureDevice_return;
    }

    //
    // Initialize buffers by 0
    //

    RtlZeroMemory(pConfigurationDescriptor, siz);
    RtlZeroMemory(pUrb, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    UsbBuildGetDescriptorRequest(pUrb,
                                 (USHORT)sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                 USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                 0,
                                 0,
                                 pConfigurationDescriptor,
                                 NULL,
                                 siz,
                                 NULL);

    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

    DebugTrace(TRACE_STATUS,("USConfigureDevice: URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE Status = %x\n", Status));
    DebugTrace(TRACE_STATUS,("USConfigureDevice: Configuration Descriptor = %x, len = %x\n",
                               pConfigurationDescriptor,
                               pUrb -> UrbControlDescriptorRequest.TransferBufferLength));


    //
    // if we got some data see if it was enough.
    //
    // NOTE: we may get an error in URB because of buffer overrun
    //

    if ( (pUrb -> UrbControlDescriptorRequest.TransferBufferLength > 0) &&
         (pConfigurationDescriptor -> wTotalLength > siz)) {

        DebugTrace(TRACE_WARNING,("USConfigureDevice: WARNING!! Data is incomplete. Fetch descriptor again...\n"));

        siz = pConfigurationDescriptor -> wTotalLength;
        USFreePool(pConfigurationDescriptor);
        pConfigurationDescriptor = NULL;
        goto get_config_descriptor_retry;
    }

    USFreePool(pUrb);
    pUrb = NULL;

    //
    // We have the configuration descriptor for the configuration
    // we want.  Save it in our device extension.
    //

    pde -> pConfigurationDescriptor = pConfigurationDescriptor;

    //
    // Now we issue the select configuration command to get
    // the pipes associated with this configuration.
    //

    pUrb = USCreateConfigurationRequest(pConfigurationDescriptor, &length);
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USConfigureDevice: ERROR!! Can't allocate select configuration urb.\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USConfigureDevice_return;
    }

    //
    // Get the Interface descriptors.
    //

    pInterfaceDescriptor = USBD_ParseConfigurationDescriptorEx(pConfigurationDescriptor,
                                                               pConfigurationDescriptor,
                                                               -1,
                                                               0,
                                                               -1,
                                                               -1,
                                                               -1);

    if(NULL == pInterfaceDescriptor){
        DebugTrace(TRACE_CRITICAL,("USConfigureDevice: ERROR!! Can't get Interface descriptor.\n"));
        USFreePool(pUrb);
        pUrb = NULL;
        Status = STATUS_UNSUCCESSFUL;
        goto USConfigureDevice_return;
    }

    //
    // Get the Endpoint descriptors.
    //

    pCommonDescriptor = USBD_ParseDescriptors(pConfigurationDescriptor,
                                              pConfigurationDescriptor->wTotalLength,
                                              pInterfaceDescriptor,
                                              USB_ENDPOINT_DESCRIPTOR_TYPE);
    if(NULL == pCommonDescriptor){
        DebugTrace(TRACE_CRITICAL,("USConfigureDevice: ERROR!! Can't get Endpoint descriptor.\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto USConfigureDevice_return;
    }

    ASSERT(USB_ENDPOINT_DESCRIPTOR_TYPE == pCommonDescriptor->bDescriptorType);
    pEndpointDescriptor = (PUSB_ENDPOINT_DESCRIPTOR)pCommonDescriptor;

    //
    // save these pointers is our device extension.
    //

    pde -> pInterfaceDescriptor = pInterfaceDescriptor;
    pde -> pEndpointDescriptor  = pEndpointDescriptor;

    //
    // Set the max transfer size for each BULK endpoint to 64K.
    // Also, search through the set of endpoints and find the pipe index for our
    // bulk-in, interrupt, and optionally bulk-out pipes.
    //

    pde -> IndexBulkIn    = -1;
    pde -> IndexBulkOut   = -1;
    pde -> IndexInterrupt = -1;

    pInterface = &(pUrb -> UrbSelectConfiguration.Interface);

    for (i=0; i < pInterfaceDescriptor -> bNumEndpoints; i++) {

        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: End point[%d] descriptor\n", i));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: bLength          : 0x%X\n", pEndpointDescriptor[i].bLength));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: bDescriptorType  : 0x%X\n", pEndpointDescriptor[i].bDescriptorType));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: bEndpointAddress : 0x%X\n", pEndpointDescriptor[i].bEndpointAddress));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: bmAttributes     : 0x%X\n", pEndpointDescriptor[i].bmAttributes));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: wMaxPacketSize   : 0x%X\n", pEndpointDescriptor[i].wMaxPacketSize));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: bInterval        : 0x%X\n", pEndpointDescriptor[i].bInterval));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: \n"));

        if (USB_ENDPOINT_TYPE_BULK == pEndpointDescriptor[i].bmAttributes) {
            pInterface -> Pipes[i].MaximumTransferSize = 64*1024;
            if (pEndpointDescriptor[i].bEndpointAddress & BULKIN_FLAG) {    // if input endpoint
                pde -> IndexBulkIn = i;
            } else {
                pde -> IndexBulkOut = i;
            }
        } else if (USB_ENDPOINT_TYPE_INTERRUPT == pEndpointDescriptor[i].bmAttributes) {
            pde -> IndexInterrupt = i;
        }
    }

    //
    // Select the default configuration.
    //

    UsbBuildSelectConfigurationRequest(pUrb, length, pConfigurationDescriptor);
    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);
    if (STATUS_SUCCESS != Status) {
        DebugTrace(TRACE_ERROR,("USConfigureDevice: ERROR!! Selecting default configuration. Status = %x\n", Status));

        USFreePool(pUrb);
        pUrb = NULL;
        Status = STATUS_IO_DEVICE_ERROR;
        goto USConfigureDevice_return;
    }

    //
    // Save the configuration handle in our device extension.
    //

    pde -> ConfigurationHandle = pUrb -> UrbSelectConfiguration.ConfigurationHandle;

    //
    // Insure that this device won't overflow our PipeInfo structure.
    //

    if (pInterfaceDescriptor -> bNumEndpoints > MAX_NUM_PIPES) {
        DebugTrace(TRACE_ERROR,("USConfigureDevice: ERROR!! Too many endpoints for this driver! # endpoints = %d\n",
                                    pInterfaceDescriptor -> bNumEndpoints));
//        DEBUG_BREAKPOINT();
        USFreePool(pUrb);
        pUrb = NULL;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USConfigureDevice_return;
    }

    //
    // Save pipe configurations in our device extension
    //

    pde -> NumberOfPipes = pInterfaceDescriptor -> bNumEndpoints;

    for (i=0; i < pInterfaceDescriptor -> bNumEndpoints; i++) {
        pde -> PipeInfo[i] = pInterface -> Pipes[i];

        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: Pipe[%d] information\n", i));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: MaximumPacketSize : 0x%X\n", pde -> PipeInfo[i].MaximumPacketSize));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: EndpointAddress   : 0x%X\n", pde -> PipeInfo[i].EndpointAddress));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: Interval          : 0x%X\n", pde -> PipeInfo[i].Interval));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: PipeType          : 0x%X\n", pde -> PipeInfo[i].PipeType));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: PipeHandle        : 0x%X\n", pde -> PipeInfo[i].PipeHandle));

        //
        // Initialize the read pipe buffer if type is Bulk-In.
        //

        if( (pde->PipeInfo[i].PipeType == UsbdPipeTypeBulk)
         && (pde->PipeInfo[i].EndpointAddress & BULKIN_FLAG) )
        {

            DebugTrace(TRACE_STATUS,("USConfigureDevice: Alocates buffer for Pipe[%d]\n", i));

            pde -> ReadPipeBuffer[i].RemainingData = 0;
            pde -> ReadPipeBuffer[i].pBuffer = USAllocatePool(NonPagedPool, 2 * (pde -> PipeInfo[i].MaximumPacketSize));
            if (NULL == pde -> ReadPipeBuffer[i].pBuffer) {
                DebugTrace(TRACE_CRITICAL,("USConfigureDevice: Cannot allocate bulk-in buffer.\n"));
                DEBUG_BREAKPOINT();
                Status = STATUS_INSUFFICIENT_RESOURCES;
                USFreePool(pUrb);
                pUrb = NULL;
                goto USConfigureDevice_return;
            }
            pde -> ReadPipeBuffer[i].pStartBuffer = pde -> ReadPipeBuffer[i].pBuffer;
        } else {
            pde -> ReadPipeBuffer[i].pBuffer = NULL;
        }
    }

    USFreePool(pUrb);
    pUrb = NULL;

USConfigureDevice_return:
    DebugTrace(TRACE_PROC_LEAVE,("USConfigureDevice: Leaving.. Status = %x\n", Status));
    return Status;
} // USConfigureDevice()


NTSTATUS
USUnConfigureDevice(
    IN PDEVICE_OBJECT pDeviceObject
)
/*++

Routine Description:

Arguments:
    pDeviceObject - pointer to the device object

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                      Status;
    PURB                          pUrb;
    ULONG                         siz;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USUnConfigureDevice: Enter..\n"));

    siz = sizeof(struct _URB_SELECT_CONFIGURATION);
    pUrb = USAllocatePool(NonPagedPool, siz);
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USUnConfigureDevice: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USUnConfigureDevice_return;
    }
    RtlZeroMemory(pUrb, siz);

    //
    // Send the select configuration urb with a NULL pointer for the configuration
    // handle, this closes the configuration and puts the device in the 'unconfigured'
    // state.
    //

    UsbBuildSelectConfigurationRequest(pUrb, (USHORT)siz, NULL);
    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);
    DebugTrace(TRACE_STATUS,("USUnConfigureDevice: Device Configuration Closed status = %x usb status = %x.\n",
                               Status, pUrb->UrbHeader.Status));

    USFreePool(pUrb);
    pUrb = NULL;

USUnConfigureDevice_return:
    DebugTrace(TRACE_PROC_LEAVE,("USUnConfigureDevice: Leaving.. Status = %x\n", Status));
    return Status;
} // USUnConfigureDevice()

NTSTATUS
USGetDeviceCapability(
    IN PUSBSCAN_DEVICE_EXTENSION    pde
    )
/*++

Routine Description:

Arguments:
    pDeviceObject - pointer to the device object

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                Status;
    PIRP                    pIrp;
    PIO_STACK_LOCATION      pIrpStack;
    KEVENT                  Event;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USGetDeviceCapability: Enter..\n"));

    //
    // Initialize local.
    //

    Status      = STATUS_SUCCESS;
    pIrp        = NULL;
    pIrpStack   = NULL;
    
    //
    // Allocate Irp.
    //
    
    pIrp = IoAllocateIrp(pde->pStackDeviceObject->StackSize, FALSE);
    if(NULL == pIrp){
        DebugTrace(TRACE_WARNING,("USUnConfigureDevice: ERROR!! Unable to allocate Irp.\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USGetDeviceCapability_return;
    } // if(NULL == pIrp)
    
    //
    // Get next stack location of the allocated IRP.
    //
    
    pIrpStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(NULL != pIrpStack);
    
    //
    // Initialize required fields.
    //

    RtlZeroMemory(&pde->DeviceCapabilities, sizeof(DEVICE_CAPABILITIES));
    pde->DeviceCapabilities.Size     = sizeof(DEVICE_CAPABILITIES);
    pde->DeviceCapabilities.Version  = 1;
    pde->DeviceCapabilities.Address  = -1;
    pde->DeviceCapabilities.UINumber = -1;

    //
    // Set required parameters.
    //
    
    pIrpStack->MajorFunction = IRP_MJ_PNP;
    pIrpStack->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
    pIrpStack->Parameters.DeviceCapabilities.Capabilities = &pde->DeviceCapabilities;
    
    pIrp->IoStatus.Status       = STATUS_NOT_SUPPORTED;
    pIrp->IoStatus.Information  = 0;
    
    //
    // Initialize synchronization.
    //

    KeInitializeEvent(&Event,
                      SynchronizationEvent,
                      FALSE);

    //
    // Set completion routine
    //

    IoSetCompletionRoutine(pIrp,
                           USDeferIrpCompletion,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // Call down
    //

    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);
    if(Status == STATUS_PENDING){

        //
        // Waiting for the completion.
        //

        DebugTrace(TRACE_STATUS,("USGetDeviceCapability: STATUS_PENDING. Wait for completion.\n"));
        KeWaitForSingleObject(&Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        Status = pIrp -> IoStatus.Status;
    } // if(Status == STATUS_PENDING)

    //
    // See if device is capable for remote wake.
    //

    if(NT_SUCCESS(Status)){
        if(PowerDeviceD0 != pde->DeviceCapabilities.DeviceWake){

            //
            // Remote wake isn't supported on this device.
            //

            pde->bEnabledForWakeup = TRUE;
        } // if(PowerDeviceD0 == pCaps->DeviceWake)
    } // if(NT_SUCCESS(Status))

    //
    // Free allocated Irp.
    //
    
    IoFreeIrp(pIrp);
    pIrp = NULL;

USGetDeviceCapability_return:
    DebugTrace(TRACE_PROC_LEAVE,("USGetDeviceCapability: Leaving.. Status = %x\n", Status));
    return Status;
} // USGetDeviceCapability()


VOID
USUnload(
    IN PDRIVER_OBJECT pDriverObject
)
/*++

   Routine Description:
   Unload routine. The routine is called when the driver is unloaded.
   Release every resource allocated in relation with the driver object.

   Arguments:
   pDriverObject - pointer to the driver object

   Return Value:
   None

   -- */
{
    PAGED_CODE();

    DebugTrace((MIN_TRACE | TRACE_FLAG_PROC),("UsbScanUnload(0x%X);\n", pDriverObject));

} // end USUnload()


NTSTATUS
USCallNextDriverSynch(
    IN PUSBSCAN_DEVICE_EXTENSION  pde,
    IN PIRP              pIrp
)
/*++

Routine Description:

    Calls lower driver and waits for result

Arguments:

    DeviceExtension - pointer to device extension
    Irp - pointer to IRP

Return Value:

    none.

--*/
{
    KEVENT          Event;
    PIO_STACK_LOCATION IrpStack;
    NTSTATUS        Status;

    DebugTrace(TRACE_PROC_ENTER,("USCallNextDriverSynch: Enter..\n"));

    IrpStack = IoGetCurrentIrpStackLocation(pIrp);

    //
    // Copy IRP stack to the next.
    //

    IoCopyCurrentIrpStackLocationToNext(pIrp);

    //
    // Initialize synchronizing event.
    //

    KeInitializeEvent(&Event,
                      SynchronizationEvent,
                      FALSE);

    //
    // Set completion routine
    //

    IoSetCompletionRoutine(pIrp,
                           USDeferIrpCompletion,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // Call down
    //

    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

    if (Status == STATUS_PENDING) {

        //
        // Waiting for the completion.
        //

        DebugTrace(TRACE_STATUS,("USCallNextDriverSynch: STATUS_PENDING. Wait for event.\n"));
        KeWaitForSingleObject(&Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        Status = pIrp -> IoStatus.Status;
    }

    //
    // Return
    //

    DebugTrace(TRACE_PROC_LEAVE,("USCallNextDriverSynch: Leaving.. Status = %x\n", Status));
    return (Status);
}

NTSTATUS
UsbScanHandleInterface(
    PDEVICE_OBJECT      DeviceObject,
    PUNICODE_STRING     InterfaceName,
    BOOLEAN             Create
    )
/*++

Routine Description:

Arguments:

    DeviceObject    - Supplies the device object.

Return Value:

    None.

--*/
{

    NTSTATUS           Status;

    DebugTrace(TRACE_PROC_ENTER,("UsbScanHandleInterface: Enter..\n"));

    Status = STATUS_SUCCESS;

#ifndef _CHICAGO_

    if (Create) {

        Status=IoRegisterDeviceInterface(
            DeviceObject,
            &GUID_DEVINTERFACE_IMAGE,
            NULL,
            InterfaceName
            );
        DebugTrace(TRACE_STATUS,("Called IoRegisterDeviceInterface . Returned=0x%X\n",Status));

        if (NT_SUCCESS(Status)) {

            IoSetDeviceInterfaceState(
                InterfaceName,
                TRUE
                );

            DebugTrace(TRACE_STATUS,("Called IoSetDeviceInterfaceState(TRUE) . \n"));
        }
    } else {

        if (InterfaceName->Buffer != NULL) {

            Status = IoSetDeviceInterfaceState(
                        InterfaceName,
                        FALSE
                        );

            RtlFreeUnicodeString(
                InterfaceName
                );

            InterfaceName->Buffer = NULL;
        }
    }

#endif // !_CHICAGO_

    DebugTrace(TRACE_PROC_LEAVE,("IoRegisterDeviceInterface: Leaving... Status=0x%X\n",Status));
    return Status;

}

BOOLEAN
USArmForWake(
    PUSBSCAN_DEVICE_EXTENSION   pde,
    POWER_STATE                 SystemState
    )
/*++

Routine Description:
    Arm device for remote wakeup.

Arguments:
    pde - pointer to device extension

Return Value:
    STATUS_SUCCESS if successful,

--*/
{
    BOOLEAN     bRet;
    LONG        OldWakeState;
    NTSTATUS    status;

    DebugTrace(TRACE_PROC_ENTER,("USArmForWake: Enter..\n"));

    //
    // Initialize local.
    //

    bRet            = FALSE;
    status          = STATUS_SUCCESS;
    OldWakeState    = WAKESTATE_DISARMED;

    //
    // See if device/system supports wakeup.
    //

    if(TRUE != pde->bEnabledForWakeup){
        DebugTrace(TRACE_STATUS,("USArmForWake: This device or system doesn't support RemoteWake.\n"));
        bRet = FALSE;
        goto USArmForWake_return;
    } // if(TRUE != pde->bEnabledForWakeup)

    //
    // Make sure about curent state.
    //

    while(1){
        // Try to move us into the arming state
        OldWakeState = InterlockedCompareExchange(&pde->WakeState,
                                                  WAKESTATE_WAITING,
                                                  WAKESTATE_DISARMED);
        if(WAKESTATE_DISARMED == OldWakeState){
            break;
        } // if(OldWakeState == WAKESTATE_DISARMED)


        if( (WAKESTATE_ARMED   == OldWakeState)
         || (WAKESTATE_WAITING == OldWakeState) )
        {
            // The device is already armed.
            DebugTrace(TRACE_STATUS,("USArmForWake: Device is already armed for wake\n"));
            bRet = TRUE;
            goto USArmForWake_return;
        }

        // Wait for the previous wait-wake IRP to finish
        DebugTrace(TRACE_STATUS,("USArmForWake: Wait for previous wake IRP to complete.\n"));
        USDisarmWake(pde);
    } // while(1)

    // The state just got moved to WAKESTATE_WAITING. First ensure the previous
    // WaitWake IRP has finished

    KeWaitForSingleObject(&pde->WakeCompletedEvent,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    //
    // Request the power IRP, STATUS_PENDING is success
    //

    status = PoRequestPowerIrp(pde->pStackDeviceObject,
                               IRP_MN_WAIT_WAKE,
                               SystemState,
                               USWaitWakePoCompletionRoutine,
                               (PVOID)pde,
                               NULL );
    if(!NT_SUCCESS(status)){

        //
        // IRP_MN_WAIT_WAKE didn't succeed. Possiblly lower stack doesn't support.
        //

        DebugTrace(TRACE_WARNING,("USArmForWake: WARNING!! IRP_MN_WAIT_WAKE failed. Statust=0x%x.\n", status));

        pde->WakeState = WAKESTATE_DISARMED;
        KeSetEvent(&pde->WakeCompletedEvent,
                   IO_NO_INCREMENT,
                   FALSE);
    } // if(!NT_SUCCESS(status))

    bRet = (status == STATUS_PENDING);

USArmForWake_return:
    DebugTrace(TRACE_PROC_LEAVE,("USArmForWake: Leaving.. Ret=0x%x\n", bRet));
    return bRet;

} // USArmForWake()


VOID
USDisarmWake(
    PUSBSCAN_DEVICE_EXTENSION  pde
    )
{
    LONG    oldWakeState;

    DebugTrace(TRACE_PROC_ENTER,("USDisarmWake: Enter...\n"));

    //
    // See if device/system supports wakeup.
    //

    if(TRUE != pde->bEnabledForWakeup){
        DebugTrace(TRACE_STATUS,("USDisarmWake: This device or system doesn't support RemoteWake.\n"));
        goto USDisarmWake_return;
    } // if(TRUE != pde->bEnabledForWakeup)

    // Go from WAKESTATE_WAITING to WAKESTATE_WAITING_CANCELLED, or
    //         WAKESTATE_ARMED   to WAKESTATE_ARMING_CANCELLED, or
    // stay in WAKESTATE_DISARMED or WAKESTATE_COMPLETING

    oldWakeState = MyInterlockedOr(&pde->SpinLock, 
                                   &pde->WakeState, 
                                   1);

    if(WAKESTATE_ARMED == oldWakeState){
        DebugTrace(TRACE_STATUS,("USDisarmWake: Currently armed, canceling WaitWakeIRP...\n"));
        ASSERT(NULL != pde->pWakeIrp);

        IoCancelIrp(pde->pWakeIrp);

        //
        // Now that wefve cancelled the IRP, try to give back ownership
        // to the completion routine by restoring the WAKESTATE_ARMED state
        //


        //
        // Note: Check again here to make sure there's no "Dangerous moment"
        //

        oldWakeState = InterlockedCompareExchange(&pde->WakeState,
                                                  WAKESTATE_ARMED,
                                                  WAKESTATE_ARMING_CANCELLED);
        if(WAKESTATE_COMPLETING == oldWakeState){

            //
            // We didnft give back control of IRP in time, so we own it now.
            //

            IoCompleteRequest(pde->pWakeIrp, IO_NO_INCREMENT);
        } // if(WAKESTATE_COMPLETING == oldWakeState)
    } // if(WAKESTATE_ARMED == oldWakeState)

USDisarmWake_return:

    DebugTrace(TRACE_PROC_LEAVE,("USDisarmWake: Leaving.. Ret=VOID.\n"));
} // USDisarmWake()


VOID
USWaitWakePoCompletionRoutine(
    PDEVICE_OBJECT      pDeviceObject,
    UCHAR               MinorFunction,
    POWER_STATE         State,
    PVOID               pContext,
    PIO_STATUS_BLOCK    pIoStatus
    )
/*++

Routine Description:
    Completion routine for WaitWait IRP.
--*/
{
    PUSBSCAN_DEVICE_EXTENSION pde;

    DebugTrace(TRACE_PROC_ENTER,("USWaitWakePoCompletionRoutine: Enter...\n"));

    pde = (PUSBSCAN_DEVICE_EXTENSION) pContext;

    //
    // WaitWakeIRP has been freed.
    //

    pde->pWakeIrp   = NULL;
    pde->WakeState  = WAKESTATE_DISARMED;

    //
    // Adjust synchronization event so another Wait-Wake can get queued
    //

    KeSetEvent(&pde->WakeCompletedEvent,
               IO_NO_INCREMENT,
               FALSE);

    if(NT_SUCCESS(pIoStatus->Status)){
        DebugTrace(TRACE_STATUS,("USWaitWakePoCompletionRoutine: Wakeup succeeded. Queue rearm callback.\n"));

        
        //
        // WaitWakeIRP has been completed successfully. Rearming for next wakeup.
        //

        USQueuePassiveLevelCallback(pde->pOwnDeviceObject,
                                    USPassiveLevelReArmCallbackWorker);

    } else if(  (STATUS_UNSUCCESSFUL        == pIoStatus->Status)
             || (STATUS_NOT_IMPLEMENTED     == pIoStatus->Status)
             || (STATUS_POWER_STATE_INVALID == pIoStatus->Status)
             || (STATUS_NOT_SUPPORTED       == pIoStatus->Status) )
    {
        //
        // Remote wakeup isn't supported on this bus/device.
        //

        DebugTrace(TRACE_STATUS,("USWaitWakePoCompletionRoutine: RemoteWake isn't supported. Ret=VOID.\n"));
        pde -> bEnabledForWakeup = FALSE;

    }  else { 
        DebugTrace(TRACE_STATUS,("USWaitWakePoCompletionRoutine: Wakeup didn't succeed.(0x%x).\n", pIoStatus->Status));
    }

    DebugTrace(TRACE_PROC_LEAVE,("USWaitWakePoCompletionRoutine: Leaving.. Ret=VOID.\n"));
    return;
} // USWaitWakePoCompletionRoutine()

VOID
USInitializeWakeState(
    PUSBSCAN_DEVICE_EXTENSION  pde
    )
/*++

Routine Description:
    Initialize wake state.

Arguments:
    pde - pointer to device extension

Return Value:
    none.

--*/
{

    pde->WakeState  = WAKESTATE_DISARMED;
    pde->pWakeIrp   = NULL;

    //
    // Initialize event for sync.
    //

    KeInitializeEvent(&pde->WakeCompletedEvent,
                      SynchronizationEvent,
                      TRUE);
} // USArmDevice()

VOID
USQueuePassiveLevelCallback(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIO_WORKITEM_ROUTINE pCallbackFunction
    )
/*++

Routine Description:

    This routine queues a passive level callback if it's called
    at DISPATCH_LEVEL otherwise calls the worker routine directly.

Arguments:

   DeviceObject - pointer to a device extenion.

   CallbackFunction - Function to invoke when at PASSIVE_LEVEL.

Return Value:

--*/
{
    PIO_WORKITEM            item;


    DebugTrace(TRACE_PROC_ENTER,("USQueuePassiveLevelCallback: Enter...\n"));

    //
    // If the current IRQL level is not DISPATCH_LEVEL, we will call the
    // CallbackFunction directly without queuing a workitem.
    //

    if(KeGetCurrentIrql() != DISPATCH_LEVEL) {
        (*pCallbackFunction)(pDeviceObject, NULL);
    } else { // if(KeGetCurrentIrql() != DISPATCH_LEVEL)

        //
        // Allocate a workitem and queue it for passive level processing.
        //

        item = IoAllocateWorkItem(pDeviceObject);
        if(NULL != item){
            IoQueueWorkItem(item,
                            pCallbackFunction,
                            DelayedWorkQueue,
                            item
                            );
        } else { // if(NULL != item)

            DebugTrace(TRACE_WARNING,("USQueuePassiveLevelCallback: WARNING!! IoAllocateWorkItem() failed, running out of resource.\n"));
        } // else(NULL != item)
    } // else(KeGetCurrentIrql() != DISPATCH_LEVEL)

    DebugTrace(TRACE_PROC_LEAVE,("USQueuePassiveLevelCallback: Leaving.. Ret=VOID.\n"));

} // USQueuePassiveLevelCallback()

VOID
USPassiveLevelReArmCallbackWorker(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PVOID            pContext
    )
{
    PUSBSCAN_DEVICE_EXTENSION   pde;
    POWER_STATE                 PowerState;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USPassiveLevelReArmCallbackWorker: Enter...\n"));

    pde = pDeviceObject->DeviceExtension;

    //
    // Rearm for wake.
    //

    PowerState.SystemState = pde -> DeviceCapabilities.SystemWake;
    USArmForWake(pde, PowerState);

    if(NULL != pContext){
        IoFreeWorkItem((PIO_WORKITEM)pContext);
    } // if(Context)

    DebugTrace(TRACE_PROC_LEAVE,("USPassiveLevelReArmCallbackWorker: Leaving.. Ret=VOID.\n"));

} // USPassiveLevelReArmCallbackWorker()


LONG
MyInterlockedOr(
    PKSPIN_LOCK     pSpinLock,
    LONG volatile   *Destination,
    LONG            Value
    )
{

    KIRQL   OldIrql;
    LONG    lOldValue;
    
    //
    // Acquire spinlock to access shared resource, going into IRQL_DISPATCH_LEVEL.
    //
    
    KeAcquireSpinLock(pSpinLock, &OldIrql);
    
    //
    // Save old value;
    //
    
    lOldValue = *Destination;
    
    //
    // Or Value to the destination.
    //
    
    *Destination |= Value;
    
    //
    // Release spinlock and return to the original IRQL.
    //
    
    KeReleaseSpinLock(pSpinLock, OldIrql);

    //
    // Return original value.
    //

    return lOldValue;

} // MyInterlockedOr()


NTSTATUS
UsbScanReadDeviceRegistry(
    IN  PUSBSCAN_DEVICE_EXTENSION   pExtension,
    IN  PCWSTR                      pKeyName,
    OUT PVOID                       *ppvData
    )
/*++

Routine Description:

    This routine open registry for this device and query a value specified
    by key name. This routine allocate non-paged memory and return its pointer.
    Caller must free returned pointer.

Arguments:

    pExtension  - pointer to device extension
    pKeyName    - pointer to a wide string specify key name
    ppvData     - pointer to the queried data pointer allocated by this routine

Return Value:
    STATUS_SUCCESS              - if success,
    STATUS_INVALID_PARAMETER    - if passed argument is invalid,

--*/

{
    NTSTATUS                        Status;
    HANDLE                          hRegKey;
    PVOID                           pvBuffer;
    ULONG                           DataSize;
    PVOID                           pvRetData;
    UNICODE_STRING                  unicodeKeyName;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER, ("UsbScanReadDeviceRegistry: Entering...\n"));

    //
    // Initialize status
    //

    Status = STATUS_SUCCESS;

    hRegKey = NULL;
    pvBuffer = NULL;
    pvRetData = NULL;
    DataSize = 0;

    //
    // Check the arguments
    //

    if( (NULL == pExtension)
     || (NULL == pKeyName)
     || (NULL == ppvData) )
    {
        DebugTrace(TRACE_ERROR, ("UsbScanReadDeviceRegistry: ERROR!! Invalid argument.\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto UsbScanReadDeviceRegistry_return;
    }

    //
    // Open device registry.
    //

    Status = IoOpenDeviceRegistryKey(pExtension->pPhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     KEY_ALL_ACCESS,
                                     &hRegKey);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR, ("UsbScanReadDeviceRegistry: ERROR!! IoOpenDeviceRegistryKey failed.\n"));
        goto UsbScanReadDeviceRegistry_return;
    }

    //
    // Query required size.
    //

    RtlInitUnicodeString(&unicodeKeyName, pKeyName);
    Status = ZwQueryValueKey(hRegKey,
                             &unicodeKeyName,
                             KeyValuePartialInformation,
                             NULL,
                             0,
                             &DataSize);
    if(0 == DataSize){
        if(STATUS_OBJECT_NAME_NOT_FOUND == Status){
            DebugTrace(TRACE_STATUS, ("UsbScanReadDeviceRegistry: Reg-key \"%wZ\" doesn't exist.\n", &unicodeKeyName));
        } else {
            DebugTrace(TRACE_ERROR, ("UsbScanReadDeviceRegistry: ERROR!! Cannot retrieve reqired data size of %wZ. Status=0x%x\n",
                                     &unicodeKeyName ,
                                     Status));
        }
        goto UsbScanReadDeviceRegistry_return;
    }

    //
    // Allocate memory for temp buffer. size +2 for NULL.
    //

    pvBuffer = USAllocatePool(NonPagedPool, DataSize+2);
    if(NULL == pvBuffer){
        DebugTrace(TRACE_CRITICAL, ("UsbScanReadDeviceRegistry: ERROR!! Buffer allocate failed.\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto UsbScanReadDeviceRegistry_return;
    }
    RtlZeroMemory(pvBuffer, DataSize+sizeof(WCHAR));

    //
    // Query specified value.
    //

    DebugTrace(TRACE_STATUS, ("UsbScanReadDeviceRegistry: Query \"%wZ\".\n", &unicodeKeyName));
    Status = ZwQueryValueKey(hRegKey,
                             &unicodeKeyName,
                             KeyValuePartialInformation,
                             pvBuffer,
                             DataSize,
                             &DataSize);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR, ("UsbScanReadDeviceRegistry: ERROR!! ZwQueryValueKey failed. Status=0x%x\n", Status));
        goto UsbScanReadDeviceRegistry_return;
    }

UsbScanReadDeviceRegistry_return:
    if(!NT_SUCCESS(Status)){

        //
        // This routine failed.
        //

        if(pvRetData){
            USFreePool(pvRetData);
        }
        *ppvData = NULL;
    } else {

        //
        // This routine succeeded.
        //

        *ppvData = pvBuffer;
    }

    //
    // Clean-up.
    //

    if(hRegKey){
        ZwClose(hRegKey);
    }
    DebugTrace(TRACE_PROC_LEAVE, ("UsbScanReadDeviceRegistry: Leaving... Status=0x%x\n", Status));
    return Status;
}


NTSTATUS
UsbScanWriteDeviceRegistry(
    IN PUSBSCAN_DEVICE_EXTENSION    pExtension,
    IN PCWSTR                       pKeyName,
    IN ULONG                        Type,
    IN PVOID                        pvData,
    IN ULONG                        DataSize
    )
/*++

Routine Description:

    This routine open registry for this device and set a value specified
    by key name.

Arguments:

    pExtension  - pointer to device extension
    pKeyName    - pointer to a wide string specify key name
    Type        - specifies the type of data to be written
    pvData      - pointer to a caller allocated buffer containing data
    DataSize    - specifies the size in bytes of the data buffer

Return Value:
    STATUS_SUCCESS              - if success,
    STATUS_INVALID_PARAMETER    - if passed argument is invalid,

--*/

{
    NTSTATUS                        Status;
    HANDLE                          hRegKey;
    UNICODE_STRING                  unicodeKeyName;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER, ("UsbScanWriteDeviceRegistry: Entering...\n"));

    //
    // Initialize status
    //

    Status = STATUS_SUCCESS;

    hRegKey = NULL;

    //
    // Check the arguments
    //

    if( (NULL == pExtension)
     || (NULL == pKeyName)
     || (NULL == pvData)
     || (0 == DataSize) )
    {
        DebugTrace(TRACE_ERROR, ("UsbScanWriteDeviceRegistry: ERROR!! Invalid argument.\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto UsbScanWriteDeviceRegistry_return;
    }

    //
    // Open device registry.
    //

    Status = IoOpenDeviceRegistryKey(pExtension->pPhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     KEY_ALL_ACCESS,
                                     &hRegKey);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR, ("UsbScanWriteDeviceRegistry: ERROR!! IoOpenDeviceRegistryKey failed.\n"));
        goto UsbScanWriteDeviceRegistry_return;
    }

    //
    // Set specified value.
    //

    RtlInitUnicodeString(&unicodeKeyName, pKeyName);
    DebugTrace(TRACE_STATUS, ("UsbScanWriteDeviceRegistry: Setting \"%wZ\".\n", &unicodeKeyName));
    Status = ZwSetValueKey(hRegKey,
                           &unicodeKeyName,
                           0,
                           Type,
                           pvData,
                           DataSize);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR, ("UsbScanWriteDeviceRegistry: ERROR!! ZwSetValueKey failed. Status = 0x%x\n", Status));
        goto UsbScanWriteDeviceRegistry_return;
    }

UsbScanWriteDeviceRegistry_return:

    //
    // Clean-up.
    //

    if(hRegKey){
        ZwClose(hRegKey);
    }
    DebugTrace(TRACE_PROC_LEAVE, ("UsbScanWriteDeviceRegistry: Leaving... Status=0x%x\n", Status));
    return Status;
} // UsbScanWriteDeviceRegistry()

PURB
USCreateConfigurationRequest(
    IN PUSB_CONFIGURATION_DESCRIPTOR    ConfigurationDescriptor,
    IN OUT PUSHORT                      Siz
    )
/*++

Routine Description:

Arguments:

Return Value:

    Pointer to initailized select_configuration urb.

--*/
{
    PURB urb = NULL;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    PUSBD_INTERFACE_LIST_ENTRY interfaceList, tmp;
    LONG numberOfInterfaces, interfaceNumber, i;

    PAGED_CODE();
    DebugTrace(TRACE_PROC_ENTER, ("USCreateConfigurationRequest: Entering...\n"));

    //
    // build a request structure and call the new api
    //

    numberOfInterfaces = ConfigurationDescriptor->bNumInterfaces;

    tmp = interfaceList = USAllocatePool(PagedPool, sizeof(USBD_INTERFACE_LIST_ENTRY) * (numberOfInterfaces+1));

    //
    // just grab the first alt setting we find for each interface
    //

    i = interfaceNumber = 0;

    while (i< numberOfInterfaces) {

        interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(ConfigurationDescriptor,
                                                                  ConfigurationDescriptor,
                                                                  -1,
                                                                  0, // assume alt setting zero here
                                                                  -1,
                                                                  -1,
                                                                  -1);

        ASSERT(interfaceDescriptor != NULL);

        if (interfaceDescriptor) {
            interfaceList->InterfaceDescriptor =
                interfaceDescriptor;
            interfaceList++;
            i++;
        } else {
            // could not find the requested interface descriptor
            // bail, we will prorblay crash somewhere in the
            // client driver.

            goto USCreateConfigurationRequest_return;
        }

        interfaceNumber++;
    }

    //
    // terminate the list
    //
    interfaceList->InterfaceDescriptor = NULL;

    urb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor, tmp);

USCreateConfigurationRequest_return:

    ExFreePool(tmp);

    if (urb) {
        *Siz = urb->UrbHeader.Length;
    }

    DebugTrace(TRACE_PROC_LEAVE, ("USCreateConfigurationRequest: Leaving... Ret=0x%x\n", urb));
    return urb;

} // USCreateConfigurationRequest()

VOID
UsbScanLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DriverObject        - Supplies a pointer to the driver object for the
                            device.

    DeviceObject        - Supplies a pointer to the device object associated
                            with the device that had the error, early in
                            initialization, one may not yet exist.

    SequenceNumber      - Supplies a ulong value that is unique to an IRP over
                            the life of the irp in this driver - 0 generally
                            means an error not associated with an irp.

    MajorFunctionCode   - Supplies the major function code of the irp if there
                            is an error associated with it.

    RetryCount          - Supplies the number of times a particular operation
                            has been retried.

    UniqueErrorValue    - Supplies a unique long word that identifies the
                            particular call to this function.

    FinalStatus         - Supplies the final status given to the irp that was
                            associated with this error.  If this log entry is
                            being made during one of the retries this value
                            will be STATUS_SUCCESS.

    SpecificIOStatus    - Supplies the IO status for this particular error.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET    ErrorLogEntry;
    PVOID                   ObjectToUse;
    SHORT                   DumpToAllocate;

    if (ARGUMENT_PRESENT(DeviceObject)) {

        ObjectToUse = DeviceObject;

    } else {

        ObjectToUse = DriverObject;

    }

    DumpToAllocate = 0;

    ErrorLogEntry = IoAllocateErrorLogEntry(ObjectToUse,
            (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) + DumpToAllocate));

    if (!ErrorLogEntry) {
        return;
    }

    ErrorLogEntry->ErrorCode         = SpecificIOStatus;
    ErrorLogEntry->SequenceNumber    = SequenceNumber;
    ErrorLogEntry->MajorFunctionCode = MajorFunctionCode;
    ErrorLogEntry->RetryCount        = RetryCount;
    ErrorLogEntry->UniqueErrorValue  = UniqueErrorValue;
    ErrorLogEntry->FinalStatus       = FinalStatus;
    ErrorLogEntry->DumpDataSize      = DumpToAllocate;

    if (DumpToAllocate) {

        // If needed - add more to parameter list and move memory here
        //RtlCopyMemory(ErrorLogEntry->DumpData, &P1, sizeof(PHYSICAL_ADDRESS));

    }

    IoWriteErrorLogEntry(ErrorLogEntry);

}



#ifdef ORIGINAL_POOLTRACK

int NumberOfAllocate = 0;

PVOID
USAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG     ulNumberOfBytes
)
/*++

Routine Description:

    Wrapper for pool allocation. Use tag to avoid heap corruption.

Arguments:

    PoolType - type of pool memory to allocate
    ulNumberOfBytes - number of bytes to allocate

Return Value:

    Pointer to the allocated memory

--*/
{
    PVOID pvRet;

    DebugTrace(TRACE_PROC_ENTER,("USAllocatePool: Enter.. Size = %d\n", ulNumberOfBytes));

    pvRet = ExAllocatePoolWithTag(PoolType,
                                  ulNumberOfBytes,
                                  TAG_USBSCAN);

    NumberOfAllocate++;
    DebugTrace(TRACE_PROC_LEAVE,("USAllocatePool: Leaving.. pvRet = %x, Count=%d\n", pvRet, NumberOfAllocate));
    return pvRet;

}


VOID
USFreePool(
    IN PVOID     pvAddress
)
/*++

Routine Description:

    Wrapper for pool free. Check tag to avoid heap corruption

Arguments:

    pvAddress - Pointer to the allocated memory

Return Value:

    none.

--*/
{

    ULONG ulTag;

    DebugTrace(TRACE_PROC_ENTER,("USFreePool: Enter..\n"));

    ulTag = *((PULONG)pvAddress-1);

    if( (TAG_USBSCAN == ulTag) || (TAG_USBD == ulTag) ){
        DebugTrace(TRACE_STATUS,("USFreePool: Free memory. tag = %c%c%c%c\n",
                                        ((PUCHAR)&ulTag)[0],
                                        ((PUCHAR)&ulTag)[1],
                                        ((PUCHAR)&ulTag)[2],
                                        ((PUCHAR)&ulTag)[3]  ))
    } else {
        DebugTrace(TRACE_WARNING,("USFreePool: WARNING!! Free memory. tag = %c%c%c%c\n",
                                        ((PUCHAR)&ulTag)[0],
                                        ((PUCHAR)&ulTag)[1],
                                        ((PUCHAR)&ulTag)[2],
                                        ((PUCHAR)&ulTag)[3]  ))
    }

    ExFreePool(pvAddress);

    NumberOfAllocate--;
    DebugTrace(TRACE_PROC_LEAVE,("USFreePool: Leaving.. Status = VOID, Count=%d\n", NumberOfAllocate));
}

#endif   // ORIGINAL_POOLTRACK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\device.cpp ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Device.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Device class for WIA class installer.
*
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

#define INITGUID

#include "device.h"

#include "sti.h"
#include "stiregi.h"

#include <stisvc.h>
#include <devguid.h>
#include <regstr.h>
#include <icm.h>
#include <ks.h>
#include <aclapi.h>
#include <sddl.h>


//
// Parsinc character used to separate field type from value in registry data section
//

#define     FIELD_DELIMETER     TEXT(',')


BOOL
CDevice::CollectNames(
    VOID
    )
{

    BOOL                        bRet;
    HANDLE                      hDevInfo;
    GUID                        Guid;
    DWORD                       dwRequired;
    DWORD                       Idx;
    SP_DEVINFO_DATA             spDevInfoData;
    SP_DEVICE_INTERFACE_DATA    spDevInterfaceData;
    TCHAR                       szTempBuffer[MAX_DESCRIPTION];
    HKEY                        hKeyInterface;
    HKEY                        hKeyDevice;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::CollectNames: Enter...\r\n")));

    //
    // Initialize local.
    //

    bRet            = FALSE;
    hDevInfo        = INVALID_HANDLE_VALUE;
    Guid            = GUID_DEVCLASS_IMAGE;
    dwRequired      = 0;
    Idx             = 0;
    hKeyInterface   = (HKEY)INVALID_HANDLE_VALUE;
    hKeyDevice      = (HKEY)INVALID_HANDLE_VALUE;

    memset(szTempBuffer, 0, sizeof(szTempBuffer));
    memset(&spDevInfoData, 0, sizeof(spDevInfoData));
    memset(&spDevInterfaceData, 0, sizeof(spDevInterfaceData));

    //
    // Reset device name/ID array.
    //

    m_csaAllNames.Cleanup();
    m_csaAllId.Cleanup();

    //
    //  Get all of installed WIA "devnode" device info set.
    //

    hDevInfo = SetupDiGetClassDevs (&Guid, NULL, NULL, DIGCF_PROFILE);
    if (hDevInfo == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("CDevice::CollectNames: ERROR!! SetupDiGetClassDevs (devnodes) fails. Err=0x%x\n"), GetLastError()));

        bRet = FALSE;
        goto CollectNames_return;
    }

    //
    // Enum WIA devnode device friendly name and add them to array.
    //

    DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: Looking for DevNodes.\r\n")));

    spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
    for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++) {

        //
        // Open device registry key.
        //

        hKeyDevice = SetupDiOpenDevRegKey(hDevInfo,
                                          &spDevInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DRV,
                                          KEY_READ);

        if (INVALID_HANDLE_VALUE != hKeyDevice) {

            //
            // Get FriendlyName.
            //

            dwRequired = (sizeof(szTempBuffer)-sizeof(TEXT('\0')));
            if (RegQueryValueEx(hKeyDevice,
                                REGSTR_VAL_FRIENDLY_NAME,
                                NULL,
                                NULL,
                                (LPBYTE)szTempBuffer,
                                &dwRequired) == ERROR_SUCCESS)
            {

                //
                // FriendlyName is found in this device regisgry. Add to the list if valid.
                //

                if(0 != lstrlen(szTempBuffer)) {
                    DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: Found %ws as installed device name.\r\n"), szTempBuffer));
                    m_csaAllNames.Add((LPCTSTR)szTempBuffer);
                } else { // if(0 != lstrlen(szTempBuffer))
                    DebugTrace(TRACE_ERROR,(("CDevice::CollectNames: ERROR!! Invalid FriendleName (length=0).\r\n")));
                } // if(0 != lstrlen(szTempBuffer))

            } else { // if (RegQueryValueEx()
                DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: can't get FriendlyName. Err=0x%x\r\n"), GetLastError()));
            } // if (RegQueryValueEx()

            //
            // Get DeviceID.
            //

            dwRequired = (sizeof(szTempBuffer)-sizeof(TEXT('\0')));
            if (RegQueryValueEx(hKeyDevice,
                                REGSTR_VAL_DEVICE_ID,
                                NULL,
                                NULL,
                                (LPBYTE)szTempBuffer,
                                &dwRequired) == ERROR_SUCCESS)
            {

                //
                // DeviceID is found in this device regisgry. Add to the list if valid.
                //

                if(0 != lstrlen(szTempBuffer)) {
                    DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: Found %ws as installed device ID.\r\n"), szTempBuffer));
                    m_csaAllId.Add((LPCTSTR)szTempBuffer);
                } else { // if(0 != lstrlen(szTempBuffer))
                    DebugTrace(TRACE_ERROR,(("CDevice::CollectNames: ERROR!! Invalid DeviceID (length=0).\r\n")));
                } // if(0 != lstrlen(szTempBuffer))

            } else { // if (RegQueryValueEx()
                DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: can't get DeviceID. Err=0x%x\r\n"), GetLastError()));
            } // if (RegQueryValueEx()

            //
            // Close regkey and continue.
            //

            RegCloseKey(hKeyDevice);
            hKeyInterface = (HKEY)INVALID_HANDLE_VALUE;
            szTempBuffer[0] = TEXT('\0');

        } else { // if (hKeyDevice != INVALID_HANDLE_VALUE)
            DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: Unable to open Device(%d) RegKey. Err=0x%x\r\n"), Idx, GetLastError()));
        } // if (hKeyDevice != INVALID_HANDLE_VALUE)

    } // for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++)

    //
    // Free "devnode" device info set.
    //

    SetupDiDestroyDeviceInfoList(hDevInfo);
    hDevInfo = INVALID_HANDLE_VALUE;

    //
    // Enum WIA interface-only device friendly name and add them to array.
    //

    DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: Looking for Interfaces.\r\n")));

    hDevInfo = SetupDiGetClassDevs (&Guid, NULL, NULL, DIGCF_DEVICEINTERFACE | DIGCF_PROFILE);
    if (hDevInfo == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("CDevice::CollectNames: ERROR!! SetupDiGetClassDevs (inferfase) fails. Err=0x%x\n"), GetLastError()));

        bRet = FALSE;
        goto CollectNames_return;
    }

    spDevInterfaceData.cbSize = sizeof (spDevInterfaceData);
    for (Idx = 0; SetupDiEnumDeviceInterfaces (hDevInfo, NULL, &Guid, Idx, &spDevInterfaceData); Idx++) {

        hKeyInterface = SetupDiOpenDeviceInterfaceRegKey(hDevInfo,
                                                         &spDevInterfaceData,
                                                         0,
                                                         KEY_READ);
        if (hKeyInterface != INVALID_HANDLE_VALUE) {

            //
            // Get FriendlyName.
            //

            dwRequired = (sizeof(szTempBuffer)-sizeof(TEXT('\0')));
            if (RegQueryValueEx(hKeyInterface,
                                REGSTR_VAL_FRIENDLY_NAME,
                                NULL,
                                NULL,
                                (LPBYTE)szTempBuffer,
                                &dwRequired) == ERROR_SUCCESS)
            {

                //
                // FriendlyName is found in this interface. Add to the list if valid.
                //

                if(0 != lstrlen(szTempBuffer)) {
                    DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: Found %ws as installed device name (interface).\r\n"), szTempBuffer));
                    m_csaAllNames.Add((LPCTSTR)szTempBuffer);
                } else { // if(0 != lstrlen(szTempBuffer))
                    DebugTrace(TRACE_ERROR,(("CDevice::CollectNames: ERROR!! Invalid FriendleName (length=0).\r\n")));
                } // if(0 != lstrlen(szTempBuffer))

            } else { // if (RegQueryValueEx()
                DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: can't get FriendlyName. Err=0x%x\r\n"), GetLastError()));
            } // if (RegQueryValueEx()

            //
            // Get DeviceID.
            //

            dwRequired = (sizeof(szTempBuffer)-sizeof(TEXT('\0')));
            if (RegQueryValueEx(hKeyInterface,
                                REGSTR_VAL_DEVICE_ID,
                                NULL,
                                NULL,
                                (LPBYTE)szTempBuffer,
                                &dwRequired) == ERROR_SUCCESS)
            {

                //
                // DeviceID is found in this interface. Add to the list if valid.
                //

                if(0 != lstrlen(szTempBuffer)) {
                    DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: Found %ws as installed device ID (interface).\r\n"), szTempBuffer));
                    m_csaAllId.Add((LPCTSTR)szTempBuffer);
                } else { // if(0 != lstrlen(szTempBuffer))
                    DebugTrace(TRACE_ERROR,(("CDevice::CollectNames: ERROR!! Invalid DeviceID (length=0).\r\n")));
                } // if(0 != lstrlen(szTempBuffer))

            } else { // if (RegQueryValueEx()
                DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: can't get DeviceID. Err=0x%x\r\n"), GetLastError()));
            } // if (RegQueryValueEx()

            //
            // Close registry key and continue.
            //

            RegCloseKey(hKeyInterface);
            hKeyInterface = (HKEY)INVALID_HANDLE_VALUE;
            szTempBuffer[0] = TEXT('\0');

        } else { // if (hKeyInterface != INVALID_HANDLE_VALUE)
            DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: Unable to open Interface(%d) RegKey. Err=0x%x\r\n"), Idx, GetLastError()));
        } // if (hKeyInterface != INVALID_HANDLE_VALUE)
    } // for (Idx = 0; SetupDiEnumDeviceInterfaces (hDevInfo, NULL, &Guid, Idx, &spDevInterfaceData); Idx++)

    //
    // Operation succeeded.
    //

    bRet = TRUE;

CollectNames_return:

    //
    // Clean up.
    //

    if(INVALID_HANDLE_VALUE != hDevInfo){
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

    if(INVALID_HANDLE_VALUE != hKeyInterface){
        RegCloseKey(hKeyInterface);
    }

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::CollectNames: Leaving... Ret=0x%x\n"), bRet));
    return bRet;
} // CDevice::CollectNames()


// For a device w/ devnode.
CDevice::CDevice(
    HDEVINFO            hDevInfo,
    PSP_DEVINFO_DATA    pspDevInfoData,
    BOOL                bIsPnP
    )
{
    HKEY    hkDevice;
    
    //
    // Initizlize local.
    //

    hkDevice    = (HKEY)INVALID_HANDLE_VALUE;

    //
    // Initialize member.
    //

    m_hMutex                = (HANDLE)NULL;
    m_hDevInfo              = hDevInfo;
    m_pspDevInfoData        = pspDevInfoData;

    m_bIsPnP                = bIsPnP;
    m_bDefaultDevice        = FALSE;
    m_bVideoDevice          = FALSE;
    m_bInfProceeded         = FALSE;
    m_bInterfaceOnly        = FALSE;
    m_bIsMigration          = FALSE;

    m_hkInterfaceRegistry   = (HKEY)INVALID_HANDLE_VALUE;

    m_dwCapabilities        = 0;
    m_dwInterfaceIndex      = INVALID_DEVICE_INDEX;

    m_pfnDevnodeSelCallback = (DEVNODESELCALLBACK) NULL;
    m_pExtraDeviceData      = NULL;

    m_csFriendlyName.Empty();
    m_csInf.Empty();
    m_csInstallSection.Empty();
    m_csDriverDescription.Empty();
    m_csPort.Empty();
    m_csDeviceID.Empty();
    
    //
    // In case of upgrade, use original FriendlyName.
    //

    hkDevice = SetupDiOpenDevRegKey(m_hDevInfo,
                                    m_pspDevInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DRV,
                                    KEY_READ);
    if(INVALID_HANDLE_VALUE != hkDevice){

        //
        // Device registry found. Read its FriendlyName.
        //

        m_csDriverDescription.Load(hkDevice, FRIENDLYNAME);
        m_csDeviceID.Load(hkDevice, REGSTR_VAL_DEVICE_ID);
        m_csFriendlyName.Load(hkDevice, FRIENDLYNAME);

        RegCloseKey(hkDevice);
        hkDevice = (HKEY)INVALID_HANDLE_VALUE;

    } // if(INVALID_HANDLE_VALUE != hkDevice)

    //
    // Get the number of installed devices.
    //

    GetDeviceCount(&m_dwNumberOfWiaDevice, &m_dwNumberOfStiDevice);

} // CDevice::CDevice()

// For a interface-only device.
CDevice::CDevice(
    HDEVINFO            hDevInfo,
    DWORD               dwDeviceIndex
    )
{
    //
    // Initialize member.
    //

    m_hMutex                = (HANDLE)NULL;
    m_hDevInfo              = hDevInfo;
    m_pspDevInfoData        = NULL;

    m_bIsPnP                = FALSE;
    m_bDefaultDevice        = FALSE;
    m_bVideoDevice          = FALSE;
    m_bInfProceeded         = FALSE;
    m_bInterfaceOnly        = TRUE;
    m_bIsMigration          = FALSE;

    m_hkInterfaceRegistry   = (HKEY)INVALID_HANDLE_VALUE;

    m_dwCapabilities        = 0;
    m_dwInterfaceIndex      = dwDeviceIndex;

    m_pfnDevnodeSelCallback = (DEVNODESELCALLBACK) NULL;
    m_pExtraDeviceData      = NULL;

    m_csFriendlyName.Empty();
    m_csInf.Empty();
    m_csInstallSection.Empty();
    m_csDriverDescription.Empty();
    m_csPort.Empty();
    m_csDeviceID.Empty();

    //
    // Get the number of installed devices.
    //

    GetDeviceCount(&m_dwNumberOfWiaDevice, &m_dwNumberOfStiDevice);

} // CDevice::CDevice()

// For a interface-only device.
CDevice::CDevice(
    PDEVICE_INFO        pMigratingDevice
    )
{
    TCHAR   StringBuffer[MAX_PATH+1];
    TCHAR   WindowsDir[MAX_PATH+1];

    //
    // Initialize local.
    //

    memset(StringBuffer, 0, sizeof(StringBuffer));
    memset(WindowsDir, 0, sizeof(WindowsDir));

    //
    // Initialize member.
    //

    m_hMutex                = (HANDLE)NULL;
    m_hDevInfo              = NULL;
    m_pspDevInfoData        = NULL;

    m_bIsPnP                = FALSE;
    m_bDefaultDevice        = FALSE;
    m_bVideoDevice          = FALSE;
    m_bInfProceeded         = FALSE;
    m_bInterfaceOnly        = TRUE;
    m_bIsMigration          = TRUE;

    m_hkInterfaceRegistry   = (HKEY)INVALID_HANDLE_VALUE;

    m_dwCapabilities        = 0;
    m_dwInterfaceIndex      = INVALID_DEVICE_INDEX;

    m_pfnDevnodeSelCallback = (DEVNODESELCALLBACK) NULL;

    //
    // Copy migration data.
    //

    AtoT(StringBuffer, pMigratingDevice->pszInfPath);
    m_csInf                 = StringBuffer;
    if(0 != GetWindowsDirectory(WindowsDir, MAX_PATH)){
        _sntprintf(StringBuffer, ARRAYSIZE(StringBuffer)-1, TEXT("%ws\\inf\\%ws"), WindowsDir, (LPTSTR)m_csInf);
        m_csInf                 = StringBuffer;
    } // if(0 != GetWindowsDirectory(WindowsDir, MAX_PATH))

    AtoT(StringBuffer, pMigratingDevice->pszInfSection);
    m_csInstallSection      = StringBuffer;
    AtoT(StringBuffer, pMigratingDevice->pszFriendlyName);
    m_csDriverDescription   = StringBuffer;
    AtoT(StringBuffer, pMigratingDevice->pszFriendlyName);
    m_csFriendlyName        = StringBuffer;
    AtoT(StringBuffer, pMigratingDevice->pszCreateFileName);
    m_csPort                = StringBuffer;
    m_pExtraDeviceData      = pMigratingDevice->pDeviceDataParam;
    m_csDeviceID.Empty();

    //
    // Get the number of installed devices.
    //

    GetDeviceCount(&m_dwNumberOfWiaDevice, &m_dwNumberOfStiDevice);

} // CDevice::CDevice()

CDevice::~CDevice(
    )
{
    HKEY    hkNameStore;

    if(ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_INSTALL_NAMESTORE, &hkNameStore)){
        
        //
        // Delete FriendlyName and DeviceId in name store.
        //

        RegDeleteKey(hkNameStore, m_csFriendlyName);
        RegDeleteKey(hkNameStore, m_csDeviceID);
        RegCloseKey(hkNameStore);

    } // if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, REGKEY_INSTALL_NAMESTORE, &hkNameStore))

    //
    // Make sure Mutex is released.
    //
    
    ReleaseInstallerMutex();

} // CDevice::~CDevice()

BOOL
CDevice::IsSameDevice(
    HDEVINFO            hDevInfo,
    PSP_DEVINFO_DATA    pspDevInfoSet
    )
{
    BOOL                bRet;
    SP_DRVINFO_DATA     spDrvInfoData;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::IsSameDevice: Enter...\r\n")));

    //
    // Initialize local.
    //

    bRet    = FALSE;

    memset(&spDrvInfoData, 0, sizeof(spDrvInfoData));

    //
    // Get default FriendlyName. It's used to check if it's same device or not.
    //

    spDrvInfoData.cbSize = sizeof (SP_DRVINFO_DATA);
    if (!SetupDiGetSelectedDriver (hDevInfo, pspDevInfoSet, &spDrvInfoData)){

        bRet    = FALSE;
        goto IsSameDevice_return;
    } // if (SetupDiGetSelectedDriver (m_hDevInfo, m_pspDevInfoData, &spDevInfoData))

    //
    // See if it has same description of current device. (TRUE=same)
    //

    bRet = (0 == lstrcmp((LPCTSTR)spDrvInfoData.Description, (LPCTSTR)m_csPdoDescription));

IsSameDevice_return:
    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::IsSameDevice: Leaving... Ret=0x%x\n"), bRet));
    return bRet;
} // CDevice::IsSameDevice()

BOOL
CDevice::IsFriendlyNameUnique(
    LPTSTR  szFriendlyName
    )
    //
    //  Note:
    //  Before calling this function, caller has to make sure mutex is acquired.
    //
{
    BOOL    bRet;
    DWORD   Idx;
    DWORD   dwNumberOfName;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::IsFriendlyNameUnique: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet            = FALSE;
    Idx             = 0;
    dwNumberOfName  = m_csaAllNames.Count();

    //
    // If given name is same as generated one, it's unique.
    //

    if(0 == lstrcmp(szFriendlyName, (LPTSTR)(m_csFriendlyName))){
        bRet = TRUE;
        goto IsFriendlyNameUnique_return;
    } // if(0 == lstrcmp(szFriendlyName, (LPTSTR)(m_csFriendlyName)))

    //
    // Check any existing name matches given name.
    //

    for (Idx = 0; Idx < dwNumberOfName; Idx++) {

        DebugTrace(TRACE_STATUS,(("CDevice::IsFriendlyNameUnique: Name compare %ws and %ws.\r\n"),m_csaAllNames[Idx], szFriendlyName));

        if (0 == lstrcmpi(m_csaAllNames[Idx], szFriendlyName)){
            bRet = FALSE;
            goto IsFriendlyNameUnique_return;
        }
    } // for (Idx = 0; Idx < dwNumberOfName; Idx)

    //
    // Look in name store.
    //

    if(IsNameAlreadyStored(szFriendlyName)){
        bRet = FALSE;
        goto IsFriendlyNameUnique_return;
    } // if(IsNameAlreadyStored(szFriendlyName))

    //
    // This device name is unique.
    //

    bRet = TRUE;

IsFriendlyNameUnique_return:
    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::IsFriendlyNameUnique: Leaving... Ret=0x%x\n"), bRet));
    return bRet;

} // CDevice::IsFriendlyNameUnique()


BOOL
CDevice::IsDeviceIdUnique(
    LPTSTR  szDeviceId
    )
{
    BOOL    bRet;
    DWORD   Idx;
    DWORD   dwNumberOfId;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::IsDeviceIdUnique: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet            = FALSE;
    Idx             = 0;
    dwNumberOfId  = m_csaAllId.Count();

    //
    // If given ID is same as generated one, it's unique.
    //

    if(0 == lstrcmp(szDeviceId, (LPTSTR)(m_csDeviceID))){
        bRet = TRUE;
        goto IsDeviceIdUnique_return;
    } // if(0 == lstrcmp(szFriendlyName, (LPTSTR)(m_csFriendlyName)))

    //
    // Check any existing name matches given name.
    //

    for (Idx = 0; Idx < dwNumberOfId; Idx++) {

        DebugTrace(TRACE_STATUS,(("CDevice::IsDeviceIdUnique: DeviceId compare %ws and %ws.\r\n"),m_csaAllId[Idx], szDeviceId));

        if (0 == lstrcmpi(m_csaAllId[Idx], szDeviceId)){
            bRet = FALSE;
            goto IsDeviceIdUnique_return;
        } // if (0 == lstrcmpi(m_csaAllId[Idx], szFriendlyName))
    } // for (Idx = 0; Idx < dwNumberOfName; Idx)

    //
    // Look in name store.
    //

    if(IsNameAlreadyStored(szDeviceId)){
        bRet = FALSE;
        goto IsDeviceIdUnique_return;
    } // if(IsNameAlreadyStored(szFriendlyName))

    //
    // This device name is unique.
    //

    bRet = TRUE;

IsDeviceIdUnique_return:
    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::IsDeviceIdUnique: Leaving... Ret=0x%x\n"), bRet));
    return bRet;

} // CDevice::IsDeviceIdUnique()

BOOL
CDevice::NameDefaultUniqueName(
    VOID
    )
{
    SP_DRVINFO_DATA     spDrvInfoData;
    TCHAR               szFriendly[MAX_DESCRIPTION];
    TCHAR               szDescription[MAX_DESCRIPTION];
    UINT                i;
    BOOL                bRet;
    HKEY                hkNameStore;
    DWORD               dwError;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::NameDefaultUniqueName: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet        = FALSE;
    hkNameStore = (HKEY)INVALID_HANDLE_VALUE;

    memset(szFriendly, 0, sizeof(szFriendly));
    memset(szDescription, 0, sizeof(szDescription));
    memset(&spDrvInfoData, 0, sizeof(spDrvInfoData));

    //
    // Acquire mutex to make sure not duplicating FriendlyName/DeviceId.
    //

    dwError = AcquireInstallerMutex(MAX_MUTEXTIMEOUT);
    if(ERROR_SUCCESS != dwError){  // it must be done at least in 60 sec.

        if(WAIT_ABANDONED == dwError){
            DebugTrace(TRACE_ERROR,("CDevice::NameDefaultUniqueName: ERROR!! Mutex abandoned. Continue...\r\n"));
        } else if(WAIT_TIMEOUT == dwError){
            DebugTrace(TRACE_ERROR,("CDevice::NameDefaultUniqueName: ERROR!! Unable to acquire mutex in 60 sec. Bail out.\r\n"));
            bRet    = FALSE;
            goto NameDefaultUniqueName_return;
        } // else if(WAIT_TIMEOUT == dwError)
    } // if(ERROR_SUCCESS != AcquireInstallerMutex(60000))

    //
    // Get all installed WIA device friendly name.
    //

    CollectNames();

    //
    // Generate unique device ID.
    //

    if(m_csDeviceID.IsEmpty()){
        GenerateUniqueDeviceId();
    } // if(m_csDeviceID.IsEmpty())

    if(m_csFriendlyName.IsEmpty()){

        //
        // Get default FriendlyName. It's used to check if it's same device or not.
        //

        spDrvInfoData.cbSize = sizeof (SP_DRVINFO_DATA);
        if (!SetupDiGetSelectedDriver (m_hDevInfo, m_pspDevInfoData, &spDrvInfoData)){

            bRet    = FALSE;
            goto NameDefaultUniqueName_return;
        } // if (SetupDiGetSelectedDriver (m_hDevInfo, m_pspDevInfoData, &spDevInfoData))

        //
        // Copy default Device description. (= default FriendlyName)
        // Also set Vnedor name.
        //

        m_csVendor      = (LPCTSTR)spDrvInfoData.MfgName;
        m_csPdoDescription = (LPCTSTR)spDrvInfoData.Description;

        //
        // Find unique name for this device.
        //

        if(m_csDriverDescription.IsEmpty()){
            lstrcpyn(szDescription, m_csPdoDescription, ARRAYSIZE(szDescription)-1);
            m_csDriverDescription = szDescription;
        } else {
            lstrcpyn(szDescription, m_csDriverDescription, ARRAYSIZE(szDescription)-1);
        }

        lstrcpyn(szFriendly, szDescription, ARRAYSIZE(szFriendly)-1);
        for (i = 2; !IsFriendlyNameUnique(szFriendly); i++) {
            _sntprintf(szFriendly, ARRAYSIZE(szFriendly)-1, TEXT("%ws #%d"), szDescription, i);
        }

        //
        // Set created FriendlyName.
        //

        m_csFriendlyName = szFriendly;

    } // if(m_csFriendlyName.IsEmpty())

    //
    // Save FriendlyName and DeviceId in registry. It'll be deleted when installation is completed.
    //
    
    if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, REGKEY_INSTALL_NAMESTORE, &hkNameStore)){
        HKEY    hkTemp;

        hkTemp = (HKEY)INVALID_HANDLE_VALUE;

        //
        // Create FriendlyName key.
        //

        if(ERROR_SUCCESS == RegCreateKey(hkNameStore, (LPTSTR)m_csFriendlyName, &hkTemp)){
            RegCloseKey(hkTemp);
            hkTemp = (HKEY)INVALID_HANDLE_VALUE;
        } else {
            DebugTrace(TRACE_ERROR,("CDevice::NameDefaultUniqueName: ERROR!! Unable to create %s key.\r\n", (LPTSTR)m_csFriendlyName));
        } // if(ERROR_SUCCESS != RegCreateKey(hkNameStore, (LPTSTR)m_csFriendlyName, &hkTemp))

        //
        // Create DeviceId key.
        //

        if(ERROR_SUCCESS == RegCreateKey(hkNameStore, (LPTSTR)m_csDeviceID, &hkTemp)){
            RegCloseKey(hkTemp);
            hkTemp = (HKEY)INVALID_HANDLE_VALUE;
        } else {
            DebugTrace(TRACE_ERROR,("CDevice::NameDefaultUniqueName: ERROR!! Unable to create %s key.\r\n", (LPTSTR)m_csDeviceID));
        } // if(ERROR_SUCCESS != RegCreateKey(hkNameStore, (LPTSTR)m_csFriendlyName, &hkTemp))

        RegCloseKey(hkNameStore);

    } else { // if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, REGKEY_INSTALL_NAMESTORE, &hkNameStore))
        DebugTrace(TRACE_ERROR,("CDevice::NameDefaultUniqueName: ERROR!! Unable to create NameStore key.\r\n"));
    } // else(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, REGKEY_INSTALL_NAMESTORE, &hkNameStore))
    
    //
    // Operation succeeded.
    //

    DebugTrace(TRACE_STATUS,(("CDevice::NameDefaultUniqueName: Device default name=%ws.\r\n"), (LPTSTR)m_csFriendlyName));
    bRet = TRUE;

NameDefaultUniqueName_return:

    //
    // Release mutex. ReleaseInstallerMutex() will handle invalid handle also, so we can call anyway.
    //

    ReleaseInstallerMutex();

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::NameDefaultUniqueName: Leaving... Ret=0x%x\n"), bRet));
    return bRet;
} // CDevice::NameDefaultUniqueName()


BOOL
CDevice::GenerateUniqueDeviceId(
    VOID
    )
{
    DWORD               Idx;
    BOOL                bRet;
    TCHAR               szDeviceId[MAX_DESCRIPTION];

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::GenerateUniqueDeviceId: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet    = FALSE;
    memset(szDeviceId, 0, sizeof(szDeviceId));

    //
    // Find unique name for this device.
    //

    _sntprintf(szDeviceId, ARRAYSIZE(szDeviceId)-1, TEXT("%ws\\%04d"), WIA_GUIDSTRING, 0);

    for (Idx = 1; !IsDeviceIdUnique(szDeviceId); Idx++) {
        _sntprintf(szDeviceId, ARRAYSIZE(szDeviceId)-1, TEXT("%ws\\%04d"), WIA_GUIDSTRING, Idx);
    }

    //
    // Set created hardwareId.
    //

    m_csDeviceID = szDeviceId;

    //
    // Operation succeeded.
    //

    DebugTrace(TRACE_STATUS,(("CDevice::GenerateUniqueDeviceId: DeviceID=%ws.\r\n"), (LPTSTR)m_csDeviceID));
    bRet = TRUE;

// GenerateUniqueDeviceId_return:
    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::GenerateUniqueDeviceId: Leaving... Ret=0x%x\n"), bRet));
    return bRet;
} // CDevice::GenerateUniqueDeviceId()


BOOL
CDevice::Install(
    )
/*++

Routine Description:

    Worker function for DIF_INSTALL setup message

Arguments:

    none

Return Value:

    TRUE - successful
    FALSE - non successful

--*/
{

    BOOL    bRet;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::Install: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet    = FALSE;

    //
    // Class installer only handles file copy.
    //

    if(IsMigration()){
        CreateDeviceInterfaceAndInstall();
    } else { // if(IsMigration())
        if ( !HandleFilesInstallation()){
            DebugTrace(TRACE_ERROR, (("CDevice::Install: HandleFilesInstallation Failed. Err=0x%x"), GetLastError()));

            bRet    = FALSE;
            goto Install_return;
        } // if ( !HandleFilesInstallation())
    } // else(IsMigration())

    //
    // We are successfully finished
    //

    bRet = TRUE;

Install_return:

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::Install: Leaving... Ret=0x%x\n"), bRet));
    return bRet;
}

DWORD
CDevice::Remove(
    PSP_REMOVEDEVICE_PARAMS lprdp
    )
/*++

Routine Description:

    Remove

    method which is called when device is being removed

Arguments:

Return Value:

Side effects:

--*/
{

    CString                     csUninstallSection;
    CString                     csInf;
    CString                     csSubClass;
    DWORD                       dwCapabilities;
    PVOID                       pvContext;
    HKEY                        hkDrv;
    HKEY                        hkRun;
    GUID                        Guid;
    BOOL                        bIsServiceStopped;
    BOOL                        bIsSti;

    BOOL                        bSetParamRet;
    PSP_FILE_CALLBACK           SavedCallback;

    SP_DEVICE_INTERFACE_DATA    spDevInterfaceData;
    SP_DEVINSTALL_PARAMS        DeviceInstallParams;
    DWORD                       dwReturn;
    LPTSTR                      pSec;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::Remove: Enter... \r\n")));

    //
    // Initialize local.
    //

    pvContext       = NULL;
    hkDrv           = NULL;
    hkRun           = NULL;

    bSetParamRet    = FALSE;
    SavedCallback   = NULL;
    dwReturn        = NO_ERROR;
    Guid            = GUID_DEVCLASS_IMAGE;

    bIsServiceStopped   = FALSE;
    bIsSti              = FALSE;

    memset(&DeviceInstallParams, 0, sizeof(DeviceInstallParams));
    memset(&spDevInterfaceData, 0, sizeof(spDevInterfaceData));

    //
    // NT setup inconsistently set this bit , disable for now
    //

    #if SETUP_PROBLEM
    if (!(lprdp->Scope & DI_REMOVEDEVICE_GLOBAL)) {

        goto Remove_return;
    }
    #endif

    //
    // The name of the uninstall section was stored during installation
    //

    if(IsInterfaceOnlyDevice()){

        DebugTrace(TRACE_STATUS,(("CDevice::Remove: This is Interface-only device.\r\n")));

        //
        // Get interface from index.
        //

        spDevInterfaceData.cbSize = sizeof(spDevInterfaceData);
        if(!SetupDiEnumDeviceInterfaces(m_hDevInfo, NULL, &Guid, m_dwInterfaceIndex, &spDevInterfaceData)){
            DebugTrace(TRACE_ERROR,(("CDevice::Remove: SetupDiEnumDeviceInterfaces() failed. Err=0x%x \r\n"), GetLastError()));

            dwReturn  = ERROR_NO_DEFAULT_DEVICE_INTERFACE;
            goto Remove_return;
        }

        //
        // Create interface reg-key.
        //

        hkDrv = SetupDiOpenDeviceInterfaceRegKey(m_hDevInfo,
                                                 &spDevInterfaceData,
                                                 0,
                                                 KEY_READ);
    } else { // if(IsInterfaceOnlyDevice())

        DebugTrace(TRACE_STATUS,(("CDevice::Remove: This is devnode device.\r\n")));

        hkDrv = SetupDiOpenDevRegKey(m_hDevInfo,
                                     m_pspDevInfoData,
                                     DICS_FLAG_GLOBAL,
                                     0,
                                     DIREG_DRV,
                                     KEY_READ);
    } // if(IsInterfaceOnlyDevice())

    if (hkDrv == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("CDevice::Remove: Invalid device/interface regkey handle. Err=0x%x \r\n"), GetLastError()));

        dwReturn  = ERROR_KEY_DOES_NOT_EXIST;
        goto Remove_return;
    }

    //
    // Retrieve the name of the .INF File
    //

    csUninstallSection.Load (hkDrv, UNINSTALLSECTION);
    csInf.Load (hkDrv, INFPATH);
    csSubClass.Load(hkDrv, SUBCLASS);
    GetDwordFromRegistry(hkDrv, CAPABILITIES, &dwCapabilities);

    //
    // See if we need STI/WIA specific operation.
    //

    if( (!csSubClass.IsEmpty())
     && (0 == MyStrCmpi(csSubClass, STILL_IMAGE)) )
    {
        
        //
        // This is STI/WIA device.
        //
        
        bIsSti = TRUE;
        
        //
        // Delete "Scanner and Camera Wizard" menu.
        //

        if( (dwCapabilities & STI_GENCAP_WIA)
         && (m_dwNumberOfWiaDevice <= 1) )
        {
            DeleteWiaShortcut();

            //
            // remove following key for performance improvement.
            //

            if(ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, REGKEY_WIASHEXT)){
                DebugTrace(TRACE_ERROR,(("CDevice::Remove: RegDeleteKey() failed. Err=0x%x. \r\n"), GetLastError()));
            } // if(ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, REGKEY_WIASHEXT))

        } // if( (dwCapabilities & STI_GENCAP_WIA)

        //
        // If this is the last STI/WIA device, set WIA service as Manual.
        //

        if(m_dwNumberOfStiDevice <= 1){

            HKEY    hkeyTemp;

            DebugTrace(TRACE_STATUS,(("CDevice::Remove: Last WIA device being removed. Set WIA service as MANUAL.\r\n")));

            //
            // No more still image devices -- change service to Manual start
            //

//            StopWiaService();
            SetServiceStart(STI_SERVICE_NAME, SERVICE_DEMAND_START);
            bIsServiceStopped   = TRUE;

            //
            //
            // Also remove shell's flag about WIA device presence, this should be portable
            // to NT
            //
            if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_SOFT_STI, &hkRun) == 0) {
                RegDeleteValue (hkRun, REGSTR_VAL_WIA_PRESENT);
                RegCloseKey(hkRun);
                hkRun = NULL;
            } // if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_SOFT_STI, &hkRun) == 0)

        } // if(m_dwNumberOfStiDevice <= 1)
    } // if (m_dwNumberOfDevice <= 1)

    //
    // Operaion succeeded.
    //

    dwReturn = NO_ERROR;

Remove_return:

    if(IsInterfaceOnlyDevice()){

        //
        // Remove the interface.
        //

        if(!SetupDiRemoveDeviceInterface(m_hDevInfo, &spDevInterfaceData)){
            DebugTrace(TRACE_ERROR,(("CDevice::Remove: SetupDiRemoveDeviceInterface failed. Err=0x%x \r\n"), GetLastError()));
        } // if(!SetupDiRemoveDeviceInterface(m_hDevInfo, &spDevInterfaceData))

    } else { // if(IsInterfaceOnlyDevice())

        //
        // Remove the device node anyway.
        //

        if(!SetupDiRemoveDevice(m_hDevInfo, m_pspDevInfoData)){
            DebugTrace(TRACE_ERROR,(("CDevice::Remove: SetupDiRemoveDevice failed. Err=0x%x \r\n"), GetLastError()));

            //
            // Failed to remove device instance from system. Let default installer do that.
            //

            dwReturn  = ERROR_DI_DO_DEFAULT;
        } // if(!SetupDiRemoveDevice(m_hDevInfo, m_pspDevInfoData))
    } // else (IsInterfaceOnlyDevice())

    //
    // Clean up.
    //

    if(IS_VALID_HANDLE(hkDrv)){
        RegCloseKey (hkDrv);
        hkDrv = NULL;
    }

    if(IS_VALID_HANDLE(hkRun)){
        RegCloseKey (hkRun);
        hkRun = NULL;
    }

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::Remove: Leaving... Ret=0x%x\n"), dwReturn));
    return dwReturn;
}



BOOL
CDevice::PreprocessInf(
    VOID
    )
{

    BOOL    bRet;
    HINF    hInf;

    CString csCapabilities;
    CString csDeviceType;
    CString csDeviceSubType;
    CString csDriverDescription;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::PreprocessInf: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet    = FALSE;
    hInf    = INVALID_HANDLE_VALUE;

    //
    // Check if INF has already been proceeded.
    //

    if(m_bInfProceeded){
        DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: INF is already processed. \r\n")));
        bRet    = TRUE;
        goto ProcessInf_return;
    }

    //
    // Get Inf file/section name.
    //
    
    if( m_csInf.IsEmpty() || m_csInstallSection.IsEmpty()){
        GetInfInforamtion();
    } // if( m_csInf.IsEmpty() || m_csInstallSection.IsEmpty())

    //
    // Open INF file.
    //

    hInf = SetupOpenInfFile(m_csInf,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);

    if(!IS_VALID_HANDLE(hInf)){
        DebugTrace(TRACE_ERROR, (("CDevice::PreprocessInf: Unable to open INF(%ws). Error = 0x%x.\r\n"),m_csInf, GetLastError()));

        bRet = FALSE;
        goto ProcessInf_return;
    } // if(!IS_VALID_HANDLE(hInf))
    
    //
    // Check if WiaSection entry exists.
    //

    m_csWiaSection.Load (hInf, m_csInstallSection, WIASECTION);
    if(!m_csWiaSection.IsEmpty()){
        DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: WiaSection exists. Acquire all informaiton from WiaSection..\r\n")));

        //
        // Install interface from WiaSection for MFP device.
        //

        m_csInstallSection  = m_csWiaSection;
        m_bInterfaceOnly    = TRUE;

    } // if(!m_csWiaSection.IsEmpty())

    //
    // Get all information required for installation from inf file.
    //

    m_csSubClass.Load (hInf, m_csInstallSection, SUBCLASS);
    m_csUSDClass.Load (hInf, m_csInstallSection, USDCLASS);
    m_csEventSection.Load (hInf, m_csInstallSection, EVENTS);
    m_csConnection.Load (hInf, m_csInstallSection, CONNECTION);
    m_csIcmProfile.Load (hInf, m_csInstallSection, ICMPROFILES);
    m_csPropPages.Load (hInf, m_csInstallSection, PROPERTYPAGES);
    m_csDataSection.Load (hInf, m_csInstallSection, DEVICESECTION);
    m_csUninstallSection.Load (hInf, m_csInstallSection, UNINSTALLSECTION);
    m_csPortSelect.Load (hInf, m_csInstallSection, PORTSELECT);

    if(!IsMigration()){
        csDriverDescription.Load(hInf, m_csInstallSection, DESCRIPTION);
        if(!csDriverDescription.IsEmpty()){
            m_csDriverDescription = csDriverDescription;
            if(TRUE != NameDefaultUniqueName()){
                
                //
                // Unable to generate FriendlyName.
                //
            
                bRet = FALSE;
                goto ProcessInf_return;
            } // if(TRUE != NameDefaultUniqueName())
        } // if(!m_csDriverDescription.IsEmpty())
    } // if(!IsMigration())
    csCapabilities.Load (hInf, m_csInstallSection, CAPABILITIES);
    csDeviceType.Load (hInf, m_csInstallSection, DEVICETYPE);
    csDeviceSubType.Load (hInf, m_csInstallSection, DEVICESUBTYPE);

    m_dwCapabilities = csCapabilities.Decode();
    m_dwDeviceType = csDeviceType.Decode();
    m_dwDeviceSubType = csDeviceSubType.Decode();

    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: --------------- INF parameters --------------- \r\n")));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: Description      : %ws\n"), (LPTSTR)m_csDriverDescription));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: SubClass         : %ws\n"), (LPTSTR)m_csSubClass));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: USDClass         : %ws\n"), (LPTSTR)m_csUSDClass));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: EventSection     : %ws\n"), (LPTSTR)m_csEventSection));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: Connection       : %ws\n"), (LPTSTR)m_csConnection));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: IcmProfile       : %ws\n"), (LPTSTR)m_csIcmProfile));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: PropPages        : %ws\n"), (LPTSTR)m_csPropPages));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: DataSection      : %ws\n"), (LPTSTR)m_csDataSection));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: UninstallSection : %ws\n"), (LPTSTR)m_csUninstallSection));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: Capabilities     : 0x%x\n"), m_dwCapabilities));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: DeviceType       : 0x%x\n"), m_dwDeviceType));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: DeviceSubType    : 0x%x\n"), m_dwDeviceSubType));

    //
    // Set video device flag if applicable.
    //

    if(StiDeviceTypeStreamingVideo == m_dwDeviceType){
        DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: This is video device.\r\n")));
        m_bVideoDevice = TRUE;
    } else {
        m_bVideoDevice = FALSE;
    }

    //
    // Operation succeeded.
    //

    bRet            = TRUE;
    m_bInfProceeded = TRUE;

ProcessInf_return:

    if(IS_VALID_HANDLE(hInf)){
        SetupCloseInfFile(hInf);
        hInf = INVALID_HANDLE_VALUE;
    } // if(IS_VALID_HANDLE(hInf))

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::PreprocessInf: Leaving... Ret=0x%x \r\n"), bRet));
    return bRet;
} // CDevice::PreprocessInf()

BOOL
CDevice::PreInstall(
    VOID
    )
{
    BOOL                                bRet;
    HKEY                                hkDrv;
    GUID                                Guid;
    HDEVINFO                            hDevInfo;
    SP_DEVINFO_DATA                     spDevInfoData;
    SP_DEVICE_INTERFACE_DATA            spDevInterfaceData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pspDevInterfaceDetailData;
    BOOL                                bUseDefaultDevInfoSet;
    DWORD                               dwRequiredSize;



    DebugTrace(TRACE_PROC_ENTER,(("CDevice::PreInstall: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet                        = FALSE;

    //
    // Get all INF parameter.
    //

    if(!PreprocessInf()){
        DebugTrace(TRACE_ERROR,(("CDevice::PreInstall: ERROR!! Unable to process INF.\r\n")));

        bRet    = FALSE;
        goto PreInstall_return;
    }

/**************************************
    if(!IsInterfaceOnlyDevice()){

        //
        // Register device if it's getting manually installed and not "interface-only" device..
        //

        if(!IsPnpDevice()){
            if (!SetupDiRegisterDeviceInfo(m_hDevInfo, m_pspDevInfoData, 0, NULL, NULL, NULL)) {
                DebugTrace(TRACE_ERROR,(("CDevice::PreInstall: SetupDiRegisterDeviceInfo failed. Err=0x%x.\r\n"),GetLastError()));

                bRet = FALSE;
                goto PreInstall_return;
            }
        } // if(!IsPnpDevice())
    } // if(IsInterfaceOnlyDevice())

**************************************/

    //
    // Clean up.
    //

    //
    // Operation succeeded.
    //

    bRet = TRUE;

PreInstall_return:
    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::PreInstall: Leaving... Ret=0x%x.\r\n"), bRet));
    return bRet;
}


BOOL
CDevice::PostInstall(
    BOOL    bSucceeded
    )
{
    BOOL    bRet;
    HKEY    hkRun;
    HKEY    hkDrv;
    DWORD   dwFlagPresent;
    CString csInfFilename;
    CString csInfSection;
    GUID    Guid;
    HKEY    hkNameStore;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::PostInstall: Enter... \r\n")));


    //
    // Initialize local.
    //

    bRet            = FALSE;
    hkRun           = NULL;
    dwFlagPresent   = 1;
    Guid            = GUID_DEVCLASS_IMAGE;
    hkNameStore     = (HKEY)INVALID_HANDLE_VALUE;

    if(IsFeatureInstallation()){

        //
        // This is a "feature" added to other class devnode and being installed by co-isntaller.
        // Need to do actual installation here only for "feature", manual installed device would
        // be installed through wizard. (final.cpp)
        //

        bRet = Install();
        if(FALSE == bRet){
            DebugTrace(TRACE_ERROR,(("CDevice::PostInstall: device interface registry key creation failed. \r\n")));
            bSucceeded = FALSE;
        } //if(FALSE == bRet)

    } // if(IsFeatureInstallation())

    if(!bSucceeded){

        HDEVINFO                    hDevInfo;
        SP_DEVICE_INTERFACE_DATA    spDevInterfaceData;
        DWORD                       dwIndex;

        //
        // Installation failed. Do clean up.
        //

        DebugTrace(TRACE_STATUS,(("CDevice::PostInstall: Installation failed. Do clean up.\r\n")));

        //
        // Delete craeted interface if any.
        //

        if(IsInterfaceOnlyDevice()){
            hDevInfo = GetDeviceInterfaceIndex(m_csDeviceID, &dwIndex);
            if(IS_VALID_HANDLE(hDevInfo)){
                spDevInterfaceData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);
                if(SetupDiEnumDeviceInterfaces(hDevInfo, NULL, &Guid, dwIndex, &spDevInterfaceData)){

                    //
                    // Created Interface is found. Delete it...
                    //

                    DebugTrace(TRACE_STATUS,(("CDevice::PostInstall: Deleting created interface for %ws.\r\n"), (LPTSTR)m_csFriendlyName));

                    if(!SetupDiRemoveDeviceInterface(hDevInfo, &spDevInterfaceData)){
                        DebugTrace(TRACE_ERROR,(("CDevice::PostInstall: ERROR!! Unable to delete interface for %ws. Err=0x%x\n"), m_csFriendlyName, GetLastError()));
                    }
                } // if(SetupDiEnumDeviceInterfaces(hDevInfo, NULL, &Guid, dwIndex, &spDevInterfaceData))

                //
                // Destroy created DevInfoSet.
                //

                SetupDiDestroyDeviceInfoList(hDevInfo);
            } // if(NULL != hDevInfo)
        } // if(IsInterfaceOnlyDevice())

        bRet = TRUE;
        goto PostInstall_return;

    } // if(!bSucceeded)

    //
    // Save all Inf parameters to registry.
    //

    if(!UpdateDeviceRegistry()){
        DebugTrace(TRACE_ERROR,(("CDevice::PostInstall: ERROR!! UpdateDeviceRegistry() failed. \r\n")));
    }

    //
    // Do WIA/STI device only process.
    //

    if( (!m_csSubClass.IsEmpty())
     && (0 == MyStrCmpi(m_csSubClass, STILL_IMAGE)) )
    {

        HKEY    hkeyTemp;

        //
        // Change service to AUTO start.
        //

        if(TRUE != SetServiceStart(STI_SERVICE_NAME, SERVICE_AUTO_START)){
            CString csServiceName;
            
            //
            // Load ServiceName from resource.
            //
            
            csServiceName.FromTable(WiaServiceName);
            
            //
            // Service is unable to change start type, supposed to be disabled.
            //
            
            if( (!m_csFriendlyName.IsEmpty())
             && (!csServiceName.IsEmpty()) )
            {
                LPTSTR  szMsgArray[2];
                
                szMsgArray[0]   = m_csFriendlyName;
                szMsgArray[1]   = csServiceName;
                
                LogSystemEvent(EVENTLOG_WARNING_TYPE, MSG_WARNING_SERVICE_DISABLED, 2, szMsgArray);
            }
            
        } // if(TRUE != SetServiceStart(STI_SERVICE_NAME, SERVICE_AUTO_START))

        //
        // Start WIA service.
        //

        if(!StartWiaService()){
//            DebugTrace(TRACE_ERROR,(("CDevice::PostInstall: ERROR!! Unable to start WIA service.\r\n")));
        }

        //
        // Create "Scanner and Camera Wizard" menu if WIA.
        //

        if(m_dwCapabilities & STI_GENCAP_WIA){

            CreateWiaShortcut();

            //
            // Add following value upon device arrival for performance improvement.
            //

            if (ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, REGKEY_WIASHEXT, &hkeyTemp)) {
                RegSetValue (hkeyTemp,
                             NULL,
                             REG_SZ,
                             REGSTR_VAL_WIASHEXT,
                             lstrlen(REGSTR_VAL_WIASHEXT) * sizeof(TCHAR));
                RegCloseKey(hkeyTemp);
                hkeyTemp = NULL;
            } else {
                DebugTrace(TRACE_ERROR,(("CDevice::PostInstall: ERROR!! RegOpenKey(WIASHEXT) failed. Err=0x%x \r\n"), GetLastError()));
            } // if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_SOFT_STI, &hkRun))
        } // if(m_dwCapabilities & STI_GENCAP_WIA)

        //
        // Also add shell's flag about WIA device presence, this should be portable
        // to NT
        //

        if (ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_SOFT_STI, &hkRun)) {
            RegDeleteValue (hkRun, REGSTR_VAL_WIA_PRESENT);
            RegSetValueEx (hkRun,
                           REGSTR_VAL_WIA_PRESENT,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwFlagPresent,
                           sizeof(DWORD));
        } else {
            DebugTrace(TRACE_ERROR,(("CDevice::PostInstall: ERROR!! RegOpenKey() failed. Err=0x%x \r\n"), GetLastError()));
        } // if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_SOFT_STI, &hkRun))

    } // if(!lstrcmpi(m_csSubClass, STILL_IMAGE))

    //
    // ICM support
    //

    ProcessICMProfiles();

    //
    // Register interface name of Videoo device.
    //

    bRet = TRUE;

PostInstall_return:

    //
    // Clean up.
    //

    if(NULL != hkRun){
        RegCloseKey(hkRun);
    }

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::PostInstall: Leaving... Ret=0x%x.\r\n"), bRet));
    return bRet;
} // CDevice::PostInstall()


BOOL
CDevice::HandleFilesInstallation(
    VOID
    )
/*++

Routine Description:

Arguments:

Return Value:

Side effects:

--*/
{

    BOOL                                bRet;
    BOOL                                bSetParamRet;
    PSP_FILE_CALLBACK                   pSavedCallback;
    PVOID                               pvContext;
    SP_DEVINSTALL_PARAMS                spDeviceInstallParams;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::HandleFilesInstallation: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet                        = FALSE;
    bSetParamRet                = FALSE;
    pvContext                   = NULL;
    pSavedCallback              = NULL;

    memset(&spDeviceInstallParams, 0, sizeof(spDeviceInstallParams));

    //
    // Get device install parameter.
    //

    spDeviceInstallParams.cbSize = sizeof (SP_DEVINSTALL_PARAMS);
    if (!SetupDiGetDeviceInstallParams (m_hDevInfo, m_pspDevInfoData, &spDeviceInstallParams)) {
        DebugTrace(TRACE_ERROR,(("CDevice::HandleFilesInstallation: ERROR!! SetupDiGetDeviceInstallParams() failed. Err=0x%x.\r\n"), GetLastError()));

        bRet = FALSE;
        goto HandleFilesInstallation_return;
    }

    //
    // Modify device installation parameters to have custom callback
    //

    pvContext = SetupInitDefaultQueueCallbackEx(NULL,
                                                (HWND)((spDeviceInstallParams.Flags & DI_QUIETINSTALL) ?INVALID_HANDLE_VALUE : NULL),
                                                0,
                                                0,
                                                NULL);
    if(NULL == pvContext){

        DebugTrace(TRACE_ERROR,(("CDevice::HandleFilesInstallation: ERROR!! SetupInitDefaultQueueCallbackEx() failed. Err=0x%x.\r\n"), GetLastError()));

        bRet = FALSE;
        goto HandleFilesInstallation_return;
    } // if(NULL == pvContext)

    pSavedCallback = spDeviceInstallParams.InstallMsgHandler;
    spDeviceInstallParams.InstallMsgHandler = StiInstallCallback;
    spDeviceInstallParams.InstallMsgHandlerContext = pvContext;

    bSetParamRet = SetupDiSetDeviceInstallParams (m_hDevInfo,
                                                  m_pspDevInfoData,
                                                  &spDeviceInstallParams);

    if(FALSE == bSetParamRet){
        DebugTrace(TRACE_ERROR,(("CDevice::HandleFilesInstallation: ERROR!! SetupDiSetDeviceInstallParams() failed. Err=0x%x.\r\n"), GetLastError()));

        bRet = FALSE;
        goto HandleFilesInstallation_return;
    } // if(FALSE == bSetParamRet)

    //
    // Let the default installer do its job.
    //

    if(IsInterfaceOnlyDevice()){
        bRet = CreateDeviceInterfaceAndInstall();
    } else {
        bRet = SetupDiInstallDevice(m_hDevInfo, m_pspDevInfoData);
    }
    if(FALSE == bRet){
        DebugTrace(TRACE_ERROR,(("CDevice::HandleFilesInstallation: ERROR!! SetupDiInstallDevice() failed. Err=0x%x.\r\n"), GetLastError()));

        bRet = FALSE;
        goto HandleFilesInstallation_return;
    } // if(FALSE == bSetParamRet)

    //
    // Terminate defaule queue callback
    //

    SetupTermDefaultQueueCallback(pvContext);

    //
    // Cleanup.
    //

    if (bSetParamRet) {
        spDeviceInstallParams.InstallMsgHandler = pSavedCallback;
        SetupDiSetDeviceInstallParams (m_hDevInfo, m_pspDevInfoData, &spDeviceInstallParams);
    }

HandleFilesInstallation_return:

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::HandleFilesInstallation: Leaving... Ret=0x%x.\r\n"), bRet));
    return bRet;

} // CDevice::HandleFilesInstallation()


BOOL
CDevice::UpdateDeviceRegistry(
    VOID
    )
{
    BOOL    bRet;
    HKEY    hkDrv;
    DWORD   dwConnectionType;
    HINF    hInf;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::UpdateDeviceRegistry: Enter... \r\n")));

    //
    // Initialize Local.
    //

    bRet                = FALSE;
    hkDrv               = NULL;
    dwConnectionType    = STI_HW_CONFIG_UNKNOWN;

    //
    // Open INF.
    //

    hInf = SetupOpenInfFile(m_csInf,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);

    if (hInf == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR, (("CDevice::UpdateDeviceRegistry: Unable to open INF(%ws). Error = 0x%x.\r\n"),m_csInf, GetLastError()));

        bRet = FALSE;
        goto UpdateDeviceRegistry_return;
    } // if (hInf == INVALID_HANDLE_VALUE)

    //
    // Create device registry key.
    //

    if(IsInterfaceOnlyDevice()){

        DebugTrace(TRACE_STATUS,(("CDevice::UpdateDeviceRegistry: This is Interface-only device.\r\n")));

        //
        // Create interface reg-key.
        //

        hkDrv = m_hkInterfaceRegistry;

    } else { // if(IsInterfaceOnlyDevice())

        DebugTrace(TRACE_STATUS,(("CDevice::UpdateDeviceRegistry: This is devnode device.\r\n")));

        hkDrv = SetupDiCreateDevRegKey(m_hDevInfo,
                                       m_pspDevInfoData,
                                       DICS_FLAG_GLOBAL,
                                       0,
                                       DIREG_DRV,
                                       NULL,
                                       NULL);
    } // if(IsInterfaceOnlyDevice())
    if(hkDrv == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("CDevice::UpdateDeviceRegistry: ERROR!! SetupDiCreateDevRegKey() failed. Err=0x%x.\r\n"), GetLastError()));

        bRet = FALSE;
        goto UpdateDeviceRegistry_return;
    } //if(hkDrv == INVALID_HANDLE_VALUE)

    //
    // Save INF parameters to registry.
    //

    if(m_csPort.IsEmpty()){
        if(m_bInterfaceOnly){

            //
            // If PortName doesn't exist for interface-only device, then use symbolic link as CraeteFile name.
            //

            m_csSymbolicLink.Store(hkDrv, CREATEFILENAME);
        } //if(m_bInterfaceOnly)
    } else { // if(m_csPort.IsEmpty())
        m_csPort.Store(hkDrv, CREATEFILENAME);
    } // if(m_csPort.IsEmpty())

    m_csSubClass.Store(hkDrv, SUBCLASS);
    m_csUSDClass.Store(hkDrv, USDCLASS);
    m_csVendor.Store(hkDrv, VENDOR);
    m_csFriendlyName.Store(hkDrv, FRIENDLYNAME);
    m_csUninstallSection.Store(hkDrv, UNINSTALLSECTION);
    m_csPropPages.Store(hkDrv, PROPERTYPAGES);
    m_csIcmProfile.Store(hkDrv, ICMPROFILES);
    m_csDeviceID.Store(hkDrv, REGSTR_VAL_DEVICE_ID);
    m_csPortSelect.Store (hkDrv, PORTSELECT);


    if(IsInterfaceOnlyDevice()){
        m_csInf.Store(hkDrv, INFPATH);
        m_csInstallSection.Store(hkDrv, INFSECTION);
        m_csDriverDescription.Store(hkDrv, DRIVERDESC);
    } // if(IsInterfaceOnlyDevice())

    //
    // Save DWORD values.
    //

    RegSetValueEx(hkDrv,
                  CAPABILITIES,
                  0,
                  REG_DWORD,
                  (LPBYTE) &m_dwCapabilities,
                  sizeof(m_dwCapabilities));

    RegSetValueEx(hkDrv,
                  DEVICETYPE,
                  0,
                  REG_DWORD,
                  (LPBYTE) &m_dwDeviceType,
                  sizeof(m_dwDeviceType));

    RegSetValueEx(hkDrv,
                  DEVICESUBTYPE,
                  0,
                  REG_DWORD,
                  (LPBYTE) &m_dwDeviceSubType,
                  sizeof(m_dwDeviceSubType));

    RegSetValueEx(hkDrv,
                  ISPNP,
                  0,
                  REG_DWORD,
                  (LPBYTE) &m_bIsPnP,
                  sizeof(m_bIsPnP));

    //
    // Set HardwareConfig. (= Connection)
    //

    if(!m_csConnection.IsEmpty()){

        m_csConnection.Store (hkDrv, CONNECTION);

        if(_tcsicmp(m_csConnection, SERIAL) == 0 ){
            dwConnectionType = STI_HW_CONFIG_SERIAL;
        }
        else if(_tcsicmp(m_csConnection, PARALLEL) == 0 ){
            dwConnectionType = STI_HW_CONFIG_PARALLEL;
        }

        if (dwConnectionType != STI_HW_CONFIG_UNKNOWN) {
            RegSetValueEx(hkDrv,
                          REGSTR_VAL_HARDWARE,
                          0,
                          REG_DWORD,
                          (LPBYTE) &dwConnectionType,
                          sizeof(dwConnectionType));
        }
    } // if(!m_csConneciton.IsEmpty())

    //
    // Process DeviceData section.
    //

    ProcessDataSection(hInf, hkDrv);

    //
    // Process Event section.
    //

    ProcessEventsSection(hInf, hkDrv);

    //
    // Create registry key for video key if applicable.
    //

    ProcessVideoDevice(hkDrv);

    //
    // Operation succeeded.
    //

    bRet = TRUE;

UpdateDeviceRegistry_return:

    //
    // Cleanup.
    //

    if(hkDrv != INVALID_HANDLE_VALUE){
        RegCloseKey(hkDrv);
        m_hkInterfaceRegistry = NULL;
    }

    if(hInf != INVALID_HANDLE_VALUE){
        SetupCloseInfFile(hInf);
    }


    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::UpdateDeviceRegistry: Leaving... Ret=0x%x.\r\n"), bRet));
    return bRet;
} // CDevice::UpdateDeviceRegistry()


VOID
CDevice::ProcessVideoDevice(
    HKEY        hkDrv
    )
{

    GUID                                Guid;
    HKEY                                hkDeviceData;
    TCHAR                               Buffer[1024];
    SP_DEVICE_INTERFACE_DATA            spDevInterfaceData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pspDevInterfaceDetail;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::ProcessVideoDevice: Enter... \r\n")));

    //
    // Initialize local.
    //

     Guid                   = KSCATEGORY_CAPTURE;
     pspDevInterfaceDetail  = NULL;
     hkDeviceData           = NULL;

     memset(&spDevInterfaceData, 0, sizeof(spDevInterfaceData));
     memset(Buffer, 0, sizeof(Buffer));

    //
    // This is only for video devices.
    //

    if (!m_bVideoDevice) {
        DebugTrace(TRACE_STATUS,(("CDevice::ProcessVideoDevice: This is not a video device. Do nothing.\r\n")));
        goto ProcessVideoDevice_return;
    }

    //
    // Use "AUTO" as dummy CreatFile name for Video devices.
    //

    RegSetValueEx( hkDrv,
                   CREATEFILENAME,
                   0,
                   REG_SZ,
                   (LPBYTE)AUTO,
                   (lstrlen(AUTO)+1)*sizeof(TCHAR)
                  );

    //
    // Get device interface data of installing Video device.
    //

    spDevInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
    if (!SetupDiEnumDeviceInterfaces (m_hDevInfo,
                                      m_pspDevInfoData,
                                      &Guid,
                                      0,
                                      &spDevInterfaceData
                                      ) )
    {
        DebugTrace(TRACE_ERROR,(("ProcessVideoDevice: ERROR!!SetupDiEnumDeviceInterfaces failed. Err=0x%x \r\n"), GetLastError()));
        goto ProcessVideoDevice_return;
    }

    //
    // Get detailed data of acquired interface.
    //

    pspDevInterfaceDetail = (PSP_DEVICE_INTERFACE_DETAIL_DATA)Buffer;
    pspDevInterfaceDetail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
    if (!SetupDiGetDeviceInterfaceDetail (m_hDevInfo,
                                          &spDevInterfaceData,
                                          pspDevInterfaceDetail,
                                          sizeof(Buffer) - sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA),
                                          NULL,
                                          NULL) )
    {
        DebugTrace(TRACE_ERROR,(("ProcessVideoDevice: ERROR!!SetupDiGetDeviceInterfaceDetail failed. Err=0x%x \r\n"), GetLastError()));
        goto ProcessVideoDevice_return;
    }

    //
    // We got the device path, now write it to registry
    //

    if (ERROR_SUCCESS != RegOpenKey(hkDrv, DEVICESECTION, &hkDeviceData)) {
        DebugTrace(TRACE_ERROR,(("ProcessVideoDevice: ERROR!! Unable to open DeviceData key. Err=0x%x \r\n"), GetLastError()));
        goto ProcessVideoDevice_return;
    }

    RegSetValueEx(hkDeviceData,
                  VIDEO_PATH_ID,
                  0,
                  REG_SZ,
                  (LPBYTE)pspDevInterfaceDetail->DevicePath,
                  (lstrlen(pspDevInterfaceDetail->DevicePath)+1)*sizeof(TCHAR) );

ProcessVideoDevice_return:

    //
    // Cleanup.
    //

    if(NULL != hkDeviceData){
        RegCloseKey(hkDeviceData);
    }

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::ProcessVideoDevice: Leaving... Ret=VOID.\r\n")));
    return;
} // CDevice::ProcessVideoDevice()


VOID
CDevice::ProcessEventsSection(
    HINF        hInf,
    HKEY        hkDrv
    )
/*++

Routine Description:

Arguments:

Return Value:

Side effects:

--*/
{

    CString csFriendlyName;
    CString csRegisteredApp;
    CString csGuid;

    HKEY    hkEvents;
    HKEY    hkEventPod;

    INFCONTEXT InfContext;
    UINT    uiLineIndex = 0;

    BOOL    fRet = TRUE;
    BOOL    fLooping = TRUE;

    TCHAR   pKeyName[LINE_LEN ];
    TCHAR   pField [MAX_INF_STRING_LENGTH];
    TCHAR   pTypeField[LINE_LEN];

    DWORD   dwKeySize = LINE_LEN;
    DWORD   dwFieldSize = MAX_INF_STRING_LENGTH;

    DWORD   dwError = 0;
    DWORD   dwFieldIndex = 0;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::ProcessEventsSection: Enter... \r\n")));

    if (!m_csEventSection.IsEmpty()) {

        // First create device data subkey
        dwError = RegCreateKey(hkDrv, EVENTS, &hkEvents);

        if ( NOERROR == dwError ) {

            fLooping = SetupFindFirstLine(hInf,
                                      (LPCTSTR) m_csEventSection,
                                      NULL,
                                      &InfContext
                                      );
            while (fLooping) {


                ::ZeroMemory(pKeyName, sizeof(pKeyName));
                ::ZeroMemory(pField, sizeof(pField));
                ::ZeroMemory(pTypeField, sizeof(pTypeField) );


                // Get key name as zero-based indexed field
                dwFieldIndex = 0;
                dwKeySize = sizeof(pKeyName) / sizeof(TCHAR);

                fRet = SetupGetStringField(&InfContext,
                                           dwFieldIndex,
                                           pKeyName,
                                           dwKeySize,
                                           NULL);

                dwError = ::GetLastError();
                if (!fRet) {
                    // Didn't get key name - move to the next
                    DebugTrace(TRACE_ERROR,(("CDevice::ProcessEventsSection: ERROR!! Failed to get key name. Error=0x%x. \r\n"), dwError));
                    fLooping = SetupFindNextLine(&InfContext,&InfContext);
                    continue;
                }

                // Get friendly name  field
                dwFieldIndex = 1;
                dwFieldSize = sizeof(pField) / sizeof(TCHAR);

                fRet = SetupGetStringField(&InfContext,
                                           dwFieldIndex,
                                           pField,
                                           dwFieldSize,
                                           NULL);

                dwError = ::GetLastError();
                if (!fRet ) {
                    // Didn't get name - move to the next
                    DebugTrace(TRACE_ERROR,(("CDevice::ProcessEventsSection: ERROR!! Failed to get field [%d]. Error=0x%x. \r\n"), dwFieldIndex, dwError));
                    fLooping = SetupFindNextLine(&InfContext,&InfContext);
                    continue;
                }

                csFriendlyName = pField;

                // Get GUID field
                dwFieldIndex = 2;
                dwFieldSize = sizeof(pField) / sizeof(TCHAR);

                fRet = SetupGetStringField(&InfContext,
                                           dwFieldIndex,
                                           pField,
                                           dwFieldSize,
                                           NULL);

                dwError = ::GetLastError();
                if (!fRet ) {
                    // Didn't get GUID - move to the next line
                    DebugTrace(TRACE_ERROR,(("CDevice::ProcessEventsSection: ERROR!! Failed to get field [%d]. Error=0x%x. \r\n"), dwFieldIndex, dwError));
                    fLooping = SetupFindNextLine(&InfContext,&InfContext);
                    continue;
                }

                csGuid = pField;

                // Get registered app  field
                dwFieldIndex = 3;
                dwFieldSize = sizeof(pField) / sizeof(TCHAR);

                fRet = SetupGetStringField(&InfContext,
                                           3,
                                           pField,
                                           dwFieldSize,
                                           NULL);

                dwError = ::GetLastError();
                if (fRet ) {
//                    DebugTrace(TRACE_ERROR,(("CDevice::ProcessEventsSection: ERROR!! Failed to get field [%d]. Error=0x%x. \r\n"), dwFieldIndex, dwError));
                    csRegisteredApp = pField;
                }
                else {
                    // Didn't get key type - use widlcard by default
                    csRegisteredApp = TEXT("*");
                }

                // Now only if we have all needed values - save to the registry
                if (RegCreateKey(hkEvents, pKeyName, &hkEventPod) == NO_ERROR) {

                    // Event friendly name  store as default value
                    csFriendlyName.Store (hkEventPod, TEXT(""));

                    csGuid.Store (hkEventPod, SZ_GUID);

                    csRegisteredApp.Store (hkEventPod, LAUNCH_APP);

                    RegCloseKey (hkEventPod);
                } else {
                    // Couldn't create event key - bad
                    DebugTrace(TRACE_ERROR,(("CDevice::ProcessEventsSection: ERROR!! Unable to create RegKey. Error=0x%x.\r\n"), GetLastError()));
                }

                // Move to the next line finally
                fLooping = SetupFindNextLine(&InfContext,&InfContext);
            }

            RegCloseKey (hkEvents);

        } else {
            DebugTrace(TRACE_ERROR,(("CDevice::ProcessEventsSection: ERROR!! Unable to create event RegKey. Error=0x%x.\r\n"), GetLastError()));
        }
    }
// ProcessEventsSection_return:

    //
    // Cleanup.
    //

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::ProcessEventsSection: Leaving... Ret=VOID.\r\n")));
    return;
} // CDevice::ProcessEventsSection()

VOID
CDevice::ProcessDataSection(
    HINF        hInf,
    HKEY        hkDrv
)
/*++

Routine Description:

Arguments:

Return Value:

Side effects:

--*/
{
    CString                 csTempValue;
    HKEY                    hkDeviceData;
    INFCONTEXT              InfContext;
    BOOL                    fRet;
    BOOL                    fLooping;
    TCHAR                   pKeyName[LINE_LEN];
    TCHAR                   pField[MAX_INF_STRING_LENGTH];
    TCHAR                   pTypeField[LINE_LEN];
    UINT                    uiLineIndex;
    DWORD                   dwKeySize;
    DWORD                   dwFieldSize;
    DWORD                   dwError;
    DWORD                   dwFieldIndex;
    PSECURITY_DESCRIPTOR    pSecurityDescriptor;
    BOOL                    bDaclExisting;
    BOOL                    bDaclDefaulted;
    PACL                    pDacl;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::ProcessDataSection: Enter... \r\n")));

    //
    // Initialize local.
    //

    hkDeviceData                = (HKEY)INVALID_HANDLE_VALUE;
    uiLineIndex                 = 0;
    fRet                        = TRUE;
    fLooping                    = TRUE;
    dwKeySize                   = LINE_LEN;
    dwFieldSize                 = MAX_INF_STRING_LENGTH;
    dwError                     = 0;
    dwFieldIndex                = 0;
    pSecurityDescriptor         = NULL;
    pDacl                       = NULL;
    bDaclExisting               = FALSE;
    bDaclDefaulted              = FALSE;

    memset(&InfContext, 0, sizeof(InfContext));
    memset(pKeyName, 0, sizeof(pKeyName));
    memset(pField, 0, sizeof(pField));
    memset(pTypeField, 0, sizeof(pTypeField));

    if (!m_csDataSection.IsEmpty()) {

        // First create device data subkey
        dwError = RegCreateKey(hkDrv, DEVICESECTION, &hkDeviceData);

        if ( NOERROR == dwError ) {
            
            //
            // Get a DACL for LS full access.
            //
            
            fRet = ConvertStringSecurityDescriptorToSecurityDescriptor(TEXT("D:(A;CIOI;GA;;;LS)"),
                                                                       SDDL_REVISION_1,
                                                                       &pSecurityDescriptor,
                                                                       NULL);
            if( (TRUE != fRet) 
             || (NULL == pSecurityDescriptor) )
            {
                DebugTrace(TRACE_ERROR, (("CDevice::ProcessDataSection: Unable to get SD. Err=0x%x.\r\n"),GetLastError()));
                goto ProcessDataSection_return;
            } // if( (TRUE != fRet) || (NULL == pSecurityDescriptor)
            
            if(!GetSecurityDescriptorDacl(pSecurityDescriptor,
                                          &bDaclExisting,
                                          &pDacl,
                                          &bDaclDefaulted))
            {
                DebugTrace(TRACE_ERROR, (("CDevice::ProcessDataSection: GetSecurityDescriptorDacl() failed. Err=0x%x.\r\n"),GetLastError()));
                goto ProcessDataSection_return;
            } // if(!GetSecurityDescriptorDacl()
            
            //
            // Add LocalService to ACL.
            //
            
            dwError = SetSecurityInfo(hkDeviceData,
                                      SE_REGISTRY_KEY,
                                      DACL_SECURITY_INFORMATION,
                                      NULL,
                                      NULL,
                                      pDacl,
                                      NULL);
            if(ERROR_SUCCESS != dwError){
                DebugTrace(TRACE_ERROR, (("CDevice::ProcessDataSection: Failed to get key name. Error = 0x%x.\r\n"),dwError));
                goto ProcessDataSection_return;
            } // if(ERROR_SUCCESS != dwError)

            // Seek to the first line of the section
            fLooping = SetupFindFirstLine(hInf,
                                      (LPCTSTR) m_csDataSection,
                                      NULL,
                                      &InfContext);

            while (fLooping) {

                dwKeySize = sizeof(pKeyName) / sizeof(TCHAR);

                ::ZeroMemory(pKeyName, sizeof(pKeyName));
                ::ZeroMemory(pField, sizeof(pField));
                ::ZeroMemory(pTypeField, sizeof(pTypeField) );


                dwFieldIndex = 0;

                // Get key name as zero-indexed field
                fRet = SetupGetStringField(&InfContext,
                                           dwFieldIndex,
                                           pKeyName,
                                           dwKeySize,
                                           &dwKeySize);

                dwError = ::GetLastError();
                if (!fRet) {
                    // Didn't get key name - move to the next
                    DebugTrace(TRACE_ERROR, (("CDevice::ProcessDataSection: Failed to get key name. Error = 0x%x.\r\n"),dwError));
                    fLooping = SetupFindNextLine(&InfContext,&InfContext);
                    continue;
                }

                // Get value field
                dwFieldIndex = 1;
                dwFieldSize = sizeof(pField) / sizeof(TCHAR);

                fRet = SetupGetStringField(&InfContext,
                                           dwFieldIndex,
                                           pField,
                                           dwFieldSize,
                                           NULL);

                dwError = ::GetLastError();
                if (!fRet ) {
                    // Didn't get key name - move to the next
                    DebugTrace(TRACE_ERROR, (("CDevice::ProcessDataSection: Failed to get field [%d]. Error = 0x%x.\r\n"),dwFieldIndex, dwError));
                    fLooping = SetupFindNextLine(&InfContext,&InfContext);
                    continue;
                }

                csTempValue = pField;
                // Get value field
                *pTypeField = TEXT('\0');
                dwFieldIndex = 2;
                dwFieldSize = sizeof(pTypeField) / sizeof(TCHAR);

                fRet = SetupGetStringField(&InfContext,
                                           dwFieldIndex,
                                           pTypeField,
                                           dwFieldSize,
                                           NULL);

                dwError = ::GetLastError();
                if (!fRet ) {
                    // Didn't get key type - assume string
                    *pTypeField = TEXT('\0');
                }

                // Now we have both type and value - save it in the registry
                csTempValue.Store (hkDeviceData, pKeyName,pTypeField );

                // Move to the next line finally
                fLooping = SetupFindNextLine(&InfContext,&InfContext);
            }

            //
            // Process migrating DeviceData section.
            //

            MigrateDeviceData(hkDeviceData, m_pExtraDeviceData, "");

            // Now clean up
            RegCloseKey (hkDeviceData);
            hkDeviceData = (HKEY)INVALID_HANDLE_VALUE;

        } else { // if ( NOERROR == dwError )
            DebugTrace(TRACE_ERROR, (("CDevice::ProcessDataSection: ERROR!! Unable to create DataSection RegKey. Error = 0x%x.\r\n"), dwError));
        } // if ( NOERROR == dwError )

    } // if (!m_csDataSection.IsEmpty())

ProcessDataSection_return:

    //
    // Cleanup.
    //

    if(IS_VALID_HANDLE(hkDeviceData)){
        RegCloseKey(hkDeviceData);
        hkDeviceData = (HKEY)INVALID_HANDLE_VALUE;
    } // if(IS_VALID_HANDLE(hkDeviceData))

    if(NULL != pSecurityDescriptor){
        LocalFree(pSecurityDescriptor);
        pSecurityDescriptor = NULL;
    } // if(NULL != pSecurityDescriptor))

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::ProcessDataSection: Leaving... Ret=VOID.\r\n")));
    return;
} // CDevice::ProcessDataSection()

VOID
CDevice::ProcessICMProfiles(
    VOID
)
/*++

Routine Description:

Arguments:

Return Value:

Side effects:

--*/
{

    DWORD           Idx;
    CStringArray    csaICMProfiles;
    TCHAR           szAnsiName[STI_MAX_INTERNAL_NAME_LENGTH];

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::ProcessICMProfiles: Enter... \r\n")));

    //
    // Initialize Local.
    //

    Idx = 0;

    memset(szAnsiName, 0, sizeof(szAnsiName));

    //
    // If section doesn't exist, just return.
    //

    if(m_csIcmProfile.IsEmpty()){
        goto ProcessICMProfiles_return;
    }

    //
    // Split a line to each token.
    //

    csaICMProfiles.Tokenize ((LPTSTR)m_csIcmProfile, FIELD_DELIMETER);

    //
    // Process all ICM profiles.
    //

    while ((LPTSTR)csaICMProfiles[Idx] != NULL) {

        DebugTrace(TRACE_STATUS,(("ProcessICMProfiles: Installing ICM profile%d(%ws) for %ws.\r\n"), Idx, (LPTSTR)csaICMProfiles[Idx], (LPTSTR)m_csDeviceID));

        //
        // Install color profile.
        //

        if (!InstallColorProfile (NULL, csaICMProfiles[Idx])) {
            DebugTrace(TRACE_ERROR,(("ProcessICMProfiles: ERROR!! InstallColorProfile failed. Err=0x%x \r\n"), GetLastError()));
        } // if (!InstallColorProfile (NULL, csaICMProfiles[Idx]))

        //
        // Register color profile with installing device.
        //

        if (!AssociateColorProfileWithDevice (NULL, csaICMProfiles[Idx], (LPTSTR)m_csDeviceID)) {
                    DebugTrace(TRACE_ERROR,(("ProcessICMProfiles: ERROR!! AssociateColorProfileWithDevice failed. Err=0x%x \r\n"), GetLastError()));        }

        //
        // Process next device.
        //

        Idx++;

    } // while ((LPTSTR)csaICMProfiles[Idx] != NULL)

ProcessICMProfiles_return:
    return;

} // CDevice::ProcessICMProfiles()


BOOL
CDevice::GetInfInforamtion(
    VOID
    )
{
    BOOL                    bRet;

    HINF                    hInf;
    SP_DRVINFO_DATA         DriverInfoData;
    PSP_DRVINFO_DETAIL_DATA pDriverInfoDetailData;
    TCHAR                   szInfSectionName[MAX_DESCRIPTION];
    DWORD                   dwSize;
    DWORD                   dwLastError;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::GetInfInforamtion: Enter... \r\n")));

    //
    // Initialize locals.
    //

    dwSize                  = 0;
    bRet                    = FALSE;
    hInf                    = INVALID_HANDLE_VALUE;
    dwLastError             = ERROR_SUCCESS;
    pDriverInfoDetailData   = NULL;

    memset (szInfSectionName, 0, sizeof(szInfSectionName));
    memset (&DriverInfoData, 0, sizeof(SP_DRVINFO_DATA));

    //
    // Get selected device driver information.
    //

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (!SetupDiGetSelectedDriver(m_hDevInfo, m_pspDevInfoData, &DriverInfoData)) {
        DebugTrace(TRACE_ERROR,(("CDevice::GetInfInforamtion: ERROR!! SetupDiGetSelectedDriver Failed. Err=0x%x\r\n"), GetLastError()));

        bRet = FALSE;
        goto GetInfInforamtion_return;
    }

    //
    // See required buffer size for driver detailed data.
    //

    SetupDiGetDriverInfoDetail(m_hDevInfo,
                               m_pspDevInfoData,
                               &DriverInfoData,
                               NULL,
                               0,
                               &dwSize);
    dwLastError = GetLastError();
    if(ERROR_INSUFFICIENT_BUFFER != dwLastError){
        DebugTrace(TRACE_ERROR,(("CDevice::GetInfInforamtion: ERROR!! SetupDiGetDriverInfoDetail doesn't return required size.Er=0x%x\r\n"),dwLastError));

        bRet = FALSE;
        goto GetInfInforamtion_return;
    }

    //
    // Allocate required size of buffer for driver detailed data.
    //

    pDriverInfoDetailData   = (PSP_DRVINFO_DETAIL_DATA)new char[dwSize];
    if(NULL == pDriverInfoDetailData){
        DebugTrace(TRACE_ERROR,(("CDevice::GetInfInforamtion: ERROR!! Unable to allocate driver detailed info buffer.\r\n")));

        bRet = FALSE;
        goto GetInfInforamtion_return;
    }

    //
    // Initialize allocated buffer.
    //

    memset(pDriverInfoDetailData, 0, dwSize);
    pDriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

    //
    // Get detailed data of selected device driver.
    //

    if(!SetupDiGetDriverInfoDetail(m_hDevInfo,
                                   m_pspDevInfoData,
                                   &DriverInfoData,
                                   pDriverInfoDetailData,
                                   dwSize,
                                   NULL) )
    {
        DebugTrace(TRACE_ERROR,(("CDevice::GetInfInforamtion: ERROR!! SetupDiGetDriverInfoDetail Failed.Er=0x%x\r\n"),GetLastError()));

        bRet = FALSE;
        goto GetInfInforamtion_return;
    }

    //
    // Open INF file of selected driver.
    //

    hInf = SetupOpenInfFile(pDriverInfoDetailData->InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);
    if (hInf == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("CDevice::GetInfInforamtion: ERROR!! SetupOpenInfFile Failed.Er=0x%x\r\n"),GetLastError()));

        bRet = FALSE;
        goto GetInfInforamtion_return;
    }

    //
    // Get actual INF section name to be installed.
    //

    if (!SetupDiGetActualSectionToInstall(hInf,
                                          pDriverInfoDetailData->SectionName,
                                          szInfSectionName,
                                          sizeof(szInfSectionName)/sizeof(TCHAR),
                                          NULL,
                                          NULL) )
    {
        DebugTrace(TRACE_ERROR,(("CDevice::GetInfInforamtion: ERROR!! SetupDiGetActualSectionToInstall Failed.Er=0x%x\r\n"),GetLastError()));

        bRet = FALSE;
        goto GetInfInforamtion_return;
    }

    //
    // Set Inf section/file name.
    //

    m_csInf             = pDriverInfoDetailData->InfFileName;
    m_csInstallSection  = szInfSectionName;

    DebugTrace(TRACE_STATUS,(("CDevice::GetInfInforamtion: INF Filename    : %ws\n"),(LPTSTR)m_csInf));
    DebugTrace(TRACE_STATUS,(("CDevice::GetInfInforamtion: INF Section name: %ws\n"),(LPTSTR)m_csInstallSection));

    //
    // Operation succeeded.
    //

    bRet = TRUE;

GetInfInforamtion_return:

    //
    // Clean up.
    //

    if(INVALID_HANDLE_VALUE != hInf){
        SetupCloseInfFile(hInf);
    }

    if(NULL != pDriverInfoDetailData){
        delete[] pDriverInfoDetailData;
    }

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::GetInfInforamtion: Leaving... Ret=0x%x\n"), bRet));
    return bRet;
} // CDevice::GetInfInforamtion()


VOID
CDevice::SetPort(
    LPTSTR              szPortName
    )
{
    DebugTrace(TRACE_STATUS,(("CDevice::SetPort: Current Portname=%ws\n"), szPortName));

    //
    // Set PortName.
    //

    m_csPort = szPortName;

} // CDevice::SetPort()

VOID    
CDevice::SetFriendlyName(
    LPTSTR szFriendlyName
    )
    //
    //  Note:
    //  Before calling this function, caller has to make sure mutex is acquired.
    //
{
    HKEY    hkNameStore;

    //
    // Mutex must have been acquired before this call.
    //

    DebugTrace(TRACE_STATUS,(("CDevice::SetFriendlyName: Current CreateFileName=%ws\n"), szFriendlyName));

    //
    // Delete stored entry, create new one.
    //

    if(ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_INSTALL_NAMESTORE, &hkNameStore)){
        HKEY    hkTemp;

        hkTemp = (HKEY)INVALID_HANDLE_VALUE;
        
        //
        // Delete FriendlyName and DeviceId in name store.
        //

        RegDeleteKey(hkNameStore, m_csFriendlyName);
        if(ERROR_SUCCESS == RegCreateKey(hkNameStore, szFriendlyName, &hkTemp)){
            RegCloseKey(hkTemp);
        } // if(ERROR_SUCCESS == RegCreateKey(hkNameStore, szFriendlyName, &hkTemp))
        RegCloseKey(hkNameStore);
    } // if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, REGKEY_INSTALL_NAMESTORE, &hkNameStore))

    //
    // Set PortName.
    //

    m_csFriendlyName = szFriendlyName;

} // CDevice::SetPort()

VOID
CDevice::SetDevnodeSelectCallback(
    DEVNODESELCALLBACK  pfnDevnodeSelCallback
    )
{
    DebugTrace(TRACE_STATUS,(("CDevice::SetDevnodeSelectCallback: Current PortselCallback=0x%x\n"), pfnDevnodeSelCallback));

    //
    // Set SetPortselCallBack.
    //

    m_pfnDevnodeSelCallback = pfnDevnodeSelCallback;

    //
    // This is "interface-only" device.
    //

    m_bInterfaceOnly        = TRUE;

} // CDevice::SetDevnodeSelectCallback()

BOOL
CDevice::CreateDeviceInterfaceAndInstall(
    VOID
    )
{
    BOOL                                bRet;
    HKEY                                hkDrv;
    GUID                                Guid;
    HDEVINFO                            hDevInfo;
    SP_DEVINFO_DATA                     spDevInfoData;
    SP_DEVICE_INTERFACE_DATA            spDevInterfaceData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pspDevInterfaceDetailData;
    HINF                                hInf;
    BOOL                                bUseDefaultDevInfoSet;
    DWORD                               dwRequiredSize;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::CreateDeviceInterfaceAndInstall: Enter....\r\n")));

    //
    // Initialize local.
    //

    bRet                        = FALSE;
    hInf                        = INVALID_HANDLE_VALUE;
    hDevInfo                    = INVALID_HANDLE_VALUE;
    Guid                        = GUID_DEVCLASS_IMAGE;
    bUseDefaultDevInfoSet       = TRUE;
    dwRequiredSize              = 0;
    pspDevInterfaceDetailData   = NULL;

    //
    // Get devnode to create interface on.
    //

    if(NULL != m_pfnDevnodeSelCallback){
        if( (FALSE == m_pfnDevnodeSelCallback(m_csPort, &hDevInfo, &spDevInfoData))
         || (INVALID_HANDLE_VALUE == hDevInfo) )
        {
            DebugTrace(TRACE_ERROR,(("CDevice::CreateDeviceInterfaceAndInstall: m_pfnDevnodeSelCallback failed. Err=0x%x.\r\n"),GetLastError()));

            bRet = FALSE;
            goto CreateDeviceInterfaceAndInstall_return;
        }

        //
        // Devnode selector functions.
        //

        bUseDefaultDevInfoSet = FALSE;

    } else { // if(NULL != m_pfnDevnodeSelCallback)

        //
        // Use default device info set if available.
        //

        if( (INVALID_HANDLE_VALUE == m_hDevInfo)
         || (NULL == m_pspDevInfoData) )
        {
            DebugTrace(TRACE_ERROR,(("CDevice::CreateDeviceInterfaceAndInstall: Invalid Device info and no m_pfnDevnodeSelCallback.\r\n")));

            bRet = FALSE;
            goto CreateDeviceInterfaceAndInstall_return;
        } else {
            hDevInfo = m_hDevInfo;
            spDevInfoData = *m_pspDevInfoData;
        }
    } // if(NULL != m_pfnDevnodeSelCallback)

    //
    // Create Interface (SoftDevice). Use FriendlyName ad ref-string.
    //

    DebugTrace(TRACE_STATUS,(("CDevice::CreateDeviceInterfaceAndInstall: Creating interface for %ws.\r\n"), (LPTSTR)m_csFriendlyName));

    spDevInterfaceData.cbSize = sizeof(spDevInterfaceData);
    if(!SetupDiCreateDeviceInterface(hDevInfo,
                                     &spDevInfoData,
                                     &Guid,
                                     m_csFriendlyName,
                                     0,
                                     &spDevInterfaceData))
    {
        DebugTrace(TRACE_ERROR,(("CDevice::CreateDeviceInterfaceAndInstall: SetupDiCreateInterface failed. Err=0x%x.\r\n"),GetLastError()));

        bRet = FALSE;
        goto CreateDeviceInterfaceAndInstall_return;
    }

    //
    // Get symbolic link of created interface.
    //

    SetupDiGetDeviceInterfaceDetail(hDevInfo,
                                    &spDevInterfaceData,
                                    NULL,
                                    0,
                                    &dwRequiredSize,
                                    NULL);
    if(0 == dwRequiredSize){
        DebugTrace(TRACE_ERROR,(("CDevice::CreateDeviceInterfaceAndInstall: Unable to get required size for InterfaceDetailedData. Err=0x%x.\r\n"),GetLastError()));

        bRet = FALSE;
        goto CreateDeviceInterfaceAndInstall_return;
    } // if(0 == dwRequiredSize)

    pspDevInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)new BYTE[dwRequiredSize];
    if(NULL == pspDevInterfaceDetailData){
        DebugTrace(TRACE_ERROR,(("CDevice::CreateDeviceInterfaceAndInstall: Unable to allocate buffer.\r\n")));

        bRet = FALSE;
        goto CreateDeviceInterfaceAndInstall_return;
    } // if(NULL == pspDevInterfaceDetailData)

    pspDevInterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
    if(!SetupDiGetDeviceInterfaceDetail(hDevInfo,
                                        &spDevInterfaceData,
                                        pspDevInterfaceDetailData,
                                        dwRequiredSize,
                                        &dwRequiredSize,
                                        NULL))
    {
        DebugTrace(TRACE_ERROR,(("CDevice::CreateDeviceInterfaceAndInstall: SetupDiGetDeviceInterfaceDetail() failed. Err=0x%x.\r\n"),GetLastError()));

        bRet = FALSE;
        goto CreateDeviceInterfaceAndInstall_return;

    } // if(!SetupDiGetDeviceInterfaceDetail(

    m_csSymbolicLink = pspDevInterfaceDetailData->DevicePath;

    //
    // Open INF file handle for registry creation.
    //

    hInf = SetupOpenInfFile(m_csInf,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);

    if(INVALID_HANDLE_VALUE == hInf){
        DebugTrace(TRACE_ERROR,(("CDevice::CreateDeviceInterfaceAndInstall: SetupOpenInfFile failed. Err=0x%x.\r\n"),GetLastError()));

        bRet = FALSE;
        goto CreateDeviceInterfaceAndInstall_return;
    } // if(INVALID_HANDLE_VALUE == hInf)

     if(!SetupOpenAppendInfFile(NULL, hInf, NULL)){
        DebugTrace(TRACE_WARNING,(("CDevice::CreateDeviceInterfaceAndInstall: SetupOpenAppendInfFile() failed. Err=0x%x.\r\n"),GetLastError()));
     } // if(!SetupOpenAppendInfFile(NULL, hInf, NULL))

    //
    // Create Interface Registry and keep its handle, it's hard to find it later.
    //

    m_hkInterfaceRegistry = SetupDiCreateDeviceInterfaceRegKey(hDevInfo,
                                                               &spDevInterfaceData,
                                                               0,
                                                               KEY_ALL_ACCESS,
//                                                               NULL,
//                                                               NULL);
                                                               hInf,
                                                               (LPCTSTR)m_csInstallSection);
    if(INVALID_HANDLE_VALUE == m_hkInterfaceRegistry){
        DebugTrace(TRACE_ERROR,(("CDevice::CreateDeviceInterfaceAndInstall: SetupDiCreateDeviceInterfaceRegKey failed. Err=0x%x.\r\n"),GetLastError()));
        bRet = FALSE;
        goto CreateDeviceInterfaceAndInstall_return;
    } // if(INVALID_HANDLE_VALUE == m_hkInterfaceRegistry)

    //
    // Operation succeeded.
    //

    bRet = TRUE;

CreateDeviceInterfaceAndInstall_return:

    //
    // Clean up.
    //

    if(INVALID_HANDLE_VALUE != hDevInfo){
        if(FALSE == bUseDefaultDevInfoSet){

            //
            // Destroy created DevInfoSet.
            //

            SetupDiDestroyDeviceInfoList(hDevInfo);
        } // if(FALSE == bUseDefaultDevInfoSet)
    } // if(INVALID_HANDLE_VALUE != hDevInfo)

    if(INVALID_HANDLE_VALUE != hInf){
        SetupCloseInfFile(hInf);
    } // if(INVALID_HANDLE_VALUE != hInf)

    if(NULL != pspDevInterfaceDetailData){
        delete[] pspDevInterfaceDetailData;
    } // if(NULL != pspDevInterfaceDetailData)

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::CreateDeviceInterfaceAndInstall: Leaving... Ret=0x%x.\r\n"), bRet));

    return bRet;
} // CDevice::CreateDeviceInterfaceAndInstall()

DWORD
CDevice::GetPortSelectMode(
    VOID
    )
{
    DWORD    dwRet;
    
    //
    // Initialize local.
    //

    dwRet    = PORTSELMODE_NORMAL;
    
    //
    // Make sure INF is processed.
    //

    if(!PreprocessInf()){
        DebugTrace(TRACE_ERROR,(("CDevice::GetPortSelectMode: ERROR!! Unable to process INF.\r\n")));

        dwRet = PORTSELMODE_NORMAL;
        goto GetPortSelectMode_return;
    }

    //
    // If "PortSelect" is empty, use default.
    //

    if(m_csPortSelect.IsEmpty()){
        dwRet = PORTSELMODE_NORMAL;
        goto GetPortSelectMode_return;
    } // if(m_csPortSelect.IsEmpty())

    //
    // See if "PortSelect" directive is "no".
    //

    if(0 == MyStrCmpi(m_csPortSelect, NO)){

        //
        // Port Selection page should be skipped.
        //
        
        dwRet = PORTSELMODE_SKIP;
    } else if(0 == MyStrCmpi(m_csPortSelect, MESSAGE1)){

        //
        // System supplied message should be shown.
        //

        dwRet = PORTSELMODE_MESSAGE1;
    } else {

        //
        // Unsupported PortSel option.
        //
        
        dwRet = PORTSELMODE_NORMAL;
    }

GetPortSelectMode_return:

    return dwRet;
} // CDevice::GetPortSelectMode()

DWORD
CDevice::AcquireInstallerMutex(
    DWORD   dwTimeout
    )
{
    DWORD   dwReturn;
    
    //
    // Initialize local.
    //
    
    dwReturn    = ERROR_SUCCESS;
    
    if(NULL != m_hMutex){

        //
        // Mutex is already acquired.
        //
        
        DebugTrace(TRACE_WARNING,("WARNING!! AcquireInstallerMutex: Mutex acquired twice.\r\n"));
        dwReturn = ERROR_SUCCESS;
        goto AcquireInstallerMutex_return;

    } // if(INVALID_HANDLE_VALUE != m_hMutex)

    //
    // Acquire Mutex.
    //

    m_hMutex = CreateMutex(NULL, FALSE, WIAINSTALLERMUTEX);
    dwReturn = GetLastError();

    if(NULL == m_hMutex){

        //
        // CreteMutex() failed.
        //

        DebugTrace(TRACE_ERROR,("ERROR!! AcquireInstallerMutex: CraeteMutex() failed. Err=0x%x.\r\n", dwReturn));
        goto AcquireInstallerMutex_return;

    } // if(NULL == hMutex)

    //
    // Wait until ownership is acquired.
    //

    dwReturn = WaitForSingleObject(m_hMutex, dwTimeout);
    switch(dwReturn){
        case WAIT_ABANDONED:
            DebugTrace(TRACE_ERROR, ("CDevice::AcquireInstallerMutex: ERROR!! Wait abandoned.\r\n"));
            break;

        case WAIT_OBJECT_0:
            DebugTrace(TRACE_STATUS, ("CDevice::AcquireInstallerMutex: Mutex acquired.\r\n"));
            dwReturn = ERROR_SUCCESS;
            break;

        case WAIT_TIMEOUT:
            DebugTrace(TRACE_WARNING, ("CDevice::AcquireInstallerMutex: WARNING!! Mutex acquisition timeout.\r\n"));
            break;

        default:
            DebugTrace(TRACE_ERROR, ("CDevice::AcquireInstallerMutex: ERROR!! Unexpected error from WaitForSingleObjecct(). Err=0x%x.\r\n", dwReturn));
            break;
    } // switch(dwReturn)

AcquireInstallerMutex_return:

    DebugTrace(TRACE_PROC_LEAVE,("CDevice::AcquireInstallerMutex: Leaving... Ret=0x%x\n", dwReturn));
    return  dwReturn;

} // CDevice::AcquireInstallerMutex()

VOID
CDevice::ReleaseInstallerMutex(
    )
{
    if(NULL != m_hMutex){

        if(!ReleaseMutex(m_hMutex)){
            DebugTrace(TRACE_ERROR, ("CDevice::ReleaseInstallerMutex: ERROR!! Releasing mutex which not owned..\r\n"));
        } // if(!ReleaseMutex(m_hMutex))

        CloseHandle(m_hMutex);
        m_hMutex = NULL;
        DebugTrace(TRACE_STATUS, ("CDevice::ReleaseInstallerMutex: Mutex released.\r\n"));
    } // if(NULL != m_hMutex)
} // CDevice::ReleaseInstallerMutex()




UINT
CALLBACK
StiInstallCallback (
    PVOID    Context,
    UINT     Notification,
    UINT_PTR Param1,
    UINT_PTR Param2
    )

/*++

Routine Description:

    StiInstallCallback

    Callback routine used when calling SetupAPI file copying/installation functions

Arguments:

    Context -  our context
    Notification - notification message

Return Value:

    SetupAPI return code

Side effects:

    None

--*/
{

    UINT        uRet = FILEOP_COPY;

    DebugTrace(TRACE_PROC_ENTER,(("StiInstallCallback: Enter... \r\n")));

    //
    // Initialize local.
    //

    uRet = FILEOP_COPY;

    //
    // Dispatch notification code.
    //

    switch(Notification){

        case SPFILENOTIFY_ENDCOPY:
        {
            PFILEPATHS   pFilePathInfo;
            HKEY        hKey;
            DWORD       dwDisposition;
            DWORD       dwRefCount;
            DWORD       dwType;
            UINT        uSize;
            LONG        Status;

            uSize = sizeof(dwRefCount);
            pFilePathInfo = (PFILEPATHS)Param1;

            DebugTrace(TRACE_STATUS,(("StiInstallCallback:ENDCOPY FileTarget  %ws\r\n"), pFilePathInfo->Target));

            //
            // Open HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\SharedDlls
            //

            Status = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                    REGSTR_PATH_SHAREDDLL,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hKey,
                                    &dwDisposition);
            if(ERROR_SUCCESS != Status)
            {
                DebugTrace(TRACE_ERROR,(("StiInstallCallback: RegCreateKeyEx failed. Err=0x%x\r\n"), Status));
                break;
            }

            //
            // Retrieve reference count of this file
            //

            Status = RegQueryValueEx(hKey,
                                     pFilePathInfo->Target,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)&dwRefCount,
                                     (LPDWORD)&uSize);
            if(ERROR_SUCCESS != Status)
            {
                //
                // Value for this file hasn't been created, or error
                //

                DebugTrace(TRACE_ERROR,(("StiInstallCallback: Value for Ref-count doesn't exist\r\n")));
                dwRefCount = 0;
            }

            //
            // Increment reference count and set value
            //

            dwRefCount++;
            uSize = sizeof(dwRefCount);
            Status = RegSetValueEx(hKey,
                                   pFilePathInfo->Target,
                                   NULL,
                                   REG_DWORD,
                                   (CONST BYTE *)&dwRefCount,
                                   uSize);
            if(ERROR_SUCCESS != Status)
            {
                DebugTrace(TRACE_ERROR,(("StiInstallCallback: RegSetValueEx. Err=0x%x.\r\n"), Status));
            }

            DebugTrace(TRACE_STATUS,(("StiInstallCallback: ref-count of %ws is now 0x%x.\r\n"), pFilePathInfo->Target, dwRefCount));

            //
            // Close Registry key
            //

            RegCloseKey(hKey);

            Report(( TEXT("StiInstallCallback:%ws copied.\r\n"), pFilePathInfo->Target));
        } // case SPFILENOTIFY_ENDCOPY

        default:
            ;
    }

    uRet = SetupDefaultQueueCallback(Context,
                                    Notification,
                                    Param1,
                                    Param2);

    DebugTrace(TRACE_PROC_LEAVE,(("StiInstallCallback: Leaving... Ret=0x%x\n"), uRet));
    return uRet;
}

VOID
GetDeviceCount(
    DWORD   *pdwWiaCount,
    DWORD   *pdwStiCount
    )
/*++

Routine Description:

    GetDeviceCount

    Verifes if there is at least one STI device installed in a system

Arguments:

    bWia    - TRUE: Count WIA device

Return Value:

    Number of WIA device
    FALSE

--*/
{
    DWORD                       dwWiaCount;
    DWORD                       dwStiCount;
    BOOL                        fRet;
    CString                     csSubClass;
    DWORD                       dwCapabilities;
    GUID                        Guid;
    UINT                        Idx;
    DWORD                       dwRequired;
    DWORD                       dwError;
    HKEY                        hkThis;
    HKEY                        hkRun;
    HANDLE                      hDevInfo;
    SP_DEVINFO_DATA             spDevInfoData;
    SP_DEVICE_INTERFACE_DATA    spDevInterfaceData;

    DebugTrace(TRACE_PROC_ENTER,(("GetDeviceCount: Enter... \r\n")));

    //
    // Initialize local.
    //

    dwWiaCount      = 0;
    dwStiCount      = 0;
    fRet            = FALSE;
    Idx             = 0;
    dwRequired      = 0;
    dwError         = 0;
    hkThis          = NULL;
    hkRun           = NULL;
    hDevInfo        = NULL;
    dwCapabilities  = 0;

    memset(&spDevInfoData, 0, sizeof(spDevInfoData));
    memset(&spDevInterfaceData, 0, sizeof(spDevInterfaceData));

    //
    // Get WIA class guid.
    //

    SetupDiClassGuidsFromName (CLASSNAME, &Guid, sizeof(GUID), &dwRequired);

    //
    // Get device info set of all WIA devices (devnode).
    //

    hDevInfo = SetupDiGetClassDevs (&Guid,
                                    NULL,
                                    NULL,
                                    DIGCF_PROFILE
                                    );

    if (hDevInfo != INVALID_HANDLE_VALUE) {

        spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);

        for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++) {

           #if DEBUG
           CHAR   szDevDriver[STI_MAX_INTERNAL_NAME_LENGTH];
           ULONG       cbData;

           fRet = SetupDiGetDeviceRegistryProperty (hDevInfo,
                                                    &spDevInfoData,
                                                    SPDRP_DRIVER,
                                                    NULL,
                                                    (UCHAR *)szDevDriver, sizeof (szDevDriver),
                                                   &cbData);
            DebugTrace(TRACE_STATUS,(("GetDeviceCount: Checking device No%d(%ws)\r\n"), Idx, szDevDriver));
           #endif

           //
           // Verify device is not being removed
           //
           spDevInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
           spDevInterfaceData.InterfaceClassGuid = GUID_DEVCLASS_IMAGE;

           fRet = SetupDiEnumDeviceInterfaces (hDevInfo,
                                               NULL,
                                               &Guid,
                                               Idx,
                                               &spDevInterfaceData);

           dwError = GetLastError();

           if (fRet) {
               if (spDevInterfaceData.Flags & SPINT_REMOVED) {
                   continue;
               }
           }

            hkThis = SetupDiOpenDevRegKey(hDevInfo,
                                          &spDevInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DRV,
                                          KEY_READ );

            if (hkThis != INVALID_HANDLE_VALUE) {

                csSubClass.Load(hkThis, SUBCLASS);
                GetDwordFromRegistry(hkThis, CAPABILITIES, &dwCapabilities);

DebugTrace(TRACE_STATUS,(("GetDeviceCount: Capabilities=0x%x\n"), dwCapabilities));


                RegCloseKey(hkThis);

                if( (!csSubClass.IsEmpty())
                 && (0 == MyStrCmpi(csSubClass, STILL_IMAGE)) )
                {

                    //
                    // STI device found. Increse the counter.
                    //

                    dwStiCount++;

                    if(dwCapabilities & STI_GENCAP_WIA){

                        //
                        // WIA device found.
                        //

                            dwWiaCount++;

                    } // if(dwCapabilities & STI_GENCAP_WIA){

                } // if (!csSubClass.IsEmpty() && !lstrcmpi(csSubClass, STILL_IMAGE))
            } // if (hkThis != INVALID_HANDLE_VALUE)
        } // for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++)

        SetupDiDestroyDeviceInfoList(hDevInfo);
    } else {
        DebugTrace(TRACE_ERROR,(("GetDeviceCount: ERROR!! Unable to get device info set.\r\n")));
    } // if (hDevInfo != INVALID_HANDLE_VALUE)


    //
    // Get device info set of all WIA devices (interface).
    //

    hDevInfo = SetupDiGetClassDevs (&Guid,
                                    NULL,
                                    NULL,
                                    DIGCF_PROFILE |
                                    DIGCF_DEVICEINTERFACE
                                    );

    if (hDevInfo != INVALID_HANDLE_VALUE) {

        spDevInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
        for (Idx = 0; SetupDiEnumDeviceInterfaces (hDevInfo, NULL, &Guid, Idx, &spDevInterfaceData); Idx++) {

            DebugTrace(TRACE_STATUS,(("GetDeviceCount: Checking interface No%d.\r\n"), Idx));

            //
            // Verify device is not being removed
            //

            if (spDevInterfaceData.Flags & SPINT_REMOVED) {
                continue;
            }

            hkThis = SetupDiOpenDeviceInterfaceRegKey(hDevInfo,
                                                      &spDevInterfaceData,
                                                      0,
                                                      KEY_READ );

            if (hkThis != INVALID_HANDLE_VALUE) {
                csSubClass.Load(hkThis, SUBCLASS);
                GetDwordFromRegistry(hkThis, CAPABILITIES, &dwCapabilities);
                RegCloseKey(hkThis);

                if( (!csSubClass.IsEmpty())
                 && (0 == MyStrCmpi(csSubClass, STILL_IMAGE)) )
                {

                    //
                    // STI device found. Increse the counter.
                    //

                    dwStiCount++;

                    if(dwCapabilities & STI_GENCAP_WIA){

                        //
                        // WIA device found.
                        //

                            dwWiaCount++;

                    } // if(dwCapabilities & STI_GENCAP_WIA){
                } // if (!csSubClass.IsEmpty() && !lstrcmpi(csSubClass, STILL_IMAGE))
            } // if (hkThis != INVALID_HANDLE_VALUE)
        } // for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++)

        SetupDiDestroyDeviceInfoList(hDevInfo);
    } else { // if (hDevInfo != INVALID_HANDLE_VALUE)
        DebugTrace(TRACE_ERROR,(("GetDeviceCount: ERROR!! Unable to get device info set.\r\n")));
    } // if (hDevInfo != INVALID_HANDLE_VALUE)

    //
    // Copy the result.
    //

    *pdwWiaCount = dwWiaCount;
    *pdwStiCount = dwStiCount;

    DebugTrace(TRACE_PROC_LEAVE,(("GetDeviceCount: Leaving... STI=0x%x, WIA=0x%x.\r\n"), dwStiCount, dwWiaCount));
    return;
} // GetDeviceCount()



HANDLE
ExecCommandLine(
    LPTSTR  szCommandLine,
    DWORD   dwDirectory
    )
{
    HANDLE              hRet;
    BOOL                bSucceeded;
    CString             csCommandLine;
    TCHAR               szAppendDirectory[MAX_PATH+1];
    UINT                uiDirSize;
    PROCESS_INFORMATION pi;
    STARTUPINFO         si  = {
                   sizeof(si),              // cb
                   NULL,                    // lpReserved;
                   NULL,                    // lpDesktop;
                   NULL,                    // lpTitle;
                   0,                       // dwX;
                   0,                       // dwY;
                   0,                       // dwXSize;
                   0,                       // dwYSize;
                   0,                       // dwXCountChars;
                   0,                       // dwYCountChars;
                   0,                       // dwFillAttribute;
                   STARTF_FORCEONFEEDBACK,  // dwFlags;
                   SW_SHOWNORMAL,           // wShowWindow;
                   0,                       // cbReserved2;
                   NULL,                    // lpReserved2;
                   NULL,                    // hStdInput;
                   NULL,                    // hStdOutput;
                   NULL                     // hStdError;
                   };
    
    hRet = INVALID_HANDLE_VALUE;
    
    //
    // Get appending directory as needed.
    //
    
    memset(szAppendDirectory, 0, sizeof(szAppendDirectory));

    switch(dwDirectory){
        case EXECDIR_SYSTEM32:
        {
            uiDirSize = GetSystemDirectory(szAppendDirectory, ARRAYSIZE(szAppendDirectory)-1);
            if( (0 == uiDirSize)
             || (MAX_PATH < uiDirSize) )
            {
                DebugTrace(TRACE_ERROR,(("ExecCommandLine: ERROR!! Unable to get system directory. Err=0x%x.\r\n"), GetLastError()));
                hRet = INVALID_HANDLE_VALUE;
                goto ExecCommandLine_return;
            }
            
            break;
        } // case EXECDIR_SYSTEM32:
            
        default:
        {
            DebugTrace(TRACE_ERROR,(("ExecCommandLine: WARNING!! no valid directory (0x%x) specified.\r\n"), dwDirectory));
            hRet = INVALID_HANDLE_VALUE;
            goto ExecCommandLine_return;
        } // default:
//      case EXECDIR_WINDOWS:
//      case EXECDIR_SYSTEM:
    } // switch(dwDirectory)

    csCommandLine = szAppendDirectory;
    csCommandLine = csCommandLine + TEXT("\\");
    csCommandLine = csCommandLine + szCommandLine;

    bSucceeded = CreateProcess(NULL,                  // Application name
                               (LPTSTR)csCommandLine, // Command line
                               NULL,                  // Process attributes
                               NULL,                  // Thread attributes
                               FALSE,                 // Handle inheritance
                               NORMAL_PRIORITY_CLASS, // Creation flags
                               NULL,                  // Environment
                               NULL,                  // Current directory
                               &si,
                               &pi);

    if (bSucceeded) {
        hRet = pi.hProcess;
        CloseHandle(pi.hThread);
    } else {
        DebugTrace(TRACE_ERROR,(("ExecCommandLine: ERROR!! CreateProcess failed. Err=0x%x.\r\n"), GetLastError()));
    }

ExecCommandLine_return:
    return hRet;
}


PPARAM_LIST
MigrateDeviceData(
    HKEY        hkDeviceData,
    PPARAM_LIST pExtraDeviceData,
    LPSTR       pszKeyName
    )
{

    BOOL        bDone;
    PPARAM_LIST pCurrent;
    PPARAM_LIST pReturn;
    DWORD       dwType;
    DWORD       dwSize;
    PCHAR       pOrginalBuffer;
    CHAR        pCopyBuffer[MAX_PATH*3];
    CHAR        pDataBuffer[MAX_PATH];
    DWORD       Idx;

    //
    // Initialize local.
    //

    bDone       = FALSE;
    pCurrent    = pExtraDeviceData;
    pReturn     = NULL;
    
    //
    // Loop until it gets "END".
    //

    while(!bDone){

        if(NULL == pCurrent){
            
            //
            // Hit the end of list.
            //
            
            bDone = TRUE;
            pReturn =NULL;
            continue;

        } // if(NULL == pTemp)
        
        //
        // If "KeyName = END" is found, return.
        //

        if( (CSTR_EQUAL == CompareStringA(LOCALE_INVARIANT,NORM_IGNORECASE, pCurrent->pParam1, -1,pszKeyName,-1))
         && (CSTR_EQUAL == CompareStringA(LOCALE_INVARIANT,NORM_IGNORECASE, pCurrent->pParam2, -1,NAME_END_A,-1)) )
        {
            bDone   = TRUE;
            pReturn = (PPARAM_LIST)pCurrent->pNext;
            continue;
        }

        //
        // If 2nd parameter is "BEGIN", create subkey and call this function recursively.
        //

        if(CSTR_EQUAL == CompareStringA(LOCALE_INVARIANT,NORM_IGNORECASE, pCurrent->pParam2, -1,NAME_BEGIN_A,-1)){
            HKEY    hkSubKey;
            LONG    lError;
            
            lError = RegCreateKeyA(hkDeviceData, pCurrent->pParam1, &hkSubKey);
            if(ERROR_SUCCESS != lError){
                
                //
                // Unable to create subkey.
                //

                DebugTrace(TRACE_ERROR,(("MigrateDeviceData: ERROR!! Unable to create subkey..\r\n")));
                pReturn = NULL;
                goto MigrateDeviceData_return;
            } // if(ERROR_SUCCESS != lError)
            
            pCurrent = MigrateDeviceData(hkSubKey, (PPARAM_LIST)pCurrent->pNext, pCurrent->pParam1);
            RegCloseKey(hkSubKey);
            continue;
        } // if(0 == lstrcmpiA(pCurrent->pParam2, NAME_BEGIN_A))

        //
        // This is a set of value and data.
        //

        lstrcpyA(pCopyBuffer, pCurrent->pParam2);
        pOrginalBuffer = pCopyBuffer;
        
        //
        // Get key type.
        //

        pOrginalBuffer[8] = '\0';
        dwType = DecodeHexA(pOrginalBuffer);

        //
        // Get data.
        //
        
        Idx = 0;
        pOrginalBuffer+=9;

        while('\0' != *pOrginalBuffer){
            if('\0' != pOrginalBuffer[2]){
                pOrginalBuffer[2] = '\0';
                pDataBuffer[Idx++] = (CHAR)DecodeHexA(pOrginalBuffer);
                pOrginalBuffer+=3;
            } else {
                pDataBuffer[Idx++] = (CHAR)DecodeHexA(pOrginalBuffer);
                break;
            }
        } // while('\0' != pCurrent->pParam2[Idx])

        //
        // Create this value.
        //

        RegSetValueExA(hkDeviceData,
                      pCurrent->pParam1,
                      0,
                      dwType,
                      (PBYTE)pDataBuffer,
                      Idx);

        //
        // Process next line.
        //

        pCurrent = (PPARAM_LIST)pCurrent->pNext;

    } // while(!bDone)

MigrateDeviceData_return:
    return pReturn;
} // MigrateDeviceData()


DWORD   
DecodeHexA(
    LPSTR   lpstr
    ) 
{

    DWORD   dwReturn;

    //
    // Initialize local.
    //
    
    dwReturn = 0;

    if(NULL == lpstr){
        dwReturn = 0;
        goto DecodeHexA_return;
    } // if(NULL == lpstr)
    
    //
    // Skip spaces.
    //

    for (LPSTR  lpstrThis = lpstr;
        *lpstrThis && *lpstrThis == TEXT(' ');
        lpstrThis++)
        ;

    while   (*lpstrThis) {
        switch  (*lpstrThis) {
            case    '0':
            case    '1':
            case    '2':
            case    '3':
            case    '4':
            case    '5':
            case    '6':
            case    '7':
            case    '8':
            case    '9':
                dwReturn <<= 4;
                dwReturn += ((*lpstrThis) - '0');
                break;
            case    'a':
            case    'b':
            case    'c':
            case    'd':
            case    'e':
            case    'f':
                dwReturn <<= 4;
                dwReturn += 10 + (*lpstrThis - 'a');
                break;
            case    'A':
            case    'B':
            case    'C':
            case    'D':
            case    'E':
            case    'F':
                dwReturn <<= 4;
                dwReturn += 10 + (*lpstrThis - 'A');
                break;

            default:
                return  dwReturn;
        }
        lpstrThis++;
    } // while   (*lpstrThis) 

DecodeHexA_return:
    return  dwReturn;
} // DWORD   CString::DecodeHex() 

BOOL
IsNameAlreadyStored(
    LPTSTR  szName
    )
{
    BOOL    bRet;
    HKEY    hkNameStore;

    DebugTrace(TRACE_PROC_ENTER,(("IsNameAlreadyStored: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet            = FALSE;
    hkNameStore = (HKEY)INVALID_HANDLE_VALUE;

    //
    // Open name store regkey.
    //

    if(ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_INSTALL_NAMESTORE, &hkNameStore)){
        HKEY    hkTemp;
        
        hkTemp  = (HKEY)INVALID_HANDLE_VALUE;

        //
        // See if specified name exists in name store.
        //

        if(ERROR_SUCCESS == RegOpenKey(hkNameStore, szName, &hkTemp)){

            //
            // Specified name already exists in name store.
            //
            
            bRet = TRUE;
            RegCloseKey(hkTemp);

        } // if(ERROR_SUCCESS == RegOpenKey(hkNameStore, szName, &hkTemp))

        RegCloseKey(hkNameStore);
        
    } // if(ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_INSTALL_NAMESTORE, &hkNameStore))

// IsNameAlreadyStored_return:
    DebugTrace(TRACE_PROC_LEAVE,(("IsNameAlreadyStored: Leaving... Ret=0x%x\n"), bRet));
    return bRet;
} // IsFriendlyNameUnique()









#if DEAD_CODE

#ifdef USE_STIMON
//
// For the time being always load and start the monitor
//
HKEY hkRun;

if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUN, &hkRun) == NO_ERROR) {

    CString csCmdLine;
    csCmdLine.MakeSystemPath(MONITOR_NAME);
    csCmdLine.Store (hkRun, REGSTR_VAL_MONITOR);

    Report(( TEXT("Monitor Command Line %ws\r\n"), (LPCTSTR)csCmdLine));

    // Launch it...
    WinExec(csCmdLine, SW_SHOWNOACTIVATE);
    RegCloseKey(hkRun);
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\entry.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Entry.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Co/Installer/DLL entry point.
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Include
//


#include "sti_ci.h"
#include <setupapi.h>

#include "firstpg.h"
#include "portsel.h"
#include "nameit.h"
#include "finalpg.h"
#include "prevpg.h"
#include "device.h"
#include "stiregi.h"

#include "userdbg.h"

//
// Global
//

HINSTANCE       g_hDllInstance  = NULL;

//
// Function
//

extern "C"
BOOL
APIENTRY
DllMain(
    IN  HINSTANCE   hDll,
    IN  ULONG       ulReason,
    IN  LPVOID      lpReserved
    )
/*++

Routine Description:

    DllMain

    Entrypoint when this DLL is loaded.

Arguments:

    IN  HINSTANCE   hDll        Handle to this DLL instance.
    IN  ULONG       ulReason    The reason this entry is called.
    IN  LPVOID      lpReserved

Return Value:

    TRUE always.

Side effects:

    None

--*/
{

    if (ulReason == DLL_PROCESS_ATTACH) {

        //
        // Initialize globals.
        //

        g_hDllInstance = hDll;

        //
        // Initialize Fusion
        //
        SHFusionInitializeFromModuleID( hDll, 123 );

        DisableThreadLibraryCalls(hDll);
        InitCommonControls();

        DBG_INIT(g_hDllInstance);
//        MyDebugInit();

    }
    else if (ulReason == DLL_PROCESS_DETACH) {
        //
        // Shutdown Fusion
        //
        SHFusionUninitialize();
    }

    return TRUE;
} // DllMain ()


extern "C"
DWORD
APIENTRY
ClassInstall (
    IN  DI_FUNCTION         diFunction,
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData
    )
/*++

Routine Description:

    ClassInstall

    Entrypoint of WIA class installer.

Arguments:

    IN  DI_FUNCTION         diFunction      Function to perform.
    IN  HDEVINFO            hDevInfo,       Handle to Device Information.
    IN  PSP_DEVINFO_DATA    pDevInfoData    Pointer to Device Data.

Return Value:

    NO_ERROR            -   Operation succeeded.
    ERROR_DI_DO_DEFAULT -   Operation succeeded, or failed but let it continue.
    Other               -   Operation failed and unable to continue.

Side effects:

    None

--*/
{
    DWORD                   dwReturn;
    DWORD                   dwError;
    DWORD                   dwSize;
    SP_INSTALLWIZARD_DATA   InstallWizardData;
    SP_DEVINSTALL_PARAMS    spDevInstallParams;
    BOOL                    fCleanupContext;
    PINSTALLER_CONTEXT      pInstallerContext;

    DebugTrace(TRACE_PROC_ENTER,(("ClassInstall: Enter... \r\n")));
    DebugTrace(TRACE_STATUS,(("ClassInstall: Processing %ws message.\r\n"), DifDebug[diFunction].DifString));

    //
    // Initialize locals.
    //

    dwReturn            = ERROR_DI_DO_DEFAULT;
    dwError             = ERROR_SUCCESS;
    dwSize              = 0;
    fCleanupContext     = FALSE;
    pInstallerContext   = NULL;

    memset(&InstallWizardData, 0, sizeof(InstallWizardData));
    memset(&spDevInstallParams, 0, sizeof(spDevInstallParams));

    //
    // Dispatch requests.
    //

    switch(diFunction){

        case DIF_INSTALLWIZARD:
        {

            fCleanupContext = TRUE;

            //
            // Get install parameter(s).
            //

            InstallWizardData.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            if(!SetupDiGetClassInstallParams(hDevInfo,
                                             pDevInfoData,
                                             &InstallWizardData.ClassInstallHeader,
                                             sizeof(InstallWizardData),
                                             NULL) )
            {
                dwError = GetLastError();
//                DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! SetupDiGetClassInstallParams failed. Err=0x%x. dwSize=0x%x\n"), dwError, dwSize));
                DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! SetupDiGetClassInstallParams failed. Err=0x%x\n"), dwError));

                dwReturn    = ERROR_DI_DONT_INSTALL;
                goto ClassInstall_return;
            }

            //
            // Check if operation is correct.
            //

            if (InstallWizardData.ClassInstallHeader.InstallFunction != diFunction) {
                DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! InstallHeader.InstallFunction is incorrect..\r\n")));

                dwReturn    = ERROR_DI_DONT_INSTALL;
                goto ClassInstall_return;
            }

            //
            // Check if we still have enough room to add pages.
            //

            if( (MAX_INSTALLWIZARD_DYNAPAGES - NUM_WIA_PAGES) < InstallWizardData.NumDynamicPages ){
                DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! No room for WIA installer pages.\r\n")));

                dwReturn    = ERROR_DI_DONT_INSTALL;
                goto ClassInstall_return;
            }

            //
            // Allocate context structure.
            //

            if(NULL == InstallWizardData.PrivateData){
                pInstallerContext = new INSTALLER_CONTEXT;
                if(NULL == pInstallerContext){
                    DebugTrace(TRACE_WARNING,(("ClassInstall: ERROR!! Insufficient memory.\r\n")));

                    dwReturn    = ERROR_DI_DONT_INSTALL;
                    goto ClassInstall_return;
                }
                InstallWizardData.PrivateData = (DWORD_PTR)pInstallerContext;
                memset((PBYTE)pInstallerContext, 0, sizeof(INSTALLER_CONTEXT));
            } else {
                DebugTrace(TRACE_WARNING,(("ClassInstall: WARNING!! Installer context already exists.\r\n")));
            }

            //
            // See who invoked installer.
            //

            pInstallerContext->bShowFirstPage           = InstallWizardData.PrivateFlags & SCIW_PRIV_SHOW_FIRST;
            pInstallerContext->bCalledFromControlPanal  = InstallWizardData.PrivateFlags & SCIW_PRIV_CALLED_FROMCPL;

            //
            // Save device info set.
            //

            pInstallerContext->hDevInfo         = hDevInfo;

            //
            // Save wizard windows handle.
            //

            pInstallerContext->hwndWizard       = InstallWizardData.hwndWizardDlg;

            //
            // Create/Initialize all wizard pages and a device class object.
            //

            CFirstPage *tempFistPage            = new CFirstPage(pInstallerContext);
            CPrevSelectPage *tempPrevSelectPage = new CPrevSelectPage(pInstallerContext);
            CPortSelectPage *tempPortSelectPage = new CPortSelectPage(pInstallerContext);
            CNameDevicePage *tempNameDevicePage = new CNameDevicePage(pInstallerContext);
            CInstallPage *tempInstallPage       = new CInstallPage(pInstallerContext);

            if( (NULL == tempFistPage)
             || (NULL == tempPrevSelectPage)
             || (NULL == tempPortSelectPage)
             || (NULL == tempNameDevicePage)
             || (NULL == tempInstallPage) )
            {
                DebugTrace(TRACE_WARNING,(("ClassInstall: ERROR!! Insufficient memory.\r\n")));

                dwReturn    = ERROR_DI_DO_DEFAULT;
                goto ClassInstall_return;
            }

            //
            // Save created to context.
            //

            pInstallerContext->pFirstPage       = (PVOID) tempFistPage;
            pInstallerContext->pPrevSelectPage  = (PVOID) tempPrevSelectPage;
            pInstallerContext->pPortSelectPage  = (PVOID) tempPortSelectPage;
            pInstallerContext->pNameDevicePage  = (PVOID) tempNameDevicePage;
            pInstallerContext->pFinalPage       = (PVOID) tempInstallPage;

            //
            // Add created pages.
            //

            InstallWizardData.DynamicPages[InstallWizardData.NumDynamicPages++] = tempFistPage->Handle();
            InstallWizardData.DynamicPages[InstallWizardData.NumDynamicPages++] = tempPrevSelectPage->Handle();
            InstallWizardData.DynamicPages[InstallWizardData.NumDynamicPages++] = tempPortSelectPage->Handle();
            InstallWizardData.DynamicPages[InstallWizardData.NumDynamicPages++] = tempNameDevicePage->Handle();
            InstallWizardData.DynamicPages[InstallWizardData.NumDynamicPages++] = tempInstallPage->Handle();

            //
            // Indicate "pages are added".
            //

            InstallWizardData.DynamicPageFlags |= DYNAWIZ_FLAG_PAGESADDED;

            //
            // Set the parameters back.
            //

            SetupDiSetClassInstallParams (hDevInfo,
                                          pDevInfoData,
                                          &InstallWizardData.ClassInstallHeader,
                                          sizeof(InstallWizardData));

            fCleanupContext = FALSE;
            dwReturn    = NO_ERROR;
            goto ClassInstall_return;
            break;

        } // case DIF_INSTALLWIZARD:


        case DIF_DESTROYWIZARDDATA:
        {

            //
            // Get install parameter(s).
            //

            InstallWizardData.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            if(!SetupDiGetClassInstallParams(hDevInfo,
                                             pDevInfoData,
                                             &InstallWizardData.ClassInstallHeader,
                                             sizeof(InstallWizardData),
                                             &dwSize) )
            {
                dwError = GetLastError();
                DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! SetupDiGetClassInstallParams failed. Err=0x%x\n"), dwError));

                dwReturn    = ERROR_DI_DO_DEFAULT;
                goto ClassInstall_return;
            }

//            //
//            // Check if operation is correct.
//            //
//
//            if (InstallWizardData.ClassInstallHeader.InstallFunction != diFunction) {
//                DebugTrace(TRACE_WARNING,(("ClassInstall: ERROR!! InstallHeader.InstallFunction is incorrect..\r\n")));
//
//                dwReturn    = ERROR_DI_DO_DEFAULT;
//                goto ClassInstall_return;
//            }

            //
            // Free all allocated resources.
            //

            fCleanupContext = TRUE;
            pInstallerContext = (PINSTALLER_CONTEXT)InstallWizardData.PrivateData;
            InstallWizardData.PrivateData = NULL;

            dwReturn    = NO_ERROR;
            goto ClassInstall_return;
            break;

        } // case DIF_DESTROYWIZARDDATA:

        case DIF_INSTALLDEVICE:
        {
            BOOL    bSucceeded;
            BOOL    bIsPnp;

            //
            // Sanity check of DevInfoSet and DevInfoData.
            //

            if( (NULL == pDevInfoData)
             || (!IS_VALID_HANDLE(hDevInfo)) )
            {
                DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! Wrong Infoset(0x%x) or instance(0x%x). Unable to continue.\r\n"),pDevInfoData,hDevInfo));

                dwReturn = ERROR_DI_DO_DEFAULT;
                goto ClassInstall_return;
            }

            //
            // Get device install parameters.
            //

            memset(&spDevInstallParams, 0, sizeof(spDevInstallParams));
            spDevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if(!SetupDiGetDeviceInstallParams(hDevInfo,
                                              pDevInfoData,
                                              &spDevInstallParams))
            {
                DebugTrace(TRACE_STATUS,(("ClassInstall: SetupDiGetDeviceInstallParams failed Err=0x%x.\r\n"), GetLastError()));
                dwReturn = ERROR_DI_DO_DEFAULT;
                goto ClassInstall_return;
            }

            //
            // Check NULL driver installation.
            //

            if(spDevInstallParams.FlagsEx & DI_FLAGSEX_SETFAILEDINSTALL){

                //
                // Installing NULL driver. Let default handler handle it.
                //

                dwReturn = ERROR_DI_DO_DEFAULT;
                goto ClassInstall_return;
            } // if(spDevInstallParams.FlagsEx & DI_FLAGSEX_SETFAILEDINSTALL)

            //
            // See if it's root-enumerated or not.
            //

            if(IsDeviceRootEnumerated(hDevInfo, pDevInfoData)){
                bIsPnp = FALSE;
            } else {
                bIsPnp = TRUE;
            }

            //
            // Create CDevice class.
            //
            //
            // Start the WIA service.  We start it here so that it will be running when we finish, so
            // it will receive the PnP device arrival notification.
            // Notice we don't change the startup-type here - this will be done later if the device
            // installation was successful.
            //

            StartWiaService();

            CDevice cdThis(hDevInfo, pDevInfoData, bIsPnp);

            //
            // Let it create unique FriendlyName.
            //

            bSucceeded = cdThis.NameDefaultUniqueName();
            if(bSucceeded){

                //
                // Do pre-installation process.
                //

                bSucceeded = cdThis.PreInstall();
                if(bSucceeded){

                    //
                    // Do actual installation.
                    //

                    bSucceeded = cdThis.Install();
                    if(!bSucceeded){
                        dwReturn = ERROR_DI_DONT_INSTALL;
                        DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! Installation failed in CDevice class.\r\n")));
                    }
                } else {
                    DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! PreInstall failed in CDevice class.\r\n")));
                }
            } else {
                DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! NameDefaultUniqueName failed in CDevice class.\r\n")));
                dwReturn = ERROR_DI_DONT_INSTALL;
            }

            if(bSucceeded){

                //
                // So far, installation is working fine. Do final touch.
                //

                bSucceeded = cdThis.PostInstall(TRUE);
                if(!bSucceeded){
                    dwReturn = ERROR_DI_DONT_INSTALL;
                    DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! PostInstall failed in CDevice class.\r\n")));
                }
                
                //
                // At this point, we consider the installation is succeeded.
                //

                dwReturn = NO_ERROR;
                
                //
                // Get device install parameters again.
                //

                memset(&spDevInstallParams, 0, sizeof(spDevInstallParams));
                spDevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                if(!SetupDiGetDeviceInstallParams(hDevInfo,
                                                  pDevInfoData,
                                                  &spDevInstallParams))
                {
                    dwReturn = GetLastError();;
                    DebugTrace(TRACE_STATUS,(("ClassInstall: SetupDiGetDeviceInstallParams failed Err=0x%x.\r\n"), dwReturn));
                    goto ClassInstall_return;
                }

                //
                // We need to notify WIA service about new device addition.
                //
                
                if(NULL == spDevInstallParams.ClassInstallReserved){
                    spDevInstallParams.ClassInstallReserved = (ULONG_PTR)new CLEANUPITEM;
                    if(NULL != spDevInstallParams.ClassInstallReserved){
                        memset((PVOID)(spDevInstallParams.ClassInstallReserved), 0, sizeof(CLEANUPITEM));
                    } else { // if(NULL == spDevInstallParams.ClassInstallReserved)
                        DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! Unable to allocate CLEANUPITEM.\r\n")));
                    }
                } // if(NULL == spDevInstallParams.ClassInstallReserved)

                if(NULL != spDevInstallParams.ClassInstallReserved){
                    ((PCLEANUPITEM)spDevInstallParams.ClassInstallReserved)->bInstalled = TRUE;
                    if(SetupDiSetDeviceInstallParams(hDevInfo,
                                                     pDevInfoData,
                                                     &spDevInstallParams))
                    {
                        //
                        // Installation succeeded.
                        //

                        DebugTrace(TRACE_STATUS,(("ClassInstall: WIA service will reenumerate device.\r\n")));
                    } else {
                        DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! SetupDiSetDeviceInstallParams() failed. Err=0x%x.\r\n"), GetLastError()));
                    }
                } else { // if(NULL != spDevInstallParams.ClassInstallReserved)
                    DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! No CLEANUPITEM in context.\r\n")));
                } // else(NULL != spDevInstallParams.ClassInstallReserved)

            } else {

                //
                // There's an error during installation. Revert.
                //

                cdThis.PostInstall(FALSE);
                dwReturn = ERROR_DI_DONT_INSTALL;
                DebugTrace(TRACE_ERROR,(("ClassInstall: Reverting installation...\r\n")));
            }

            goto ClassInstall_return;
            break;
        } // case DIF_INSTALLDEVICE:

        case DIF_REMOVE:
        {

            SP_REMOVEDEVICE_PARAMS   rdp;

            //
            // Check if operation is correct.
            //

            memset (&rdp, 0, sizeof(SP_REMOVEDEVICE_PARAMS));
            rdp.ClassInstallHeader.cbSize = sizeof (SP_CLASSINSTALL_HEADER);
            if (!SetupDiGetClassInstallParams (hDevInfo,
                                               pDevInfoData,
                                               &rdp.ClassInstallHeader,
                                               sizeof(SP_REMOVEDEVICE_PARAMS),
                                               NULL))
            {
                DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! SetupDiGetClassInstallParams failed Err=0x%x.\r\n"), GetLastError()));

                dwReturn = ERROR_DI_DO_DEFAULT;
                goto ClassInstall_return;
            } // if (!SetupDiGetClassInstallParams ()

            if (rdp.ClassInstallHeader.InstallFunction != DIF_REMOVE) {
                dwReturn = ERROR_DI_DO_DEFAULT;
                goto ClassInstall_return;
            }

            //
            // Create CDevice object.
            //

            CDevice cdThis(hDevInfo, pDevInfoData, TRUE);

            //
            // Remove the device.
            //

            dwReturn = cdThis.Remove(&rdp);

            //
            // Get device install parameters.
            //

            memset(&spDevInstallParams, 0, sizeof(spDevInstallParams));
            spDevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if(!SetupDiGetDeviceInstallParams(hDevInfo,
                                              pDevInfoData,
                                              &spDevInstallParams))
            {
                dwReturn = GetLastError();;
                DebugTrace(TRACE_STATUS,(("ClassInstall: SetupDiGetDeviceInstallParams failed Err=0x%x.\r\n"), dwReturn));
                goto ClassInstall_return;
            }

            //
            // We need to notify WIA service about new device addition.
            //

            if(NULL == spDevInstallParams.ClassInstallReserved){
                spDevInstallParams.ClassInstallReserved = (ULONG_PTR)new CLEANUPITEM;
                if(NULL != spDevInstallParams.ClassInstallReserved){
                    memset((PVOID)(spDevInstallParams.ClassInstallReserved), 0, sizeof(CLEANUPITEM));
                } else { // if(NULL == spDevInstallParams.ClassInstallReserved)
                    DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! Unable to allocate CLEANUPITEM.\r\n")));
                }
            } // if(NULL == spDevInstallParams.ClassInstallReserved)

            if(NULL != spDevInstallParams.ClassInstallReserved){
                ((PCLEANUPITEM)spDevInstallParams.ClassInstallReserved)->bRemoved = TRUE;
                if(SetupDiSetDeviceInstallParams(hDevInfo,
                                                 pDevInfoData,
                                                 &spDevInstallParams))
                {
                    //
                    // Installation succeeded.
                    //

                    DebugTrace(TRACE_STATUS,(("ClassInstall: WIA service will reenumerate device.\r\n")));

                } else {
                    DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! SetupDiSetDeviceInstallParams() failed. Err=0x%x.\r\n"), GetLastError()));
                }
            } else { // if(NULL != spDevInstallParams.ClassInstallReserved)
                DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! No CLEANUPITEM in context.\r\n")));
            } // else(NULL != spDevInstallParams.ClassInstallReserved)

            goto ClassInstall_return;
            break;
        } // case DIF_REMOVE:

        case DIF_SELECTBESTCOMPATDRV:
        {
            SP_DRVINSTALL_PARAMS    spDriverInstallParams;
            SP_DRVINFO_DATA         spDriverInfoData;
            PSP_DRVINFO_DETAIL_DATA pspDriverInfoDetailData;
            DWORD                   dwLastError;
            DWORD                   dwSizeLocal;
            DWORD                   Idx;


            //
            // Get driver info.
            //

            memset(&spDriverInfoData, 0, sizeof(spDriverInfoData));
            spDriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
            for(Idx = 0; SetupDiEnumDriverInfo(hDevInfo, pDevInfoData, SPDIT_COMPATDRIVER, Idx, &spDriverInfoData); Idx++){

                //
                // Get driver install params.
                //

                memset(&spDriverInstallParams, 0, sizeof(spDriverInstallParams));
                spDriverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
                if(!SetupDiGetDriverInstallParams(hDevInfo, pDevInfoData, &spDriverInfoData, &spDriverInstallParams)){
                    DebugTrace(TRACE_ERROR,("ClassInstall: ERROR!! SetupDiGetDriverInstallParams() failed LastError=0x%x.\r\n", GetLastError()));

                    dwReturn = ERROR_DI_DO_DEFAULT;
                    goto ClassInstall_return;
                } // if(!SetupDiGetDriverInstallParams(hDevInfo, pDevInfoData, &spDriverInfoData, &spDriverInstallParams))

                //
                // Get buffer size required for driver derail data.
                //

                dwSizeLocal = 0;
                SetupDiGetDriverInfoDetail(hDevInfo,
                                           pDevInfoData,
                                           &spDriverInfoData,
                                           NULL,
                                           0,
                                           &dwSizeLocal);
                dwLastError = GetLastError();
                if(ERROR_INSUFFICIENT_BUFFER != dwLastError){
                    DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! SetupDiGetDriverInfoDetail() doesn't return required size.Er=0x%x\r\n"),dwLastError));

                    dwReturn = ERROR_DI_DO_DEFAULT;
                    goto ClassInstall_return;
                } // if(ERROR_INSUFFICIENT_BUFFER != dwLastError)

                //
                // Allocate required size of buffer for driver detailed data.
                //

                pspDriverInfoDetailData   = (PSP_DRVINFO_DETAIL_DATA)new char[dwSizeLocal];
                if(NULL == pspDriverInfoDetailData){
                    DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! Unable to allocate driver detailed info buffer.\r\n")));

                    dwReturn = ERROR_DI_DO_DEFAULT;
                    goto ClassInstall_return;
                } // if(NULL == pspDriverInfoDetailData)

                //
                // Initialize allocated buffer.
                //

                memset(pspDriverInfoDetailData, 0, dwSizeLocal);
                pspDriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

                //
                // Get detailed data of selected device driver.
                //

                if(!SetupDiGetDriverInfoDetail(hDevInfo,
                                               pDevInfoData,
                                               &spDriverInfoData,
                                               pspDriverInfoDetailData,
                                               dwSizeLocal,
                                               NULL) )
                {
                    DebugTrace(TRACE_ERROR,("ClassInstall: ERROR!! SetupDiGetDriverInfoDetail() failed LastError=0x%x.\r\n", GetLastError()));

                    delete[] pspDriverInfoDetailData;
                    continue;
                } // if(NULL == pspDriverInfoDetailData)

                //
                // See if INF filename is valid.
                //

                if(NULL == pspDriverInfoDetailData->InfFileName){
                    DebugTrace(TRACE_ERROR,("ClassInstall: ERROR!! SetupDiGetDriverInfoDetail() returned invalid INF name.\r\n"));

                    delete[] pspDriverInfoDetailData;
                    continue;
                } // if(NULL == pspDriverInfoDetailData->InfFileName)

                //
                // If it's Inbox driver, set DNF_BASIC_DRIVER.
                //

                if( IsWindowsFile(pspDriverInfoDetailData->InfFileName)
                 && IsProviderMs(pspDriverInfoDetailData->InfFileName ) )
                {

                    //
                    // This is inbox INF. set DNF_BASIC_DRIVER.
                    //

                    spDriverInstallParams.Flags |= DNF_BASIC_DRIVER;
                    SetupDiSetDriverInstallParams(hDevInfo,
                                                  pDevInfoData,
                                                  &spDriverInfoData,
                                                  &spDriverInstallParams);
                } // if(IsWindowsFilw() && IsProviderMs())

                //
                // Clean up.
                //

                delete[] pspDriverInfoDetailData;

            } // for(Idx = 0; SetupDiEnumDriverInfo(hDevInfo, pDevInfoData, SPDIT_COMPATDRIVER, Idx, &spDriverInfoData), Idx++)

            goto ClassInstall_return;
            break;
        } // case DIF_SELECTBESTCOMPATDRV:

        case DIF_DESTROYPRIVATEDATA:
        {
            PCLEANUPITEM    pCleanupItem;
            
            //
            // Get device install parameters.
            //

            spDevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if(!SetupDiGetDeviceInstallParams(hDevInfo,
                                              pDevInfoData,
                                              &spDevInstallParams))
            {
                dwReturn = GetLastError();;
                DebugTrace(TRACE_STATUS,(("ClassInstall: SetupDiGetDeviceInstallParams failed Err=0x%x.\r\n"), dwReturn));
                goto ClassInstall_return;
            }

            //
            // See if any cleanup required.
            //
            
            pCleanupItem = (PCLEANUPITEM)spDevInstallParams.ClassInstallReserved;
            if(NULL != pCleanupItem){

                //
                // A device is installed/uninstalled.
                //

                DebugTrace(TRACE_STATUS,("ClassInstall: Clean up item is created..\r\n"));

                if( (TRUE == pCleanupItem->bInstalled)
                 || (TRUE == pCleanupItem->bRemoved) )
                {
                    DebugTrace(TRACE_STATUS,("ClassInstall: Let WIA service refresh device list.\r\n"));
                    WiaDeviceEnum();
                }
            
                delete pCleanupItem;
                pCleanupItem = NULL;
            } // if(NULL != pCleanupItem)
        } // case DIF_DESTROYPRIVATEDATA:


//        case DIF_ENABLECLASS:
//        case DIF_FIRSTTIMESETUP:
        default:
            break;

    } // switch(diFunction)


ClassInstall_return:


    if(fCleanupContext){
        if(NULL != pInstallerContext){


            if(NULL != pInstallerContext->pFirstPage){
                delete (CFirstPage *)(pInstallerContext->pFirstPage);
            }
            if(NULL != pInstallerContext->pPrevSelectPage){
                delete (CPrevSelectPage *)(pInstallerContext->pPrevSelectPage);
            }
            if(NULL != pInstallerContext->pPortSelectPage){
                delete (CPortSelectPage *)(pInstallerContext->pPortSelectPage);
            }
            if(NULL != pInstallerContext->pNameDevicePage){
                delete (CNameDevicePage *)(pInstallerContext->pNameDevicePage);
            }
            if(NULL != pInstallerContext->pFinalPage){
                delete (CInstallPage *)(pInstallerContext->pFinalPage);
            }

            //
            // Removed this delete call for the pDevice pointer. The Wizard pages
            // delete this memory when a user presses "cancel" or closes the Wizard
            // dialog.
            //
            // COOPP - 01-18-2001. Quick fix to BUG #284981 Heap Corruption
            //
            // Note for future: As discussed with KeisukeT, a better design would be
            // adding a shared pInstallerContext pointer in the BASE class of the
            // Wizard pages.  This would allow this routine to remain enabled as a
            // "catch-all" case. (Catching the case if the Wizard dialogs did not free
            // the memory first)
            //
            // if(NULL != pInstallerContext->pDevice){
            //    delete pInstallerContext->pDevice;
            //}
            //

            delete pInstallerContext;
        } // if(NULL != pInstallerContext)
    }

    DebugTrace(TRACE_PROC_LEAVE,(("ClassInstall: Leaving... Ret=0x%x.\r\n"), dwReturn));
    return dwReturn;
} // ClassInstall()


extern "C"
DWORD
APIENTRY
CoinstallerEntry(
    IN  DI_FUNCTION                     diFunction,
    IN  HDEVINFO                        hDevInfo,
    IN  PSP_DEVINFO_DATA                pDevInfoData,
    IN  OUT PCOINSTALLER_CONTEXT_DATA   pCoinstallerContext
    )
/*++

Routine Description:

    CoinstallerEntry

    Entrypoint of WIA class coinstaller.

Arguments:

    IN  DI_FUNCTION                     diFunction,             Function to perform.
    IN  HDEVINFO                        hDevInfo,               Handle to Device Information.
    IN  PSP_DEVINFO_DATA                pDevInfoData,           Pointer to Device Data.
    IN  OUT PCOINSTALLER_CONTEXT_DATA   pCoinstallerContext     Context data for coinstaller.

Return Value:

    NO_ERROR                            -   Operation succeeded.
    ERROR_DI_POSTPROCESSING_REQUIRED    -   Need post processing after installation has done.

Side effects:

    None

--*/
{
    DWORD   dwReturn;

    DebugTrace(TRACE_PROC_ENTER,(("CoinstallerEntry: Enter... \r\n")));

    //
    // Initialize local.
    //

    dwReturn = NO_ERROR;

    //
    // Do Pre/Post process.
    //

    if(pCoinstallerContext->PostProcessing){

        //
        // Do post-process.
        //

        dwReturn = CoinstallerPostProcess(diFunction,
                                          hDevInfo,
                                          pDevInfoData,
                                          pCoinstallerContext);
    } else {

        //
        // Do pre-process.
        //

        dwReturn = CoinstallerPreProcess(diFunction,
                                         hDevInfo,
                                         pDevInfoData,
                                         pCoinstallerContext);
    } // if(pCoinstallerContext->PostProcessing)

// CoinstallerEntry_return:
    DebugTrace(TRACE_PROC_LEAVE,(("CoinstallerEntry: Leaving... Ret=0x%x.\r\n"), dwReturn));
    return dwReturn;

} // CoinstallerEntry()



DWORD
APIENTRY
CoinstallerPreProcess(
    IN  DI_FUNCTION                     diFunction,
    IN  HDEVINFO                        hDevInfo,
    IN  PSP_DEVINFO_DATA                pDevInfoData,
    IN  OUT PCOINSTALLER_CONTEXT_DATA   pCoinstallerContext
    )
{
    DWORD   dwReturn;

    DebugTrace(TRACE_PROC_ENTER,(("CoinstallerPreProcess: Enter... \r\n")));
    DebugTrace(TRACE_STATUS,(("CoinstallerPreProcess: Processing %ws message.\r\n"), DifDebug[diFunction].DifString));

    //
    // Initialize local.
    //

    dwReturn = NO_ERROR;

    //
    // Dispatch requests.
    //

    switch(diFunction){

        case DIF_INSTALLDEVICE:
        {
            BOOL    bSucceeded;

            //
            // Initialize private data.
            //

            if(NULL != pCoinstallerContext->PrivateData){
                DebugTrace(TRACE_WARNING,(("CoinstallerPreProcess: WARNING!! Private has value other than NULL.\r\n")));
            }
            pCoinstallerContext->PrivateData = NULL;

            //
            // Create CDevice class.
            //

            CDevice *pDevice = new CDevice(hDevInfo, pDevInfoData, TRUE);
            if(NULL == pDevice){
                DebugTrace(TRACE_ERROR,(("CoinstallerPreProcess: ERROR!! Insufficient memory.\r\n")));
                dwReturn = NO_ERROR;
                goto CoinstallerPreProcess_return;
            } // if(NULL == pDevice)

            //
            // Let it create unique FriendlyName.
            //

            bSucceeded = pDevice->NameDefaultUniqueName();
            if(bSucceeded){

                //
                // Do pre-installation process.
                //

                bSucceeded = pDevice->PreInstall();
                if(!bSucceeded){
                    DebugTrace(TRACE_ERROR,(("CoinstallerPreProcess: ERROR!! Pre-Installation failed in CDevice class.\r\n")));
                    delete pDevice;

                    dwReturn = NO_ERROR;
                    goto CoinstallerPreProcess_return;
                }
            } else {
                DebugTrace(TRACE_ERROR,(("CoinstallerPreProcess: ERROR!! NameDefaultUniqueName failed in CDevice class.\r\n")));
                delete pDevice;

                dwReturn = NO_ERROR;
                goto CoinstallerPreProcess_return;
            }

            //
            // Post-installation have to free allocated object.
            //

            pCoinstallerContext->PrivateData = (PVOID)pDevice;
            dwReturn = ERROR_DI_POSTPROCESSING_REQUIRED;

            goto CoinstallerPreProcess_return;
            break;
        } // case DIF_INSTALLDEVICE:

        default:
            break;
    } // switch(diFunction)

CoinstallerPreProcess_return:
    DebugTrace(TRACE_PROC_LEAVE,(("CoinstallerPreProcess: Leaving... Ret=0x%x.\r\n"), dwReturn));
    return dwReturn;
} // CoinstallerPreProcess()


DWORD
APIENTRY
CoinstallerPostProcess(
    IN  DI_FUNCTION                     diFunction,
    IN  HDEVINFO                        hDevInfo,
    IN  PSP_DEVINFO_DATA                pDevInfoData,
    IN  OUT PCOINSTALLER_CONTEXT_DATA   pCoinstallerContext
    )
{
    DWORD   dwReturn;

    DebugTrace(TRACE_PROC_ENTER,(("CoinstallerPostProcess: Enter... \r\n")));
    DebugTrace(TRACE_STATUS,(("CoinstallerPostProcess: Processing %ws message.\r\n"), DifDebug[diFunction].DifString));

    //
    // Initialize local.
    //

    dwReturn = NO_ERROR;

    //
    // Dispatch requests.
    //

    switch(diFunction){

        case DIF_INSTALLDEVICE:
        {
            BOOL    bSucceeded;
            CDevice *pDevice;

            if(NO_ERROR == pCoinstallerContext->InstallResult){
                bSucceeded = TRUE;
            } else {
                bSucceeded = FALSE;
            }
            //
            // Get pointer to the CDevice class created in pre-process.
            //

            pDevice = (CDevice *)pCoinstallerContext->PrivateData;

            //
            // Do post-installation process.
            //

            pDevice->PostInstall(bSucceeded);

            //
            // Delete CDevice object.
            //

            delete pDevice;
            pCoinstallerContext->PrivateData = NULL;

            dwReturn = NO_ERROR;
            goto CoinstallerPostProcess_return;
            break;
        } // case DIF_INSTALLDEVICE:

        default:
            break;
    } // switch(diFunction)

CoinstallerPostProcess_return:
    DebugTrace(TRACE_PROC_LEAVE,(("CoinstallerPostProcess: Leaving... Ret=0x%x.\r\n"), dwReturn));
    return dwReturn;
} // CoinstallerPostProcess(
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\device.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       device.h
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Class to handle device un/installation for WIA class installer.
*
*******************************************************************************/

#ifndef _DEVICE_H_
#define _DEVICE_H_

//
// Include
//

#include "sti_ci.h"
#include "exports.h"

//
// Define
//

#ifndef StiDeviceTypeStreamingVideo
 #define StiDeviceTypeStreamingVideo 3
#endif

typedef BOOL (CALLBACK FAR * DEVNODESELCALLBACK)(LPTSTR szPortName, HDEVINFO *phDevInfo, PSP_DEVINFO_DATA pspDevInfoData);


//
// Class
//

class CDevice {

    //  Mutex for unique DeviceID/FriendlName creation.

    HANDLE              m_hMutex;

//    // These members are set in constructor.
//    HDEVINFO            m_hDevInfo;
//    PSP_DEVINFO_DATA    m_pspDevInfoData;

    CString             m_csInf;                // INF filename.
    CString             m_csInstallSection;     // INF section name.

    // These members are set during installation process.
    CString             m_csPort;               // Port name.
    DEVNODESELCALLBACK  m_pfnDevnodeSelCallback;// Callback for devnode selection.
    
    HKEY                m_hkInterfaceRegistry;  // RegKey to created interface.

    CString             m_csWiaSection;         // WIA Section nane.
    CString             m_csSubClass;           // Subclass.
    CString             m_csConnection;         // Connection type.
    CString             m_csVendor;             // Vendor name.
    CString             m_csFriendlyName;       // Friendly name.
    CString             m_csPdoDescription;     // Device Desc. of Devnode..
    CString             m_csDriverDescription;  // Driver Description.
    CString             m_csUninstallSection;   // UninstallSection.
    CString             m_csPropPages;          // VendorPropertyPage.
    CString             m_csVendorSetup;        // Vendor setup extention.
    CString             m_csDataSection;        // DeviceDataSection name.
    CString             m_csEventSection;       // EventSection name.
    CString             m_csIcmProfile;         // ICM Profile.
    CString             m_csUSDClass;           // USD Class GUID.
    CString             m_csDeviceID;           // Unique device ID.
    CString             m_csSymbolicLink;       // Symbolic link to the PDO.
    CString             m_csPortSelect;         // Indicate needs of port selection page..

    CStringArray        m_csaAllNames;          // Array to keep all device FriendlyName.
    CStringArray        m_csaAllId;             // Array to keep all device ID.

    DWORD               m_dwCapabilities;       // Capabilities.
    DWORD               m_dwDeviceType;         // DeviceType.
    DWORD               m_dwDeviceSubType;      // DeviceSubType.
    DWORD               m_dwNumberOfWiaDevice;  // Number of WIA device.
    DWORD               m_dwNumberOfStiDevice;  // Number of STI device.
    DWORD               m_dwInterfaceIndex;     // Index of interface.

    BOOL                m_bVideoDevice;         // Flag to indicate video device.
    BOOL                m_bIsPnP;               // Flag to indicate PnP device.
    BOOL                m_bDefaultDevice;       // 
    BOOL                m_bInfProceeded;        // Flag to indicate INF is proceeded.
    BOOL                m_bInterfaceOnly;       // Flag to indicate Interface-onle device.
    BOOL                m_bIsMigration;         // Flag to indicate migration.

    PPARAM_LIST         m_pExtraDeviceData;     // DeviceData migrated from Win9x.

    BOOL    GetInfInforamtion();
    VOID    ProcessEventsSection(HINF hInf, HKEY hkDrv);
    VOID    ProcessDataSection(HINF hInf, HKEY hkDrv);
    VOID    ProcessICMProfiles();
    VOID    ProcessVideoDevice(HKEY hkDrv);
    BOOL    HandleFilesInstallation();
    BOOL    IsInterfaceOnlyDevice(){ return m_bInterfaceOnly; };
    BOOL    IsPnpDevice(){ return m_bIsPnP; };
    BOOL    IsFeatureInstallation(){ return ( m_bIsPnP && m_bInterfaceOnly); };
    BOOL    CreateDeviceInterfaceAndInstall();
    BOOL    IsMigration(){return m_bIsMigration;};

public:

    // These members are set in constructor. These really should be in private.
    HDEVINFO            m_hDevInfo;
    PSP_DEVINFO_DATA    m_pspDevInfoData;

    CDevice(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pspDevInfoSet, BOOL bIsPnP);
    CDevice(HDEVINFO hDevInfo, DWORD dwDeviceIndex);
    CDevice(PDEVICE_INFO pMigratingDevice);
    CDevice::~CDevice();

    BOOL    CollectNames();
    BOOL    IsDefault() const { return m_bDefaultDevice; }
    VOID    Default(BOOL bNew) { m_bDefaultDevice = bNew; }
    DWORD   GetCapabilities(){ return m_dwCapabilities; };
    LPTSTR  GetConnection(){ return m_csConnection; };
    LPTSTR  GetFriendlyName(){ return m_csFriendlyName; };
    VOID    SetPort (LPTSTR szPortName);
    VOID    SetDevnodeSelectCallback (DEVNODESELCALLBACK pfnDevnodeSelCallback);
    VOID    SetFriendlyName(LPTSTR szFriendlyName);

    BOOL    IsDeviceIdUnique(LPTSTR  szDeviceId);
    BOOL    IsFriendlyNameUnique(LPTSTR  szFriendlyName);
    BOOL    IsSameDevice(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pspDevInfoSet);
    BOOL    NameDefaultUniqueName();
    BOOL    GenerateUniqueDeviceId();
    BOOL    Install();
    DWORD   Remove(PSP_REMOVEDEVICE_PARAMS lprdp);
    BOOL    PreInstall();
    BOOL    PostInstall(BOOL   bSucceeded);
    BOOL    PreprocessInf();
    BOOL    UpdateDeviceRegistry();
    DWORD   GetPortSelectMode(VOID);
    DWORD   AcquireInstallerMutex(DWORD dwTimeout);
    VOID    ReleaseInstallerMutex();

};


//
// Prototype
//

// from device.cpp
VOID
GetDeviceCount(
    DWORD   *pdwWiaCount,
    DWORD   *pdwStiCount
    );

HANDLE
ExecCommandLine(
    LPTSTR  szCommandLine,
    DWORD   dwDirectory
    );

// from service.cpp
DWORD
WINAPI
StiServiceRemove(
    VOID
    );

DWORD
WINAPI
StiServiceInstall(
    BOOL    UseLocalSystem,
    BOOL    DemandStart,
    LPTSTR  lpszUserName,
    LPTSTR  lpszUserPassword
    );

BOOL
SetServiceStart(
    LPTSTR ServiceName,
    DWORD StartType
    );

BOOL
StartWiaService(
    VOID
    );

BOOL
StopWiaService(
    VOID
    );

//PSP_FILE_CALLBACK StiInstallCallback;
//PSP_FILE_CALLBACK StiUninstallCallback;

UINT
CALLBACK
StiInstallCallback (
    PVOID    Context,
    UINT     Notification,
    UINT_PTR Param1,
    UINT_PTR Param2
    );

HANDLE
GetDeviceInterfaceIndex(
    LPSTR   pszLocalName,
    DWORD   *pdwIndex
    );

PPARAM_LIST
MigrateDeviceData(
    HKEY        hkDeviceData,
    PPARAM_LIST pExtraDeviceData,
    LPSTR       pszKeyName
    );

#endif // _DEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\exports.cpp ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Exports.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Exported functions.
*
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Include
//

#include "sti_ci.h"
#include "exports.h"
#include "device.h"
#include "portsel.h"

#include <devguid.h>
#include <stdio.h>
#include <shlobj.h>
#include <objbase.h>
#include <icm.h>
#include <stiregi.h>
#include <stisvc.h>

//
// Global
//

extern  HINSTANCE   g_hDllInstance;

//
// Function
//


DLLEXPORT
HANDLE
WINAPI
WiaAddDevice(
    VOID
    )
{
    return ExecCommandLine(STR_ADD_DEVICE, EXECDIR_SYSTEM32);
} // WiaAddDevice()

DLLEXPORT
BOOL
WINAPI
WiaRemoveDevice(
    PSTI_DEVICE_INFORMATION pStiDeviceInformation
    )
{
    if(NULL == pStiDeviceInformation){
        DebugTrace(TRACE_ERROR,(("WiaRemoveDevice: ERROR!! Invalid argument.\r\n")));
        return FALSE;
    } // if(NULL == pStiDeviceInformation)

    return (RemoveDevice(NULL, g_hDllInstance, pStiDeviceInformation->szDeviceInternalName, 0));
} // WiaRemoveDevice(

HANDLE
WiaInstallerProcess(
    LPTSTR   lpCommandLine
    )
{
    BOOL                bRet = FALSE;
    HANDLE              hProcess = NULL;
    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFO         SetupInfo = {sizeof SetupInfo, NULL, NULL, NULL, 0, 0,
                                    0, 0, 0, 0, 0, STARTF_FORCEONFEEDBACK,
                                    SW_SHOWNORMAL, 0, NULL, NULL, NULL, NULL};

    //
    // Create install wizard process.
    //



    DebugTrace(TRACE_STATUS,(("WiaInstallerProcess: Executing \"%ws\".\r\n"), lpCommandLine));
    bRet = CreateProcess(NULL,
                        lpCommandLine,
                        NULL,
                        NULL,
                        FALSE,
                        NORMAL_PRIORITY_CLASS,
                        NULL,
                        NULL,
                        &SetupInfo,
                        &ProcessInfo);

    if(bRet){
        DebugTrace(TRACE_STATUS,(("WiaInstallerProcess: Installer process successfully created.\r\n")));
        CloseHandle(ProcessInfo.hThread);
        hProcess = ProcessInfo.hProcess;
    } else {
        DebugTrace(TRACE_ERROR,(("WiaInstallerProcess: ERROR!! Unable to create a process. Err=0x%x.\r\n"), GetLastError()));
        hProcess = NULL;
    }

    return hProcess;
}

BOOL
WINAPI
CreateWiaShortcut(
    VOID
    )
{

    HRESULT     hres;
    IShellLink  *psl;
    LONG        err;
    HKEY        khWindowsCurrentVersion;
    DWORD       dwType;
    DWORD       dwSize;

    TCHAR       pszSystemPath[MAX_PATH+1];      //  path to system32 folder.
    TCHAR       pszShortcutPath[MAX_PATH+1];    //  path to creating shortcut.
    TCHAR       pszProgramPath[MAX_PATH+1];     //  path to ProgramFiles folder.
    TCHAR       pszAccessoriesPath[MAX_PATH+1]; //  path to Accessories folder.
    TCHAR       pszWizardPath[MAX_PATH+1];      //  path to wiaacmgr.exe.
    TCHAR       pszSticiPath[MAX_PATH+1];       //  path to sti_ci.dll.

    TCHAR       pszWizardName[MAX_PATH+1];      //  Menu name ofcreating shortcut.
    TCHAR       pszWizardLinkName[MAX_PATH+1];  //  filename ofcreating shortcut.
    TCHAR       pszWizardDesc[MAX_PATH+1];      //  description of creating shortcut.
    TCHAR       pszAccessoriesName[MAX_PATH+1]; //  localized "Accessories" folder name.

    BOOL        bRet;

    //
    // Init locals.
    //

    bRet    = FALSE;
    psl     = NULL;
    err     = 0;
    khWindowsCurrentVersion = NULL;

    memset(pszSystemPath, 0, sizeof(pszSystemPath));
    memset(pszShortcutPath, 0, sizeof(pszShortcutPath));
    memset(pszProgramPath, 0, sizeof(pszProgramPath));
    memset(pszAccessoriesPath, 0, sizeof(pszAccessoriesPath));
    memset(pszWizardPath, 0, sizeof(pszWizardPath));
    memset(pszSticiPath, 0, sizeof(pszSticiPath));
    memset(pszWizardName, 0, sizeof(pszWizardName));
    memset(pszWizardLinkName, 0, sizeof(pszWizardLinkName));
    memset(pszWizardDesc, 0, sizeof(pszWizardDesc));
    memset(pszAccessoriesName, 0, sizeof(pszAccessoriesName));

    //
    // Get path to the "ProgramFiles" folder.
    //

    hres = SHGetFolderPath(NULL,
                           CSIDL_COMMON_PROGRAMS | CSIDL_FLAG_CREATE,
                           NULL,
                           0,
                           pszProgramPath);
    if(!SUCCEEDED(hres)){
        DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! Can't get ProgramFiles folder.\r\n")));
        bRet = FALSE;
        goto CreateWiaShortcut_return;

    }

    //
    // Get localized "Accessoies" folder name from reistry.
    //

    err = RegOpenKey(HKEY_LOCAL_MACHINE,
                     REGKEY_WINDOWS_CURRENTVERSION,
                     &khWindowsCurrentVersion);
    if(ERROR_SUCCESS != err){
        DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! Can't open Windows\\CurrentVersion.Err=0x%x \r\n"), err));
        bRet = FALSE;
        goto CreateWiaShortcut_return;
    }

    dwSize = sizeof(pszAccessoriesName);
    err = RegQueryValueEx(khWindowsCurrentVersion,
                          REGSTR_VAL_ACCESSORIES_NAME,
                          NULL,
                          &dwType,
                          (LPBYTE)pszAccessoriesName,
                          &dwSize);
    if(err){
        DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! Can't get %ws value.Err=0x%x\r\n"), REGSTR_VAL_ACCESSORIES_NAME, err));

        //
        // Unable to get "Accessories" name from registry. Let's take it from resource.
        //

        if( (NULL == g_hDllInstance)
         || (0 == LoadString(g_hDllInstance, LocalAccessoriesFolderName, pszAccessoriesName, MAX_PATH)) )
        {
            bRet = FALSE;
            goto CreateWiaShortcut_return;
        } // if(0 == LoadString(g_hDllInstance, AccessoriesFolderName, pszAccessoriesName, MAX_PATH))
    } // if(err)

    //
    // Load localizable string from resource.
    //

    if(NULL != g_hDllInstance){
        LoadString(g_hDllInstance, WiaWizardName, pszWizardName, MAX_PATH);
    } else {
        DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! No DLL instance\r\n")));

        bRet = FALSE;
        goto CreateWiaShortcut_return;
    }

    //
    // Get System path.
    //

    if( 0== GetSystemDirectory(pszSystemPath, MAX_PATH)){
        DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! GetSystemDirectory failed. Err=0x%x\r\n"), GetLastError()));

        bRet = FALSE;
        goto CreateWiaShortcut_return;
    }

    //
    // Create shortcut/program name.
    //


    _sntprintf(pszAccessoriesPath, ARRAYSIZE(pszAccessoriesPath)-1, TEXT("%ws\\%ws"), pszProgramPath, pszAccessoriesName);
    _sntprintf(pszWizardLinkName, ARRAYSIZE(pszWizardLinkName)-1, TEXT("%ws.lnk"), WIAWIZARDCHORCUTNAME);
    _sntprintf(pszShortcutPath, ARRAYSIZE(pszShortcutPath)-1, TEXT("%ws\\%ws"), pszAccessoriesPath, pszWizardLinkName);
    _sntprintf(pszWizardPath, ARRAYSIZE(pszWizardPath)-1, TEXT("%ws\\%ws"), pszSystemPath, WIAACMGR_PATH);
    _sntprintf(pszSticiPath, ARRAYSIZE(pszSticiPath)-1, TEXT("%ws\\%ws"), pszSystemPath, WIAINSTALLERFILENAME);
    _sntprintf(pszWizardDesc, ARRAYSIZE(pszWizardDesc)-1, TEXT("@%ws,-%d"), pszSticiPath, WiaWizardDescription);


    //
    // Create an IShellLink object and get a pointer to the IShellLink
    // interface (returned from CoCreateInstance).
    //

    hres = CoInitialize(NULL);
    if(!SUCCEEDED(hres)){
        DebugTrace(TRACE_ERROR,(("CoInitialize failed. hres=0x%x\r\n"), hres));
        bRet = FALSE;
        goto CreateWiaShortcut_return;
    }

    hres = CoCreateInstance(CLSID_ShellLink,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IShellLink,
                            (LPVOID *)&psl);
    if (SUCCEEDED(hres)){

       IPersistFile *ppf;

       //
       // Query IShellLink for the IPersistFile interface for
       // saving the shortcut in persistent storage.
       //

       hres = psl->QueryInterface(IID_IPersistFile, (void **)&ppf);
       if (SUCCEEDED(hres)){

            // Set the path to the shortcut target.
            hres = psl->SetPath(pszWizardPath);

            if (SUCCEEDED(hres)){
                // Set the argument to the shortcut target.
                hres = psl->SetArguments(WIAACMGR_ARG);

                if (SUCCEEDED(hres)){
                    // Set the description of the shortcut.

                    hres = psl->SetDescription(pszWizardDesc);

                    if (SUCCEEDED(hres)){
                        // Save the shortcut via the IPersistFile::Save member function.
                        hres = ppf->Save(pszShortcutPath, TRUE);

                        if (SUCCEEDED(hres)){
                            
                            //
                            // Shortcut created. Set MUI name.
                            //
                            
                            hres = SHSetLocalizedName(pszShortcutPath, pszSticiPath, WiaWizardName);
                            if (SUCCEEDED(hres)){
                            
                                //
                                // Operation succeeded.
                                //

                                bRet = TRUE;
                            } else {
                                DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! SHSetLocalizedName failed. hRes=0x%x\r\n"), hres));
                            }
                        } else {
                            DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! Save failed. hRes=0x%x\r\n"), hres));
                        }
                    } else {
                        DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! SetDescription failed. hRes=0x%x\r\n"), hres));
                    }
                } else {
                    DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! SetArguments failed. hRes=0x%x\r\n"), hres));
                }
            } else {
                DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! SetPath failed. hRes=0x%x\r\n"), hres));
            }

            // Release the pointer to IPersistFile.
            ppf->Release();
        } else {
            DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! QueryInterface(IID_IPersistFile) failed.\r\n")));
        }

        // Release the pointer to IShellLink.
        psl->Release();

        CoUninitialize();

    } else { // if (SUCCEEDED(hres))
        DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! CoCreateInstance(IID_IShellLink) failed.\r\n")));

        switch(hres){

            case REGDB_E_CLASSNOTREG :
                DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: REGDB_E_CLASSNOTREG.\r\n")));
                break;
            case CLASS_E_NOAGGREGATION  :
                DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: CLASS_E_NOAGGREGATION.\r\n")));
                break;
            case E_NOINTERFACE :
                DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: E_NOINTERFACE.\r\n")));
                break;

            default:
                DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: default.(hres=0x%x).\r\n hres=0x%x"), hres));
                break;
        }

        bRet = FALSE;
        goto CreateWiaShortcut_return;
    } // if (SUCCEEDED(hres))

CreateWiaShortcut_return:

    if(FALSE == bRet){
        CString csCmdLine;

        //
        // Try it again after next reboot.
        //

        csCmdLine.MakeSystemPath(STI_CI32_ENTRY_WIZMANU);
        csCmdLine = TEXT(" ") + csCmdLine;
        csCmdLine = RUNDLL32 + csCmdLine;

        SetRunonceKey(REGSTR_VAL_WIZMENU, csCmdLine);
    } // if(FALSE == bRet)

    //
    // Clean up
    //

    if(NULL != khWindowsCurrentVersion){
        RegCloseKey(khWindowsCurrentVersion);
    }

    return bRet;
}

BOOL
WINAPI
DeleteWiaShortcut(
    VOID
    )
{

    HRESULT     hres;
    IShellLink  *psl;
    LONG        err;
    HKEY        khWindowsCurrentVersion;
    DWORD       dwType;
    DWORD       dwSize;

    TCHAR       pszShortcutPath[MAX_PATH];
    TCHAR       pszAccessoriesName[MAX_PATH];   //  localized "Accessories" folder name.
    TCHAR       pszProgramPath[MAX_PATH];       //  path to ProgramFiles folder.

    BOOL        bRet;



    //
    // Init locals.
    //

    bRet    = FALSE;
    psl     = NULL;
    err     = 0;
    khWindowsCurrentVersion = NULL;

    memset(pszShortcutPath, 0, sizeof(pszShortcutPath));
    memset(pszAccessoriesName, 0, sizeof(pszAccessoriesName));
    memset(pszProgramPath, 0, sizeof(pszProgramPath));

    //
    // Get path to the "ProgramFiles" folder.
    //

    hres = SHGetFolderPath(NULL,
                           CSIDL_COMMON_PROGRAMS | CSIDL_FLAG_CREATE,
                           NULL,
                           0,
                           pszProgramPath);
    if(!SUCCEEDED(hres)){
        DebugTrace(TRACE_ERROR,(("DeleteWiaShortcut: ERROR!! Can't get ProgramFiles folder.\r\n"), hres));

        bRet = FALSE;
        goto DeleteWiaShortcut_return;

    }

    //
    // Get localized "Accessoies" folder name from reistry.
    //

    err = RegOpenKey(HKEY_LOCAL_MACHINE,
                     REGKEY_WINDOWS_CURRENTVERSION,
                     &khWindowsCurrentVersion);
    if(err){
        DebugTrace(TRACE_ERROR,(("DeleteWiaShortcut: ERROR!! Can't open Windows\\CurrentVersion key.Err=0x%x\r\n"), err));

        bRet = FALSE;
        goto DeleteWiaShortcut_return;
    }

    dwSize = sizeof(pszAccessoriesName)-sizeof(TCHAR);
    err = RegQueryValueEx(khWindowsCurrentVersion,
                          REGSTR_VAL_ACCESSORIES_NAME,
                          NULL,
                          &dwType,
                          (LPBYTE)pszAccessoriesName,
                          &dwSize);
    if(err){
        DebugTrace(TRACE_ERROR,(("DeleteWiaShortcut: ERROR!! Can't get %ws value.Err=0x%x\r\n"), REGSTR_VAL_ACCESSORIES_NAME, err));

        //
        // Unable to get "Accessories" name from registry. Let's take it from resource.
        //

        if( (NULL == g_hDllInstance)
         || (0 == LoadString(g_hDllInstance, LocalAccessoriesFolderName, pszAccessoriesName, MAX_PATH)) )
        {
            bRet = FALSE;
            goto DeleteWiaShortcut_return;
        } // if(0 == LoadString(g_hDllInstance, AccessoriesFolderName, pszAccessoriesName, MAX_PATH))
    }

    //
    // Create shortcut/program name.
    //

    _sntprintf(pszShortcutPath, ARRAYSIZE(pszShortcutPath)-1, TEXT("%ws\\%ws\\%ws.lnk"), pszProgramPath, pszAccessoriesName, WIAWIZARDCHORCUTNAME);

    if(!DeleteFile((LPCTSTR)pszShortcutPath)){
        DebugTrace(TRACE_ERROR,(("ERROR!! DeleteFile failed. Err=0x%x\r\n"), GetLastError()));

        bRet = FALSE;
        goto DeleteWiaShortcut_return;
    }

    //
    // Operation succeeded.
    //

    bRet = TRUE;

DeleteWiaShortcut_return:

    //
    // Clean up
    //

    if(NULL != khWindowsCurrentVersion){
        RegCloseKey(khWindowsCurrentVersion);
    }

    return bRet;
}

DLLEXPORT
VOID
CALLBACK
WiaCreateWizardMenu(
    HWND        hwnd,
    HINSTANCE   hinst,
    LPTSTR      lpszCmdLine,
    int         nCmdShow
    )
{
    CreateWiaShortcut();
}

DLLEXPORT
VOID
CALLBACK
AddDevice(
    HWND        hWnd,
    HINSTANCE   hInst,
    LPSTR       lpszCmdLine,
    int         nCmdShow
    )
{

    HANDLE                  hDevInfo;
    HWND                    hDlg;
    GUID                    Guid;
    SP_DEVINFO_DATA         spDevInfoData;
    SP_INSTALLWIZARD_DATA   InstallWizard;
    SP_DEVINSTALL_PARAMS    spDevInstallParams;
    TCHAR                   ClassName[LINE_LEN];
    DWORD                   err;
    DWORD                   dwRequired;
    HANDLE                  hMutex;

    CString                 csTitle;
    CString                 csSubTitle;
    CString                 csInstruction;
    CString                 csListLabel;

    DebugTrace(TRACE_PROC_ENTER,(("AddDevice: Enter...\r\n")));

    //
    // Initialize locals.
    //

    hDevInfo    = INVALID_HANDLE_VALUE;
    hDlg        = hWnd;
    Guid        = GUID_DEVCLASS_IMAGE;
    err         = ERROR_SUCCESS;
    dwRequired  = 0;
    hMutex      = NULL;

    memset(&spDevInfoData, 0, sizeof(spDevInfoData));
    memset(&InstallWizard, 0, sizeof(InstallWizard));
    memset(&spDevInstallParams, 0, sizeof(spDevInstallParams));
    memset(ClassName, 0, sizeof(ClassName));

    //
    // Acquire Mutex.
    //

    CInstallerMutex CMutex(&hMutex, WIAINSTALLWIZMUTEX, 0);
    if(!CMutex.Succeeded()){

        HWND    hwndAnotherWizard;
        CString csWindowTitle;

        hwndAnotherWizard = NULL;

        //
        // Other instance is running. Just activate that window and quit.
        //

        csWindowTitle.FromTable (MessageTitle);
        hwndAnotherWizard = FindWindow(NULL, (LPTSTR)csWindowTitle);
        if(NULL != hwndAnotherWizard){
            if(!SetForegroundWindow(hwndAnotherWizard)){
                DebugTrace(TRACE_ERROR, ("AddDevice: ERROR!! SetForegroundWindow() failed. Err=0x%x.\r\n", GetLastError()));
            } // if(!SetForegroundWindow(hwndAnotherWizard))
        } else { // if(NULL != hwndAnotherWizard)

            //
            // Mutex acquisition was failed but didn't find Window.
            // Continue.
            //

            DebugTrace(TRACE_WARNING, ("AddDevice: WARNING!! Mutex acquisition was failed but didn't find Window.\r\n"));
        } // else (NULL != hwndAnotherWizard)

        goto AddDevice_Err;
    } // if(!CMutex.Succeeded())

    //
    // Create Device Information Set from guid.
    //

    hDevInfo = SetupDiCreateDeviceInfoList(&Guid, hDlg);

    if (hDevInfo == INVALID_HANDLE_VALUE) {
        err=GetLastError();
        goto AddDevice_Err;
    }

//    //
//    // Get class install parameter.
//    //
//
//    if(!SetupDiGetClassInstallParams(hDevInfo,
//                                     NULL,
//                                     &spSelectDeviceParams.ClassInstallHeader,
//                                     sizeof(spSelectDeviceParams),
//                                     &dwRequired)){
//        err=GetLastError();
//        goto AddDevice_Err;
//    }


    //
    // Get class name from Guid.
    //

    if(!SetupDiClassNameFromGuid(&Guid,
                                 ClassName,
                                 sizeof(ClassName)/sizeof(TCHAR),
                                 NULL
                                 )){
        err=GetLastError();
        goto AddDevice_Err;
    }


    //
    // Create a new device information element to install
    //

    spDevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    if(!SetupDiCreateDeviceInfo(hDevInfo,
                                ClassName,
                                &Guid,
                                NULL,
                                hDlg,
                                DICD_GENERATE_ID,
                                &spDevInfoData
                                )){
        err=GetLastError();
        goto AddDevice_Err;
    }


    //
    // Set new element as selected device
    //

    if(!SetupDiSetSelectedDevice(hDevInfo,
                                &spDevInfoData
                                )){
        err=GetLastError();
        goto AddDevice_Err;
    }


    //
    // Get device install parameters
    //

    spDevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if(!SetupDiGetDeviceInstallParams(hDevInfo,
                                      &spDevInfoData,
                                      &spDevInstallParams
                                      )){
        err=GetLastError();
        goto AddDevice_Err;
    }


    //
    // Set device install parameters
    //

    spDevInstallParams.Flags |= DI_SHOWOEM ;
    spDevInstallParams.Flags |= DI_USECI_SELECTSTRINGS;

    spDevInstallParams.hwndParent = hDlg;

    if(!SetupDiSetDeviceInstallParams(hDevInfo,
                                      &spDevInfoData,
                                      &spDevInstallParams
                                      )){
        err=GetLastError();
        goto AddDevice_Err;
    }

    //
    // Set class install parameter.
    //

    InstallWizard.ClassInstallHeader.InstallFunction = DIF_INSTALLWIZARD;
    InstallWizard.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    InstallWizard.hwndWizardDlg =  hDlg;

    //
    // TRUE = Show first page
    //

    InstallWizard.PrivateFlags =   SCIW_PRIV_CALLED_FROMCPL | SCIW_PRIV_SHOW_FIRST;

    if(!SetupDiSetClassInstallParams(hDevInfo,
                                     &spDevInfoData,
                                     &InstallWizard.ClassInstallHeader,
                                     sizeof(SP_INSTALLWIZARD_DATA)
                                     ))
    {
        err=GetLastError();
        goto AddDevice_Err;
    }


    //
    // Call class installer to retrieve wizard pages
    //

    if(!SetupDiCallClassInstaller(DIF_INSTALLWIZARD,
                                  hDevInfo,
                                  &spDevInfoData
                                  )){
        err=GetLastError();
        goto AddDevice_Err;
    }

    //
    // Get result from class installer
    //

    if(!SetupDiGetClassInstallParams(hDevInfo,
                                     &spDevInfoData,
                                     &InstallWizard.ClassInstallHeader,
                                     sizeof(SP_INSTALLWIZARD_DATA),
                                     NULL
                                     ))
    {
        err=GetLastError();
        goto AddDevice_Err;
    }

    //
    // Prepare UI parameters to be used by DevSelect page,
    //

    csTitle.FromTable(SelDevTitle);
    csSubTitle.FromTable(SelDevSubTitle);
    csInstruction.FromTable(SelDevInstructions);
    csListLabel.FromTable(SelDevListLabel);

    if(!SetSelectDevTitleAndInstructions(hDevInfo,
                                         &spDevInfoData,
                                         (LPTSTR)csTitle,
                                         (LPTSTR)csSubTitle,
                                         (LPTSTR)csInstruction,
                                         (LPTSTR)csListLabel))
    {
        err=GetLastError();
        goto AddDevice_Err;
    }

    //
    // Get device selection page
    //

    InstallWizard.DynamicPageFlags =  DYNAWIZ_FLAG_PAGESADDED;
    InstallWizard.DynamicPages[InstallWizard.NumDynamicPages++] = SetupDiGetWizardPage(hDevInfo,
                                                                                       &spDevInfoData,
                                                                                       &InstallWizard,
                                                                                       SPWPT_SELECTDEVICE,
                                                                                       0);

    //
    // Create installer property sheet
    //

    {
        PROPSHEETHEADER PropSheetHeader;
        DWORD   Pages;
        HPROPSHEETPAGE SelectDevicePage;


        PropSheetHeader.dwSize = sizeof(PropSheetHeader);
        PropSheetHeader.dwFlags = PSH_WIZARD | PSH_USECALLBACK | PSH_WIZARD97 | PSH_STRETCHWATERMARK | PSH_WATERMARK | PSH_HEADER;
        PropSheetHeader.pszbmWatermark = MAKEINTRESOURCE(WizardBitmap);
        PropSheetHeader.pszbmHeader = MAKEINTRESOURCE(IDB_BANNERBMP);
        PropSheetHeader.hwndParent = hDlg;
        PropSheetHeader.hInstance = g_hDllInstance;
        PropSheetHeader.pszIcon = NULL;            //MAKEINTRESOURCE(IDI_NEWDEVICEICON);
        PropSheetHeader.pszCaption = MAKEINTRESOURCE(MessageTitle);
        PropSheetHeader.nStartPage = 0;
        PropSheetHeader.nPages = InstallWizard.NumDynamicPages;
        PropSheetHeader.phpage = InstallWizard.DynamicPages;
        PropSheetHeader.pfnCallback = iHdwWizardDlgCallback;

        if(PropertySheet(&PropSheetHeader) < 0){
            err=GetLastError();
        }

    }

AddDevice_Err:

    //
    // Free allocated memory
    //

    if(IS_VALID_HANDLE(hDevInfo)){


        //
        // Set install parameter.
        //

        InstallWizard.ClassInstallHeader.InstallFunction = DIF_DESTROYWIZARDDATA;
        InstallWizard.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
        if(!SetupDiSetClassInstallParams(hDevInfo,
                                         &spDevInfoData,
                                         &InstallWizard.ClassInstallHeader,
                                         sizeof(SP_INSTALLWIZARD_DATA)) )
        {
            DebugTrace(TRACE_ERROR,(("AddDevice: ERROR!! SetupDiSetClassInstallParams() failed with active hDevInfo.\r\n")));
        }

        //
        // Let isntaller free context data.
        //

        SetupDiCallClassInstaller(DIF_DESTROYWIZARDDATA,
                                  hDevInfo,
                                  &spDevInfoData
                                  );

        //
        // Destroy infoset.
        //
        
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

    DebugTrace(TRACE_PROC_LEAVE,(("AddDevice: Leaving... Ret=VOID.\r\n")));
    return;
}


BOOL
CALLBACK
RemoveDevice(
    HWND        hWnd,
    HINSTANCE   hInst,
    LPTSTR      lpszCmdLine,
    int         nCmdShow
    )
{

    HANDLE                  hDevInfo;
    SP_DEVINFO_DATA         spDevInfoData;
    SP_REMOVEDEVICE_PARAMS  spRemoveDeviceParams;
    BOOL                    bStatus;
    BOOL                    bIsInterfaceOnly;
    DWORD                   err;
    DWORD                   dwDeviceIndex;
    TCHAR                   szTemp[MAX_FRIENDLYNAME+1];

    DebugTrace(TRACE_PROC_ENTER,(("RemoveDevice: Enter...\r\n")));

    //
    // Initialize local.
    //

    hDevInfo            = INVALID_HANDLE_VALUE;
    bStatus             = FALSE;
    err                 = ERROR_SUCCESS;
    bIsInterfaceOnly    = FALSE;
    dwDeviceIndex       = INVALID_DEVICE_INDEX;

    memset (&spDevInfoData, 0, sizeof(SP_DEVINFO_DATA));
    memset((void *)&spRemoveDeviceParams, 0, sizeof(SP_REMOVEDEVICE_PARAMS));
    memset(szTemp, 0, sizeof(szTemp));

    //
    // Check the argument.
    //

    if(NULL == lpszCmdLine){
        DebugTrace(TRACE_ERROR,(("RemoveDevice: ERROR!! Invalid argumet.\r\n")));
        goto RemoveDevice_Err;
    } // if(NULL == lpszCmdLine)

    lstrcpyn(szTemp, lpszCmdLine, ARRAYSIZE(szTemp)-1);
    DebugTrace(TRACE_STATUS,(("RemoveDevice: Removing \"%ws\".\r\n"), szTemp));

    //
    // Get removing device element.
    //

    hDevInfo = SelectDevInfoFromDeviceId(szTemp);

    if(INVALID_HANDLE_VALUE != hDevInfo){
        spDevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        SetupDiGetSelectedDevice(hDevInfo, &spDevInfoData);
    } else {

        //
        // See if it's "Interface-only" device.
        //

        hDevInfo = GetDeviceInterfaceIndex(szTemp, &dwDeviceIndex);
        if( (INVALID_HANDLE_VALUE == hDevInfo)
         || (INVALID_DEVICE_INDEX == dwDeviceIndex) )
        {
            DebugTrace(TRACE_ERROR,(("RemoveDevice: ERROR!! Can't find \"%ws\".\r\n"), szTemp));
            goto RemoveDevice_Err;
        }

        //
        // This is "Interface-only" device.
        //

        bIsInterfaceOnly = TRUE;

    } // if(INVALID_HANDLE_VALUE != hDevInfo)

    if(bIsInterfaceOnly){
        DebugTrace(TRACE_STATUS,(("RemoveDevice: Uninstalling interface-only device.\r\n")));

        //
        // Uninstalling "Interface-only" device.
        //

        CDevice cdThis(hDevInfo, dwDeviceIndex);
        bStatus = (NO_ERROR == cdThis.Remove(NULL));

    } else { // if(bIsInterfaceOnly)
        DebugTrace(TRACE_STATUS,(("RemoveDevice: Uninstalling a device w/ devnode.\r\n")));

        //
        // Uninstalling device w/ devnode.
        //

        if(!SetupDiSetSelectedDevice(hDevInfo,
                                    &spDevInfoData
                                    )){
            err=GetLastError();
            goto RemoveDevice_Err;
        }

        //
        // Call class installer to remove selected device.
        //

        spRemoveDeviceParams.ClassInstallHeader.InstallFunction = DIF_REMOVE;
        spRemoveDeviceParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
        spRemoveDeviceParams.Scope = DI_REMOVEDEVICE_GLOBAL;

        if(!SetupDiSetClassInstallParams(hDevInfo,
                                         &spDevInfoData,
                                         &spRemoveDeviceParams.ClassInstallHeader,
                                         sizeof(SP_REMOVEDEVICE_PARAMS)
                                         )){
            err=GetLastError();
            goto RemoveDevice_Err;
        }

        if(!SetupDiCallClassInstaller(DIF_REMOVE,
                                      hDevInfo,
                                      &spDevInfoData
                                      )){
            err=GetLastError();
            goto RemoveDevice_Err;
        }

        //
        // Removal succeeded.
        //

        bStatus = TRUE;

    } // if(bIsInterfaceOnly)

RemoveDevice_Err:

    if(IS_VALID_HANDLE(hDevInfo)){
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }
    DebugTrace(TRACE_PROC_LEAVE,(("RemoveDevice... Ret=0x%x Err=0x%x.\r\n"), bStatus, err));
    return bStatus;
} // RemoveDevice()

DLLEXPORT
VOID
CALLBACK
InstallWiaService(
    HWND        hwnd,
    HINSTANCE   hinst,
    LPTSTR      lpszCmdLine,
    int         nCmdShow
    )
{
    DWORD   dwError;
    DWORD   dwStiCount;
    DWORD   dwWiaCount;
    HANDLE  hProcess;

    DebugTrace(TRACE_PROC_ENTER,(("InstallWiaService: Enter...\r\n")));

    //
    // Remove old service entry.
    //

    GetDeviceCount(&dwWiaCount, &dwStiCount);

    //
    // Install WIA service.  This will install only if the service failed to install during processing of STI.INF, else
    // it will simply change the StartType.
    //

    dwError = StiServiceInstall(FALSE,
                                TRUE,  // Disable by default
                                TEXT("NT AUTHORITY\\LocalService"),
                                TEXT(""));
    if(NOERROR != dwError){
        DebugTrace(TRACE_ERROR,(("InstallWiaService: ERROR!! Unable to install service. Err=0x%x\n"), dwError));
    } // if(NOERROR != dwError)

    //
    // Register WIA DLLs.
    //

    hProcess = ExecCommandLine(TEXT("regsvr32.exe /s wiaservc.dll"), EXECDIR_SYSTEM32);
    if(IS_VALID_HANDLE(hProcess)){
        CloseHandle(hProcess);
    }

    hProcess = ExecCommandLine(TEXT("regsvr32.exe /s sti.dll"), EXECDIR_SYSTEM32);
    if(IS_VALID_HANDLE(hProcess)){
        CloseHandle(hProcess);
    }

    hProcess = ExecCommandLine(TEXT("regsvr32.exe /s wiascr.dll"), EXECDIR_SYSTEM32);
    if(IS_VALID_HANDLE(hProcess)){
        CloseHandle(hProcess);
    }

    hProcess = ExecCommandLine(TEXT("regsvr32.exe /s wiashext.dll"), EXECDIR_SYSTEM32);
    if(IS_VALID_HANDLE(hProcess)){
        CloseHandle(hProcess);
    }

    hProcess = ExecCommandLine(TEXT("regsvr32.exe /s camocx.dll"), EXECDIR_SYSTEM32);
    if(IS_VALID_HANDLE(hProcess)){
        CloseHandle(hProcess);
    }

    hProcess = ExecCommandLine(TEXT("regsvr32.exe /s wiadefui.dll"), EXECDIR_SYSTEM32);
    if(IS_VALID_HANDLE(hProcess)){
        CloseHandle(hProcess);
    }

    hProcess = ExecCommandLine(TEXT("wiaacmgr.exe /RegServer"), EXECDIR_SYSTEM32);
    if(IS_VALID_HANDLE(hProcess)){
        CloseHandle(hProcess);
    }

    hProcess = ExecCommandLine(TEXT("regsvr32.exe /s wiavusd.dll"), EXECDIR_SYSTEM32);
    if(IS_VALID_HANDLE(hProcess)){
        CloseHandle(hProcess);
    }

    hProcess = ExecCommandLine(TEXT("regsvr32.exe /s wiasf.ax"), EXECDIR_SYSTEM32);
    if(IS_VALID_HANDLE(hProcess)){
        CloseHandle(hProcess);
    }

    hProcess = ExecCommandLine(TEXT("rundll32.exe  sti.dll,MigrateRegisteredSTIAppsForWIAEvents %%l"), EXECDIR_SYSTEM32);
    if(IS_VALID_HANDLE(hProcess)){
        CloseHandle(hProcess);
    }

    DebugTrace(TRACE_PROC_LEAVE,(("InstallWiaService: Leaving... Ret=VOID.\r\n")));

} // InstallWiaService()


HANDLE
SelectDevInfoFromDeviceId(
    LPTSTR  pszDeviceId
    )
{
    TCHAR                   szTemp[MAX_DEVICE_ID];
    HANDLE                  hDevInfo;
    GUID                    Guid;
    DWORD                   Idx;
    SP_DEVINFO_DATA         spDevInfoData;
    BOOL                    bFound;
    HKEY                    hKeyDevice;
    ULONG                   cbData;
    LONG                    lResult;

    DebugTrace(TRACE_PROC_ENTER,(("SelectDevInfoFromDeviceId: Enter...\r\n")));

    //
    // Initialize local.
    //

    hDevInfo    = INVALID_HANDLE_VALUE;
    Guid        = GUID_DEVCLASS_IMAGE;
//    Guid      = KSCATEGORY_CAPTURE;
    Idx         = 0;
    cbData      = 0;
    bFound      = FALSE;
    hKeyDevice  = NULL;
    lResult     = ERROR_SUCCESS;

    memset(szTemp, 0, sizeof(szTemp));
    memset(&spDevInfoData, 0, sizeof(spDevInfoData));

    //
    // Check argument.
    //

    if(NULL == pszDeviceId){
        DebugTrace(TRACE_ERROR,(("SelectDevInfoFromDeviceId: Invalid arbument.\r\n")));

        hDevInfo = INVALID_HANDLE_VALUE;
        goto SelectDevInfoFromDeviceId_return;
    }

    //
    // Get device info set of specified class.
    //

    hDevInfo = SetupDiGetClassDevs (&Guid, NULL, NULL, DIGCF_PROFILE);
    if (hDevInfo == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("SelectDevInfoFromDeviceId: SetupDiGetClassDevs failed. Err=0x%x\r\n"), GetLastError()));

        hDevInfo = INVALID_HANDLE_VALUE;
        goto SelectDevInfoFromDeviceId_return;
    }

    spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
    for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++) {

        DebugTrace(TRACE_STATUS,(("SelectDevInfoFromDeviceId: Checking Device(0x%x)\r\n"), Idx));
        hKeyDevice = SetupDiOpenDevRegKey (hDevInfo,
                                           &spDevInfoData,
                                           DICS_FLAG_GLOBAL,
                                           0,
                                           DIREG_DRV,
                                           KEY_READ);

        if (hKeyDevice != INVALID_HANDLE_VALUE) {

            //
            // Is DeviceId == pszDeviceId?
            //

            cbData = sizeof(szTemp)-sizeof(TEXT('\0'));
            lResult = RegQueryValueEx(hKeyDevice,
                                      REGSTR_VAL_DEVICE_ID,
                                      NULL,
                                      NULL,
                                      (LPBYTE)szTemp,
                                      &cbData);
            if(ERROR_SUCCESS == lResult){

                if(_tcsicmp((LPCTSTR)pszDeviceId, (LPCTSTR)szTemp) != 0) {

                    //
                    // Doesn't match, skip this one.
                    //

                    RegCloseKey(hKeyDevice);
                    continue;
                }
            } else {
                DebugTrace(TRACE_ERROR,(("SelectDevInfoFromDeviceId: can't get DeviceId. Err=0x%x\r\n"), GetLastError()));
                RegCloseKey(hKeyDevice);
                continue;
            }

            //
            // Found the target!
            //

            bFound = TRUE;
            RegCloseKey(hKeyDevice);
            break;
        } else {
            DebugTrace(TRACE_ERROR,(("SelectDevInfoFromDeviceId: Invalid handle.\r\n"), GetLastError()));
        } // if (hKeyDevice != INVALID_HANDLE_VALUE)

    } //for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++)

SelectDevInfoFromDeviceId_return:

    if(!bFound){

        //
        // FriendleName is not found.
        //

        if (IS_VALID_HANDLE(hDevInfo)) {
            SetupDiDestroyDeviceInfoList(hDevInfo);
            hDevInfo = INVALID_HANDLE_VALUE;
        }
    } else {

        //
        // Device found. Select found device.
        //

        SetupDiSetSelectedDevice(hDevInfo, &spDevInfoData);
    }

    DebugTrace(TRACE_PROC_LEAVE,(("SelectDevInfoFromDeviceId: Leaving... Ret=0x%x\r\n"), hDevInfo));

    return hDevInfo;
} // SelectDevInfoFromDeviceId()




HANDLE
GetDeviceInterfaceIndex(
    LPTSTR  pszDeviceId,
    DWORD   *pdwIndex
    )
{
    TCHAR                       szTemp[MAX_DEVICE_ID];
    HANDLE                      hDevInfo;
    GUID                        Guid;
    DWORD                       Idx;
    SP_DEVICE_INTERFACE_DATA    spDevInterfaceData;
    BOOL                        bFound;
    HKEY                        hKeyInterface;
    ULONG                       cbData;
    LONG                        lResult;

    DebugTrace(TRACE_PROC_ENTER,(("GetDeviceInterfaceIndex: Enter... DeviceId=%ws\r\n"), pszDeviceId));

    //
    // Initialize local.
    //

    hDevInfo        = INVALID_HANDLE_VALUE;
    Guid            = GUID_DEVCLASS_IMAGE;
    Idx             = 0;
    cbData          = 0;
    bFound          = FALSE;
    hKeyInterface   = NULL;
    lResult         = ERROR_SUCCESS;

    memset(szTemp, 0, sizeof(szTemp));
    memset(&spDevInterfaceData, 0, sizeof(spDevInterfaceData));

    //
    // Check argument.
    //

    if(NULL == pszDeviceId){
        DebugTrace(TRACE_ERROR,(("GetDeviceInterfaceIndex: Invalid arbument.\r\n")));

        hDevInfo = INVALID_HANDLE_VALUE;
        goto GetDeviceInterfaceIndex_return;
    }

    //
    // Get device info set of specified class interface.
    //

    hDevInfo = SetupDiGetClassDevs (&Guid,
                                    NULL,
                                    NULL,
                                    DIGCF_DEVICEINTERFACE | DIGCF_PROFILE);
    if (hDevInfo == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("GetDeviceInterfaceIndex: SetupDiGetClassDevs failed. Err=0x%x\r\n"), GetLastError()));

        hDevInfo = INVALID_HANDLE_VALUE;
        goto GetDeviceInterfaceIndex_return;
    }

    spDevInterfaceData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);
    for (Idx = 0; SetupDiEnumDeviceInterfaces (hDevInfo, NULL, &Guid, Idx, &spDevInterfaceData); Idx++) {

        DebugTrace(TRACE_STATUS,(("GetDeviceInterfaceIndex: Checking Interface(0x%x)\r\n"), Idx));
        hKeyInterface = SetupDiOpenDeviceInterfaceRegKey(hDevInfo,
                                                           &spDevInterfaceData,
                                                           0,
                                                           KEY_ALL_ACCESS);
        if (INVALID_HANDLE_VALUE != hKeyInterface) {

            //
            // Is FriendlyName == pszLocalName?
            //

            cbData = sizeof(szTemp)-sizeof(TEXT('\0'));
            lResult = RegQueryValueEx(hKeyInterface,
                                      REGSTR_VAL_DEVICE_ID,
                                      NULL,
                                      NULL,
                                      (LPBYTE)szTemp,
                                      &cbData);
            if(ERROR_SUCCESS == lResult){

                if(_tcsicmp((LPCTSTR)pszDeviceId, (LPCTSTR)szTemp) == 0) {

                    //
                    // Found the target!
                    //

                    bFound = TRUE;
                    RegCloseKey(hKeyInterface);
                    break;
                }
            } else { // if(ERROR_SUCCESS == lResult)
                DebugTrace(TRACE_STATUS,(("GetDeviceInterfaceIndex: can't get DeviceID. Err=0x%x\r\n"), GetLastError()));
            } // if(ERROR_SUCCESS == lResult)

            RegCloseKey(hKeyInterface);
            hKeyInterface = NULL;
        } else { // if (hKeyDevice != INVALID_HANDLE_VALUE)
            DWORD Err;
            Err = GetLastError();
            DebugTrace(TRACE_ERROR,(("GetDeviceInterfaceIndex: Invalid handle. Err=0x%x.\r\n"), Err));
        } // if (hKeyDevice != INVALID_HANDLE_VALUE)

    } //for (Idx = 0; SetupDiEnumDeviceInterface (hDevInfo, NULL, &Guid, Idx, &spDevInterfaceData); Idx++)

GetDeviceInterfaceIndex_return:

    if(FALSE == bFound){
        if (IS_VALID_HANDLE(hDevInfo)) {
            SetupDiDestroyDeviceInfoList(hDevInfo);
            hDevInfo = INVALID_HANDLE_VALUE;
        }

        *pdwIndex = INVALID_DEVICE_INDEX;

    } else {

        //
        // Interface found.
        //

        *pdwIndex = Idx;
    }

    DebugTrace(TRACE_PROC_LEAVE,(("GetDeviceInterfaceIndex: Leaving... Ret=0x%x\r\n"), hDevInfo));

    return hDevInfo;
} // GetDeviceInterfaceIndex()





INT CALLBACK
iHdwWizardDlgCallback(
    IN HWND             hwndDlg,
    IN UINT             uMsg,
    IN LPARAM           lParam
    )
/*++

Routine Description:

    Call back used to remove the "?" from the wizard page.

Arguments:

    hwndDlg - Handle to the property sheet dialog box.

    uMsg - Identifies the message being received. This parameter
            is one of the following values:

            PSCB_INITIALIZED - Indicates that the property sheet is
            being initialized. The lParam value is zero for this message.

            PSCB_PRECREATE      Indicates that the property sheet is about
            to be created. The hwndDlg parameter is NULL and the lParam
            parameter is a pointer to a dialog template in memory. This
            template is in the form of a DLGTEMPLATE structure followed
            by one or more DLGITEMTEMPLATE structures.

    lParam - Specifies additional information about the message. The
            meaning of this value depends on the uMsg parameter.

Return Value:

    The function returns zero.

--*/
{

    switch( uMsg ) {

    case PSCB_INITIALIZED:
        break;

    case PSCB_PRECREATE:
        if( lParam ){

            DLGTEMPLATE *pDlgTemplate = (DLGTEMPLATE *)lParam;
            pDlgTemplate->style &= ~DS_CONTEXTHELP;
        }
        break;
    }

    return FALSE;
}

BOOL
SetSelectDevTitleAndInstructions(
    HDEVINFO            hDevInfo,
    PSP_DEVINFO_DATA    pspDevInfoData,
    LPCTSTR             pszTitle,
    LPCTSTR             pszSubTitle,
    LPCTSTR             pszInstn,
    LPCTSTR             pszListLabel
    )
/*++

Routine Description:

Arguments:

Return Value:

Side effects:

--*/
{
    SP_SELECTDEVICE_PARAMS  SelectDevParams;
    BOOL                    fRet;

    memset((void *)&SelectDevParams, 0, sizeof(SelectDevParams));

    if ( pszTitle && (lstrlen(pszTitle) + 1 > MAX_TITLE_LEN ) ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( pszSubTitle && (lstrlen(pszSubTitle) + 1 > MAX_SUBTITLE_LEN )) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( pszInstn && (lstrlen(pszInstn) + 1 > MAX_INSTRUCTION_LEN )) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( pszListLabel && (lstrlen(pszListLabel) + 1 > MAX_LABEL_LEN )) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    SelectDevParams.ClassInstallHeader.cbSize
                                 = sizeof(SelectDevParams.ClassInstallHeader);

    if ( !SetupDiGetClassInstallParams(hDevInfo,
                                       pspDevInfoData,
                                       &SelectDevParams.ClassInstallHeader,
                                       sizeof(SelectDevParams),
                                       NULL) ) {
        DWORD   dwErr = GetLastError();

        if (ERROR_NO_CLASSINSTALL_PARAMS != dwErr ) {
            return FALSE;
        }
    }

    if ( pszTitle ){
        lstrcpyn(SelectDevParams.Title, pszTitle, ARRAYSIZE(SelectDevParams.Title));
        SelectDevParams.Title[ARRAYSIZE(SelectDevParams.Title)-1] = TEXT('\0');
    }

    if ( pszSubTitle ){
        lstrcpyn(SelectDevParams.SubTitle, pszSubTitle, ARRAYSIZE(SelectDevParams.SubTitle));
        SelectDevParams.SubTitle[ARRAYSIZE(SelectDevParams.SubTitle)-1] = TEXT('\0');
    }

    if ( pszInstn ){
        lstrcpyn(SelectDevParams.Instructions, pszInstn, ARRAYSIZE(SelectDevParams.Instructions));
        SelectDevParams.Instructions[ARRAYSIZE(SelectDevParams.Instructions)-1] = TEXT('\0');
    }
    
    if ( pszListLabel ){
        lstrcpyn(SelectDevParams.ListLabel, pszListLabel, ARRAYSIZE(SelectDevParams.ListLabel));
        SelectDevParams.ListLabel[ARRAYSIZE(SelectDevParams.ListLabel)-1] = TEXT('\0');
    }

    SelectDevParams.ClassInstallHeader.InstallFunction = DIF_SELECTDEVICE;
    fRet =  SetupDiSetClassInstallParams(hDevInfo,
                                         pspDevInfoData,
                                         &SelectDevParams.ClassInstallHeader,
                                         sizeof(SelectDevParams));

    return fRet;

}

BOOL
WINAPI
WiaDeviceEnum(
    VOID
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr = NULL;
    SC_HANDLE       hService = NULL;
    SERVICE_STATUS  ServiceStatus;
    UINT            uiRetry = 10;

    DebugTrace(TRACE_PROC_ENTER,(("WiaDeviceEnum: Enter... \r\n")));

    //
    // Open Service Control Manager.
    //

    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        DebugTrace(TRACE_ERROR,(("WiaDeviceEnum: ERROR!! OpenSCManager failed. Err=0x%x\n"), GetLastError()));
        goto exit;
    }

    //
    // Open WIA service.
    //

    hService = OpenService(
        hSvcMgr,
        STI_SERVICE_NAME,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        DebugTrace(TRACE_ERROR,(("WiaDeviceEnum: ERROR!! OpenService failed. Err=0x%x\n"), GetLastError()));
        goto exit;
    }

    //
    // Inform WIA service to refresh its device list.
    //

    rVal = ControlService(hService,
                          STI_SERVICE_CONTROL_REFRESH,
                         &ServiceStatus);
    if (!rVal) {
        DebugTrace(TRACE_WARNING,(("WiaDeviceEnum: WARNING!! ControlService failed. Err=0x%x\n"), GetLastError()));
        goto exit;
    }

exit:
    if(NULL != hService){
        CloseServiceHandle( hService );
    }
    if(NULL != hSvcMgr){
        CloseServiceHandle( hSvcMgr );
    }

    DebugTrace(TRACE_PROC_LEAVE,(("WiaDeviceEnum: Leaving... Ret=0x%x\n"), rVal));
    return rVal;

} // WiaDeviceEnum()



DLLEXPORT
PWIA_PORTLIST
WINAPI
WiaCreatePortList(
    LPWSTR  szDeviceId
    )
{

    PWIA_PORTLIST   pReturn;
    GUID            PortGuid;
    HDEVINFO        hPortDevInfo = NULL;
    DWORD           Idx;
    DWORD           dwRequired;
    DWORD           dwNumberOfPorts;
    DWORD           dwSize;
    CStringArray    csaPortName;
    TCHAR           szPortName[MAX_DESCRIPTION];
    TCHAR           szPortFriendlyName[MAX_DESCRIPTION];

    BOOL            bIsSerial;
    BOOL            bIsParallel;
    BOOL            bIsAutoCapable;
    BOOL            bIsPortSelectable;
    //
    // Initialize local.
    //

    Idx                     = 0;
    hPortDevInfo            = NULL;
    pReturn                 = NULL;
    dwSize                  = 0;
    dwRequired              = 0;
    dwNumberOfPorts         = 0;

    bIsSerial               = TRUE;
    bIsParallel             = TRUE;
    bIsAutoCapable          = FALSE;
    bIsPortSelectable       = TRUE;

    memset(szPortName, 0, sizeof(szPortName));
    memset(szPortFriendlyName, 0, sizeof(szPortFriendlyName));

    //
    // Convert from WCHAR to TCHAR
    //
    #ifndef UNICODE
//
//    #pragma message("Not optimal conversion - reimplement if running on nonUNICODE system")
//
//    TCHAR      szDeviceIdConverted[STI_MAX_INTERNAL_NAME_LENGTH+1];
//
//    szDeviceIdConverted[0] = TEXT('\0');
//    MultiByteToWideChar(CP_ACP,
//                        0,
//                        szDeviceIdConverted, 
//                        -1,
//                        szDeviceId, 
//                        sizeof(szDeviceId));
//
    #else
    // On UNICODE system use the same buffer
    #define szDeviceIdConverted szDeviceId
    #endif

    if(!CheckPortForDevice(szDeviceIdConverted, &bIsSerial, &bIsParallel, &bIsAutoCapable, &bIsPortSelectable)){
        DebugTrace(TRACE_ERROR,(("WiaGetPortList: ERROR!! Unable to get port info for device.\r\n")));

        pReturn = NULL;
        goto WiaGetPortList_return;
    }

    if(bIsAutoCapable){
        dwNumberOfPorts++;
        csaPortName.Add(AUTO);
    }

    //
    // Enumerate all Port class devices if "PortSelect=NO" is not specified.
    //

    if(bIsPortSelectable){

        //
        // Get GUID of port device.
        //

        if(!SetupDiClassGuidsFromName (PORTS, &PortGuid, sizeof(GUID), &dwRequired)){
            DebugTrace(TRACE_ERROR,(("WiaGetPortList: ERROR!! SetupDiClassGuidsFromName Failed. Err=0x%lX\r\n"), GetLastError()));

            pReturn = NULL;
            goto WiaGetPortList_return;
        } // if(!SetupDiClassGuidsFromName (PORTS, &Guid, sizeof(GUID), &dwRequired))

        //
        // Get device info set of port devices.
        //

        hPortDevInfo = SetupDiGetClassDevs (&PortGuid,
                                            NULL,
                                            NULL,
                                            DIGCF_PRESENT | DIGCF_PROFILE);
        if (hPortDevInfo == INVALID_HANDLE_VALUE) {
            DebugTrace(TRACE_ERROR,(("WiaGetPortList: ERROR!! SetupDiGetClassDevs Failed. Err=0x%lX\r\n"), GetLastError()));

            pReturn = NULL;
            goto WiaGetPortList_return;
        }

        //
        // Process all of device element listed in device info set.
        //

        for(Idx = 0; GetPortNamesFromIndex(hPortDevInfo, Idx, szPortName, szPortFriendlyName); Idx++){

            //
            // Add valid Port CreateFile/Friendly Name to array.
            //

            if(0 == lstrlen(szPortName)){
                DebugTrace(TRACE_ERROR,(("WiaGetPortList: ERROR!! Invalid Port/Friendly Name.\r\n")));

                szPortName[0] = TEXT('\0');
                continue;
            }

            DebugTrace(TRACE_STATUS,(("WiaGetPortList: Found Port %d: %ws.\r\n"), Idx, szPortName));

            //
            // Check it's port type.
            //

            if(_tcsstr((const TCHAR *)szPortName, TEXT("LPT"))){
                if(!bIsParallel){
                    szPortName[0] = TEXT('\0');
                    continue;
                }
            }

            if(_tcsstr((const TCHAR *)szPortName, TEXT("COM"))){
                if(!bIsSerial){
                    szPortName[0] = TEXT('\0');
                    continue;
                }
            }

            dwNumberOfPorts++;
            csaPortName.Add(szPortName);

            szPortName[0]           = TEXT('\0');

        } // for(Idx = 0; GetPortNamesFromIndex(hPortDevInfo, Idx, szPortName, szPortFriendlyName); Idx++)
    } // if(bIsPortSelectable)

    if(0 != dwNumberOfPorts){

        //
        // Allocate memory for returning structure.
        //

        dwSize = sizeof(DWORD) + sizeof(LPTSTR)*dwNumberOfPorts;
        pReturn = (PWIA_PORTLIST)new BYTE[dwSize];
        if(NULL == pReturn){
            goto WiaGetPortList_return;
        }
        memset(pReturn, 0, dwSize);

        //
        // Fill in the info.
        //

        pReturn->dwNumberOfPorts = dwNumberOfPorts;
        for(Idx = 0; Idx < dwNumberOfPorts; Idx++){
            pReturn->szPortName[Idx] = (LPTSTR)new BYTE[lstrlen(csaPortName[Idx])*sizeof(TCHAR)+sizeof(TEXT('\0'))];
            if(NULL != pReturn->szPortName[Idx]){
                lstrcpy(pReturn->szPortName[Idx], csaPortName[Idx]);
            } else {
                WiaDestroyPortList(pReturn);
                pReturn = NULL;
                break;
            } // if(NULL != pReturn->szPortName[Idx])
        } // for(Idx = 0; Idx < dwNumberOfPorts; Idx++)
    } // if(0 != dwNumberOfPorts)

WiaGetPortList_return:

    //
    // Cleanup
    //
    if ( IS_VALID_HANDLE(hPortDevInfo) ) {
        SetupDiDestroyDeviceInfoList(hPortDevInfo);
    }

    return pReturn;

} // WiaCreatePortList()

DLLEXPORT
VOID
WINAPI
WiaDestroyPortList(
    PWIA_PORTLIST   pWiaPortList
    )
{
    DWORD   Idx;

    if(NULL == pWiaPortList){
        return;
    } // if(NULL == pWiaPortList)

    for(Idx = 0; Idx < pWiaPortList->dwNumberOfPorts; Idx++){
        if(NULL != pWiaPortList->szPortName[Idx]){
            delete pWiaPortList->szPortName[Idx];
        } // if(NULL != pWiaPortList->szPortName[Idx])
    } // for(Idx = 0; Idx < pWiaPortList; Idx++)

    delete pWiaPortList;

    return;

} // WiaDestroyPortList()


BOOL
CheckPortForDevice(
    LPTSTR  szDeviceId,
    BOOL    *pbIsSerial,
    BOOL    *pbIsParallel,
    BOOL    *pbIsAutoCapable,
    BOOL    *pbIsPortSelectable
    )
{

    GUID            WiaGuid;
    HDEVINFO        hWiaDevInfo;
    DWORD           dwCapability;
    SP_DEVINFO_DATA spDevInfoData;
    CString         csConnection;
    CString         csPortSelect;
    DWORD           dwDeviceIndex;
    HKEY            hkDevice;
    BOOL            bCapabilityAcquired;
    BOOL            bRet;

    BOOL            bIsSerial;
    BOOL            bIsParallel;
    BOOL            bIsAutoCapable;
    BOOL            bIsPortSelectable;
    DWORD           dwIsPnp;


    //
    // Initialize locals.
    //

    dwCapability            = 0;
    dwIsPnp                 = 0;
    hWiaDevInfo             = INVALID_HANDLE_VALUE;
    dwDeviceIndex           = INVALID_DEVICE_INDEX;
    WiaGuid                 = GUID_DEVCLASS_IMAGE;

    bRet                    = FALSE;
    bCapabilityAcquired     = FALSE;

    bIsSerial               = TRUE;
    bIsParallel             = TRUE;
    bIsAutoCapable          = FALSE;
    bIsPortSelectable       = TRUE;

    memset(&spDevInfoData, 0, sizeof(spDevInfoData));

    //
    // Get specified device property.
    //

    hWiaDevInfo = SelectDevInfoFromDeviceId(szDeviceId);

    if(INVALID_HANDLE_VALUE != hWiaDevInfo){
        spDevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        SetupDiGetSelectedDevice(hWiaDevInfo, &spDevInfoData);

        hkDevice = SetupDiOpenDevRegKey(hWiaDevInfo,
                                        &spDevInfoData,
                                        DICS_FLAG_GLOBAL,
                                        0,
                                        DIREG_DRV,
                                        KEY_READ);

        if(INVALID_HANDLE_VALUE != hkDevice){
            csConnection.Load(hkDevice, CONNECTION);
            csPortSelect.Load(hkDevice, PORTSELECT);
            GetDwordFromRegistry(hkDevice, ISPNP, &dwIsPnp);

            if(GetDwordFromRegistry(hkDevice, CAPABILITIES, &dwCapability)){

                bCapabilityAcquired = TRUE;

            } // if(GetDwordFromRegistry(hkDevice, CAPABILITIES, &dwCapability))

            RegCloseKey(hkDevice);
            hkDevice = (HKEY)INVALID_HANDLE_VALUE;

        } // if(INVALID_HANDLE_VALUE != hkDevice)

        SetupDiDestroyDeviceInfoList(hWiaDevInfo);
        hWiaDevInfo = INVALID_HANDLE_VALUE;

    } else { // if(INVALID_HANDLE_VALUE != hDevInfo)

        SP_DEVICE_INTERFACE_DATA    spDeviceInterfaceData;

        //
        // See if it's "Interface-only" device.
        //

        hWiaDevInfo = GetDeviceInterfaceIndex(szDeviceId, &dwDeviceIndex);
        if( (INVALID_HANDLE_VALUE == hWiaDevInfo)
         || (INVALID_DEVICE_INDEX == dwDeviceIndex) )
        {
            DebugTrace(TRACE_ERROR,(("CheckPortForDevice: ERROR!! Can't find \"%ws\".\r\n"), szDeviceId));
            bRet = FALSE;
            goto CheckPortForDevice_return;
        }

        spDeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
        if(!SetupDiEnumDeviceInterfaces(hWiaDevInfo, NULL, &WiaGuid, dwDeviceIndex, &spDeviceInterfaceData)){
            DebugTrace(TRACE_ERROR,(("CheckPortForDevice: ERROR!! SetupDiEnumDeviceInterfaces() failed. Err=0x%x.\r\n"), GetLastError()));
            bRet = FALSE;
            goto CheckPortForDevice_return;
        }

        hkDevice = SetupDiOpenDeviceInterfaceRegKey(hWiaDevInfo, &spDeviceInterfaceData, 0, KEY_READ);
        if(INVALID_HANDLE_VALUE == hkDevice){
            DebugTrace(TRACE_ERROR,(("CheckPortForDevice: ERROR!! SetupDiOpenDeviceInterfaceRegKey() failed. Err=0x%x.\r\n"), GetLastError()));
            bRet = FALSE;
            goto CheckPortForDevice_return;
        }

        csConnection.Load(hkDevice, CONNECTION);
        csPortSelect.Load(hkDevice, PORTSELECT);
        GetDwordFromRegistry(hkDevice, ISPNP, &dwIsPnp);
        if(GetDwordFromRegistry(hkDevice, CAPABILITIES, &dwCapability)){

            bCapabilityAcquired = TRUE;

        } // if(GetDwordFromRegistry(hkDevice, CAPABILITIES, &dwCapability))

        RegCloseKey(hkDevice);
        hkDevice = (HKEY)INVALID_HANDLE_VALUE;

    } // else (INVALID_HANDLE_VALUE != hDevInfo)

    //
    // Check what port should be shown.
    //

    if(0 != dwIsPnp){
        //
        // This is PnP device. No port should be available.
        //

        bRet                    = FALSE;
        goto CheckPortForDevice_return;
    }

    if(bCapabilityAcquired){

        if(csConnection.IsEmpty()){
            bIsSerial   = TRUE;
            bIsParallel = TRUE;
        } else {
            if(0 == _tcsicmp((LPTSTR)csConnection, SERIAL)){
                bIsSerial   = TRUE;
                bIsParallel = FALSE;
            }
            if(0 == _tcsicmp((LPTSTR)csConnection, PARALLEL)){
                bIsSerial   = FALSE;
                bIsParallel = TRUE;
            }
        }

        if(dwCapability & STI_GENCAP_AUTO_PORTSELECT){
            bIsAutoCapable = TRUE;
        } else {
            bIsAutoCapable = FALSE;
        }

        if(0 == MyStrCmpi(csPortSelect, NO)){
            bIsPortSelectable = FALSE;
        } else {// if(0 == lstrcmpi(csPortSelect, NO))
            bIsPortSelectable = TRUE;
        }
    } else {
        DebugTrace(TRACE_ERROR,(("CheckPortForDevice: ERROR!! Unable to acquire info from registry.\r\n")));
        bRet = FALSE;
        goto CheckPortForDevice_return;
    }

    //
    // Operation succeeded.
    //

    bRet = TRUE;

CheckPortForDevice_return:

    if(IS_VALID_HANDLE(hWiaDevInfo)){
        SetupDiDestroyDeviceInfoList(hWiaDevInfo);
    }

    if(bRet){
        *pbIsSerial         = bIsSerial;
        *pbIsParallel       = bIsParallel;
        *pbIsAutoCapable    = bIsAutoCapable;
        *pbIsPortSelectable = bIsPortSelectable;
    }

    return bRet;

} // CheckPortForDevice()

DLLEXPORT
BOOL
WINAPI
MigrateDevice(
    PDEVICE_INFO    pMigratingDevice
    )
{
    BOOL    bSucceeded;

    //
    // Initialize local.
    //

    bSucceeded  = TRUE;

    //
    // Validate migrating device.
    //

    if(!IsValidMigrationDevice(pMigratingDevice)){
        DebugTrace(TRACE_ERROR,(("MigrateDevice: ERROR!! Invalid migration device.\r\n")));
        bSucceeded = FALSE;
        return FALSE;
    } // if(!IsValidMigrationDevice(pMigratingDevice))

    //
    // Create Device class object.
    //

    CDevice cdThis(pMigratingDevice);

    //
    // Set default devnode selector.
    //

    cdThis.SetDevnodeSelectCallback((DEVNODESELCALLBACK)GetDevinfoFromPortName);

    //
    // Generate FriendlyName.
    //

    cdThis.NameDefaultUniqueName();

    //
    // Install(migrate) the device.
    //

    bSucceeded = cdThis.PreInstall();
    if(bSucceeded){
        bSucceeded = cdThis.Install();
    }

    //
    // Do final touch. Clean up if failed, or finish installation.
    //

    cdThis.PostInstall(bSucceeded);

//MigrateDevice_return:

    return bSucceeded;
} // MigrateDevice()

BOOL
IsValidMigrationDevice(
    PDEVICE_INFO    pMigratingDevice
    )
{
    BOOL        bRet;
    DWORD       dwCounter;
    PARAM_LIST  CurrentParam;
    PVOID       pNext;
    HINF        hInf;

    //
    // Initialize local.
    //
    
    bRet        = FALSE;
    dwCounter   = 0;
    pNext       = NULL;
    hInf        = INVALID_HANDLE_VALUE;
    memset(&CurrentParam, 0, sizeof(CurrentParam));
    
    //
    // See if given pointer is NULL.
    //
    
    if(NULL == pMigratingDevice){
        DebugTrace(TRACE_ERROR,(("IsValidMigrationDevice: ERROR!! Passed pointer is NULL.\r\n")));
        bRet = FALSE;
        goto IsValidMigrationDevice_return;
    } // if(NULL == pMigratingDevice)
    
    //
    // See if all members are valid.
    //
    
    _try {
        
        //
        // It must have valid FridendlyName.
        //
        
        if( (NULL == pMigratingDevice->pszFriendlyName)
         || (!IsValidFriendlyName(pMigratingDevice->pszFriendlyName)) )
        {
            DebugTrace(TRACE_ERROR,(("IsValidMigrationDevice: ERROR!! Invalid FriendlyName.\r\n")));
            bRet = FALSE;
            goto IsValidMigrationDevice_return;
        }

        //
        // It must have valid INF path and section.
        //

        if( (NULL == pMigratingDevice->pszInfPath)
         || (NULL == pMigratingDevice->pszInfSection) )
        {
            DebugTrace(TRACE_ERROR,(("IsValidMigrationDevice: ERROR!! Invalid INF info.\r\n")));
            bRet = FALSE;
            goto IsValidMigrationDevice_return;
        }

        //
        // See if INF exists or not.
        //

        hInf = SetupOpenInfFileA(pMigratingDevice->pszInfPath, NULL, INF_STYLE_WIN4, NULL);
        if(INVALID_HANDLE_VALUE == hInf){
            DebugTrace(TRACE_ERROR,(("IsValidMigrationDevice: ERROR!! INF doesn't exist.\r\n")));
            bRet = FALSE;
            goto IsValidMigrationDevice_return;
        } else {
            SetupCloseInfFile(hInf);
            hInf = INVALID_HANDLE_VALUE;
        }

        //
        // It must have valid DeviceData parameters.
        //

        dwCounter = pMigratingDevice->dwNumberOfDeviceDataKey;
        pNext = pMigratingDevice->pDeviceDataParam;
        for(;dwCounter != 0; dwCounter--){
            CurrentParam = *((PPARAM_LIST)pNext);
            pNext = CurrentParam.pNext;
        } // for(;dwCounter != 0; dwCounter--)
    } // _try
    _except (EXCEPTION_EXECUTE_HANDLER) {
        DebugTrace(TRACE_ERROR,(("IsValidMigrationDevice: ERROR!! Access to given data caused AV.\r\n")));
        bRet = FALSE;
        goto IsValidMigrationDevice_return;
    } // _except (EXCEPTION_EXECUTE_HANDLER)
    
    //
    // Data validated.
    //
    
    bRet = TRUE;
    
IsValidMigrationDevice_return:
    return bRet;

} // IsValidMigrationDevice()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\firstpg.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Firstpg.h
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   First page of WIA class installer.
*
*******************************************************************************/

#ifndef _FIRSTPG_H_
#define _FIRSTPG_H_

//
// Include
//

#include    "wizpage.h"

//
// Extern
//

extern HINSTANCE g_hDllInstance;

//
// Class
//

class CFirstPage : public CInstallWizardPage 
{

    BOOL        m_bShowThisPage;
    
public:

    CFirstPage(PINSTALLER_CONTEXT pInstallerContext);
    ~CFirstPage() {}

    virtual BOOL    OnInit();
    virtual BOOL    OnNotify(LPNMHDR lpnmh);
};

#endif // _FIRSTPG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\finalpg.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Finalpg.h
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Header file for final page of WIA class installer.
*
*******************************************************************************/

#ifndef _FINALPG_H_
#define _FINALPG_H_

//
// Include
//

#include "wizpage.h"
#include "device.h"

//
// Typedef
//

typedef BOOL (CALLBACK FAR * INSTALLSELECTEDDRIVER)(HWND hwndParent, HDEVINFO hDeviceInfo, LPCWSTR DisplayName, BOOL Backup, PDWORD pReboot);

//
// Class
//

class CInstallPage : public CInstallWizardPage {

    PINSTALLER_CONTEXT  m_pInstallerContext;    // Installer context.

public:

    CInstallPage(PINSTALLER_CONTEXT pInstallerContext);
    ~CInstallPage() {}

    virtual BOOL    OnInit();
    virtual BOOL    OnNotify(LPNMHDR lpnmh);
};

#endif // _FINALPG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\firstpg.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Firstpg.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   First page of WIA class installer.
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Include
//


#include "firstpg.h"


//
// Function
//

CFirstPage::CFirstPage(PINSTALLER_CONTEXT pInstallerContext) :
    CInstallWizardPage(pInstallerContext, IDD_DYNAWIZ_FIRSTPAGE)
{

    //
    // Set link to previous/next page.
    //

    m_uPreviousPage = 0;
    m_uNextPage     = IDD_DYNAWIZ_SELECTDEV_PAGE;

    //
    // See if this page shuld be skipped.
    //

    m_bShowThisPage = pInstallerContext->bShowFirstPage;

}


BOOL
CFirstPage::OnInit()
{
    HFONT   hFont;
    HICON   hIcon;

    //
    // Initialize locals.
    //

    hFont   = NULL;
    hIcon   = NULL;

    //
    // Change icon if it's invoked from S&C folder.
    //

    if(m_bShowThisPage){
        hIcon = ::LoadIcon(g_hDllInstance, MAKEINTRESOURCE(ImageIcon));
        if(NULL != hIcon){
            SendMessage(m_hwndWizard, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
            SendMessage(m_hwndWizard, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
        } // if(NULL != hIcon)
    } // if(m_bShowThisPage)

    //
    // Enable "NEXT" button, disable "Back" button.
    //

    SendMessage(m_hwndWizard, PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT);

    //
    // Set font of title.
    //

    hFont = GetIntroFont(m_hwndWizard);

    if( hFont ){
        HWND hwndControl = GetDlgItem(m_hwnd, WelcomeMessage);

        if( hwndControl ){
            SetWindowFont(hwndControl, hFont, TRUE);
        } // if( hwndControl )
    } // if( hFont )

    return  TRUE;
}

//
//  This page is a NOP...return -1 to activate the Next or Previous page.
//

BOOL
CFirstPage::OnNotify(
    LPNMHDR lpnmh
    )
{

    if (lpnmh->code == PSN_SETACTIVE) {

        TCHAR   szTitle[MAX_PATH] = {TEXT('\0')};

        //
        // Set Window title.
        //

        if(0 != ::LoadString(g_hDllInstance, MessageTitle, szTitle, MAX_PATH)){
            PropSheet_SetTitle(m_hwndWizard ,0 , szTitle);
        } // if(0 != ::LoadString(m_DllHandle, 0, szTitle, MAX_PATH)

        if(!m_bShowThisPage){

                //
                // Jump to device seleciton page.
                //

                SetWindowLongPtr(m_hwnd, DWLP_MSGRESULT, IDD_DYNAWIZ_SELECTDEV_PAGE);
                return TRUE;

        } // if(!m_bShowThisPage)
    } // if (lpnmh->code == PSN_SETACTIVE)

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\exports.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Exports..h
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*  Header file for class installer exports.
*
*******************************************************************************/


#ifndef _EXPORTS_H_
#define _EXPORTS_H_

//
// Include
//

#include <sti.h>

//
// Define
//

#define STR_ADD_DEVICE      TEXT("rundll32.exe sti_ci.dll,AddDevice")
#define STR_REMOVE          TEXT("rundll32.exe sti_ci.dll,RemoveDevice ")

#define REGKEY_WINDOWS_CURRENTVERSION   TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")
#define REGSTR_VAL_ACCESSORIES_NAME     TEXT("SM_AccessoriesName")

#define WIA_DEVKEYLIST_INITIAL_SIZE     1024

//
// Typedef
//

typedef struct _WIA_DEVKEYLIST {

    DWORD   dwNumberOfDevices;
    HKEY    hkDeviceRegistry[1];

} WIA_DEVKEYLIST, *PWIA_DEVKEYLIST;

typedef struct _WIA_PORTLIST {

    DWORD   dwNumberOfPorts;
    LPWSTR  szPortName[1];

} WIA_PORTLIST, *PWIA_PORTLIST;

typedef PWIA_DEVKEYLIST (CALLBACK FAR * WIAENUMDEVICEREGISTRY)(BOOL bEnumActiveOnly);

//
// Prototype
//

HANDLE
WiaInstallerProcess(
    LPTSTR   lpCommandLine
    );

INT
CALLBACK
iHdwWizardDlgCallback(
    IN HWND             hwndDlg,
    IN UINT             uMsg,
    IN LPARAM           lParam
    );


BOOL
SetSelectDevTitleAndInstructions(
    HDEVINFO            hDevInfo,
    PSP_DEVINFO_DATA    pspDevInfoData,
    LPCTSTR             pszTitle,
    LPCTSTR             pszSubTitle,
    LPCTSTR             pszInstn,
    LPCTSTR             pszListLabel
    );

DLLEXPORT
HANDLE
WINAPI
WiaAddDevice(
    VOID
    );

DLLEXPORT
BOOL
WINAPI
WiaRemoveDevice(
    PSTI_DEVICE_INFORMATION pStiDeviceInformation
    );

BOOL
WINAPI
CreateWiaShortcut(
    VOID
    );

BOOL
WINAPI
DeleteWiaShortcut(
    VOID
    );

HANDLE
SelectDevInfoFromDeviceId(
    LPTSTR  pszDeviceId
    );

DLLEXPORT
VOID
CALLBACK
WiaCreateWizardMenu(
    HWND        hwnd,
    HINSTANCE   hinst,
    LPSTR       lpszCmdLine,
    int         nCmdShow
    );

DLLEXPORT
VOID
CALLBACK
AddDevice(
    HWND        hWnd,
    HINSTANCE   hInst,
    LPSTR       lpszCmdLine,
    int         nCmdShow
    );

BOOL
CALLBACK
RemoveDevice(
    HWND        hWnd,
    HINSTANCE   hInst,
    LPTSTR      lpszCmdLine,
    int         nCmdShow
    );

INT CALLBACK
iHdwWizardDlgCallback(
    IN HWND             hwndDlg,
    IN UINT             uMsg,
    IN LPARAM           lParam
    );

BOOL
SetSelectDevTitleAndInstructions(
    HDEVINFO    hDevInfo,
    LPCTSTR     pszTitle,
    LPCTSTR     pszSubTitle,
    LPCTSTR     pszInstn
    );

HANDLE
GetDeviceInterfaceIndex(
    LPTSTR  pszLocalName,
    DWORD   *pdwIndex
    );

BOOL
WINAPI
WiaDeviceEnum(
    VOID
    );


DLLEXPORT
PWIA_PORTLIST
WINAPI
WiaCreatePortList(
    VOID
    );

DLLEXPORT
VOID
WINAPI
WiaDestroyPortList(
    PWIA_PORTLIST   pWiaPortList
    );

BOOL
CheckPortForDevice(
    LPTSTR  szDeviceId,
    BOOL    *pbIsSerial,
    BOOL    *pbIsParallel,
    BOOL    *pbIsAutoCapable,
    BOOL    *pbIsPortSelectable
    );

DLLEXPORT
BOOL
WINAPI
MigrateDevice(
    PDEVICE_INFO    pMigratingDevice
    );


#endif // _EXPORTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\finalpg.cpp ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Final.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Final page of WIA class installer.
*
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Include
//

#include "finalpg.h"

//
// Function
//

CInstallPage::CInstallPage(PINSTALLER_CONTEXT pInstallerContext) :
    CInstallWizardPage(pInstallerContext, EmeraldCity)
{

    //
    // Set link to previous/next page. This page should show up.
    //

    m_uPreviousPage = NameTheDevice;
    m_uNextPage     = 0;

    //
    // Initialize member.
    //

    m_pInstallerContext = pInstallerContext;

} // CInstallPage::CInstallPage()

BOOL
CInstallPage::OnInit()
{
    HFONT    hFont;

    //
    // Set font of title.
    //

    hFont = GetIntroFont(m_hwndWizard);

    if( hFont ){
        HWND hwndControl = GetDlgItem(m_hwnd, CompleteMessage);

        if( hwndControl ){
            SetWindowFont(hwndControl, hFont, TRUE);
        } // if( hwndControl )
    } // if( hFont )

    return  TRUE;
}


BOOL
CInstallPage::OnNotify(
    LPNMHDR lpnmh
    )
{

    if (lpnmh->code == PSN_WIZFINISH){

        BOOL    bSucceeded;

        if(NULL == m_pCDevice){
            goto OnNotify_return;
        }
        
        //
        // Register the device element.
        //

        bSucceeded = SetupDiRegisterDeviceInfo(m_pCDevice->m_hDevInfo, 
                                               m_pCDevice->m_pspDevInfoData,
                                               0,
                                               NULL,
                                               NULL,
                                               NULL);
        if(FALSE == bSucceeded){
            DebugTrace(TRACE_ERROR,(("CInstallPage::OnNotify: ERROR!! SetupDiRegisterDeviceInfo() failed. Err=0x%x.\r\n"), GetLastError()));
            goto OnNotify_return;
        } // if(FALSE == bSucceeded)

        //
        // Do device installation.
        //
        
        {

            INSTALLSELECTEDDRIVER   pfnInstallSelectedDriver;
            HMODULE                 hNewDevDll;
            DWORD                   dwReboot;
            
            //
            // Device/Driver must be selected at this point.
            //

            //
            // Load newdev.dll
            //
            
            hNewDevDll = LoadLibrary(NEWDEVDLL);
            if(NULL != hNewDevDll){

                pfnInstallSelectedDriver = (INSTALLSELECTEDDRIVER)GetProcAddress(hNewDevDll, "InstallSelectedDriver");
                if(NULL != pfnInstallSelectedDriver){
                    
                    //
                    // Call install function in newdev.dll
                    //
                    
                    dwReboot = 0;
                    bSucceeded = pfnInstallSelectedDriver(NULL, m_pCDevice->m_hDevInfo, NULL, TRUE, NULL);

                } else { // if(NULL != pfnInstallSelectedDriver)
                    DebugTrace(TRACE_ERROR,(("CInstallPage::OnNotify: ERROR!! Unable to get the address of InstallSelectedDriver. Err=0x%x.\r\n"), GetLastError()));
                    FreeLibrary(hNewDevDll);
                    goto OnNotify_return;
                } // if(NULL == pfnInstallSelectedDriver)
            
                FreeLibrary(hNewDevDll);

            } else { 
                DebugTrace(TRACE_ERROR,(("CInstallPage::OnNotify: ERROR!! Unable to load newdev.dll. Err=0x%x.\r\n"), GetLastError()));
                goto OnNotify_return;
            } // if(NULL == hNewDevDll)
        }

        //
        // Do post-installation if succeeded, to make sure about the portname and FriendlyName.
        //

        if(bSucceeded){
            m_pCDevice->PostInstall(TRUE);
        }

        //
        // Free device object anyway.
        //

        delete m_pCDevice;
        m_pCDevice = NULL;
        m_pInstallerContext->pDevice = NULL;

    } // if (lpnmh->code == PSN_WIZFINISH)

    if (lpnmh->code == PSN_SETACTIVE){

        //
        // Get CDevice object from context.
        //

        m_pCDevice = (CDevice *)m_pInstallerContext->pDevice;
    } // if (lpnmh->code == PSN_SETACTIVE)

OnNotify_return:
    return  FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\nameit.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Nameit.h
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Header file for a page to name a device.
*
*******************************************************************************/

#ifndef _NAMEIT_H_
#define _NAMEIT_H_

//
// Include
//

#include    "wizpage.h"
#include    "device.h"

//
// Class
//

class CNameDevicePage : public CInstallWizardPage {

    PINSTALLER_CONTEXT  m_pInstallerContext;    // Installer context.

    public:

    CNameDevicePage(PINSTALLER_CONTEXT pInstallerContext);
    ~CNameDevicePage();

    virtual BOOL    OnNotify(LPNMHDR lpnmh);
};

#endif // _NAMEIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\nameit.cpp ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Nameit.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Device naming page of WIA class installer.
*
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Include
//

#include "nameit.h"

//
// Function
//

CNameDevicePage::CNameDevicePage(PINSTALLER_CONTEXT pInstallerContext) :
    CInstallWizardPage(pInstallerContext, NameTheDevice)
{

    //
    // Set link to previous/next page. This page should show up.
    //

    m_uPreviousPage = IDD_DYNAWIZ_SELECT_NEXTPAGE;
    m_uNextPage     = EmeraldCity;

    //
    // Initialize member.
    //

    m_pInstallerContext = pInstallerContext;

}

CNameDevicePage::~CNameDevicePage() {

} // CNameDevicePage()


BOOL
CNameDevicePage::OnNotify(
    LPNMHDR lpnmh
    )
{
    BOOL    bRet;
    DWORD   dwMessageId;

    DebugTrace(TRACE_PROC_ENTER,(("CNameDevicePage::OnNotify: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet        = FALSE;
    dwMessageId = 0;

    //
    // Dispatch message.
    //

    switch(lpnmh->code){

        case PSN_KILLACTIVE:
        {
            CString csFriendlyName;

            DebugTrace(TRACE_STATUS,(("CNameDevicePage::OnNotify: PSN_KILLACTIVE.\r\n")));

            //
            // Dialog is about to disappear. Set FriendlyName.
            //

            if(NULL == m_pCDevice){
                DebugTrace(TRACE_WARNING,(("CNameDevicePage::OnNotify: WARNING!! CDevice doesn't exist.\r\n")));

                bRet = FALSE;
                goto OnNotify_return;
            }

            //
            // Get FriendlyName from text box.
            //

            csFriendlyName.GetContents(GetDlgItem(m_hwnd, DeviceFriendlyName));

            //
            // Check the FriendlyName only when user push 'NEXT'.
            //

            if(m_bNextButtonPushed){

                DWORD   dwLength;

                //
                // Check length.
                //

                dwLength = lstrlen((LPCTSTR)csFriendlyName);

                if(0 == dwLength){
                    dwMessageId = NoDeviceName;
                }

                if(dwLength > MAX_FRIENDLYNAME){
                    dwMessageId = DeviceNameTooLong;
                }

                //
                // Check if it's unique.
                //

                if(!csFriendlyName.IsEmpty()){

                    //
                    // Acquire mutex to access name store.
                    //

                    if(ERROR_SUCCESS != m_pCDevice->AcquireInstallerMutex(MAX_MUTEXTIMEOUT)){  // it must be done at least in 60 sec.
                        DebugTrace(TRACE_ERROR,("CNameDevicePage::OnNotify: ERROR!! Unable to acquire mutex in 60 sec.\r\n"));
                    } // if(ERROR_SUCCESS != AcquireInstallerMutex(60000))

                    //
                    // Refresh current device list.
                    //
                    
                    m_pCDevice->CollectNames();
                    
                    //
                    // See if Friendly is unique.
                    //

                    if(!(m_pCDevice->IsFriendlyNameUnique((LPTSTR)csFriendlyName))){
                        dwMessageId = DuplicateDeviceName;
                    } // if(!(m_pCDevice->IsFriendlyNameUnique((LPTSTR)csFriendlyName)))

                } // if(!csFriendlyName.IsEmpty())

                //
                // If FriendlyName is invalid, show error MessageBox.
                //

                if(0 != dwMessageId){

                    //
                    // Select text box.
                    //

                    SendDlgItemMessage(m_hwnd,
                                       DeviceFriendlyName,
                                       EM_SETSEL,
                                       0,
                                       MAKELPARAM(0, -1));
                    SetFocus(GetDlgItem(m_hwnd, DeviceFriendlyName));

                    //
                    // Show error message box.
                    //

                    ShowInstallerMessage(dwMessageId);

                    //
                    // Don't leave this page.
                    //

                    SetWindowLongPtr(m_hwnd, DWLP_MSGRESULT, TRUE);
                    bRet = TRUE;
                    goto OnNotify_return;
                } else { // if(0 != dwMessageId)

                    //
                    // Set FriendlyName.
                    //

                    m_pCDevice->SetFriendlyName((LPTSTR)csFriendlyName);
                } //  // if(0 != dwMessageId)
            } //  else (m_bNextButtonPushed)

            //
            // Release mutex.
            //

            m_pCDevice->ReleaseInstallerMutex();

            //
            // Reset pCDevice. 
            //

            m_pCDevice = NULL;

            bRet = TRUE;
            goto OnNotify_return;
        } // case PSN_KILLACTIVE

        case PSN_SETACTIVE:
        {
            DebugTrace(TRACE_STATUS,(("CNameDevicePage::OnNotify: PSN_SETACTIVE.\r\n")));

            //
            // Get current CDevice object;
            //

            m_pCDevice = (CDevice *)m_pInstallerContext->pDevice;
            if(NULL == m_pCDevice){
                DebugTrace(TRACE_ERROR, (("CNameDevicePage::OnNotify: ERROR!! CDevice is not created.\r\n")));
            }

            //
            // Show current friendly name.
            //

            SetDlgItemText(m_hwnd, DeviceFriendlyName, m_pCDevice->GetFriendlyName());

            //
            // Limit the text upto MAX_FRIENDLYNAME. (=64)
            //

            SendDlgItemMessage(m_hwnd, DeviceFriendlyName, EM_LIMITTEXT, MAX_FRIENDLYNAME, 0);

            //
            // If "PortSelect = no", then set previous page to device selection page.
            //
            
            if(PORTSELMODE_NORMAL != m_pCDevice->GetPortSelectMode())
            {
                m_uPreviousPage = IDD_DYNAWIZ_SELECTDEV_PAGE;
            } else {
                m_uPreviousPage = IDD_DYNAWIZ_SELECT_NEXTPAGE;
            }

            goto OnNotify_return;
        } // case PSN_SETACTIVE:
    } // switch(lpnmh->code)

OnNotify_return:

    //
    // Release mutex. ReleaseInstallerMutex() will handle invalid handle also, so we can call anyway.
    //

    if(NULL != m_pCDevice){
        m_pCDevice->ReleaseInstallerMutex();
    } // if(NULL != m_pCDevice)

    DebugTrace(TRACE_PROC_LEAVE,(("CNameDevicePage::OnNotify: Leaving... Ret=0x%x.\r\n"), bRet));
    return bRet;
} // CNameDevicePage::OnNotify()

BOOL
IsValidFriendlyName(
    LPSTR   szFriendlyName
    )
{
    return TRUE;
} // IsValidFriendlyName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\precomp.h ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       precomp.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        8 Sep, 2000
*
*  DESCRIPTION:
*   Precompiled header
*
*
*******************************************************************************/

#ifndef __PRECOMP_H_INCLUDED
#define __PRECOMP_H_INCLUDED

#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>
#include <commctrl.h>
#include <assert.h>
#include <objbase.h>
#include <setupapi.h>
#include <shfusion.h>
#include <shlobj.h>
#include <stdio.h>
#include <tchar.h>
#include "sticimsg.h"

//
// Make sure this is included last, so it can redefine the necessary stuff
//
#include <shfusion.h>

#endif // __PRECOMP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\portsel.cpp ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Portsel.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   port selection page of WIA class installer.
*
*   1. Create CDevice object of selected device.
*   2. Process INF of selected device thru CDevice.
*   3. Get all Port's CreatFile name and Friendly name, store locally.
*   4. Handle Port selection UI and set CreateFile name thru CDevice.
*   5. Delele CDevice object if user re-select another device.
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Include
//


#include "portsel.h"
#include <sti.h>
#include <setupapi.h>

//
// Extern
//

extern HINSTANCE    g_hDllInstance;

//
// Function
//

CPortSelectPage::CPortSelectPage(PINSTALLER_CONTEXT pInstallerContext) :
    CInstallWizardPage(pInstallerContext, IDD_DYNAWIZ_SELECT_NEXTPAGE)
{
    //
    // Set link to previous/next page. This page should show up.
    //

    m_uPreviousPage = IDD_DYNAWIZ_SELECTDEV_PAGE;
    m_uNextPage     = NameTheDevice;

    //
    // Initialize member.
    //

    m_hDevInfo          = pInstallerContext->hDevInfo;
    m_pspDevInfoData    = &(pInstallerContext->spDevInfoData);
    m_pInstallerContext = pInstallerContext;

    m_bPortEnumerated   = FALSE;
    m_dwNumberOfPort    = 0;

    m_dwCapabilities    = 0;
    m_csConnection      = BOTH;

}

CPortSelectPage::~CPortSelectPage()
{

} // CPortSelectPage::CPortSelectPage(PINSTALLER_CONTEXT pInstallerContext)

BOOL
CPortSelectPage::OnCommand(
    WORD wItem,
    WORD wNotifyCode,
    HWND hwndItem
    )
{

    LRESULT                 lResult;
    BOOL                    bRet;

    DebugTrace(TRACE_PROC_ENTER,(("CPortSelectPage::OnCommand: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet    = FALSE;
    lResult = 0;

    //
    // Dispatch message.
    //

    switch (wNotifyCode) {

        case LBN_SELCHANGE: {

            int ItemData = (int) SendMessage(hwndItem, LB_GETCURSEL, 0, 0);

            //
            // Check the existance of CDevice.
            //

            if(NULL == m_pCDevice){
                DebugTrace(TRACE_ERROR,(("CPortSelectPage::OnCommand: CDevice doesn't exist yet.\r\n")));

                bRet = TRUE;
                goto OnCommand_return;
            }

            if (ItemData >= 0) {

                LONG    lPortIndex;

                lPortIndex = (LONG)SendMessage(hwndItem, LB_GETITEMDATA, ItemData, 0);

                if(ID_AUTO == lPortIndex){

                    //
                    // This is "AUTO" port.
                    //

                    m_pCDevice->SetPort(AUTO);
                    DebugTrace(TRACE_STATUS,(("CPortSelectPage::OnCommand: Setting portname to %ws.\r\n"), AUTO));

                } else if (lPortIndex >= 0 ) {

                    //
                    // Set port name.
                    //

                    m_pCDevice->SetPort(m_csaPortName[lPortIndex]);
                    DebugTrace(TRACE_STATUS,(("CPortSelectPage::OnCommand: Setting portname to %ws.\r\n"), m_csaPortName[lPortIndex]));

                } else { // if (lPortIndex >= 0 )

                    //
                    // Shouldn't come here, id < -1. Use AUTO.
                    //

                    DebugTrace(TRACE_ERROR,(("CPortSelectPage::OnCommand: Got improper id(0x%x). Use AUTO.\r\n"), lPortIndex));
                    m_pCDevice->SetPort(AUTO);
                } // if (lPortIndex >= 0 )

                bRet = TRUE;
                goto OnCommand_return;

            } // if (ItemData >= 0)
        } // case LBN_SELCHANGE:
    } // switch (wNotifyCode)

OnCommand_return:
    DebugTrace(TRACE_PROC_LEAVE,(("CPortSelectPage::OnCommand: Leaving... Ret=0x%x.\r\n"), bRet));
    return  bRet;

}

BOOL
CPortSelectPage::OnNotify(
    LPNMHDR lpnmh
    )
{
    DWORD                   Idx;
    DWORD                   dwPortSelectMode;
    BOOL                    bRet;

    DebugTrace(TRACE_PROC_ENTER,(("CPortSelectPage::OnNotify: Enter... \r\n")));

    //
    // Initialize locals.
    //

    Idx                 = 0;
    dwPortSelectMode    = 0;
    bRet                = FALSE;

    if (lpnmh->code == PSN_SETACTIVE) {

        DebugTrace(TRACE_STATUS,(("CPortSelectPage::OnNotify: PSN_SETACTIVE.\r\n")));

        //
        // Create CDevice object.
        //

        if(!CreateCDeviceObject()){
            DebugTrace(TRACE_ERROR,(("CPortSelectPage::OnNotify: ERROR!! Unable to create CDeviceobject.\r\n")));

            bRet = FALSE;
            goto OnNotify_return;
        }

        //
        // See if need to show port selection page.
        //

        dwPortSelectMode = m_pCDevice->GetPortSelectMode();
        switch(dwPortSelectMode){

            case PORTSELMODE_NORMAL:
            {
                //
                // Set proper message.
                //

                if(!SetDialogText(PortSelectMessage0)){
                    DebugTrace(TRACE_ERROR,(("CPortSelectPage::OnNotify: ERROR!! Unable to set dialog text.\r\n")));
                } // if(!SetDialogText(PortSelectMessage0)
                    

                //
                // Make all cotrol visible.
                //

                if(!ShowControl(TRUE)){
                    DebugTrace(TRACE_ERROR,(("CPortSelectPage::OnNotify: ERROR!! Port listbox can't be visible.\r\n")));
                } // ShowControl(TRUE)

                //
                // Enumerate all Ports.
                //

                if(!EnumPort()){
                    DebugTrace(TRACE_ERROR,(("CPortSelectPage::OnNotify: ERROR!! Unable to enumerate ports.\r\n")));

                    bRet = FALSE;
                    goto OnNotify_return;
                }

                //
                // Update port list.
                //

                UpdatePortList();

                //
                // Focus the first item.
                //

                SendDlgItemMessage(m_hwnd,
                                   LocalPortList,
                                   LB_SETCURSEL,
                                   0,
                                   0);

                //
                // Store the current selection.
                //

                Idx = (DWORD)SendDlgItemMessage(m_hwnd,
                                                LocalPortList,
                                                LB_GETITEMDATA,
                                                0,
                                                0);
                if(ID_AUTO == Idx){
                    m_pCDevice->SetPort(AUTO);
                } else {
                    m_pCDevice->SetPort(m_csaPortName[Idx]);
                }

                //
                // Let the default handler do its job.
                //

                bRet = FALSE;
                goto OnNotify_return;
            } // case PORTSELMODE_NORMAL:

            case PORTSELMODE_SKIP:
            {
                //
                // "PortSelect = no" specified. Set port to "AUTO" and skip to the next page.
                //

                m_pCDevice->SetPort(AUTO);
                SetWindowLongPtr(m_hwnd, DWLP_MSGRESULT, m_uNextPage);
                bRet =  TRUE;
                goto OnNotify_return;
            } // case PORTSELMODE_SKIP:
            
            case PORTSELMODE_MESSAGE1:{

                //
                // Set proper message.
                //

                if(!SetDialogText(PortSelectMessage1)){
                    DebugTrace(TRACE_ERROR,(("CPortSelectPage::OnNotify: ERROR!! Unable to set dialog text.\r\n")));
                } // if(!SetDialogText(PortSelectMessage0)
                    

                //
                // Make all cotrol invisible.
                //

                if(!ShowControl(FALSE)){
                    DebugTrace(TRACE_ERROR,(("CPortSelectPage::OnNotify: ERROR!! Port listbox can't be invisible.\r\n")));
                } // if(!ShowControl(FALSE))

                //
                // Set port name.
                //

                m_pCDevice->SetPort(AUTO);

                bRet = FALSE;
                goto OnNotify_return;

            } // case PORTSELMODE_MESSAGE1:
            
            default:
                DebugTrace(TRACE_ERROR,(("CPortSelectPage::OnNotify: ERROR!! undefined PortSelect mode(0x%x).\r\n"), dwPortSelectMode));

                bRet = FALSE;
                goto OnNotify_return;
        } // switch(m_pCDevice->GetPortSelectMode())
    } // if (lpnmh->code == PSN_SETACTIVE)

    if (lpnmh->code == PSN_KILLACTIVE){

        if(!m_bNextButtonPushed){

            //
            // It's getting back to DeviceSelection page. Delete craeted CDevice object.
            //
            
            delete m_pCDevice;

            m_pCDevice                      = NULL;
            m_pInstallerContext->pDevice    = NULL;
        } // if(!m_bNextButtonPushed)
    } // if (lpnmh->code == PSN_KILLACTIVE)

OnNotify_return:

    DebugTrace(TRACE_PROC_LEAVE,(("CPortSelectPage::OnNotify: Leaving... Ret=0x%x.\r\n"), bRet));
    return  bRet;
}

VOID
CPortSelectPage::UpdatePortList(
    VOID
    )
{

    DWORD   Idx;

    DebugTrace(TRACE_PROC_ENTER,(("CPortSelectPage::UpdatePortList: Enter... \r\n")));

    //
    // Initialize local.
    //

    Idx = 0;

    //
    // Reset port list.
    //

    SendDlgItemMessage(m_hwnd,
                       LocalPortList,
                       LB_RESETCONTENT,
                       0,
                       0);

    //
    // Add "AUTO" port if capable.
    //

    if(m_dwCapabilities & STI_GENCAP_AUTO_PORTSELECT){

        TCHAR szTemp[MAX_DESCRIPTION];

        //
        // Load localized "Automatic Port Select" from resource.
        //

        LoadString(g_hDllInstance,
                   AutoPortSelect,
                   (TCHAR *)szTemp,
                   sizeof(szTemp) / sizeof(TCHAR));

        //
        // Add to the list with special index number. (ID_AUTO = -1)
        //

        AddItemToPortList(szTemp, ID_AUTO);

    } // if(dwCapabilities & STI_GENCAP_AUTO_PORTSELECT)

    //
    // Add all port FriendlyName to the list.
    //

    for(Idx = 0; Idx < m_dwNumberOfPort; Idx++){
        AddItemToPortList(m_csaPortFriendlyName[Idx], Idx);
    }

    DebugTrace(TRACE_PROC_LEAVE,(("CPortSelectPage::UpdatePortList: Leaving... Ret=VOID.\r\n")));
} // CPortSelectPage::UpdatePortList()


VOID
CPortSelectPage::AddItemToPortList(
    LPTSTR  szPortFriendlyName,
    DWORD   Idx
    )
{

    LRESULT         lResult;

    DebugTrace(TRACE_PROC_ENTER,(("CPortSelectPage::AddItemToPortList: Enter... \r\n")));

    //
    // Initialize local.
    //

    lResult = LB_ERR;

    //
    // See if we can add this item to list. It depends on its ConnectionType.
    //

    if(_tcsstr((const TCHAR *)szPortFriendlyName, TEXT("COM"))) {

        //
        // This is Communications Port.
        //

        if(_tcsicmp(m_csConnection, PARALLEL)){
            lResult = SendDlgItemMessage(m_hwnd,
                                         LocalPortList,
                                         LB_ADDSTRING,
                                         0,
                                         (LPARAM)szPortFriendlyName);
        } else {
            lResult = LB_ERR;
        }
    } else if(_tcsstr((const TCHAR *)szPortFriendlyName, TEXT("LPT"))){

        //
        // This is Printer Port.
        //

        if(_tcsicmp(m_csConnection, SERIAL)){
            lResult = SendDlgItemMessage(m_hwnd,
                                         LocalPortList,
                                         LB_ADDSTRING,
                                         0,
                                         (LPARAM)szPortFriendlyName);
        } else {
            lResult = LB_ERR;
        }
    } else {

        //
        // This is Unknown port. Add to the list anyway.
        //

        lResult = SendDlgItemMessage(m_hwnd,
                                     LocalPortList,
                                     LB_ADDSTRING,
                                     0,
                                     (LPARAM)szPortFriendlyName);
    }

    //
    // If it has proper capability, add the item to the list.
    //

    if (lResult != LB_ERR) {
        SendDlgItemMessage(m_hwnd,
                           LocalPortList,
                           LB_SETITEMDATA,
                           lResult,
                           (LPARAM)Idx);
    } // if (lResult != LB_ERR)

    DebugTrace(TRACE_PROC_LEAVE,(("CPortSelectPage::AddItemToPortList: Leaving... Ret=VOID.\r\n")));

} // CPortSelectPage::AddItemToPortList()


BOOL
CPortSelectPage::EnumPort(
    VOID
    )
{

    BOOL        bRet;
    GUID        Guid;
    DWORD       dwRequired;
    HDEVINFO    hPortDevInfo;
    DWORD       Idx;
    TCHAR       szPortName[MAX_DESCRIPTION];
    TCHAR       szPortFriendlyName[MAX_DESCRIPTION];

    DebugTrace(TRACE_PROC_ENTER,(("CPortSelectPage::EnumPort: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet            = FALSE;
    dwRequired      = 0;
    Idx             = 0;
    hPortDevInfo    = NULL;

    memset(szPortName, 0, sizeof(szPortName));
    memset(szPortFriendlyName, 0, sizeof(szPortFriendlyName));

    //
    // If it's already enumerated, just return success.
    //

    if(m_bPortEnumerated){
        bRet = TRUE;
        goto EnumPort_return;
    }

    //
    // Initialize Port CreateFile/Friendly Name string array.
    //

    m_dwNumberOfPort = 0;
    m_csaPortName.Cleanup();
    m_csaPortFriendlyName.Cleanup();

    //
    // Get GUID of port device.
    //

    if(!SetupDiClassGuidsFromName (PORTS, &Guid, sizeof(GUID), &dwRequired)){
        DebugTrace(TRACE_ERROR,(("CPortSelectPage::EnumPort: ERROR!! SetupDiClassGuidsFromName Failed. Err=0x%lX\r\n"), GetLastError()));

        bRet = FALSE;
        goto EnumPort_return;
    }

    //
    // Get device info set of port devices.
    //

    hPortDevInfo = SetupDiGetClassDevs (&Guid,
                                       NULL,
                                       NULL,
                                       DIGCF_PRESENT | DIGCF_PROFILE);
    if (hPortDevInfo == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("CPortSelectPage::EnumPort: ERROR!! SetupDiGetClassDevs Failed. Err=0x%lX\r\n"), GetLastError()));

        bRet = FALSE;
        goto EnumPort_return;
    }

    //
    // Process all of device element listed in device info set.
    //

    for(Idx = 0; GetPortNamesFromIndex(hPortDevInfo, Idx, szPortName, szPortFriendlyName); Idx++){

        //
        // Add valid Port CreateFile/Friendly Name to array.
        //

        if( (0 == lstrlen(szPortName))
         || (0 == lstrlen(szPortFriendlyName)) )
        {
            DebugTrace(TRACE_ERROR,(("CPortSelectPage::EnumPort: ERROR!! Invalid Port/Friendly Name.\r\n")));

            szPortName[0]           = TEXT('\0');
            szPortFriendlyName[0]   = TEXT('\0');
            continue;
        }

        DebugTrace(TRACE_STATUS,(("CPortSelectPage::EnumPort: Found Port %d: %ws(%ws).\r\n"), Idx, szPortName, szPortFriendlyName));

        m_dwNumberOfPort++;
        m_csaPortName.Add(szPortName);
        m_csaPortFriendlyName.Add(szPortFriendlyName);

        szPortName[0]           = TEXT('\0');
        szPortFriendlyName[0]   = TEXT('\0');

    } // for(Idx = 0; GetPortNamesFromIndex(hPortDevInfo, Idx, szPortName, szPortFriendlyName); Idx++)

    //
    // Operation succeeded.
    //

    bRet                = TRUE;
    m_bPortEnumerated   = TRUE;

EnumPort_return:

    //
    // Cleanup
    //

    if(IS_VALID_HANDLE(hPortDevInfo)){
        SetupDiDestroyDeviceInfoList(hPortDevInfo);
        hPortDevInfo = INVALID_HANDLE_VALUE;
    }

    DebugTrace(TRACE_PROC_LEAVE,(("CPortSelectPage::EnumPort: Leaving... Ret=0x%x.\r\n"), bRet));
    return bRet;

} // CPortSelectPage::EnumPort()

BOOL
CPortSelectPage::CreateCDeviceObject(
    VOID
    )
{
    BOOL    bRet;

    DebugTrace(TRACE_PROC_ENTER,(("CPortSelectPage::CreateCDeviceObject: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet    = FALSE;

    //
    // If CDevice already exists, see if we can reuse it.
    //

    if(NULL != m_pCDevice){
        SP_DEVINFO_DATA spDevInfoData;

        memset(&spDevInfoData, 0, sizeof(SP_DEVINFO_DATA));
        spDevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        if(!SetupDiGetSelectedDevice(m_hDevInfo, &spDevInfoData)){
            DebugTrace(TRACE_ERROR,(("CPortSelectPage::CreateCDeviceObject: ERROR!! Can't get selected device element. Err=0x%x\n"), GetLastError()));

            bRet = FALSE;
            goto CreateCDeviceObject_return;
        }

        if(!(m_pCDevice->IsSameDevice(m_hDevInfo, &spDevInfoData))){

            //
            // User changed selected device. Delete the object.
            //

            delete m_pCDevice;

            m_pCDevice                      = NULL;
            m_pInstallerContext->pDevice    = NULL;
            m_csConnection                  = BOTH;
            m_dwCapabilities                = NULL;

        } // if(!(m_pCDevice->IsSameDevice(m_hDevInfo, &spDevInfoData)))
    } // if(NULL != m_pCDevice)

    //
    // Create CDevice object here if it doesn't exist.
    //

    if(NULL == m_pCDevice){

        //
        // Get selected device.
        //

        memset(m_pspDevInfoData, 0, sizeof(SP_DEVINFO_DATA));
        m_pspDevInfoData->cbSize = sizeof(SP_DEVINFO_DATA);
        if(!SetupDiGetSelectedDevice(m_hDevInfo, m_pspDevInfoData)){
            DebugTrace(TRACE_ERROR,(("CPortSelectPage::CreateCDeviceObject: ERROR!! Can't get selected device element. Err=0x%x\n"), GetLastError()));

            bRet = FALSE;
            goto CreateCDeviceObject_return;
        }

        //
        // Create CDevice object for installing device.
        //

        m_pCDevice = new CDevice(m_hDevInfo, m_pspDevInfoData, FALSE);
        if(NULL == m_pCDevice){
            DebugTrace(TRACE_ERROR,(("CPortSelectPage::CreateCDeviceObject: ERROR!! Can't create CDevice object.\r\n")));

            bRet = FALSE;
            goto CreateCDeviceObject_return;
        } // if(NULL == m_pCDevice)

        //
        // Name default unique name.
        //

        if(!m_pCDevice->NameDefaultUniqueName()){
                DebugTrace(TRACE_ERROR,(("CPortSelectPage::CreateCDeviceObject: ERROR!! Unable to get default name.\r\n")));
        }

        //
        // Pre-process INF.
        //

        if(!m_pCDevice->PreprocessInf()){
            DebugTrace(TRACE_ERROR,(("CPortSelectPage::CreateCDeviceObject: ERROR!! Unable to process INF.\r\n")));
        }

        //
        // Save created CDevice object into installer context.
        //

        m_pInstallerContext->pDevice = (PVOID)m_pCDevice;

        //
        // Get ConnectionType/Capabilities.
        //

        m_dwCapabilities    = m_pCDevice->GetCapabilities();
        m_csConnection      = m_pCDevice->GetConnection();
        if(m_csConnection.IsEmpty()){
            m_csConnection = BOTH;
        } // if(m_csConnection.IsEmpty())

    } // if(NULL == m_pCDevice)

    //
    // Operation succeeded.
    //

    bRet    = TRUE;

CreateCDeviceObject_return:
    DebugTrace(TRACE_PROC_LEAVE,(("CPortSelectPage::CreateCDeviceObject: Leaving... Ret=0x%x.\r\n"), bRet));
    return bRet;
} // CPortSelectPage::CreateCDeviceObject()

BOOL
CPortSelectPage::SetDialogText(
    UINT uiMessageId
    )
{
    BOOL    bRet;
    TCHAR   szStringBuffer[MAX_STRING_LENGTH];
    HWND    hwndMessage;
    
    //
    // Initialize local.
    //

    bRet        = FALSE;
    hwndMessage = (HWND)NULL;

    memset(szStringBuffer, 0, sizeof(szStringBuffer));

    //
    // Load message string.
    //

    if(0 == LoadString(g_hDllInstance,
                       uiMessageId,
                       szStringBuffer,
                       sizeof(szStringBuffer)/sizeof(TCHAR)))
    {
        //
        // Unable to load specified string.
        //

        bRet = FALSE;
        goto SetDialogText_return;

    } // if(0 == LoadString()

    //
    // Get window handle the control
    //

    hwndMessage = GetDlgItem(m_hwnd, IDC_PORTSEL_MESSAGE);

    //
    // Set loaded string to the dialog.
    //

    SetWindowText(hwndMessage, (LPCTSTR)szStringBuffer);

    bRet = TRUE;

SetDialogText_return:

    return bRet;

} // CPortSelectPage::SetDialogText()

BOOL
CPortSelectPage::ShowControl(
    BOOL    bShow
    )
{
    BOOL    bRet;
    HWND    hwndString;
    HWND    hwndListBox;
    int     nCmdShow;
    
    //
    // Initialize local.
    //

    bRet        = FALSE;
    hwndString  = (HWND)NULL;
    hwndListBox = (HWND)NULL;

    if(bShow){
        nCmdShow = SW_SHOW;
    } else {
        nCmdShow = SW_HIDE;
    }

    //
    // Get window handle the control
    //

    hwndString  = GetDlgItem(m_hwnd, IDC_PORTSEL_AVAILABLEPORTS);
    hwndListBox = GetDlgItem(m_hwnd, LocalPortList);

    //
    // Make them in/visible.
    //

    if(NULL != hwndString){
        ShowWindow(hwndString, nCmdShow);
    } // if(NULL != hwndString)

    if(NULL != hwndListBox){
        ShowWindow(hwndListBox, nCmdShow);
    } // if(NULL != hwndListBox)

    bRet = TRUE;

// ShowControl_return:

    return bRet;
} // CPortSelectPage::ShowControl()





BOOL
GetDevinfoFromPortName(
    LPTSTR              szPortName,
    HDEVINFO            *phDevInfo,
    PSP_DEVINFO_DATA    pspDevInfoData
    )
{
    BOOL            bRet;
    BOOL            bFound;
    HDEVINFO        hPortDevInfo;
    SP_DEVINFO_DATA spDevInfoData;
    GUID            Guid;
    DWORD           dwRequired;
    DWORD           Idx;
    TCHAR           szTempPortName[MAX_DESCRIPTION];
    TCHAR           szPortFriendlyName[MAX_DESCRIPTION];

    DebugTrace(TRACE_PROC_ENTER,(("GetDevinfoFromPortName: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet            = FALSE;
    bFound          = FALSE;
    hPortDevInfo    = INVALID_HANDLE_VALUE;
    dwRequired      = 0;

    memset(&spDevInfoData, 0, sizeof(spDevInfoData));
    memset(szTempPortName, 0, sizeof(szTempPortName));
    memset(szPortFriendlyName, 0, sizeof(szPortFriendlyName));

    //
    // Get GUID of port device.
    //

    if(!SetupDiClassGuidsFromName (PORTS, &Guid, sizeof(GUID), &dwRequired)){
        DebugTrace(TRACE_ERROR,(("GetDevinfoFromPortName: ERROR!! SetupDiClassGuidsFromName Failed. Err=0x%lX\r\n"), GetLastError()));

        goto GetDevinfoFromPortName_return;
    }

    //
    // Get device info set of port devices.
    //

    hPortDevInfo = SetupDiGetClassDevs (&Guid,
                                        NULL,
                                        NULL,
                                        DIGCF_PRESENT | DIGCF_PROFILE);
    if (hPortDevInfo == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("GetDevinfoFromPortName: ERROR!! SetupDiGetClassDevs Failed. Err=0x%lX\r\n"), GetLastError()));

        goto GetDevinfoFromPortName_return;
    }

    //
    // If portname is AUTO, use the first port no matter what it is.
    //

    if(0 == _tcsicmp(szPortName, AUTO)){

        DebugTrace(TRACE_STATUS,(("GetDevinfoFromPortName: Portname is AUTO. The first port found will be returned,\r\n")));

        Idx = 0;
        bFound = TRUE;
        goto GetDevinfoFromPortName_return;
    } // if(0 == _tcsicmp(szPortName, AUTO))

    //
    // Enum all ports and find specified port.
    //

    for(Idx = 0; GetPortNamesFromIndex(hPortDevInfo, Idx, szTempPortName, szPortFriendlyName); Idx++){

        //
        // Find specified portname..
        //

        if( (0 == lstrlen(szTempPortName))
         || (0 == lstrlen(szPortFriendlyName)) )
        {
            DebugTrace(TRACE_ERROR,(("GetDevinfoFromPortName: ERROR!! Invalid Port/Friendly Name.\r\n")));

            szTempPortName[0]       = TEXT('\0');
            szPortFriendlyName[0]   = TEXT('\0');
            continue;
        }

        DebugTrace(TRACE_STATUS,(("GetDevinfoFromPortName: Found Port %d: %ws(%ws). Comparing w/ %ws\r\n"), Idx, szTempPortName, szPortFriendlyName, szPortName));

        if(0 == _tcsicmp(szPortName, szTempPortName)){

            //
            // Specified portname found.
            //

            bFound = TRUE;
            break;
        }

        szTempPortName[0]       = TEXT('\0');
        szPortFriendlyName[0]   = TEXT('\0');

    } // for(Idx = 0; GetPortNamesFromIndex(hPortDevInfo, Idx, szPortName, szPortFriendlyName); Idx++)

GetDevinfoFromPortName_return:

    if(FALSE == bFound){
        if(INVALID_HANDLE_VALUE != hPortDevInfo){
            SetupDiDestroyDeviceInfoList(hPortDevInfo);
        }

        *phDevInfo = NULL;
    } else {
        *phDevInfo = hPortDevInfo;
        pspDevInfoData->cbSize = sizeof (SP_DEVINFO_DATA);
        if(!SetupDiEnumDeviceInfo(hPortDevInfo, Idx, pspDevInfoData)){
            DebugTrace(TRACE_ERROR,(("GetDevinfoFromPortName: Unable to get specified devnode. Err=0x%x\n"), GetLastError()));
        } //if(!SetupDiEnumDeviceInfo(hDevInfo, Idx, pspDevInfoData))

    } // if(FALSE == bFound)

    bRet = bFound;
    DebugTrace(TRACE_PROC_LEAVE,(("GetDevinfoFromPortName: Leaving... Ret=0x%x.\r\n"), bRet));
    return bRet;
} // GetDevinfoFromPortName()



BOOL
GetPortNamesFromIndex(
    HDEVINFO    hPortDevInfo,
    DWORD       dwPortIndex,
    LPTSTR      szPortName,
    LPTSTR      szPortFriendlyName
    )
{
    HKEY            hkPort;
    SP_DEVINFO_DATA spDevInfoData;
    DWORD           dwSize;
    BOOL            bRet;

    DebugTrace(TRACE_PROC_ENTER,(("GetPortNamesFromIndex: Enter... \r\n")));

    //
    // Initialize local.
    //

    hkPort  = NULL;
    dwSize  = 0;
    bRet    = TRUE;

    memset(&spDevInfoData, 0, sizeof(spDevInfoData));

    //
    // Get specified device info data.
    //

    spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
    if (!SetupDiEnumDeviceInfo (hPortDevInfo, dwPortIndex, &spDevInfoData)) {
        DWORD dwError;

        dwError = GetLastError();
        if(ERROR_NO_MORE_ITEMS == dwError){
            DebugTrace(TRACE_STATUS,(("GetPortNamesFromIndex: Hits end of enumeration. Index=0x%x.\r\n"), dwPortIndex));
        } else {
            DebugTrace(TRACE_ERROR,(("GetPortNamesFromIndex: ERROR!! SetupDiEnumDeviceInfo() failed. Err=0x%x\n"), dwError));
        }

        bRet = FALSE;
        goto GetPortNamesFromIndex_return;
    }

    //
    // Open port device registry.
    //

    hkPort = SetupDiOpenDevRegKey (hPortDevInfo,
                                   &spDevInfoData,
                                   DICS_FLAG_GLOBAL,
                                   0,
                                   DIREG_DEV, KEY_READ);
    if (hkPort == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("GetPortNamesFromIndex: SetupDiOpenDevRegKey() failed.Err=0x%x\n"), GetLastError()));

        goto GetPortNamesFromIndex_return;
    }

    //
    // Get portname from device key.
    //

    if(!GetStringFromRegistry(hkPort, PORTNAME, szPortName)){
        DebugTrace(TRACE_ERROR,(("GetPortNamesFromIndex: Can't get portname from registry.\r\n")));

        goto GetPortNamesFromIndex_return;
    }

    //
    // Get port FriendlyName from registry.
    //

    if (!SetupDiGetDeviceRegistryProperty (hPortDevInfo,
                                           &spDevInfoData,
                                           SPDRP_FRIENDLYNAME,
                                           NULL,
                                           (LPBYTE)szPortFriendlyName,
                                           MAX_DESCRIPTION,
                                           NULL) )
    {
        DebugTrace(TRACE_ERROR,(("GetPortNamesFromIndex: SetupDiGetDeviceRegistryProperty() failed. Err=0x%x\n"), GetLastError()));

        goto GetPortNamesFromIndex_return;
    } // if (SetupDiGetDeviceRegistryProperty())

    //
    // Operation succeeded.
    //

    bRet = TRUE;

GetPortNamesFromIndex_return:

    //
    // Clean up.
    //

    if(NULL != hkPort){
        RegCloseKey(hkPort);
    }

    DebugTrace(TRACE_PROC_LEAVE,(("GetPortNamesFromIndex: Leaving... Ret=0x%x.\r\n"), bRet));
    return bRet;
} // CPortSelectPage::GetPortNamesFromIndex()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\portsel.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Portsel.h
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Port selection page of WIA class installer.
*
*******************************************************************************/

#ifndef _PORTSEL_H_
#define _PORTSEL_H_

//
// Include
//

#include "wizpage.h"
#include "device.h"

//
// Class
//

class   CPortSelectPage : public CInstallWizardPage 
{

    HDEVINFO            m_hDevInfo;             // Device info set of installing device.
    PSP_DEVINFO_DATA    m_pspDevInfoData;       // Pointer to Device element structure.

    BOOL                m_bPortEnumerated;      // Inidicate if ports are already enumed.
    DWORD               m_dwNumberOfPort;       // Number of port.
    CStringArray        m_csaPortName;          // All port CreateFile name on the system.
    CStringArray        m_csaPortFriendlyName;  // All port Friendly name on the system.
    
    PINSTALLER_CONTEXT  m_pInstallerContext;    // Installer context.
    
    CString             m_csConnection;         // Connection type of installing device.
    DWORD               m_dwCapabilities;       // Capabilities of installing device.

    BOOL    CreateCDeviceObject();
    BOOL    EnumPort();
    VOID    UpdatePortList();
    
    VOID
    AddItemToPortList(
        LPTSTR  szPortFriendlyName,
        DWORD   Idx
        );

    BOOL
    SetDialogText(
        UINT uiMessageId
        );

    BOOL
    ShowControl(
        BOOL    bShow
        );

public:

    CPortSelectPage(PINSTALLER_CONTEXT pInstallerContext);
    ~CPortSelectPage();

    virtual BOOL OnCommand(WORD wItem, WORD wNotifyCode, HWND hwndItem);
    virtual BOOL OnNotify(LPNMHDR lpnmh);

};

BOOL
GetPortNamesFromIndex(
    HDEVINFO    hPortDevInfo,
    DWORD       dwPortIndex,
    LPTSTR      szPortName,
    LPTSTR      szPortFriendlyName
    );

BOOL
GetDevinfoFromPortName(
    LPTSTR              szPortName,
    HDEVINFO            *phDevInfo,
    PSP_DEVINFO_DATA    pspDevInfoData
    );

#endif // _PORTSEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\prevpg.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Prevpg.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Dummy page for the case user push BACK button in device selection page.
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

#include "prevpg.h"

CPrevSelectPage::CPrevSelectPage(PINSTALLER_CONTEXT pInstallerContext) :
    CInstallWizardPage(pInstallerContext, IDD_DYNAWIZ_SELECT_PREVPAGE)
{

    //
    // Set link to previous/next page. This page should show up.
    //

    m_uPreviousPage = 0;
    m_uNextPage     = 0;

    //
    // Initialize member.
    //

    m_pInstallerContext = pInstallerContext;
}

BOOL
CPrevSelectPage::OnNotify(
    LPNMHDR lpnmh
    )
{
    BOOL bRet;

    if(lpnmh->code == PSN_SETACTIVE) {

        LONG_PTR    lNextPage;

        //
        // User clicked BACK button in devlce selection page. Just skip to First
        // page or Class selection page if it's invoked from Hardware Wizard.
        //

        if(m_pInstallerContext->bCalledFromControlPanal){

            //
            // Called from Control Panel. Goto first page.
            //

            lNextPage = IDD_DYNAWIZ_FIRSTPAGE;
        } else {

            //
            // Called from hardware wizard. Goto Class selection page.
            //

            lNextPage = IDD_DYNAWIZ_SELECTCLASS_PAGE;
        } // if(m_pInstallerContext->bCalledFromControlPanal)

        //
        // Skip to next page.
        //

        SetWindowLongPtr(m_hwnd, DWLP_MSGRESULT, lNextPage);

        //
        // Default handler isn't needed.
        //

        bRet =  TRUE;
        goto OnNotify_return;

    } // if(lpnmh->code == PSN_SETACTIVE)

    //
    // Let default handler do its job.
    //

    bRet = FALSE;

OnNotify_return:
    return bRet;
} // CPrevSelectPage::OnNotify
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\prevpg.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Prevpg.h
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Dummy page for the case user push BACK button in device selection page.
*
*******************************************************************************/

#ifndef _PREVPG_H_
#define _PREVPG_H_

//
// Include
//

#include    "wizpage.h"

//
// Class
//

class CPrevSelectPage : public CInstallWizardPage {

    PINSTALLER_CONTEXT  m_pInstallerContext;    // Installer context.

public:

    CPrevSelectPage(PINSTALLER_CONTEXT pInstallerContext);
    ~CPrevSelectPage() {};

    virtual BOOL OnNotify(LPNMHDR lpnmh);
};

#endif // _PREVPG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\resource.h ===
/******************************************************************************

  Header File:  Resource.H

  Resource IDs used in the Class Installer

  Range 100-999     Control IDs
  Range 1000-1999   Icon, bitmap, and Dialog IDs
  Range 1-32767     String IDs

  Copyright (c) 1996, 1997 by Microsoft Corporation.  All Rights Reserved

  Change History:

  12-12-1996    Bob Kjelgaard   Created it

******************************************************************************/

//  Control IDs
#define IDC_STATIC                      -1
#define LocalPortList                   100
#define ConfigureButton                 101
#define DeviceFriendlyName              102
#define YesButton                       103
#define NoButton                        104
#define IDC_SCNAME                      105
#define IDC_PORTSEL_AVAILABLEPORTS      106
#define IDC_PORTSEL_MESSAGE             107


//  Icon, bitmap, Dialog IDs
#define ImageIcon                       1000
#define WizardBitmap                    1001
#define WizardBitmap2                   1002
// From Win2k CPL.

#define IDB_BANNERBMP                   1010
#define IDB_WATERMARK                   1011

#define NameTheDevice                   5002
#define EmeraldCity                     5003

//  String IDs

#define MessageTitle                    1
#define InstallationSuccessful          2
#define InstallationFailed              3
#define SelectionInstructions           4
#define ListTitle                       5
#define DuplicateDeviceName             6
#define CannotConfigurePort             7
#define AutoPortSelect                  8
#define HeaderTitle                     9
#define SubHeaderTitle                 10
#define WiaWizardName                  11
#define AccessoriesFolderName          12
#define WiaWizardDescription           13
#define DeviceNameTooLong              14
#define NoDeviceName                   15
#define WiaServiceDescription          16
#define WiaServiceName                 17
#define HeaderForPortsel               18
#define HeaderForNameIt                19

#define WelcomeMessage                 20
#define CompleteMessage                21
#define LocalAccessoriesFolderName     22

#define SelDevTitle                    23
#define SelDevSubTitle                 24
#define SelDevInstructions             25
#define SelDevListLabel                26

#define PortSelectMessage0             27
#define PortSelectMessage1             28

#define IDS_TITLEFONTNAME              50
#define IDS_TITLEFONTSIZE              51
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\ptp.cpp ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       PTP.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        23 Apr, 2002
*
*  DESCRIPTION:
*   Utility function for PTP device access and coinstaller entry.
*
*   NOTE:
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#include <strsafe.h>
#include <cfgmgr32.h>
#include "sti_ci.h"
#include "cistr.h"
#include "debug.h"
#pragma hdrstop

//
// Include
//

//
// Define
//

#define MAX_STRING_BUFFER       256
#define PTPUSD_DLL              L"ptpusd.dll"
#define FUNTION_GETDEVICENAME   "GetDeviceName"


//
// Typedef
//


typedef HRESULT (WINAPI* GETDEVICENAME)(LPCWSTR     pwszPortName,
                                        WCHAR       *pwszManufacturer,
                                        DWORD       cchManufacturer,
                                        WCHAR       *pwszModelName,
                                        DWORD       cchModelName
                                        );

//
// Prototype
//


//
// Global
//


//
// Function
//

extern "C"
DWORD
APIENTRY
PTPCoinstallerEntry(
    IN  DI_FUNCTION                     diFunction,
    IN  HDEVINFO                        hDevInfo,
    IN  PSP_DEVINFO_DATA                pDevInfoData,
    IN  OUT PCOINSTALLER_CONTEXT_DATA   pCoinstallerContext
    )
{
    DWORD                   dwReturn;
    DWORD                   dwWaitResult;
    WCHAR                   wszMfg[MAX_STRING_BUFFER];
    WCHAR                   wszModel[MAX_STRING_BUFFER];
    CString                 csSymbolicLink;
    CString                 csMfg;
    CString                 csModel;
    CString                 csDeviceID;
    HKEY                    hDevRegKey;
    HRESULT                 hr;
    HANDLE                  hThread;
    HMODULE                 hDll;
    GETDEVICENAME           pfnGetDeviceName;

    DebugTrace(TRACE_PROC_ENTER,(("PTPCoinstallerEntry: Enter... \r\n")));

    //
    // Initialize local.
    //

    dwReturn            = NO_ERROR;
    dwWaitResult        = 0;
    hDevRegKey          = NULL;
    hr                  = S_OK;
    hThread             = NULL;
    pfnGetDeviceName    = NULL;
    hDll                = NULL;

    memset(wszMfg, 0, sizeof(wszMfg));
    memset(wszModel, 0, sizeof(wszModel));

    switch(diFunction){

        case DIF_INSTALLDEVICE:
        {
            if(pCoinstallerContext->PostProcessing){

                //
                // Open device regkey.
                //
                
                hDevRegKey = SetupDiOpenDevRegKey(hDevInfo,
                                                  pDevInfoData,
                                                  DICS_FLAG_GLOBAL,
                                                  0,
                                                  DIREG_DRV,
                                                  KEY_READ | KEY_WRITE);
                if(!IS_VALID_HANDLE(hDevRegKey)){
                    DebugTrace(TRACE_STATUS,(("PTPCoinstallerEntry: Unable to open driver key for isntalling device. Err=0x%x.\r\n"), GetLastError()));
                    goto PTPCoinstallerEntry_return;
                } // if(!IS_VALID_HANDLE(hDevRegKey))
                
                //
                // Get symbolic link of the installing device.
                //
                
                csSymbolicLink.Load(hDevRegKey, CREATEFILENAME);
                if(csSymbolicLink.IsEmpty()){
                    DebugTrace(TRACE_ERROR,(("PTPCoinstallerEntry: ERROR!! Unable to get symbolic link. Err=0x%x.\r\n"), GetLastError()));
                    goto PTPCoinstallerEntry_return;
                } // if(csSymbolicLink.IsEmpty())

                DebugTrace(TRACE_STATUS,(("PTPCoinstallerEntry: CreateFileName=%ws.\r\n"), (LPWSTR)csSymbolicLink));

                //
                // Load ptpusd.dll..
                //
                            
                hDll = LoadLibrary(PTPUSD_DLL);
                if(!IS_VALID_HANDLE(hDll)){
                    DebugTrace(TRACE_ERROR,(("PTPCoinstallerEntry: ERROR!! Unable to load %ws. Err=0x%x.\r\n"), PTPUSD_DLL, GetLastError()));
                    goto PTPCoinstallerEntry_return;
                } // if(!IS_VALID_HANDLE(hDll))
                                
                //
                // Get proc address of GetDeviceName from ptpusd.dll.
                //

                pfnGetDeviceName = (GETDEVICENAME)GetProcAddress(hDll, FUNTION_GETDEVICENAME);
                if(NULL == pfnGetDeviceName){
                    DebugTrace(TRACE_ERROR,(("PTPCoinstallerEntry: ERROR!! Unable to get proc address. Err=0x%x.\r\n"), GetLastError()));
                    goto PTPCoinstallerEntry_return;
                } // if(NULL == pfnGetDeviceName)

                //
                // Call the function to get the device info.
                //

                _try {

                    hr = pfnGetDeviceName(csSymbolicLink,
                                          wszMfg,
                                          ARRAYSIZE(wszMfg),
                                          wszModel,
                                          ARRAYSIZE(wszModel));
                }
                _except(EXCEPTION_EXECUTE_HANDLER) {
                    DebugTrace(TRACE_ERROR,(("PTPCoinstallerEntry: ERROR!! excpetion in ptpusd.dll.\r\n")));
                    goto PTPCoinstallerEntry_return;
                } // _except(EXCEPTION_EXECUTE_HANDLER)
                            
                if(S_OK != hr){
                    DebugTrace(TRACE_ERROR,(("PTPCoinstallerEntry: ERROR!! Unable to get device info from device. hr=0x%x.\r\n"), hr));
                    goto PTPCoinstallerEntry_return;
                } // if(S_OK != hr)

                DebugTrace(TRACE_STATUS,(("PTPCoinstallerEntry: Manufacturer name=%ws.\r\n"), wszMfg));
                DebugTrace(TRACE_STATUS,(("PTPCoinstallerEntry: Model name=%ws.\r\n"), wszModel));
                
                //
                // We will need to generate unique FriendlyName.
                //
                
                //
                // Store Vendor, FriendlyName and DriverDesc.
                //

                csMfg   = wszMfg;
                csModel = wszModel;
                
                csMfg.Store(hDevRegKey, VENDOR);
                csModel.Store(hDevRegKey, FRIENDLYNAME);
                csModel.Store(hDevRegKey, DRIVERDESC);

                CM_Set_DevNode_Registry_Property(pDevInfoData->DevInst,
                                                 CM_DRP_FRIENDLYNAME,
                                                 (LPTSTR)csModel,
                                                 (lstrlen(csModel) + 1) * sizeof(TCHAR),
                                                  0);

            } else { // if(pCoinstallerContext->PostProcessing)

                dwReturn = ERROR_DI_POSTPROCESSING_REQUIRED;
            } // else(pCoinstallerContext->PostProcessing)
            
            break;
        } // case DIF_INSTALLDEVICE:
    } // switch(diFunction)

PTPCoinstallerEntry_return:
    
    //
    // Clean up.
    //
    
    if(IS_VALID_HANDLE(hDevRegKey)){
        RegCloseKey(hDevRegKey);
        hDevRegKey = (HKEY)INVALID_HANDLE_VALUE;
    } // if(IS_VALID_HANDLE(hDevRegKey))

    if( (DIF_INSTALLDEVICE == diFunction)
     && (pCoinstallerContext->PostProcessing) )
    {
        if(IS_VALID_HANDLE(hDll)){
            FreeLibrary(hDll);
            hDll = NULL;
        } // if(IS_VALID_HANDLE(hDll))

    } // if(DIF_DESTROYPRIVATEDATA == diFunction)

    DebugTrace(TRACE_PROC_LEAVE,(("PTPCoinstallerEntry: Leaving... Ret=0x%x.\r\n"), dwReturn));
    return dwReturn;
} // PTPCoinstallerEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\security.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    security.cpp

Abstract:

Environment:

    WIN32 User Mode

Author:

    Vlad Sadovsky (vlads) 19-Apr-1998


--*/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "sti_ci.h"

#include <sti.h>
#include <stiregi.h>
#include <stilib.h>
#include <stiapi.h>
#include <stisvc.h>

#include <eventlog.h>

#include <ntsecapi.h>
#include <lm.h>



NTSTATUS
OpenPolicy(
    LPTSTR ServerName,          // machine to open policy on (Unicode)
    DWORD DesiredAccess,        // desired access to policy
    PLSA_HANDLE PolicyHandle    // resultant policy handle
    );

BOOL
GetAccountSid(
    LPTSTR SystemName,          // where to lookup account
    LPTSTR AccountName,         // account of interest
    PSID *Sid                   // resultant buffer containing SID
    );

NTSTATUS
SetPrivilegeOnAccount(
    LSA_HANDLE PolicyHandle,    // open policy handle
    PSID AccountSid,            // SID to grant privilege to
    LPTSTR PrivilegeName,       // privilege to grant (Unicode)
    BOOL bEnable                // enable or disable
    );

void
InitLsaString(
    PLSA_UNICODE_STRING LsaString, // destination
    LPTSTR String                  // source (Unicode)
    );

#define RTN_OK 0
#define RTN_USAGE 1
#define RTN_ERROR 13

//
// If you have the ddk, include ntstatus.h.
//
#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS  ((NTSTATUS)0x00000000L)
#endif


BOOL
GetDefaultDomainName(
    LPTSTR DomainName
    )
{
    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    DWORD                       err             = 0;
    LSA_HANDLE                  LsaPolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo      = NULL;


    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  // object attributes
                                NULL,               // name
                                0L,                 // attributes
                                NULL,               // root directory
                                NULL );             // security descriptor

    NtStatus = LsaOpenPolicy( NULL,                 // system name
                              &ObjectAttributes,    // object attributes
                              POLICY_EXECUTE,       // access mask
                              &LsaPolicyHandle );   // policy handle

    if( !NT_SUCCESS( NtStatus ) )
    {
        return FALSE;
    }

    //
    //  Query the domain information from the policy object.
    //
    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *) &DomainInfo );

    if (!NT_SUCCESS(NtStatus))
    {
        LsaClose(LsaPolicyHandle);
        return FALSE;
    }


    (void) LsaClose(LsaPolicyHandle);

    //
    // Copy the domain name into our cache, and
    //

    CopyMemory( DomainName,
                DomainInfo->DomainName.Buffer,
                DomainInfo->DomainName.Length );

    //
    // Null terminate it appropriately
    //

    DomainName[DomainInfo->DomainName.Length / sizeof(WCHAR)] = L'\0';

    //
    // Clean up
    //
    LsaFreeMemory( (PVOID)DomainInfo );

    return TRUE;
}


LPTSTR
GetMachineName(
    LPWSTR AccountName
    )
{
    LSA_HANDLE PolicyHandle = NULL;

    WCHAR   DomainName[128];
    WCHAR   LocalComputerName[128];

    LPTSTR MachineName = NULL;
    LPTSTR p;
    LPTSTR DCName = NULL;
    NET_API_STATUS NetStatus;
    UNICODE_STRING NameStrings;
    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains = NULL;
    PLSA_TRANSLATED_SID LsaSids = NULL;
    PUSER_MODALS_INFO_1 Modals = NULL;
    DWORD Size;
    NTSTATUS Status;

    //
    // Get the domain name
    //

    p = wcschr( wszAccountName, L'\\' );
    if (p) {
        *p = 0;
        wcscpy( DomainName, wszAccountName );
        *p = L'\\';
    } else {
        wcscpy( DomainName, wszAccountName );
    }

    //
    // Open the policy on the target machine.
    //
    Status = OpenPolicy(
        NULL,
        POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
        &PolicyHandle
        );
    if (Status != STATUS_SUCCESS) {
        goto exit;
    }

    //
    // lookup the domain name for the account
    //

    InitLsaString( &NameStrings, AccountName );

    Status = LsaLookupNames(
        PolicyHandle,
        1,
        &NameStrings,
        &ReferencedDomains,
        &LsaSids
        );
    if (Status != STATUS_SUCCESS) {
        goto exit;
    }

    //
    // get the local computer name
    //

    Size = sizeof(LocalComputerName);
    if (!GetComputerNameW( LocalComputerName, &Size )) {
        goto exit;
    }

    //
    // see if we are tring to set a local account
    //

    if (wcscmp( LocalComputerName, ReferencedDomains->Domains->Name.Buffer ) != 0) {

        //
        // see what part of the domain we are attempting to set
        //

        NetStatus = NetUserModalsGet( NULL, 1, (LPBYTE*) &Modals );
        if (NetStatus != NERR_Success) {
            goto exit;
        }

        if (Modals->usrmod1_role != UAS_ROLE_PRIMARY) {

            //
            // we know we are remote, so get the real dc name
            //

            NetStatus = NetGetDCName( NULL, DomainName, (LPBYTE*) &DCName );
            if (NetStatus != NERR_Success) {
                goto exit;
            }

            MachineName = StringDup( DCName );

        }
    }


exit:
    if (Modals) {
        NetApiBufferFree( Modals );
    }
    if (DCName) {
        NetApiBufferFree( DCName );
    }
    if (ReferencedDomains) {
        LsaFreeMemory( ReferencedDomains );
    }
    if (LsaSids) {
        LsaFreeMemory( LsaSids );
    }
    if (PolicyHandle) {
        LsaClose( PolicyHandle );
    }

    return MachineName;
}



DWORD
SetServiceSecurity(
    LPTSTR AccountName
    )
{
    LSA_HANDLE PolicyHandle;
    PSID pSid;
    NTSTATUS Status;
    int iRetVal=RTN_ERROR;
    LPWSTR MachineName;

    WCHAR   NewAccountName[512];
    WCHAR   wszAccountName[256];

    *wszAccountName = L'\0';

    #ifdef UNICODE
    wcscpy(wszAccountName,AccountName);
    #else
//    MultiByteToWideChar(CP_ACP,
//                        0,
//                        AccountName, -1,
//                        wszAccountName, sizeof(wszAccountName));
    #endif


    if (AccountName[0] == L'.') {
        if (GetDefaultDomainName( NewAccountName )) {
            wcscat( NewAccountName, &AccountName[1] );
            AccountName = NewAccountName;
        }
    }

    //
    // try to get the correct machine name
    //
    MachineName = GetMachineName( wszAccountName );

    //
    // Open the policy on the target machine.
    //
    Status = OpenPolicy(
        MachineName,
        POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
        &PolicyHandle
        );
    if (Status != STATUS_SUCCESS) {
        return RTN_ERROR;
    }

    //
    // Obtain the SID of the user/group.
    // Note that we could target a specific machine, but we don't.
    // Specifying NULL for target machine searches for the SID in the
    // following order: well-known, Built-in and local, primary domain,
    // trusted domains.
    //
    if(GetAccountSid(
            MachineName, // target machine
            AccountName,// account to obtain SID
            &pSid       // buffer to allocate to contain resultant SID
            )) {
        //
        // We only grant the privilege if we succeeded in obtaining the
        // SID. We can actually add SIDs which cannot be looked up, but
        // looking up the SID is a good sanity check which is suitable for
        // most cases.

        //
        // Grant the SeServiceLogonRight to users represented by pSid.
        //
        if((Status=SetPrivilegeOnAccount(
                    PolicyHandle,           // policy handle
                    pSid,                   // SID to grant privilege
                    L"SeServiceLogonRight", // Unicode privilege
                    TRUE                    // enable the privilege
                    )) == STATUS_SUCCESS) {
            iRetVal=RTN_OK;
        }
    }

    //
    // Close the policy handle.
    //
    LsaClose(PolicyHandle);

    //
    // Free memory allocated for SID.
    //
    if(pSid != NULL) MemFree(pSid);

    return iRetVal;
}


void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPTSTR String
    )
{
    DWORD StringLength;

    if (String == NULL) {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = wcslen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}

NTSTATUS
OpenPolicy(
    LPTSTR ServerName,
    DWORD DesiredAccess,
    PLSA_HANDLE PolicyHandle
    )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server = NULL;

    //
    // Always initialize the object attributes to all zeroes.
    //
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    if (ServerName != NULL) {
        //
        // Make a LSA_UNICODE_STRING out of the LPTSTR passed in
        //
        InitLsaString(&ServerString, ServerName);
        Server = &ServerString;
    }

    //
    // Attempt to open the policy.
    //
    return LsaOpenPolicy(
                Server,
                &ObjectAttributes,
                DesiredAccess,
                PolicyHandle
                );
}

/*++
This function attempts to obtain a SID representing the supplied
account on the supplied system.

If the function succeeds, the return value is TRUE. A buffer is
allocated which contains the SID representing the supplied account.
This buffer should be freed when it is no longer needed by calling
HeapFree(GetProcessHeap(), 0, buffer)

If the function fails, the return value is FALSE. Call GetLastError()
to obtain extended error information.
--*/

BOOL
GetAccountSid(
    LPTSTR SystemName,
    LPTSTR AccountName,
    PSID *Sid
    )
{
    LPTSTR ReferencedDomain=NULL;
    DWORD cbSid=128;    // initial allocation attempt
    DWORD cbReferencedDomain=32; // initial allocation size
    SID_NAME_USE peUse;
    BOOL bSuccess=FALSE; // assume this function will fail

    __try {

    //
    // initial memory allocations
    //
    if((*Sid=LocalAlloc(cbSid)) == NULL) {
        __leave;
    }

    if((ReferencedDomain=LocalAlloc(cbReferencedDomain)) == NULL) {
        __leave;
    }

    //
    // Obtain the SID of the specified account on the specified system.
    //
    while(!LookupAccountName(
                    SystemName,         // machine to lookup account on
                    AccountName,        // account to lookup
                    *Sid,               // SID of interest
                    &cbSid,             // size of SID
                    ReferencedDomain,   // domain account was found on
                    &cbReferencedDomain,
                    &peUse
                    )) {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            //
            // reallocate memory
            //
            if((*Sid=HeapReAlloc(
                        GetProcessHeap(),
                        0,
                        *Sid,
                        cbSid
                        )) == NULL) __leave;

            if((ReferencedDomain=HeapReAlloc(
                        GetProcessHeap(),
                        0,
                        ReferencedDomain,
                        cbReferencedDomain
                        )) == NULL) __leave;
        }
        else __leave;
    }

    //
    // Indicate success.
    //
    bSuccess=TRUE;

    } // finally
    __finally {

    //
    // Cleanup and indicate failure, if appropriate.
    //

    LocalFree(ReferencedDomain);

    if(!bSuccess) {
        if(*Sid != NULL) {
            LocalFree(*Sid);
            *Sid = NULL;
        }
    }

    } // finally

    return bSuccess;
}

NTSTATUS
SetPrivilegeOnAccount(
    LSA_HANDLE PolicyHandle,    // open policy handle
    PSID AccountSid,            // SID to grant privilege to
    LPTSTR PrivilegeName,       // privilege to grant (Unicode)
    BOOL bEnable                // enable or disable
    )
{
    LSA_UNICODE_STRING PrivilegeString;

    //
    // Create a LSA_UNICODE_STRING for the privilege name.
    //
    InitLsaString(&PrivilegeString, PrivilegeName);

    //
    // grant or revoke the privilege, accordingly
    //
    if(bEnable) {
        return LsaAddAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    }
    else {
        return LsaRemoveAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                FALSE,              // do not disable all rights
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   byronc, coopp, keisuket, vlads
#
#Date:
#   2-Feb-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     StillImage class installer
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=sti_ci
TARGETTYPE=DYNLINK
TARGETPATH=$(OBJ_DIR)

TARGETEXT=dll
DLLENTRY=_DllMainCRTStartup
COFFBASE=usermode

#
# Make sure we pick up the latest versions of things
#
WIN32_WINNT_VERSION=$(LATEST_WIN32_WINNT_VERSION)

#
# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
#
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

#
# Includes
#
INCLUDES = $(INCLUDES); \
    $(BASEDIR)\public\internal\shell\inc;


DLLDEF=..\sti_ci.def

SOURCES=                \
        ..\wizpage.cpp  \
        ..\prevpg.cpp   \
        ..\string.cpp   \
        ..\nameit.cpp   \
        ..\firstpg.cpp  \
        ..\finalpg.cpp  \
        ..\debug.cpp    \
        ..\service.cpp  \
        ..\util.cpp     \
        ..\portsel.cpp  \
        ..\exports.cpp  \
        ..\device.cpp   \
        ..\entry.cpp    \
        ..\ptp.cpp      \
        ..\sti_ci.rc



TARGETLIBS= $(TARGETLIBS) \
            $(SHELL_LIB_PATH)\shfusion.lib      \
            $(SDK_LIB_PATH)\shell32.lib         \
            $(SDK_LIB_PATH)\mscms.lib           \
            $(SDK_LIB_PATH)\oldnames.lib        \
            $(WIA_LIB_PATH)\stirt.lib           \
            $(SDK_LIB_PATH)\wiaguid.lib


PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

#
#
# Fusion manifest
#
SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=sti_ci.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\sticimsg.h ===
;/*++;
;
;Copyright (c) 2002 Microsoft Corporation
;
;Module Name:
;
;    sticimsg.h
;
;Abstract:
;
;    This file contains the message definitions for the WIA class installer.
;
;Author:
;
;    Keisuke Tsuchida   (KeisukeT)    09-Apr-2002
;
;Revision History:
;
;Notes:
;
;--*/
;

//
// MessageId: MSG_WARNING_SERVICE_DISABLED
//
// MessageText:
//
//  %1 is installed, but will not function until the %2 Service is started in the Service Control Manager.
//
#define MSG_WARNING_SERVICE_DISABLED     0x8000200FL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\service.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    service.cpp

Abstract:

    This file provides access to the service control
    manager for starting, stopping, adding, and removing
    services.

Environment:

    WIN32 User Mode

Author:

    Vlad Sadovsky (vlads) 17-Apr-1998

--*/


//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Include
//

#include "sti_ci.h"
#include "device.h"

#include <regstr.h>

#include <sti.h>
#include <stiregi.h>
#include <stilib.h>
#include <stidebug.h>
#include <stiapi.h>
#include <stisvc.h>

#include <eventlog.h>

//
// Extern
//

extern  HINSTANCE   g_hDllInstance;


//
// Prototype
//

DWORD
SetServiceSecurity(
    LPTSTR AccountName
    );

DLLEXPORT
VOID
CALLBACK
InstallWiaService(
    HWND        hwnd,
    HINSTANCE   hinst,
    LPTSTR      lpszCmdLine,
    int         nCmdShow
    );

//
// Function
//

DWORD
WINAPI
StiServiceInstall(
    BOOL    UseLocalSystem,
    BOOL    DemandStart,
    LPTSTR  lpszUserName,
    LPTSTR  lpszUserPassword
    )
/*++

Routine Description:

    Service installation function.
    Calls SCM to install STI service, which is running in user security context

Arguments:

Return Value:

    None.

--*/
{

    DWORD       dwError = NOERROR;

    SC_HANDLE   hSCM = NULL;
    SC_HANDLE   hService = NULL;

    SERVICE_DESCRIPTION ServiceDescroption;
    TCHAR               szServiceDesc[MAX_PATH];
    TCHAR               szServiceName[MAX_PATH];


    __try  {

        hSCM = ::OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);

        if (!hSCM) {
            dwError = GetLastError();
            __leave;
        }

        //
        // If service already exists change startup type, else CreateService.
        // NOTE: The service should already be installed - if it isn't, we're 
        // patching it here because it MUST be installed in order to use WIA.
        //

        hService = OpenService(
                            hSCM,
                            STI_SERVICE_NAME,
                            SERVICE_ALL_ACCESS
                            );
        if (hService) {

            //
            //  Change the service config parameters.  Note: we're only changing StartType
            //

            if (!ChangeServiceConfig(hService,          // handle to WIA service
                                     SERVICE_NO_CHANGE, // Don't change ServiceType
                                     DemandStart ? SERVICE_DISABLED : SERVICE_AUTO_START,   // Change StartType
                                     SERVICE_NO_CHANGE, // Don't change ErrorControl
                                     NULL,              // Don't change BinaryPathName
                                     NULL,              // Don't change LoadOrderGroup
                                     NULL,              // Don't change TagId
                                     NULL,              // Don't change Dependencies
                                     NULL,              // Don't change ServiceStartName
                                     NULL,              // Don't change Password
                                     NULL)) {           // Don't change DisplayName
                dwError = GetLastError();
                DebugTrace(TRACE_ERROR,(("StiServiceInstall: ChangeServiceConfig() failed. Err=0x%x.\r\n"), dwError));
                __leave;
            } // if (!ChangeServiceConfig(...))

        } else {
            //
            // If use local system - set security
            //

            if (!UseLocalSystem) {
                #ifdef LATER
                dwError = SetServiceSecurity( lpszUserName );
                if (dwError) {
                    dwError = ERROR_SERVICE_LOGON_FAILED ;
                    __leave;
                }
                #endif
            }

            //
            // Load service name.
            //

            if(0 == LoadString(g_hDllInstance, WiaServiceName, szServiceName, MAX_PATH)){
                dwError = GetLastError();
                __leave;
            } // if(0 != LoadString(g_hDllInstance, WiaServiceName, szServiceName, MAX_PATH))

            hService = CreateService(
                                    hSCM,
                                    STI_SERVICE_NAME,
                                    szServiceName,
                                    SERVICE_ALL_ACCESS,
                                    STI_SVC_SERVICE_TYPE,
                                    DemandStart ? SERVICE_DISABLED : SERVICE_AUTO_START,
                                    SERVICE_ERROR_NORMAL,
                                    STI_IMAGE_NAME_SVCHOST,
                                    NULL,
                                    NULL,
                                    STI_SVC_DEPENDENCIES, //STI_SERVICE_DEPENDENCY,
                                    UseLocalSystem ? NULL : lpszUserName,
                                    UseLocalSystem ? NULL : lpszUserPassword
                                    );

            if (!hService) {
                dwError = GetLastError();
                DebugTrace(TRACE_ERROR,(("StiServiceInstall: CreateService() failed. Err=0x%x.\r\n"), dwError));
                __leave;
            }

            //
            // Load service description.
            //

            if(0 != LoadString(g_hDllInstance, WiaServiceDescription, szServiceDesc, MAX_PATH)){

                //
                // Change service description.
                //

                ServiceDescroption.lpDescription = (LPTSTR)szServiceDesc;
                ChangeServiceConfig2(hService,
                                     SERVICE_CONFIG_DESCRIPTION,
                                     (LPVOID)&ServiceDescroption);
            } // if(0 != LoadString(g_hDllInstance, WiaServiceDescription, szServiceDesc, MAX_PATH))
        }

        //
        // Add registry settings for event logging
        //

        RegisterStiEventSources();

        //
        // Start service if AUTO_START.
        //

        if(FALSE == DemandStart){
            if(!StartService(hService,0,(LPCTSTR *)NULL)){
                dwError = GetLastError();
            } // if(!StartService(hService,0,(LPCTSTR *)NULL))
        } // if(FALSE == DemandStart)
    }
    __finally {
        //
        // Close service handle.
        //

        if (NULL != hService) {
            CloseServiceHandle(hService);
        } // if(NULL != hService)

        if(NULL != hSCM){
            CloseServiceHandle( hSCM );
        } // if(NULL != hSCM)
    }

    return dwError;

} //StiServiceInstall


DWORD
WINAPI
StiServiceRemove(
    VOID
    )

/*++

Routine Description:

    Service removal function.  This function calls SCM to remove the STI  service.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success

--*/

{
    DWORD       dwError = NOERROR;

    SC_HANDLE   hSCM = NULL;
    SC_HANDLE   hService = NULL;

    SERVICE_STATUS  ServiceStatus;
    UINT        uiRetry = 10;

    HKEY        hkRun;

    __try  {

        hSCM = ::OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);

        if (!hSCM) {
            dwError = GetLastError();
            DebugTrace(TRACE_ERROR,(("StiServiceRemove: OpenSCManager() failed. Err=0x%x.\r\n"), dwError));
            __leave;
        }

        hService = OpenService(
                            hSCM,
                            STI_SERVICE_NAME,
                            SERVICE_ALL_ACCESS
                            );
        if (!hService) {
            dwError = GetLastError();
            DebugTrace(TRACE_ERROR,(("StiServiceRemove: OpenService() failed. Err=0x%x.\r\n"), dwError));
            __leave;
        }


        //
        // Stop service first
        //

        if (ControlService( hService, SERVICE_CONTROL_STOP, &ServiceStatus )) {

            //
            // Wait a little
            //

            Sleep( STI_STOP_FOR_REMOVE_TIMEOUT );

            ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;

            while( QueryServiceStatus( hService, &ServiceStatus ) &&
                  (SERVICE_STOP_PENDING ==  ServiceStatus.dwCurrentState)) {
                Sleep( STI_STOP_FOR_REMOVE_TIMEOUT );
                if (!uiRetry--) {
                    break;
                }
            }

            if (ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
                dwError = GetLastError();
                DebugTrace(TRACE_ERROR,(("StiServiceRemove: Unable to stop service. Err=0x%x.\r\n"), dwError));
                if(ServiceStatus.dwCurrentState != ERROR_SERVICE_NOT_ACTIVE) {
                    __leave;
                } // if(ServiceStatus.dwCurrentState != ERROR_SERVICE_NOT_ACTIVE)
            } // if (ServiceStatus.dwCurrentState != SERVICE_STOPPED)

        } else { // if (ControlService( hService, SERVICE_CONTROL_STOP, &ServiceStatus ))

            dwError = GetLastError();
            DebugTrace(TRACE_ERROR,(("StiServiceRemove: ControlService() failed. Err=0x%x.\r\n"), dwError));

            //
            // If service hasn't been started yet, just ignore.
            //

            if(ERROR_SERVICE_NOT_ACTIVE != dwError){
                __leave;
            }
        }

        if (!DeleteService( hService )) {
            dwError = GetLastError();
            DebugTrace(TRACE_ERROR,(("StiServiceRemove: DeleteService() failed. Err=0x%x.\r\n"), dwError));
            __leave;
        } else {
            dwError = NOERROR;
        }
    }
    __finally {
        if(NULL != hService){
            CloseServiceHandle( hService );
        }
        if(NULL != hSCM){
            CloseServiceHandle( hSCM );
        }
    } // __finally

    //
    // Leftovers from Win9x - remove STI monitor from Run section
    //
    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUN, &hkRun) == NO_ERROR) {

        RegDeleteValue (hkRun, REGSTR_VAL_MONITOR);
        RegCloseKey(hkRun);
    }

    return dwError;

} // StiServiceRemove


BOOL
SetServiceDependency(
    LPTSTR ServiceName,
    LPTSTR DependentServiceName
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr = NULL;
    SC_HANDLE       hService = NULL;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        goto exit;
    }


    if (!ChangeServiceConfig(
        hService,               // handle to service
        SERVICE_NO_CHANGE,      // type of service
        SERVICE_NO_CHANGE,      // when to start service
        SERVICE_NO_CHANGE,      // severity if service fails to start
        NULL,                   // pointer to service binary file name
        NULL,                   // pointer to load ordering group name
        NULL,                   // pointer to variable to get tag identifier
        DependentServiceName,   // pointer to array of dependency names
        NULL,                   // pointer to account name of service
        NULL,                   // pointer to password for service account
        NULL                    // pointer to display name
        )) {
        goto exit;
    }

    rVal = TRUE;

exit:
    if(NULL != hService){
        CloseServiceHandle( hService );
    }
    if(NULL != hSvcMgr){
        CloseServiceHandle( hSvcMgr );
    }

    return rVal;
}


BOOL
SetServiceStart(
    LPTSTR ServiceName,
    DWORD StartType
    )
{
    BOOL                    rVal = FALSE;
    BOOL                    bRetult = FALSE;
    SC_HANDLE               hSvcMgr = NULL;
    SC_HANDLE               hService = NULL;
    LPQUERY_SERVICE_CONFIG  pServiceConfig = NULL;
    DWORD                   dwSize;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        goto exit;
    }

    //
    // Query service config to get current state.
    //

    dwSize = 0;
    bRetult = QueryServiceConfig(hService, NULL, dwSize, &dwSize);

    if(0 == dwSize){
        goto exit;
    }

    //
    // Allocate required memory.
    //
    
    pServiceConfig = (LPQUERY_SERVICE_CONFIG)new BYTE[dwSize];
    if(NULL == pServiceConfig){
        goto exit;
    } // if(NULL == pServiceConfig)

    if(!QueryServiceConfig(hService, pServiceConfig, dwSize, &dwSize)){
        goto exit;
    } // if(!QueryServiceConig(hService, pServiceConfig, dwSize, &dwSize))

    if(SERVICE_DISABLED == pServiceConfig->dwStartType){
        
        //
        // Service is disabled, we can't change the state here.
        //
        
        goto exit;
    } else if(StartType == pServiceConfig->dwStartType){
        
        //
        // We're already in the specified state.
        //
        
        rVal = TRUE;
        goto exit;
    }

    if (!ChangeServiceConfig(
        hService,                        // handle to service
        SERVICE_NO_CHANGE,               // type of service
        StartType,                       // when to start service
        SERVICE_NO_CHANGE,               // severity if service fails to start
        NULL,                            // pointer to service binary file name
        NULL,                            // pointer to load ordering group name
        NULL,                            // pointer to variable to get tag identifier
        NULL,                            // pointer to array of dependency names
        NULL,                            // pointer to account name of service
        NULL,                            // pointer to password for service account
        NULL                             // pointer to display name
        ))
    {
        goto exit;
    }

    rVal = TRUE;

exit:
    if(NULL != pServiceConfig){
        delete[] pServiceConfig;
        pServiceConfig = NULL;
    } // if(NULL != pServiceConfig)

    if(NULL != hService){
        CloseServiceHandle( hService );
    }
    if(NULL != hSvcMgr){
        CloseServiceHandle( hSvcMgr );
    }

    return rVal;
}

BOOL
StartWiaService(
    VOID
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr = NULL;
    SC_HANDLE       hService = NULL;
    SERVICE_STATUS  ServiceStatus;
    UINT            uiRetry = 40;       // start time is much larger than stop time.
                                        // Setting 40 sec just to be safe.




    DebugTrace(TRACE_PROC_ENTER,(("StartWiaService: Enter... \r\n")));

    //
    // Open Service Control Manager.
    //

    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        DebugTrace(TRACE_ERROR,(("StartWiaService: ERROR!! OpenSCManager failed. Err=0x%x\n"), GetLastError()));
        goto exit;
    }

    //
    // Open WIA service.
    //

    hService = OpenService(
        hSvcMgr,
        STI_SERVICE_NAME,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        DebugTrace(TRACE_ERROR,(("StartWiaService: ERROR!! OpenService failed, re-creating Service Entry (Err=0x%x)\n"), GetLastError()));

        //
        //  Attempt to re-install service
        //

        InstallWiaService(NULL,
                          NULL,
                          NULL,
                          0);
        Sleep(3000);

        //
        //  Try to open it again
        //
        hService = OpenService(
            hSvcMgr,
            STI_SERVICE_NAME,
            SERVICE_ALL_ACCESS
            );

        if (!hService) {
            DebugTrace(TRACE_ERROR,(("StartWiaService: ERROR!! OpenService failed for the second time.  Err=0x%x\n"), GetLastError()));
            goto exit;
        }
    }

    rVal = StartService(hService,
                        0,
                        (LPCTSTR *)NULL);
    if(!rVal){
        DebugTrace(TRACE_STATUS,(("StartWiaService: ERROR!! StartService failed. Err=0x%x\n"), GetLastError()));
        goto exit;
    }

    //
    // Wait for WIA service to really start.
    //

    Sleep( STI_STOP_FOR_REMOVE_TIMEOUT );

    ServiceStatus.dwCurrentState = SERVICE_START_PENDING;

    while( QueryServiceStatus( hService, &ServiceStatus ) &&
          (SERVICE_START_PENDING ==  ServiceStatus.dwCurrentState)) {
        Sleep( STI_STOP_FOR_REMOVE_TIMEOUT );
        if (!uiRetry--) {
            break;
        }
    }

    if (ServiceStatus.dwCurrentState != SERVICE_RUNNING) {
        DebugTrace(TRACE_ERROR,(("StartWiaService: ERROR!! Hit timeout to start service. Err=0x%x\n"), GetLastError()));
    }


exit:
    if(NULL != hService){
        CloseServiceHandle( hService );
    }
    if(NULL != hSvcMgr){
        CloseServiceHandle( hSvcMgr );
    }

    DebugTrace(TRACE_PROC_LEAVE,(("StartWiaService: Leaving... Ret=0x%x\n"), rVal));
    return rVal;
}


BOOL
StopWiaService(
    VOID
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr = NULL;
    SC_HANDLE       hService = NULL;
    SERVICE_STATUS  ServiceStatus;
    UINT            uiRetry = 10;

    DebugTrace(TRACE_PROC_ENTER,(("StopWiaService: Enter... \r\n")));

    //
    // Open Service Control Manager.
    //

    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        DebugTrace(TRACE_ERROR,(("StopWiaService: ERROR!! OpenSCManager failed. Err=0x%x\n"), GetLastError()));
        goto exit;
    }

    //
    // Open WIA service.
    //

    hService = OpenService(
        hSvcMgr,
        STI_SERVICE_NAME,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        DebugTrace(TRACE_ERROR,(("StopWiaService: ERROR!! OpenService failed. Err=0x%x\n"), GetLastError()));
        goto exit;
    }

    //
    // Stop WIA service.
    //

    rVal = ControlService(hService,
                         SERVICE_CONTROL_STOP,
                         &ServiceStatus);
    if(!rVal){
        DebugTrace(TRACE_ERROR,(("StopWiaService: ERROR!! ControlService failed. Err=0x%x\n"), GetLastError()));
    } else {

        //
        // Wait for WIA service really stops.
        //

        Sleep( STI_STOP_FOR_REMOVE_TIMEOUT );

        ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;

        while( QueryServiceStatus( hService, &ServiceStatus ) &&
              (SERVICE_STOP_PENDING ==  ServiceStatus.dwCurrentState)) {
            Sleep( STI_STOP_FOR_REMOVE_TIMEOUT );
            if (!uiRetry--) {
                break;
            }
        }

        if (ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
            DebugTrace(TRACE_ERROR,(("StopWiaService: ERROR!! Hit timeout to stop service. Err=0x%x\n"), GetLastError()));
        }
    }

exit:
    if(NULL != hService){
        CloseServiceHandle( hService );
    }
    if(NULL != hSvcMgr){
        CloseServiceHandle( hSvcMgr );
    }

    DebugTrace(TRACE_PROC_LEAVE,(("StopWiaService: Leaving... Ret=0x%x\n"), rVal));
    return rVal;
}





/*
BOOL
SetServiceAccount(
    LPTSTR ServiceName,
    PSECURITY_INFO SecurityInfo
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr;
    SC_HANDLE       hService;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        goto exit;
    }


    if (!ChangeServiceConfig(
        hService,                        // handle to service
        SERVICE_NO_CHANGE,               // type of service
        SERVICE_NO_CHANGE,               // when to start service
        SERVICE_NO_CHANGE,               // severity if service fails to start
        NULL,                            // pointer to service binary file name
        NULL,                            // pointer to load ordering group name
        NULL,                            // pointer to variable to get tag identifier
        NULL,                            // pointer to array of dependency names
        SecurityInfo->AccountName,       // pointer to account name of service
        SecurityInfo->Password,          // pointer to password for service account
        NULL                             // pointer to display name
        )) {
        goto exit;
    }

    rVal = TRUE;

exit:
    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\sti_ci.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       sti_ci.h
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Generic header file for WIA class installer.
*
*******************************************************************************/

#ifndef _STI_CI_H_
#define _STI_CI_H_

//
// Include
//

#include <windows.h>
#include <windowsx.h>
#include <assert.h>
#include <tchar.h>
#include <setupapi.h>


#include "resource.h"
#include "cistr.h"
#include "debug.h"

//
// Define
//


#define ID_AUTO                 -1
#define NUM_WIA_PAGES           5
#define MAX_DATA_SECTION        512*sizeof(TCHAR)
#define MAX_DESCRIPTION         64*sizeof(TCHAR)
#define MAX_FRIENDLYNAME        64
#define MAX_DEVICE_ID           64
#define MAX_COMMANDLINE         256
#define MAX_STRING_LENGTH       1024
#define MAX_MUTEXTIMEOUT        60*1000              // 60 Sec
#define MANUAL_INSTALL_MASK     100

#define INVALID_DEVICE_INDEX    -1

#define MONITOR_NAME            TEXT("STIMON.EXE")
#define RUNDLL32                TEXT("RUNDLL32.EXE")
#define STILL_IMAGE             TEXT("StillImage")
#define FRIENDLYNAME            TEXT("FriendlyName")
#define VENDORSETUP             TEXT("VendorSetup")
#define DEVICESECTION           TEXT("DeviceData")
#define PORTNAME                TEXT("PortName")
#define DEVICETYPE              TEXT("DeviceType")
#define DEVICESUBTYPE           TEXT("DeviceSubType")
#define DRIVERDESC              TEXT("DriverDesc")
#define DESCRIPTION             TEXT("Description")
#define CREATEFILENAME          TEXT("CreateFileName")
#define CAPABILITIES            TEXT("Capabilities")
#define EVENTS                  TEXT("Events")
#define WIASECTION              TEXT("WiaSection")
#define PROPERTYPAGES           TEXT("PropertyPages")
#define VENDOR                  TEXT("Vendor")
#define UNINSTALLSECTION        TEXT("UninstallSection")
#define SUBCLASS                TEXT("SubClass")
#define ICMPROFILES             TEXT("ICMProfiles")
#define INFPATH                 TEXT("InfPath")
#define INFSECTION              TEXT("InfSection")
#define ISPNP                   TEXT("IsPnP")
#define USDCLASS                TEXT("USDClass")
#define LPTENUM                 TEXT("LptEnum")
#define ENUM                    TEXT("\\Enum")
#define PORTS                   TEXT("Ports")
#define DONT_LOAD               TEXT("don't load")
#define CONTROL_INI             TEXT("control.ini")
#define CPL_NAME                TEXT("sticpl.cpl")
#define NO                      TEXT("no")
#define LAUNCH_APP              TEXT("LaunchApplications")
#define SZ_GUID                 TEXT("GUID")
#define CONNECTION              TEXT("Connection")
#define SERIAL                  TEXT("Serial")
#define PARALLEL                TEXT("Parallel")
#define BOTH                    TEXT("Both")
#define AUTO                    TEXT("AUTO")
#define VIDEO_PATH_ID           TEXT("DShowDeviceId")
#define DEVICESECTION           TEXT("DeviceData")
#define WIAACMGR_PATH           TEXT("wiaacmgr.exe")
#define WIAACMGR_ARG            TEXT("-SelectDevice")
#define WIADEVLISTMUTEX         TEXT("WiaDeviceListMutex")
#define WIA_GUIDSTRING          TEXT("{6BDD1FC6-810F-11D0-BEC7-08002BE2092F}")
#define STI_CI32_ENTRY_WIZMANU  TEXT("sti_ci.dll,WiaCreateWizardMenu")
#define LAYOUT_INF_PATH         TEXT("\\inf\\layout.inf")
#define SOURCEDISKFILES         TEXT("SourceDisksFiles")
#define PROVIDER                TEXT("Provider")
#define MICROSOFT               TEXT("Microsoft")
#define PORTSELECT              TEXT("PortSelect")
#define WIAINSTALLERMUTEX       TEXT("WiaInstallerMutex")
#define WIAINSTALLWIZMUTEX      TEXT("WiaInstallWizMutex")
#define WIAINSTALLERFILENAME    TEXT("sti_ci.dll")
#define WIAWIZARDCHORCUTNAME    TEXT("Scanner and Camera Wizard")
#define MESSAGE1                TEXT("Message1")
#define NEWDEVDLL               TEXT("newdev.dll")

#define BUTTON_NOT_PUSHED       0
#define BUTTON_NEXT             1
#define BUTTON_BACK             2

#define PORTSELMODE_NORMAL      0
#define PORTSELMODE_SKIP        1
#define PORTSELMODE_MESSAGE1    2

#define EXECDIR_SYSTEM32        1

#ifndef DLLEXPORT
#define DLLEXPORT               __declspec(dllexport)
#endif // DLLEXPORT


//
// Registry Paths
//

#define REGKEY_DEVICE_PARMS             TEXT("Device Parameters")
#define REGKEY_CONTROLINIFILEMAPPING    TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping\\control.ini")
#define REGSTR_VAL_FRIENDLY_NAME        TEXT("FriendlyName")
#define REGSTR_VAL_FRIENDLY_NAME_A      "FriendlyName"
#define REGSTR_VAL_DEVICE_ID            TEXT("DeviceID")
#define REGSTR_VAL_WIZMENU              TEXT("WIAWizardMenu")

#define REGKEY_WIASHEXT                 TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\DelegateFolders\\{E211B736-43FD-11D1-9EFB-0000F8757FCD}")
#define REGKEY_INSTALL_NAMESTORE        TEXT("SYSTEM\\CurrentControlSet\\Control\\StillImage\\DeviceNameStore")
#define REGSTR_VAL_WIASHEXT             TEXT("Scanners & Cameras")

//
// Migration
//

#define NAME_BEGIN_A                "BEGIN"
#define NAME_BEGIN_W                L"BEGIN"
#define NAME_END_A                  "END"
#define NAME_END_W                  L"END"

//
// Macro
//

#ifdef UNICODE
 #define AtoT(_d_, _s_)  MultiByteToWideChar(CP_ACP, 0, _s_, -1, _d_, MAX_PATH);
#else // UNICODE
 #define AtoT(_d_, _s_)
#endif // UNICODE


#define IS_VALID_HANDLE(h)  (((h) != NULL) && ((h) != INVALID_HANDLE_VALUE))

#ifndef ARRAYSIZE
 #define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#endif


//
// Struct
//

typedef struct  _INSTALLER_CONTEXT {

    HDEVINFO            hDevInfo;
    SP_DEVINFO_DATA     spDevInfoData;
    HWND                hwndWizard;

    PVOID               pFirstPage;
    PVOID               pPrevSelectPage;
    PVOID               pPortSelectPage;
    PVOID               pNameDevicePage;
    PVOID               pFinalPage;
    PVOID               pDevice;

    BOOL                bShowFirstPage;
    BOOL                bCalledFromControlPanal;
    UCHAR               szPortName[MAX_DESCRIPTION];

} INSTALLER_CONTEXT, *PINSTALLER_CONTEXT;

typedef struct  _CLEANUPITEM {
    BOOL    bInstalled;
    BOOL    bRemoved;
} CLEANUPITEM, *PCLEANUPITEM;


// For migration.
typedef struct  _PARAM_LIST {
    PVOID           pNext;
    LPSTR           pParam1;
    LPSTR           pParam2;
} PARAM_LIST, *PPARAM_LIST;

typedef struct  _DEVICE_INFO {

    LPSTR           pszFriendlyName;
    LPSTR           pszCreateFileName;
    LPSTR           pszInfPath;
    LPSTR           pszInfSection;

    DWORD           dwNumberOfDeviceDataKey;
    PPARAM_LIST     pDeviceDataParam;
} DEVICE_INFO, *PDEVICE_INFO;



//
// Prototype
//

BOOL
GetInfInforamtionFromSelectedDevice(
    HDEVINFO    hDevInfo,
    LPTSTR      pInfFileName,
    LPTSTR      pInfSectionName
    );

BOOL
GetStringFromRegistry(
    HKEY    hkRegistry,
    LPCTSTR szValueName,
    LPTSTR  pBuffer
    );

BOOL
GetDwordFromRegistry(
    HKEY    hkRegistry,
    LPCTSTR szValueName,
    LPDWORD pdwValue
    );

VOID
ShowInstallerMessage(
    DWORD   dwMessageId
    );

VOID
SetRunonceKey(
    LPTSTR  szValue,
    LPTSTR  szData
    );
DWORD
DecodeHexA(
    LPSTR   lpstr
    );

BOOL
IsWindowsFile(
    LPTSTR  szFileName
    );

BOOL
IsProviderMs(
    LPTSTR  szInfName
    );

BOOL
IsIhvAndInboxExisting(
    HDEVINFO            hDevInfo,
    PSP_DEVINFO_DATA    pDevInfoData
    );

BOOL
IsNameAlreadyStored(
    LPTSTR  szName
    );

HFONT
GetIntroFont(
    HWND hwnd
    );

BOOL
IsDeviceRootEnumerated(
    IN  HDEVINFO                        hDevInfo,
    IN  PSP_DEVINFO_DATA                pDevInfoData
    );

int
MyStrCmpi(
    LPCTSTR str1,
    LPCTSTR str2
    );

VOID
LogSystemEvent(
    WORD    wEventType,
    DWORD   dwEventID,
    WORD    wNumberOfString,
    LPTSTR  szMsg[]
    );

// from entry.cpp
extern "C"
DWORD
APIENTRY
CoinstallerEntry(
    IN  DI_FUNCTION                     diFunction,
    IN  HDEVINFO                        hDevInfo,
    IN  PSP_DEVINFO_DATA                pDevInfoData,
    IN  OUT PCOINSTALLER_CONTEXT_DATA   pCoinstallerContext
    );

DWORD
APIENTRY
CoinstallerPreProcess(
    IN  DI_FUNCTION                     diFunction,
    IN  HDEVINFO                        hDevInfo,
    IN  PSP_DEVINFO_DATA                pDevInfoData,
    IN  OUT PCOINSTALLER_CONTEXT_DATA   pCoinstallerContext
    );

DWORD
APIENTRY
CoinstallerPostProcess(
    IN  DI_FUNCTION                     diFunction,
    IN  HDEVINFO                        hDevInfo,
    IN  PSP_DEVINFO_DATA                pDevInfoData,
    IN  OUT PCOINSTALLER_CONTEXT_DATA   pCoinstallerContext
    );

BOOL
IsValidMigrationDevice(
    PDEVICE_INFO    pMigratingDevice
    );

BOOL
IsValidFriendlyName(
    LPSTR   szFriendlyName
    );

//
// Class
//

class CInstallerMutex {

private:
    HANDLE              *m_phMutex;
    BOOL                m_bSucceeded;

public:

    CInstallerMutex(HANDLE* phMutex, LPTSTR szMutexName, DWORD dwTimeout);
    ~CInstallerMutex();

    inline BOOL Succeeded() {
        return m_bSucceeded;
    }
};

#endif // _STI_CI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\userdbg.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2000

Module Name:

    userdbg.h

Abstract:

    Project dependent header for debug.

Author: 

    Keisuke Tsuchida (KeisukeT)

Environment:

    user mode only

Notes:

Revision History:

--*/

#ifndef __USERDBG__
#define __USERDBG__

#include <setupapi.h>

typedef struct _DIF_DEBUG {
    DWORD DifValue;
    LPTSTR DifString;
} DIF_DEBUG, *PDIF_DEBUG;

const DIF_DEBUG DifDebug[] =
{
    { 0,                                    TEXT("")                                  },  //  0x00000000
    { DIF_SELECTDEVICE,                     TEXT("DIF_SELECTDEVICE"                 ) },  //  0x00000001
    { DIF_INSTALLDEVICE,                    TEXT("DIF_INSTALLDEVICE"                ) },  //  0x00000002
    { DIF_ASSIGNRESOURCES,                  TEXT("DIF_ASSIGNRESOURCES"              ) },  //  0x00000003
    { DIF_PROPERTIES,                       TEXT("DIF_PROPERTIES"                   ) },  //  0x00000004
    { DIF_REMOVE,                           TEXT("DIF_REMOVE"                       ) },  //  0x00000005
    { DIF_FIRSTTIMESETUP,                   TEXT("DIF_FIRSTTIMESETUP"               ) },  //  0x00000006
    { DIF_FOUNDDEVICE,                      TEXT("DIF_FOUNDDEVICE"                  ) },  //  0x00000007
    { DIF_SELECTCLASSDRIVERS,               TEXT("DIF_SELECTCLASSDRIVERS"           ) },  //  0x00000008
    { DIF_VALIDATECLASSDRIVERS,             TEXT("DIF_VALIDATECLASSDRIVERS"         ) },  //  0x00000009
    { DIF_INSTALLCLASSDRIVERS,              TEXT("DIF_INSTALLCLASSDRIVERS"          ) },  //  0x0000000A
    { DIF_CALCDISKSPACE,                    TEXT("DIF_CALCDISKSPACE"                ) },  //  0x0000000B
    { DIF_DESTROYPRIVATEDATA,               TEXT("DIF_DESTROYPRIVATEDATA"           ) },  //  0x0000000C
    { DIF_VALIDATEDRIVER,                   TEXT("DIF_VALIDATEDRIVER"               ) },  //  0x0000000D
    { DIF_MOVEDEVICE,                       TEXT("DIF_MOVEDEVICE"                   ) },  //  0x0000000E
    { DIF_DETECT,                           TEXT("DIF_DETECT"                       ) },  //  0x0000000F
    { DIF_INSTALLWIZARD,                    TEXT("DIF_INSTALLWIZARD"                ) },  //  0x00000010
    { DIF_DESTROYWIZARDDATA,                TEXT("DIF_DESTROYWIZARDDATA"            ) },  //  0x00000011
    { DIF_PROPERTYCHANGE,                   TEXT("DIF_PROPERTYCHANGE"               ) },  //  0x00000012
    { DIF_ENABLECLASS,                      TEXT("DIF_ENABLECLASS"                  ) },  //  0x00000013
    { DIF_DETECTVERIFY,                     TEXT("DIF_DETECTVERIFY"                 ) },  //  0x00000014
    { DIF_INSTALLDEVICEFILES,               TEXT("DIF_INSTALLDEVICEFILES"           ) },  //  0x00000015
    { DIF_UNREMOVE,                         TEXT("DIF_UNREMOVE"                     ) },  //  0x00000016
    { DIF_SELECTBESTCOMPATDRV,              TEXT("DIF_SELECTBESTCOMPATDRV"          ) },  //  0x00000017
    { DIF_ALLOW_INSTALL,                    TEXT("DIF_ALLOW_INSTAL"                 ) },  //  0x00000018
    { DIF_REGISTERDEVICE,                   TEXT("DIF_REGISTERDEVICE"               ) },  //  0x00000019
    { DIF_NEWDEVICEWIZARD_PRESELECT,        TEXT("DIF_NEWDEVICEWIZARD_PRESELECT"    ) },  //  0x0000001A
    { DIF_NEWDEVICEWIZARD_SELECT,           TEXT("DIF_NEWDEVICEWIZARD_SELECT"       ) },  //  0x0000001B
    { DIF_NEWDEVICEWIZARD_PREANALYZE,       TEXT("DIF_NEWDEVICEWIZARD_PREANALYZE"   ) },  //  0x0000001C
    { DIF_NEWDEVICEWIZARD_POSTANALYZE,      TEXT("DIF_NEWDEVICEWIZARD_POSTANALYZE"  ) },  //  0x0000001D
    { DIF_NEWDEVICEWIZARD_FINISHINSTALL,    TEXT("DIF_NEWDEVICEWIZARD_FINISHINSTALL") },  //  0x0000001E
    { DIF_UNUSED1,                          TEXT("DIF_UNUSED1"                      ) },  //  0x0000001F
    { DIF_INSTALLINTERFACES,                TEXT("DIF_INSTALLINTERFACES"            ) },  //  0x00000020
    { DIF_DETECTCANCEL,                     TEXT("DIF_DETECTCANCE"                  ) },  //  0x00000021
    { DIF_REGISTER_COINSTALLERS,            TEXT("DIF_REGISTER_COINSTALLERS"        ) },  //  0x00000022
    { DIF_ADDPROPERTYPAGE_ADVANCED,         TEXT("DIF_ADDPROPERTYPAGE_ADVANCED"     ) },  //  0x00000023
    { DIF_ADDPROPERTYPAGE_BASIC,            TEXT("DIF_ADDPROPERTYPAGE_BASIC"        ) },  //  0x00000024
    { DIF_RESERVED1,                        TEXT("DIF_RESERVED1"                    ) },  //  0x00000025
    { DIF_TROUBLESHOOTER,                   TEXT("DIF_TROUBLESHOOTER"               ) },  //  0x00000026
    { DIF_POWERMESSAGEWAKE,                 TEXT("DIF_POWERMESSAGEWAKE"             ) },  //  0x00000027
    { 0,                                    TEXT("")                                  }   //  0x00000028
};


const TCHAR  *szInstallOpNames[] = {
    TEXT("SPFILENOTIFY_UNKNOWN            "), // 0x00000000
    TEXT("SPFILENOTIFY_STARTQUEUE         "), // 0x00000001
    TEXT("SPFILENOTIFY_ENDQUEUE           "), // 0x00000002
    TEXT("SPFILENOTIFY_STARTSUBQUEUE      "), // 0x00000003
    TEXT("SPFILENOTIFY_ENDSUBQUEUE        "), // 0x00000004
    TEXT("SPFILENOTIFY_STARTDELETE        "), // 0x00000005
    TEXT("SPFILENOTIFY_ENDDELETE          "), // 0x00000006
    TEXT("SPFILENOTIFY_DELETEERROR        "), // 0x00000007
    TEXT("SPFILENOTIFY_STARTRENAME        "), // 0x00000008
    TEXT("SPFILENOTIFY_ENDRENAME          "), // 0x00000009
    TEXT("SPFILENOTIFY_RENAMEERROR        "), // 0x0000000a
    TEXT("SPFILENOTIFY_STARTCOPY          "), // 0x0000000b
    TEXT("SPFILENOTIFY_ENDCOPY            "), // 0x0000000c
    TEXT("SPFILENOTIFY_COPYERROR          "), // 0x0000000d
    TEXT("SPFILENOTIFY_NEEDMEDIA          "), // 0x0000000e
    TEXT("SPFILENOTIFY_QUEUESCAN          ") // 0x0000000f
};


#endif //  __USERDBG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\string.cpp ===
/******************************************************************************

  Source File:  String.CPP

  String Handling class implementation, v 98.6 1/2

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  Change History:
  01-08-97  Bob Kjelgaard
  01-03-97  Bob Kjelgaard   Added special functions to aid port extraction
                            for plug-and-play.
  07-05-97  Tim Wells       Ported to NT.


******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Include
//

#include "sti_ci.h"

//
// Extern
//

extern HINSTANCE g_hDllInstance;

//
// Function
//


CString::CString(const CString& csRef) {

    m_lpstr = (csRef.m_lpstr && *csRef.m_lpstr) ?
        new TCHAR[1 + lstrlen(csRef.m_lpstr)] : NULL;

    if  (m_lpstr)
        lstrcpy(m_lpstr, csRef.m_lpstr);
}

CString::CString(LPCTSTR lpstrRef){

    DWORD   dwLength;

    m_lpstr     = NULL;

    _try {
        dwLength = lstrlen(lpstrRef);
    } // _try {
    _except(EXCEPTION_EXECUTE_HANDLER) {
        dwLength = 0;
    } // _except(EXCEPTION_EXECUTE_HANDLER) 
    
    if( (NULL != lpstrRef)
     && (NULL != *lpstrRef)
     && (0 != dwLength) )
    {
        m_lpstr = new TCHAR[dwLength+1];
        lstrcpy(m_lpstr, lpstrRef);
    }

} // CString::CString(LPCTSTR lpstrRef)

const CString&  CString::operator =(const CString& csRef) {

    Empty();

    m_lpstr = (csRef.m_lpstr && *csRef.m_lpstr) ?
        new TCHAR[1 + lstrlen(csRef.m_lpstr)] : NULL;

    if  (m_lpstr)
        lstrcpy(m_lpstr, csRef.m_lpstr);

    return  *this;

    }

const 
CString&  
CString::operator =(
    LPCTSTR lpstrRef
    ) 
{

    DWORD   dwLength;

    Empty();

    _try {
        dwLength = lstrlen(lpstrRef);
    } // _try {
    _except(EXCEPTION_EXECUTE_HANDLER) {
        dwLength = 0;
    } // _except(EXCEPTION_EXECUTE_HANDLER) 
    
    if( (NULL != lpstrRef)
     && (NULL != *lpstrRef)
     && (0 != dwLength) )
    {
        m_lpstr = new TCHAR[dwLength+1];
        lstrcpy(m_lpstr, lpstrRef);
    }

    return  *this;
} // CString::operator =(LPCTSTR lpstrRef)

void    CString::GetContents(HWND hwnd) {

    Empty();

    if  (!IsWindow(hwnd))
        return;

    unsigned u = (unsigned) SendMessage(hwnd, WM_GETTEXTLENGTH, 0, 0);

    if  (!u)
        return;

    m_lpstr = new TCHAR[++u];
    if(NULL != m_lpstr){
        SendMessage(hwnd, WM_GETTEXT, u, (LPARAM) m_lpstr);
    }
}

void    CString::FromTable(unsigned uid) {

    TCHAR    acTemp[MAX_PATH+1];

    memset(acTemp, 0, sizeof(acTemp));

    LoadString(g_hDllInstance, uid, acTemp, ARRAYSIZE(acTemp)-1);

    *this = acTemp;
}

void    CString::Load(ATOM at, BOOL bGlobal) {

    TCHAR    acTemp[MAX_PATH+1];

    memset(acTemp, 0, sizeof(acTemp));

    if(bGlobal){
        GlobalGetAtomName(at, 
                          acTemp, 
                          ARRAYSIZE(acTemp)-1);
    } else {
        GetAtomName(at, 
                    acTemp, 
                    sizeof(acTemp)/sizeof(TCHAR));
    }

    *this = acTemp;
}

void    
CString::Load(
    HINF    hInf,
    LPCTSTR lpstrSection, 
    LPCTSTR lpstrKeyword,
    DWORD   dwFieldIndex,
    LPCTSTR lpstrDefault
    ) 
{

    INFCONTEXT  InfContext;
    TCHAR       szKeyBuffer[MAX_PATH+1];
    TCHAR       szValueBuffer[MAX_PATH+1];
    
    //
    // Initialize local.
    //
    memset(&InfContext, 0, sizeof(InfContext));
    memset(szKeyBuffer, 0, sizeof(szKeyBuffer));
    memset(szValueBuffer, 0, sizeof(szValueBuffer));
    
    //
    // Cleanup contents;
    //

    Empty();

    //
    // Check all parameters.
    //
    
    if( (NULL == lpstrSection)
     || (NULL == lpstrKeyword)
     || (!IS_VALID_HANDLE(hInf)) )
    {
        //
        // Invalid parameter.
        //
        
        goto Load_return;
    }

    //
    // Get matching line.
    //

    while(SetupFindFirstLine(hInf, lpstrSection, lpstrKeyword, &InfContext)){
        
        //
        // Get a field of a line.
        //

        if(SetupGetStringField(&InfContext, dwFieldIndex, szValueBuffer, ARRAYSIZE(szValueBuffer)-1, NULL)){
            
            *this = szValueBuffer;
            break;
        }// if(SetupGetStringField(&InfContext, dwFieldIndex, szValueBuffer, ARRAYSIZE(szValueBuffer)-1))
    } // while(SetupFindFirstLine(hInf, lpstrSection, lpstrKeyword, &InfContext))

Load_return:

    return;

} // CString::Load() Load from INF

void    CString::Load(HKEY hk, LPCTSTR lpstrKeyword) {

    TCHAR   abTemp[MAX_PATH+1];
    ULONG   lcbNeeded = sizeof(abTemp)-sizeof(TCHAR);

    memset(abTemp, 0, sizeof(abTemp));

    RegQueryValueEx(hk, lpstrKeyword, NULL, NULL, (PBYTE)abTemp, &lcbNeeded);
    *this = (LPCTSTR) abTemp;
}

void    CString::MakeSystemPath(LPCTSTR lpstrFileName) {

    DWORD   dwLength;

    if (m_lpstr)
        delete m_lpstr;

    _try {
        dwLength = lstrlen(lpstrFileName);
    } // _try {
    _except(EXCEPTION_EXECUTE_HANDLER) {
        dwLength = 0;
    } // _except(EXCEPTION_EXECUTE_HANDLER) 

    m_lpstr = new TCHAR[MAX_PATH * 2];
    if( (NULL != m_lpstr)
     && (0 != dwLength)
     && (MAX_PATH >= dwLength) )
    {
        memset(m_lpstr, 0, MAX_PATH*2*sizeof(TCHAR));

        UINT uiLength = GetSystemDirectory (m_lpstr, MAX_PATH);

        if ( *(m_lpstr + uiLength) != TEXT('\\'))
            lstrcat (m_lpstr, TEXT("\\"));

        lstrcat (m_lpstr, lpstrFileName);
    }
}

void    CString::Store(HKEY hk, LPCTSTR lpstrKey, LPCTSTR lpstrType) {

    DWORD   dwLength;

    if  (IsEmpty())
        return;

    _try {
        dwLength = lstrlen(lpstrKey);
    } // _try {
    _except(EXCEPTION_EXECUTE_HANDLER) {
        return;
    } // _except(EXCEPTION_EXECUTE_HANDLER) 

    if (lpstrType && *lpstrType == TEXT('1')) {

        DWORD   dwValue = Decode();
        RegSetValueEx(hk, lpstrKey, NULL, REG_DWORD, (LPBYTE) &dwValue,
            sizeof (DWORD));

    } else {

        RegSetValueEx(hk, lpstrKey, NULL, REG_SZ, (LPBYTE) m_lpstr,
            (1 + lstrlen(m_lpstr)) * sizeof(TCHAR) );
    }
}

//  This one is a bit lame, but it does the job.

DWORD   CString::Decode() {

    if  (IsEmpty())
        return  0;

    for (LPTSTR  lpstrThis = m_lpstr;
        *lpstrThis && *lpstrThis == TEXT(' ');
        lpstrThis++)
        ;

    if  (!*lpstrThis)
        return  0;

    // BIUGBUG
    if  (lpstrThis[0] == TEXT('0') && (lpstrThis[1] | TEXT('\x20') ) == TEXT('x')) {
        //  Hex string
        lpstrThis += 2;
        DWORD   dwReturn = 0;

        while   (*lpstrThis) {
            switch  (*lpstrThis) {
                case    TEXT('0'):
                case    TEXT('1'):
                case    TEXT('2'):
                case    TEXT('3'):
                case    TEXT('4'):
                case    TEXT('5'):
                case    TEXT('6'):
                case    TEXT('7'):
                case    TEXT('8'):
                case    TEXT('9'):
                    dwReturn <<= 4;
                    dwReturn += ((*lpstrThis) - TEXT('0'));
                    break;

                case    TEXT('a'):
                case    TEXT('A'):
                case    TEXT('b'):
                case    TEXT('c'):
                case    TEXT('d'):
                case    TEXT('e'):
                case    TEXT('f'):
                case    TEXT('B'):
                case    TEXT('C'):
                case    TEXT('D'):
                case    TEXT('E'):
                case    TEXT('F'):
                    dwReturn <<= 4;
                    dwReturn += 10 + ((*lpstrThis | TEXT('\x20')) - TEXT('a'));
                    break;

                default:
                    return  dwReturn;
            }
            lpstrThis++;
        }
        return  dwReturn;
    }

    for (DWORD  dwReturn = 0;
         *lpstrThis && *lpstrThis >= TEXT('0') && *lpstrThis <= TEXT('9');
         lpstrThis++) {

        dwReturn *= 10;
        dwReturn += *lpstrThis - TEXT('0');
    }

    return  dwReturn;

}


CString  operator + (const CString& cs1, const CString& cs2) {

    if  (cs1.IsEmpty())
        return  cs2;

    if  (cs2.IsEmpty())
        return  cs1;

    CString csReturn;

    csReturn.m_lpstr = new TCHAR[ 1 + lstrlen(cs1) +lstrlen(cs2)];

    if(NULL != csReturn.m_lpstr){
        lstrcat(lstrcpy(csReturn.m_lpstr, cs1.m_lpstr), cs2.m_lpstr);
    }

    return  csReturn;
}

CString  operator + (const CString& cs1, LPCTSTR lpstr2) {

    DWORD   dwLength;

    _try {
        dwLength = lstrlen(lpstr2);
    } // _try {
    _except(EXCEPTION_EXECUTE_HANDLER) {
        dwLength = 0;
    } // _except(EXCEPTION_EXECUTE_HANDLER) 

    if(0 == dwLength)
        return  cs1;

    if(cs1.IsEmpty())
        return  lpstr2;

    CString csReturn;

    csReturn.m_lpstr = new TCHAR[ 1 + lstrlen(cs1) + dwLength];
    if(NULL != csReturn.m_lpstr){
        lstrcat(lstrcpy(csReturn.m_lpstr, cs1.m_lpstr), lpstr2);
    }

    return  csReturn;
}

CString  operator + (LPCTSTR lpstr1,const CString& cs2) {

    DWORD   dwLength;

    _try {
        dwLength = lstrlen(lpstr1);
    } // _try {
    _except(EXCEPTION_EXECUTE_HANDLER) {
        dwLength = 0;
    } // _except(EXCEPTION_EXECUTE_HANDLER) 

    if(0 == dwLength)
        return  cs2;

    if  (cs2.IsEmpty())
        return  lpstr1;

    CString csReturn;

    csReturn.m_lpstr = new TCHAR[ 1 + dwLength +lstrlen(cs2)];

    if(NULL != csReturn.m_lpstr){
        lstrcat(lstrcpy(csReturn.m_lpstr, lpstr1), cs2.m_lpstr);
    }
    return  csReturn;
}


//  CStringArray class- the implementation is a bit lame, but it isn't
//  really necessary to not be lame, at this point...

CStringArray::CStringArray(unsigned uGrowBy) {
    m_ucItems = m_ucMax = 0;
    m_pcsContents = NULL;
    m_uGrowBy = uGrowBy ? uGrowBy : 10;
}

CStringArray::~CStringArray() {
    if  (m_pcsContents)
        delete[]  m_pcsContents;
}

VOID
CStringArray::Cleanup() {
    if  (m_pcsContents){
        delete[]  m_pcsContents;
    }
    m_pcsContents = NULL;
    m_ucItems = m_ucMax = 0;
}

void    CStringArray::Add(LPCTSTR lpstr) {

    if  (m_ucItems >= m_ucMax) {
        CString *pcsNew = new CString[m_ucMax += m_uGrowBy];

        if  (!pcsNew) {
            m_ucMax -= m_uGrowBy;
            return;
        }

        for (unsigned u = 0; u < m_ucItems; u++)
            pcsNew[u] = m_pcsContents[u];

        delete[]  m_pcsContents;
        m_pcsContents = pcsNew;
    }

    m_pcsContents[m_ucItems++] = lpstr;
}

CString&    CStringArray::operator [](unsigned u) {

    return  (u < m_ucItems) ? m_pcsContents[u] : m_csEmpty;
}

//  Split a string into tokens, and make an array of it

void    CStringArray::Tokenize(LPTSTR lpstr, TCHAR cSeparator) {

    BOOL    fInsideQuotes = FALSE;
    TCHAR   cPreviousChar = TEXT('\0');


    if  (m_pcsContents) {
        delete[]  m_pcsContents;
        m_pcsContents = NULL;
        m_ucItems = m_ucMax = 0;
    }

    if  (!lpstr)
        return;

    for (LPTSTR  lpstrThis = lpstr; *lpstr; lpstr = lpstrThis) {

        /*
        for (; *lpstrThis && *lpstrThis != cSeparator; lpstrThis++) {

        }
        */

        //
        // Skip for next separator , counting quotes
        //

        cPreviousChar = '\0';
        for (;*lpstrThis;  lpstrThis++) {

            if (fInsideQuotes) {
                if (*lpstrThis == TEXT('"')) {
                    if (cPreviousChar != TEXT('"')) {
                       // Previous was not a quote - going out of quotation
                        fInsideQuotes = FALSE;
                    }
                    else {
                        // Previous char was tab too - continue BUGBUG should coalesce
                    }
                    cPreviousChar = TEXT('\0');
                }
                else {
                    cPreviousChar = *lpstrThis;
                }
                continue;
            }
            else {
                if (*lpstrThis == TEXT('"')) {
                    // Starting quote
                    fInsideQuotes = TRUE;
                    cPreviousChar = TEXT('\0');
                    continue;
                }
                if (*lpstrThis == cSeparator) {
                    // Got to separator outside of quote - break the loop
                    break;
                }
            }
        }

        if  (*lpstrThis) {
            *lpstrThis = '\0';
            Add(lpstr);
            *lpstrThis++ = cSeparator;
        }
        else
            Add(lpstr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\wiatwain\wiatwain.cpp ===
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       wiatwain.cpp
*
*  VERSION:     1.0
*
*  DATE:        1 August, 2000
*
*  AUTHOR:      Cooper Partin (coopp)
*
*  DESCRIPTION:
*   Main module, for the "real" fake TWAIN data source wiatwain.ds
*
*******************************************************************************/

BOOL APIENTRY DllMain(HMODULE hModule, DWORD dwreason, LPVOID lpReserved)
{    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\wizpage.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Wizpage.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Generic wizard page class. This is parent class of each wizard pages and it
*   handles common user operation of wizard.
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Include
//


#include "wizpage.h"
#include <stilib.h>

//
// Extern
//

extern HINSTANCE    g_hDllInstance;

//
// Function
//

INT_PTR
CALLBACK
CInstallWizardPage::PageProc(
    HWND    hwndPage,
    UINT    uiMessage,
    WPARAM  wParam,
    LPARAM  lParam
    )
{

    INT_PTR ipReturn = 0;

//    DebugTrace(TRACE_PROC_ENTER,(("CInstallWizardPage::PageProc: Enter... \r\n")));

    //
    // Get current context.
    //

    CInstallWizardPage *pInstallWizardPage = (CInstallWizardPage *)GetWindowLongPtr(hwndPage, DWLP_USER);

    switch (uiMessage) {

        case WM_INITDIALOG: {

            LPPROPSHEETPAGE pPropSheetPage;

            //  The lParam will point to the PROPSHEETPAGE structure which
            //  created this page.  Its lParam parameter will point to the
            //  object instance.

            pPropSheetPage = (LPPROPSHEETPAGE) lParam;
            pInstallWizardPage = (CInstallWizardPage *) pPropSheetPage->lParam;
            ::SetWindowLongPtr(hwndPage, DWLP_USER, (LONG_PTR)pInstallWizardPage);

            //
            // Save parent windows handle.
            //

            pInstallWizardPage->m_hwnd = hwndPage;

            //
            // Call derived class.
            //

            ipReturn = pInstallWizardPage->OnInit();

            goto PageProc_return;
            break;
        } // case WM_INITDIALOG:

        case WM_COMMAND:
        {
            //
            // Just pass down to the derived class.
            //

            ipReturn = pInstallWizardPage->OnCommand(LOWORD(wParam), HIWORD(wParam), (HWND) LOWORD(lParam));
            goto PageProc_return;
            break;
        } // case WM_COMMAND:

        case WM_NOTIFY:
        {

            LPNMHDR lpnmh = (LPNMHDR) lParam;

            //
            // Let derivd class handle this first, then we do if it returns FALSE.
            //

            ipReturn = pInstallWizardPage->OnNotify(lpnmh);
            if(FALSE == ipReturn){
            DebugTrace(TRACE_STATUS,(("CInstallWizardPage::PageProc: Processing default WM_NOTIFY handler. \r\n")));

                switch  (lpnmh->code) {

                    case PSN_WIZBACK:

                        pInstallWizardPage->m_bNextButtonPushed = FALSE;

                        //
                        // Goto previous page.
                        //

                        ::SetWindowLongPtr(hwndPage, DWLP_MSGRESULT, (LONG_PTR)pInstallWizardPage->m_uPreviousPage);
                        ipReturn = TRUE;
                        goto PageProc_return;

                    case PSN_WIZNEXT:

                        pInstallWizardPage->m_bNextButtonPushed = TRUE;

                        //
                        // Goto next page.
                        //

                        ::SetWindowLongPtr(hwndPage, DWLP_MSGRESULT, (LONG_PTR)pInstallWizardPage->m_uNextPage);
                        ipReturn = TRUE;
                        goto PageProc_return;

                    case PSN_SETACTIVE: {

                        DWORD dwFlags;

                        //
                        //  Set the wizard buttons, according to next/prev page.
                        //

                        dwFlags =
                            (pInstallWizardPage->m_uPreviousPage    ? PSWIZB_BACK : 0)
                          | (pInstallWizardPage->m_uNextPage        ? PSWIZB_NEXT : PSWIZB_FINISH);

                        ::SendMessage(GetParent(hwndPage),
                                      PSM_SETWIZBUTTONS,
                                      0,
                                      (long) dwFlags);
                        ipReturn = TRUE;
                        goto PageProc_return;

                    } // case PSN_SETACTIVE:
                    
                    case PSN_QUERYCANCEL: {

                        //
                        // User canceled. Free device object if ever allocated.
                        //
                        if(NULL != pInstallWizardPage->m_pCDevice){
                            delete pInstallWizardPage->m_pCDevice;
                            pInstallWizardPage->m_pCDevice = NULL;
                        } // if(NULL != m_pCDevice)
                        ipReturn = TRUE;
                        goto PageProc_return;
                    } // case PSN_QUERYCANCEL:
                } // switch  (lpnmh->code)

                ipReturn = TRUE;;
            } // if(FALSE == ipReturn)

            goto PageProc_return;
            break;
        } // case WM_NOTIFY:

        default:
        ipReturn = FALSE;
    } // switch (uiMessage)

PageProc_return:
//    DebugTrace(TRACE_PROC_LEAVE,(("CInstallWizardPage::PageProc: Leaving... Ret=0x%x.\r\n"), ipReturn));
    return ipReturn;
}

CInstallWizardPage::CInstallWizardPage(
    PINSTALLER_CONTEXT  pInstallerContext,
    UINT                uTemplate
    )
{
    //
    // Initialize property sheet.
    //

    m_PropSheetPage.hInstance           = g_hDllInstance;
    m_PropSheetPage.pszTemplate         = MAKEINTRESOURCE(uTemplate);
    m_PropSheetPage.pszTitle            = MAKEINTRESOURCE(MessageTitle);
    m_PropSheetPage.dwSize              = sizeof m_PropSheetPage;
    m_PropSheetPage.dwFlags             = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    m_PropSheetPage.pfnDlgProc          = PageProc;
    m_PropSheetPage.lParam              = (LPARAM) this;
    m_PropSheetPage.pszHeaderTitle      = MAKEINTRESOURCE(HeaderTitle);
    m_PropSheetPage.pszHeaderSubTitle   = MAKEINTRESOURCE(SubHeaderTitle);

    //
    // Don't want to show header on welcome/final page.
    //

    if( (IDD_DYNAWIZ_FIRSTPAGE == uTemplate)
     || (EmeraldCity == uTemplate) )
    {
        m_PropSheetPage.dwFlags |= PSP_HIDEHEADER;
    }

    //
    // We want to show some other header for some pages.
    //

    if(IDD_DYNAWIZ_SELECT_NEXTPAGE == uTemplate){
        m_PropSheetPage.pszHeaderTitle      = MAKEINTRESOURCE(HeaderForPortsel);
    } else if (NameTheDevice == uTemplate) {
        m_PropSheetPage.pszHeaderTitle      = MAKEINTRESOURCE(HeaderForNameIt);
    }
    //
    // Add the Fusion flags and global context, so the pages we add will pick up COMCTL32V6
    //

    m_PropSheetPage.hActCtx  = g_hActCtx;
    m_PropSheetPage.dwFlags |= PSP_USEFUSIONCONTEXT;

    //
    // Create Property sheet page.
    //

    m_hPropSheetPage = CreatePropertySheetPage(&m_PropSheetPage);

    //
    // Set other member.
    //

    m_hwnd              = NULL;
    m_hwndWizard        = pInstallerContext->hwndWizard;
    m_pCDevice          = NULL;
    m_bNextButtonPushed = TRUE;
}

CInstallWizardPage::~CInstallWizardPage(
    VOID
    )
{
    //
    // Destroy property sheet page.
    //

    if(NULL != m_hPropSheetPage){
        m_hPropSheetPage = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\wiatwain\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   byronc, coopp, keisuket, vlads
#
#Date:
#   1-Aug-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     Fake TWAIN data source (real binary)
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=wiatwain
TARGETTYPE=DYNLINK
TARGETPATH=$(OBJ_DIR)
TARGETEXT=ds

COFFBASE=usermode

RESOURCE_ONLY_DLL=1

SOURCES=                 \
        ..\wiatwain.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\wizpage.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Wizpage.h
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Generic wizard page class header file.
*
*******************************************************************************/

#ifndef _WIZPAGE_H_
#define _WIZPAGE_H_

//
// Include
//

#include "sti_ci.h"
#include "device.h"

//
// Class
//

class CInstallWizardPage
{

    static
    INT_PTR 
    CALLBACK 
    PageProc(
        HWND    hwndPage,
        UINT    uiMessage,
        WPARAM  wParam,
        LPARAM  lParam
        );

    PROPSHEETPAGE               m_PropSheetPage;        // This property sheet page
    HPROPSHEETPAGE              m_hPropSheetPage;       // Handle to this prop sheet page

protected:

    UINT                        m_uPreviousPage;        // Resource ID of previous page
    UINT                        m_uNextPage;            // Resource ID of next page
    HWND                        m_hwnd;                 // Window handle to this page
    HWND                        m_hwndWizard;           // Window handle to wizard
    CDevice                     *m_pCDevice;            // Device class object.
    BOOL                        m_bNextButtonPushed;    // Indicates how page was moved.
public:

    CInstallWizardPage(PINSTALLER_CONTEXT  pInstallerContext,
                       UINT                uTemplate
                       );
    ~CInstallWizardPage();

    HPROPSHEETPAGE Handle() { return m_hPropSheetPage; }
    
    virtual BOOL OnInit(){ return TRUE; }
    virtual BOOL OnNotify( LPNMHDR lpnmh ) { return FALSE; }
    virtual BOOL OnCommand(WORD wItem, WORD wNotifyCode, HWND hwndItem){ return  FALSE; }
    
};

#endif // !_WIZPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\clsinst\util.cpp ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Util.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Utility function for WIA class installer.
*
*   NOTE:
*   All of string buffers dealt in these functions must have at least
*   MAX_DESCRIPTION size. Since it doesn't have size check of buffer, it assumes
*   all string size is unfer MAX_DESCRIPTION, which must be OK to be used only
*   for WIA class installer.
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Include
//

#include "sti_ci.h"
#include "stiregi.h"
#include <regstr.h>
#include <cfgmgr32.h>

//
// Extern
//

extern HINSTANCE g_hDllInstance;

//
// Function
//

BOOL
GetInfInforamtionFromSelectedDevice(
    HDEVINFO    hDevInfo,
    LPTSTR      pInfFileName,
    LPTSTR      pInfSectionName
    )
{
    BOOL                    bRet;

    SP_DEVINFO_DATA         DeviceInfoData;
    SP_DRVINFO_DATA         DriverInfoData;
    SP_DRVINFO_DETAIL_DATA  DriverInfoDetailData;
    HINF                    hInf;

    TCHAR                   szInfFileName[MAX_DESCRIPTION];
    TCHAR                   szInfSectionName[MAX_DESCRIPTION];

    DebugTrace(TRACE_PROC_ENTER,(("GetInfInforamtionFromSelectedDevice: Enter... \r\n")));

    hInf    = INVALID_HANDLE_VALUE;
    bRet    = FALSE;

    //
    // Check arguments.
    //

    if( (NULL == hDevInfo)
     || (NULL == pInfFileName)
     || (NULL == pInfSectionName) )
    {
        DebugTrace(TRACE_ERROR,(("GetInfInforamtionFromSelectedDevice: ERROR!! Invalid argument. \r\n")));

        bRet = FALSE;
        goto GetInfInforamtionFromSelectedDevice_return;
    }

    //
    // Initialize locals.
    //

    memset (&DeviceInfoData, 0, sizeof(SP_DEVINFO_DATA));
    memset (&DriverInfoData, 0, sizeof(SP_DRVINFO_DATA));
    memset (&DriverInfoDetailData, 0, sizeof(SP_DRVINFO_DETAIL_DATA));
    memset (szInfFileName, 0, sizeof(szInfFileName));
    memset (szInfSectionName, 0, sizeof(szInfSectionName));

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

    //
    // Get selected device element.
    //

    if (!SetupDiGetSelectedDevice (hDevInfo, &DeviceInfoData)) {
        DebugTrace(TRACE_ERROR,(("GetInfInforamtionFromSelectedDevice: ERROR!! SetupDiGetSelectedDevice Failed. Err=0x%lX\r\n"), GetLastError()));
        bRet = FALSE;
        goto GetInfInforamtionFromSelectedDevice_return;
    }

    //
    // Get selected device driver information.
    //

    if (!SetupDiGetSelectedDriver(hDevInfo, &DeviceInfoData, &DriverInfoData)) {
        DebugTrace(TRACE_ERROR,(("GetInfInforamtionFromSelectedDevice: ERROR!! SetupDiGetSelectedDriver Failed. Err=0x%lX\r\n"), GetLastError()));
        bRet = FALSE;
        goto GetInfInforamtionFromSelectedDevice_return;
    }

    //
    // Get detailed data of selected device driver.
    //

    if(!SetupDiGetDriverInfoDetail(hDevInfo,
                                   &DeviceInfoData,
                                   &DriverInfoData,
                                   &DriverInfoDetailData,
                                   sizeof(DriverInfoDetailData),
                                   NULL) )
    {
        DebugTrace(TRACE_ERROR,(("GetInfInforamtionFromSelectedDevice: ERROR!! SetupDiGetDriverInfoDetail Failed.Er=0x%lX\r\n"),GetLastError()));

        bRet = FALSE;
        goto GetInfInforamtionFromSelectedDevice_return;
    }

    //
    // Copy INF filename.
    //

    _tcsncpy(szInfFileName, DriverInfoDetailData.InfFileName, sizeof(szInfFileName)/sizeof(TCHAR));

    //
    // Open INF file of selected driver.
    //

    hInf = SetupOpenInfFile(szInfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);

    if (hInf == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("GetInfInforamtionFromSelectedDevice: ERROR!! SetupOpenInfFile Failed.Er=0x%lX\r\n"),GetLastError()));

        bRet = FALSE;
        goto GetInfInforamtionFromSelectedDevice_return;
    }

    //
    // Get actual INF section name to be installed.
    //

    if (!SetupDiGetActualSectionToInstall(hInf,
                                          DriverInfoDetailData.SectionName,
                                          szInfSectionName,
                                          sizeof(szInfSectionName)/sizeof(TCHAR),
                                          NULL,
                                          NULL) )
    {
        DebugTrace(TRACE_ERROR,(("GetInfInforamtionFromSelectedDevice: ERROR!! SetupDiGetActualSectionToInstall Failed.Er=0x%lX\r\n"),GetLastError()));

        bRet = FALSE;
        goto GetInfInforamtionFromSelectedDevice_return;
    }

    //
    // Copy strings to given buffer.
    //

    _tcsncpy(pInfFileName, szInfFileName, sizeof(szInfFileName)/sizeof(TCHAR));
    _tcsncpy(pInfSectionName, szInfSectionName, sizeof(szInfSectionName)/sizeof(TCHAR));

    //
    // Operation succeeded.
    //

    bRet = TRUE;

GetInfInforamtionFromSelectedDevice_return:

    if(INVALID_HANDLE_VALUE != hInf){
        SetupCloseInfFile(hInf);
    }

    DebugTrace(TRACE_PROC_LEAVE,(("GetInfInforamtionFromSelectedDevice: Leaving... Ret=0x%x\n"), bRet));
    return bRet;
}

BOOL
GetStringFromRegistry(
    HKEY    hkRegistry,
    LPCTSTR szValueName,
    LPTSTR   pBuffer
    )
{
    BOOL    bRet;
    LONG    lError;
    DWORD   dwSize;
    DWORD   dwType;
    TCHAR   szString[MAX_DESCRIPTION];

    //
    // Initialize local.
    //

    bRet        = FALSE;
    lError      = ERROR_SUCCESS;
    dwSize      = sizeof(szString);
    memset(szString, 0, sizeof(szString));

    //
    // Check arguments.
    //

    if( (NULL == hkRegistry)
     || (NULL == szValueName)
     || (NULL == pBuffer) )
    {
        DebugTrace(TRACE_ERROR,(("GetStringFromRegistry: ERROR!! Invalid argument\r\n")));

        bRet = FALSE;
        goto GetStringFromRegistry_return;
    }

    //
    // Get specified string from registry.
    //

    lError = RegQueryValueEx(hkRegistry,
                             szValueName,
                             NULL,
                             &dwType,
                             (LPBYTE)szString,
                             &dwSize);
    if(ERROR_SUCCESS != lError){
        DebugTrace(TRACE_WARNING,(("GetStringFromRegistry: WARNING!! RegQueryValueEx failed. Err=0x%x.\r\n"), GetLastError()));

        bRet = FALSE;
        goto GetStringFromRegistry_return;
    }

    //
    // Make sure NULL termination.
    //

    szString[ARRAYSIZE(szString)-1] = TEXT('\0');

    //
    // Copy acquired string to given buffer. This function assume max-string/bufer size is MAX_DESCRIPTION.
    //

    _tcsncpy(pBuffer, szString, MAX_DESCRIPTION);

    //
    // Operation succeeded.
    //

    bRet = TRUE;

GetStringFromRegistry_return:
    return bRet;
}

BOOL
GetDwordFromRegistry(
    HKEY    hkRegistry,
    LPCTSTR szValueName,
    LPDWORD pdwValue
    )
{
    BOOL    bRet;
    LONG    lError;
    DWORD   dwSize;
    DWORD   dwType;
    DWORD   dwValue;

    //
    // Initialize local.
    //

    bRet        = FALSE;
    lError      = ERROR_SUCCESS;
    dwSize      = sizeof(dwValue);
    dwValue     = 0;

    //
    // Check arguments.
    //

    if( (NULL == hkRegistry)
     || (NULL == szValueName)
     || (NULL == pdwValue) )
    {
        DebugTrace(TRACE_ERROR,(("GetDwordFromRegistry: ERROR!! Invalid argument\r\n")));

        bRet = FALSE;
        goto GetDwordFromRegistry_return;
    }

    //
    // Get specified string from registry.
    //

    lError = RegQueryValueEx(hkRegistry,
                             szValueName,
                             NULL,
                             &dwType,
                             (LPBYTE)&dwValue,
                             &dwSize);
    if(ERROR_SUCCESS != lError){
        DebugTrace(TRACE_WARNING,(("GetDwordFromRegistry: WARNING!! RegQueryValueEx failed. Err=0x%x. Size=0x%x, Type=0x%x\r\n"), lError, dwSize, dwType));

        bRet = FALSE;
        goto GetDwordFromRegistry_return;
    }

    //
    // Copy acquired DWORD value to given buffer.
    //

    *pdwValue = dwValue;

    //
    // Operation succeeded.
    //

    bRet = TRUE;

GetDwordFromRegistry_return:
    return bRet;
} // GetDwordFromRegistry

VOID
SetRunonceKey(
    LPTSTR  szValue,
    LPTSTR  szData
    )
{
    HKEY    hkRun;
    LONG    lResult;
    CString csData;

    //
    // Initialize local.
    //

    hkRun   = NULL;
    lResult = ERROR_SUCCESS;
    csData  = szData;

    //
    // Get RUNONCE regkey.
    //

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           REGSTR_PATH_RUNONCE,
                           0,
                           KEY_READ | KEY_WRITE,
                           &hkRun);
    if(ERROR_SUCCESS == lResult){
        csData.Store(hkRun, szValue);
        RegCloseKey(hkRun);
    } // if(ERROR_SUCCESS == lResult)
} // SetRunonceKey()

VOID
ShowInstallerMessage(
    DWORD   dwMessageId
    )
{
    CString     csTitle;
    CString     csText;

    csTitle.FromTable (MessageTitle);
    csText.FromTable ((unsigned)dwMessageId);

    if( !csTitle.IsEmpty() && !csText.IsEmpty()){
        MessageBox (GetActiveWindow(),
                    csText,
                    csTitle,
                    MB_ICONINFORMATION | MB_OK);
    } // if(csTitle.IsEmpty() || csText.IsEmpty())

} // ShowInstallerMessage()

BOOL
IsWindowsFile(
    LPTSTR  szFileName
    )
{
    BOOL    bRet;
    DWORD   dwNumberOfChar;
    TCHAR   szLayoutInfpath[MAX_PATH+1];
    TCHAR   szReturnBuffer[MAX_PATH];
    TCHAR   *pszFileNameWithoutPath;
    DWORD   Idx;

    DebugTrace(TRACE_PROC_ENTER,("IsWindowsFile: Enter... Checking %ws.\r\n", szFileName));

    //
    // Initialize local.
    //

    bRet                    = FALSE;
    dwNumberOfChar          = 0;
    Idx                     = 0;
    pszFileNameWithoutPath  = NULL;

    memset(szLayoutInfpath, 0, sizeof(szLayoutInfpath));

    //
    // Get INF filename without path.
    //

    while(TEXT('\0') != szFileName[Idx]){
        if(TEXT('\\') == szFileName[Idx]){
            pszFileNameWithoutPath = &(szFileName[Idx+1]);
        } // if('\\' == szFileName[Idx])
        Idx++;
    } // while('\0' != szFileName[Idx])

    //
    // Get system directory.
    //

    if(0 == GetWindowsDirectory(szLayoutInfpath, sizeof(szLayoutInfpath)/sizeof(TCHAR))){
        DebugTrace(TRACE_ERROR,("IsWindowsFile: ERROR!! GetWindowsDirectory failed. Err=0x%x.\r\n", GetLastError()));

        bRet = FALSE;
        goto IsWindowsFile_return;
    } // if(0 == GetWindowsDirectory(szSystemDir, sizeof(szSystemDir)/sizeof(TCHAR)))

    //
    // Create fullpath of layout.inf.
    //

    lstrcat(szLayoutInfpath, LAYOUT_INF_PATH);
    DebugTrace(TRACE_STATUS,("IsWindowsFile: Looking for \'%ws\' in %ws.\r\n", pszFileNameWithoutPath, szLayoutInfpath));

    //
    // See if provided filename is in layout.inf.
    //

    dwNumberOfChar = GetPrivateProfileString(SOURCEDISKFILES,
                                             pszFileNameWithoutPath,
                                             NULL,
                                             szReturnBuffer,
                                             sizeof(szReturnBuffer) / sizeof(TCHAR),
                                             szLayoutInfpath);
    if(0 == dwNumberOfChar){

        //
        // Filename doesn't exist in layout.inf.
        //

        bRet = FALSE;
        goto IsWindowsFile_return;

    } // if(0 == dwNumberOfChar)

    //
    // This filename exists in layout.inf.
    //

    bRet = TRUE;

IsWindowsFile_return:

    DebugTrace(TRACE_PROC_LEAVE,("IsWindowsFile: Leaving... Ret=0x%x\n", bRet));

    return bRet;

} // IsWindowsFile()

BOOL
IsProviderMs(
    LPTSTR  szInfName
    )
{

    BOOL                bRet;
    DWORD               dwSize;
    TCHAR               szProvider[MAX_PATH+1];
    PSP_INF_INFORMATION pspInfInfo;

    DebugTrace(TRACE_PROC_ENTER,("IsProviderMs: Enter... Checking %ws.\r\n", szInfName));

    //
    // Initialize local.
    //

    bRet        = FALSE;
    dwSize      = 0;
    pspInfInfo  = NULL;

    memset(szProvider, 0, sizeof(szProvider));
    
    //
    // Get INF information size.
    //

    SetupGetInfInformation(szInfName,
                           INFINFO_INF_NAME_IS_ABSOLUTE,
                           NULL,
                           0,
                           &dwSize);
    if(0 == dwSize){
        DebugTrace(TRACE_ERROR,(("IsProviderMs: ERROR!! Enable to get required size for INF info. Err=0x%x.\r\n"), GetLastError()));

        bRet = FALSE;
        goto IsProviderMs_return;
    } // if(0 == dwSize)

    //
    // Allocate buffer for INF information.
    //

    pspInfInfo = (PSP_INF_INFORMATION) new char[dwSize];
    if(NULL == pspInfInfo){
        DebugTrace(TRACE_ERROR,(("IsProviderMs: ERROR!! Insuffisient memory.\r\n")));

        bRet = FALSE;
        goto IsProviderMs_return;
    } // if(NULL == pspInfInfo)

    //
    // Get actual INF informaton.
    //

    if(!SetupGetInfInformation(szInfName,
                               INFINFO_INF_NAME_IS_ABSOLUTE,
                               pspInfInfo,
                               dwSize,
                               &dwSize))
    {
        DebugTrace(TRACE_ERROR,(("IsProviderMs: ERROR!! Unable to get Inf info. Err=0x%x.\r\n"), GetLastError()));

        bRet = FALSE;
        goto IsProviderMs_return;
    } // if(!SetupGetInflnformation()

    //
    // Query "Provider" of given INF.
    //

    if(!SetupQueryInfVersionInformation(pspInfInfo,
                                        0,
                                        PROVIDER,
                                        szProvider,
                                        ARRAYSIZE(szProvider)-1,
                                        &dwSize))
    {
        DebugTrace(TRACE_ERROR,(("IsProviderMs: ERROR!! SetupQueryInfVersionInformation() failed. Err=0x%x.\r\n"), GetLastError()));

        bRet = FALSE;
        goto IsProviderMs_return;
    } // if(!SetupGetInflnformation()

    //
    // See if provider is "Microsoft"
    //
    
    DebugTrace(TRACE_STATUS,(("IsProviderMs: Provider = \'%ws\'.\r\n"), szProvider));
    if(0 == MyStrCmpi(szProvider, MICROSOFT)){
        
        //
        // This INF file has 'Provider = "Microsoft"'
        //

        bRet = TRUE;

    } // if(0 == lstrcmp(szProvider, MICROSOFT))

IsProviderMs_return:
    
    if(NULL != pspInfInfo){
        delete[] pspInfInfo;
    } // if(NULL != pspInfInfo)

    DebugTrace(TRACE_PROC_LEAVE,("IsProviderMs: Leaving... Ret=0x%x\n", bRet));

    return bRet;

} // IsProviderMs()

BOOL
IsIhvAndInboxExisting(
    HDEVINFO            hDevInfo,
    PSP_DEVINFO_DATA    pDevInfoData
    )
{

    BOOL                    bRet;
    BOOL                    bIhvExists;
    BOOL                    bInboxExists;
    DWORD                   dwLastError;
    DWORD                   dwSize;
    DWORD                   Idx;
    SP_DRVINSTALL_PARAMS    spDriverInstallParams;
    SP_DRVINFO_DATA         spDriverInfoData;
    PSP_DRVINFO_DETAIL_DATA pspDriverInfoDetailData;

    //
    // Initialize local.
    //

    bRet                    = FALSE;
    bIhvExists              = FALSE;
    bInboxExists            = FALSE;
    dwSize                  = 0;
    Idx                     = 0;
    dwLastError             = ERROR_SUCCESS;
    pspDriverInfoDetailData = NULL;

    memset(&spDriverInstallParams, 0, sizeof(spDriverInstallParams));

    //
    // Get driver info.
    //

    memset(&spDriverInfoData, 0, sizeof(spDriverInfoData));
    spDriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    for(Idx = 0; SetupDiEnumDriverInfo(hDevInfo, pDevInfoData, SPDIT_COMPATDRIVER, Idx, &spDriverInfoData); Idx++){

        //
        // Get driver install params.
        //

        memset(&spDriverInstallParams, 0, sizeof(spDriverInstallParams));
        spDriverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
        if(!SetupDiGetDriverInstallParams(hDevInfo, pDevInfoData, &spDriverInfoData, &spDriverInstallParams)){
            DebugTrace(TRACE_ERROR,("IsIhvAndInboxExisting: ERROR!! SetupDiGetDriverInstallParams() failed LastError=0x%x.\r\n", GetLastError()));
            goto IsIhvAndInboxExisting_return;
        } // if(!SetupDiGetDriverInstallParams(hDevInfo, pDevInfoData, &spDriverInfoData, &spDriverInstallParams))

        //
        // Get buffer size required for driver derail data.
        //

        dwSize = 0;
        SetupDiGetDriverInfoDetail(hDevInfo,
                                   pDevInfoData,
                                   &spDriverInfoData,
                                   NULL,
                                   0,
                                   &dwSize);
        dwLastError = GetLastError();
        if(ERROR_INSUFFICIENT_BUFFER != dwLastError){
            DebugTrace(TRACE_ERROR,(("IsIhvAndInboxExisting: ERROR!! SetupDiGetDriverInfoDetail() doesn't return required size.Er=0x%x\r\n"),dwLastError));
            goto IsIhvAndInboxExisting_return;
        } // if(ERROR_INSUFFICIENT_BUFFER != dwLastError)
                    
        //
        // Allocate required size of buffer for driver detailed data.
        //

        pspDriverInfoDetailData   = (PSP_DRVINFO_DETAIL_DATA)new char[dwSize];
        if(NULL == pspDriverInfoDetailData){
            DebugTrace(TRACE_ERROR,(("IsIhvAndInboxExisting: ERROR!! Unable to allocate driver detailed info buffer.\r\n")));
            goto IsIhvAndInboxExisting_return;
        } // if(NULL == pspDriverInfoDetailData)

        //
        // Initialize allocated buffer.
        //

        memset(pspDriverInfoDetailData, 0, dwSize);
        pspDriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
                
        //
        // Get detailed data of selected device driver.
        //

        if(!SetupDiGetDriverInfoDetail(hDevInfo,
                                       pDevInfoData,
                                       &spDriverInfoData,
                                       pspDriverInfoDetailData,
                                       dwSize,
                                       NULL) )
        {
            DebugTrace(TRACE_ERROR,("IsIhvAndInboxExisting: ERROR!! SetupDiGetDriverInfoDetail() failed LastError=0x%x.\r\n", GetLastError()));

            delete[] pspDriverInfoDetailData;
            pspDriverInfoDetailData = NULL;
            continue;
        } // if(NULL == pspDriverInfoDetailData)

        //
        // See if INF filename is valid.
        //

        if(NULL == pspDriverInfoDetailData->InfFileName){
            DebugTrace(TRACE_ERROR,("IsIhvAndInboxExisting: ERROR!! SetupDiGetDriverInfoDetail() returned invalid INF name.\r\n"));
            delete[] pspDriverInfoDetailData;
            pspDriverInfoDetailData = NULL;
            continue;
        } // if(NULL == pspDriverInfoDetailData->InfFileName)

        //
        // If it's Inbox driver, lower the lank.
        //

        if( IsWindowsFile(pspDriverInfoDetailData->InfFileName) 
         && IsProviderMs(pspDriverInfoDetailData->InfFileName ) )
        {

            //
            // This is inbox INF.
            //
            
            bInboxExists = TRUE;

        } else { // if(IsWindowsFilw() && IsProviderMs())

            //
            // This is IHV INF.
            //
            
            bIhvExists = TRUE;
        }
        //
        // Clean up.
        //
                    
        delete[] pspDriverInfoDetailData;
        pspDriverInfoDetailData = NULL;

    } // for(Idx = 0; SetupDiEnumDriverInfo(hDevInfo, pDevInfoData, SPDIT_COMPATDRIVER, Idx, &spDriverInfoData), Idx++)
IsIhvAndInboxExisting_return:

    if( (TRUE == bInboxExists)
     && (TRUE == bIhvExists) )
    {
        bRet = TRUE;
    } else { // if(bInboxExists && bIhvExists)
        bRet = FALSE;
    } //  else // if(bInboxExists && bIhvExists)

    DebugTrace(TRACE_PROC_LEAVE,("IsIhvAndInboxExisting: Leaving... Ret=0x%x\n", bRet));
    return bRet;
} // IsProviderMs()

CInstallerMutex::CInstallerMutex(
    HANDLE* phMutex, 
    LPTSTR szMutexName, 
    DWORD dwTimeout
    )
{
    m_bSucceeded    = FALSE;
    m_phMutex       = phMutex;

    _try {
        *m_phMutex = CreateMutex(NULL, FALSE, szMutexName);
        if(NULL != *m_phMutex){

            //
            // Wait until ownership is acquired.
            //

            switch(WaitForSingleObject(*m_phMutex, dwTimeout)){
                case WAIT_ABANDONED:
                    DebugTrace(TRACE_ERROR, ("CInstallerMutex: ERROR!! Wait abandoned.\r\n"));
                    m_bSucceeded = TRUE;
                    break;

                case WAIT_OBJECT_0:
                    DebugTrace(TRACE_STATUS, ("CInstallerMutex: Mutex acquired.\r\n"));
                    m_bSucceeded = TRUE;
                    break;

                case WAIT_TIMEOUT:
                    DebugTrace(TRACE_WARNING, ("CInstallerMutex: WARNING!! Mutex acquisition timeout.\r\n"));
                    break;

                default:
                    DebugTrace(TRACE_ERROR, ("CInstallerMutex: ERROR!! Unexpected error from WaitForSingleObjecct().\r\n"));
                    break;
            } // switch(dwReturn)
        } // if(NULL != *m_phMutex)
    }
    _except (EXCEPTION_EXECUTE_HANDLER) {
         DebugTrace(TRACE_ERROR, ("CInstallerMutex: ERROR!! Unexpected exception.\r\n"));
    }
} // CInstallerMutex::CInstallerMutex()

CInstallerMutex::~CInstallerMutex(
    ) 
{
    if (m_bSucceeded) {
        ReleaseMutex(*m_phMutex);
        DebugTrace(TRACE_STATUS, ("CInstallerMutex: Mutex released.\r\n"));
    }
    if(NULL != *m_phMutex){
        CloseHandle(*m_phMutex);
    } // if(NULL != *m_phMutex)

} // CInstallerMutex::~CInstallerMutex(

HFONT 
GetIntroFont(
    HWND hwnd
    )
{
    static  HFONT   _hfontIntro = NULL;
    static  int     iDevCap = 0;

    if ( !_hfontIntro ){
        TCHAR               szBuffer[64];
        NONCLIENTMETRICS    ncm = { 0 };
        LOGFONT             lf;
        CString             csSize;
        HDC                 hDC = (HDC)NULL;

        hDC = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
        if(NULL != hDC){
        
            iDevCap = GetDeviceCaps(hDC, LOGPIXELSY);
            ncm.cbSize = sizeof(ncm);
            SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

            lf = ncm.lfMessageFont;
            if(0 != LoadString(g_hDllInstance, IDS_TITLEFONTNAME, lf.lfFaceName, (sizeof(lf.lfFaceName)/sizeof(TCHAR)))){
                lf.lfWeight = FW_BOLD;
                
                if(0 != LoadString(g_hDllInstance, IDS_TITLEFONTSIZE, szBuffer, (sizeof(szBuffer)/sizeof(TCHAR)))){
                    csSize = szBuffer;
                    lf.lfHeight = 0 - (iDevCap * (DWORD)csSize.Decode() / 72);

                    _hfontIntro = CreateFontIndirect(&lf);
                } // if(0 != LoadString(g_hDllInstance, IDS_TITLEFONTSIZE, szBuffer, (sizeof(szBuffer)/sizeof(TCHAR))))
            } // if(0 != LoadString(g_hDllInstance, IDS_TITLEFONTNAME, lf.lfFaceName, (sizeof(lf.lfFaceName)/sizeof(TCHAR))))
            
            DeleteDC(hDC);

        } else { // if(NULL != hDC)
            DebugTrace(TRACE_ERROR, ("GetIntroFont: ERROR!! Unable to create DC.Err=0x%x.\r\n",GetLastError()));
        } // else(NULL != hDC)
    }
    return _hfontIntro;
} // GetIntroFont()

BOOL
IsDeviceRootEnumerated(
    IN  HDEVINFO                        hDevInfo,
    IN  PSP_DEVINFO_DATA                pDevInfoData
    )
{
    CONFIGRET   cmRetCode;
    BOOL        bRet;
    ULONG       ulStatus;
    ULONG       ulProblem;
    

    DebugTrace(TRACE_PROC_ENTER,("IsDeviceRootEnumerated: Enter... \r\n"));

    //
    // Initialize local.
    //

    cmRetCode   = CR_SUCCESS;
    bRet        = FALSE;
    ulStatus    = 0;
    ulProblem   = 0;


    //
    // Devnode Status.
    //
    
    cmRetCode = CM_Get_DevNode_Status(&ulStatus,
                                      &ulProblem,
                                      pDevInfoData->DevInst,
                                      0);

    if(CR_SUCCESS != cmRetCode){
        
        //
        // Unable to get devnode status.
        //

        DebugTrace(TRACE_ERROR,("IsDeviceRootEnumerated: ERROR!! Unable to get Devnode status. CR=0x%x.\r\n", cmRetCode));

        bRet = FALSE;
        goto IsDeviceRootEnumerated_return;

    } // if(CD_SUCCESS != cmRetCode)

    //
    // See if it's root-enumerated.
    //

    if(DN_ROOT_ENUMERATED & ulStatus){
        
        //
        // This devnode is root-enumerated.
        //

        bRet = TRUE;

    } // if(DN_ROOT_ENUMERATED & ulStatus)

IsDeviceRootEnumerated_return:
    
    DebugTrace(TRACE_PROC_LEAVE,("IsDeviceRootEnumerated: Leaving... Ret=0x%x.\r\n", bRet));
    return bRet;

} // IsDeviceRootEnumerated()


int
MyStrCmpi(
    LPCTSTR str1,
    LPCTSTR str2
    )
{
    int iRet;
    
    //
    // Initialize local.
    //
    
    iRet = 0;
    
    //
    // Compare string.
    //
    
    if(CSTR_EQUAL == CompareString(LOCALE_INVARIANT,
                                   NORM_IGNORECASE, 
                                   str1, 
                                   -1,
                                   str2,
                                   -1) )
    {
        iRet = 0;
    } else {
        iRet = -1;
    }

    return iRet;
} // MyStrCmpi()

VOID
LogSystemEvent(
    WORD    wEventType,
    DWORD   dwEventID,
    WORD    wNumberOfString,
    LPTSTR  szMsg[]
    )
{
    HANDLE  hSystemEvent;

    DebugTrace(TRACE_PROC_ENTER,("LogSystemEvent: Enter...\r\n"));

    //
    // Initialize local.
    //
 
    hSystemEvent    = NULL;

    //
    // Get handle to System event log.
    //
 
    hSystemEvent = RegisterEventSource(NULL, STILLIMAGE);
    if(NULL == hSystemEvent){
        
        //
        // Unable to open System log.
        //

        DebugTrace(TRACE_ERROR,("LogSystemEvent: ERROR!! Unable to get handle to system log. Err=0x%x.\r\n", GetLastError()));
        goto LogSystemEvent_return;
    } // if (NULL == hSystemEvent)

    if(!ReportEvent(hSystemEvent,
                    wEventType,
                    0,
                    dwEventID,
                    NULL,
                    wNumberOfString,
                    0,
                    (LPCTSTR *)szMsg,
                    (LPVOID)NULL) )
    {
        DebugTrace(TRACE_ERROR,("LogSystemEvent: ERROR!! Unable to log to system log. Err=0x%x.\r\n", GetLastError()));
        goto LogSystemEvent_return;
    }
 
LogSystemEvent_return:
    
    if(IS_VALID_HANDLE(hSystemEvent)){
        DeregisterEventSource(hSystemEvent);
        hSystemEvent = NULL;
    } // if(IS_VALID_HANDLE())
    
    DebugTrace(TRACE_PROC_LEAVE,("LogSystemEvent: Leaving... Ret=VOID.\r\n"));
    return;
} // LogSystemEvent()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\win9xupg\makefile.inc ===
all: $(O)\msg.h $(O)\msg.rc $(O)\msg00001.bin $(O)\msg.mc

$(O)\msg.mc: $(BASE_INC_PATH)\vendinfo.mc
        copy $(BASE_INC_PATH)\vendinfo.mc $(O)\msg.mc

$(O)\msg.h $(O)\msg00001.bin $(O)\msg.rc:$(O)\msg.mc
        mc -A -v $(O)\msg.mc -h .\$(O) -r .\$(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\win9xupg\local.h ===
/*++

Copyright (c) 2000  Microsoft Corporation
All rights reserved.

Module Name:

    local.h

Abstract:

    Local header file for migration DLL of WIA class.

Author:

    Keisuke Tsuchida (KeisukeT)  10-Oct-2000

Revision History:

--*/

#ifndef LOCAL_H
#define LOCAL_H


//
// Define
//

#define MAX_FRIENDLYNAME        64
#define MAX_LINELENGTH          2048

#define NAME_WIN9X_SETTING_FILE_A   "sti9x.txt"
#define NAME_WIN9X_SETTING_FILE_W   L"sti9x.txt"
#define NAME_MIGRATE_INF_A          "migrate.inf"
#define NAME_MIGRATE_INF_W          L"migrate.inf"
#define NAME_STILLIMAGE_A           "StillImage"
#define NAME_STILLIMAGE_W           L"StillImage"
#define NAME_FRIENDLYNAME_A         "FriendlyName"
#define NAME_FRIENDLYNAME_W         L"FriendlyName"
#define NAME_CREATEFILENAME_A       "CreateFileName"
#define NAME_CREATEFILENAME_W       L"CreateFileName"
#define NAME_INF_PATH_A             "InfPath"
#define NAME_INF_PATH_W             L"InfPath"
#define NAME_INF_SECTION_A          "InfSection"
#define NAME_INF_SECTION_W          L"InfSection"
#define NAME_INSTALLER_A            "sti_ci.dll"
#define NAME_INSTALLER_W            L"sti_ci.dll"
#define NAME_PROC_MIGRATEDEVICE_A   "MigrateDevice"
#define NAME_PROC_MIGRATEDEVICE_W   L"MigrateDevice"
#define NAME_DEVICE_A               "Device"
#define NAME_DEVICE_W               L"Device"
#define NAME_BEGIN_A                "BEGIN"
#define NAME_BEGIN_W                L"BEGIN"
#define NAME_END_A                  "END"
#define NAME_END_W                  L"END"



#define REGKEY_DEVICEDATA_A         "DeviceData"
#define REGKEY_DEVICEDATA_W         L"DeviceData"
#define REGVAL_SUBCLASS_A           "SubClass"
#define REGVAL_SUBCLASS_W           L"SubClass"
#define REGVAL_USDCLASS_A           "USDClass"
#define REGVAL_USDCLASS_W           L"USDClass"
#define REGVAL_NTMPDRIVER_A         "NTMPDriver"
#define REGVAL_NTMPDRIVER_W         L"NTMPDriver"

// Kodak related.

#define FILEVER_KODAKIMAGING_WIN98_MS   0x4000a
#define FILEVER_KODAKIMAGING_WIN98_LS   0x7ce
#define PRODVER_KODAKIMAGING_WIN98_MS   0x10000
#define PRODVER_KODAKIMAGING_WIN98_LS   0x51f

#define FILEVER_KODAKIMAGING_WINME_MS   0x4005a
#define FILEVER_KODAKIMAGING_WINME_LS   0xbb8
#define PRODVER_KODAKIMAGING_WINME_MS   0x10000
#define PRODVER_KODAKIMAGING_WINME_LS   0x520


#define NAME_KODAKIMAGING_A         "kodakimg.exe"
#define NAME_KODAKIMAGING_W         L"kodakimg.exe"
#define REGSTR_PATH_KODAKEVENT_A    "System\\CurrentControlSet\\Control\\StillImage\\Events\\STIProxyEvent\\{5F89FC93-A94E-4C0B-A1F2-DB6E97AA0B38}"
#define REGSTR_PATH_KODAKEVENT_W    L"System\\CurrentControlSet\\Control\\StillImage\\Events\\STIProxyEvent\\{5F89FC93-A94E-4C0B-A1F2-DB6E97AA0B38}"
#define REGSTR_KEY_KODAKGUID_A      "{5F89FC93-A94E-4C0B-A1F2-DB6E97AA0B38}"
#define REGSTR_KEY_KODAKGUID_W      L"{5F89FC93-A94E-4C0B-A1F2-DB6E97AA0B38}"


#ifdef UNICODE
 #define NAME_KODAKIMAGING          NAME_KODAKIMAGING_W
 #define REGSTR_PATH_KODAKEVENT     REGSTR_PATH_KODAKEVENT_W
 #define REGSTR_KEY_KODAKGUID       REGSTR_KEY_KODAKGUID_W
#else   // #ifdef UNICODE
 #define NAME_KODAKIMAGING          NAME_KODAKIMAGING_A
 #define REGSTR_PATH_KODAKEVENT     REGSTR_PATH_KODAKEVENT_A
 #define REGSTR_KEY_KODAKGUID       REGSTR_KEY_KODAKGUID_A
#endif  // #ifdef UNICODE


//
// Typedef
//

typedef struct  _PARAM_LIST {
    PVOID           pNext;
    LPSTR           pParam1;
    LPSTR           pParam2;
} PARAM_LIST, *PPARAM_LIST;

typedef struct  _DEVICE_INFO {

    LPSTR           pszFriendlyName;
    LPSTR           pszCreateFileName;
    LPSTR           pszInfPath;
    LPSTR           pszInfSection;

    DWORD           dwNumberOfDeviceDataKey;
    PPARAM_LIST     pDeviceDataParam;
} DEVICE_INFO, *PDEVICE_INFO;


//
// Extern
//

extern HINSTANCE    g_hInst;

//
// Proto-type
//

//
// Migrate function
//


LONG
CALLBACK
Mig9xGetGlobalInfo(
    IN      HANDLE      hFile
    );


LONG
CALLBACK
Mig9xGetDeviceInfo(
    IN      HANDLE      hFile
    );

//
// Debug functions
//
VOID
DebugMsg(
    LPCSTR  pszFormat,
    ...
    );

//
// Heap management
//

PVOID
AllocMem(
    IN UINT cbSize
    );

VOID
FreeMem(
    IN PVOID pMem
    );

LPSTR
AllocStrA(
    IN LPCSTR  pszStr
    );

LPWSTR
AllocStrW(
    IN LPCWSTR  pszStr
    );

LPWSTR
AllocStrWFromStrA(
    LPCSTR  pszStr
    );

LPSTR
AllocStrAFromStrW(
    LPCWSTR     pszStr
    );

VOID
FreePrinterInfo2Strings(
    PPRINTER_INFO_2A   pPrinterInfo2
    );

//
// Functions to write print config to the text file
//
BOOL
WriteToFile(
    HANDLE  hFile,
    LPCSTR  pszFormat,
    ...
    );

VOID
WriteString(
    IN      HANDLE  hFile,
    IN OUT  LPBOOL  pbFail,
    IN      LPCSTR  pszStr
    );

//
// Functions to parse the text file having printing config info
//
LPSTR
GetLine(
    IN      HANDLE  hFile,
    IN  OUT LPBOOL  pbFail
    );

VOID
ReadString(
    IN      HANDLE  hFile,
    OUT     LPSTR  *ppszParam1,
    OUT     LPSTR  *ppszParam2
    );

VOID
ReadDword(
    IN      HANDLE  hFile,
    IN      LPSTR   pszLine,
    IN      DWORD   dwLineSize,
    IN      LPSTR   pszPrefix,
    OUT     LPDWORD pdwValue,
    IN  OUT LPBOOL  pbFail
    );


//
// Misc stuff
//

LPSTR
ErrorMsg(
    VOID
    );

VOID
LogError(
    IN  LogSeverity Severity,
    IN  UINT        MessageId,
    ...
    );

LPSTR
GetStringFromRcFileA(
    IN  UINT    uId
    );

VOID
SetupNetworkPrinterUpgrade(
    IN  LPCSTR pszWorkingDir
    );

BOOL
ProcessNetPrnUpgradeForUser(
    HKEY    hKeyUser
    );

DWORD
MySetDefaultPrinter(
    IN  HKEY    hUserRegKey,
    IN  LPSTR   pszDefaultPrinterString
    );

VOID
WriteRunOnceCount(
    );

LPSTR
GetDefPrnString(
    IN  LPCSTR  pszPrinterName
    );

CHAR
My_fgetc(
    HANDLE  hFile
    );

LPSTR
My_fgets(
    LPSTR   pszBuf,
    DWORD   dwSize,
    HANDLE  hFile
    );

DWORD
My_fread(
    LPBYTE      pBuf,
    DWORD       dwSize,
    HANDLE      hFile
    );

BOOL
My_ungetc(
    HANDLE  hFile
    );

int
MyStrCmpiA(
    LPCSTR str1,
    LPCSTR str2
    );


LONG
WriteRegistryToFile(
    IN  HANDLE  hFile,
    IN  HKEY    hKey,
    IN  LPCSTR  pszPath
    );

LONG
WriteRegistryValueToFile(
    HANDLE  hFile,
    LPSTR   pszValue,
    DWORD   dwType,
    PCHAR   pDataBuffer,
    DWORD   dwSize
    );

LONG
GetRegData(
    HKEY    hKey,
    LPSTR   pszValue,
    PCHAR   *ppDataBuffer,
    PDWORD  pdwType,
    PDWORD  pdwSize
    );

BOOL
IsSti(
    HKEY    hKeyDevice
    );

BOOL
IsKernelDriverRequired(
    HKEY    hKeyDevice
    );

LONG
WriteDeviceToFile(
    HANDLE  hFile,
    HKEY    hKey
    );

LONG
MigNtProcessMigrationInfo(
    HANDLE  hFile
    );

LONG
MigNtGetDevice(
    HANDLE          hFile,
    PDEVICE_INFO    pMigrateDevice
    );


VOID
MigNtFreeDeviceInfo(
    PDEVICE_INFO    pMigrateDevice
    );

VOID
MyLogError(
    LPCSTR  pszFormat,
    ...
    );

BOOL
MigNtIsWin9xImagingExisting(
    VOID
    );

VOID
MigNtRemoveKodakImagingKey(
    VOID
    );

#endif  // LOCAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\win9xupg\precomp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file

Author:

    Muhunthan Sivapragasam (MuhuntS)  17-Oct-1995

Revision History:

--*/

#include <windows.h>
#include <winspool.h>
#include <stdio.h>
#include <objbase.h>
#include <shellapi.h>
#include <setupapi.h>
#include <initguid.h>
#include <cfgmgr32.h>
#include "splsetup.h"
#include "local.h"
#include "resource.h"
#include <plugin.h>
#include <stiregi.h>
#include <tchar.h>

#define STRSAFE_NO_DEPRECATE

#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\win9xupg\migmain.c ===
/*++

Copyright (c) 2000 Microsoft Corporation
All rights reserved.

Module Name:

    Migmain.c

Abstract:

    Routines to migrate Win95 to NT

Author:

    Keisuke Tsuchida (KeisukeT) 10-Oct-2000

Revision History:

--*/


#include    "precomp.h"
#pragma     hdrstop
#include    <devguid.h>
#include    "msg.h"

//
// Global
//

HINSTANCE   g_hInst = (HINSTANCE)NULL;

BOOL
DllEntryPoint(
    IN HINSTANCE    hInst,
    IN DWORD        dwReason,
    IN LPVOID       lpRes
    )

/*++

Routine Description:
    Dll entry point.

Arguments:

Return Value:

--*/
{
    UNREFERENCED_PARAMETER(lpRes);

    switch( dwReason ){

        case DLL_PROCESS_ATTACH:
            g_hInst = hInst;
            SetupOpenLog(FALSE);
            break;

        case DLL_PROCESS_DETACH:
            g_hInst = (HINSTANCE)NULL;
            SetupCloseLog();
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


LONG
QueryVersion(
    OUT     LPCSTR         *pszProductID,
    OUT     LPUINT          plDllVersion,
    OUT     LPINT          *pCodePageArray    OPTIONAL,
    OUT     LPCSTR         *ExeNamesBuf       OPTIONAL,
    OUT     PVENDORINFO    *pVendorInfo
    )
{
    BOOL            bFail = TRUE;
    LPSTR           pszLocalProductID;
    VENDORINFO      VendorInfo;
    DWORD           dwRet, dwNeeded, dwReturned, dwLangId;


    if ( !(pszLocalProductID = GetStringFromRcFileA(IDS_PRODUCTID)) )
        goto Done;

    ZeroMemory(&VendorInfo, sizeof(VendorInfo));
    dwLangId = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT);

    FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   (LPVOID)g_hInst,
                   MSG_VI_COMPANY_NAME,
                   dwLangId,
                   VendorInfo.CompanyName,
                   sizeof(VendorInfo.CompanyName),
                   0);

    FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   (LPVOID)g_hInst,
                   MSG_VI_SUPPORT_NUMBER,
                   dwLangId,
                   VendorInfo.SupportNumber,
                   sizeof(VendorInfo.SupportNumber),
                   0);

    FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   (LPVOID)g_hInst,
                   MSG_VI_SUPPORT_URL,
                   dwLangId,
                   VendorInfo.SupportUrl,
                   sizeof(VendorInfo.SupportUrl),
                   0);

    FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   (LPVOID)g_hInst,
                   MSG_VI_INSTRUCTIONS,
                   dwLangId,
                   VendorInfo.InstructionsToUser,
                   sizeof(VendorInfo.InstructionsToUser),
                   0);


    *pszProductID   = pszLocalProductID;
    *plDllVersion   = 1;
    *pCodePageArray = NULL;
    *ExeNamesBuf    = NULL;
    *pVendorInfo    = &VendorInfo;

/********
    //
    // Call this DLL only if there are some printers or printer drivers
    // installed
    //
    if ( EnumPrinterDriversA(NULL,
                             NULL,
                             3,
                             NULL,
                             0,
                             &dwNeeded,
                             &dwReturned)   &&
          EnumPrintersA(PRINTER_ENUM_LOCAL,
                        NULL,
                        2,
                        NULL,
                        0,
                        &dwNeeded,
                        &dwReturned) ) {

        return ERROR_NOT_INSTALLED;
    }
********/

    bFail = FALSE;

Done:
    if ( bFail ) {

        if ( dwRet = GetLastError() )
            return dwRet;

        return STG_E_UNKNOWN;
    }

    return ERROR_SUCCESS;
}


P_QUERY_VERSION     pQueryVersion   = QueryVersion;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\win9xupg\nt.c ===
/*++

Copyright (c) 2000 Microsoft Corporation
All rights reserved.

Module Name:

    Nt.c

Abstract:

    Routines to migrate Win95 printing components to NT

Author:

    Keisuke Tsuchida (KeisukeT) 10-Oct-2000

Revision History:

--*/


#include "precomp.h"

//
// Extern
//

extern LPCSTR  g_WorkingDirectory;
extern LPCSTR  g_SourceDirectory;
extern LPCSTR  g_MediaDirectory;

//
// Typedef
//

typedef BOOL (WINAPI *PMIGRATEDEVICE)(PDEVICE_INFO);
typedef DWORD (WINAPI *PSHDELETEKEY)(HKEY, LPCSTR);


LONG
CALLBACK
InitializeNT(
    IN  LPCWSTR pszWorkingDir,
    IN  LPCWSTR pszSourceDir,
    IN  LPCWSTR pszMediaDir
    )
{
    LONG    lError;

    //
    // Initialize local.
    //
    
    lError = ERROR_SUCCESS;

    //
    // Save given parameters.
    //
    
    g_WorkingDirectory   = AllocStrAFromStrW(pszWorkingDir);
    g_SourceDirectory    = AllocStrAFromStrW(pszSourceDir);
    g_MediaDirectory     = AllocStrAFromStrW(pszMediaDir);

    if(NULL == g_WorkingDirectory){
        SetupLogError("WIA Migration: InitializeNT: ERROR!! insufficient memory.\r\n", LogSevError);
        
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto InitializeNT_return;
    }

InitializeNT_return:

    if(ERROR_SUCCESS != lError){
        
        //
        // Can't process migration. Clean up.
        //
        
        if(NULL != g_WorkingDirectory){
            FreeMem((PVOID)g_WorkingDirectory);
            g_WorkingDirectory = NULL;
        }

        if(NULL != g_SourceDirectory){
            FreeMem((PVOID)g_SourceDirectory);
            g_SourceDirectory = NULL;
        }

        if(NULL != g_MediaDirectory){
            FreeMem((PVOID)g_MediaDirectory);
            g_MediaDirectory = NULL;
        }
    } // if(ERROR_SUCCESS != lError)

    return lError;
}


LONG
CALLBACK
MigrateUserNT(
    IN  HINF        hUnattendInf,
    IN  HKEY        hUserRegKey,
    IN  LPCWSTR     pszUserName,
        LPVOID      Reserved
    )
{
    return  ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateSystemNT(
    IN  HINF    hUnattendInf,
        LPVOID  Reserved
    )
{
    LONG    lError;
    HANDLE  hFile;
    CHAR    szFile[MAX_PATH];

    //
    // Initialize local.
    //

    lError  = ERROR_SUCCESS;
    hFile   = (HANDLE)INVALID_HANDLE_VALUE;

    //
    // Check global initialization.
    //

    if(NULL == g_WorkingDirectory){
        lError = ERROR_NOT_ENOUGH_MEMORY;
        MyLogError("WIA Migration: MigrateSystemNT: ERROR!! Initialize failed. Err=0x%x\n", lError);

        goto MigrateSystemNT_return;
    } // if(NULL == g_WorkingDirectory)

    //
    // Create path to the files.
    //

//    wsprintfA(szFile, "%s\\%s", g_WorkingDirectory, NAME_WIN9X_SETTING_FILE_A);
    _snprintf(szFile, sizeof(szFile), "%s\\%s", g_WorkingDirectory, NAME_WIN9X_SETTING_FILE_A);

    //
    // Make sure the string is NULL terminated.
    //

    szFile[sizeof(szFile)/sizeof(szFile[0]) -1] = '\0';

    //
    // Open migration file.
    //

    hFile = CreateFileA(szFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL |
                        FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE){
        lError = GetLastError();
        MyLogError("WIA Migration: MigrateSystemNT: ERROR!! Unable to open migration file. Err=0x%x\n", lError);

        goto MigrateSystemNT_return;
    } // if (hFile == INVALID_HANDLE_VALUE)

    //
    // Process migration info file created on Win9x.
    //

    lError = MigNtProcessMigrationInfo(hFile);

    //
    // Remove certain reg if inbox Kodak Imaging for Win9x is installed.
    //

    if(MigNtIsWin9xImagingExisting()){
        MigNtRemoveKodakImagingKey();
    } // if(MigNtIsWin9xImagingExisting())

MigrateSystemNT_return:

    //
    // Clean up.
    //

    if(INVALID_HANDLE_VALUE == hFile){
        CloseHandle(hFile);
    }

    return lError;
} // MigrateSystemNT()


LONG
MigNtProcessMigrationInfo(
    HANDLE  hFile
    )
{
    LONG            lError;
    DEVICE_INFO     MigrateDevice;
    HMODULE         hInstaller;
    PMIGRATEDEVICE  pfnMigrateDevice;


    //
    // Initialize local.
    //

    lError              = ERROR_SUCCESS;
    hInstaller          = (HMODULE)NULL;
    pfnMigrateDevice    = NULL;

    memset(&MigrateDevice, 0, sizeof(MigrateDevice));

    //
    // Load STI_CI.DLL.
    //

    hInstaller = LoadLibrary(NAME_INSTALLER_A);
    if(NULL == hInstaller){
        
        //
        // Unable to load sti_ci.dll.
        //

        lError = GetLastError();
        MyLogError("WIA Migration: MigNtProcessMigrationInfo: ERROR!! Unable to load sti_ci.dll. Err=0x%x\n", lError);

        goto MigNtProcessMigrationInfo_return;

    } // if(NULL == hInstaller)

    //
    // Get address of MigrateDevice()
    //

    pfnMigrateDevice = (PMIGRATEDEVICE)GetProcAddress(hInstaller, NAME_PROC_MIGRATEDEVICE_A);
    if(NULL == pfnMigrateDevice){
        
        //
        // Unable to get proc address.
        //

        lError = GetLastError();
        MyLogError("WIA Migration: MigNtProcessMigrationInfo: ERROR!! Unable to get proc address. Err=0x%x\n", lError);

        goto MigNtProcessMigrationInfo_return;

    } // if(NULL == pfnMigrateDevice)

    //
    // Query migrating device.
    //

    while(ERROR_SUCCESS == MigNtGetDevice(hFile, &MigrateDevice)){

        //
        // Install only COM/LPT device.
        //

        if( (NULL != strstr(MigrateDevice.pszCreateFileName, "COM"))
         || (NULL != strstr(MigrateDevice.pszCreateFileName, "LPT"))
         || (NULL != strstr(MigrateDevice.pszCreateFileName, "AUTO")) )
        {
            pfnMigrateDevice(&MigrateDevice);
        }

/***********
{
PPARAM_LIST pTemp;

printf("\"%s\" = \"%s\"\r\n", NAME_FRIENDLYNAME_A, MigrateDevice.pszFriendlyName);
printf("\"%s\" = \"%s\"\r\n", NAME_CREATEFILENAME_A, MigrateDevice.pszCreateFileName);
printf("\"%s\" = \"%s\"\r\n", NAME_INF_PATH_A, MigrateDevice.pszInfPath);
printf("\"%s\" = \"%s\"\r\n", NAME_INF_SECTION_A, MigrateDevice.pszInfSection);
    
for(pTemp = MigrateDevice.pDeviceDataParam; pTemp != NULL;){
    printf("\"%s\" = \"%s\"\r\n", pTemp->pParam1, pTemp->pParam2);
    pTemp = (PPARAM_LIST)pTemp->pNext;
} // for(pTemp = MigrateDevice.pDeviceDataParam; pTemp != NULL;)

printf("\r\n");

}
***********/

        //
        // Clean up.
        //

      MigNtFreeDeviceInfo(&MigrateDevice);

    } // while(ERROR_SUCCESS == MigNtGetDevice(hFile, &MigrateDevice))


MigNtProcessMigrationInfo_return:

    //
    // Clean up.
    //
    
    if(NULL != hInstaller){
        FreeLibrary(hInstaller);
    }
    
    return lError;
} // MigNtProcessMigrationInfo()


LONG
MigNtGetDevice(
    HANDLE          hFile,
    PDEVICE_INFO    pMigrateDevice
    )
{
    LONG        lError;
    LPSTR       pParam1;
    LPSTR       pParam2;
    BOOL        bFound;
    LPSTR       pszFriendlyName;
    LPSTR       pszCreateFileName;
    LPSTR       pszInfPath;
    LPSTR       pszInfSection;
    DWORD       dwNumberOfDeviceDataKey;
    PPARAM_LIST pDeviceDataParam;
    PPARAM_LIST pTempParam;
    //
    // Initialize local.
    //

    lError                  = ERROR_SUCCESS;
    pParam1                 = NULL;
    pParam2                 = NULL;
    bFound                  = FALSE;
    
    pszFriendlyName         = NULL;
    pszCreateFileName       = NULL;
    pszInfPath              = NULL;
    pszInfSection           = NULL;
    pDeviceDataParam        = NULL;
    pTempParam              = NULL;
    dwNumberOfDeviceDataKey = 0;

    //
    // Find "Device = BEGIN"
    //
    
    while(FALSE == bFound){
        
        ReadString(hFile, &pParam1, &pParam2);
        if( (NULL != pParam1) && (NULL != pParam2) ){
            
            //
            // Both parameter exist.
            //
            
            if( (0 == MyStrCmpiA(pParam1, NAME_DEVICE_A))
             && (0 == MyStrCmpiA(pParam2, NAME_BEGIN_A)) )
            {
                
                //
                // Found begining of device description.
                //

                bFound = TRUE;
            }
        } else { // if( (NULL != pParam1) && (NULL != pParam2) )
            if( (NULL == pParam1) && (NULL == pParam2) ){

                //
                // Error or EOF.
                //

                lError = ERROR_NO_MORE_ITEMS;
                goto MigNtGetDevice_return;
            } else {

                //
                // A line with single parameter. Just ignore.
                //
                
            }
        }

        //
        // Free allocated memory.
        //

        if(NULL != pParam1){
            FreeMem(pParam1);
            pParam1 = NULL;
        }

        if(NULL != pParam2){
            FreeMem(pParam2);
            pParam2 = NULL;
        }
    } // while(FALSE == bFound)

    //
    // Get FriendlyName
    //

    ReadString(hFile, &pParam1, &pParam2);
    if( (NULL == pParam1) || (NULL == pParam2) ){
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto MigNtGetDevice_return;
    } // if( (NULL == pParam1) || (NULL == pParam2) )
    if(0 != MyStrCmpiA(pParam1, NAME_FRIENDLYNAME_A)){
        
        //
        // Invalid migration file.
        //
        
        lError = ERROR_INVALID_PARAMETER;
        goto MigNtGetDevice_return;
    } //if(0 != MyStrCmpiA(pParam1, NAME_FRIENDLYNAME_A))

    //
    // Copy to allocated buffer.
    //

    pszFriendlyName = AllocStrA(pParam2);

    //
    // Free allocated memory.
    //

    if(NULL != pParam1){
        FreeMem(pParam1);
        pParam1 = NULL;
    }

    if(NULL != pParam2){
        FreeMem(pParam2);
        pParam2 = NULL;
    }

    //
    // Get CreateFileName
    //

    ReadString(hFile, &pParam1, &pParam2);
    if( (NULL == pParam1) || (NULL == pParam2) ){
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto MigNtGetDevice_return;
    } // if( (NULL == pParam1) || (NULL == pParam2) )
    if(0 != MyStrCmpiA(pParam1, NAME_CREATEFILENAME_A)){
        
        //
        // Invalid migration file.
        //
        
        lError = ERROR_INVALID_PARAMETER;
        goto MigNtGetDevice_return;
    } //if(0 != MyStrCmpiA(pParam1, NAME_CREATEFILENAME_A))

    //
    // Copy to allocated buffer.
    //

    pszCreateFileName = AllocStrA(pParam2);

    //
    // Free allocated memory.
    //

    if(NULL != pParam1){
        FreeMem(pParam1);
        pParam1 = NULL;
    }

    if(NULL != pParam2){
        FreeMem(pParam2);
        pParam2 = NULL;
    }

    //
    // Get InfPath
    //

    ReadString(hFile, &pParam1, &pParam2);
    if( (NULL == pParam1) || (NULL == pParam2) ){
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto MigNtGetDevice_return;
    } // if( (NULL == pParam1) || (NULL == pParam2) )
    if(0 != MyStrCmpiA(pParam1, NAME_INF_PATH_A)){
        
        //
        // Invalid migration file.
        //
        
        lError = ERROR_INVALID_PARAMETER;
        goto MigNtGetDevice_return;
    } //if(0 != MyStrCmpiA(pParam1, NAME_INF_PATH_A))

    //
    // Copy to allocated buffer.
    //

    pszInfPath = AllocStrA(pParam2);

    //
    // Free allocated memory.
    //

    if(NULL != pParam1){
        FreeMem(pParam1);
        pParam1 = NULL;
    }

    if(NULL != pParam2){
        FreeMem(pParam2);
        pParam2 = NULL;
    }

    //
    // Get InfSection
    //

    ReadString(hFile, &pParam1, &pParam2);
    if( (NULL == pParam1) || (NULL == pParam2) ){
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto MigNtGetDevice_return;
    } // if( (NULL == pParam1) || (NULL == pParam2) )
    if(0 != MyStrCmpiA(pParam1, NAME_INF_SECTION_A)){
        
        //
        // Invalid migration file.
        //
        
        lError = ERROR_INVALID_PARAMETER;
        goto MigNtGetDevice_return;
    } //if(0 != MyStrCmpiA(pParam1, NAME_INF_SECTION_A))

    //
    // Copy to allocated buffer.
    //

    pszInfSection = AllocStrA(pParam2);

    //
    // Free allocated memory.
    //

    if(NULL != pParam1){
        FreeMem(pParam1);
        pParam1 = NULL;
    }

    if(NULL != pParam2){
        FreeMem(pParam2);
        pParam2 = NULL;
    }

    //
    // Get DeviceData section.
    //

    bFound = FALSE;
    while(FALSE == bFound){
        ReadString(hFile, &pParam1, &pParam2);
        if( (NULL == pParam1) || (NULL == pParam2) ){
            lError = ERROR_NOT_ENOUGH_MEMORY;
            goto MigNtGetDevice_return;
        } // if( (NULL == pParam1) || (NULL == pParam2) )
        
        if(0 == MyStrCmpiA(pParam1, REGKEY_DEVICEDATA_A)){
            //
            // Found beginning of DeviceData section.
            //

            bFound = TRUE;
        
        } // if(0 == MyStrCmpiA(pParam1, REGKEY_DEVICEDATA_A))
        

        //
        // Free allocated memory.
        //

        if(NULL != pParam1){
            FreeMem(pParam1);
            pParam1 = NULL;
        }

        if(NULL != pParam2){
            FreeMem(pParam2);
            pParam2 = NULL;
        }
        
    } // while(FALSE == bFound)

    //
    // Process until DeviceData = END is found.
    //

    bFound = FALSE;
    while(FALSE == bFound){
        ReadString(hFile, &pParam1, &pParam2);
        if( (NULL == pParam1) || (NULL == pParam2) ){
            lError = ERROR_NOT_ENOUGH_MEMORY;
            goto MigNtGetDevice_return;
        } // if( (NULL == pParam1) || (NULL == pParam2) )
        
        if( (0 == MyStrCmpiA(pParam1, REGKEY_DEVICEDATA_A))
         && (0 == MyStrCmpiA(pParam2, NAME_END_A)) )
        {
            //
            // Found beginning of DeviceData section.
            //

            bFound = TRUE;

            //
            // Free allocated memory.
            //

            if(NULL != pParam1){
                FreeMem(pParam1);
                pParam1 = NULL;
            }

            if(NULL != pParam2){
                FreeMem(pParam2);
                pParam2 = NULL;
            }
            break;
        } // if(0 == MyStrCmpiA(pParam1, REGKEY_DEVICEDATA_A))

        //
        // Increment counter.
        //

        dwNumberOfDeviceDataKey++;

        //
        // Allocate new structure for parameters.
        //
        
        pTempParam  = (PPARAM_LIST)AllocMem(sizeof(PARAM_LIST));
        if(NULL == pTempParam){
            lError = ERROR_NOT_ENOUGH_MEMORY;
            goto MigNtGetDevice_return;
        } // if(NULL == pTempParam)

        //
        // Set parameters.
        //

        pTempParam->pNext   = NULL;
        pTempParam->pParam1 = AllocStrA(pParam1);
        pTempParam->pParam2 = AllocStrA(pParam2);

        //
        // Add this parameter to list.
        //
        
        if(NULL == pDeviceDataParam){
            pDeviceDataParam = pTempParam;
        } else { // if(NULL == pDeviceDataParam)
            PPARAM_LIST pTemp;
            
            //
            // Find the last data, and add.
            //
            
            for(pTemp = pDeviceDataParam; NULL !=pTemp->pNext; pTemp=(PPARAM_LIST)pTemp->pNext);
            pTemp->pNext = (PVOID)pTempParam;

        } // else(NULL == pDeviceDataParam)

        //
        // Free allocated memory.
        //

        if(NULL != pParam1){
            FreeMem(pParam1);
            pParam1 = NULL;
        }

        if(NULL != pParam2){
            FreeMem(pParam2);
            pParam2 = NULL;
        }
        
    } // while(FALSE == bFound)

    //
    // Copy all data.
    //

    pMigrateDevice->pszFriendlyName         = pszFriendlyName;
    pMigrateDevice->pszCreateFileName       = pszCreateFileName;
    pMigrateDevice->pszInfPath              = pszInfPath;
    pMigrateDevice->pszInfSection           = pszInfSection;
    pMigrateDevice->dwNumberOfDeviceDataKey = dwNumberOfDeviceDataKey;
    pMigrateDevice->pDeviceDataParam        = pDeviceDataParam;

    //
    // Operation succeeded.
    //

    lError = ERROR_SUCCESS;

MigNtGetDevice_return:

    //
    // Clean up.
    //

    if(ERROR_SUCCESS != lError){
        PPARAM_LIST pTemp;
        
        //
        // Free all allocated parameters.
        //

        if(NULL != pszFriendlyName){
            FreeMem(pszFriendlyName);
        }
        if(NULL != pszCreateFileName){
            FreeMem(pszCreateFileName);
        }
        if(NULL != pszInfPath){
            FreeMem(pszInfPath);
        }
        if(NULL != pszInfSection){
            FreeMem(pszInfSection);
        }
        if(NULL != pDeviceDataParam){
            pTemp = pDeviceDataParam;
            while(NULL != pTemp){
                pDeviceDataParam = (PPARAM_LIST)pDeviceDataParam->pNext;
                FreeMem(pTemp);
                pTemp = pDeviceDataParam;
            } // while(NULL != pTemp)
        } // if(NULL != pDeviceDataParam)
    } // if(ERROR_SUCCESS != lError)

    if(NULL != pParam1){
        FreeMem(pParam1);
    }

    if(NULL != pParam2){
        FreeMem(pParam2);
    }
    
    return lError;
} // MigNtGetDevice()


VOID
MigNtFreeDeviceInfo(
    PDEVICE_INFO    pMigrateDevice
    )
{
    PPARAM_LIST pCurrent;
    PPARAM_LIST pNext;

    if(NULL == pMigrateDevice){
        goto MigNtFreeDeviceInfo_return;
    } // if(NULL == pMigrateDevice)

    //
    // Free all allocated parameters.
    //

    if(NULL != pMigrateDevice->pszFriendlyName){
        FreeMem(pMigrateDevice->pszFriendlyName);
    }
    if(NULL != pMigrateDevice->pszCreateFileName){
        FreeMem(pMigrateDevice->pszCreateFileName);
    }
    if(NULL != pMigrateDevice->pszInfPath){
        FreeMem(pMigrateDevice->pszInfPath);
    }
    if(NULL != pMigrateDevice->pszInfSection){
        FreeMem(pMigrateDevice->pszInfSection);
    }
    if(NULL != pMigrateDevice->pDeviceDataParam){
        pCurrent = pMigrateDevice->pDeviceDataParam;
        while(NULL != pCurrent){
            pNext = (PPARAM_LIST)pCurrent->pNext;
            FreeMem(pCurrent);
            pCurrent = pNext;
        } // while(NULL != pTemp)
    } // if(NULL != pDeviceDataParam)

    //
    // Null out the buffer.
    //

    memset(pMigrateDevice, 0, sizeof(DEVICE_INFO));

MigNtFreeDeviceInfo_return:
    return;
} // MigNtFreeDeviceInfo()

BOOL
CALLBACK
MigNtIsWin9xImagingExisting(
    VOID
    )
{
    BOOL                bRet;
    LONG                lError;
    HKEY                hkKodak;
    TCHAR               szWindowsDirectory[MAX_PATH];
    TCHAR               szKodakImaging[MAX_PATH];
    DWORD               dwVersionInfoSize;
    DWORD               dwDummy;
    PVOID               pVersion;
    PVOID               pFileVersionInfo;
    DWORD               dwFileVersionInfoSize;

    

    //
    // Initialize local.
    //

    bRet                    = FALSE;
    lError                  = ERROR_SUCCESS;
    dwVersionInfoSize       = 0;
    dwFileVersionInfoSize   = 0;
    pVersion                = NULL;
    pFileVersionInfo        = NULL;

    memset(szWindowsDirectory, 0, sizeof(szWindowsDirectory));
    memset(szKodakImaging, 0, sizeof(szKodakImaging));

    //
    // Get Windows directory.
    //

    if(0 == GetWindowsDirectory(szWindowsDirectory, sizeof(szWindowsDirectory)/sizeof(TCHAR))){
        lError = GetLastError();
        MyLogError("WIA Migration: MigNtIsWin9xImagingExisting: ERROR!! GetWindowsDirectory() failed. Err=0x%x\n", lError);

        goto MigNtIsWin9xImagingExisting_return;
    } // if(0 == GetWindowsDirectory(szTemp, sizeof(szTemp)/sizeof(TCHAR)))

    //
    // Create path to Kodak Imaging.
    //

//    wsprintf(szKodakImaging, "%s\\%s", szWindowsDirectory, NAME_KODAKIMAGING);
    _sntprintf(szKodakImaging, sizeof(szKodakImaging)/sizeof(TCHAR), TEXT("%s\\%s"), szWindowsDirectory, NAME_KODAKIMAGING);

    //
    // Make sure the string is NULL terminated.
    //

    szKodakImaging[sizeof(szKodakImaging)/sizeof(szKodakImaging[0]) -1] = TEXT('\0');


    //
    // Get size of version resource of the file.
    //

    dwVersionInfoSize = GetFileVersionInfoSize(szKodakImaging, &dwDummy);
    if(0 == dwVersionInfoSize){
        
        //
        // Unable to get version info of the file. Most probably the file doesn't exist.
        //

        lError = GetLastError();
        if(ERROR_FILE_NOT_FOUND == lError){

            //
            // File doesn't exist. Now it's safe to remove regkey for kodakimg.exe.
            //
            
            bRet = TRUE;

        } // if(ERROR_FILE_NOT_FOUND == lError)
//        MyLogError("WIA Migration: MigNtIsWin9xImagingExisting: ERROR!! GetFileVersionInfoSize() failed. Err=0x%x\n", lError);

        goto MigNtIsWin9xImagingExisting_return;
    } // if(0 == dwVersionInfoSize)

    //
    // Allocate required size of buffer.
    //

    pVersion = AllocMem(dwVersionInfoSize);
    if(NULL == pVersion){
        lError = ERROR_INSUFFICIENT_BUFFER;
        MyLogError("WIA Migration: MigNtIsWin9xImagingExisting: ERROR!! InsufficientBuffer. Err=0x%x\n", lError);

        goto MigNtIsWin9xImagingExisting_return;
    } // if(NULL == pVersion)

    //
    // Get version info.
    //

    if(FALSE == GetFileVersionInfo(szKodakImaging, 0, dwVersionInfoSize, pVersion)){
        lError = GetLastError();
        MyLogError("WIA Migration: MigNtIsWin9xImagingExisting: ERROR!! GetVersionInfo() failed. Err=0x%x\n", lError);

        goto MigNtIsWin9xImagingExisting_return;
    } // if(FALSE == GetVersionInfo(szKodakImaging, 0, dwVersionInfoSize, pVersion))

    //
    // See if the binary is Win9x inbox.
    //

    if(FALSE == VerQueryValue(pVersion, TEXT("\\"), &pFileVersionInfo, &dwFileVersionInfoSize)){
        lError = GetLastError();
        MyLogError("WIA Migration: MigNtIsWin9xImagingExisting: ERROR!! VerQueryValue() failed. Err=0x%x\n", lError);

        goto MigNtIsWin9xImagingExisting_return;
    } // if(FALSE == VerQueryValue(pVersion, TEXT("\\"), &pFileVersionInfo, &dwFileVersionInfoSize))

    if( (FILEVER_KODAKIMAGING_WIN98_MS == ((VS_FIXEDFILEINFO *)pFileVersionInfo)->dwFileVersionMS)
     && (FILEVER_KODAKIMAGING_WIN98_LS == ((VS_FIXEDFILEINFO *)pFileVersionInfo)->dwFileVersionLS)
     && (PRODVER_KODAKIMAGING_WIN98_MS == ((VS_FIXEDFILEINFO *)pFileVersionInfo)->dwProductVersionMS)
     && (PRODVER_KODAKIMAGING_WIN98_LS == ((VS_FIXEDFILEINFO *)pFileVersionInfo)->dwProductVersionLS) )
    {
        //
        // This is Win98 inbox Kodak Imaging. Process regkey removal.
        //
        
        bRet = TRUE;
    } else if( (FILEVER_KODAKIMAGING_WINME_MS == ((VS_FIXEDFILEINFO *)pFileVersionInfo)->dwFileVersionMS)
            && (FILEVER_KODAKIMAGING_WINME_LS == ((VS_FIXEDFILEINFO *)pFileVersionInfo)->dwFileVersionLS)
            && (PRODVER_KODAKIMAGING_WINME_MS == ((VS_FIXEDFILEINFO *)pFileVersionInfo)->dwProductVersionMS)
            && (PRODVER_KODAKIMAGING_WINME_LS == ((VS_FIXEDFILEINFO *)pFileVersionInfo)->dwProductVersionLS) )
    {
        //
        // This is WinMe inbox Kodak Imaging. Process regkey removal.
        //
        
        bRet = TRUE;
    }

MigNtIsWin9xImagingExisting_return:
    
    //
    // Cleanup.
    //
    
    if(NULL != pVersion){
        FreeMem(pVersion);
    } // if(NULL != pVersion)

    return bRet;

} // MigNtIsWin9xImagingExisting()


VOID
CALLBACK
MigNtRemoveKodakImagingKey(
    VOID
    )
{

    HMODULE         hmShlwapi;
    PSHDELETEKEY    pfnSHDeleteKey;

    //
    // Initialize local.
    //

    hmShlwapi       = (HMODULE)NULL;
    pfnSHDeleteKey  = (PSHDELETEKEY)NULL;

    //
    // Load shlwapi.dll.
    //
    
    hmShlwapi = LoadLibrary(TEXT("shlwapi.dll"));
    if(NULL == hmShlwapi){
        MyLogError("WIA Migration: MigNtRemoveKodakImagingKey: ERROR!! Unable to load hmShlwapi.dll. Err=0x%x.\n", GetLastError());

        goto MigNtRemoveKodakImagingKey_return;
    } // if(NULL == hmShlwapi)

    //
    // Get proc address of SHDeleteKey.
    //

    pfnSHDeleteKey = (PSHDELETEKEY)GetProcAddress(hmShlwapi, TEXT("SHDeleteKeyA"));
    if(NULL == pfnSHDeleteKey){
        MyLogError("WIA Migration: MigNtRemoveKodakImagingKey: ERROR!! Unable to find SHDeleteKeyA. Err=0x%x.\n", GetLastError());

        goto MigNtRemoveKodakImagingKey_return;
    } // if(NULL == hmShlwapi)

    //
    // Delete key.
    //

    if(ERROR_SUCCESS != pfnSHDeleteKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_KODAKEVENT_A)){
        MyLogError("WIA Migration: MigNtRemoveKodakImagingKey: ERROR!! Unable to delete key. Err=0x%x.\n", GetLastError());

        goto MigNtRemoveKodakImagingKey_return;
    } // if(ERROR_SUCCESS != pfnSHDeleteKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_KODAKEVENT_A))

MigNtRemoveKodakImagingKey_return:
    if(NULL != hmShlwapi){
        FreeLibrary(hmShlwapi);
        hmShlwapi = NULL;
    } // if(NULL != hmShlwapi)

} // MigNtRemoveKodakImagingKey()

//
// The following are to make sure if setup changes the header file they
// first tell me (otherwise they will break build of this)
//
P_INITIALIZE_NT     pfnInitializeNT         = InitializeNT;
P_MIGRATE_USER_NT   pfnMigrateUserNt        = MigrateUserNT;
P_MIGRATE_SYSTEM_NT pfnMigrateSystemNT      = MigrateSystemNT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\win9xupg\resource.h ===
#define     IDS_PRODUCTID                   1001
#define     IDS_TITLE                       1002

#define     IDS_DRIVERS_UPGRADE_FAILED      2001
#define     IDS_DRIVER_UPGRADE_FAILED       2002
#define     IDS_ADDDRIVER_FAILED            2003
#define     IDS_ICM_FAILED                  2004
#define     IDS_DEFAULT_PRINTER_FAILED      2005
#define     IDS_ADDPRINTER_FAILED           2006
#define     IDS_ADDMONITOR_FAILED           2007

#define     IDS_PRINTER_CANT_MIGRATE        3001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\win9xupg\util.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved.

Module Name:

    Util.c

Abstract:

    Uitility routines for printer migration from Win9x to NT

Author:

    Muhunthan Sivapragasam (MuhuntS) 02-Jan-1996

Revision History:

--*/


#include "precomp.h"





PVOID
AllocMem(
    IN UINT cbSize
    )
/*++

Routine Description:
    Allocate memory from the heap

Arguments:
    cbSize  : Byte count

Return Value:
    Pointer to the allocated memory

--*/
{
    return LocalAlloc(LPTR, cbSize);
}


VOID
FreeMem(
    IN PVOID    p
    )
/*++

Routine Description:
    Free memory allocated on the heap

Arguments:
    p   : Pointer to the memory to be freed

Return Value:
    None

--*/
{
    LocalFree(p);
}


LPSTR
AllocStrA(
    LPCSTR  pszStr
    )
/*++

Routine Description:
    Allocate memory and make a copy of an ansi string field

Arguments:
    pszStr   : String to copy

Return Value:
    Pointer to the copied string. Memory is allocated.

--*/
{
    LPSTR  pszRet = NULL;

    if ( pszStr && *pszStr ) {

        pszRet = AllocMem((strlen(pszStr) + 1) * sizeof(CHAR));
        if ( pszRet )
            strcpy(pszRet, pszStr);
    }

    return pszRet;
}



LPSTR
AllocStrAFromStrW(
    LPCWSTR     pszStr
    )
/*++

Routine Description:
    Returns the ansi string for a give unicode string. Memory is allocated.

Arguments:
    pszStr   : Gives the ansi string to copy

Return Value:
    Pointer to the copied ansi string. Memory is allocated.

--*/
{
    DWORD   dwLen;
    LPSTR   pszRet = NULL;

    if ( pszStr                     &&
         *pszStr                    &&
         (dwLen = wcslen(pszStr))   &&
         (pszRet = AllocMem((dwLen + 1 ) * sizeof(CHAR))) ) {

        WideCharToMultiByte(CP_ACP,
                            0,
                            pszStr,
                            dwLen,
                            pszRet,
                            dwLen,
                            NULL,
                            NULL );
    }

    return pszRet;
}


BOOL
WriteToFile(
    HANDLE  hFile,
    LPCSTR  pszFormat,
    ...
    )
/*++

Routine Description:
    Format and write a string to the text file. This is used to write the
    printing configuration on Win9x

Arguments:
    hFile       : File handle
    pszFormat   : Format string for the message

Return Value:
    None

--*/
{
    CHAR        szMsg[MAX_LINELENGTH];
    int         iResult;
    va_list     vargs;
    DWORD       dwSize, dwWritten;
    BOOL        bRet;

    bRet = TRUE;

    va_start(vargs, pszFormat);
//    vsprintf(szMsg, pszFormat, vargs);  
    iResult = StringCbVPrintfA(szMsg, sizeof(szMsg), pszFormat, vargs);
    va_end(vargs);

    dwSize = strlen(szMsg) * sizeof(CHAR);

    if ( !WriteFile(hFile, (LPCVOID)szMsg, dwSize, &dwWritten, NULL)    ||
         dwSize != dwWritten ) {

        bRet = FALSE;
    }
    
    return bRet;
}


LPSTR
GetStringFromRcFileA(
    UINT    uId
    )
/*++

Routine Description:
    Load a string from the .rc file and make a copy of it by doing AllocStr

Arguments:
    uId     : Identifier for the string to be loaded

Return Value:
    String value loaded, NULL on error. Caller should free the memory

--*/
{
    CHAR    buf[MAX_LINELENGTH+1];

    if(0 != LoadStringA(g_hInst, uId, buf, sizeof(buf))){
        buf[sizeof(buf)-1] = '\0';
        return AllocStrA(buf);
    } else {
        return NULL;
    } // if(0 != LoadStringA(g_hInst, uId, buf, sizeof(buf)))
} // GetStringFromRcFileA()



VOID
ReadString(
    IN      HANDLE  hFile,
    OUT     LPSTR  *ppszParam1,
    OUT     LPSTR  *ppszParam2
    )
{
    CHAR    c;
    LPSTR   pszParameter1;
    LPSTR   pszParameter2;
    DWORD   dwLen;
    CHAR    LineBuffer[MAX_LINELENGTH+1];
    DWORD   Idx;
    PCHAR   pCurrent;

    //
    // Initialize local.
    //

    c               = 0;
    pszParameter1   = NULL;
    pszParameter2   = NULL;
    dwLen           = 0;
    Idx             = 0;
    pCurrent        = NULL;
    
    memset(LineBuffer, 0, sizeof(LineBuffer));

    //
    // Initialize caller buffer
    //

    *ppszParam1 = NULL;
    *ppszParam2 = NULL;

    //
    // First skip space/\r/\n.
    //

    c = (CHAR) My_fgetc(hFile);
    while( (' ' == c)
        || ('\n' == c)
        || ('\r' == c) )
    {
        c = (CHAR) My_fgetc(hFile);
    }

    //
    // See if it's EOF.
    //

    if(EOF == c){
        
        //
        // End of file.
        //

        goto ReadString_return;
    }

    //
    // Get a line.
    //

    Idx = 0;
    while( ('\n' != c) && (EOF != c) && (Idx < sizeof(LineBuffer)-2) ){
        LineBuffer[Idx++] = c;
        c = (CHAR) My_fgetc(hFile);
    } // while( ('\n' != c) && (EOF != c) )
    dwLen = Idx;

    //
    // See if it's EOF.
    //

    if(EOF == c){
        
        //
        // Illegal migration file.
        //
        
        SetupLogError("WIA Migration: ReadString: ERROR!! Illegal migration file.\r\n", LogSevError);
        goto ReadString_return;
    } else if ('\n' != c) {

        //
        // A line too long.
        //

        SetupLogError("WIA Migration: ReadString: ERROR!! Reading line is too long.\r\n", LogSevError);
        goto ReadString_return;
    }

    //
    // See if it's double quated.
    //

    if('\"' != LineBuffer[0]){
        //
        // There's no '"'. Invalid migration file.
        //
        SetupLogError("WIA Migration: ReadString: ERROR!! Illegal migration file with no Quote.\r\n", LogSevError);
        goto ReadString_return;
    } // if('\"' != LineBuffer[0])
    

    pszParameter1 = &LineBuffer[1];
    pCurrent      = &LineBuffer[1];

    //
    // Find next '"' and replace with '\0'.
    //

    pCurrent = strchr(pCurrent, '\"');
    if(NULL == pCurrent){
        SetupLogError("WIA Migration: ReadString: ERROR!! Illegal migration file.\r\n", LogSevError);
        goto ReadString_return;
    } // if(NULL == pCurrent)

    *pCurrent++ = '\0';

    //
    // Find next (3rd) '"', it's beginning of 2nd parameter.
    //

    pCurrent = strchr(pCurrent, '\"');
    if(NULL == pCurrent){
        SetupLogError("WIA Migration: ReadString: ERROR!! Illegal migration file.\r\n", LogSevError);
        goto ReadString_return;
    } // if(NULL == pCurrent)

    pCurrent++;
    pszParameter2 = pCurrent;

    //
    // Find last '"' and replace with '\0'.
    //

    pCurrent = strchr(pCurrent, '\"');
    if(NULL == pCurrent){
        SetupLogError("WIA Migration: ReadString: ERROR!! Illegal migration file.\r\n", LogSevError);
        goto ReadString_return;
    } // if(NULL == pCurrent)

    *pCurrent = '\0';

    //
    // Allocate buffer for returning string.
    //

    *ppszParam1 = AllocStrA(pszParameter1);
    *ppszParam2 = AllocStrA(pszParameter2);

ReadString_return:
    return;
} // ReadString()



LONG
WriteRegistryToFile(
    IN  HANDLE  hFile,
    IN  HKEY    hKey,
    IN  LPCSTR  pszPath
    )
{
    LONG    lError;
    HKEY    hSubKey;
    DWORD   dwValueSize;
    DWORD   dwDataSize;
    DWORD   dwSubKeySize;
    DWORD   dwTypeBuffer;

    PCHAR   pSubKeyBuffer;
    PCHAR   pValueBuffer;
    PCHAR   pDataBuffer;

    DWORD   Idx;
    
    //
    // Initialize local.
    //
    
    lError          = ERROR_SUCCESS;
    hSubKey         = (HKEY)INVALID_HANDLE_VALUE;
    dwValueSize     = 0;
    dwDataSize      = 0;
    dwSubKeySize    = 0;
    dwTypeBuffer    = 0;
    Idx             = 0;
    
    pSubKeyBuffer   = NULL;
    pValueBuffer    = NULL;
    pDataBuffer     = NULL;

    //
    // Query necessary buffer size.
    //

    lError = RegQueryInfoKeyA(hKey,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              &dwSubKeySize,
                              NULL,
                              NULL,
                              &dwValueSize,
                              &dwDataSize,
                              NULL,
                              NULL);
    if(ERROR_SUCCESS != lError){

        //
        // Unable to retrieve key info.
        //

        goto WriteRegistryToFile_return;

    } // if(ERROR_SUCCESS != lError)

    //
    // Allocate buffers.
    //

    dwValueSize     = (dwValueSize+1+1) * sizeof(CHAR);
    dwSubKeySize    = (dwSubKeySize+1) * sizeof(CHAR);

    pValueBuffer    = AllocMem(dwValueSize);
    pDataBuffer     = AllocMem(dwDataSize);
    pSubKeyBuffer   = AllocMem(dwSubKeySize);

    if( (NULL == pValueBuffer)
     || (NULL == pDataBuffer)
     || (NULL == pSubKeyBuffer) )
    {

        //
        // Insufficient memory.
        //

        SetupLogError("WIA Migration: WriteRegistryToFile: ERROR!! Unable to allocate buffer.\r\n", LogSevError);
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto WriteRegistryToFile_return;
    } // if(NULL == pDataBuffer)

    //
    // Indicate beginning of this subkey to the file.
    //

    WriteToFile(hFile, "\"%s\" = \"BEGIN\"\r\n", pszPath);

    //
    // Enumerate all values.
    //

    while(ERROR_SUCCESS == lError){

        DWORD   dwLocalValueSize;
        DWORD   dwLocalDataSize;
        
        //
        // Reset buffer and size.
        //
        
        dwLocalValueSize    = dwValueSize;
        dwLocalDataSize     = dwDataSize;
        memset(pValueBuffer, 0, dwValueSize);
        memset(pDataBuffer, 0, dwDataSize);

        //
        // Acquire registry value/data..
        //

        lError = RegEnumValueA(hKey,
                               Idx,
                               pValueBuffer,
                               &dwLocalValueSize,
                               NULL,
                               &dwTypeBuffer,
                               pDataBuffer,
                               &dwLocalDataSize);
        if(ERROR_NO_MORE_ITEMS == lError){
            
            //
            // End of data.
            //
            
            continue;
        } // if(ERROR_NO_MORE_ITEMS == lError)

        if(ERROR_SUCCESS != lError){
            
            //
            // Unable to read registry value.
            //
            
            SetupLogError("WIA Migration: WriteRegistryToFile: ERROR!! Unable to acqure registry value/data.\r\n", LogSevError);
            goto WriteRegistryToFile_return;
        } // if(ERROR_NO_MORE_ITEMS == lError)

        //
        // Write this value to a file.
        //

        lError = WriteRegistryValueToFile(hFile,
                                          pValueBuffer,
                                          dwTypeBuffer,
                                          pDataBuffer,
                                          dwLocalDataSize);
        if(ERROR_SUCCESS != lError){
            
            //
            // Unable to write to a file.
            //

            SetupLogError("WIA Migration: WriteRegistryToFile: ERROR!! Unable to write to a file.\r\n", LogSevError);
            goto WriteRegistryToFile_return;
        } // if(ERROR_SUCCESS != lError)

        //
        // Goto next value.
        //
        
        Idx++;
                            
    } // while(ERROR_SUCCESS == lError)

    //
    // Enumerate all sub keys.
    //

    lError          = ERROR_SUCCESS;
    Idx             = 0;

    while(ERROR_SUCCESS == lError){

        memset(pSubKeyBuffer, 0, dwSubKeySize);
        lError = RegEnumKeyA(hKey, Idx++, pSubKeyBuffer, dwSubKeySize);
        if(ERROR_SUCCESS == lError){

            //
            // There's sub key exists. Spew it to the file and store all the
            // values recursively.
            //

            lError = RegOpenKey(hKey, pSubKeyBuffer, &hSubKey);
            if(ERROR_SUCCESS != lError){
                SetupLogError("WIA Migration: WriteRegistryToFile: ERROR!! Unable to open subkey.\r\n", LogSevError);
                continue;
            } // if(ERROR_SUCCESS != lError)

            //
            // Call subkey recursively.
            //
            
            lError = WriteRegistryToFile(hFile, hSubKey, pSubKeyBuffer);

        } // if(ERROR_SUCCESS == lError)
    } // while(ERROR_SUCCESS == lError)

    if(ERROR_NO_MORE_ITEMS == lError){
        
        //
        // Operation completed as expected.
        //
        
        lError = ERROR_SUCCESS;

    } // if(ERROR_NO_MORE_ITEMS == lError)

    //
    // Indicate end of this subkey to the file.
    //

    WriteToFile(hFile, "\"%s\" = \"END\"\r\n", pszPath);

WriteRegistryToFile_return:

    //
    // Clean up.
    //

    if(NULL != pValueBuffer){
        FreeMem(pValueBuffer);
    } // if(NULL != pValueBuffer)

    if(NULL != pDataBuffer){
        FreeMem(pDataBuffer);
    } // if(NULL != pDataBuffer)

    if(NULL != pSubKeyBuffer){
        FreeMem(pSubKeyBuffer);
    } // if(NULL != pSubKeyBuffer)

    return lError;
} // WriteRegistryToFile()


LONG
WriteRegistryValueToFile(
    HANDLE  hFile,
    LPSTR   pszValue,
    DWORD   dwType,
    PCHAR   pDataBuffer,
    DWORD   dwSize
    )
{

    LONG    lError;
    PCHAR   pSpewBuffer;
    DWORD   Idx;

    //
    // Initialize locals.
    //

    lError      = ERROR_SUCCESS;
    pSpewBuffer = NULL;

    //
    // Allocate buffer for actual spew.
    //
    
    pSpewBuffer = AllocMem(dwSize*3);
    if(NULL == pSpewBuffer){
        
        //
        // Unable to allocate buffer.
        //
        
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto WriteRegistryValueToFile_return;
    } // if(NULL == pSpewBuffer)

    for(Idx = 0; Idx < dwSize; Idx++){
        
        wsprintf(pSpewBuffer+Idx*3, "%02x", pDataBuffer[Idx]);
        *(pSpewBuffer+Idx*3+2) = ',';
        
    } // for(Idx = 0; Idx < dwSize; Idx++)

    *(pSpewBuffer+dwSize*3-1) = '\0';

    WriteToFile(hFile, "\"%s\" = \"%08x:%s\"\r\n", pszValue, dwType, pSpewBuffer);
    
    //
    // Operation succeeded.
    //
    
    lError = ERROR_SUCCESS;

WriteRegistryValueToFile_return:

    //
    // Clean up.
    //
    
    if(NULL != pSpewBuffer){
        FreeMem(pSpewBuffer);
    } // if(NULL != pSpewBuffer)
    
    return lError;

} // WriteRegistryValueToFile()


LONG
GetRegData(
    HKEY    hKey,
    LPSTR   pszValue,
    PCHAR   *ppDataBuffer,
    PDWORD  pdwType,
    PDWORD  pdwSize
    )
{

    LONG    lError;
    PCHAR   pTempBuffer;
    DWORD   dwRequiredSize;
    DWORD   dwType;
    
    //
    // Initialize local.
    //
    
    lError          = ERROR_SUCCESS;
    pTempBuffer     = NULL;
    dwRequiredSize  = 0;
    dwType          = 0;
    
    //
    // Get required size.
    //
    
    lError = RegQueryValueEx(hKey,
                             pszValue,
                             NULL,
                             &dwType,
                             NULL,
                             &dwRequiredSize);
    if( (ERROR_SUCCESS != lError)
     || (0 == dwRequiredSize) )
    {
        
        pTempBuffer = NULL;
        goto GetRegData_return;

    } // if(ERROR_MORE_DATA != lError)

    //
    // If it doesn't need actual data, just bail out.
    //

    if(NULL == ppDataBuffer){
        lError = ERROR_SUCCESS;
        goto GetRegData_return;
    } // if(NULL == ppDataBuffer)

    //
    // Allocate buffer to receive data.
    //

    pTempBuffer = AllocMem(dwRequiredSize);
    if(NULL == pTempBuffer){
        
        //
        // Allocation failed.
        //
        
        SetupLogError("WIA Migration: GetRegData: ERROR!! Unable to allocate buffer.\r\n", LogSevError);
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto GetRegData_return;
    } // if(NULL == pTempBuffer)

    //
    // Query the data.
    //

    lError = RegQueryValueEx(hKey,
                             pszValue,
                             NULL,
                             &dwType,
                             pTempBuffer,
                             &dwRequiredSize);
    if(ERROR_SUCCESS != lError){
        
        //
        // Data acquisition somehow failed. Free buffer.
        //
        
        goto GetRegData_return;
    } // if(ERROR_SUCCESS != lError)

GetRegData_return:

    if(ERROR_SUCCESS != lError){
        
        //
        // Operation unsuccessful. Free the buffer if allocated.
        //
        
        if(NULL != pTempBuffer){
            FreeMem(pTempBuffer);
            pTempBuffer = NULL;
        } // if(NULL != pTempBuffer)
    } // if(ERROR_SUCCESS != lError)

    //
    // Copy the result.
    //

    if(NULL != pdwSize){
        *pdwSize = dwRequiredSize;
    } // if(NULL != pdwSize)

    if(NULL != ppDataBuffer){
        *ppDataBuffer = pTempBuffer;
    } // if(NULL != ppDataBuffer)

    if(NULL != pdwType){
        *pdwType = dwType;
    } // if(NULL != pdwType)

    return lError;
} // GetRegData()

VOID
MyLogError(
    LPCSTR  pszFormat,
    ...
    )
{
    LPSTR       psz;
    CHAR        szMsg[1024];
    va_list     vargs;

    if(NULL != pszFormat){
        va_start(vargs, pszFormat);
        vsprintf(szMsg, pszFormat, vargs);
        va_end(vargs);

        SetupLogError(szMsg, LogSevError);
    } // if(NULL != pszFormat)

} // MyLogError()

CHAR
My_fgetc(
    HANDLE  hFile
    )
/*++

Routine Description:
    Gets a character from the file

Arguments:

Return Value:

--*/
{
    CHAR    c;
    DWORD   cbRead;

    if ( ReadFile(hFile, (LPBYTE)&c, sizeof(c), &cbRead, NULL)  &&
         cbRead == sizeof(c) )
        return c;
    else
        return (CHAR) EOF;
} // My_fgetc()

int
MyStrCmpiA(
    LPCSTR str1,
    LPCSTR str2
    )
{
    int iRet;
    
    //
    // Initialize local.
    //
    
    iRet = 0;
    
    //
    // Compare string.
    //
    
    if(CSTR_EQUAL == CompareStringA(LOCALE_INVARIANT,
                                    NORM_IGNORECASE, 
                                    str1, 
                                    -1,
                                    str2,
                                    -1) )
    {
        iRet = 0;
    } else {
        iRet = -1;
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\win9xupg\test\win9x.c ===
/*++

Copyright (c) 1994 - 1995 Microsoft Corporation

Module Name:

    Win9x.c

Abstract:

    Test pre-migration of Win95 to NT

Author:
    MuhuntS


Revision History:
    01-17-97


--*/

#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <setupapi.h>
#include <plugin.h>

P_QUERY_VERSION         QueryVersion;
P_INITIALIZE_9X         Initialize9x;
P_MIGRATE_SYSTEM_9X     MigrateSystem9x;

P_INITIALIZE_NT         InitializeNT;
P_MIGRATE_SYSTEM_NT     MigrateSystemNT;

WCHAR   szSrcDir[MAX_PATH], szWrkDir[MAX_PATH];

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    PVENDORINFO     pVI;
    HMODULE         hModule;
    HANDLE          hAlive = NULL;
    DWORD           dwLastError;
    LPSTR           p1, p2, p3, p4, p5;
    LONG            x;
    UINT            v;
    INT             c;

    p1 = p2 = p3 = p4 = p5 = NULL;

    if ( argc < 3 ) {

        printf("Usage: %s <working-dir> <source-dir>\n", argv[0]);
        return 0;
    }

    hModule = LoadLibraryA("migrate.dll");
    if ( !hModule ) {

        printf("%s: LoadLibrary failed with %d\n", argv[0], GetLastError());
        goto Cleanup;
    }

    //
    // Nt only?
    //
    if ( argc == 4 && argv[3][0] == '+' )
        goto DoNT;

    (FARPROC) QueryVersion      = GetProcAddress(hModule, "QueryVersion");
    (FARPROC) Initialize9x      = GetProcAddress(hModule, "Initialize9x");
    (FARPROC) MigrateSystem9x   = GetProcAddress(hModule, "MigrateSystem9x");

    if ( !QueryVersion || !Initialize9x || !MigrateSystem9x )
        goto Cleanup;

    x = QueryVersion(&p1, (LPUINT)&p2, (LPINT*)&p3, &p4, (PVENDORINFO*)&pVI);

    printf("QueryVersion returned %d\n", x);

    x = Initialize9x(argv[1], argv[2], 0);

    printf("Initialize9x returned %d\n", x);

    x = MigrateSystem9x(0, NULL, 0);

    printf("MigrateSystem9x returned %d\n", x);

    FreeLibrary(hModule);

    //
    // Win95 only?
    //
    if ( argc == 4 && argv[3][0] == '-' )
        goto Cleanup;

    hModule = LoadLibraryA("migrate.dll");
    if ( !hModule ) {

        printf("%s: LoadLibrary II failed with %d\n", argv[0], GetLastError());
        goto Cleanup;
    }

DoNT:
    MultiByteToWideChar(CP_ACP,
                        MB_PRECOMPOSED,
                        argv[1],
                        -1,
                        szWrkDir,
                        MAX_PATH);

    MultiByteToWideChar(CP_ACP,
                        MB_PRECOMPOSED,
                        argv[2],
                        -1,
                        szSrcDir,
                        MAX_PATH);

    InitializeNT     = (P_INITIALIZE_NT)GetProcAddress(hModule, "InitializeNT");
    MigrateSystemNT  = (P_MIGRATE_SYSTEM_NT)GetProcAddress(hModule, "MigrateSystemNT");

    if ( !InitializeNT || !MigrateSystemNT )
        goto Cleanup;

    hAlive = CreateEventA(NULL, FALSE, FALSE, "MigDllAlive");

    if ( ERROR_SUCCESS == InitializeNT(szWrkDir, szSrcDir, 0) )
        MigrateSystemNT(INVALID_HANDLE_VALUE, 0);

    FreeLibrary(hModule);
Cleanup:
    if ( hModule )
        FreeLibrary(hModule);

    if ( hAlive )
        CloseHandle(hAlive);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\msqscan\datatypes.h ===
// DataTypes.h

#ifndef _DATA_H
#define _DATA_H

typedef struct _RANGE_TYPE {
	LONG Min;
	LONG Max;
	LONG Nom;
	LONG Step;
	LONG Current;
} RANGE_TYPE;

typedef struct _SUPPORTED_FORMAT {
	TYMED tymed;
	GUID guidFormat;
} SUPPORTED_FORMAT;

typedef struct _SCANNER_SETTINGS {
	RANGE_TYPE Brightness;
	RANGE_TYPE Contrast;
	RANGE_TYPE Resolution;
	SUPPORTED_FORMAT *pSupportedFormats;	
}SCANNER_SETTINGS;

typedef struct _ADF_SETTINGS {
    LONG lDocumentHandlingCapabilites;
	LONG lDocumentHandlingSelect;
	LONG lDocumentHandlingStatus;
	LONG lDocumentHandlingCapacity;
	LONG lPages;
}ADF_SETTINGS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\msqscan\adfdlg.cpp ===
// ADFDlg.cpp : implementation file
//

#include "stdafx.h"
#include "msqscan.h"
#include "ADFDlg.h"
#include "uitables.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern WIA_DOCUMENT_HANDLING_TABLE_ENTRY g_WIA_DOCUMENT_HANDLING_STATUS_TABLE[];
extern WIA_DOCUMENT_HANDLING_TABLE_ENTRY g_WIA_DOCUMENT_HANDLING_CAPABILITES_TABLE[];
extern WIA_DOCUMENT_HANDLING_TABLE_ENTRY g_WIA_DOCUMENT_HANDLING_SELECT_TABLE[];

/////////////////////////////////////////////////////////////////////////////
// CADFDlg dialog


CADFDlg::CADFDlg(ADF_SETTINGS *pADFSettings, CWnd* pParent /*=NULL*/)
    : CDialog(CADFDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CADFDlg)
    m_ADFStatusText = _T("No document feeder is attached..");
    m_NumberOfPages = 1;
    m_pADFSettings = pADFSettings;
    m_MaxPagesAllowed = m_pADFSettings->lDocumentHandlingCapacity;
    m_DocumentHandlingSelectBackup = m_pADFSettings->lDocumentHandlingSelect;
    //}}AFX_DATA_INIT

    if(m_MaxPagesAllowed <= 0){
        m_MaxPagesAllowed = 50; // set to a large max value
    }
}


void CADFDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CADFDlg)    
    DDX_Control(pDX, IDC_ADF_MODE_COMBOBOX, m_ADFModeComboBox);
    DDX_Control(pDX, IDC_NUMBER_OF_PAGES_EDITBOX, m_ScanNumberOfPagesEditBox);
    DDX_Text(pDX, IDC_FEEDER_STATUS_TEXT, m_ADFStatusText);
    DDX_Text(pDX, IDC_NUMBER_OF_PAGES_EDITBOX, m_NumberOfPages);
    DDV_MinMaxUInt(pDX, m_NumberOfPages, 0, m_MaxPagesAllowed);
    DDX_Control(pDX, IDC_SCAN_ALL_PAGES_RADIOBUTTON, m_ScanAllPages);
    DDX_Control(pDX, IDC_SCAN_SPECIFIED_PAGES_RADIOBUTTON, m_ScanNumberOfPages);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CADFDlg, CDialog)
    //{{AFX_MSG_MAP(CADFDlg)
    ON_EN_KILLFOCUS(IDC_NUMBER_OF_PAGES_EDITBOX, OnKillfocusNumberOfPagesEditbox)
    ON_BN_CLICKED(IDC_SCAN_ALL_PAGES_RADIOBUTTON, OnScanAllPagesRadiobutton)
    ON_BN_CLICKED(IDC_SCAN_SPECIFIED_PAGES_RADIOBUTTON, OnScanSpecifiedPagesRadiobutton)
    ON_CBN_SELCHANGE(IDC_ADF_MODE_COMBOBOX, OnSelchangeAdfModeCombobox)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CADFDlg message handlers

void CADFDlg::OnKillfocusNumberOfPagesEditbox()
{

    //
    // write number of pages to member variable/forcing validation
    //

    UpdateData(TRUE);
    m_pADFSettings->lPages = m_NumberOfPages;
}

BOOL CADFDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    //
    // default to scanning only a single page
    //

    m_ScanNumberOfPages.SetCheck(1);
    OnScanSpecifiedPagesRadiobutton();

    //
    // Initialize Scanner status text
    //

    InitStatusText();

    //
    // Initialize Feeder Mode combo box, and handle
    // special case, for FLATBED selection
    //

    InitFeederModeComboBox();
    OnSelchangeAdfModeCombobox();
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CADFDlg::OnScanAllPagesRadiobutton()
{
    //
    // disable pages edit box
    //

    m_NumberOfPages = 0;
    UpdateData(FALSE);
    m_ScanNumberOfPagesEditBox.EnableWindow(FALSE);
}

void CADFDlg::OnScanSpecifiedPagesRadiobutton()
{
    //
    // enable pages edit box
    //

    m_ScanNumberOfPagesEditBox.EnableWindow(TRUE);
}

VOID CADFDlg::InitStatusText()
{
    for(ULONG index = 0;index < NUM_WIA_DOC_HANDLING_STATUS_ENTRIES;index++) {
        if((m_pADFSettings->lDocumentHandlingStatus &
            g_WIA_DOCUMENT_HANDLING_STATUS_TABLE[index].lFlagValue) ==
            g_WIA_DOCUMENT_HANDLING_STATUS_TABLE[index].lFlagValue) {

            //
            // we found a match, so add it to the text
            //

            m_ADFStatusText = g_WIA_DOCUMENT_HANDLING_STATUS_TABLE[index].szFlagName;
            UpdateData(FALSE);
        }
    }
}

VOID CADFDlg::InitFeederModeComboBox()
{
    //
    // check all three possible modes, FEEDER, FLATBED, and DUPLEX
    //

    ULONG NumModes = 3;
    for(ULONG index = 0;index < NumModes;index++) {
        if((m_pADFSettings->lDocumentHandlingCapabilites &
            g_WIA_DOCUMENT_HANDLING_CAPABILITES_TABLE[index].lFlagValue) ==
            g_WIA_DOCUMENT_HANDLING_CAPABILITES_TABLE[index].lFlagValue) {

            //
            // we found a match, so add it to the combobox along with the flag value
            //

            INT InsertIndex = m_ADFModeComboBox.AddString(g_WIA_DOCUMENT_HANDLING_SELECT_TABLE[index].szFlagName);
            m_ADFModeComboBox.SetItemData(InsertIndex, g_WIA_DOCUMENT_HANDLING_SELECT_TABLE[index].lFlagValue);

            //
            // set the combobox to the current setting value using the Document Handling Select
            //

            if((m_pADFSettings->lDocumentHandlingSelect &
                g_WIA_DOCUMENT_HANDLING_SELECT_TABLE[index].lFlagValue) ==
                g_WIA_DOCUMENT_HANDLING_SELECT_TABLE[index].lFlagValue) {

                m_ADFModeComboBox.SetCurSel(InsertIndex);
            }
        }
    }
}

INT CADFDlg::GetIDAndStringFromDocHandlingStatus(LONG lDocHandlingStatus, TCHAR *pszString)
{
    INT index = 0;
    while(g_WIA_DOCUMENT_HANDLING_STATUS_TABLE[index].lFlagValue != lDocHandlingStatus && index < NUM_WIA_DOC_HANDLING_STATUS_ENTRIES) {
        index++;
    }

    if(index > NUM_WIA_DOC_HANDLING_STATUS_ENTRIES)
        index = NUM_WIA_DOC_HANDLING_STATUS_ENTRIES;

    lstrcpy(pszString, g_WIA_DOCUMENT_HANDLING_STATUS_TABLE[index].szFlagName);

    return index;
}

void CADFDlg::OnSelchangeAdfModeCombobox()
{
    INT Index = m_ADFModeComboBox.GetCurSel();
    LONG lFlagValue = 0;
    lFlagValue = (LONG)m_ADFModeComboBox.GetItemData(Index);

    //
    // check for FLATBED setting, and adjust UI
    //

    if((lFlagValue & FLATBED) == FLATBED) {        
        m_ScanAllPages.EnableWindow(FALSE);
        m_ScanNumberOfPages.EnableWindow(FALSE);

        if(m_ScanNumberOfPages.GetCheck() == 1) {
            m_ScanNumberOfPagesEditBox.EnableWindow(FALSE);
        }

    } else {
        m_ScanAllPages.EnableWindow(TRUE);
        m_ScanNumberOfPages.EnableWindow(TRUE);

        if(m_ScanNumberOfPages.GetCheck() == 1) {
            m_ScanNumberOfPagesEditBox.EnableWindow(TRUE);
        }
    }
}

void CADFDlg::OnOK()
{
    //
    // get current Mode setting
    //

    LONG lModeflag = 0;

    INT Index = m_ADFModeComboBox.GetCurSel();
    lModeflag = (LONG)m_ADFModeComboBox.GetItemData(Index);
    
    //
    // clear old settings
    //

    m_pADFSettings->lDocumentHandlingSelect = 0;

    //
    // set new settings
    //

    m_pADFSettings->lDocumentHandlingSelect = lModeflag;

    //
    // set page count
    //

    m_pADFSettings->lPages = m_NumberOfPages;

    CDialog::OnOK();
}

void CADFDlg::OnCancel()
{
    m_pADFSettings->lDocumentHandlingSelect = m_DocumentHandlingSelectBackup;
    m_pADFSettings->lPages = 1;
    CDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\msqscan\cwia.h ===
// CWIA.H

#ifndef _CWIA_H
#define _CWIA_H

#include "wia.h"
#include "datatypes.h"
#include "sti.h"

#define MIN_PROPID 2

//
// helper MACROS
//

#define RECTWIDTH(lpRect)  ((lpRect)->right - (lpRect)->left)
#define RECTHEIGHT(lpRect) ((lpRect)->bottom - (lpRect)->top)

typedef BOOL (*FPPROGRESS)(LPTSTR lpszText, LONG lPercentComplete);
typedef struct _DATA_ACQUIRE_INFO {
	DWORD dwCookie;
	FPPROGRESS pProgressFunc;
	BOOL bPreview;
    BOOL bTransferToFile;
    BOOL bTransferToClipboard;
    CHAR szFileName[256];
	HBITMAP hBitmap;
	HWND hWnd;
    HGLOBAL hClipboardData;
    HGLOBAL hBitmapData;
} DATA_ACQUIRE_INFO;

//
// global helpers, for all to use
//

HRESULT WriteInterfaceToGlobalInterfaceTable(DWORD *pdwCookie, IWiaItem *pIWiaItem);
HRESULT ReadInterfaceFromGlobalInterfaceTable(DWORD dwCookie, IWiaItem **ppIWiaItem);

class CWIA {
public:
	 CWIA(DATA_ACQUIRE_INFO* pDataAcquireInfo = NULL, IWiaItem *pRootItem = NULL);
	~CWIA();
	
	VOID CleanUp();

	//
	// operations
	//

	HRESULT GetLastWIAError(TCHAR *pszErrorText = NULL);
	HRESULT ReadRangeLong(IWiaItem *pIWiaItem, PROPID propid, ULONG ulFlag, LONG *plVal);	
	HRESULT ReadLong(IWiaItem *pIWiaItem, PROPID propid, LONG *plVal);
	HRESULT ReadStr(IWiaItem *pIWiaItem, PROPID propid, BSTR *pbstr);
	HRESULT ReadGuid(IWiaItem *pIWiaItem, PROPID propid, GUID *pguidVal);

	HRESULT WriteLong(IWiaItem *pIWiaItem, PROPID propid, LONG lVal);
	HRESULT WriteGuid(IWiaItem *pIWiaItem, PROPID propid, GUID guidVal);

	HRESULT DoBandedTransfer(DATA_ACQUIRE_INFO* pDataAcquireInfo);
    HRESULT DoFileTransfer(DATA_ACQUIRE_INFO* pDataAcquireInfo);
	BOOL IsAcquireComplete();

	HRESULT EnumerateSupportedFormats(IWiaItem *pIWiaItem, WIA_FORMAT_INFO **ppSupportedFormats, ULONG *pulCount);

	//
	// Root Item operations
	//

	VOID SetRootItem(IWiaItem *pRootItem);
	IWiaItem *GetRootItem();
	LONG GetRootItemType(IWiaItem *pRootItem = NULL);

	//
	// standard item operations
	//

	BOOL SetFirstChild();
	IWiaItem *GetFirstChild();
	
private:
	
	//
	// helpers
	//

	VOID SaveErrorText(TCHAR *pszText);

	//
	// Read/Write LONG properties
	//

	HRESULT WritePropLong(PROPID propid, IWiaPropertyStorage *pIWiaPropStg, LONG lVal);
	HRESULT ReadPropLong(PROPID propid, IWiaPropertyStorage  *pIWiaPropStg, LONG *plval);

	//
	// Read/Write GUID properties
	//

	HRESULT WritePropGUID(PROPID propid, IWiaPropertyStorage *pIWiaPropStg, GUID guidVal);
	HRESULT ReadPropGUID(PROPID propid, IWiaPropertyStorage *pIWiaPropStg, GUID *pguidVal);

	//
	// Read/Write BSTR properties
	//

	HRESULT ReadPropStr(PROPID propid,IWiaPropertyStorage  *pIWiaPropStg,BSTR *pbstr);
	HRESULT WritePropStr(PROPID propid, IWiaPropertyStorage  *pIWiaPropStg, BSTR bstr);

protected:

	IWiaItem  *m_pIWiaRootItem;
	IWiaItem  *m_pIWiaFirstChildItem;
	BOOL      m_bFinishedAcquire;

	TCHAR     m_szErrorText[MAX_PATH];
	HRESULT   m_hrLastError;
};

//
// IWiaDataCallback Data callback transfer
//

class CWiaDataCallback : public IWiaDataCallback
{

private:

   ULONG                    m_cRef;         // Object reference count.     
   LONG                     m_MemBlockSize;
   LONG                     m_BytesTransfered;
   GUID                     m_cFormat;
   FPPROGRESS               m_pProgressFunc;
   LONG                     m_lPageCount;
   BOOL                     m_bCanceled;
   DATA_ACQUIRE_INFO*       m_pDataAcquireInfo;
   BOOL                     m_bBitmapCreated;
public:

    CWiaDataCallback();
    ~CWiaDataCallback();

    HRESULT _stdcall QueryInterface(const IID&,void**);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();

	//
	// public members
	//

    HRESULT _stdcall Initialize(DATA_ACQUIRE_INFO* pDataAcquireInfo = NULL);
    HRESULT _stdcall BandedDataCallback(LONG  lMessage,
										LONG  lStatus,
										LONG  lPercentComplete,
										LONG  lOffset,
										LONG  lLength,
										LONG  lReserved,
										LONG  lResLength,
										BYTE* pbBuffer);	
private:

	//
	// helpers
	//

	VOID AddDataToHBITMAP(HWND hWnd, HGLOBAL hBitmapData, HBITMAP *phBitmap, LONG lOffset);
	VOID CreateHBITMAP(HWND hWnd, HGLOBAL hBitmapData, HBITMAP *phBitmap, LONG lOffset);
	void ScreenRectToClientRect(HWND hWnd,LPRECT pRect);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\setup\win9xupg\win9x.c ===
/*++

Copyright (c) 2000 Microsoft Corporation
All rights reserved.

Module Name:

    Win9x.c

Abstract:

    Routines to pre-migrate Win9x to NT

Author:

    Keisuke Tsuchida (KeisukeT) 10-Oct-2000

Revision History:

--*/


#include "precomp.h"
#include "devguid.h" 

//
// Globals
//

 LPCSTR  g_WorkingDirectory   = NULL;
 LPCSTR  g_SourceDirectory    = NULL;
 LPCSTR  g_MediaDirectory     = NULL;
//LPCSTR  g_WorkingDirectory   = ".";
//LPCSTR  g_SourceDirectory    = ".";
//LPCSTR  g_MediaDirectory     = ".";

LONG
CALLBACK
Initialize9x(
    IN  LPCSTR      pszWorkingDir,
    IN  LPCSTR      pszSourceDir,
    IN  LPCSTR      pszMediaDir
    )
{
    LONG    lError;

    //
    // Initialize local.
    //

    lError = ERROR_SUCCESS;

    //
    // Save given parameters.
    //
    
    g_WorkingDirectory   = AllocStrA(pszWorkingDir);
    g_SourceDirectory    = AllocStrA(pszSourceDir);
    g_MediaDirectory     = AllocStrA(pszMediaDir);

    if( (NULL == g_WorkingDirectory)
     || (NULL == g_SourceDirectory)
     || (NULL == g_MediaDirectory)   )
    {
        SetupLogError("WIA Migration: Initialize9x: ERROR!! insufficient memory.\r\n", LogSevError);
        
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto Initialize9x_return;
    }

Initialize9x_return:

    if(ERROR_SUCCESS != lError){
        
        //
        // Can't process migration. Clean up.
        //
        
        if(NULL != g_WorkingDirectory){
            FreeMem((PVOID)g_WorkingDirectory);
            g_WorkingDirectory = NULL;
        }

        if(NULL != g_SourceDirectory){
            FreeMem((PVOID)g_SourceDirectory);
            g_SourceDirectory = NULL;
        }

        if(NULL != g_MediaDirectory){
            FreeMem((PVOID)g_MediaDirectory);
            g_MediaDirectory = NULL;
        }
    } // if(ERROR_SUCCESS != lError)

    return lError;
} // Initialize9x()


LONG
CALLBACK
MigrateUser9x(
    IN  HWND        hwndParent,
    IN  LPCSTR      pszUnattendFile,
    IN  HKEY        hUserRegKey,
    IN  LPCSTR      pszUserName,
        LPVOID      Reserved
    )
{
    //
    // Nothing to do
    //

    return  ERROR_SUCCESS;
} // MigrateUser9x()


LONG
CALLBACK
MigrateSystem9x(
    IN      HWND        hwndParent,
    IN      LPCSTR      pszUnattendFile,
    IN      LPVOID      Reserved
    )
{
    LONG    lError;
    CHAR    szFile[MAX_PATH];
    CHAR    szInfName[MAX_PATH];

    HANDLE  hSettingStore;

    //
    // Initialize locals.
    //
    
    lError          = ERROR_SUCCESS;
    hSettingStore   = (HANDLE)INVALID_HANDLE_VALUE;

    //
    // Check global initialization.
    //

    if( (NULL == g_WorkingDirectory)
     || (NULL == g_SourceDirectory)
     || (NULL == g_MediaDirectory)   )
    {
        SetupLogError("WIA Migration: MigrateSystem9x: ERROR!! Initialize failed.\r\n", LogSevError);
        
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto MigrateSystem9x_return;
    }

    //
    // Create path to the files.
    //

    wsprintfA(szFile, "%s\\%s", g_WorkingDirectory, NAME_WIN9X_SETTING_FILE_A);
    wsprintfA(szInfName, "%s\\%s", g_WorkingDirectory, NAME_MIGRATE_INF_A);

    //
    // Create files.
    //


    hSettingStore = CreateFileA(szFile,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
    if(INVALID_HANDLE_VALUE == hSettingStore){
        SetupLogError("WIA Migration: MigrateSystem9x: ERROR!! Unable to create setting file.\r\n", LogSevError);
        lError = GetLastError();
        goto MigrateSystem9x_return;
    } // if(INVALID_HANDLE_VALUE == hSettingStore)

    //
    // Create setting file based on device registry.
    //


    lError = Mig9xGetDeviceInfo(hSettingStore);
    if(ERROR_SUCCESS != lError){
        goto MigrateSystem9x_return;
    } // if(ERROR_SUCCESS != lError)

MigrateSystem9x_return:

    //
    // Clean up.
    //

    if(hSettingStore != INVALID_HANDLE_VALUE){
        CloseHandle(hSettingStore);
    }
    

    return  lError;

} // MigrateSystem9x()


LONG
CALLBACK
Mig9xGetDeviceInfo(
    IN      HANDLE      hFile
    )
{

    LONG            lError;
    DWORD           Idx;
    GUID            Guid;
    HANDLE          hDevInfo;
    SP_DEVINFO_DATA spDevInfoData;
    HKEY            hKeyDevice;
    PCHAR           pTempBuffer;


    //
    // Initialize locals.
    //

    lError      = ERROR_SUCCESS;
    Guid        = GUID_DEVCLASS_IMAGE;
    hDevInfo    = (HANDLE)INVALID_HANDLE_VALUE;
    Idx         = 0;
    hKeyDevice  = (HKEY)INVALID_HANDLE_VALUE;
    pTempBuffer = NULL;

    //
    // Enumerate WIA/STI devices and spew device info.
    //


    hDevInfo = SetupDiGetClassDevs(&Guid, NULL, NULL, DIGCF_PROFILE);
    if(INVALID_HANDLE_VALUE == hDevInfo){
        
        SetupLogError("WIA Migration: Mig9xGetDeviceInfo: ERROR!! Unable to acquire device list.\r\n", LogSevError);
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto Mig9xGetDeviceInfo_return;
        
    } // if(INVALID_HANDLE_VALUE == hDevInfo)

    //
    // Save installed device setting.
    //
    
    spDevInfoData.cbSize = sizeof(spDevInfoData);
    for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++) {

        //
        // Open device registry key.
        //

        hKeyDevice = SetupDiOpenDevRegKey(hDevInfo,
                                          &spDevInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DRV,
                                          KEY_READ);

        if (INVALID_HANDLE_VALUE != hKeyDevice) {
            
            if( (TRUE == IsSti(hKeyDevice))
             && (FALSE == IsKernelDriverRequired(hKeyDevice)) )
            {
                
                //
                // This is STI/WIA device with no kernel driver . Spew required info.
                //
                
                WriteDeviceToFile(hFile, hKeyDevice);
                
            } // if( IsSti(hKeyDevice) && !IsKernelDriverRequired(hKeyDevice))
        } // if (INVALID_HANDLE_VALUE != hKeyDevice) 
    } // for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++)




Mig9xGetDeviceInfo_return:

    if(NULL != pTempBuffer){
        FreeMem(pTempBuffer);
    } // if(NULL != pTempBuffer)

    return lError;
} // Mig9xGetGlobalInfo()



BOOL
IsSti(
    HKEY    hKeyDevice
    )
{
    BOOL    bRet;
    PCHAR   pTempBuffer;
    LONG    lError;
    
    //
    // Initialize local.
    //

    bRet        = FALSE;
    pTempBuffer = NULL;
    lError      = ERROR_SUCCESS;
    
    //
    // See if it's StillImage device.
    //
    
    lError = GetRegData(hKeyDevice, 
                        REGVAL_USDCLASS_A, 
                        &pTempBuffer, 
                        NULL, 
                        NULL);
    
    if( (ERROR_SUCCESS != lError)
     || (NULL == pTempBuffer) )
    {
        //
        // Unable to get "SubClass" data. This is not STI/WIA.
        //
        
        bRet = FALSE;
        goto IsSti_return;
    } // if( (ERROR_SUCCESS != lError) || (NULL == pTempBuffer)
    
    //
    // This is STI/WIA device.
    //

    bRet = TRUE;

IsSti_return:
    
    //
    // Clean up.
    //

    if(NULL != pTempBuffer){
        FreeMem(pTempBuffer);
    } // if(NULL != pTempBuffer)

    return bRet;
} // IsSti()


BOOL
IsKernelDriverRequired(
    HKEY    hKeyDevice
    )
{
    BOOL    bRet;
    PCHAR   pTempBuffer;
    LONG    lError;
    
    //
    // Initialize local.
    //

    bRet        = FALSE;
    pTempBuffer = NULL;
    lError      = ERROR_SUCCESS;
    
    //
    // See if it's StillImage device.
    //
    
    lError = GetRegData(hKeyDevice, 
                        REGVAL_NTMPDRIVER_A, 
                        &pTempBuffer, 
                        NULL, 
                        NULL);
    
    if( (ERROR_SUCCESS != lError)
     || (NULL == pTempBuffer) )
    {
        //
        // Unable to get "NTMPDriver" data. This device doesn't require kernel mode component.
        //

        bRet = FALSE;
        goto IsKernelDriverRequired_return;
    } // if( (ERROR_SUCCESS != lError) || (NULL == pTempBuffer)
    
    //
    // This device requires kernel mode component.
    //

    bRet = TRUE;

IsKernelDriverRequired_return:
    
    //
    // Clean up.
    //

    if(NULL != pTempBuffer){
        FreeMem(pTempBuffer);
    } // if(NULL != pTempBuffer)

    return bRet;
} // IsKernelDriverRequired()

LONG
WriteDeviceToFile(
    HANDLE  hFile,
    HKEY    hKey
    )
{
    LONG    lError;
    PCHAR   pFriendlyName;
    PCHAR   pCreateFileName;
    PCHAR   pInfPath;
    PCHAR   pInfSection;
    DWORD   dwType;
    DWORD   dwSize;
    CHAR    SpewBuffer[256];
    HKEY    hDeviceData;
    
    //
    // Initialize local.
    //

    lError          = ERROR_SUCCESS;
    pFriendlyName   = NULL;
    pCreateFileName = NULL;
    pInfPath        = NULL;
    pInfSection     = NULL;
    dwSize          = 0;
    hDeviceData     = (HKEY)INVALID_HANDLE_VALUE;
    
    memset(SpewBuffer, 0, sizeof(SpewBuffer));

    //
    // Get FriendlyName.
    //
    
    dwSize = 0;
    lError = GetRegData(hKey, NAME_FRIENDLYNAME_A, &pFriendlyName, &dwType, &dwSize);
    if(ERROR_SUCCESS != lError){
        
        //
        // Unable to get FriendlyName.
        //
        
        SetupLogError("WIA Migration: WriteDeviceToFile: ERROR!! Unable to get FriendlyName.\r\n", LogSevError);
        goto WriteDeviceToFile_return;
    } // if(ERROR_SUCCESS != lError)

    if(REG_SZ != dwType){

        //
        // FriendlyName key is other than REG_SZ.
        //

        SetupLogError("WIA Migration: WriteDeviceToFile: ERROR!! FriendlyName is other than REG_SZ.\r\n", LogSevError);
        lError = ERROR_REGISTRY_CORRUPT;
        goto WriteDeviceToFile_return;
    } // if(REG_SZ != dwType)

    if(dwSize > MAX_FRIENDLYNAME+1){
        
        //
        // Too long
        //

        SetupLogError("WIA Migration: WriteDeviceToFile: ERROR!! FriendlyName is too long.\r\n", LogSevError);
        lError = ERROR_REGISTRY_CORRUPT;
        goto WriteDeviceToFile_return;
    }

    //
    // Get CreateFileName.
    //

    dwSize = 0;
    lError = GetRegData(hKey, NAME_CREATEFILENAME_A, &pCreateFileName, &dwType, &dwSize);
    if(ERROR_SUCCESS != lError){
        
        //
        // Unable to get CreateFileName.
        //
        
        SetupLogError("WIA Migration: WriteDeviceToFile: ERROR!! Unable to get CreateFileName.\r\n", LogSevError);
        goto WriteDeviceToFile_return;
    } // if(ERROR_SUCCESS != lError)

    if(REG_SZ != dwType){

        //
        // CreateFileName key is other than REG_SZ.
        //

        SetupLogError("WIA Migration: WriteDeviceToFile: ERROR!! CreateFileName is other than REG_SZ.\r\n", LogSevError);
        lError = ERROR_REGISTRY_CORRUPT;
        goto WriteDeviceToFile_return;
    } // if(REG_SZ != dwType)

    if(dwSize > MAX_PATH+1){
        
        //
        // Too long
        //

        SetupLogError("WIA Migration: WriteDeviceToFile: ERROR!! CreateFileName is too long.\r\n", LogSevError);
        lError = ERROR_REGISTRY_CORRUPT;
        goto WriteDeviceToFile_return;
    }

    //
    // Get InfPath.
    //
    
    dwSize = 0;
    lError = GetRegData(hKey, NAME_INF_PATH_A, &pInfPath, &dwType, &dwSize);
    if(ERROR_SUCCESS != lError){
        
        //
        // Unable to get InfPath.
        //
        
        SetupLogError("WIA Migration: WriteDeviceToFile: ERROR!! Unable to get InfPath.\r\n", LogSevError);
        goto WriteDeviceToFile_return;
    } // if(ERROR_SUCCESS != lError)

    if(REG_SZ != dwType){

        //
        // InfPath key is other than REG_SZ.
        //

        SetupLogError("WIA Migration: WriteDeviceToFile: ERROR!! InfPath is other than REG_SZ.\r\n", LogSevError);
        lError = ERROR_REGISTRY_CORRUPT;
        goto WriteDeviceToFile_return;
    } // if(REG_SZ != dwType)

    if(dwSize > MAX_PATH+1){
        
        //
        // Too long
        //

        SetupLogError("WIA Migration: WriteDeviceToFile: ERROR!! InfPath is too long.\r\n", LogSevError);
        lError = ERROR_REGISTRY_CORRUPT;
        goto WriteDeviceToFile_return;
    }

    //
    // Get InfSection.
    //

    dwSize = 0;
    lError = GetRegData(hKey, NAME_INF_SECTION_A, &pInfSection, &dwType, &dwSize);
    if(ERROR_SUCCESS != lError){
        
        //
        // Unable to get InfSection.
        //
        
        SetupLogError("WIA Migration: WriteDeviceToFile: ERROR!! Unable to get InfSection.\r\n", LogSevError);
        goto WriteDeviceToFile_return;
    } // if(ERROR_SUCCESS != lError)

    if(REG_SZ != dwType){

        //
        // InfSection key is other than REG_SZ.
        //

        SetupLogError("WIA Migration: WriteDeviceToFile: ERROR!! InfSection is other than REG_SZ.\r\n", LogSevError);
        lError = ERROR_REGISTRY_CORRUPT;
        goto WriteDeviceToFile_return;
    } // if(REG_SZ != dwType)

    if(dwSize > MAX_PATH+1){
        
        //
        // Too long
        //

        SetupLogError("WIA Migration: WriteDeviceToFile: ERROR!! InfSection is too long.\r\n", LogSevError);
        lError = ERROR_REGISTRY_CORRUPT;
        goto WriteDeviceToFile_return;
    }

    //
    // Spew device information.
    //

    WriteToFile(hFile, "\r\n");
    WriteToFile(hFile, "\"%s\" = \"%s\"\r\n", NAME_DEVICE_A, NAME_BEGIN_A);
    WriteToFile(hFile, "\"%s\" = \"%s\"\r\n", NAME_FRIENDLYNAME_A, pFriendlyName);
    WriteToFile(hFile, "\"%s\" = \"%s\"\r\n", NAME_CREATEFILENAME_A, pCreateFileName);
    WriteToFile(hFile, "\"%s\" = \"%s\"\r\n", NAME_INF_PATH_A, pInfPath);
    WriteToFile(hFile, "\"%s\" = \"%s\"\r\n", NAME_INF_SECTION_A, pInfSection);

    //
    // Spew DaviceData section.
    //

    lError = RegOpenKey(hKey,
                        REGKEY_DEVICEDATA_A,
                        &hDeviceData);

    if(lError != ERROR_SUCCESS){

        //
        // Unable to open DeviceData or doesn't exist.
        //

    }

    //
    // Spew DeviceData section if exists.
    //

    if(INVALID_HANDLE_VALUE != hDeviceData){
        
        lError = WriteRegistryToFile(hFile, hDeviceData, REGKEY_DEVICEDATA_A);
        
    } // if(INVALID_HANDLE_VALUE != hDeviceData)

    //
    // Indicate the end of device description.
    //

    WriteToFile(hFile, "\"%s\" = \"%s\"\r\n", NAME_DEVICE_A, NAME_END_A);

WriteDeviceToFile_return:
    
    //
    // Clean up.
    //

    if(INVALID_HANDLE_VALUE != hDeviceData){
        RegCloseKey(hDeviceData);
    } //if(INVALID_HANDLE_VALUE != hDeviceData)

    if(NULL != pFriendlyName){
        FreeMem(pFriendlyName);
    }

    if(NULL != pCreateFileName){
        FreeMem(pCreateFileName);
    }

    if(NULL != pInfPath){
        FreeMem(pInfPath);
    }

    if(NULL != pInfSection){
        FreeMem(pInfSection);
    }

    return lError;
} // WriteDeviceToFile()


//
// The following are to make sure if setup changes the header file they
// first tell me (otherwise they will break build of this)
//

P_INITIALIZE_9X     pfnInitialize9x         = Initialize9x;
P_MIGRATE_USER_9X   pfnMigrateUser9x        = MigrateUser9x;
P_MIGRATE_SYSTEM_9X pfnMigrateSystem9x      = MigrateSystem9x;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\test\msqscan\cwia.cpp ===
// CWIA.cpp : implementation file
//

#include "stdafx.h"
#include "CWIA.h"

extern IGlobalInterfaceTable *g_pGIT;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CWIA::CWIA(DATA_ACQUIRE_INFO* pThreadDataInfo, IWiaItem *pRootItem)
{
    m_bFinishedAcquire = FALSE;
    m_pIWiaRootItem   = NULL;
    m_pIWiaFirstChildItem = NULL;
    if(pRootItem != NULL)
        m_pIWiaRootItem = pRootItem;
}

CWIA::~CWIA()
{

}

VOID CWIA::CleanUp()
{
    if(m_pIWiaRootItem != NULL)
        m_pIWiaRootItem->Release();
    if(m_pIWiaFirstChildItem != NULL)
        m_pIWiaFirstChildItem->Release();
}

VOID CWIA::SetRootItem(IWiaItem *pRootItem)
{
    m_pIWiaRootItem = pRootItem;
    SetFirstChild();
}

BOOL CWIA::IsAcquireComplete()
{
    return m_bFinishedAcquire;
}

HRESULT CWIA::EnumerateSupportedFormats(IWiaItem *pIWiaItem, WIA_FORMAT_INFO **ppSupportedFormats, ULONG *pulCount)
{
    HRESULT hr  = E_FAIL;
    *pulCount = 0;
    IWiaDataTransfer *pIWiaDataTransfer = NULL;

    IWiaItem *pTargetItem = pIWiaItem;
    if(pTargetItem == NULL) {

        //
        // use first child of root
        //

        pTargetItem = m_pIWiaFirstChildItem;
    }

    if(pTargetItem != NULL) {

        hr = pTargetItem->QueryInterface(IID_IWiaDataTransfer, (void **)&pIWiaDataTransfer);
        if (SUCCEEDED(hr)) {
            IEnumWIA_FORMAT_INFO *pIEnumWIA_FORMAT_INFO;

            hr = pIWiaDataTransfer->idtEnumWIA_FORMAT_INFO(&pIEnumWIA_FORMAT_INFO);
            if (SUCCEEDED(hr)) {

                hr = pIEnumWIA_FORMAT_INFO->Reset();
                if(SUCCEEDED(hr)) {
                    hr = pIEnumWIA_FORMAT_INFO->GetCount(pulCount);
                    if(SUCCEEDED(hr)) {

                        //
                        // caller of this routine must free the allocated memory
                        //

                        *ppSupportedFormats = (WIA_FORMAT_INFO*)GlobalAlloc(GPTR,(sizeof(WIA_FORMAT_INFO) * (*pulCount)));
                        if(*ppSupportedFormats != NULL) {
                            hr = pIEnumWIA_FORMAT_INFO->Next(*pulCount, *ppSupportedFormats, pulCount);
                            if(hr != S_OK) {

                                //
                                // if this failed, write error to Last error buffer,
                                // and let the procedure wind out
                                //

                                //
                                // free allocated memory, because we failed
                                //

                                GlobalFree(*ppSupportedFormats);

                                //
                                // set pointer to NULL, to clean the exit path for
                                // application
                                //

                                *ppSupportedFormats = NULL;
                                SaveErrorText(TEXT("EnumerateSupportedFileTypes, pIEnumWIA_FORMAT_INFO->Next() failed"));
                            }
                        } else {
                            SaveErrorText(TEXT("EnumerateSupportedFileTypes, out of memory"));
                        }
                    } else {
                        SaveErrorText(TEXT("EnumerateSupportedFileTypes, pIEnumWIA_FORMAT_INFO->GetCount() failed"));
                    }
                } else {
                    SaveErrorText(TEXT("EnumerateSupportedFileTypes, pIEnumWIA_FORMAT_INFO->Reset() failed"));
                }

                //
                // Release supported format enumerator interface
                //

                pIEnumWIA_FORMAT_INFO->Release();
            } else {
                SaveErrorText(TEXT("EnumerateSupportedFileTypes, pIWiaDataTransfer->idtEnumWIA_FORMAT_INFO() failed"));
            }

            //
            // Release data transfer interface
            //

            pIWiaDataTransfer->Release();
        } else {
            SaveErrorText(TEXT("EnumerateSupportedFileTypes, QI for IWiaDataTransfer failed"));
        }
    }
    return hr;
}

BOOL CWIA::SetFirstChild()
{
    HRESULT hr = E_FAIL;
    BOOL bSuccess = FALSE;
    IEnumWiaItem* pIEnumWiaItem = NULL;
    IWiaItem *pIWiaItem = NULL;

    hr = m_pIWiaRootItem->EnumChildItems(&pIEnumWiaItem);
    if(SUCCEEDED(hr)) {

        //
        // get first child item
        //

        hr = pIEnumWiaItem->Next(1,&pIWiaItem,NULL);
        if(hr == S_OK) {

            //
            // item was retrieved, so now assign you first child member
            //

            m_pIWiaFirstChildItem = pIWiaItem;

            //
            // assign success flag
            //

            bSuccess = TRUE;
        } else {

            //
            // save last error, for later request
            //

            SaveErrorText(TEXT("SetFirstChild, pIEnumWiaItem->Next failed"));
            m_hrLastError = hr;
        }

        //
        // release Item enumerator
        //

        pIEnumWiaItem->Release();
    }
    return bSuccess;
}

IWiaItem* CWIA::GetFirstChild()
{
    return m_pIWiaFirstChildItem;
}

IWiaItem* CWIA::GetRootItem()
{
    return m_pIWiaRootItem;
}

LONG CWIA::GetRootItemType(IWiaItem *pRootItem)
{
    IWiaItem *pTargetRootItem = NULL;

    //
    // start with the requested RootItem first
    //

    pTargetRootItem = pRootItem;

    if(pTargetRootItem == NULL) {

        //
        // the requested root item is NULL, so try our
        // internal root item (m_pIWiaRootItem)
        //

        pTargetRootItem = m_pIWiaRootItem;
    }

    //
    // get Root item's type (ie. device type)
    //

    LONG lVal = -888;

    if (pTargetRootItem != NULL) {

        //
        // get an IWiaPropertyStorage Interface
        //

        IWiaPropertyStorage *pIWiaPropStg;
        HRESULT hr = S_OK;
        hr = pTargetRootItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (SUCCEEDED(hr)) {

            //
            // read Root Item's Type
            //

            hr = ReadPropLong(WIA_DIP_DEV_TYPE, pIWiaPropStg, &lVal);
            if(SUCCEEDED(hr)) {

                //
                // release the IWiaPropertyStorage Interface
                //

                pIWiaPropStg->Release();
            } else {

                //
                // save last error, for later request
                //

                SaveErrorText(TEXT("GetRootItemType, ReadPropLong(WIA_DIP_DEV_TYPE) failed"));
                m_hrLastError = hr;
            }
        } else {

            //
            // save last error, for later request
            //

            SaveErrorText(TEXT("GetRootItemType, ReadPropLong(WIA_DIP_DEV_TYPE) failed"));
            m_hrLastError = hr;
        }
    }
    return(GET_STIDEVICE_TYPE(lVal));
}

//
// ERROR PROCESSING
//

VOID CWIA::SaveErrorText(TCHAR *pszText)
{
    lstrcpy(m_szErrorText,pszText);
}

HRESULT CWIA::GetLastWIAError(TCHAR *pszErrorText)
{
    if(pszErrorText != NULL)
        lstrcpy(pszErrorText, m_szErrorText);
    return m_hrLastError;
}

//
// PROPERTY ACCESS HELPERS
//

HRESULT CWIA::WritePropLong(PROPID propid, IWiaPropertyStorage *pIWiaPropStg, LONG lVal)
{
    HRESULT     hr = E_FAIL;
    PROPSPEC    propspec[1];
    PROPVARIANT propvar[1];

    propspec[0].ulKind = PRSPEC_PROPID;
    propspec[0].propid = propid;

    propvar[0].vt   = VT_I4;
    propvar[0].lVal = lVal;

    hr = pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    return hr;
}

HRESULT CWIA::ReadPropLong(PROPID propid, IWiaPropertyStorage  *pIWiaPropStg, LONG *plval)
{
    HRESULT           hr = E_FAIL;
    PROPSPEC          PropSpec[1];
    PROPVARIANT       PropVar[1];
    UINT              cbSize = 0;

    memset(PropVar, 0, sizeof(PropVar));
    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;
    hr = pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
    if (SUCCEEDED(hr)) {
        *plval = PropVar[0].lVal;
    }
    return hr;
}

HRESULT CWIA::ReadRangeLong(IWiaItem *pIWiaItem, PROPID propid, ULONG ulFlag, LONG *plVal)
{
    HRESULT           hr = E_FAIL;
    IWiaItem         *pTargetItem = NULL;
    PROPSPEC          PropSpec[1];
    PROPVARIANT       AttrPropVar;
    ULONG             ulAccessFlags = 0;

    //
    // create a propspec
    //

    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;

    pTargetItem = pIWiaItem;
    if(pTargetItem == NULL) {

        //
        // use first child of root
        //

        pTargetItem = m_pIWiaFirstChildItem;
    }

    if(pTargetItem != NULL) {

        //
        // get an IWiaPropertyStorage Interface
        //

        IWiaPropertyStorage *pIWiaPropStg;
        hr = pTargetItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (SUCCEEDED(hr)) {

            //
            // get property's attributes
            //

            hr = pIWiaPropStg->GetPropertyAttributes(1, PropSpec, &ulAccessFlags, &AttrPropVar);
            if(SUCCEEDED(hr)) {
                *plVal = (LONG)AttrPropVar.caul.pElems[ulFlag];
            } else {

                //
                // save last error, for later request
                //

                SaveErrorText(TEXT("ReadRangeLong, GetPropertyAttributes() failed"));
                m_hrLastError = hr;
            }

            //
            // release the IWiaPropertyStorage Interface
            //

            pIWiaPropStg->Release();
        } else {

            //
            // save last error, for later request
            //

            SaveErrorText(TEXT("ReadRangeLong, QI for IWiaProperyStorage failed"));
            m_hrLastError = hr;
        }
    }
    return hr;
}

HRESULT CWIA::ReadLong(IWiaItem *pIWiaItem, PROPID propid, LONG *plVal)
{
    HRESULT           hr = E_FAIL;
    IWiaItem         *pTargetItem = NULL;
    PROPSPEC          PropSpec[1];

    //
    // create a propspec
    //

    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;

    pTargetItem = pIWiaItem;
    if(pTargetItem == NULL) {

        //
        // use first child of root
        //

        pTargetItem = m_pIWiaFirstChildItem;
    }

    if(pTargetItem != NULL) {

        //
        // get an IWiaPropertyStorage Interface
        //

        IWiaPropertyStorage *pIWiaPropStg;
        hr = pTargetItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (SUCCEEDED(hr)) {

            hr = ReadPropLong(propid,pIWiaPropStg,plVal);
            if(SUCCEEDED(hr)) {

                //
                // read has taken place
                //

            } else {

                //
                // save last error, for later request
                //

                SaveErrorText(TEXT("ReadLong, ReadPropLong() failed"));
                m_hrLastError = hr;
            }
            pIWiaPropStg->Release();
        } else {

            //
            // save last error, for later request
            //

            SaveErrorText(TEXT("ReadLong, QI for IWiaProperyStorage failed"));
            m_hrLastError = hr;
        }
    }
    return hr;
}

HRESULT CWIA::WriteLong(IWiaItem *pIWiaItem, PROPID propid, LONG lVal)
{
    HRESULT           hr = E_FAIL;
    IWiaItem         *pTargetItem = NULL;
    PROPSPEC          PropSpec[1];

    //
    // create a propspec
    //

    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;

    pTargetItem = pIWiaItem;
    if(pTargetItem == NULL) {

        //
        // use first child of root
        //

        pTargetItem = m_pIWiaFirstChildItem;
    }

    if(pTargetItem != NULL) {

        //
        // get an IWiaPropertyStorage Interface
        //

        IWiaPropertyStorage *pIWiaPropStg;
        hr = pTargetItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (SUCCEEDED(hr)) {

            hr = WritePropLong(propid,pIWiaPropStg,lVal);
            if(SUCCEEDED(hr)) {

                //
                // read has taken place
                //

            } else {

                //
                // save last error, for later request
                //

                SaveErrorText(TEXT("WriteLong, WritePropLong() failed"));
                m_hrLastError = hr;
            }
            pIWiaPropStg->Release();
        } else {

            //
            // save last error, for later request
            //

            SaveErrorText(TEXT("WriteLong, QI for IWiaProperyStorage failed"));
            m_hrLastError = hr;
        }
    }
    return hr;
}

HRESULT CWIA::ReadStr(IWiaItem *pIWiaItem, PROPID propid, BSTR *pbstr)
{
    HRESULT           hr = E_FAIL;
    IWiaItem         *pTargetItem = NULL;
    PROPSPEC          PropSpec[1];

    //
    // create a propspec
    //

    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;

    pTargetItem = pIWiaItem;
    if(pTargetItem == NULL) {

        //
        // use first child of root
        //

        pTargetItem = m_pIWiaFirstChildItem;
    }

    if(pTargetItem != NULL) {

        //
        // get an IWiaPropertyStorage Interface
        //

        IWiaPropertyStorage *pIWiaPropStg;
        hr = pTargetItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (SUCCEEDED(hr)) {

            hr = ReadPropStr(propid,pIWiaPropStg,pbstr);
            if(SUCCEEDED(hr)) {

                //
                // read has taken place
                //

            } else {

                //
                // save last error, for later request
                //

                SaveErrorText(TEXT("ReadStr, ReadPropStr() failed"));
                m_hrLastError = hr;
            }
            pIWiaPropStg->Release();
        } else {

            //
            // save last error, for later request
            //

            SaveErrorText(TEXT("ReadStr, QI for IWiaProperyStorage failed"));
            m_hrLastError = hr;
        }
    }
    return hr;
}

HRESULT CWIA::ReadGuid(IWiaItem *pIWiaItem, PROPID propid, GUID *pguidVal)
{
    HRESULT           hr = E_FAIL;
    IWiaItem         *pTargetItem = NULL;
    PROPSPEC          PropSpec[1];

    //
    // create a propspec
    //

    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;

    pTargetItem = pIWiaItem;
    if(pTargetItem == NULL) {

        //
        // use first child of root
        //

        pTargetItem = m_pIWiaFirstChildItem;
    }

    if(pTargetItem != NULL) {

        //
        // get an IWiaPropertyStorage Interface
        //

        IWiaPropertyStorage *pIWiaPropStg;
        hr = pTargetItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (SUCCEEDED(hr)) {

            hr = ReadPropGUID(propid,pIWiaPropStg,pguidVal);
            if(SUCCEEDED(hr)) {

                //
                // read has taken place
                //

            } else {

                //
                // save last error, for later request
                //

                SaveErrorText(TEXT("ReadGuid, ReadPropGuid() failed"));
                m_hrLastError = hr;
            }
            pIWiaPropStg->Release();
        } else {

            //
            // save last error, for later request
            //

            SaveErrorText(TEXT("ReadGuid, QI for IWiaProperyStorage failed"));
            m_hrLastError = hr;
        }
    }
    return hr;
}

HRESULT CWIA::WriteGuid(IWiaItem *pIWiaItem, PROPID propid, GUID guidVal)
{
    HRESULT           hr = E_FAIL;
    IWiaItem         *pTargetItem = NULL;
    PROPSPEC          PropSpec[1];

    //
    // create a propspec
    //

    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;

    pTargetItem = pIWiaItem;
    if(pTargetItem == NULL) {

        //
        // use first child of root
        //

        pTargetItem = m_pIWiaFirstChildItem;
    }

    if(pTargetItem != NULL) {

        //
        // get an IWiaPropertyStorage Interface
        //

        IWiaPropertyStorage *pIWiaPropStg;
        hr = pTargetItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (SUCCEEDED(hr)) {

            hr = WritePropGUID(propid,pIWiaPropStg,guidVal);
            if(SUCCEEDED(hr)) {

                //
                // read has taken place
                //

            } else {

                //
                // save last error, for later request
                //

                SaveErrorText(TEXT("WriteGuid, WritePropGuid() failed"));
                m_hrLastError = hr;
            }
            pIWiaPropStg->Release();
        } else {

            //
            // save last error, for later request
            //

            SaveErrorText(TEXT("WriteGuid, QI for IWiaProperyStorage failed"));
            m_hrLastError = hr;
        }
    }
    return hr;
}

HRESULT CWIA::DoBandedTransfer(DATA_ACQUIRE_INFO* pDataAcquireInfo)
{
    HRESULT hr = S_OK;

    //
    // Write TYMED value to callback
    //

    hr = WriteLong(m_pIWiaFirstChildItem,WIA_IPA_TYMED,TYMED_CALLBACK);

    //
    // get IWiaDatatransfer interface
    //

    IWiaDataTransfer *pIBandTran = NULL;
    hr = m_pIWiaFirstChildItem->QueryInterface(IID_IWiaDataTransfer, (void **)&pIBandTran);
    if (SUCCEEDED(hr)) {

        //
        // create Banded callback
        //

        IWiaDataCallback* pIWiaDataCallback = NULL;
        CWiaDataCallback* pCBandedCB = new CWiaDataCallback();
        if (pCBandedCB) {
            hr = pCBandedCB->QueryInterface(IID_IWiaDataCallback,(void **)&pIWiaDataCallback);
            if (SUCCEEDED(hr)) {
                WIA_DATA_TRANSFER_INFO  wiaDataTransInfo;

                pCBandedCB->Initialize(pDataAcquireInfo);

                ZeroMemory(&wiaDataTransInfo, sizeof(WIA_DATA_TRANSFER_INFO));
                wiaDataTransInfo.ulSize = sizeof(WIA_DATA_TRANSFER_INFO);
                wiaDataTransInfo.ulBufferSize = 524288;//262144; // calculate, or determine buffer size

                hr = pIBandTran->idtGetBandedData(&wiaDataTransInfo, pIWiaDataCallback);
                m_bFinishedAcquire = TRUE;
                pIBandTran->Release();
                if (hr == S_OK) {
                    OutputDebugString(TEXT("IWiaData Transfer.(CALLBACK)..Success\n"));
                } else if (hr == S_FALSE) {
                    OutputDebugString(TEXT("IWiaData Transfer.(CALLBACK)..Canceled by user\n"));
                } else {
                    OutputDebugString(TEXT("* idtGetBandedData() Failed\n"));
                }

                //
                // release Callback object
                //

                pCBandedCB->Release();
            } else
                // TEXT("* pCBandedCB->QueryInterface(IID_IWiaDataCallback) Failed");
                return hr;
        } else
            return hr;
            // TEXT("* pCBandedCB failed to create..");
    } else
        return hr;
        // TEXT("* pIWiaItem->QueryInterface(IID_IWiaDataTransfer) Failed");
    return S_OK;
}

HRESULT CWIA::DoFileTransfer(DATA_ACQUIRE_INFO* pDataAcquireInfo)
{
    HRESULT hr = S_OK;

    //
    // Write TYMED value to file
    //

    hr = WriteLong(m_pIWiaFirstChildItem,WIA_IPA_TYMED,TYMED_FILE);

    //
    // get IWiaDatatransfer interface
    //

    IWiaDataTransfer *pIBandTran = NULL;
    hr = m_pIWiaFirstChildItem->QueryInterface(IID_IWiaDataTransfer, (void **)&pIBandTran);
    if (SUCCEEDED(hr)) {

        //
        // create Banded callback
        //

        IWiaDataCallback* pIWiaDataCallback = NULL;
        CWiaDataCallback* pCBandedCB = new CWiaDataCallback();
        if (pCBandedCB) {
            hr = pCBandedCB->QueryInterface(IID_IWiaDataCallback,(void **)&pIWiaDataCallback);
            if (SUCCEEDED(hr)) {

                //
                // fill out STGMEDIUM
                //

                STGMEDIUM StgMedium;
                ZeroMemory(&StgMedium, sizeof(STGMEDIUM));

                StgMedium.tymed          = TYMED_FILE;
                StgMedium.lpszFileName   = NULL;
                StgMedium.pUnkForRelease = NULL;
                StgMedium.hGlobal        = NULL;

                pCBandedCB->Initialize(pDataAcquireInfo);

                hr = pIBandTran->idtGetData(&StgMedium,pIWiaDataCallback);
                m_bFinishedAcquire = TRUE;
                pIBandTran->Release();

                if (hr == S_OK) {

                    OutputDebugString(TEXT("IWiaData Transfer.(FILE)..Success\n"));

                    //
                    // We have completed the transfer...so now move the temporary file into
                    // the needed location, with the users requested file name.
                    //

                    CString WIATempFile = StgMedium.lpszFileName;
                    if(!CopyFile(WIATempFile,pDataAcquireInfo->szFileName,FALSE)){
                        OutputDebugString(TEXT("Failed to copy temp file.."));
                    }

                    //
                    // delete WIA created TEMP file
                    //

                    DeleteFile(WIATempFile);

                } else if (hr == S_FALSE) {
                    OutputDebugString(TEXT("IWiaData Transfer.(FILE)..Canceled by user\n"));
                } else {
                    OutputDebugString(TEXT("* idtGetData() Failed\n"));
                }

                //
                // release Callback object
                //

                pCBandedCB->Release();
            } else
                // TEXT("* pCBandedCB->QueryInterface(IID_IWiaDataCallback) Failed");
                return hr;
        } else
            return hr;
            // TEXT("* pCBandedCB failed to create..");
    } else
        return hr;
        // TEXT("* pIWiaItem->QueryInterface(IID_IWiaDataTransfer) Failed");
    return hr;
}

HRESULT CWIA::WritePropGUID(PROPID propid, IWiaPropertyStorage *pIWiaPropStg, GUID guidVal)
{
    HRESULT     hr = E_FAIL;
    PROPSPEC    propspec[1];
    PROPVARIANT propvar[1];

    propspec[0].ulKind = PRSPEC_PROPID;
    propspec[0].propid = propid;

    propvar[0].vt   = VT_CLSID;
    propvar[0].puuid = &guidVal;

    hr = pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    return hr;
}

HRESULT CWIA::ReadPropGUID(PROPID propid, IWiaPropertyStorage *pIWiaPropStg, GUID *pguidVal)
{
    HRESULT           hr = E_FAIL;
    PROPSPEC          PropSpec[1];
    PROPVARIANT       PropVar[1];
    UINT              cbSize = 0;

    memset(PropVar, 0, sizeof(PropVar));
    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;
    hr = pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
    if (SUCCEEDED(hr)) {
        pguidVal = PropVar[0].puuid;
    }
    return hr;
}

HRESULT CWIA::ReadPropStr(PROPID propid,IWiaPropertyStorage  *pIWiaPropStg,BSTR *pbstr)
{
    HRESULT     hr = S_OK;
    PROPSPEC    PropSpec[1];
    PROPVARIANT PropVar[1];
    UINT        cbSize = 0;

    *pbstr = NULL;
    memset(PropVar, 0, sizeof(PropVar));
    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;
    hr = pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
    if (SUCCEEDED(hr)) {
        if (PropVar[0].pwszVal) {
            *pbstr = SysAllocString(PropVar[0].pwszVal);
        } else {
            *pbstr = SysAllocString(L"");
        }
        if (*pbstr == NULL) {
            hr = E_OUTOFMEMORY;
        }
        PropVariantClear(PropVar);
    }
    return hr;
}

HRESULT CWIA::WritePropStr(PROPID propid, IWiaPropertyStorage  *pIWiaPropStg, BSTR bstr)
{
    HRESULT     hr = S_OK;
    PROPSPEC    propspec[1];
    PROPVARIANT propvar[1];

    pr