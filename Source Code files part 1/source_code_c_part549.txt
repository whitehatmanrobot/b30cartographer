nel32.
    See nt/base/dload where dload.lib is built.
    See nt/net/published/lib/dload where dloadnet.lib is built.
    Both are linked into kernel32 and provide the failure hooks which support
    delay loading (via /DELAYLOAD linker switch) various DLLs in the system.
   
Author:
    
    Shaun Cox (shaunco) 10-Mar-2000

Environment:

    User mode only.

Revision History:
    conradc   May 3, 2001 
	      Copy from nt\public\internal\base\inc\dloaddef.h because there is problem in 	      linking when using const with DLOAD_PROCNAME_MAP. 


--*/

#pragma once

#define celems(_x)          (sizeof(_x) / sizeof(_x[0]))


typedef struct _DLOAD_PROCNAME_ENTRY
{
    LPCSTR  pszProcName;
    FARPROC pfnProc;
} DLOAD_PROCNAME_ENTRY;

#define DLPENTRY(_fcn)  { #_fcn, (FARPROC)_fcn },

#define DEFINE_PROCNAME_ENTRIES(_dllbasename) \
    const DLOAD_PROCNAME_ENTRY c_PmapEntries_##_dllbasename [] =


typedef struct _DLOAD_PROCNAME_MAP
{
    UINT                        NumberOfEntries;
    const DLOAD_PROCNAME_ENTRY* pProcNameEntry;
} DLOAD_PROCNAME_MAP;

#define DECLARE_PROCNAME_MAP(_dllbasename) \
    extern  DLOAD_PROCNAME_MAP c_Pmap_##_dllbasename;

#define DEFINE_PROCNAME_MAP(_dllbasename) \
    DLOAD_PROCNAME_MAP c_Pmap_##_dllbasename = \
    { \
        celems(c_PmapEntries_##_dllbasename), \
        c_PmapEntries_##_dllbasename \
    };




typedef struct _DLOAD_ORDINAL_ENTRY
{
    DWORD   dwOrdinal;
    FARPROC pfnProc;
} DLOAD_ORDINAL_ENTRY;

#define DLOENTRY(_ord, _fcn)  { _ord, (FARPROC)_fcn },

#define DEFINE_ORDINAL_ENTRIES(_dllbasename) \
    const DLOAD_ORDINAL_ENTRY c_OmapEntries_##_dllbasename [] =


typedef struct _DLOAD_ORDINAL_MAP
{
    UINT                        NumberOfEntries;
    const DLOAD_ORDINAL_ENTRY*  pOrdinalEntry;
} DLOAD_ORDINAL_MAP;

#define DECLARE_ORDINAL_MAP(_dllbasename) \
    extern const DLOAD_ORDINAL_MAP c_Omap_##_dllbasename;

#define DEFINE_ORDINAL_MAP(_dllbasename) \
    const DLOAD_ORDINAL_MAP c_Omap_##_dllbasename = \
    { \
        celems(c_OmapEntries_##_dllbasename), \
        c_OmapEntries_##_dllbasename \
    };


typedef struct _DLOAD_DLL_ENTRY
{
    LPCSTR                      pszDll;
    const DLOAD_PROCNAME_MAP*   pProcNameMap;
    const DLOAD_ORDINAL_MAP*    pOrdinalMap;
} DLOAD_DLL_ENTRY;

typedef struct _DLOAD_DLL_MAP
{
    UINT                    NumberOfEntries;
    const DLOAD_DLL_ENTRY*  pDllEntry;
} DLOAD_DLL_MAP;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\ev.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Ev.h

Abstract:
    Event Report public interface

Author:
    Uri Habusha (urih) 04-May-99

--*/

#pragma once

#ifndef _MSMQ_Ev_H_
#define _MSMQ_Ev_H_

VOID
EvInitialize(
    LPCWSTR ApplicationName
    );

VOID
__cdecl
EvReport(
    DWORD EventId,
    WORD NoOfStrings,
    ... 
    );

VOID
__cdecl
EvReportWithError(
    DWORD EventId,
    HRESULT Error,
    WORD NoOfStrings,
    ... 
    );

VOID
EvReport(
    DWORD EventId
    );

VOID
EvReportWithError(
    DWORD EventId,
    HRESULT Error
    );

VOID 
EvSetup(
    LPCWSTR ApplicationName,
    LPCWSTR ReportModuleName
    );


#endif // _MSMQ_Ev_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\ex.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Ex.h

Abstract:
    Exceutive public interface

Author:
    Erez Haba (erezh) 03-Jan-99

--*/

#pragma once

#ifndef _MSMQ_Ex_H_
#define _MSMQ_Ex_H_

#include <TimeTypes.h>

class EXOVERLAPPED;
class CTimer;


VOID
ExInitialize(
    DWORD ThreadCount
    );


HANDLE
ExIOCPort(
    VOID
    );


VOID
ExAttachHandle(
    HANDLE Handle
    );


VOID
ExPostRequest(
    EXOVERLAPPED* pOverlapped
    );

VOID
ExSetTimer(
    CTimer* pTimer,
    const CTimeDuration& Timeout
    );

VOID
ExSetTimer(
    CTimer* pTimer,
    const CTimeInstant& ExpirationTime
    );

BOOL
ExCancelTimer(
    CTimer* pTimer
    );

CTimeInstant
ExGetCurrentTime(
    VOID
    );


//---------------------------------------------------------
//
// Exceutive Overlapped
//
//---------------------------------------------------------
class EXOVERLAPPED : public OVERLAPPED {
public:

    typedef VOID (WINAPI *COMPLETION_ROUTINE)(EXOVERLAPPED* pov);

public:
    EXOVERLAPPED(
            COMPLETION_ROUTINE pfnSuccessRoutine,
            COMPLETION_ROUTINE pfnFailureRoutine
            );

    VOID SetStatus(HRESULT rc);
    HRESULT GetStatus() const;

    VOID CompleteRequest();
    VOID CompleteRequest(HRESULT rc);

private:
    COMPLETION_ROUTINE m_pfnSuccess;
    COMPLETION_ROUTINE m_pfnFailure;
};


inline
EXOVERLAPPED::EXOVERLAPPED(
    COMPLETION_ROUTINE pfnSuccessRoutine,
    COMPLETION_ROUTINE pfnFailureRoutine
    ) :
    m_pfnSuccess(pfnSuccessRoutine),
    m_pfnFailure(pfnFailureRoutine)
{
	ASSERT(("Illegal successroutine", (pfnSuccessRoutine != NULL)));
	ASSERT(("Illegal failure routine", (pfnFailureRoutine !=NULL)));

    memset(static_cast<OVERLAPPED*>(this), 0, sizeof(OVERLAPPED));
}


inline VOID EXOVERLAPPED::SetStatus(HRESULT rc)
{
    Internal = rc;
}


inline HRESULT EXOVERLAPPED::GetStatus() const
{
    return static_cast<HRESULT>(Internal);
}


inline VOID EXOVERLAPPED::CompleteRequest(HRESULT rc)
{
    SetStatus(rc);
    CompleteRequest();
}


//---------------------------------------------------------
//
// Exceutive Timer
//
//---------------------------------------------------------
class CTimer {
public:

    friend class CScheduler;
    typedef VOID (WINAPI *CALLBACK_ROUTINE)(CTimer* pTimer);

public:

    CTimer(CALLBACK_ROUTINE pfnCallback);
    ~CTimer();

    bool InUse() const;

private:
    const CTimeInstant& GetExpirationTime() const;
    void SetExpirationTime(const CTimeInstant& ExpirationTime);

private:
    CTimer(const CTimer&);
    CTimer& operator=(const CTimer&);

private:
    EXOVERLAPPED m_ov;
    CTimeInstant m_ExpirationTime;

public:
    LIST_ENTRY m_link;

};


inline
CTimer::CTimer(
    CALLBACK_ROUTINE pfnCallback
    ) :
    m_ov(reinterpret_cast<EXOVERLAPPED::COMPLETION_ROUTINE>(pfnCallback),
         reinterpret_cast<EXOVERLAPPED::COMPLETION_ROUTINE>(pfnCallback)),
    m_ExpirationTime(CTimeInstant::MinValue())
{
    m_link.Flink = NULL;
    m_link.Blink = NULL;


    //
    // Verify that the overlapped is the first CTimer member. This is required
    // since the Calback routine is casted to the overlapped completion routine
    //
    //
    C_ASSERT(FIELD_OFFSET(CTimer, m_ov) == 0);
}


inline CTimer::~CTimer()
{
    ASSERT(MmIsStaticAddress(this) || !InUse());
}


inline bool CTimer::InUse() const
{
    return (m_link.Flink != NULL);
}

#endif // _MSMQ_Ex_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\libpch.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    libpch.h

Abstract:

    Include the *real* libpch header.

Author:

    Shai Kariv    (shaik)   03-Jun-2000

Revision History:

--*/

#include "..\libpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\doublekeymap.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:
    doublekeymap.h

Abstract:
    CDoubleKeyMap implements double key mapping template.  It enables searching a data 
    according each one of the keys.

    CDoubleKeyMap is defined as a combination of 2 maps that the value of each one of them 
    is a set of the opposite key type. Following diagram illustrates the internal 
    datastructure.


     MAP1                                           MAP2

     KEY      VALUE (set)                           KEY      VALUE (set)
    +-------+---------------------------+          +-------+---------------------------+
    |       |                           |          |       |                           |
    | K1_1  | K2_1, K2_2, K2_N          |          | K2_1  | K1_1, K1_3                |
    |       |                           |          |       |                           |
    +-------+---------------------------+          +-------+---------------------------+
    |       |                           |          |       |                           |
    | K1_2  | K2_3                      |          | K2_2  | K1_1                      |
    |       |                           |          |       |                           |
    +-------+---------------------------+          +-------+---------------------------+
    |       |                           |          |       |                           |
    | K1_3  | K2_1, K2_3                |          | K2_3  | K1_2, K1_3                          |
    |       |                           |          |       |                           |
    +-------+---------------------------+          +-------+---------------------------+
        o                                              o
        o                                              o
        o                                              o
    +-------+---------------------------+          +-------+---------------------------+
    |       |                           |          |       |                           |
    |       |                           |          | K2_N  |  K1_1                     |
    |       |                           |          |       |                           |
    +-------+---------------------------+          +-------+---------------------------+

    CDoubleKeyMap  implements the basic operation, Insert of 2 elements to the map, erase
    and find.

    CDoubleKeyMap isn't multithread sfae. It is the user reponsibility.

    In the future instead of inserting the data to the set we can insert iterator in the 
    opposite map.

Author:
    Uri Habusha (urih) 20-Oct-2000

--*/

#pragma once

#ifndef __DOUBLEKEYMAP_H__
#define __DOUBLEKEYMAP_H__

template<class Key1, class Key2, class Pred1 = std::less<Key1>, class Pred2 = std::less<Key2>, class A1 = std::allocator<Key1>, class A2 = std::allocator<Key2> >
class CDoubleKeyMap
{
public:
    typedef std::set< Key1, Pred1, A1 > KEY1SET;
    typedef std::set< Key2, Pred2, A2 > KEY2SET;

private:
    typedef std::map< Key1, KEY2SET ,Pred1 ,A1 > MAP_KEY1_TO_KEY2SET;	
    typedef std::map< Key2, KEY1SET ,Pred2 ,A2 > MAP_KEY2_TO_KEY1SET;	

public:
    explicit CDoubleKeyMap(
        const Pred1& pred1 = Pred1(), 
        const Pred2& pred2 = Pred2(), 
        const A1& a1 = A1(),
        const A2& a2 = A2()
        ):
        m_mapKey1ToKey2(pred1,a1),
        m_mapKey2ToKey1(pred2,a2)
	{
	}


	void insert(const Key1& k1, const Key2& k2)
    {
        InsertToFirstMap(k1, k2);
        try
        {
            InsertToSecondMap(k2, k1);
        }
        catch(const std::exception&)
        {
            //
            // cleanup previous data
            //
            RemoveFromFirstMap(k1, k2);
            throw;
        }
    }

	
	void erase(const Key1& k1, const Key2& k2)
    {
        RemoveFromFirstMap(k1, k2);
        RemoveFromSecondMap(k2, k1);
    }


    void erase_key1(const Key1& k1)
    {
        MAP_KEY1_TO_KEY2SET::iterator it = m_mapKey1ToKey2.find(k1);
    
        if (it == m_mapKey1ToKey2.end())
            return;
    
        KEY2SET& s2 = it->second;

        for(KEY2SET::iterator it1 = s2.begin(); it1 != s2.end(); ++it1)
        {
            RemoveFromSecondMap(*it1, k1);
        }

        m_mapKey1ToKey2.erase(it);
    }


    void erase_key2(const Key2& k2)
    {
        MAP_KEY2_TO_KEY1SET::iterator it = m_mapKey2ToKey1.find(k2);
    
        if (it == m_mapKey2ToKey1.end())
            return;
    
        KEY1SET& s1 = it->second;

        for(KEY1SET::iterator it1 = s1.begin(); it1 != s1.end(); ++it1)
        {
            RemoveFromFirstMap(*it1, k2);
        }

        m_mapKey2ToKey1.erase(it);
    }

	
    KEY2SET get_key2set(const Key1& k1) const
    {
        MAP_KEY1_TO_KEY2SET::const_iterator it = m_mapKey1ToKey2.find(k1);
    
        if (it == m_mapKey1ToKey2.end())
        {
            return KEY2SET();
        }
        return it->second;
    }

    
    KEY1SET get_key1set(const Key2& k2) const
    {
        MAP_KEY2_TO_KEY1SET::const_iterator it = m_mapKey2ToKey1.find(k2);
    
        if (it == m_mapKey2ToKey1.end())
        {
            return KEY1SET();
        }

        return it->second;
    }


    bool key1_empty(const Key1& key) const
    {
        return (m_mapKey1ToKey2.find(key) == m_mapKey1ToKey2.end());
    }


    bool key2_empty(const Key2& key) const
    {
        return (m_mapKey2ToKey1.find(key) == m_mapKey2ToKey1.end());
    }


private:
    static bool Insert(KEY1SET& s1, const Key1& v) 
    {
        return s1.insert(v).second;
    }


    static bool Insert(KEY2SET& s2, const Key2& v)
    {
        return s2.insert(v).second;
    }


    void InsertToFirstMap(const Key1& k1, const Key2& k2)
    {
        MAP_KEY1_TO_KEY2SET::iterator it1 = m_mapKey1ToKey2.find(k1);

        if (it1 != m_mapKey1ToKey2.end())
        {
            bool f = Insert(it1->second, k2);
            ASSERT(("Second key already associated to first key", f));
            DBG_USED(f);

            return;
        }

        KEY2SET val2;
        val2.insert(k2);

        m_mapKey1ToKey2.insert(MAP_KEY1_TO_KEY2SET::value_type(k1, val2));
    }


    void InsertToSecondMap(const Key2& k2, const Key1& k1)
    {
        MAP_KEY2_TO_KEY1SET::iterator it = m_mapKey2ToKey1.find(k2);

        if (it != m_mapKey2ToKey1.end())
        {
            bool f = Insert(it->second, k1);
            ASSERT(("First key already associated to second key", f));
            DBG_USED(f);

            return;
        }

        KEY1SET val1;
        val1.insert(k1);
    
        m_mapKey2ToKey1.insert(MAP_KEY2_TO_KEY1SET::value_type(k2, val1));
    }


    void RemoveFromFirstMap(const Key1& k1, const Key2& k2)
    {
        MAP_KEY1_TO_KEY2SET::iterator it = m_mapKey1ToKey2.find(k1);
        ASSERT (it != m_mapKey1ToKey2.end());

        (it->second).erase(k2);
        if ((it->second).empty())
        {
            m_mapKey1ToKey2.erase(it);
        }
    }


    void RemoveFromSecondMap(const Key2& k2, const Key1& k1)
    {
        MAP_KEY2_TO_KEY1SET::iterator it = m_mapKey2ToKey1.find(k2);
        ASSERT (it != m_mapKey2ToKey1.end());

        (it->second).erase(k1);
        if ((it->second).empty())
        {
            m_mapKey2ToKey1.erase(it);
        }
    }


private:
    MAP_KEY1_TO_KEY2SET m_mapKey1ToKey2;	
	MAP_KEY2_TO_KEY1SET m_mapKey2ToKey1;
};


#endif //   __DOUBLEKEYMAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\lim.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    lim.h

Abstract:
    Define numeric limits to types not defined in limit standard header.
	This header extend limit standard header.

Author:
    Gil Shafriri (gilsh)

--*/


#pragma once

#ifndef LIM_H
#define LIM_H

#include <limits>

namespace std
{

// CLASS numeric_limits<__int64>
template <>
class  numeric_limits<__int64> : public _Num_int_base 
{
public:
	typedef __int64 _Ty;
	static _Ty (__cdecl min)() _THROW0()
	{
		return (_I64_MIN); 
	}

	static _Ty (__cdecl max)() _THROW0()
	{
		return (_I64_MAX); 
	};

};
 


// CLASS numeric_limits<unsigned __int64>
template <>
class numeric_limits<unsigned __int64> : public _Num_int_base 
{
public:
	typedef unsigned __int64 _Ty;
	static _Ty (__cdecl min)() _THROW0()
	{
		return (0); 
	}

	static _Ty (__cdecl max)() _THROW0()
	{
		return (_UI64_MAX); 
	
	};
};

}// namesoace std

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\fntoken.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    fntoken.h

Abstract:
    Format Name tokens

Author:
    Erez Haba (erezh) 17-Jan-1997

Revision History:

--*/

#ifndef __FNTOKEN_H
#define __FNTOKEN_H

#include <mqmacro.h>


#define GUID_ELEMENTS(p) \
    (p)->Data1, (p)->Data2, (p)->Data3,\
    (p)->Data4[0], (p)->Data4[1], (p)->Data4[2], (p)->Data4[3],\
    (p)->Data4[4], (p)->Data4[5], (p)->Data4[6], (p)->Data4[7]

//
//  GUID_STR_LENGTH is the buffer size required for string guid
//
#define GUID_FORMAT_A	"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"
#define GUID_FORMAT     L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"
#define GUID_STR_LENGTH (8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12)



//
//  Format Name prefix tokens
//
#define FN_PUBLIC_TOKEN         L"PUBLIC"
#define FN_PUBLIC_TOKEN_LEN     STRLEN(FN_PUBLIC_TOKEN)

#define FN_DL_TOKEN             L"DL"
#define FN_DL_TOKEN_LEN         STRLEN(FN_DL_TOKEN)

#define FN_PRIVATE_TOKEN        L"PRIVATE"
#define FN_PRIVATE_TOKEN_LEN    STRLEN(FN_PRIVATE_TOKEN)

#define FN_PRIVATE_$_TOKEN        L"PRIVATE$"
#define FN_PRIVATE_$_TOKEN_LEN    STRLEN(FN_PRIVATE_$_TOKEN)



#define FN_DIRECT_TOKEN         L"DIRECT"
#define FN_DIRECT_TOKEN_LEN     STRLEN(FN_DIRECT_TOKEN)

#define FN_MACHINE_TOKEN        L"MACHINE"
#define FN_MACHINE_TOKEN_LEN    STRLEN(FN_MACHINE_TOKEN)

#define FN_CONNECTOR_TOKEN      L"CONNECTOR"
#define FN_CONNECTOR_TOKEN_LEN  STRLEN(FN_CONNECTOR_TOKEN)

#define FN_MULTICAST_TOKEN      L"MULTICAST"
#define FN_MULTICAST_TOKEN_LEN  STRLEN(FN_MULTICAST_TOKEN)




#define FN_PRIVATE_QUEUE_PATH_INDICATIOR L"PRIVATE$\\"
#define FN_PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH \
    STRLEN(FN_PRIVATE_QUEUE_PATH_INDICATIOR)

#define FN_SYSTEM_QUEUE_PATH_INDICATIOR L"SYSTEM$"
#define FN_SYSTEM_QUEUE_PATH_INDICATIOR_LENGTH \
    STRLEN(FN_SYSTEM_QUEUE_PATH_INDICATIOR)

//
//  Format Name suffix tokens
//
#define FN_NONE_SUFFIX          L""
#define FN_NONE_SUFFIX_LEN      STRLEN(FN_NONE_SUFFIX)

#define FN_JOURNAL_SUFFIX       L";JOURNAL"
#define FN_JOURNAL_SUFFIX_LEN   STRLEN(FN_JOURNAL_SUFFIX)

#define FN_DEADLETTER_SUFFIX    L";DEADLETTER"
#define FN_DEADLETTER_SUFFIX_LEN STRLEN(FN_DEADLETTER_SUFFIX)

#define FN_DEADXACT_SUFFIX      L";DEADXACT"
#define FN_DEADXACT_SUFFIX_LEN  STRLEN(FN_DEADXACT_SUFFIX)

#define FN_XACTONLY_SUFFIX      L";XACTONLY"
#define FN_XACTONLY_SUFFIX_LEN  STRLEN(FN_XACTONLY_SUFFIX)


//
//  Format Name direct infix tokens
//
#define FN_DIRECT_OS_TOKEN      L"OS:"
#define FN_DIRECT_OS_TOKEN_LEN  STRLEN(FN_DIRECT_OS_TOKEN)

#define FN_DIRECT_TCP_TOKEN     L"TCP:"
#define FN_DIRECT_TCP_TOKEN_LEN STRLEN(FN_DIRECT_TCP_TOKEN)

#define FN_DIRECT_HTTP_TOKEN    L"HTTP://"
#define FN_DIRECT_HTTP_TOKEN_LEN STRLEN(FN_DIRECT_HTTP_TOKEN)

#define FN_DIRECT_HTTPS_TOKEN   L"HTTPS://"
#define FN_DIRECT_HTTPS_TOKEN_LEN STRLEN(FN_DIRECT_HTTPS_TOKEN)

//
// MSMQ: is used to prefix msmq format names in the srmp message.
//
const   WCHAR FN_MSMQ_URI_PREFIX_TOKEN[] = L"MSMQ:";
const   size_t FN_MSMQ_URI_PREFIX_TOKEN_LEN = STRLEN(FN_MSMQ_URI_PREFIX_TOKEN);




//
// This token represents the msmq namespace - comes in http format between the
// computer name and the queue name.
// Sample http direct format name - DIRECT=HTTP://mycomputer.mycompany.com\MSMQ\myqueue
//
#define FN_MSMQ_HTTP_NAMESPACE_TOKEN   L"MSMQ"
#define FN_MSMQ_HTTP_NAMESPACE_TOKEN_LEN STRLEN(FN_MSMQ_HTTP_NAMESPACE_TOKEN)

#define FN_PRIVATE_ID_FORMAT   L"%08x"
#define FN_PRIVATE_ID_FORMAT_LEN (8)
#define FN_SUFFIX_FORMAT       L"%s"
#define FN_DOMAIN_FORMAT       L"%s"


//
//  Format Names tokens
//
#define FN_EQUAL_SIGN   L"="
#define FN_EQUAL_SIGN_C L'='

#define FN_AT_SIGN      L"@"
#define FN_AT_SIGN_C    L'@'

#define FN_DELIMITER_C      L'\\'
#define FN_LOCAL_MACHINE_C  L'.'

#define FN_PRIVATE_SEPERATOR    L"\\"
#define FN_PRIVATE_SEPERATOR_C  L'\\'

#define FN_SUFFIX_DELIMITER_C   L';'

#define FN_HTTP_SEPERATORS   L"\\/"
#define FN_HTTP_SEPERATOR_C   L'/'
#define FN_HTTP_PORT_SEPERATOR L":"

#define FN_MQF_SEPARATOR     L","
#define FN_MQF_SEPARATOR_C   L','

#endif //  __FNTOKEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\fn.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Fn.h

Abstract:
    Format Name Parsing public interface

Author:
    Nir Aides (niraides) 21-May-00

--*/



#pragma once



#ifndef _MSMQ_Fn_H_
#define _MSMQ_Fn_H_



#include "mqwin64.h"
#include <qformat.h>
#include <mqexception.h>
#include <fntoken.h>
#include <xstr.h>

class bad_format_name: public exception
{
public:
	bad_format_name(LPCWSTR p) : m_p(p)
	{
	}

	LPCWSTR Location() const
	{
		return m_p;
	}

private:
	LPCWSTR m_p;
};


VOID
FnInitialize(
	VOID
	);



//
// ------------------ MQF expansion routines ---------------------
//

VOID
FnExpandMqf(
	ULONG nTopLevelMqf,
	const QUEUE_FORMAT TopLevelMqf[],
	ULONG* pnLeafMqf,
	QUEUE_FORMAT** ppLeafMqf
	);


class CMqfDisposer
{
public:

    CMqfDisposer(
        ULONG        nMqf,
        QUEUE_FORMAT mqf[]
        ) :
        m_nMqf(nMqf),
        m_mqf(mqf)
    {
    }

    ~CMqfDisposer()
    {
        for ( ; m_nMqf-- != 0; )
        {
            m_mqf[m_nMqf].DisposeString();
        }
    }

private:

    ULONG          m_nMqf;
    QUEUE_FORMAT * m_mqf;

}; // class CMqfDisposer



//
// CStringsToFree - holds an array of strings to free - from the parsing process
//
class CStringsToFree
{
public:
    CStringsToFree();
    void Add(LPWSTR pStringToFree);

private:
    AP< AP<WCHAR> > m_pStringsBuffer;
    DWORD m_nStringsToFree;
    DWORD m_nStringsToFreeAllocated;
};



//
// --------------------- Format name parsing classes & routines -------------------
//



//---------------------------------------------------------
//
//  CFnQueueFormat - create   QUEUE_FORMAT from given format name or url
//---------------------------------------------------------
class CFnQueueFormat : public QUEUE_FORMAT
{
public:
	CFnQueueFormat(){}
	
public:
	void CreateFromFormatName(LPCWSTR pfn, bool fDuplicate = false);
	void CreateFromFormatName(const xwcs_t& fn);
	void CreateFromUrl(LPCWSTR pfn, bool fDuplicate = false);
	void CreateFromUrl(const xwcs_t& fn);
    void CreateFromQueueFormat(const QUEUE_FORMAT& qf);

private:
	CFnQueueFormat(const CFnQueueFormat&);
	CFnQueueFormat& operator=(CFnQueueFormat&);	

private:
	AP<WCHAR> m_OriginalDupAutoDelete;
	AP<WCHAR> m_ParsingResultAutoDelete;
};



//---------------------------------------------------------
//
//  CFnMqf - create   list of QUEUE_FORMAT from given mqf
//---------------------------------------------------------
class CFnMqf
{
public:
	CFnMqf(
		void
		):
		m_QueueFormats(NULL),
		m_nQueueFormats(0)					
		{
		}

	explicit CFnMqf(const xwcs_t& fn)
	{
		CreateFromMqf(fn);						
	}			

	explicit CFnMqf(const WCHAR* fn)
	{
		CreateFromMqf(fn);						
	}			

public:
	void  CreateFromMqf(const xwcs_t& fn);
	void  CreateFromMqf(const WCHAR* fnstr);
	void  CreateFromMqf(const QUEUE_FORMAT* QueueFormats, DWORD nQueueFormats)
	{
		ASSERT(!(QueueFormats != NULL && nQueueFormats == 0));
		ASSERT(!(QueueFormats == NULL && nQueueFormats != 0));
		m_QueueFormats =  QueueFormats;
		m_nQueueFormats = nQueueFormats;
	}


	const QUEUE_FORMAT* GetQueueFormats() const
	{
		return 	m_QueueFormats;
	}

	const DWORD GetCount()const
	{
		return 	m_nQueueFormats;
	}

private:
	CFnMqf& operator=(const CFnMqf&);
	CFnMqf(const CFnMqf&);

private:
	CStringsToFree strsToFree;
	const QUEUE_FORMAT* m_QueueFormats;
	AP<QUEUE_FORMAT> m_AutoQueueFormats;
	DWORD m_nQueueFormats;
	AP<WCHAR> m_fnstr;
};

struct CFnSerializeQueueFormat
{
	explicit CFnSerializeQueueFormat(
		const QUEUE_FORMAT&	qf
		):
		m_qf(qf)
		{
		}

	const QUEUE_FORMAT& m_qf;	
};


struct CFnSerializeMqf
{
	CFnSerializeMqf(
		QUEUE_FORMAT*  pqf,
		ULONG count
		)
		:
		m_pqf(pqf),
		m_count(count)
		{
		}

	QUEUE_FORMAT* m_pqf;
	ULONG m_count;
};


std::wostream&
operator<<(
   std::wostream& os,
   const CFnSerializeQueueFormat& qf
   );


std::wostream&
operator<<(
   std::wostream& os,
   const CFnSerializeMqf& mqf
   );



enum QUEUE_PATH_TYPE{
    ILLEGAL_QUEUE_PATH_TYPE = 0,
    PRIVATE_QUEUE_PATH_TYPE,
    PUBLIC_QUEUE_PATH_TYPE,
    SYSTEM_QUEUE_PATH_TYPE
};


QUEUE_PATH_TYPE
FnValidateAndExpandQueuePath(
    LPCWSTR pwcsPathName,
    LPCWSTR* ppwcsExpandedPathName,
    LPWSTR* ppStringToFree
    );

LPCWSTR
FnParseGuidString(
	LPCWSTR p,
	GUID* pg
	);

BOOL
FnFormatNameToQueueFormat(
    LPCWSTR lpwcsFormatName,
    QUEUE_FORMAT* pQueueFormat,
    LPWSTR* ppStringToFree
    );

BOOL
FnMqfToQueueFormats(
    LPCWSTR pfn,
    AP<QUEUE_FORMAT> &pmqf,
    DWORD   *pnQueues,
    CStringsToFree &strsToFree
    );



VOID
FnExtractMachineNameFromPathName(
	LPCWSTR PathName,
	AP<WCHAR>& MachineName
	);

VOID
FnExtractMachineNameFromDirectPath(
	LPCWSTR PathName,
	AP<WCHAR>& MachineName
	);

enum DirectQueueType
{
    dtTCP,
    dtOS,
    dtHTTP,
    dtHTTPS
};

LPCWSTR
FnParseDirectQueueType(
	LPCWSTR DirectQueuePath,
	DirectQueueType* dqt
	);

LPCWSTR
FnParseMulticastString(
    LPCWSTR p,
    MULTICAST_ID* pMulticastID
	);

VOID
FnDirectIDToLocalPathName(
	LPCWSTR DirectID,
	LPCWSTR LocalMachineName,
	AP<WCHAR>& PathName
	);

bool
FnIsPrivatePathName(
	LPCWSTR PathName
	);

bool
FnIsHttpFormatName(
    LPCWSTR pfn
    );

bool
FnIsHttpDirectID(
	LPCWSTR p
	);

bool
FnIsHttpHttpsUrl(
	LPCWSTR url
	);


bool
FnIsHttpHttpsUrl(
	const xwcs_t& url
	);


bool
FnIsMSMQUrl(
	LPCWSTR url
	);

bool
FnIsMSMQUrl(
	const xwcs_t& url
	);


LPCWSTR
FnFindResourcePath(
	LPCWSTR url
	);



bool
FnAbsoluteMsmqUrlCanonization(
	LPCWSTR url
	)throw();




bool
FnIsDirectHttpFormatName(
	const QUEUE_FORMAT* pQueueFormat
	);


void
FnReplaceBackSlashWithSlash(
	LPWSTR url
	)throw();

bool
FnIsValidQueueFormat(
	const QUEUE_FORMAT* pQueueFormat
	);

#endif // _MSMQ_Fn_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\mc.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Mc.h

Abstract:
    Machine Configuration public interface

Author:
    Erez Haba (erezh) 15-Aug-99

--*/

#pragma once

#ifndef _MSMQ_Mc_H_
#define _MSMQ_Mc_H_

VOID
McInitialize(
    VOID
    );

time_t
McGetStartupTime(
	VOID
	);

LPCWSTR
McComputerName(
	VOID
	);

DWORD
McComputerNameLen(
	VOID
	);

const GUID&
McGetMachineID(
    void
    );



#ifdef _DEBUG

VOID
McSetComputerName(
	LPCSTR ComputerName
	);

#else // _DEBUG

#define McSetComputerName(ComputerName) ((void)0)

#endif // _DEBUG

BOOL
McIsLocalComputerName(
	LPCSTR ComputerName
	);

#endif _MSMQ_Mc_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\mmt.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    Mmt.h

Abstract:

    Multicast Message Transport public interface

Author:

    Shai Kariv  (shaik)  27-Aug-00

--*/

#pragma once

#ifndef _MSMQ_Mmt_H_
#define _MSMQ_Mmt_H_

#include <mqwin64a.h>
#include <qformat.h>

class IMessagePool;
class ISessionPerfmon;
class CTimeDuration;
class CQmPacket;


//
// Multicast Transport base class
//
class __declspec(novtable) CMulticastTransport : public CReference 
{
public:
    enum ConnectionState
    {
        csNotConnected,
        csConnected,
        csShuttingDown,
        csShutdownCompleted
    };

public:

    CMulticastTransport(MULTICAST_ID id) :
        m_state(csNotConnected),
        m_MulticastId(id)
    {
    }

    
    virtual ~CMulticastTransport() = 0
    {
    }


	virtual void Pause(void) = 0
	{
	}


    ConnectionState State() const
    {
        return m_state;
    }

    
    void State(ConnectionState state) 
    {
        m_state = state;
    }

    
    MULTICAST_ID MulticastId() const
    {
        return m_MulticastId;
    }

private:
    ConnectionState m_state;
    MULTICAST_ID m_MulticastId;

}; // class CMulticastTransport


VOID
MmtInitialize(
    VOID
    );

R<CMulticastTransport>
MmtCreateTransport(
    MULTICAST_ID id,
	IMessagePool * pMessageSource,
	ISessionPerfmon* pPerfmon,
    const CTimeDuration& retryTimeout,
    const CTimeDuration& cleanupTimeout
    );

VOID
AppNotifyMulticastTransportClosed(
    MULTICAST_ID id
    );

void
AppRequeueMustSucceed(
	CQmPacket *pQMPacket
	);


#endif // _MSMQ_Mmt_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\list.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    list.h

Abstract:
    List and List::iterator, implements an intrusive double linked list and
    iterator template

    List is defined as a circular doubble linked list. With actions to insert
    and remove entries.

       List
      +-----+   +-----+ +-----+ +-----+ +-----+ +-----+
     -|     |<--|     |-|     |-|     |-|     |-|     |
      | head|   | data| | data| | data| | data| | data|
      |     |-->|     |-|     |-|     |-|     |-|     |-
      +-----+   +-----+ +-----+ +-----+ +-----+ +-----+

                      Linked list diagram

    An iteration is defined for the list using the member type named
    iterator. To declater an interator variable, use full qualified
    name. e.g., List<T>::iterator. An iterator variable is analogous
    to type T pointer. Dereference '*' and arrow '->' operators are
    overloaded for this type so you can (allmost) freely use it as a
    T pointer.

      Example:

        for(List<T>::iterator p = list.begin(); p != list.end(); ++p)
        {
            p->doSomeThing();
        }

Author:
    Erez Haba (erezh) 13-Aug-95

--*/

#pragma once

#ifndef _MSMQ_LIST_H_
#define _MSMQ_LIST_H_


//---------------------------------------------------------
//
//  class List
//
//---------------------------------------------------------
template<class T, int Offset = FIELD_OFFSET(T, m_link)>
class List {
private:
    LIST_ENTRY m_head;

public:
    class iterator;

public:
    List();
   ~List();

    iterator begin() const;
    iterator end() const;

    bool empty() const;

    T& front() const;
    T& back() const;
    void push_front(T& item);
    void push_back(T& item);
    void pop_front();
    void pop_back();

    iterator insert(iterator it, T& item);
    iterator erase(iterator it);
    void remove(T& item);

public:
    static LIST_ENTRY* item2entry(T&);
    static T& entry2item(LIST_ENTRY*);
	static void RemoveEntry(LIST_ENTRY*);
    static void InsertBefore(LIST_ENTRY* pNext, LIST_ENTRY*);
    static void InsertAfter(LIST_ENTRY* pPrev, LIST_ENTRY*);
   

private:
    List(const List&);
    List& operator=(const List&);

public:

    //
    // class List<T, Offset>::iterator
    //
    class iterator {
    private:
        LIST_ENTRY* m_current;

    public:
        explicit iterator(LIST_ENTRY* pEntry) :
            m_current(pEntry)
        {
        }


        iterator& operator++()
        {
            m_current = m_current->Flink;
            return *this;
        }


        iterator& operator--()
        {
            m_current = m_current->Blink;
            return *this;
        }


        T& operator*() const
        {
            return entry2item(m_current);
        }

        
        T* operator->() const
        {
            return (&**this);
        }


        bool operator==(const iterator& it) const
        {
            return (m_current == it.m_current);
        }


        bool operator!=(const iterator& it) const
        {
            return !(*this == it);
        }
    };
    //
    // end class iterator decleration
    //
};


//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------
template<class T, int Offset>
inline List<T, Offset>::List()
{
    m_head.Flink = &m_head;
    m_head.Blink = &m_head;
}


template<class T, int Offset>
inline List<T, Offset>::~List()
{
    ASSERT_BENIGN(empty());
}


template<class T, int Offset>
inline LIST_ENTRY* List<T, Offset>::item2entry(T& item)
{
    return ((LIST_ENTRY*)(PVOID)((PCHAR)&item + Offset));
}


template<class T, int Offset>
inline T& List<T, Offset>::entry2item(LIST_ENTRY* pEntry)
{
    return *((T*)(PVOID)((PCHAR)pEntry - Offset));
}


template<class T, int Offset>
inline void List<T, Offset>::InsertBefore(LIST_ENTRY* pNext, LIST_ENTRY* pEntry)
{
	pEntry->Flink = pNext;
	pEntry->Blink = pNext->Blink;
	pNext->Blink->Flink = pEntry;
	pNext->Blink = pEntry;
}


template<class T, int Offset>
inline void List<T, Offset>::InsertAfter(LIST_ENTRY* pPrev, LIST_ENTRY* pEntry)
{
	pEntry->Blink = pPrev;
	pEntry->Flink = pPrev->Flink;
	pPrev->Flink->Blink = pEntry;
	pPrev->Flink = pEntry;
}


template<class T, int Offset>
inline void List<T, Offset>::RemoveEntry(LIST_ENTRY* pEntry)
{
    LIST_ENTRY* Blink = pEntry->Blink;
    LIST_ENTRY* Flink = pEntry->Flink;

    Blink->Flink = Flink;
    Flink->Blink = Blink;

	//
	// Set pointers to NULL; I rather have AV than a memory corruption.
	//
    pEntry->Flink = pEntry->Blink = 0;
}


template<class T, int Offset>
inline typename List<T, Offset>::iterator List<T, Offset>::begin() const
{
    return iterator(m_head.Flink);
}


template<class T, int Offset>
inline typename List<T, Offset>::iterator List<T, Offset>::end() const
{
    return iterator(const_cast<LIST_ENTRY*>(&m_head));
}


template<class T, int Offset>
inline bool List<T, Offset>::empty() const
{
    return (m_head.Flink == &m_head);
}


template<class T, int Offset>
inline T& List<T, Offset>::front() const
{
    ASSERT(!empty());
    return entry2item(m_head.Flink);
}


template<class T, int Offset>
inline T& List<T, Offset>::back() const
{
    ASSERT(!empty());
    return entry2item(m_head.Blink);
}


template<class T, int Offset>
inline void List<T, Offset>::push_front(T& item)
{
    LIST_ENTRY* pEntry = item2entry(item);
    InsertAfter(&m_head, pEntry);
}                                


template<class T, int Offset>
inline void List<T, Offset>::push_back(T& item)
{
    LIST_ENTRY* pEntry = item2entry(item);
    InsertBefore(&m_head, pEntry);
}                                


template<class T, int Offset>
inline void List<T, Offset>::pop_front()
{
    ASSERT(!empty());
    RemoveEntry(m_head.Flink);
}                                


template<class T, int Offset>
inline void List<T, Offset>::pop_back()
{
    ASSERT(!empty());
    RemoveEntry(m_head.Blink);
}                                


template<class T, int Offset>
inline typename List<T, Offset>::iterator List<T, Offset>::insert(iterator it, T& item)
{
    LIST_ENTRY* pEntry = item2entry(item);
    LIST_ENTRY* pNext = item2entry(*it);
    InsertBefore(pNext, pEntry);
    return iterator(pEntry);
}


template<class T, int Offset>
inline typename List<T, Offset>::iterator List<T, Offset>::erase(iterator it)
{
    ASSERT(it != end());
    iterator next = it;
    ++next;
    remove(*it);
    return next;
}


template<class T, int Offset>
inline void List<T, Offset>::remove(T& item)
{
    ASSERT(&item != &*end());
    LIST_ENTRY* pEntry = item2entry(item);
    RemoveEntry(pEntry);
}

#endif // _MSMQ_LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\mm.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Mm.h

Abstract:
    Memory public interface

Author:
    Erez Haba (erezh) 04-Aug-99

--*/

#pragma once

#ifndef _MSMQ_Mm_H_
#define _MSMQ_Mm_H_

//
// Exported allocation/deallocation functions
//
void* MmAllocate(size_t) throw(bad_alloc);
void* MmAllocate(size_t, const nothrow_t&) throw();
void* MmAllocate(size_t, const char*, int) throw(bad_alloc);
void* MmAllocate(size_t, const char*, int, const nothrow_t&) throw();

void MmDeallocate(void*) throw();
__declspec(noreturn) void MmThrowBadAlloc() throw(bad_alloc);


//
// new and delete operators (free/checked)
//
inline void* __cdecl operator new(size_t s) throw(bad_alloc)
{
    return MmAllocate(s);
}


inline void* __cdecl operator new(size_t s, const nothrow_t& nt) throw()
{
    return MmAllocate(s, nt);
}


inline void* __cdecl operator new(size_t s, const char* fn, int l) throw(bad_alloc)
{
    return MmAllocate(s, fn, l);
}


inline void* __cdecl operator new(size_t s, const char* fn, int l, const nothrow_t& nt) throw()
{
    return MmAllocate(s, fn, l, nt);
}


inline void __cdecl operator delete(void* p) throw()
{
    MmDeallocate(p);
}


#if  defined(_M_AMD64) || defined(_M_IA64)
inline void __cdecl operator delete(void* p, const nothrow_t&) throw()
{
    MmDeallocate(p);
}
#endif


inline void __cdecl operator delete(void* p, const char*, int) throw()
{
    MmDeallocate(p);
}


inline void __cdecl operator delete(void* p, const char*, int, const nothrow_t&) throw()
{
    MmDeallocate(p);
}


//
// Memory allocation failure control
//
const int xAllocationAlwaysSucceed = 100;
const int xAllocationAlwaysFail = 0;

#ifdef _DEBUG

VOID
MmSetAllocationSeed(
	DWORD AllocationSeed
	);
						
DWORD
MmAllocationProbability(
	DWORD AllocationProbability
	);

DWORD
MmAllocationValidation(
	DWORD AllocationFlags
	);

DWORD
MmAllocationBreak(
	DWORD AllocationNumber
	);

VOID
MmCheckpoint(
    VOID
    );

VOID
MmDumpUsage(
    VOID
    );


//
// This function is for debug use only, so don't
// define its release version
//
bool
MmIsStaticAddress(
    const void* Address
    );


//
// In checked builds we trace allocation positions
//
#define DEBUG_NEW new(__FILE__, __LINE__)
#define new_nothrow new(__FILE__, __LINE__, nothrow)

//
// Tune 'new' for allocation tracing
//
#define new DEBUG_NEW

#else // _DEBUG

#define MmSetAllocationSeed(x) ((DWORD)0)
#define MmAllocationProbability(x) ((void)0)
#define MmAllocationValidation(x) ((DWORD)0)
#define MmAllocationBreak ((DWORD)0)
#define MmCheckpoint() ((void) 0)
#define MmDumpUsage() ((void) 0)

#define DEBUG_NEW new
#define new_nothrow new(nothrow)

#endif // _DEBUG

#define PUSH_NEW push_macro("new")
#define POP_NEW pop_macro("new")

//
// String functionality
//
LPWSTR newwcs(LPCWSTR p);
LPSTR  newstr(LPCSTR p);
LPWSTR newwcscat(LPCWSTR s1, LPCWSTR s2);
LPSTR  newstrcat(LPCSTR s1,LPCSTR s2);



#endif // _MSMQ_Mm_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\mqcast.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    mqcast.h

Abstract:
    Define usefull casting operations.

Author:
    Gil Shafriri (gilsh)

--*/

#pragma once

#ifndef MQCAST_H
#define MQCAST_H

#pragma push_macro("min")
#undef min

#pragma push_macro("max")
#undef max

#pragma warning(push)
#pragma warning(disable: 4296)	// '<' : expression is always false

//
// On cast from unsigned to signed, compiler error "signed/unsigned mismatch"
// on <= inequality. In template there is no way to know the type of 'from' or 
// 'to', therefore the warning is irrelevant.
//
#pragma warning(disable: 4018)

template <class TO,class FROM> TO numeric_cast (FROM from)
/*++

Routine Description:
    static cast numerics values verify that casting is done without sign loss or trancation.

Arguments:
    from - value to cast from/

Returned Value:
      casted value.

Usage :
    __int64 i64 = 1000;
    DWORD dw =  numeric_cast<DWORD>(i64);

--*/
{
    //
    // if from is negative - then TO type must be signed (std::numeric_limits<TO>::min() < 0) 
	// and is capable to hold the value without truncation.
	//
	ASSERT(
	  from >= 0 || 
	  (std::numeric_limits<TO>::min() < 0 &&   std::numeric_limits<TO>::min() <= from)  
	  );

     //
     //if from is non negative - make sure TO type is capable to hold the value without truncation.
     // 
     ASSERT(from < 0 ||	from <=  std::numeric_limits<TO>::max());

     return static_cast<const TO&>(from);
}

#pragma warning(pop)
#pragma pop_macro("max")
#pragma pop_macro("min")

#endif // MQCAST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\mpnames.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    mpnames.h

Abstract:
    mp names constants

Author:
    Ilan Herbst (ilanh) 29-Apr-01

--*/

#pragma once

#ifndef _MSMQ_MPNAMES_H_
#define _MSMQ_MPNAMES_H_

#include "fntoken.h"

#define MIME_ID_FMT_A		"%.*s" GUID_FORMAT_A

#define PREFIX_INTERNAL_REFERENCE_C     L'#'

const char xPrefixMimeAttachment[] = "cid:";
const WCHAR xPrefixMimeAttachmentW[] = L"cid:";
const DWORD xPrefixMimeAttachmentLen = STRLEN(xPrefixMimeAttachment);

const char xEnvelopeId[] = "envelope@";
const WCHAR xEnvelopeIdW[] = L"envelope@";
const DWORD xEnvelopeIdLen = STRLEN(xEnvelopeId);

const char xMimeBodyId[] = "body@";
const WCHAR xMimeBodyIdW[] = L"body@";
const DWORD xMimeBodyIdLen = STRLEN(xMimeBodyId);

const char xMimeSenderCertificateId[] = "certificate@";
const WCHAR xMimeSenderCertificateIdW[] = L"certificate@";
const DWORD xMimeSenderCertificateIdLen = STRLEN(xMimeSenderCertificateId);

const char xMimeExtensionId[] = "extension@";
const WCHAR xMimeExtensionIdW[] = L"extension@";
const DWORD xMimeExtensionIdLen = STRLEN(xMimeExtensionId);


#endif // _MSMQ_MPNAMES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\mqmacro.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    mqmacro.h

Abstract:
    Common MSMQ macros

Author:
    Erez Haba (erezh) 20-Dec-98

--*/

#pragma once

#ifndef _MSMQ_MQMACRO_H_
#define _MSMQ_MQMACRO_H_


//
// Make a BUGBUG messages appear in compiler output
//
// Usage: #pragma BUGBUG("This line appears in the compiler output")
//
#define MAKELINE0(a, b) a "(" #b ") : BUGBUG: "
#define MAKELINE(a, b)  MAKELINE0(a, b) 
#define BUGBUG(a)       message(MAKELINE(__FILE__,__LINE__) a)

//
//Verify that given object is  not a pointer
// 
// Example:
//
//   const char* Foo="123";
//   C_ASSERT_NON_PTR(Foo); // will not compile
//
//   const char Bar[]="123"
//   C_ASSERT_NON_PTR(Bar); // ok
//
class NonPtrChecker
{
public:      
	static char Check(const void*); 
private:
	template <class T> static void  Check(T**);
};
#define C_ASSERT_NON_PTR(x) (sizeof(NonPtrChecker::Check(&(x)))) 


//
// Number of elements in an array or table
//
// Usage:
//      int MyTable[] = {1, 2, 3, 4, 5};
//      int nElements = TABLE_SIZE(MyTable);
//
#define TABLE_SIZE(x) (C_ASSERT_NON_PTR(x)/C_ASSERT_NON_PTR(x)*(sizeof(x)/sizeof(*(x))))


//
// The length of a constant string
//
// Usage:
//      const WCHAR xString1[] = L"String1";
//
//      int len1 = STRLEN(xString1);
//      int len2 = STRLEN("String2");
//
#define STRLEN(x) (TABLE_SIZE(x) - 1)


//
// Declare parameters as used in debug builds
//
// Usage:
//      DBG_USED(Valid);
//      DBG_USED(argc);
//
#ifndef _DEBUG
#define DBG_USED(x) ((void)x)
#else
#define DBG_USED(x) NULL
#endif


#endif // _MSMQ_MQMACRO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\mqenv.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    mqenv.h

Abstract:
    Master Windows, libraries and allocation include file 

Author:
    Erez Haba (erezh) 09-Mar-2000

--*/

#pragma once

#ifndef _MSMQ_MQENV_H_
#define _MSMQ_MQENV_H_


//
// Always use Unicode
//
#ifndef UNICODE
#define UNICODE
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _WINDOWS_
	#error WINDOWS.H already included.
#endif

// STRICT is the only supported option (NOSTRICT is no longer supported)
#ifndef STRICT
#define STRICT 1
#endif

#ifndef WIN32
#define WIN32
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE             // UNICODE is used by Windows headers
#endif
#endif

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE            // _UNICODE is used by C-runtime/MFC headers
#endif
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <winsock2.h>

#undef ASSERT
#define MAXDWORD    0xffffffff  
typedef TUCHAR TBYTE , *PTBYTE ;

/////////////////////////////////////////////////////////////////////////////
// Other includes from windows libraries

#include <tchar.h>


/////////////////////////////////////////////////////////////////////////////
// Other includes from standard "C" runtimes

#include <malloc.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <limits.h>
#include <stddef.h>
#include <stdarg.h>
#include <align.h>

#include <crtdbg.h>

/////////////////////////////////////////////////////////////////////////////
// Turn off warnings for /W4

#ifndef ALL_WARNINGS

#pragma warning(disable: 4097) // typedef-name 'id1' used as synonym for class-name 'id2'
#pragma warning(disable: 4127)  // conditional expression is constant
#pragma warning(disable: 4200)  // zero-sized array in struct/union
#pragma warning(disable: 4201)  // nameless struct/union
#pragma warning(disable: 4251)  // using non-exported class as member in exported class
#pragma warning(disable: 4275)  // An exported class was derived from a class that was not exported
#pragma warning(disable: 4284)  // return type for 'identifier::operator ->' is not a UDT or reference to a UDT.
#pragma warning(disable: 4290)  // C++ Exception Specification ignored
#pragma warning(disable: 4511)  // 'class' : copy constructor could not be generated
#pragma warning(disable: 4512)  // 'class' : assignment operator could not be generated
#pragma warning(disable: 4514)  // unreferenced inline/local function has been removed
#pragma warning(disable: 4601)  // #pragma push_macro : 'macro' is not currently defined as a macro
#pragma warning(disable: 4702)  // unreachable code (due to optimization)
#pragma warning(disable: 4710)  // 'function' : function not inlined
#pragma warning(disable: 4711)  // function 'function' selected for inline expansion
#pragma warning(disable: 4786)  // truncated to 'number' characters in the debug information

#endif //!ALL_WARNINGS


/////////////////////////////////////////////////////////////////////////////
// Other includes for tracing and assertion

#include <tr.h>

/////////////////////////////////////////////////////////////////////////////
// Other includes for memroy allocation support

#include <new>
using std::bad_alloc;
using std::nothrow_t;
using std::nothrow;

#include <utility>
using namespace std::rel_ops;

#include <mm.h>


/////////////////////////////////////////////////////////////////////////////
// Support Win64 string length usage

inline unsigned int mqstrlen(const char * s)
{
    size_t len = strlen(s);
    ASSERT(("String length must be 32 bit max", len <= UINT_MAX));
    return static_cast<unsigned int>(len);
}


inline unsigned int mqwcslen(const wchar_t * s)
{
    size_t len = wcslen(s);
    ASSERT(("String length must be 32 bit max", len <= UINT_MAX));
    return static_cast<unsigned int>(len);
}


#define strlen(x) mqstrlen(x)
#define wcslen(x) mqwcslen(x)

/////////////////////////////////////////////////////////////////////////////


#endif // _MSMQ_MQENV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\mp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Mp.h

Abstract:
    SRMP Serialization and Deserialization public interface

Author:
    Uri Habusha (urih) 28-May-00

--*/

#pragma once

#ifndef _MSMQ_Mp_H_
#define _MSMQ_Mp_H_

#include <xstr.h>
#include <strutl.h>
#include <buffer.h>
#include <mpnames.h>



//-------------------------------------------------------------------
//
// Exception class bad_message
//
//-------------------------------------------------------------------
class bad_srmp : public exception
{
};


//-------------------------------------------------------------------
//
// Exception class bad_request
//
//-------------------------------------------------------------------
class bad_request : public exception
{
};



//-------------------------------------------------------------------
//
// Exception class bad_packet_size - thrown in the case packet size is too big to
// be stored in the driver
//
//-------------------------------------------------------------------
class bad_packet_size : public exception
{
};



//-------------------------------------------------------------------
//
// Class resposibile for reading http delivery version (1.0 or 1.1)
//
//-------------------------------------------------------------------
class CHttpDeliveryVesrion
{
public:
	bool IsHttp10Delivery() const;
	CHttpDeliveryVesrion();


private:
	DWORD m_Http10Delivery;
};	



class CAttachmentsArray;
//-------------------------------------------------------------------
//
// class CSrmpRequestBuffers - Translate  QM packet to SRMP network buffers.
//
//-------------------------------------------------------------------
class CQmPacket;
class CSrmpRequestBuffers : public CReference
{
	typedef std::basic_string<unsigned  char> utf8_str;

public:
	CSrmpRequestBuffers(const CQmPacket& pkt, LPCWSTR targethost, LPCWSTR uri);

public:
	size_t GetNumberOfBuffers() const;
	const WSABUF* GetSendBuffers() const;
	size_t GetSendDataLength() const;
	BYTE*  SerializeSendData() const;
	std::wstring GetEnvelop() const;
	const char* GetHttpHeader() const;
	BYTE*  SerializeHttpBody() const;
	size_t GetHttpBodyLength() const;


private:
	size_t GetHttpHeaderLength() const;
	void   SFDSerializeMessage();
	void   CreateSFDHeader(const xstr_t& OrgHeader);
	void   SourceSerializeMessage();
	void   CreateHttpRequestHeaders(const CAttachmentsArray& attachments);
	void   CreateMultipartHeaders(const CAttachmentsArray& attachments);
	void   SetBufferPointers();
	void   CreateSimpleHttpHeader();
	DWORD  GenerateEnvelopeAttachmentHeader(DWORD dataSize, DWORD boundaryId);
	DWORD  GenerateMultipartAttachmentHeader(DWORD dataSize,  const xstr_t& contentId, DWORD boundaryId);
	

private:
	typedef unsigned char utf8_char;
	const CQmPacket& m_pkt;
	AP<utf8_char> m_targethost;
	CStaticResizeBuffer<utf8_char, 64>  m_uri;
	std::vector<WSABUF> m_buffers;
	CResizeBuffer<char>  m_HttpRequestData;	
	utf8_str m_envelope;	
};



//
// Forward decleration
//
struct QUEUE_FORMAT;
struct CBaseHeader;
class  CACPacketPtrs;



//
// Interface functions
//
VOID
MpInitialize(
    VOID
    );



CQmPacket*
MpDeserialize(
    const char* httpHeader,
    DWORD bodySize,
    const BYTE* body,
    const QUEUE_FORMAT* pqf,
	bool fLocal = false
    );




R<CSrmpRequestBuffers>
MpSerialize(
	const CQmPacket& pkt,
	LPCWSTR targethost,
	LPCWSTR uri
	);

//------------------------------------------------
//
//  URI encoding / decoding functions
//
//------------------------------------------------
WCHAR* DecodeURI(LPCWSTR szURI);
WCHAR* DecodeURI(const xwcs_t& sURI );

//------------------------------------------------
//
// App override function
//
//------------------------------------------------

struct QUEUE_FORMAT;

void
AppAllocatePacket(
    const QUEUE_FORMAT& destQueue,
    UCHAR delivery,
    DWORD pktSize,
    CACPacketPtrs& pktPtrs
    );

void
AppFreePacket(
    CACPacketPtrs& pktPtrs
    );

PSID
AppGetCertSid(
	const BYTE*  pCertBlob,
	ULONG        ulCertSize,
	bool		 fDefaultProvider,
	LPCWSTR      pwszProvName,
	DWORD        dwProvType
	);

bool
AppIsDestinationAccepted(
    const QUEUE_FORMAT* pfn,
    bool fTranslated
    );


#endif // _MSMQ_Mp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\mqexception.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mqexception.h

Abstract:

    MSMQ exceptions.

Author:

    Shai Kariv  (shaik)  23-Jul-2000

--*/


#pragma once


#ifndef _MSMQ_EXCEPTION_H_
#define _MSMQ_EXCEPTION_H_



class bad_api : public exception
{
    //
    // Abstract base class for exceptions thrown internally in msmq code when
    // a call to an API returns with failure status.
    //

public:

    virtual ~bad_api(VOID) =0 {};

}; // class bad_api



class bad_hresult : public bad_api
{
    //
    // Base class for HRESULT failures
    //

public:

    explicit bad_hresult(HRESULT hr): m_hresult(hr) { ASSERT(FAILED(hr)); }

    virtual ~bad_hresult(VOID) {}

    virtual HRESULT error(VOID) const throw() { return m_hresult; }

private:

    HRESULT m_hresult;

}; // class bad_hresult



class bad_win32_error : public bad_api
{
    //
    // Base class for Win32 errors (DWORD)
    //

public:

    explicit bad_win32_error(DWORD error): m_error(error) { ASSERT(error != ERROR_SUCCESS); }

    virtual ~bad_win32_error(VOID) {}

    virtual DWORD error(VOID) const throw() { return m_error; }

private:

    DWORD m_error;

}; // class bad_win32_error



class bad_ds_result : public bad_hresult
{
    //
    // DS APIs failures
    //

    typedef bad_hresult Inherited;

public:

    explicit bad_ds_result(HRESULT hr): Inherited(hr) {}

}; // class bad_ds_result



#endif // _MSMQ_EXCEPTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\msi.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    msi.h

Abstract:
    Message Pool interface

Author:
    Uri habusha (urih)
    Shai Kariv  (shaik)  06-Sep-00

--*/

#pragma once 

#ifndef __MSI_H__
#define __MSI_H__

#include "Tr.h"
#include "ref.h"


class CQmPacket;
class CACPacketPtrs;
class EXOVERLAPPED;

class __declspec(novtable) IMessagePool : public CReference
{
public:
    virtual ~IMessagePool() = 0
    {
    }


    virtual void Requeue(CQmPacket* pPacket)throw() = 0;
    virtual void EndProcessing(CQmPacket* pPacket, USHORT mqclass) = 0;
    virtual void LockMemoryAndDeleteStorage(CQmPacket* pPacket) = 0;
    virtual void GetFirstEntry(EXOVERLAPPED* pov, CACPacketPtrs& acPacketPtrs) = 0;
	virtual void CancelRequest(void) = 0;
	virtual void OnRetryableDeliveryError(){}
	virtual void OnRedirected(LPCWSTR ){};
	virtual void Close(void) {};
};

#endif // __MSI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\mqstl.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    mqstl.h

Abstract:
    MSMQ  include STL

Author:
    Uri Habusha (urih) 6-Jan-99

--*/

#pragma once

#ifndef _MSMQ_MQSTL_H_
#define _MSMQ_MQSTL_H_


#pragma PUSH_NEW
#undef new

//
// 'identifier' : identifier was truncated to 'number' characters in the debug information
//
#pragma warning(disable: 4786)

//
//  STL include files are using placment format of new
//
#pragma warning(push, 3)

//
// standard header files
//
#include <static_stl_str.h>
#include <map>
#include <set>
#include <list>
#include <queue>
#include <string>
#include <vector>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <functional>
#include <fstream>
#include <utility>

//
// MSMQ files.
//
#include <lim.h>
#include <mqcast.h>

#pragma warning(pop)

#pragma POP_NEW


#endif // _MSMQ_MQSTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\msm.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Msm.h

Abstract:
    Multicast Session Manager public interface

Author:
    Shai Kariv (shaik) 05-Sep-00

--*/

#pragma once

#ifndef _MSMQ_Msm_H_
#define _MSMQ_Msm_H_

#include <mqwin64a.h>
#include <qformat.h>


VOID
MsmInitialize(
    VOID
    );

VOID
MsmBind(
    const QUEUE_FORMAT& QueueFormat,
    MULTICAST_ID        MulticastId
    );

VOID
MsmUnbind(
    const QUEUE_FORMAT& QueueFormat
    )
    throw();

VOID 
MsmDisconnect(
	VOID
	)
	throw();

VOID 
MsmConnect(
	VOID
	);


void
AppAcceptMulticastPacket(
    const char* httpHeader,
    DWORD bodySize,
    const BYTE* body,
    const QUEUE_FORMAT& destQueue
    );


class ISessionPerfmon;

R<ISessionPerfmon>
AppGetIncomingPgmSessionPerfmonCounters(
	LPCWSTR strMulticastId,
	LPCWSTR remoteAddr
	);


void
AppConnectMulticast(
	void
	);

#endif // _MSMQ_Msm_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\mt.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    mt.h

Abstract:
    Message Transport public interface

Author:
    Uri Habusha (urih) 11-Aug-99

--*/

#pragma once

#include "xstr.h"

//
// Forwarding decleration
//
class IMessagePool;
class ISessionPerfmon;
class CTimeDuration;
class CQmPacket;

//
// Transport base class
//
class __declspec(novtable) CTransport : public CReference 
{
public:
    enum ConnectionState
    {
        csNotConnected,
        csConnected,
        csShuttingDown,
        csShutdownCompleted
	 };

public:

    CTransport(LPCWSTR queueUrl) :
        m_state(csNotConnected),
        m_queueUrl(newwcs(queueUrl))
    {
    }

    
    virtual ~CTransport() = 0
    {
    }

    virtual LPCWSTR ConnectedHost(void) const = 0;
    virtual LPCWSTR ConnectedUri(void) const = 0;
    virtual USHORT ConnectedPort(void) const = 0;
	virtual void Pause(void) = 0;

    ConnectionState State() const
    {
        return m_state;
    }

    
    void State(ConnectionState state) 
    {
        m_state = state;
    }

    
    LPCWSTR QueueUrl() const
    {
        return m_queueUrl;
    }

private:
    ConnectionState m_state;
    const AP<WCHAR> m_queueUrl;
};



VOID
MtInitialize(
    VOID
    );


R<CTransport>
MtCreateTransport(
    const xwcs_t& targetHost,
    const xwcs_t& nextHop,
    const xwcs_t& nextUri,
    USHORT port,
	USHORT nextHopPort,
    LPCWSTR queueUrl,
	IMessagePool* pMessageSource,
	ISessionPerfmon* pPerfmon,
	const CTimeDuration& responseTimeout,
    const CTimeDuration& cleanupTimeout,
	bool fSecure,
    DWORD SendWindowinBytes   
    );


VOID
AppNotifyTransportClosed(
    LPCWSTR queueUrl
    );

bool 
AppCanDeliverPacket(
	CQmPacket* pPkt
	);

void 
AppPutPacketOnHold(
	CQmPacket* pPkt
	);

bool 
AppPostSend(
	CQmPacket* pPkt,
	USHORT mqclass
	);

void
AppRequeueMustSucceed(
	CQmPacket *pQMPacket
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\no.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    No.h

Abstract:
    Network Output public interface

Author:
    Uri Habusha (urih) 12-Aug-99

--*/

#pragma once

#ifndef __NO_H__
#define __NO_H__


class EXOVERLAPPED;

//-------------------------------------------------------------------
//
// Send Buffer
//
//-------------------------------------------------------------------


//
// Initilization routine. 
//
VOID
NoInitialize(
    VOID
    );

bool
NoGetHostByName(
    LPCWSTR host,
	std::vector<SOCKADDR_IN>* pAddr,
	bool fUseCache	= true
    );

SOCKET
NoCreateStreamConnection(
    VOID
    );

SOCKET
NoCreatePgmConnection(
    VOID
    );

VOID
NoConnect(
    SOCKET Socket,
    const SOCKADDR_IN& Addr,
    EXOVERLAPPED* pOverlapped
    );

VOID
NoCloseConnection(
    SOCKET Socket
	);

VOID
NoReceiveCompleteBuffer(
    SOCKET Socket,                                              
    VOID* pBuffer,                                     
    DWORD Size, 
    EXOVERLAPPED* pov
    );

VOID
NoReceivePartialBuffer(
    SOCKET Socket,                                              
    VOID* pBuffer,                                     
    DWORD Size, 
    EXOVERLAPPED* pov
    );

VOID
NoSend(
    SOCKET Socket,                                              
    const WSABUF* Buffers,                                     
    DWORD nBuffers, 
    EXOVERLAPPED* pov
    );

DWORD
AppGetBindInterfaceIp(
	void
	);


#endif // __NO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\mtm.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    Mtm.h

Abstract:

    Multicast Transport Manager public interface

Author:

    Shai Kariv  (shaik)  27-Aug-00

--*/

#pragma once

#ifndef _MSMQ_Mtm_H_
#define _MSMQ_Mtm_H_

#include <mqwin64a.h>
#include <qformat.h>


class IMessagePool;
class ISessionPerfmon;
class CTimeDuration;
class CMulticastTransport;


VOID 
MtmCreateTransport(
    IMessagePool * pMessageSource,
	ISessionPerfmon* pPerfmon,
	MULTICAST_ID id
    );

VOID
MtmTransportClosed(
    MULTICAST_ID id
    );

VOID
MtmInitialize(
    VOID
    );

VOID 
MtmTransportPause(
    MULTICAST_ID id
    );
		 
VOID
MtmDisconnect(
	VOID
	);

R<CMulticastTransport>
MtmGetTransport(
    MULTICAST_ID id
    );

R<CMulticastTransport>
MtmFindFirst(
	VOID
	);


R<CMulticastTransport>
MtmFindLast(
	VOID
	);


R<CMulticastTransport>
MtmFindNext(
	const CMulticastTransport& transport
	);


R<CMulticastTransport>
MtmFindPrev(
	const CMulticastTransport& transport
	);

#endif // _MSMQ_Mtm_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\ref.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    ref.h

Abstract:
    Abstruct object for refrence count and list entry.

Author:
    Erez Haba (erezh) 04-Aug-99

--*/

#pragma once

#ifndef _MSMQ_REF_H_
#define _MSMQ_REF_H_


//---------------------------------------------------------
//
//  class CReference
//
//---------------------------------------------------------

class __declspec(novtable) CReference {
public:

    CReference() :
        m_ref(1)
    {
    }


    void AddRef() const
    {
        LONG ref = InterlockedIncrement(&m_ref);

        //TrTRACE(Reference, "AddRef(0x%p)=%d", this, ref);
        UNREFERENCED_PARAMETER(ref);
    }


    void Release() const
    {
        ASSERT(m_ref > 0);
        LONG ref = InterlockedDecrement(&m_ref);

        //TrTRACE(Reference, "Release(0x%p)=%d", this, ref);
        ASSERT(!(ref < 0));

        if(ref == 0)
        {
            delete this;
        }
    }

    
    LONG GetRef(void) const
    {
        //
        // N.B. This memeber is for specialized use only. You can not rely on
        //      its return value but in specific scnarios. A returned value of
        //      1 is considered stable (as the caller holds the only reference
        //      to the object) as well as a return value that matchs exactly
        //      the number of references the caller logicly holds to the
        //      object. Use this function with caution.     erezh  16-Feb-2000
        //

        return m_ref; 
    }


protected:
    virtual ~CReference() = 0
    {
        //
        // Either this object is deleted through the last Release call, or an
        // exception was raised in this object constructor.
        //
        // PITFALL: This will not prevent deleting an object with a reference count
        // of one. But this object is trying to prevent this by defining its dtor
        // as a protected member. Neverthless derived object can override the dtor
        // protected access, allowing direct delete call. In any case deleting an
        // object with a reference count of 1 does seem harmelss as this is the
        // only reference to that object.   erezh 11-Oct-99
        // 
        //
        ASSERT((m_ref == 0) || (m_ref == 1));
    }

private:
    mutable LONG m_ref;
};


#endif // _MSMQ_REF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\rwlock.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    rwlock.h

Abstract:
    This file contains a Multi-reader, one-writer synchronization object and
    useful templates for auto lock/unlock

Author:
    Uri Habusha (urih), 27-Dec-99

--*/

#pragma once

#ifndef _MSMQ_RWLOCK_H_
#define _MSMQ_RWLOCK_H_

/*++

  Class:      CReadWriteLock

  Purpose:    Shared/Exclusive access services

  Interface:  LockRead      - Grab shared access to resource
              LockWrite       - Grab exclusive access to resource
              UnlockRead      - Release shared access to resource
              UnlockWrite     - Release exclusive access to resource
                
    Notes:      This class guards a resource in such a way that it can have
                multiple readers XOR one writer at any one time. It's clever,
                and won't let writers be starved by a constant flow of
                readers. Another way of saying this is, it can guard a
                resource in a way that offers both shared and exclusive
                access to it.
                
                If any thread holds a lock of one sort on a CReadWriteLock,
                it had better not grab a second. That way could lay deadlock,
                matey! Har har har.....

--*/

class CReadWriteLock 
{
public:
    CReadWriteLock(unsigned long ulcSpinCount = 0);
    ~CReadWriteLock(void);

    void LockRead(void);
    void LockWrite(void);
    void UnlockRead(void);
    void UnlockWrite(void);

private:
    HANDLE GetReadWaiterSemaphore(void);
    HANDLE GetWriteWaiterEvent (void);

private:
    unsigned long m_ulcSpinCount;       // spin counter
    volatile unsigned long m_dwFlag;    // internal state, see implementation
    HANDLE m_hReadWaiterSemaphore;      // semaphore for awakening read waiters
    HANDLE m_hWriteWaiterEvent;         // event for awakening write waiters
};





//---------------------------------------------------------
//
//  class CSR
//
//---------------------------------------------------------
class CSR {
public:
    CSR(CReadWriteLock& lock) : m_lock(&lock)  { m_lock->LockRead(); }
	~CSR() {if(m_lock) m_lock->UnlockRead(); }
	CReadWriteLock* detach(){CReadWriteLock* lock = m_lock; m_lock = 0; return lock;}

private:
    CReadWriteLock* m_lock;
};


//---------------------------------------------------------
//
//  class CSW
//
//---------------------------------------------------------
class CSW
{

public:
    CSW(CReadWriteLock& lock) : m_lock(&lock)  { m_lock->LockWrite(); }
   ~CSW() {if(m_lock) m_lock->UnlockWrite(); }
   	CReadWriteLock* detach(){CReadWriteLock* lock = m_lock; m_lock = 0; return lock; }

private:
    CReadWriteLock* m_lock;
};


#endif // _MSMQ_RWLOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\rd.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Rd.h

Abstract:
    Routing Decision public interface

Author:
    Uri Habusha (urih) 10-Apr-00

--*/

#pragma once

#ifndef __Rd_H_
#define __Rd_H_

#include "timetypes.h"

//-------------------------------------------------------------------
//
// Exception class bad_route
//
//-------------------------------------------------------------------
class bad_route : public exception 
{
};


class CRouteMachine : public CReference
{
public:
    virtual ~CRouteMachine()
    {
    }

    virtual const GUID& GetId(void) const = 0;
    virtual LPCWSTR GetName(void) const = 0; 
    virtual bool IsForeign(void) const = 0;
    virtual const CACLSID& GetSiteIds(void) const = 0;

};


class CRouteTable
{
private:
    struct next_hop_less: public std::binary_function<R<const CRouteMachine>&, R<const CRouteMachine>&, bool> 
    {
        bool operator()(const R<const CRouteMachine>& k1, const R<const CRouteMachine>& k2) const
        {
            return (memcmp(&k1->GetId(), &k2->GetId(), sizeof(GUID)) < 0);
        }
    };

public:
    typedef std::set<R<const CRouteMachine>, next_hop_less> RoutingInfo;

public:
    virtual ~CRouteTable()
    {
    }


    RoutingInfo* GetNextHopFirstPriority(void) 
    { 
        return &m_nextHopTable[0]; 
    }


    RoutingInfo* GetNextHopSecondPriority(void) 
    { 
        return &m_nextHopTable[1]; 
    }


private:
    RoutingInfo m_nextHopTable[2];
};



VOID
RdInitialize(
    bool fRoutingServer,
    CTimeDuration rebuildInterval
    );


VOID
RdRefresh(
    VOID
    );

VOID
RdGetRoutingTable(
    const GUID& destMachineId,
    CRouteTable& RoutingTable                                                                                    
    );

void
RdGetConnector(
    const GUID& foreignMachineId,
    GUID& connectorId
    );


#endif // __Rd_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\rex.h ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

    Module Name:    rex.h

    Abstract:

    Author:
        Vlad Dovlekaev  (vladisld)      1/10/2002

    History:
        1/10/2002   vladisld    - Created
--*/

/****************************************************************************/
/*  File:       regexpr.h                                                  */
/*  Author:     J. Kanze                                                    */
/*  Date:       07/06/91                                                    */
/*      Copyright (c) 1991,1993,1994 James Kanze                            */
/* ------------------------------------------------------------------------ */
/*  Modified:   28/10/91    J. Kanze                                        */
/*      Converted "char *" to "const char *" where possible. (I             */
/*      considered using String, but the classes defined here would         */
/*      not get any benefit from it, as they only use "char *" as           */
/*      messages, or as an input parameter to be scanner.)                  */
/*  Modified:   24/12/93    J. Kanze                                        */
/*      Completely reworked to use more modern compilers (with fully        */
/*      nested classes, for example).  Hid implementation.                  */
/*  Modified:   04/11/94    J. Kanze                                        */
/*      Adapted to new coding standards.  Also, use GB_StringArg            */
/*      instead of char const* for parameters.                              */
/*  Modified:   13/06/2000  J. Kanze                                        */
/*      Ported to current library conventions and the standard library.     */
/*  Modified:   01/20/2002  vladisld                                        */
/*      Ported to MSMQ build environment
/* ------------------------------------------------------------------------ */
//      CRegExpr:
//      ===========
//
//      Interface specifications for regular expression objects.
//
//      A regular expression object (class CRegExpr) is a parsed
//      regular expression tree.  In addition, it is possible to
//      operate on this tree to expand it ("or" nodes).
//
//      In this implementation, a tree may have several accept nodes.
//      The matching function will return a match if any subtree of an
//      accept node matches.  A match is indicated by returning the
//      acceptId (2nd parameter of the constructor) of the matching
//      node.  If several nodes match, the acceptId of the longest
//      match will be returned.  -1 signals no match.
//
//      To create such a tree, the idea is to use the following code
//      (input from argv as example):
//
//          CRegExpr          x ;
//          for ( int i = 1 ; i < argc ; i ++ )
//              x |= CRegExpr( argv[ i ] , i ) ;
//
//      The return value on a match (x.match() in the above example)
//      will then correspond to the number of the argument of the
//      longest match (or -1 if no match).
//
//      If there are two "longest" matches, the return value will be
//      that of the left-most (in this case, the first seen).
//
//      The constructor constructs a parse tree from the
//      initialization string.  The match function builds a DFA on an
//      as needed basis (lazy evaluation).  The DFA can also be built
//      explicitly: x.buildCompleteDFA().  This is only recommended if
//      the state table is to be output; the lazy evaluation is
//      superior in both time and space in all other cases.
// --------------------------------------------------------------------------

#ifndef REGEXPR_HH
#define REGEXPR_HH

class CRexRegExpr_Impl ;

class CRegExpr
{
public :
    //      Status:
    //      =======
    //
    //      This enum defines the possible result states for the
    //      constructor.  At present, this status is a characteristic
    //      of this class, which can be tested at any time after
    //      construction, and *should* be tested immediately after any
    //      constructor.
    //
    //      The last entry is used to report errors from GB_CharClass:
    //      it is or'ed into the error from GB_CharClass.
    // ----------------------------------------------------------------------
    enum Status
    {
        ok = 0 ,
        emptyExpr ,
        illegalDelimiter ,
        unexpectedEOF ,
        unmatchedParen ,
        garbageAtEnd ,
        emptyOrTerm ,
        defaultCtorUsed ,
        illegalCharClass = 0x40
    } ;

    typedef unsigned int TransitionState ;

    //      Constructors, destructors and assignment:
    //      =========================================
    //
    //      The default constructor creates an invalid regular
    //      expression (which matches nothing).
    //
    //      In the constructor taking a string or an istream as first
    //      parameter, the string defines the regular expression, and
    //      the acceptId determines the value to be returned on a
    //      match (default 0).  A regular expression is constructed
    //      from the string; if there is an error, an invalid regular
    //      expression (which matches nothing) will be constructed.
    //
    //      Note that giving -1 as an acceptId is likely to confuse
    //      functions like `match'.  On the other hand, it can be used
    //      to suppress certain matchings (not for neophytes).
    //
    //      Copy and assignment are supported.
    // ----------------------------------------------------------------------
    CRegExpr() ;
    CRegExpr( std::istream& source ,
              int delim ,
              int acceptCode = 0 );

    explicit  CRegExpr( char const* source , int acceptCode = 0 ) ;
    explicit  CRegExpr( std::string const& source ,
                          int acceptCode = 0 ) ;
              CRegExpr( CRegExpr const& other ) ;
              ~CRegExpr() ;
    CRegExpr& operator=( CRegExpr const& other ) ;

    //      status:
    //      ==========
    //
    //      The following routine return information concerning the
    //      status of CRegExpr.
    //
    //      There are two routines to read the status.  The first
    //      (good) simply returns true if the status is OK, false
    //      otherwise.  The second (errorCode) returns the status
    //      itself.
    // ----------------------------------------------------------------------
    bool                good() const ;
    Status              errorCode() const ;
    bool                empty() const;

    //      errorMsg:
    //      =========
    //
    //      Return error code (Status) as readable string.
    // ----------------------------------------------------------------------
    std::string        errorMsg() const ;
    static std::string errorMsg( Status errorCode ) ;

    //      merge:
    //      ======
    //
    //      This function merges the other regular expression with
    //      this one by inserting an OR node on top of both of them.
    //
    //      operator|= exists as an alias for this function.
    // ----------------------------------------------------------------------
    void                merge( CRegExpr const& other ) ;
    CRegExpr&         operator|=( CRegExpr const& other ) ;

    //      buildCompleteDFA:
    //      =================
    //
    //      This functions force all of the state machine to be built.
    //      (Normally, lasy evaluation is used, with everything but
    //      the expression parse tree only built on an as needed
    //      basis.)
    // ----------------------------------------------------------------------
    void                buildCompleteDFA() const ;

    //      Some simple predicates:
    //      =======================
    //
    //      These routines refer to the present characteristics of the
    //      DFA (which may change in time due to lazy evaluation).
    //      Normally, they will only be used after calling
    //      buildCompleteDFA, to output the DFA to an external media.
    //
    //      getStateCount returns 0 if the DFA has not yet been
    //      initialized.  The number of states is only definitive if
    //      buildCompleteDfa has been invoked.
    //
    //      The results of calling getTransition for an undefined
    //      state (>= getStateCount) or with an illegal value for chr
    //      are undefined. Legal values for chr are [0...UCHAR_MAX].
    // -----------------------------------------------------------------------
    int                 getStateCount() const ;
    TransitionState     getTransition( TransitionState state ,
                                       unsigned char chr ) const ;
    int                 getAcceptCode( TransitionState state ) const ;

    //      match:
    //      ======
    //
    //      Matches the string to this regular expression.  Returns
    //      the acceptCode for the left-most longest match, or -1 if
    //      no match.  The test starts at the first character given,
    //      and will advance as far as necessary, but does not
    //      necessarily have to match the entire string.
    //
    //      The first version is historical, but may still be be
    //      useful.  It compares a C-style '\0' terminated string, if
    //      a match is found and end != NULL, it stores the address of
    //      the last character matched + 1 in end.
    //
    //      The other versions are designed around STL: they return a
    //      pair with the results of the match, and an iterator one
    //      past the last character matched.
    //
    //      I'm not really happy about the STL interface, but I can't
    //      think of anything better for the moment.  And there is a
    //      precedent in the interface of std::map, etc.
    // -----------------------------------------------------------------------
    int                 match( char const* start ,
                               char const** end = NULL ) const ;
    template< typename FwdIter >
    std::pair< int , FwdIter >
                        match( FwdIter begin , FwdIter end ) const ;

    //      Debugging functions:
    // ----------------------------------------------------------------------
    void                dumpTree( std::ostream& output ) const ;
    void                dumpNfaAutomat( std::ostream& output ) const ;
    void                dumpDfaAutomat( std::ostream& output ) const ;
    void                dump( std::ostream& output ) const ;

    //      Swap method
    // ----------------------------------------------------------------------
    void                swap( CRegExpr& rhs );

private :
    CRexRegExpr_Impl*    myImpl ;

    //      Helper functions for the member template. Using helper
    //      functions instead of invoking the (inline) functions on
    //      the implementation class immediately probably slows things
    //      down noticeably, but the alternatives expose too much of
    //      the implementation.  (Will "export" solve this?)
    void                initForMatch() const ;
    TransitionState     processTransition( int& accept ,
                                           TransitionState state ,
                                           char ch ) const ;
} ;


inline bool
CRegExpr::good() const
{
    return errorCode() == ok ;
}

inline std::string
CRegExpr::errorMsg() const
{
    return errorMsg( errorCode() ) ;
}

inline CRegExpr&
CRegExpr::operator|=( CRegExpr const& other ) {
    merge( other ) ;
    return *this ;
}

template< typename FwdIter >
std::pair< int , FwdIter >
CRegExpr::match( FwdIter begin , FwdIter end ) const
{
    initForMatch() ;
    std::pair< int , FwdIter >
                        result( -1 , begin ) ;
    int                 accept = -1 ;
    for ( TransitionState state = 1 ;
          begin != end && state > 0 ;
          state = processTransition( accept , state , *begin ++ ) ) {
        if ( accept != -1 ) {
            result.first = accept ;
            result.second = begin ;
        }
    }
    if ( accept != -1 ) {
        result.first = accept ;
        result.second = begin ;
    }
    return result ;
}

inline void
CRegExpr::swap( CRegExpr& rhs)
{
    std::swap(myImpl, rhs.myImpl);
}

#endif
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\qal.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Qal.h

Abstract:
    header file for class CQueueAlias.
	The class manages queues aliases  in memory and load/store them
	from\in registry.It also give the class user way to enumerate queue\alias mapping


Author:
    Gil Shafriri (gilsh) 06-Apr-00

--*/

#ifndef QAL_H
#define QAL_H

#include <stlcmp.h>
#include <qformat.h>

class bad_win32_error;
//
// Error reporting hooks implemented by the library user
//
void AppNotifyQalWin32FileError(LPCWSTR pFileName, DWORD err)throw();
void AppNotifyQalDirectoryMonitoringWin32Error(LPCWSTR pMappingDir, DWORD err)throw();
void AppNotifyQalDuplicateMappingError(LPCWSTR pAliasFormatName, LPCWSTR pFormatName)throw();
void AppNotifyQalInvalidMappingFileError(LPCWSTR pMappingFileName)throw();
void AppNotifyQalXmlParserError(LPCWSTR pMappingFileName)throw();
bool AppNotifyQalMappingFound(LPCWSTR pAliasFormatName, LPCWSTR pFormatName)throw();




//---------------------------------------------------------
//
// Queue Alias
//
//---------------------------------------------------------
class CQueueAliasImp;

class CQueueAlias
{
public:

	CQueueAlias(LPCWSTR pMappingDir);

public:
	~CQueueAlias();

	bool
	GetInboundQueue(
		LPCWSTR pAliasFormatName,
		LPWSTR* ppFormatName
   		) const;

    bool
    GetOutboundQueue(
        LPCWSTR pOriginalUri,
        LPWSTR* ppTargetUri
        ) const;

	bool
	GetStreamReceiptURL(
		LPCWSTR  pFormatName,
		LPWSTR*  ppStreamReceiptURL
  		) const;

    bool
    GetDefaultStreamReceiptURL(
        LPWSTR* ppStreamReceiptURL
        ) const;

private:	
	CQueueAlias& operator=(const CQueueAlias&);
	CQueueAlias(const CQueueAlias&);

private:
	R<CQueueAliasImp> m_imp;
	mutable CCriticalSection m_cs;
};


enum TRANSLATION_TYPE {
		CONVERT_SLASHES=1,
		DECODE_URL=2, 
		MAP_QUEUE=4
		};

class QUEUE_FORMAT_TRANSLATOR
{
public:

	QUEUE_FORMAT_TRANSLATOR(const QUEUE_FORMAT* pQueueFormat, DWORD flags);

public:
	
    QUEUE_FORMAT* get()
    {
        return &m_qf;
    }

	bool IsTranslated() const
	{
		return m_fTranslated;
	}

    bool IsCanonized() const
    {
        return m_fCanonized;
    }

private:
    QUEUE_FORMAT  m_qf;
	AP<WCHAR>     m_sURL;
    bool          m_fTranslated;
    bool          m_fCanonized;

private:
	QUEUE_FORMAT_TRANSLATOR& operator=(const QUEUE_FORMAT_TRANSLATOR&);
	QUEUE_FORMAT_TRANSLATOR(const QUEUE_FORMAT_TRANSLATOR&);
};


void   QalInitialize(LPCWSTR pDir);
CQueueAlias& QalGetMapping(void);






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\rwlockexe.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    rwlockexe.h

Abstract: Header for class CReadWriteLockAsyncExcutor and  IAsyncExecutionRequest used to queue asyncrouns operations 
		  under read or write lock. Allows multiple excutions under read  lock and 
		  single excetion under write lock. The caller thread is not blocked because of 
		  locking but the execution is delayed untill the lock is freed. User of this class
		  should call AsyncExecuteUnderReadLock/AsyncExecuteUnderWriteLock and on completion
		  call UnlockRead/UnlockWrite accordingly.
    
Author:	 
    Gil Shafriri(gilsh), 26-June-2001

--*/

#pragma once

#ifndef _MSMQ_RWLOCKEXE_H_
#define _MSMQ_RWLOCKEXE_H_

//
// Async request interface - represet async command to run.
// should perform call back to the caller on completion.
//
class IAsyncExecutionRequest
{
public:
	virtual ~IAsyncExecutionRequest(){}

public:
	virtual void Run() = 0; // Run the task and callback asyncrounsly

private:
	virtual void Close() throw() = 0; // Force completion of the execution 
									  // called only by CReadWriteLockAsyncExcutor	

	friend class CReadWriteLockAsyncExcutor;
};



class CReadWriteLockAsyncExcutor
{
public:
	CReadWriteLockAsyncExcutor();
	~CReadWriteLockAsyncExcutor();

public:
	void AsyncExecuteUnderReadLock(IAsyncExecutionRequest*);
	void AsyncExecuteUnderWriteLock(IAsyncExecutionRequest* pAsyncExecute);
	void UnlockRead(void);
	void UnlockWrite(void);
	void Close() throw();
	

private:
	enum LockType{Read, Write};
	struct CExecutionContext
	{
		CExecutionContext(
			IAsyncExecutionRequest* pAsyncExecute, 
			LockType locktype
			):
			m_AsyncExecution(pAsyncExecute),
			m_locktype(locktype)
			{
			}

		IAsyncExecutionRequest* m_AsyncExecution;
		LockType m_locktype;
	};

private:
	bool IsWriteLockOn() const;
	bool IsReadLockOn() const;
	bool IsClosed() const;
	void ExecuteWatingRequeuets();
	void ExecuteReader(IAsyncExecutionRequest* pAsyncExecute);
	void ExecuteWriter(IAsyncExecutionRequest* pAsyncExecute);
	void SafeExecute(IAsyncExecutionRequest* pAsyncExecute);

	
private:
	int m_NumOfActiveReaders;
	int m_NumOfActiveWritters;
	typedef std::queue<CExecutionContext> CExQueue;
	CExQueue m_WatingForExecutionQueue;
	CCriticalSection m_Lock;
	bool m_fClosed;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\smarthandle.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    SmartHandleImpl.h

Abstract:

    SmartHandle template implemetation for many handle types

Author:

	Tomer Weisberg (tomerw) May 21, 2002
	written by YanL

Revision History:

--*/

#pragma once

#ifndef _MSMQ_SMARTHANDLE_H_
#define _MSMQ_SMARTHANDLE_H_

//----------------------------------------------------------------------
//
// class auto_resource
//		This class eliminates need for cleanup when working with pointers and 
//		handles  of the different kind
//
//		class T			- resource "handle"
//
//		class T_Traits	- required traits for this recource "handle"
//			Should be define as:
//				struct T_Traits {
//					static _Rh invalid() {}
//					static void free(_Rh rh) {}
//				};
//
//----------------------------------------------------------------------
template< class T, class T_Traits >
class auto_resource {
public:
	explicit auto_resource(T h = T_Traits::invalid()) : m_h(h) 
	{
	}


	~auto_resource() 
	{ 
		free(); 
	}


	bool valid() const	
	{	
		return (T_Traits::invalid() != m_h);	
	}


	void free()	
	{	
		if (valid()) 
		{
			T_Traits::free(m_h);
			m_h = T_Traits::invalid();
		}
	}


	T detach() 
	{
		T h = m_h;
		m_h = T_Traits::invalid();
		return h;
	}


	auto_resource& operator=(T h)
	{
        ASSERT(("Auto resource in use, can't assign it", m_h == 0));
		m_h = h;
		return *this;
	}


    T get() const
    {
    	return m_h;
    }


    T& ref()
    {
        ASSERT(("Auto resource in use, can't take resource reference", m_h == 0));
        return m_h;
    }

	
    VOID*& ref_unsafe()
    {
    	//
        // Unsafe ref to auto resource, for special uses like
        // InterlockedCompareExchangePointer
		//
        return *reinterpret_cast<VOID**>(&m_h);
    }
private:
	T m_h;
	
private:
	//
	// should not use copy constructor etc.
	//
	auto_resource(const auto_resource&);
	auto_resource& operator=(const auto_resource&);
	operator bool() const;
	bool operator !() const;
};

#endif // _MSMQ_SMARTHANDLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\smarthandleimpl.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    SmartHandle.h

Abstract:

    Smart template for auto release classes

Author:

	Tomer Weisberg (tomerw) May 21, 2002
	written by YanL

Revision History:

--*/

#pragma once

#ifndef _MSMQ_SMARTHANDLEIMPL_H_
#define _MSMQ_SMARTHANDLEIMPL_H_

#include <SmartHandle.h>
#include <Clusapi.h>


//
// auto handle to HCLUSTER OpenCluster
//
struct auto_hCluster_traits {
	static HCLUSTER invalid() { return 0; }
	static void free(HCLUSTER hCluster) { CloseCluster(hCluster); }
};
typedef auto_resource<HCLUSTER, auto_hCluster_traits> auto_hCluster;


//
// auto handle to HCLUSENUM ClusterOpenEnum
//
struct auto_hClusterEnum_traits {
	static HCLUSENUM invalid() { return 0; }
	static void free(HCLUSENUM hClusterEnum) { ClusterCloseEnum(hClusterEnum); }
};
typedef auto_resource<HCLUSENUM, auto_hClusterEnum_traits> auto_hClusterEnum;


//
// auto handle to HNETWORK OpenClusterNetworks
//
struct auto_hClusterNetwork_traits {
	static HNETWORK invalid() { return 0; }
	static void free(HNETWORK hClusterNetwork) { CloseClusterNetwork(hClusterNetwork); }
};
typedef auto_resource<HNETWORK, auto_hClusterNetwork_traits> auto_hClusterNetwork;


//
// auto handle to HNETWORKENUM ClusterNetworkOpenEnum
//
struct auto_hClusterNetworkEnum_traits {
	static HNETWORKENUM invalid() { return 0; }
	static void free(HNETWORKENUM hClusterNetworkEnum) { ClusterNetworkCloseEnum(hClusterNetworkEnum); }
};
typedef auto_resource<HNETWORKENUM, auto_hClusterNetworkEnum_traits> auto_hClusterNetworkEnum;


//
// auto handle to HNETINTERFACE OpenClusterNetInterface
//
struct auto_hClusterNetInterface_traits {
	static HNETINTERFACE invalid() { return 0; }
	static void free(HNETINTERFACE hClusterNetInterface) { CloseClusterNetInterface(hClusterNetInterface); }
};
typedef auto_resource<HNETINTERFACE, auto_hClusterNetInterface_traits> auto_hClusterNetInterface;


//
// auto handle to LONG* InterlockedIncrement
//
struct auto_InterlockedDecrement_traits {
	static LONG* invalid() { return NULL; }
	static void free(LONG* RefCount) { InterlockedDecrement(RefCount); }
};
typedef auto_resource<LONG*, auto_InterlockedDecrement_traits> auto_InterlockedDecrement;


#endif // _MSMQ_SMARTHANDLEIMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\spi.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    spi.h

Abstract:
    Session Performance counters interface

Author:
    Uri habusha (urih), 10-Dec-2000

--*/

#pragma once 

#ifndef __SPI_H__
#define __SPI_H__

#include "Tr.h"
#include "ref.h"



class __declspec(novtable) ISessionPerfmon : public CReference
{
public:
    virtual ~ISessionPerfmon() = 0
    {
    }


    virtual void CreateInstance(LPCWSTR objName) = 0;

	virtual void UpdateBytesSent(DWORD bytesSent) = 0;
	virtual void UpdateMessagesSent(void) = 0;

	virtual void UpdateBytesReceived(DWORD bytesReceived) = 0;
	virtual void UpdateMessagesReceived(void) = 0;
};

#endif // __SPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\singelton.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    singelton.h

Abstract:
    Singleton template class


--*/

#pragma once

#ifndef _MSMQ_SINGELTON_H_
#define _MSMQ_SINGELTON_H_

#include <cm.h>
#include <cs.h>
#include <_mqini.h>

template <class T>
class CSingelton
{
public:
	static T& get()
	{
		if(m_obj.get() != NULL)
			return *m_obj.get();
		
		P<T> newobj = new T();
		if(InterlockedCompareExchangePointer(&m_obj.ref_unsafe(), newobj.get(), NULL) == NULL)
		{
			newobj.detach();
		}

		return *m_obj.get();			
	}

	
private:
	static P<T> m_obj;
};
template <class T> P<T> CSingelton<T>::m_obj;

//
// CSingletonCS
//
// This class may be used instead above CSingelton class, when initialization of
// T class is very expensive or it may otherwise require only single run.
//
template <class T>
class CSingletonCS
{
public:
	static T& get()
	{
        if( m_obj.get() )
            return *m_obj.get();

        CS lock( m_cs );
        if( !m_obj.get() )
        {
             m_obj = new T();
        }
		
		return *m_obj.get();			
	}

	
private:
	static P<T> m_obj;
    static CCriticalSection m_cs;
};
template <class T> P<T>             CSingletonCS<T>::m_obj;
template <class T> CCriticalSection CSingletonCS<T>::m_cs( CCriticalSection::xAllocateSpinCount);



//
//	Class reading and storing message size limit
//
class CMessageSizeLimit
{
public:
	DWORD Limit() const
	{
		return m_limit;
	}

private:
	CMessageSizeLimit()
	{
		//
		// Message size limit default value
		//
		const int xMessageMaxSize = 4194268;

		CmQueryValue(
				RegEntry(NULL, MSMQ_MESSAGE_SIZE_LIMIT_REGNAME, xMessageMaxSize),
				&m_limit
				);	
	}

private:
	friend  CSingelton<CMessageSizeLimit>;
	DWORD m_limit;
};






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\st.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    st.h

Abstract:
    Socket Transport public interface

Author:
    Gil Shafriri (gilsh) 05-Jun-00

--*/

#pragma once

#ifndef _MSMQ_st_H_
#define _MSMQ_st_H_

template <class T> class basic_xstr_t;
typedef  basic_xstr_t<WCHAR> xwcs_t;

class  EXOVERLAPPED;


class IConnection :public CReference
{
public:
	virtual void ReceivePartialBuffer(VOID* pBuffer,DWORD Size, EXOVERLAPPED* pov) = 0;
	virtual void Send(const WSABUF* Buffers,DWORD nBuffers, EXOVERLAPPED* pov) = 0;
	virtual void Close() = 0;
	virtual ~IConnection(){}
};



class ISocketTransport
{
public:
	ISocketTransport(){};
	virtual ~ISocketTransport(){};

public:
 	virtual
	bool
	GetHostByName(
    LPCWSTR host,
	std::vector<SOCKADDR_IN>* pAddr,
	bool fUseCache	= true
    ) = 0 ;

 	virtual bool IsPipelineSupported(void) = 0;

    virtual 
	void 
	CreateConnection(
				const std::vector<SOCKADDR_IN>& Addr, 
				EXOVERLAPPED* pOverlapped,
				SOCKADDR_IN* pAddr = NULL
				) = 0;
  
    virtual R<IConnection> GetConnection(void)  = 0;

private:
	ISocketTransport(const ISocketTransport&);	 
	ISocketTransport& operator=(const ISocketTransport&);
};

void StInitialize(DWORD LocalInterfaceIP);

ISocketTransport* StCreateSimpleWinsockTransport();
R<IConnection> StCreateSimpleWisockConnection(SOCKET s);

ISocketTransport* StCreateSslWinsockTransport(const xwcs_t& ServerName, USHORT ServerPort,bool fProxy);

ISocketTransport* StCreatePgmWinsockTransport();

inline ULONG StIPWStringToULONG(LPCWSTR IPString)
{
		char AddressText[64];
		wcstombs(AddressText, IPString, sizeof(AddressText));
		AddressText[STRLEN(AddressText)] = '\0';
    	return inet_addr(AddressText);
}


#endif // _MSMQ_st_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\svc.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Svc.h

Abstract:
    Service public interface

Author:
    Erez Haba (erezh) 01-Aug-99

--*/

#pragma once

#ifndef _MSMQ_Svc_H_
#define _MSMQ_Svc_H_


VOID
SvcInitialize(
    LPCWSTR DummyServiceName
    );

VOID
SvcEnableControls(
	DWORD Controls
	);

VOID
SvcDisableControls(
	DWORD Controls
	);

DWORD
SvcQueryControls(
	VOID
	);

VOID
SvcReportState(
	DWORD State
	);


DWORD
SvcQueryState(
	VOID
	);

VOID
SvcReportProgress(
	DWORD MilliSecondsToNextTick
	);


//
// Application override functions
//
VOID
AppRun(
	LPCWSTR ServiceName
	);

VOID
AppStop(
	VOID
	);

VOID
AppPause(
	VOID
	);

VOID
AppContinue(
	VOID
	);

VOID
AppShutdown(
	VOID
	);


#endif // _MSMQ_Svc_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\stlcmp.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    stlcmp.h

Abstract:
	STL compare structre

Author:
    Uri Habusha (urih) 8-Mar-2000

--*/

#pragma once

#ifndef _MSMQ_StlCmp_H_
#define _MSMQ_StlCmp_H_

//
// less function, using to compare ASCII string in STL data strcture
//
struct CFunc_strcmp : public std::binary_function<LPCSTR, LPCSTR, bool>
{
    bool operator() (LPCSTR s1, LPCSTR s2) const
    {
        return (strcmp(s1, s2) < 0);
    }
};


struct CFunc_stricmp : public std::binary_function<LPCSTR, LPCSTR, bool>
{
    bool operator() (LPCSTR s1, LPCSTR s2) const
    {
        return (stricmp(s1, s2) < 0);
    }
};


//
// less function, using to compare UNICODE string in STL data strcture
//
struct CFunc_wcscmp : public std::binary_function<LPCWSTR, LPCWSTR, bool>
{
    bool operator() (LPCWSTR str1, LPCWSTR str2) const
    {
        return (wcscmp(str1, str2) < 0);
    }
};


struct CFunc_wcsicmp : public std::binary_function<LPCWSTR, LPCWSTR, bool>
{
    bool operator() (LPCWSTR str1, LPCWSTR str2) const
    {
        return (_wcsicmp(str1, str2) < 0);
    }
};

#endif // _MSMQ_StlCmp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\tm.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Tm.h

Abstract:
    HTTP transport manager public interface

Author:
    Uri Habusha (urih) 03-May-00

--*/

#pragma once

#ifndef _MSMQ_Tm_H_
#define _MSMQ_Tm_H_


class IMessagePool;
class ISessionPerfmon;
class CTimeDuration;
class CTransport;


VOID 
TmCreateTransport(
    IMessagePool* pMessageSource,
	ISessionPerfmon* pPerfmon,
	LPCWSTR queueUrl
    );


VOID
TmTransportClosed(
    LPCWSTR queueUrl
    );

VOID
TmPauseTransport(
	LPCWSTR queueUrl
    );	


VOID
TmInitialize(
    VOID
    );
        

R<CTransport>
TmGetTransport(
    LPCWSTR url
    );


R<CTransport>
TmFindFirst(
	void
	);


R<CTransport>
TmFindLast(
	void
	);


R<CTransport>
TmFindNext(
	const CTransport& transport
	);


R<CTransport>
TmFindPrev(
	const CTransport& transport
	);

#endif // _MSMQ_Tm_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\timeutl.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    timeutl.h

Abstract:
    Some time utilities

Author:
    Gil Shafriri (gilsh) 8-11-2000

--*/

#pragma once

#ifndef _MSMQ_TIMEUTL_H_
#define _MSMQ_TIMEUTL_H_

class CIso8601Time
{
public:
	CIso8601Time(
		time_t time
		):
		m_time(time)
		{
		}
	time_t m_time;
};

//
// Exception class indicationg that time string format is invalid
//
class bad_time_format : public std::exception
{

};

//
// Exception class indicationg that time integer is invalid (usally to large)
//
class bad_time_value : public std::exception
{

};



template <class T>
std::basic_ostream<T>& 
operator<<(
	std::basic_ostream<T>& o, 
	const CIso8601Time&
	);


template <class T> class basic_xstr_t;
typedef basic_xstr_t<WCHAR> xwcs_t;
void
UtlIso8601TimeToSystemTime(
    const xwcs_t& Iso860Time, 
    SYSTEMTIME* pSysTime
    );


time_t 
UtlSystemTimeToCrtTime(
	const SYSTEMTIME& SysTime
	);


time_t
UtlIso8601TimeDuration(
    const xwcs_t& TimeDurationStr
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\strutl.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    strutl.h

Abstract:
    Header file for string ulities

Author:
    Gil Shafriri (gilsh) 25-7-2000

--*/


#ifndef STRUTL_H
#define STRUTL_H


//
// Trivial chars binary predicator - the std::char_traits<C>::eq
// was significally slow.
//
template<class C>
class UtlCharCmp
{
public:
	bool operator()(const C& x1,const C& x2)const
	{
		return x1 == x2;
	}
};

//
// Case insensitive compare
//
template<class C>
class UtlCharNocaseCmp
{
public:
	bool operator()(const C& x1,const C& x2)const
	{
		return std::ctype<C>().tolower(x1) == std::ctype<C>().tolower(x2);
	}
};


//
// template specialization to get string len. 
//
template <class C>
class UtlCharLen;
template<> class UtlCharLen<char>
{
public:
	static size_t len(const char* str)
	{
		return strlen(str);
	}
};



template<> class UtlCharLen<WCHAR>
{
public:
	static size_t len(const WCHAR* str)
	{
		return wcslen(str);
	}
};


template <class C>
class UtlCharLen;
template<> class UtlCharLen<unsigned char>
{
public:
	static size_t len(const unsigned char* str)
	{
		return strlen(reinterpret_cast<const char*>(str));
	}
};



template <class T> T* UtlStrDup(const T* str)
{
	if(str == NULL)
		return NULL;

	size_t len =  UtlCharLen<T>::len(str) + 1;

	T* dup = new T[len];
	memcpy(dup , str, len * sizeof(T));

	return dup;
}

template <class T, class Pred> 
bool
UtlIsStartSec(
		 const T* beg1,
		 const T* end1,
		 const T* beg2,
		 const T* end2,
		 Pred pred
	 	 )

/*++

Routine Description:
	Check if the range [beg1, beg1 + end2 - beg2) is equal  to the range  [beg2, end2).
	(In other words is [beg2, end2) is at the start of  [beg1, end1)
 
Arguments:
    beg1 - start sequence 1
	end -  end sequence 1
	beg2 - start sequence 2
	end2 - end sequence 2
	pred - compare object

Returned value:
	true if the range [beg1, beg1 + end2 - beg2) is equal  to the range  [beg2, end2).

	otherwise false.

--*/
{
	if(end1 - beg1 < end2 - beg2)
		return false;

	return std::equal(  
				beg2,
				end2,
				beg1,
				pred
				); 

}


template <class T>
bool
UtlIsStartSec(
		 const T* beg1,
		 const T* end1,
		 const T* beg2,
		 const T* end2
		 )

/*++

Routine Description:
	Check if the range [beg1, beg1 + end2 - beg2) is equal  to the range  [beg2, end2).
	(In other words is [beg2, end2) is at the start of  [beg1, end1)
 
Arguments:
    beg1 - start sequence 1
	end -  end sequence 1
	beg2 - start sequence 2
	end2 - end sequence 2


Returned value:
	true if the range [beg1, beg1 + end2 - beg2) is equal  to the range  [beg2, end2).

	otherwise false.

--*/
{
	return UtlIsStartSec(beg1, end1, beg2, end2, UtlCharCmp<T>());  
}



template <class C>
inline
bool 
UtlStrIsMatch(
	const C* str, 
	const C* pattern
	)
/*++

Routine Description:
	regural expression string match with default predicator
 
Arguments:
    IN - str - string to match (null terminated)

	IN - pattern - pattern (null terminated)

   
Returned value:
	true if string match the pattern - false otherwise.

    look at UtlStrIsMatch(const C*,const C* ,const P&) for more information.

--*/
{
	return UtlStrIsMatch(str, pattern, UtlCharCmp<C>());
}



template <class C, class P>
inline
bool 
UtlStrIsMatch(
	const C* str, 
	const C* pattern,
	const P& Comp 
	)

/*++

Routine Description:
	regural expression string match with given predicator
 
Arguments:
    IN - str - string to match (null terminated)

	IN - pattern - pattern (null terminated)

    IN - Comp  - binary predicator to compare type C characters.
 

Returned value:
	true if string match the pattern -false otherwise

Note :
It does simple pattern match  includes only * and ^ special caracters in the pattern.
The caracter * match zero or more from any character. The caracter ^ switch to "literal"
mode. In this mode the caracter * has no special meaning.


Example :
str ="microsoft.com"
pattern = "mic*f*.com"
here the string match the pattern.

str ="mic*rosoft.com"
pattern = "mic^*f*.com"
here the string match the pattern.


--*/
{
	ASSERT(str != NULL);
	ASSERT(pattern != NULL);
	return UtlSecIsMatch(str, 
						str + UtlCharLen<C>::len(str), 
						pattern, 
						pattern + UtlCharLen<C>::len(pattern),
						Comp
						);
}


template <class C>
inline
bool 
UtlSecIsMatch(
	const C* sec, 
	const C* secEnd, 
	const C* pattern,
	const C* patternEnd
	)
/*++

Routine Description:
	regural expression on none null terminating sequences  with default predicator
 
Arguments:
    IN - sec - start sequence to match 

	IN - secEnd - end sequence to match 

	IN - pattern - start pattern 

	IN - pattern - end pattern 
      
Returned value:
	true if  sequence match the pattern - false otherwise

Note - behave like 	UtlStrIsMatch on none null terminating sequences.

*/
{
	return 	UtlSecIsMatch(sec, secEnd , pattern,  patternEnd, UtlCharCmp<C>());
}


template <class C, class P>
inline
bool 
UtlSecIsMatch(
	const C* sec, 
	const C* secEnd, 
	const C* pattern,
	const C* patternEnd,
	const P& Comp
	)
/*++

Routine Description:
	regural expression on none null terminating sequences  with given predicator
 
Arguments:
    IN - sec - start sequence to match 

	IN - secEnd - end sequence to match 

	IN - pattern - start pattern 

	IN - pattern - end pattern 

    IN - Comp  - binary predicator to compare type C characters.
 

Returned value:
	true if  sequence the pattern - false otherwise

Note - behave like 	UtlStrIsMatch on none null terminating sequences.

*/

{
	static const C xStar('*');
	static const C xLiteralMode('^');
 

	bool LiteralMode = false;
	//
	// Skip all caracters that are the same untill patern has '*'
	//
	while(pattern != patternEnd && ( !Comp(*pattern, xStar) || LiteralMode)  )
	{
	
		if( sec == secEnd)
			return false;			

		//
		// If we find '^' we swich to literal mode if we are not in literal mode
		//
		if( Comp(*pattern, xLiteralMode) && !LiteralMode)
		{
			LiteralMode = true;
			pattern++;
			continue;
		}

		//
		// if no '*'  in the patern or literal mode - there should be exact match.
		//
		if(!Comp( *sec, *pattern)) 
			return false;

	
		LiteralMode = false;
		
 		pattern++;
		sec++;
 	}

	//
	// If patern ended - the string must also end
	//
	if(pattern == patternEnd)
			return 	sec == secEnd;


	//
	// If '*' is last - we have match.
	//
	if(++pattern ==  patternEnd)
		return true;

	//
	// Call recursivly - and try to find match for any substring after (incuding)
	// the caracter that meets the '*' in the str
	//
	for(;;)
	{
		bool fMatch =  UtlSecIsMatch(sec, secEnd, pattern, patternEnd, Comp);

		if(fMatch)
			return true;

		if(sec == secEnd)
			return false;

  	   sec++;
	}
	return false;
}

template <class T> class basic_xstr_t;
//
// template for reference countable string
//
template <class T> class CRefcountStr_t : public CReference
{
public:
	CRefcountStr_t(const T* str);
	CRefcountStr_t(T* str, int);

	CRefcountStr_t(const basic_xstr_t<T>& xstr);

public:
	const T* getstr();

private:
	CRefcountStr_t(const CRefcountStr_t&)
	{
		ASSERT(0);
	}
	
	CRefcountStr_t& operator=(const CRefcountStr_t&)
	{
		ASSERT(0);
		return *this;
	}
private:
	AP<T> m_autostr; 
};
typedef  CRefcountStr_t<wchar_t> CWcsRef;
typedef  CRefcountStr_t<char>  CStrRef;

//
// string that can hold stl string or simple c string.
// no memory managent is done to the c string 
//
template <class T> class basic_string_ex 
{
public:

	basic_string_ex(
				void
				):
				m_pstr(NULL),
				m_len(0)					
	{
	}

	//
	// Constructor from stl string - full memory management (ref counting) by the
	// stl string
	//
	explicit basic_string_ex(
		const std::basic_string<T>& str
		):
		m_str(str),
		m_pstr(str.c_str()),
		m_len(str.length())
		{
		}

	//
	// Constructor from c string - no memory management is done.
	//
	basic_string_ex(
		const T* pstr,
		size_t len
		):
		m_pstr(pstr),
		m_len(len)
		{
			ASSERT(len != 0 || pstr != NULL);			
		}

public:
	const T* getstr() const
	{
		return m_pstr;
	}

	void free()
	{
		m_len = 0;
		m_pstr = 0;
		m_str = std::basic_string<T>();
	}

	size_t getlen()const 
	{
		return m_len;				
	}

private:
	std::basic_string<T> m_str;
	const T* m_pstr;
	size_t m_len;
};
typedef  basic_string_ex<wchar_t>  Cwstringex;
typedef  basic_string_ex<char> Cstringex;


//
// Class that parse strings seperated with delimiters.
// It let you iterate over the indeviduals strings 
// for example : input string = "abd---acdf---ttt---"
//               Delemiter = "---".
//  it will give you iterator to "abc" then to "acdf" and then to
//  "ttt" 
template <class T, class Pred = UtlCharCmp<T> > class CStringToken
{
public:
	class iterator : public std::iterator<std::input_iterator_tag,basic_xstr_t<T> >
	{
	public:
	   iterator(
		const T* begin,
		const T* end,
		const CStringToken* parser
		):
	    m_value(begin,  end -  begin),
		m_parser(parser)
		{
		}
	  
		const basic_xstr_t<T>& operator*() const
		{
			ASSERT(*this != m_parser->end());
			return m_value;
		}

		
		const basic_xstr_t<T>* operator->()
		{
			return &operator*();
		}

		
		const iterator& operator++()
		{
			ASSERT(*this != m_parser->end());
			*this = m_parser->FindNext(m_value.Buffer() + m_value.Length());
			return *this;
		}
		
		const iterator  operator++(int)
		{
			const iterator tmp(*this);
			++*this;
			return tmp;
		}
		
		bool operator==(const iterator& it) const
		{
			return m_value.Buffer() == it.m_value.Buffer();
		}

		bool operator!=(const iterator& it) const
		{
			return !(operator==(it));
		}
 
	private:
		basic_xstr_t<T> m_value;
		const CStringToken* m_parser;
	};

	CStringToken(
			const T* str,
			const T* delim,
			Pred pred = Pred()
			);


	CStringToken(
			const basic_xstr_t<T>&  str,
			const basic_xstr_t<T>&  delim,
			Pred pred = Pred()
			);


	CStringToken(
			const basic_xstr_t<T>&  str,
			const T* delim,
			Pred pred = Pred()
			);


	iterator begin() const;
	iterator end() const ;
	friend iterator;

private:
const iterator FindFirst() const;
const iterator FindNext(const T* begin)const;

private:
	const T*  m_startstr;
	const T*  m_delim;
	Pred  m_pred;
	const T* m_endstr;
	const T* m_enddelim;
};
typedef  CStringToken<wchar_t> CWcsToken;
typedef  CStringToken<char> CStrToken;





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\static_stl_str.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    static_stl_str.h

Abstract:
    Header file for making stl string and stream taken from the include headers
	and not from vc runtime dll. This is due to a bug in the vc runtime dll that Av on 
	allocation faliure (nothrow allocator). When the implementation is inlined from the header
	- user defined allocator that throw on faliure can be used.

Author:
    Gil Shafriri (gilsh) 25-3-2001

--*/


#ifndef STATIC_STL_STR_H
#define STATIC_STL_STR_H

#include <string>
#include <sstream>
#include <iosfwd>


namespace std
{
	//
	// Class allocator - does what std::allocator does but it not intansiated in the vc dll.
	//
	template <class T> class allocator_static : public std::allocator<T>
	{
	
	};

	//
	// basic_string_static - Does what std::basic_string does but uses allocator_static
	// as default allocator
	//
	template<class _E,	class _Tr = char_traits<_E>, class _A = allocator_static<_E> > 
	class basic_string_static : public basic_string<_E, _Tr, _A>
	{
	public:
		typedef basic_string<_E, _Tr, _A> base;
		typedef basic_string_static<_E, _Tr, _A> _Myt;

	public:
		explicit basic_string_static(const _A& _Al = _A()):basic_string<_E, _Tr, _A>(_Al){}
		basic_string_static(const _Myt& _X, size_type _P, size_type _M, const _A& _Al = _A()):base(_X, _P, _M,_Al){} 
		basic_string_static(const _E* _S, size_type _N,const _A& _Al = _A()):base(_S, _N, _Al){}  
		basic_string_static(const _E* _S, const _A& _Al = _A()):base(_S, _Al){}  
		basic_string_static(size_type _N, _E _C, const _A& _Al = _A()):base(_N,  _C, _Al){}
		basic_string_static(_It _F, _It _L, const _A& _Al = _A()):base(_F, _L, _Al){}
		basic_string_static(const base& _X):base(_X){}
	};


	//
	// basic_ostringstream_static - Does what std::basic_ostringstream does but uses allocator_static
	// as default allocator
	//
	template<class _E,	class _Tr = char_traits<_E>, class _A = allocator_static<_E> >
	class basic_ostringstream_static : public  basic_ostringstream<_E, _Tr, _A>
	{
	public:
		typedef basic_ostringstream<_E, _Tr, _A> base;
		typedef basic_string_static<_E, _Tr, _A> _Mystr;
		
	public:
		explicit basic_ostringstream_static(openmode _M = out):base(_M){}
		explicit basic_ostringstream_static(const _Mystr& _S, openmode _M = out):base(_S, _M){}
		basic_ostringstream_static(const base& _X):base(_X){}
	};


	//
	// basic_istringstream_static - Does what std::basic_istringstream does but uses allocator_static
	// as default allocator
	//
	template<class _E,	class _Tr = char_traits<_E>, class _A = allocator_static<_E> > 
	class basic_istringstream_static : public  basic_istringstream<_E, _Tr, _A>
	{
	public:
		typedef basic_string_static<_E, _Tr, _A> _Mystr;
		typedef basic_istringstream<_E, _Tr, _A> base;
	
	public:
		explicit basic_istringstream_static(openmode _M = in):base(_M){}
		explicit basic_istringstream_static(const _Mystr& _S, openmode _M = in):base(_S, _M){}
		basic_istringstream_static(const base& _X):base(_X){}
	};


	//
	// basic_stringbuf_static - Does what std::basic_stringbuf does but uses allocator_static
	// as default allocator
	//
	template<class _E,	class _Tr = char_traits<_E>, class _A = allocator_static<_E> > 
	class basic_stringbuf_static : public  basic_stringbuf<_E, _Tr, _A>
	{
	public:
		typedef basic_string_static<_E, _Tr, _A> _Mystr;
		typedef basic_stringbuf<_E, _Tr, _A> base;
	
	public:
		explicit basic_stringbuf_static(ios_base::openmode _W = ios_base::in | ios_base::out):base(_W){}
		explicit basic_stringbuf_static(const _Mystr& _S, ios_base::openmode _W = ios_base::in | ios_base::out):base(_S, _W){}
		basic_stringbuf_static(const base& _X):base(_X){}
	};

	
	//
	// basic_stringstream_static - Does what std::basic_stringstream does but uses allocator_static
	// as default allocator
	//
	template<class _E,	class _Tr = char_traits<_E>, class _A = allocator_static<_E> > 
	class basic_stringstream_static : public  basic_stringstream<_E, _Tr, _A>
	{
	public:
		typedef basic_string_static<_E, _Tr, _A> _Mystr;
		typedef basic_stringstream<_E, _Tr, _A> base;
	
	public:
		explicit basic_stringstream_static(openmode _M = in):base(_M){}
		explicit basic_stringstream_static(const _Mystr& _S, openmode _M = in):base(_S, _M){}
		basic_stringstream_static(const base& _X):base(_X){}
	};


	typedef basic_string<char, char_traits<char>, allocator_static<char> > string_static;
	typedef basic_string<wchar_t, char_traits<wchar_t>, allocator_static<wchar_t> > wstring_static;
	typedef basic_ostringstream<char, char_traits<char>, allocator_static<char> > ostringstream_static;
    typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,allocator_static<wchar_t> > wostringstream_static;
	typedef basic_istringstream<char, char_traits<char>, allocator_static<char> > istringstream_static;
    typedef basic_istringstream<wchar_t, char_traits<wchar_t>,allocator_static<wchar_t> > wistringstream_static;
	typedef basic_stringstream<char, char_traits<char>, allocator_static<char> > stringstream_static;
    typedef basic_stringstream<wchar_t, char_traits<wchar_t>,allocator_static<wchar_t> > wstringstream_static;
};


//
// Rename symbols so only template that uses  allocator_static as default allocator could be used
//

#define string string_static
#define wstring wstring_static
#define ostringstream ostringstream_static
#define wostringstream wostringstream_static
#define stringstream stringstream_static
#define wstringstream wstringstream_static
#define istringstream istringstream_static
#define wostringstream wostringstream_static
#define basic_string basic_string_static
#define basic_stringbuf basic_stringbuf_static
#define basic_ostringstream  basic_ostringstream_static
#define basic_istringstream  basic_istringstream_static
#define basic_stringstream basic_stringstream_static


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\timetypes.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    TimeTypes.h

Abstract:
    Time instant and Time duration classes

Author:
    Uri Habusha (urih) 6-Dec-99

--*/

#pragma once

#ifndef _MSMQ_TIMETYPES_H_
#define _MSMQ_TIMETYPES_H_

//---------------------------------------------------------
//
// class CTimeDuration
//
//---------------------------------------------------------
class CTimeDuration
{
public:
    CTimeDuration(LONGLONG duration = 0) : m_duration(duration)
    {
    }


    LONGLONG Ticks(void) const
    { 
        return m_duration;
    }

    LONG InMilliSeconds(void) const;
    CTimeDuration& operator+=(const CTimeDuration& d);
    CTimeDuration operator-() const;

public:
    static CTimeDuration OneMicroSecond(void)
    { 
        return 10i64;
    }


    static CTimeDuration OneMilliSecond(void) 
    { 
        return (1000i64 * 10i64);
    }


    static CTimeDuration OneSecond(void) 
    { 
        return (1000i64 * 1000i64 * 10i64); 
    }


    static CTimeDuration MaxValue(void)
    {
        return _I64_MAX;
    }


    static CTimeDuration MinValue(void) 
    { 
        return _I64_MIN; 
    }

    static CTimeDuration FromMilliSeconds(DWORD MilliSeconds)
    {
        return OneMilliSecond().Ticks() * MilliSeconds;
    }

private:
    LONGLONG m_duration;
};


inline CTimeDuration CTimeDuration::operator-() const
{
    return -Ticks();
}


inline LONG CTimeDuration::InMilliSeconds(void) const
{
    LONGLONG t = Ticks() / OneMilliSecond().Ticks();
    if (t > _I32_MAX) 
        return _I32_MAX;

    if (t < _I32_MIN)
        return _I32_MIN;

    return static_cast<LONG>(t);
}

//---------------------------------------------------------
//
// class CTimeInstant
//
//---------------------------------------------------------
class CTimeInstant
{
public:
    CTimeInstant(ULONGLONG time) : m_time(time)
    {
    }


    ULONGLONG Ticks(void) const
    {
        return m_time;
    }


    CTimeInstant& operator+=(const CTimeDuration& d);

public:
    static CTimeInstant MaxValue(void)
    { 
        return _UI64_MAX; 
    }


    static CTimeInstant MinValue(void) 
    { 
        return 0x0i64; 
    }


private:
    ULONGLONG m_time;
};


//---------------------------------------------------------
//
// operators
//
//---------------------------------------------------------
inline bool operator<(const CTimeInstant& t1, const CTimeInstant& t2)
{ 
    return (t1.Ticks() < t2.Ticks());
}


inline bool operator==(const CTimeInstant& t1, const CTimeInstant& t2)
{ 
    return (t1.Ticks() == t2.Ticks());
}


inline bool operator<(const CTimeDuration& d1, const CTimeDuration& d2)
{ 
    return (d1.Ticks() < d2.Ticks());
}


inline bool operator==(const CTimeDuration& d1, const CTimeDuration& d2)
{ 
    return (d1.Ticks() == d2.Ticks());
}


inline CTimeDuration operator+(const CTimeDuration& d1, const CTimeDuration& d2)
{
    LONGLONG d = d1.Ticks() + d2.Ticks();

    if ((d1.Ticks() > 0) && (d2.Ticks() > 0))
    {
        if (d > 0)
            return d;

        return CTimeDuration::MaxValue();
    }
    
    if ((d1.Ticks() < 0) && (d2.Ticks() < 0))
    {
        if (d < 0)
            return d;


        return CTimeDuration::MinValue();
    }

    return d;
}


inline CTimeDuration operator-(const CTimeDuration& d1, const CTimeDuration& d2)
{
    return (d1 + -d2);
}


inline CTimeDuration operator-(const CTimeInstant& t1, const CTimeInstant& t2)
{
    LONGLONG d = t1.Ticks() - t2.Ticks();

    if (t1.Ticks() > t2.Ticks())
    {
        if (d >= 0)
            return d;

        return CTimeDuration::MaxValue();
    }

    if (d <= 0)
        return d;

    return CTimeDuration::MinValue();
}


inline CTimeInstant operator+(const CTimeInstant t, const CTimeDuration& d)
{
    ULONGLONG ticks = t.Ticks() + d.Ticks();

    if (d.Ticks() > 0)
    {
        if (ticks >= t.Ticks())
            return ticks;

        return CTimeInstant::MaxValue();
    }

    if (ticks <= t.Ticks())
        return ticks;

    return CTimeInstant::MinValue();
}


inline CTimeInstant operator-(const CTimeInstant t, const CTimeDuration& d)
{
    return (t + -d);
}


inline CTimeDuration& CTimeDuration::operator+=(const CTimeDuration& d)
{
    *this = *this + d;
    return *this;
}


inline CTimeInstant& CTimeInstant::operator+=(const CTimeDuration& d)
{
    *this = *this + d;
    return *this;
}


#endif // _MSMQ_TIMETYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\tr.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Tr.h

Abstract:
    Tracing public interface

Author:
    Conrad Chang (conradc) 13-Sept-2002

--*/


#pragma once

#ifndef _MSMQ_Tr_H_
#define _MSMQ_Tr_H_

#include <wmistr.h>
#include <evntrace.h>
#include <windows.h>

#define TR_DEFAULT_TRACEFLAGS_REGNAME               TEXT("Flags")
#define TR_DEFAULT_TRACE_REGKEYNAME                 TEXT("Trace")
#define TR_DEFAULT_MAX_TRACE_FILESIZE               4    // 4MB
#define TR_DEFAULT_MAX_TRACE_FILESIZE_REGNAME       TEXT("MaxTraceFileSize")
#define TR_DEFAULT_USE_CIRCULAR                     1    // Default to use circular file mode
#define TR_DEFAULT_USE_CIRCULAR_FILE_REGNAME        TEXT("UseCircularTraceFileMode")
#define TR_DEFAULT_NO_TRACE_FILES_LIMIT_REGNAME     TEXT("BackupwithNoTraceFileLimit")

#define TR_DEFAULT_TRACELEVELS                      0


#define TrInitialize() ((void) 0)

extern bool g_fAssertBenign;



class TrControl
{
public:
   enum TraceMode{SEQUENTIAL, CIRCULAR};


   TrControl(
        ULONG   ulTraceFlags,
        LPCWSTR pwszTraceSessionName,
        LPCWSTR pwszTraceDirectory,
        LPCWSTR pwszTraceFileName,
        LPCWSTR pwszTraceFileExt,
        LPCWSTR pwszTraceFileBackupExt,
        ULONG   ulTraceSessionFileSize=TR_DEFAULT_MAX_TRACE_FILESIZE,
        TraceMode Mode=CIRCULAR,
        LPCWSTR pwszTraceRegistryKeyName=TR_DEFAULT_TRACE_REGKEYNAME,
        LPCWSTR pwszMaxTraceSizeRegValueName=TR_DEFAULT_MAX_TRACE_FILESIZE_REGNAME,
        LPCWSTR pwszUseCircularTraceFileModeRegValueName=TR_DEFAULT_USE_CIRCULAR_FILE_REGNAME,
        LPCWSTR pwszTraceFlagsRegValueName=TR_DEFAULT_TRACEFLAGS_REGNAME,
        LPCWSTR pwszUnlimitedTraceFileNameRegValueName=TR_DEFAULT_NO_TRACE_FILES_LIMIT_REGNAME
        );

private:
    HRESULT GetTraceFileName();
    
    HRESULT 
    ComposeTraceRegKeyName(
        const GUID guid,
        LPWSTR lpszString,
        const DWORD  dwSize
        );

    HRESULT 
    GetTraceFlag(
        const GUID guid,
        DWORD *pdwValue
        );

    HRESULT 
    GetCurrentTraceSessionProperties(
        DWORD *pdwFileSize,
        BOOL  *pbUseCircular
        );

    HRESULT
    SetTraceSessionSettingsInRegistry(
        DWORD dwFileSize,
        BOOL  bUseCircular
        );

    HRESULT GetTraceSessionSettingsFromRegistry();

    HRESULT 
    CopyStringInternal(
        LPCWSTR pSource,
        LPWSTR  pDestination,
        const   DWORD dwSize
        );
    
public:
    HRESULT Start();
    HRESULT WriteRegistry();
    BOOL    IsLoggerRunning();

    HRESULT 
    UpdateTraceFlagInRegistry(
        const GUID guid,
        const DWORD  dwFlags
        );

    HRESULT 
    AddTraceProvider(
        const LPCGUID lpGuid
        );

private:
    ULONG   m_ulTraceFlags;
    WCHAR   m_szTraceSessionName[MAX_PATH+1];
    WCHAR   m_szTraceDirectory[MAX_PATH+1];
    WCHAR   m_szTraceFileName[MAX_PATH+1];
    WCHAR   m_szTraceFileExt[MAX_PATH+1];
    WCHAR   m_szTraceFileBackupExt[MAX_PATH+1];
    ULONG   m_ulDefaultTraceSessionFileSize;
    ULONG   m_ulActualTraceSessionFileSize;
    TraceMode m_Mode;
    WCHAR   m_szTraceRegistryKeyName[REG_MAX_KEY_NAME_LENGTH];

    //
    // Value length limit is REG_MAX_KEY_VALUE_NAME_LENGTH but I think  REG_MAX_KEY_NAME_LENGTH should be plenty        
    //
    WCHAR   m_szMaxTraceSizeRegValueName[REG_MAX_KEY_NAME_LENGTH];
    WCHAR   m_szUseCircularTraceFileModeRegValueName[REG_MAX_KEY_NAME_LENGTH];
    WCHAR   m_szTraceFlagsRegValueName[REG_MAX_KEY_NAME_LENGTH];
    WCHAR   m_szUnlimitedTraceFileNameRegValueName[REG_MAX_KEY_NAME_LENGTH];
    
    WCHAR   m_szFullTraceFileName[MAX_PATH+1];
    int     m_nFullTraceFileNameLength;
    int     m_nTraceSessionNameLength;
    TRACEHANDLE m_hTraceSessionHandle;
};



bool
TrAssert(
    const char* FileName,
    unsigned int Line,
    const char* Text
    );


#define UpdateTraceFlagInRegistryEx(ID)            \
        UpdateTraceFlagInRegistry(               \
               WPP_ThisDir_CTLGUID_ ## ID,         \
               WPP_QUERY_COMPID_FLAGS(rsTrace, ID) \
               ); \


#define MQASSERT(e)\
        (void) ((e) || \
                (!TrAssert(__FILE__, __LINE__, #e)) || \
                (__debugbreak(), 0))

#define MQASSERT_RELEASE(e)\
				if (!(e))\
				{\
					EXCEPTION_RECORD er = {0x80000003/*STATUS_BREAKPOINT*/, 0, 0, 0};\
				    CONTEXT ctx = {0};\
				    EXCEPTION_POINTERS ep = {&er, &ctx};\
				    UnhandledExceptionFilter(&ep);\
				}

#ifdef _DEBUG

#define ASSERT(f)          MQASSERT(f)
#define VERIFY(f)          ASSERT(f)

#define ASSERT_BENIGN(f)   do { if(g_fAssertBenign) ASSERT(f); } while(0)
#define ASSERT_RELEASE(f)  MQASSERT(f)

#else   // _DEBUG

#define ASSERT(f)          ((void)0)
#define VERIFY(f)          ((void)(f))

#define ASSERT_BENIGN(f)   ((void)0)
#define ASSERT_RELEASE(f)  MQASSERT_RELEASE(f)

#endif // !_DEBUG

#endif // _MSMQ_Tr_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\xds.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Xds.h

Abstract:
    Xml Digital Signature public interface

Author:
    Ilan Herbst (ilanh) 06-Mar-00

--*/

#pragma once

#ifndef _MSMQ_XDS_H_
#define _MSMQ_XDS_H_


#include "Cry.h"
#include "xml.h"
#include "xbuf.h"
#include "mqstl.h"

typedef xbuf_t<const void> xdsvoid_t;

//-------------------------------------------------------------------
//
// Exception class bad_Signature
//
//-------------------------------------------------------------------
class bad_signature : public exception
{
};


//-------------------------------------------------------------------
//
// Exception class bad_Signature
//
//-------------------------------------------------------------------
class bad_XmldsigElement : public exception
{
};


//-------------------------------------------------------------------
//
// Exception class bad_Reference
//
//-------------------------------------------------------------------
class bad_reference : public exception
{
};


//-------------------------------------------------------------------
//
// Exception class bad_base64
//
//-------------------------------------------------------------------
class bad_base64 : public exception
{
};


//-------------------------------------------------------------------
//
// class CXdsReference
//
//-------------------------------------------------------------------
class  CXdsReference{

public:

	enum HashAlgorithm { haSha1, haMd5, haNull };

public:

	CXdsReference()
	{
	}
};


//-------------------------------------------------------------------
//
// class CXdsReferenceInput
//
//-------------------------------------------------------------------
class CXdsReferenceInput : public CXdsReference{

public:
	

	CXdsReferenceInput(
		HashAlgorithm HashAlg,
		LPCSTR DigestValue,
		LPCSTR Uri,
		LPCSTR Type
		);


	CXdsReferenceInput(
		const xdsvoid_t& ReferenceData,
		HashAlgorithm HashAlg,
		LPCSTR Uri,
		LPCSTR Type,
		HCRYPTPROV hCsp
		);


	CXdsReferenceInput(
		ALG_ID AlgId,
		LPCSTR DigestValue,
		LPCSTR Uri,
		LPCSTR Type
		);


	CXdsReferenceInput(
		const xdsvoid_t& ReferenceData,
		ALG_ID AlgId,
		LPCSTR Uri,
		LPCSTR Type,
		HCRYPTPROV hCsp
		);


	friend std::ostream& operator<<(std::ostream& os, const CXdsReferenceInput& ReferenceInput); 


private:	
	xdsvoid_t m_ReferenceData;
	ALG_ID m_HashAlgId;
	AP<char> m_DigestValue;
	AP<char> m_Uri;
	LPCSTR m_DigestMethodName;
	AP<char> m_Type;
};
	

//-------------------------------------------------------------------
//
// class CXdsReferenceValidateInfo
//
//-------------------------------------------------------------------
class  CXdsReferenceValidateInfo : public CXdsReference{

public:

	CXdsReferenceValidateInfo(
		xwcs_t Uri,
		xwcs_t DigestMethodName,
		xwcs_t DigestValue
		);


	CXdsReferenceValidateInfo(
		xwcs_t Uri,
		xwcs_t DigestMethodName,
		xwcs_t DigestValue,
		const xdsvoid_t& ReferenceData
		);


	xwcs_t Uri() const
	{
		return(m_Uri);
	}

	
	ALG_ID HashAlgId() const
	{
		return(m_HashAlgId);
	}


	xwcs_t DigestValue() const
	{
		return(m_DigestValue);
	}


	xdsvoid_t ReferenceData() const
	{
		return(m_ReferenceData);
	}


	void SetReferenceData(const xdsvoid_t& ReferenceData)
	{
		ASSERT(ReferenceData.Buffer() != NULL);
		ASSERT(ReferenceData.Length() != 0);
		m_ReferenceData = ReferenceData;
	}


private:	
	xwcs_t m_Uri;
	ALG_ID m_HashAlgId;
	xwcs_t m_DigestValue;
	xdsvoid_t m_ReferenceData;
};


//
// Typedefs
//
typedef std::vector<CXdsReferenceInput*> ReferenceInputVectorType;
typedef std::vector<CXdsReferenceValidateInfo*> ReferenceValidateVectorType;


//----------------------------------------------------------------------------------
//
//  class CReferenceValidateVectorTypeHelper - Auto class for ReferenceValidateVectorType 
//
//----------------------------------------------------------------------------------
class CReferenceValidateVectorTypeHelper {
public:
    CReferenceValidateVectorTypeHelper(const ReferenceValidateVectorType& h) : m_h(h)  {}
   ~CReferenceValidateVectorTypeHelper()                    
	{ 
		//
		// Cleaning Vector, CXdsReferenceValidateInfo Items
		//
		for(ReferenceValidateVectorType::iterator ir = m_h.begin(); 
			ir != m_h.end();)
		{
			CXdsReferenceValidateInfo* pReferenceValidateInfo = *ir;
			ir = m_h.erase(ir);
			delete pReferenceValidateInfo;
		}
	}

    ReferenceValidateVectorType& operator *()          { return m_h; }
    ReferenceValidateVectorType* operator ->()         { return &m_h; }

private:
    CReferenceValidateVectorTypeHelper(const CReferenceValidateVectorTypeHelper&);
    CReferenceValidateVectorTypeHelper& operator=(const CReferenceValidateVectorTypeHelper&);

private:
	ReferenceValidateVectorType m_h;
};


//-------------------------------------------------------------------
//
// class CXdsSignedInfo
//
//-------------------------------------------------------------------
class  CXdsSignedInfo{

public:

	enum SignatureAlgorithm { saDsa };

public:


	CXdsSignedInfo(
		SignatureAlgorithm SignatureAlg,
		LPCSTR Id,
		std::vector<CXdsReferenceInput*>& ReferenceInputs
		);
		

	~CXdsSignedInfo()
	{
		//
		// Empty m_References list  and free ReferenceElement strings
		//
		for(ReferenceInputVectorType::iterator it = m_ReferenceInputs.begin(); 
			it != m_ReferenceInputs.end();)
		{
			CXdsReferenceInput* pReferenceInput = *it;
			it = m_ReferenceInputs.erase(it);
			delete pReferenceInput;
		}
	}


	friend std::ostream& operator<<(std::ostream& os, const CXdsSignedInfo& SignedInfo); 


	ALG_ID SignatureAlgId() const
	{
		return(m_SignatureAlgId);
	}

private:
	AP<char> m_Id;
	ALG_ID m_SignatureAlgId;
	LPCSTR m_SignatureMethodName;
	ReferenceInputVectorType m_ReferenceInputs;
};


//-------------------------------------------------------------------
//
// class CXdsSignature
//
//-------------------------------------------------------------------
class  CXdsSignature{

public:

	CXdsSignature(
		CXdsSignedInfo::SignatureAlgorithm SignatureAlg,
		LPCSTR SignedInfoId,
		std::vector<CXdsReferenceInput*>& ReferenceInputs,
		LPCSTR Id,
		HCRYPTPROV hCsp,
		LPCSTR KeyValue = NULL
		) :
		m_SignedInfo(SignatureAlg, SignedInfoId, ReferenceInputs),
		m_Id(newstr(Id)),
		m_SignatureValue(NULL),
		m_KeyValue(newstr(KeyValue)),
		m_hCsp(hCsp),
		m_PrivateKeySpec(AT_SIGNATURE)
	{
	}


	CXdsSignature(
		CXdsSignedInfo::SignatureAlgorithm SignatureAlg,
		LPCSTR SignedInfoId,
		std::vector<CXdsReferenceInput*>& ReferenceInputs,
		LPCSTR Id,
		LPCSTR SignatureValue,
		LPCSTR KeyValue = NULL
		) :
		m_SignedInfo(SignatureAlg, SignedInfoId, ReferenceInputs),
		m_Id(newstr(Id)),
		m_SignatureValue(newstr(SignatureValue)),
		m_KeyValue(newstr(KeyValue)),
		m_hCsp(NULL),
		m_PrivateKeySpec(AT_SIGNATURE)
	{
	}


	CXdsSignature(
		CXdsSignedInfo::SignatureAlgorithm SignatureAlg,
		LPCSTR SignedInfoId,
		std::vector<CXdsReferenceInput*>& ReferenceInputs,
		LPCSTR Id,
		HCRYPTPROV hCsp,
		DWORD PrivateKeySpec,
		LPCSTR KeyValue = NULL
		) :
		m_SignedInfo(SignatureAlg, SignedInfoId, ReferenceInputs),
		m_Id(newstr(Id)),
		m_SignatureValue(NULL),
		m_KeyValue(newstr(KeyValue)),
		m_hCsp(hCsp),
		m_PrivateKeySpec(PrivateKeySpec)
	{
	}


	CXdsSignature(
		CXdsSignedInfo::SignatureAlgorithm SignatureAlg,
		LPCSTR SignedInfoId,
		std::vector<CXdsReferenceInput*>& ReferenceInputs,
		LPCSTR Id,
		LPCSTR SignatureValue,
		DWORD PrivateKeySpec,
		LPCSTR KeyValue = NULL
		) :
		m_SignedInfo(SignatureAlg, SignedInfoId, ReferenceInputs),
		m_Id(newstr(Id)),
		m_SignatureValue(newstr(SignatureValue)),
		m_KeyValue(newstr(KeyValue)),
		m_hCsp(NULL),
		m_PrivateKeySpec(PrivateKeySpec)
	{
	}


	friend std::ostringstream& operator<<(std::ostringstream& oss, const CXdsSignature& Signature);


	ALG_ID SignatureAlgId() const
	{
		return(m_SignedInfo.SignatureAlgId());
	}

	
	LPSTR SignatureElement()
	{
		std::ostringstream oss("");
		oss << *this;
		std::string TempStr = oss.str();

		//
		// c_str() return a null terminated string (opposite to data())
		// Mp (message protocol) lib assume the signature element is null terminated
		//
		return(newstr(TempStr.c_str()));
	}

private:
	AP<char> m_Id;
	CXdsSignedInfo m_SignedInfo;
	AP<char> m_SignatureValue;
	AP<char> m_KeyValue;
	DWORD m_PrivateKeySpec;
	HCRYPTPROV m_hCsp;
};


//
// Api
//
VOID
XdsInitialize(
    VOID
    );


LPWSTR
Octet2Base64W(
	const BYTE* OctetBuffer, 
	DWORD OctetLen, 
	DWORD *Base64Len
	);


LPSTR
Octet2Base64(
	const BYTE* OctetBuffer, 
	DWORD OctetLen, 
	DWORD *Base64Len
	);


BYTE* 
Base642OctetW(
	LPCWSTR Base64Buffer, 
	DWORD Base64Len,
	DWORD *OctetLen 
	);



LPWSTR
XdsCalcDataDigestW(
	const void *Data,
	DWORD DataLen,
	ALG_ID AlgId,
	HCRYPTPROV hCsp
	);


LPSTR
XdsCalcDataDigest(
	const void *Data,
	DWORD DataLen,
	ALG_ID AlgId,
	HCRYPTPROV hCsp
	);


LPSTR
XdsGetDataDigest(
	HCRYPTHASH hHash
	);


LPSTR
XdsCalcSignature(
	LPCSTR Data,
	DWORD DataLen,
	ALG_ID AlgId,
	DWORD PrivateKeySpec,
	HCRYPTPROV hCsp
	);


ReferenceValidateVectorType
XdsGetReferenceValidateInfoVector(
	const XmlNode* SignatureNode
    );


void
XdsValidateReference(
	const CXdsReferenceValidateInfo& ReferenceValidateInfo,
	HCRYPTPROV hCsp
    );


std::vector<bool>
XdsValidateAllReference(
	const ReferenceValidateVectorType& ReferenceValidateInfoVector,
	HCRYPTPROV hCsp
    );


void
XdsValidateSignature(
	const XmlNode* SignatureNode,
	HCRYPTKEY hKey,
	HCRYPTPROV hCsp
    );


void
XdsCoreValidation(
	const XmlNode* SignatureNode,
	HCRYPTKEY hKey,
	const ReferenceValidateVectorType& ReferenceValidateInfoVector,
	HCRYPTPROV hCsp
    );

#endif // _MSMQ_XDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\xmlencode.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Xml.h

Abstract:
    Xml classes for encoding decoding special xml caracters

Author:
    Gil Shafriri (gilsh) 15-Feb-2001

--*/

#pragma once

#ifndef _MSMQ_XMLENCODE_H_
#define _MSMQ_XMLENCODE_H_

#include <buffer.h>
#include <xstr.h>

//---------------------------------------------------------
//
// CXmlEncode - class for encoding xml characters  treating special caracters. 
//
//---------------------------------------------------------
class CXmlEncode
{
public:
	CXmlEncode(const xwcs_t& wcs);

private:
	const xwcs_t& m_wcs;
	friend std::wostream& operator<<(std::wostream& o, const CXmlEncode& XmlEncode);
};



//---------------------------------------------------------
//
// CXmlDecode - class for decoding emcoded xml caracters 
//
//---------------------------------------------------------
class CXmlDecode
{
public:
	CXmlDecode();

public:
	const xwcs_t get() const;
	void Decode(const xwcs_t& encoded);

private:
	const WCHAR* HandleReguralChar(const WCHAR* ptr);
	const WCHAR* HandleSpeciallChar(const WCHAR* ptr, const WCHAR* end);

private:
	xwcs_t m_encoded;
	bool m_fConverted;
	CStaticResizeBuffer<WCHAR, 256> m_DecodedBuffer;
};


//---------------------------------------------------------
//
// bad_xml_encoding - exception class thrown 
// if  CXmlDecode detect bad encoding
//
//---------------------------------------------------------
class bad_xml_encoding	: public exception
{

	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\utf8.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    utf8.h

Abstract:
    Conversion routine from utf8 caracters format to unicode and via versa.

Author:
    Gil Shafriri (gilsh) 8-11-2000

--*/

#pragma once

#ifndef _MSMQ_UTF8_H_
#define _MSMQ_UTF8_H_

//
// exception class for utf8 conversion exception - thrown  only
// because of invalid input
//
class bad_utf8 : public std::exception
{
};

typedef unsigned char utf8_char;
typedef std::basic_string<unsigned char> utf8_str;


size_t 
UtlUtf8LenOfWcs(
		const wchar_t* pwc
		)
		throw();


size_t 
UtlUtf8LenOfWcs(
		const wchar_t* pwc,
		size_t cbWcs
		)
		throw();


size_t
UtlWcToUtf8(
	wchar_t wc ,
	utf8_char *pUtf8, 
	size_t cbUtf8
	);


//
//utf8 c string to unicode c string
//
void 
UtlUtf8ToWcs(
		const utf8_char *pUtf8,
		wchar_t* pWcs,
		size_t cbWcs,
		size_t* pActualLen = NULL
		);


//
// unicode c string to utf8 c string
//
void
UtlWcsToUtf8(
		const wchar_t* pwcs,
		utf8_char* pUtf8,
		size_t cbUtf8,
		size_t* pActualLen  = NULL
		);
//
// unicode buffer to utf8 c string
//
void
UtlWcsToUtf8(
		const wchar_t* pwcs, 
		size_t cbwcs,
		utf8_char* pUtf8,
		size_t cbUtf8,
		size_t* pActualLen = NULL
		);

//
// utf8 c string to unicode c string
//
wchar_t* 
UtlUtf8ToWcs(
		const utf8_char* pUtf8,
		size_t* pActualLen  = NULL
		);

//
// utf8 buffer to unicode string
//
wchar_t* 
UtlUtf8ToWcs(
		const utf8_char* pUtf8,
		size_t cbUtf8,
		size_t* pActualLen
		);


//
// unicode buffer to utf8 c string
//
utf8_char* 
UtlWcsToUtf8(
		const wchar_t* pwcs,
		size_t* pActualLen  = NULL
		);

//
// unicode stl string to utf8 stl string.
//
utf8_str 
UtlWcsToUtf8(
			const std::wstring& wcs
			);

//
// unicode buffer to utf8 stl string
//
utf8_str 
UtlWcsToUtf8(
		const wchar_t* pwcs,
		size_t cbWcs
		);



//
// utf8 stl string to  unicode stl string.
//
std::wstring 
UtlUtf8ToWcs(
		const utf8_str& utf8
		);

//
// utf8 buffer to unicode stl string
//
std::wstring 
UtlUtf8ToWcs(
		const utf8_char* pUtf8,
		size_t cbUtf8
		);






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\xstr.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    xstr.h

Abstract:
    Length String definition and implementation

	xstr_t is reprisented as length and a character pointer, based on xbuf_t.
	The text pointed to is not a null terminated string, but rather a text
	contained within a 	larger text buffer.

Author:
    Erez Haba (erezh) 7-Sep-99

--*/

#pragma once

#include <xbuf.h>
#include <mqcast.h>


//-------------------------------------------------------------------
//
// class xstr_t
//
//-------------------------------------------------------------------
template <class T>
class basic_xstr_t : public xbuf_t<const T> {
public:

    basic_xstr_t(void)
	{
    }


	basic_xstr_t(const T* buffer, size_t length) :
		xbuf_t<const T>(buffer, length)
	{
	}

	T* ToStr() const
	{
		T* pStr = new T[Length() + 1];	
		CopyTo(pStr);
		return pStr;
	}

	void CopyTo(T* buffer) const
	{
		memcpy(buffer, Buffer(), Length()*sizeof(T));
		buffer[Length()] = 0;
	}
};

typedef  basic_xstr_t<char>  xstr_t;
typedef  basic_xstr_t<WCHAR> xwcs_t;

inline bool operator==(const xstr_t& x1, const char* s2)
{
    //
    // Check that the strings are matching to the length of x1 and that s2 is
    // the same length.
    //
	return ((strncmp(x1.Buffer(), s2, x1.Length()) == 0) && (s2[x1.Length()] == '\0'));
}


inline bool operator!=(const xstr_t& x1, const char* s2)
{
	return !(x1 == s2);
}


inline bool operator==(const xwcs_t& x1, const WCHAR* s2)
{
    //
    // Check that the strings are matching to the length of x1 and that s2 is
    // the same length.
    //
	return ((wcsncmp(x1.Buffer(), s2, x1.Length()) == 0) && (s2[x1.Length()] == L'\0'));
}


inline bool operator!=(const xwcs_t& x1, const WCHAR* s2)
{
	return !(x1 == s2);
}


inline UNICODE_STRING XwcsToUnicodeString(const xwcs_t& x)
{
	UNICODE_STRING str;
	int len = x.Length() * sizeof(WCHAR);
	len = min(len, 16 * 1024);
	str.Length = numeric_cast<USHORT>(len);
	str.MaximumLength = str.Length;
	str.Buffer = const_cast<PWSTR>(x.Buffer());
	return str;
}


#define S_XSTR(x) xstr_t((x),STRLEN(x))
#define S_XWCS(x)  xwcs_t((x),STRLEN(x))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mm\lib\mem.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    mem.cpp

Abstract:
    Memory Allocator

Author:
    Erez Haba (erezh) 04-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "allocaptr.h"

#include "mem.tmh"

#undef new

CSafeAllocaInitializer g_initSafeAlloca;

#ifdef _DEBUG

//
// Memory allocation probability
//
static int s_AllocationProbability = RAND_MAX;

DWORD
MmAllocationProbability(
	DWORD AllocationProbability
	)
{
	ASSERT(AllocationProbability <= 100);
	DWORD ap = s_AllocationProbability;
	s_AllocationProbability = (AllocationProbability * RAND_MAX) / 100;
	return ap;
}


VOID
MmSetAllocationSeed(
	DWORD AllocationSeed
	)
{
	srand(AllocationSeed);
}
						

static bool FailAllocation()
{
	return (rand() > s_AllocationProbability);
}


const unsigned char xNoMansLandFill = 0xFD;
const unsigned char xDeadLandFill = 0xDD;
const unsigned char xClearLandFill = 0xCD;

const int xSignature = 'zerE';

struct CBlockHeader {
    size_t m_size;
    const char* m_file;
    int m_line;
    int m_signature;
    unsigned char m_data[0];
};

inline void* Allocate(size_t s, const char* fn, int l)
{
	if(FailAllocation())
	{
		TrERROR(GENERAL, "Failing %Id bytes allocation at %s(%d)", s, fn, l);
		return 0;
	}

	CBlockHeader* pHeader = (CBlockHeader*)malloc(s + sizeof(CBlockHeader));
    if(pHeader == 0)
        return 0;

    pHeader->m_size = s;
    pHeader->m_file = fn;
    pHeader->m_line = l;
    pHeader->m_signature = xSignature;
    return memset(&pHeader->m_data, xClearLandFill, s);
}


inline void Deallocate(void* p)
{
    if(p == 0)
        return;

    CBlockHeader* pHeader = static_cast<CBlockHeader*>(p) - 1;

    ASSERT(pHeader->m_signature == xSignature);
    memset(pHeader, xDeadLandFill, pHeader->m_size + sizeof(CBlockHeader));
    free(pHeader);
}


#else // _DEBUG


inline void* Allocate(size_t s, const char*, int)
{
	return 	malloc(s);
}


inline void Deallocate(void* p)
{
    free(p);
}


#endif // _DEBUG


void* MmAllocate(size_t s) throw(bad_alloc)
{
    void* p = Allocate(s, __FILE__, __LINE__);

    if(p != 0)
		return p;

    TrERROR(GENERAL, "Failed to allocate %Id bytes.", s);
	MmThrowBadAlloc();
}


void* MmAllocate(size_t s, const nothrow_t&) throw()
{
    void* p = Allocate(s, __FILE__, __LINE__);
    if(p == 0)
    {
		TrERROR(GENERAL, "Failed to allocate %Id bytes with nothrow.", s);
    }
    return p;
}


void* MmAllocate(size_t s, const char* fn, int l) throw(bad_alloc)
{
    void* p = Allocate(s, fn, l);

    if(p != 0)
		return p;

	TrERROR(GENERAL, "Failed to allocate %Id bytes at %s(%d).", s, fn, l);
	MmThrowBadAlloc();
}


void* MmAllocate(size_t s, const char* fn, int l, const nothrow_t&) throw()
{
    void* p = Allocate(s, fn, l);
    if(p == 0)
    {
		TrERROR(GENERAL, "Failed to allocate %Id bytes with nothrow at %s(%d).", s, fn, l);
    }
    return p;
}


void MmDeallocate(void* p) throw()
{
    Deallocate(p);
}


static bad_alloc s_bad_alloc;

__declspec(noreturn) void MmThrowBadAlloc() throw(bad_alloc)
{
	throw s_bad_alloc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\xml.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Xml.h

Abstract:
    Xml public interface

Author:
    Erez Haba (erezh) 15-Sep-99

--*/

#pragma once

#ifndef _MSMQ_XML_H_
#define _MSMQ_XML_H_



#include "xstr.h"
#include "List.h"

class XmlNode;

//
// Interface given to the xml parser to map namespace string to id
//
class INamespaceToId
{
public:
	virtual int operator[](const xwcs_t& ns)const  = 0;
	virtual ~INamespaceToId(){};
};


VOID
XmlInitialize(
    VOID
    );

VOID
XmlFreeTree(
	XmlNode* Tree
	);


const WCHAR*
XmlParseDocument(
	const xwcs_t& doc,
	XmlNode** ppTree,
	const INamespaceToId* = NULL
	);


const
XmlNode*
XmlFindNode(
	const XmlNode* Tree,
	const WCHAR* NodePath
	);


const
xwcs_t*
XmlGetNodeFirstValue(
	const XmlNode* Tree,
	const WCHAR* NodePath
	);


const
xwcs_t*
XmlGetAttributeValue(
	const XmlNode* Tree,
	const WCHAR* AttributeTag,
	const WCHAR* NodePath = NULL
	);


#ifdef _DEBUG

VOID
XmlDumpTree(
	const XmlNode* Tree
	);

#else // _DEBUG

#define XmlDumpTree(Tree) ((void)0);

#endif // _DEBUG



//-------------------------------------------------------------------
//
// class XmlNameSpace
//
//-------------------------------------------------------------------
class XmlNameSpace
{
public:	
	XmlNameSpace(
		const xwcs_t& prefix
		):
	m_prefix(prefix),
	m_nsid(0)
	{
	}


	XmlNameSpace(
	const xwcs_t& prefix,
	const xwcs_t& uri
	)
	:
	m_prefix(prefix),
	m_uri(uri)
	{
	}

	xwcs_t m_prefix;
	xwcs_t m_uri;
	int m_nsid;
};


//-------------------------------------------------------------------
//
// class XmlAttribute
//
//-------------------------------------------------------------------
class XmlAttribute {
public:
	XmlAttribute(const xwcs_t& prefix,const xwcs_t& tag, const xwcs_t& value) :
		m_tag(tag),
		m_value(value),
		m_namespace(prefix)
	{
	}
		
public:
	LIST_ENTRY m_link;
	xwcs_t m_tag;
	xwcs_t m_value;
	XmlNameSpace m_namespace;

private:
    XmlAttribute(const XmlAttribute&);
    XmlAttribute& operator=(const XmlAttribute&);
};


//-------------------------------------------------------------------
//
// class XmlValue
//
//-------------------------------------------------------------------
class XmlValue {
public:
	XmlValue(const xwcs_t& value) :
		m_value(value)
	{
	}

public:
	LIST_ENTRY m_link;
	xwcs_t m_value;

private:
    XmlValue(const XmlValue&);
    XmlValue& operator=(const XmlValue&);
};




//-------------------------------------------------------------------
//
// class XmlNode
//
//-------------------------------------------------------------------
class XmlNode {
public:
    XmlNode(const xwcs_t& prefix,const xwcs_t& tag) :
		m_tag(tag),m_namespace(prefix)

    {
		
    }


public:
	LIST_ENTRY m_link;
	List<XmlAttribute> m_attributes;
	List<XmlValue> m_values;
	List<XmlNode, 0> m_nodes;
	xwcs_t m_tag;
	xwcs_t m_element;  // all element include the start tag and end tag
	xwcs_t m_content;  // element content not include start tag and end tag
	XmlNameSpace m_namespace;


private:
    XmlNode(const XmlNode&);
    XmlNode& operator=(const XmlNode&);
};

//
// Ensure that m_link offset in XmlNode is zero.
// As we can not have List<XmlNode> used inside XmlNode definition, so
// we assume that the link offset is zero and use List<XmlNode, 0>
// instade.
//
C_ASSERT(FIELD_OFFSET(XmlNode, m_link) == 0);




//-------------------------------------------------------------------
//
// Exception class bad_document
//
//-------------------------------------------------------------------
class bad_document : public exception {
public:
    bad_document(const WCHAR* ParsingErrorLocation) :
        m_location(ParsingErrorLocation)
    {
    }

    const WCHAR* Location() const
    {
        return m_location;
    }

private:
    const WCHAR* m_location;
};


//---------------------------------------------------------
//
// XmlNode release helper
//
//---------------------------------------------------------
class CAutoXmlNode {
private:
    XmlNode* m_p;

public:
    CAutoXmlNode(XmlNode* p = 0) : m_p(p)    {}
   ~CAutoXmlNode()                { free(); }

    operator XmlNode*() const     { return m_p; }
    XmlNode** operator&()         { return &m_p;}
    XmlNode* operator->() const   { return m_p; }
    XmlNode* detach()             { XmlNode* p = m_p; m_p = 0; return p; }
    void free()                   { if(m_p !=0){ XmlFreeTree(m_p); m_p = 0; } }
    void swap(CAutoXmlNode& rhs)  { std::swap( m_p, rhs.m_p); }

private:
    CAutoXmlNode(const CAutoXmlNode&);
    CAutoXmlNode& operator=(const CAutoXmlNode&);
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\inc\xbuf.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    xbuf.h

Abstract:
    Length buffer definition and implementation

	xbuf_t is reprisented as length and a typed buffer pointer.

    Memory representation,
	 +---+---+    --+-----------------+---
	 |Len|Ptr|----->|buffer pointed to|...
	 +---+---+    --+-----------------+---
	  xbuf_t		 .... buffer ....

Author:
    Erez Haba (erezh) 23-Sep-99

--*/

#pragma once

//-------------------------------------------------------------------
//
// class xbuf_t
//
//-------------------------------------------------------------------
template<class T>
class xbuf_t {
public:

    xbuf_t() :
		m_buffer(0),
		m_length(0)
	{
    }


	xbuf_t(T* buffer, size_t length) :
		m_buffer(buffer),
		m_length((int)length)
	{
		ASSERT((length == 0) || (buffer != 0));
	}


	T* Buffer() const
	{
		return m_buffer;
	}


	int Length() const
	{
		return m_length;
	}


private:
	int m_length;
	T* m_buffer;
};


template<class T> inline bool operator==(const xbuf_t<T>& x1, const xbuf_t<T>& x2)
{
	if(x1.Length() != x2.Length())
		return false;

	return (memcmp(x1.Buffer(), x2.Buffer(), x1.Length() * sizeof(T)) == 0);
}


template<class T> inline bool operator<(const xbuf_t<T>& x1, const xbuf_t<T>& x2)
{
	int minlen min(x1.Length(), x2.Length());
	int rc = memcmp(x1.Buffer(), x2.Buffer(), minlen * sizeof(T));
	if(rc != 0)
		return rc <0;

    return 	x1.Length() <  x2.Length();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mm\lib\mmdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MmDebug.cpp

Abstract:
    Memory Manager debugging

Author:
    Erez Haba (erezh) 03-Apr-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Mm.h"

#include "mmdebug.tmh"

#ifdef _DEBUG


static _CrtMemState s_memState ;
 
void MmCheckpoint(void)
{
    //_CrtMemCheckpoint(&s_memState);
}


void MmDumpUsage(void)
{
    //_CrtMemDumpAllObjectsSince(&s_memState);
}


DWORD
MmAllocationValidation(
	DWORD /*AllocationFlags*/
	)
{
	return 0;//_CrtSetDbgFlag(AllocationFlags);
}


DWORD
MmAllocationBreak(
	DWORD /*AllocationNumber*/
	)
{
	return 0;//_CrtSetBreakAlloc(AllocationNumber);
}


bool
MmIsStaticAddress(
    const void* Address
    )
{
    MEMORY_BASIC_INFORMATION Info;
    VirtualQuery(Address, &Info, sizeof(Info));

    return (Info.Type == MEM_IMAGE);
}


#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mm\lib\str.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    str.cpp

Abstract:
    Simple string and memory manipulations

Author:
    Erez Haba (erezh) 09-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>

#include "str.tmh"

LPWSTR newwcs(LPCWSTR p)
{
    if(p == 0)
        return 0;

    LPWSTR dup = new WCHAR[wcslen(p) + 1];
    return wcscpy(dup, p);
}


LPSTR newstr(LPCSTR p)
{
    if(p == 0)
        return 0;

    LPSTR dup = new CHAR[strlen(p) + 1];
    return strcpy(dup, p);
}

LPWSTR newwcscat(LPCWSTR s1,LPCWSTR s2)
{
    if(s1 == 0 || s2 == 0)
        return 0;

    LPWSTR scat = new WCHAR[wcslen(s1) + wcslen(s2) +1];
    wcscpy(scat,s1);
	wcscat(scat,s2);

	return scat;
}


LPSTR newstrcat(LPCSTR s1,LPCSTR s2)
{
    if(s1 == 0 || s2 == 0)
	{
		return 0;
	}

    LPSTR scat = new CHAR[strlen(s1) +strlen(s2) +1];
    strcpy(scat,s1);
	strcat(scat,s2);

	return scat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mmt\lib\mmt.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    Mmt.cpp

Abstract:

    Multicast Message Transport implementation

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent,

--*/

#include <libpch.h>
#include <st.h>
#include "Mmt.h"
#include "Mmtp.h"
#include "MmtObj.h"

#include "mmt.tmh"

R<CMulticastTransport>
MmtCreateTransport(
	MULTICAST_ID id,
	IMessagePool * pMessageSource,
	ISessionPerfmon* pPerfmon,
    const CTimeDuration& retryTimeout,
    const CTimeDuration& cleanupTimeout
    )
{
    MmtpAssertValid();

    ASSERT(pMessageSource != NULL);

	ISocketTransport* pWinsock; 
    pWinsock = StCreatePgmWinsockTransport();
	P<ISocketTransport> Winsock(pWinsock);

    CMessageMulticastTransport * pMmt;
    pMmt = new CMessageMulticastTransport(
                   id, 
                   pMessageSource, 
				   pPerfmon,
                   retryTimeout, 
                   cleanupTimeout,
                   Winsock
                   );
    return pMmt;

} // MmtCreateTransport
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mmt\lib\mmtdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MmtDebug.cpp

Abstract:

    Multicast Message Transport debugging

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Mmt.h"
#include "Mmtp.h"

#include "mmtdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Message Transport state
//
VOID MmtpAssertValid(VOID)
{
    //
    // MmtInitalize() has *not* been called. You should initialize the
    // Multicast Message Transport library before using any of its funcionality.
    //
    ASSERT(MmtpIsInitialized());
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

VOID MmtpSetInitialized(VOID)
{
    LONG fAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Multicast Message Transport library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fAlreadyInitialized);
}


BOOL MmtpIsInitialized(VOID)
{
    return s_fInitialized;
}


VOID MmtpRegisterComponent(VOID)
{
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mmt\lib\mmtget.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MmtGet.cpp

Abstract:

    Get message from queue in order to multicast it.

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include "Mmt.h"
#include "Mmtp.h"
#include "MmtObj.h"

#include "mmtget.tmh"

VOID CMessageMulticastTransport::GetNextEntry(VOID)
{
    //
    // Protect m_state and m_fPendingRequest. 
    // Insure that no one closes the connection while we are trying to issue get request.
    //
    CSR readLock(m_pendingShutdown);

    if ((State() == csShuttingDown) || (State() == csShutdownCompleted))
        throw exception();

    try
    { 
        AddRef();
        m_pMessageSource->GetFirstEntry(&m_RequestEntry, m_RequestEntry.GetAcPacketPtrs());
    }
    catch (const exception&)
    {    
        Release();
        throw;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mm\test\mmtest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MmTest.cpp

Abstract:
    Memory library test

Author:
    Erez Haba (erezh) 04-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Mm.h"

#include "MmTest.tmh"

LPCWSTR MmTest = L"Memory Test";

extern "C" int __cdecl _tmain(int /*argc*/, LPCTSTR /*argv*/[])
/*++

Routine Description:
    Test Memory library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	TrInitialize();

	MmAllocationValidation(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);

	void* p = new int[1000];

	//
	// Let memory aloocations succeed on 20% of the allocations
	//
	MmAllocationProbability(20);

	int AllocSuccess = 0;
	for(int i = 0; i < 1000; i++)
	{
		try
		{
			AP<WCHAR> q = newwcs(L"Erez");
			++AllocSuccess;
		}
		catch(const bad_alloc&)
		{
			NULL;
		}
	}

	for(int i = 0; i < 1000; i++)
	{
		try
		{
			AP<WCHAR> q = newwcscat(L"Foo&",L"Bar");
			AP<CHAR> q2 = newstrcat("Foo&","Bar");
			++AllocSuccess;
		}
		catch(const bad_alloc&)
		{
			NULL;
		}
	}



	delete[] p;

	printf("Allocation succeed for %d%%\n", (AllocSuccess * 100) / 1000);

    //
    // Check for static addresses
    //
    ASSERT(MmIsStaticAddress(MmTest));

	MmAllocationProbability(xAllocationAlwaysSucceed);
    void* q = new int[10];
    ASSERT(!MmIsStaticAddress(&q));
    ASSERT(!MmIsStaticAddress(q));
    delete[] q;

    WPP_CLEANUP();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mmt\lib\mmtconnect.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MmtConnect.cpp

Abstract:

    Multicast Message Transport class - Connect implementation

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include <mqsymbls.h>
#include <mqwin64a.h>
#include <mqformat.h>
#include "Mtm.h"
#include "Mmt.h"
#include "Mmtp.h"
#include "MmtObj.h"

#include "mmtconnect.tmh"


VOID 
CMessageMulticastTransport::RequeuePacketMustSucceed(
    VOID
    )
/*++

Routine Description:

    The routine requeus the packet currently processed by the transport.
    If the requeue operation fails, the routine will Sleep and loop
    This routine should not be called within a critical section.
  
Arguments:

    None.
  
Returned Value:

    None.

--*/
{
    CACPacketPtrs& acPtrs = m_RequestEntry.GetAcPacketPtrs();

    ASSERT(acPtrs.pDriverPacket != NULL);
    ASSERT(acPtrs.pPacket != NULL);

    CQmPacket Entry(acPtrs.pPacket, acPtrs.pDriverPacket);
	AppRequeueMustSucceed(&Entry);

    acPtrs.pPacket = NULL;
    acPtrs.pDriverPacket = NULL;

} // CMessageMulticastTransport::RequeuePacketMustSucceed


VOID 
WINAPI 
CMessageMulticastTransport::GetPacketForConnectingSucceeded(
    EXOVERLAPPED* pov
    )
/*++

Routine Description:

    The routine is called when a new packet is received for sending on non
    connecting message transport. Getting the message is used as a trigger 
    for creating a connection
  
Arguments:

    pov - pointer to overlapped structure.
  
Returned Value:

    None.

--*/
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

	CRequestOv* pRequest = static_cast<CRequestOv*>(pov);
    R<CMessageMulticastTransport> pMmt = CONTAINING_RECORD(pRequest, CMessageMulticastTransport, m_RequestEntry);

    WCHAR buffer[MAX_PATH];
    MQpMulticastIdToString(pMmt->MulticastId(), buffer, TABLE_SIZE(buffer));
    TrTRACE(NETWORKING, "Connecting to %ls. pMmt = %p", buffer, pMmt.get());

    //
    // Return the message to the queue before create the connection.
    //
    pMmt->RequeuePacketMustSucceed();
    try
    {
        if (! pMmt->TryToCancelCleanupTimer())
            return;

        pMmt->Connect();
    }
    catch(const exception&)
    {
        TrERROR(NETWORKING, "Failed to create connection to '%ls'. pMmt = %p", buffer, pMmt.get());
        
        pMmt->ScheduleRetry();
        throw;
    }
} // CMessageMulticastTransport::GetPacketForConnectingSucceeded


VOID 
WINAPI 
CMessageMulticastTransport::GetPacketForConnectingFailed(
    EXOVERLAPPED* pov
    )
/*++

Routine Description:

    The routine is called when we fail to get a a new packet from the queue.
    The message transport is in non connecting state, so we try to get the 
    message sometime later.
  
Arguments:

    pov - pointer to overlapped structure.
  
Returned Value:

    None.

--*/
{
    ASSERT(FAILED(pov->GetStatus()));

    //
    // Retrieve message transport
    //
	CRequestOv* pRequest = static_cast<CRequestOv*>(pov);
    R<CMessageMulticastTransport> pMmt = CONTAINING_RECORD(pRequest, CMessageMulticastTransport, m_RequestEntry);

    TrERROR(NETWORKING, "Failed to get a new entry for connecting. pMmt = 0x%p", pMmt.get());
    
    pMmt->Shutdown();

} // CMessageMulticastTransport::GetPacketForConnectingFailed


VOID 
WINAPI 
CMessageMulticastTransport::TimeToRetryConnection(
    CTimer * pTimer
    )
/*++

Routine Description:

    It is time to retry connecting to the destination. This function is called
    by the timer after failing to create a connection.

Arguments:

    pTimer - pointer to CTimer object embedded in the message transport object.
  
Returned Value:

    None.

--*/
{
    R<CMessageMulticastTransport> pMmt = CONTAINING_RECORD(pTimer, CMessageMulticastTransport, m_retryTimer);


    pMmt->StartCleanupTimer();

    //
    // Ask for new message from the queue. Getting a message from the queue
    // triggers the creation of the connection
    //
    // NOTE: If this function throws, the transport will be closed at *idle* time,
    //       which is okay as we are low on resources.
    //
    pMmt->GetNextEntry();

} // CMessageMulticastTransport::TimeToRetryConnection


void
CMessageMulticastTransport::InitPerfmonCounters(
	LPCWSTR strMulticastId
	)
{
    m_pPerfmon->CreateInstance(strMulticastId);
}


VOID 
CMessageMulticastTransport::ConnectionSucceeded(
    VOID
    )
/*++

Routine Description:

    The routine is called when create a connection completes successfully
  
Arguments:

    None.
  
Returned Value:

    None.

--*/
{
	m_pConnection = m_SocketTransport->GetConnection();
	ASSERT(m_pConnection.get() != NULL);
   
    WCHAR buffer[MAX_PATH];
    MQpMulticastIdToString(MulticastId(), buffer, TABLE_SIZE(buffer));
    TrTRACE(NETWORKING, "Connected to '%ls'",  buffer);

    State(csConnected);

	//
    // Create Session permormance counter structure
    //
    InitPerfmonCounters(buffer);   

    //
    // Initialize the EXOVERLAPPED with send callback routines
    //
    #pragma PUSH_NEW
    #undef new

        new(&m_ov) EXOVERLAPPED(SendSucceeded, SendFailed);
        new(&m_RequestEntry)CRequestOv(GetPacketForSendingSucceeded, GetPacketForSendingFailed);

    #pragma POP_NEW

    
    StartCleanupTimer();

    //
    // Now, connection was established. The message Transport is ready to 
    // get a message for sending
    //
    GetNextEntry();

} // CMessageMulticastTransport::ConnectionSucceeded


VOID 
WINAPI 
CMessageMulticastTransport::ConnectionSucceeded(
    EXOVERLAPPED* pov
    )
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

    R<CMessageMulticastTransport> pMmt = CONTAINING_RECORD(pov, CMessageMulticastTransport, m_ov);

    //
    // Connect has completed successfully, go and start delivering the messages.
    // If delivery failes here, the cleanup timer will eventually shutdown this
    // transport, so no explict shutdown is nesscessary.
    //
    // Do not schedule a retry here if this failes as this is the first send,
    // and any failure indicates a fatal error. (unlike after first delivery).
    //
    pMmt->ConnectionSucceeded();
}


VOID 
WINAPI
CMessageMulticastTransport::ConnectionFailed(
    EXOVERLAPPED* pov
    )
/*++

Routine Description:

    The routine is called when create a connection failed
  
Arguments:

    pov - Pointer to overlapped.
    
Returned Value:

    None.

--*/
{
    ASSERT(FAILED(pov->GetStatus()));

    R<CMessageMulticastTransport> pMmt = CONTAINING_RECORD(pov, CMessageMulticastTransport, m_ov);

    WCHAR buffer[MAX_PATH];
    MQpMulticastIdToString(pMmt->MulticastId(), buffer, TABLE_SIZE(buffer));
    TrERROR(NETWORKING, "Failed to connect to '%ls'. pMmt=%p", buffer, pMmt.get());
    pMmt->ScheduleRetry();
}


VOID 
CMessageMulticastTransport::Connect(
    VOID
    )
/*++

Routine Description:

    The routine creates a winsock connection. The operation is asynchronous 
    and on completion a call back routine is called
  
Arguments:

    None.
  
Returned Value:

    None.

Note:
    No Timers are running concurrently, so this function can not be interrupted
    by Shutdown. No need to protect m_socket etc.

--*/
{
    //
    // Start asynchronous connection
    //
    try
    {
        AddRef();
        SOCKADDR_IN Address;
        Address.sin_family = AF_INET;
        Address.sin_port = htons(static_cast<USHORT>(MulticastId().m_port));
        Address.sin_addr.s_addr = MulticastId().m_address;
		std::vector<SOCKADDR_IN> vAddress;
		vAddress.push_back(Address);
        m_SocketTransport->CreateConnection(vAddress, &m_ov);
    }
    catch(const exception&)
    {
        WCHAR buffer[MAX_PATH];
        MQpMulticastIdToString(MulticastId(), buffer, TABLE_SIZE(buffer));
		TrERROR(NETWORKING, "Failed to connect to '%ls'", buffer);
        Release();
        throw;
    }
} // CMessageMulticastTransport::Connect


VOID 
CMessageMulticastTransport::Shutdown(
    Shutdowntype Shutdowntype
    )
    throw()
{
    //
    // Protect m_socket, m_state 
    //
    CSW writeLock(m_pendingShutdown);

    if (State() == csShutdownCompleted) 
    {
        return;
    }

	// If shut down was called because an error - reprot it.
	//
	if(Shutdowntype == RETRYABLE_DELIVERY_ERROR)
	{
		m_pMessageSource->OnRetryableDeliveryError();
	}

    if (m_pConnection.get() != NULL)
    {
        m_pConnection->Close();
	}


    //
    // Now Shutdown is in progress, cancel all timers
    //
    State(csShuttingDown);
    TryToCancelCleanupTimer();

    //
    // Cancle peding request from the queue
    //
    m_pMessageSource->CancelRequest();

    //
    // Remove the message transport from transport manager data structure, and create
    // a new transport to the target
    //
    AppNotifyMulticastTransportClosed(MulticastId());
   
    State(csShutdownCompleted);
	TrTRACE(NETWORKING,"Shutdown completed (RefCount = %d)",GetRef());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mmt\lib\mmtinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MmtInit.cpp

Abstract:

    Multicast Message Transport initialization

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include "Mmt.h"
#include "Mmtp.h"

#include "mmtinit.tmh"

VOID
MmtInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes Multicast Message Transport library

Arguments:

    None.

Returned Value:

    None.

--*/
{
    //
    // Validate that the Message Transport library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!MmtpIsInitialized());
    MmtpRegisterComponent();

    MmtpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mmt\lib\mmtobj.cpp ===
/*++

  
Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MmtObj.cpp

Abstract:

    CMessageMulticastTransport implementation.

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include <mqsymbls.h>
#include <mqwin64a.h>
#include <mqformat.h>
#include "Mmt.h"
#include "Mmtp.h"
#include "MmtObj.h"

#include "mmtobj.tmh"

bool CMessageMulticastTransport::TryToCancelCleanupTimer(VOID)
{
    if (!ExCancelTimer(&m_cleanupTimer))
        return false;

    Release();
    return true;
}

VOID CMessageMulticastTransport::StartCleanupTimer(VOID)
{
    ASSERT(!m_cleanupTimer.InUse());

    m_fUsed = false;
    
    AddRef();
    ExSetTimer(&m_cleanupTimer, m_cleanupTimeout);
}


VOID WINAPI CMessageMulticastTransport::TimeToCleanup(CTimer* pTimer)
{
    R<CMessageMulticastTransport> pMmt = CONTAINING_RECORD(pTimer, CMessageMulticastTransport, m_cleanupTimer);

    if (pMmt->m_fUsed)
    {
        pMmt->StartCleanupTimer();
        return;
    }

    TrERROR(NETWORKING, "Transport is idle, shutting down. pMmt=0x%p", pMmt.get());
    pMmt->Shutdown(OK);
}


CMessageMulticastTransport::CMessageMulticastTransport(
    MULTICAST_ID id,
    IMessagePool * pMessageSource,
	ISessionPerfmon* pPerfmon,
    const CTimeDuration& retryTimeout,
    const CTimeDuration& cleanupTimeout,
	P<ISocketTransport>& SocketTransport
    ) :
    CMulticastTransport(id),
    m_pMessageSource(SafeAddRef(pMessageSource)),
	m_pPerfmon(SafeAddRef(pPerfmon)),
    m_RequestEntry(GetPacketForConnectingSucceeded, GetPacketForConnectingFailed),
    m_ov(ConnectionSucceeded, ConnectionFailed),
    m_retryTimeout(retryTimeout),
    m_retryTimer(TimeToRetryConnection),
    m_fUsed(false),
    m_cleanupTimer(TimeToCleanup),
    m_cleanupTimeout(cleanupTimeout),
	m_SocketTransport(SocketTransport.detach())
{
	ASSERT(("Invalid parameter", pMessageSource != NULL));
	ASSERT(("Invalid parameter", pPerfmon != NULL));

    WCHAR buffer[MAX_PATH];
    MQpMulticastIdToString(id, buffer, TABLE_SIZE(buffer));
	TrTRACE(
		NETWORKING, 
		"Create new multicast message transport. pMmt = 0x%p, multicast address = %ls", 
		this, 
		buffer
		);

    Connect();
}


CMessageMulticastTransport::~CMessageMulticastTransport()
{
	TrTRACE(NETWORKING,"CMessageMulticastTransport Destructor called");
    ASSERT(!m_retryTimer.InUse());

	// 
	// We close the message pool here instead of letting it self destruct since
	// the close process may be prolonged in cases of low system resources
	//
    m_pMessageSource->Close();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mmt\lib\mmtp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    Mmtp.h

Abstract:

    Multicast Message Transport private functions.

Author:

    Shai Kariv  (shaik)  27-Aug-00

--*/

#pragma once

#include <ex.h>


const char xMultipartContentType[] = "multipart/related";
const char xEnvelopeContentType[] = "text/xml";
const char xApplicationContentType[] = "application/octet-stream";

#define BOUNDARY_LEADING_HYPHEN "--"
#define BOUNDARY_VALUE "MSMQ - SOAP boundary, %d "
typedef std::vector<WSABUF> HttpRequestBuffers;



#ifdef _DEBUG

VOID MmtpAssertValid(VOID);
VOID MmtpSetInitialized(VOID);
BOOL MmtpIsInitialized(VOID);
VOID MmtpRegisterComponent(VOID);

#else // _DEBUG

#define MmtpAssertValid() ((VOID)0)
#define MmtpSetInitialized() ((VOID)0)
#define MmtpIsInitialized() TRUE
#define MmtpRegisterComponent() ((VOID)0)

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mmt\lib\mmtobj.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MmtObj.h

Abstract:

    CMessageMulticastTransport declaration.

Author:

    Shai Kariv  (shaik)  27-Aug-00

--*/

#pragma once

#ifndef __MmtObj_H__
#define __MmtObj_H__

#include "msi.h"
#include "spi.h"

#include <mqwin64a.h>
#include "acdef.h"
#include "qmpkt.h"

#include <ex.h>
#include <rwlock.h>
#include <st.h>
#include <buffer.h>
#include "Mp.h"
typedef std::basic_string<unsigned char> utf8_str;


class CMessageMulticastTransport : public CMulticastTransport
{
	enum Shutdowntype{PAUSE, OK, RETRYABLE_DELIVERY_ERROR};

public:

    CMessageMulticastTransport(
        MULTICAST_ID id,
        IMessagePool * pMessageSource,
		ISessionPerfmon* pPerfmon,
        const CTimeDuration& retryTimeout,
        const CTimeDuration& cleanupTimeout,
		P<ISocketTransport>& SocketTransport
        );

    virtual ~CMessageMulticastTransport();
    
	virtual void Pause(void)
	{
		Shutdown(PAUSE);
	}

private:

    class CRequestOv : public EXOVERLAPPED
    {
    public:

        CRequestOv(        
            COMPLETION_ROUTINE pSuccess,
            COMPLETION_ROUTINE pFailure
        ):
            EXOVERLAPPED(pSuccess, pFailure)
        {
            m_pMsg.pPacket = NULL;
            m_pMsg.pDriverPacket = NULL;
        }


        CACPacketPtrs& GetAcPacketPtrs(VOID)
        {
            return m_pMsg;
        }


    private:

        CACPacketPtrs m_pMsg;
    };


    class COverlapped : public EXOVERLAPPED
    {
    public:
        COverlapped(        
            COMPLETION_ROUTINE pSuccess,
            COMPLETION_ROUTINE pFailure
        ):
        EXOVERLAPPED(pSuccess, pFailure),
	  	m_userData1(0),
	  	m_userData2(0)
		{
		}
	
	public:
		DWORD m_userData1;
        PVOID m_userData2;
	};

private:

    static VOID WINAPI ConnectionSucceeded(EXOVERLAPPED* pov);
    static VOID WINAPI ConnectionFailed(EXOVERLAPPED* pov);
    static VOID WINAPI GetPacketForConnectingSucceeded(EXOVERLAPPED* pov);
    static VOID WINAPI GetPacketForConnectingFailed(EXOVERLAPPED* pov);


    static VOID WINAPI SendSucceeded(EXOVERLAPPED* pov);
    static VOID WINAPI SendFailed(EXOVERLAPPED* pov);
    static VOID WINAPI GetPacketForSendingSucceeded(EXOVERLAPPED* pov);
    static VOID WINAPI GetPacketForSendingFailed(EXOVERLAPPED* pov);

    static VOID WINAPI TimeToRetryConnection(CTimer* pTimer);
    static VOID WINAPI TimeToCleanup(CTimer* pTimer);

private:
	static DWORD SendSize(const HttpRequestBuffers&  sendBufs);


private:
    //
    // Get packet for sending
    //
    VOID GetNextEntry(VOID);
	VOID RequeuePacketMustSucceed(VOID);
    //
    // Create connection
    //
    VOID ConnectionSucceeded(VOID);
    VOID Connect(VOID);
	void InitPerfmonCounters(LPCWSTR strMulticastId);

    VOID ScheduleRetry(VOID)
    {
        ASSERT(!m_retryTimer.InUse());

        AddRef();
        ExSetTimer(&m_retryTimer, m_retryTimeout);
    }

    //
    // Send packet
    //
    VOID SendSucceeded(DWORD cbSendSize, CQmPacket * pEntry);
    VOID DeliverPacket(CQmPacket* pPacket);
    CQmPacket* KeepProceesingPacket(VOID);


    //
    // Shut-Down
    //
    VOID Shutdown(Shutdowntype Shutdowntype = RETRYABLE_DELIVERY_ERROR) throw();

    //
    // Cleanup
    //
    VOID StartCleanupTimer(VOID);
    bool TryToCancelCleanupTimer(VOID);
    VOID SendFailed(DWORD cbSendSize, CQmPacket * pEntry);

    VOID MarkTransportAsUsed(VOID)
    {
        m_fUsed = true;
    }

private:

    mutable CReadWriteLock m_pendingShutdown;

    R<IConnection> m_pConnection;
    R<IMessagePool> m_pMessageSource;

    CRequestOv m_RequestEntry;
    COverlapped m_ov;
    
    CTimer m_retryTimer;
    CTimeDuration m_retryTimeout;

    bool m_fUsed;
    CTimer m_cleanupTimer;
    CTimeDuration m_cleanupTimeout;
	P<ISocketTransport> m_SocketTransport; 
	R<CSrmpRequestBuffers> m_SrmpRequestBuffers;
	R<ISessionPerfmon> m_pPerfmon;
}; 


#endif // __MmtObj_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mmt\lib\mmtsend.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MmtSend.cpp

Abstract:

    Multicast Message Transport class - Send implementation

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include <mqsymbls.h>
#include <mqwin64a.h>
#include <mqformat.h>
#include "Mmt.h"
#include "Mmtp.h"
#include "MmtObj.h"

#include "mmtsend.tmh"


using namespace std;

VOID 
WINAPI 
CMessageMulticastTransport::GetPacketForSendingSucceeded(
    EXOVERLAPPED* pov
    )
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

	CRequestOv* pRequest = static_cast<CRequestOv*>(pov);
    R<CMessageMulticastTransport> pMmt = CONTAINING_RECORD(pRequest, CMessageMulticastTransport, m_RequestEntry);
      
    TrTRACE(NETWORKING, "Got a message to multicast. pMmt = 0x%p", pMmt.get());

	CQmPacket* pPkt = pMmt->KeepProceesingPacket();

    pMmt->DeliverPacket(pPkt);

} // CMessageMulticastTransport::GetPacketForSendingSucceeded


VOID 
WINAPI 
CMessageMulticastTransport::GetPacketForSendingFailed(
    EXOVERLAPPED* pov
    )
/*++

Routine Description:

    The routine is called when getting entry request from a queue failed.
  
Arguments:

    pov - Pointer to overlapped.
  
Returned Value:

    None.

--*/
{
    ASSERT(FAILED(pov->GetStatus()));

	CRequestOv* pRequest = static_cast<CRequestOv*>(pov);
    R<CMessageMulticastTransport> pMmt = CONTAINING_RECORD(pRequest, CMessageMulticastTransport, m_RequestEntry);

    WCHAR buffer[MAX_PATH];
    MQpMulticastIdToString(pMmt->MulticastId(), buffer, TABLE_SIZE(buffer));
    TrERROR(NETWORKING, "Failed to get a new entry from queue %ls. Shutting down. pMmt = 0x%p", buffer, pMmt.get());

    pMmt->Shutdown();

} // CMessageMulticastTransport::GetPacketForSendingFailed


VOID 
CMessageMulticastTransport::SendFailed(
    DWORD /*cbSendSize*/,
    CQmPacket * pEntry
    )
/*++

Routine Description:

    The routine is called when send a message failed
  
Arguments:

    cbSendSize - Size in bytes of the sent packet
     
    pEntry     - Pointer to the sent packet
  
Returned Value:

    None.

--*/
{
	m_SrmpRequestBuffers.free();
   
    //
    // Packet is already deleted from disk. Free it from memory.
    //
    CACPacketPtrs& acPtrs = m_RequestEntry.GetAcPacketPtrs();

    ASSERT(acPtrs.pDriverPacket != NULL);
    ASSERT(acPtrs.pPacket != NULL);
    ASSERT(pEntry->GetPointerToPacket() == acPtrs.pPacket);
    ASSERT(pEntry->GetPointerToDriverPacket() == acPtrs.pDriverPacket);

    m_pMessageSource->EndProcessing(pEntry, MQMSG_CLASS_NORMAL);
    delete pEntry;

    acPtrs.pPacket = NULL;
    acPtrs.pDriverPacket = NULL;

} // CMessageMulticastTransport::SendFailed

    
VOID 
WINAPI 
CMessageMulticastTransport::SendFailed(
    EXOVERLAPPED* pov
    )
/*++

Routine Description:

    The routine is called when send a message failed
  
Arguments:

    pov - Pointer to EXOVERLAPPED
    
Returned Value:

    None.

--*/
{
    HRESULT status = pov->GetStatus();
    ASSERT(FAILED(status));

	CRequestOv* pRequest = static_cast<CRequestOv*>(pov);
    R<CMessageMulticastTransport> pMmt = CONTAINING_RECORD(pRequest, CMessageMulticastTransport, m_ov);

    WCHAR buffer[MAX_PATH];
    MQpMulticastIdToString(pMmt->MulticastId(), buffer, TABLE_SIZE(buffer));
    TrERROR(NETWORKING, "Failed to send message to '%ls', status=0x%x, shutting down. pMmt=0x%p", buffer, status, pMmt.get());
    pMmt->SendFailed(pMmt->m_ov.m_userData1, static_cast<CQmPacket*>(pMmt->m_ov.m_userData2));
    pMmt->Shutdown();

} // CMessageMulticastTransport::SendFailed


VOID 
CMessageMulticastTransport::SendSucceeded(
    DWORD cbSendSize,
    CQmPacket * pEntry
    )
/*++

Routine Description:

    The routine is called when send a message succeeded
  
Arguments:

    cbSendSize - Size in bytes of the sent packet
     
    pEntry     - Pointer to the sent packet
  
Returned Value:

    None.

--*/
{
	
    WCHAR buffer[MAX_PATH];
    MQpMulticastIdToString(MulticastId(), buffer, TABLE_SIZE(buffer));
    TrTRACE(
		NETWORKING, 
		"Send message to '%ls' succeeded. pMmt=0x%p", 
		buffer,
		this
		);

	m_SrmpRequestBuffers.free();

   
    //
    // Packet is already deleted from disk. Free it from memory.
    //
    CACPacketPtrs& acPtrs = m_RequestEntry.GetAcPacketPtrs();

    ASSERT(acPtrs.pDriverPacket != NULL);
    ASSERT(acPtrs.pPacket != NULL);
    ASSERT(pEntry->GetPointerToPacket() == acPtrs.pPacket);
    ASSERT(pEntry->GetPointerToDriverPacket() == acPtrs.pDriverPacket);

    m_pMessageSource->EndProcessing(pEntry, MQMSG_CLASS_NORMAL);
    delete pEntry;

    acPtrs.pPacket = NULL;
    acPtrs.pDriverPacket = NULL;

    MarkTransportAsUsed();

	//
	// Update performance counters
	//
	m_pPerfmon->UpdateBytesSent(cbSendSize);
	m_pPerfmon->UpdateMessagesSent();

    GetNextEntry();

} // CMessageMulticastTransport::SendSucceeded


VOID 
WINAPI 
CMessageMulticastTransport::SendSucceeded(
    EXOVERLAPPED* pov
    )
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

    R<CMessageMulticastTransport> pMmt = CONTAINING_RECORD(pov, CMessageMulticastTransport, m_ov);
    
    //
    // Send has completed successfully, go and request the next message for delivery.
    // If the request failes, the cleanup timer will eventually shutdown this
    // transport, so no explict shutdown is nesscessary.
    //
    pMmt->SendSucceeded(pMmt->m_ov.m_userData1, static_cast<CQmPacket*>(pMmt->m_ov.m_userData2));

} // CMessageMulticastTransport::SendSucceeded


CQmPacket* 
CMessageMulticastTransport::KeepProceesingPacket(
    VOID
    )
{
    //
    // Get the entry from the send overlapped. 
    //
    CACPacketPtrs& acPkts = m_RequestEntry.GetAcPacketPtrs();
    CQmPacket* pEntry;

	try
	{
	    pEntry = new CQmPacket(acPkts.pPacket, acPkts.pDriverPacket);
	}
	catch (const exception&)
	{
		TrERROR(NETWORKING, "Failed to allocate multicast message, shutting down.");
        RequeuePacketMustSucceed();
        Shutdown();
        throw;
	}

    return pEntry;

} 


DWORD CMessageMulticastTransport::SendSize(const HttpRequestBuffers&  sendBufs)
{
	DWORD cbSize = 0;

	for(HttpRequestBuffers::const_iterator it = sendBufs.begin(); it != sendBufs.end(); ++it)
	{
		cbSize += it->len;
	}

	return cbSize;
}


VOID 
CMessageMulticastTransport::DeliverPacket(
    CQmPacket* pEntry
    )
/*++

Routine Description:

    The routine delivers an entry to the destination. The delivery is asynchornous.
    On completion a call back routine is called.
  
Arguments:

    pEntry - Points to a queue entry (i.e. msmq packet).
  
Returned Value:

    None.

--*/
{
    //
    // Mark the transport as used
    //
    MarkTransportAsUsed();

	WCHAR buf[MAX_PATH];
    MQpMulticastIdToString(MulticastId(), buf, TABLE_SIZE(buf));

	bool fOnWire = false;
    try
    {
	    m_SrmpRequestBuffers = MpSerialize(*pEntry, buf, buf);
	    ASSERT(m_SrmpRequestBuffers->GetNumberOfBuffers() != 0);

	    //
	    // Increment object refernce count, to insure that the object will
	    // not be destroyed before asynchronous send operation is completed
	    //
	    R<CMessageMulticastTransport> ar = SafeAddRef(this);

	    //
	    // Protect m_socket from shutdown
	    //
	    CSR readLock(m_pendingShutdown);

	    //
	    // Delete the packet from disk. Keep it in memory until send is complete.
	    //                  
	    m_pMessageSource->LockMemoryAndDeleteStorage(pEntry);
		ASSERT(m_SrmpRequestBuffers->GetNumberOfBuffers() != 0);

		m_ov.m_userData1 = numeric_cast<DWORD>(m_SrmpRequestBuffers->GetSendDataLength());
	    m_ov.m_userData2 = pEntry;

		//
		// Log to tracing that a message was sent.
		// Do this only if we are in the proper tracing level
		//
		if (WPP_LEVEL_COMPID_ENABLED(rsTrace, PROFILING))
		{
			OBJECTID TraceMessageId;
			pEntry->GetMessageId(&TraceMessageId);

			WCHAR wszName[100];
			MQpMulticastIdToString(MulticastId(),wszName, TABLE_SIZE(wszName));

			TrTRACE(PROFILING, "MESSAGE TRACE - State:%ls   Queue:%ls  ID:%!guid!\\%u   Delivery:0x%x   Class:0x%x   Label:%.*ls", 
				L"Multicast Message being sent on wire", 
				wszName, 
				&TraceMessageId.Lineage,
				TraceMessageId.Uniquifier, 
				pEntry->GetDeliveryMode(),
				pEntry->GetClass(),
				xwcs_t(pEntry->GetTitlePtr(), pEntry->GetTitleLength()));
		}

		//
		// after message is on the wire and we somehow get exception
		// we dont requeue the packet so we will not send it twice
		//
		fOnWire = true;
	    m_pConnection->Send(
							m_SrmpRequestBuffers->GetSendBuffers(), 
							numeric_cast<DWORD>(m_SrmpRequestBuffers->GetNumberOfBuffers()), 
							&m_ov
							);
	    ar.detach();
	}
    catch (const exception&)
    {
		if (!fOnWire)
		{
	        RequeuePacketMustSucceed();
		}
		else
	    {
			TrERROR(NETWORKING, "Failed to deliver multicast message, shutting down. pMmt=0x%p", this);
			SendFailed(m_ov.m_userData1, static_cast<CQmPacket*>(m_ov.m_userData2));
	    }
        Shutdown();
        throw;
    }
	
    TrTRACE(NETWORKING, "Send message to '%ls'. pMmt=0x%p", buf, this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mmt\test\group.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    group.cpp

Abstract:

    group stub for Mmt test

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent,

--*/

#include <libpch.h>
#include <mqwin64a.h>
#include <qformat.h>
#include "Ex.h"
#include "MmtTestp.h"
#include "group.h" 
#include "phbase.h"
#include "phuser.h"
#include "phprop.h"

#include "group.tmh"

MULTICAST_ID s_MulticastId = {inet_addr("231.7.8.9"), 1801};
const QUEUE_FORMAT destQueue(s_MulticastId);
const GUID sourceQm = { 0 };
const GUID destQm = { 0 };

static ULONG s_msgId = 0;




ULONG CGroup::CalcPacketSize(void)
{
    ULONG ulPacketSize;

    ulPacketSize  = CBaseHeader::CalcSectionSize();

    ulPacketSize += CUserHeader::CalcSectionSize(&sourceQm, &destQm, NULL, &destQueue, NULL, NULL);

    ulPacketSize += CPropertyHeader::CalcSectionSize(0, 0, 0);

    // what about CMqfHeader size (for destination format name)?

    return ulPacketSize;
}


char* CGroup::CreatePacket(void)
{
    ULONG ulPacketSize = CalcPacketSize();

    char* pPacket = new char[ulPacketSize];
    char* pSection = pPacket;

    // Initialize the EXOVERLAPPED with send callback routines
    //
    #pragma PUSH_NEW
    #undef new

        CBaseHeader* pBase = new(pSection) CBaseHeader(ulPacketSize);
        pSection = pBase->GetNextSection();

        CUserHeader* pUser = new(pSection) CUserHeader(
                                                &sourceQm, 
                                                &destQm,
                                                &destQueue,
                                                NULL,
                                                NULL,
                                                ++s_msgId
                                                );
        pSection = pUser->GetNextSection();

        new(pSection) CPropertyHeader();

    #pragma POP_NEW

    return pPacket;
}


void WINAPI CGroup::TimeToReturnPacket(CTimer* pTimer)
{
    R<CGroup> pGroup = CONTAINING_RECORD(pTimer, CGroup, m_getSleep);
    pGroup->TimeToReturnPacket();
}

void CGroup::TimeToReturnPacket(void)
{
    CS lock(m_cs);

    ASSERT(m_fGetScheduled);
    if(! m_request.empty())
    {
        CGroup::CRequest& request = m_request.front();
    
        EXOVERLAPPED* pov = request.m_pov;
        CACPacketPtrs* pAcPackts = request.m_pAcPackts;

        m_request.pop_front();

    
        char* pPkt = CreatePacket();

        pAcPackts->pPacket = reinterpret_cast<CBaseHeader*>(pPkt);
        pAcPackts->pDriverPacket = reinterpret_cast<CPacket*>(pPkt);

    
        pov->SetStatus(STATUS_SUCCESS);
        ExPostRequest(pov);
    }

    if (m_request.empty())
    {
        m_fGetScheduled = false;
        return;
    }

    R<CGroup> ref = SafeAddRef(this);
    CTimeDuration sleepInterval(rand()/1000);
    ExSetTimer(&m_getSleep, sleepInterval);
    ref.detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mmt\test\mmttestp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MmtTestp.h

Abstract:

    Multicast Message Transport test, private header.

Author:

    Shai Kariv  (shaik)  27-Aug-00

--*/

#pragma once

bool IsFailed(void);
void UpdateNoOfsentMessages(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mmt\test\group.h ===
#include "msi.h"

#include "mqwin64a.h"
#include "qmpkt.h"

class CGroup: public IMessagePool
{
private:
    class CRequest
    {
    public:
        CRequest(EXOVERLAPPED* pov, CACPacketPtrs& acPacketPtrs) :
            m_pov(pov),
            m_pAcPackts(&acPacketPtrs)
            {
            }
    public:
        EXOVERLAPPED* m_pov;
        CACPacketPtrs* m_pAcPackts;
    };

public:
    CGroup() :
        m_getSleep(TimeToReturnPacket),
        m_fGetScheduled(false)
    {
    }

    virtual ~CGroup()
    {
        ExCancelTimer(&m_getSleep);
    }

    void Requeue(CQmPacket* p)
    {
        delete [] reinterpret_cast<char*>(p->GetPointerToDriverPacket());
    }
    

    void EndProcessing(CQmPacket* p, USHORT)
    {
        delete [] reinterpret_cast<char*>(p->GetPointerToDriverPacket());

        UpdateNoOfsentMessages();
    }


    void LockMemoryAndDeleteStorage(CQmPacket*)
    {
        NULL;
    }


    void GetFirstEntry(EXOVERLAPPED* pov, CACPacketPtrs& acPacketPtrs)
    {
        CS lock(m_cs);

        m_request.push_back(CRequest(pov, acPacketPtrs));
        if (!m_fGetScheduled)
        {
            SafeAddRef(this);

            CTimeDuration sleepInterval(rand()/1000);
            ExSetTimer(&m_getSleep, sleepInterval);
            m_fGetScheduled = true;
        }
    }

    void CancelRequest(void)
    {
        CS lock(m_cs);

        for(std::list<CRequest>::iterator it = m_request.begin(); it != m_request.end(); )
        {
            EXOVERLAPPED* pov = (*it).m_pov;
            pov->SetStatus(STATUS_CANCELLED);
            ExPostRequest(pov);
            
            it = m_request.erase(it);
        }
    }

private:
    static void WINAPI TimeToReturnPacket(CTimer* pTimer);
    
    static ULONG CalcPacketSize(void);
    static char* CreatePacket();

private:
    void TimeToReturnPacket();

private:
    CCriticalSection    m_cs;                   // Critical section

    std::list<CRequest> m_request;

    bool m_fGetScheduled;
    CTimer m_getSleep;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\attachments.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    attachments.cpp

Abstract:
    Implements  creating attachments array from MSMQ packet


Author:
    Gil Shafriri(gilsh) 14-DEC-00

--*/

#include <libpch.h>
#include <mp.h>
#include <qmpkt.h>
#include <utf8.h>
#include "mpp.h"
#include "attachments.h"
#include "proptopkt.h"

#include "attachments.tmh"

using namespace std;

void PacketToAttachments(const CQmPacket& pkt, CAttachmentsArray* pAttachments)
{
	//
    // Body section
    //
    if (pkt.IsBodyInc())
    { 
        DWORD bodySize;
        const BYTE* pBody = pkt.GetPacketBody(&bodySize);
		CAttachment Attachment;
        Attachment.m_data =   xbuf_t<const VOID>(pBody, bodySize);
		Attachment.m_id =  xstr_t(xMimeBodyId, STRLEN(xMimeBodyId));
		pAttachments->push_back(Attachment);
    }

    //
    // Extension Section
    //
    if (pkt.GetMsgExtensionSize() != 0)
    {
        DWORD extensionSize = pkt.GetMsgExtensionSize();
        const BYTE* pExtension = pkt.GetMsgExtensionPtr();
		CAttachment Attachment;
		Attachment.m_data =   xbuf_t<const VOID>(pExtension, extensionSize);
		Attachment.m_id  = 	  xstr_t(xMimeExtensionId, STRLEN(xMimeExtensionId));
		pAttachments->push_back(Attachment);
    }

    //
    // Sender Certificate
    //
    DWORD certSize;
    const UCHAR* pCert = pkt.GetSenderCert(&certSize);
    if (certSize != 0)
    {
		CAttachment Attachment;
		Attachment.m_data =  xbuf_t<const VOID>(pCert, certSize);
		Attachment.m_id =  xstr_t(xMimeSenderCertificateId, STRLEN(xMimeSenderCertificateId));
		pAttachments->push_back(Attachment);
    }
}


static
xbuf_t<const VOID>
GetCertSid(
    CMessageProperties* mProp
    )
{

	AP<WCHAR> pProvider = mProp->providerName.ToStr();
		
	PSID pSid = AppGetCertSid(
							static_cast<const BYTE*>(mProp->senderCert.Buffer()),
							mProp->senderCert.Length(),
							mProp->fDefaultProvider,
							pProvider,
							mProp->providerType
							);

	mProp->pCleanSenderSid.free();
    mProp->pCleanSenderSid = pSid;

	ASSERT((pSid == NULL) || IsValidSid(pSid));

	if((pSid == NULL) || !IsValidSid(pSid))
	{
		return (xbuf_t<const VOID>(NULL, 0));
	}

	return(xbuf_t<const VOID>(pSid, GetLengthSid(pSid)));
}




void
AttachmentsToProps(
    const CAttachmentsArray& Attachments,
    CMessageProperties* mProp
    )
{
	for(DWORD i = 0; i< Attachments.size(); ++i)
    {
        if (Attachments[i].m_id.Length() == 0)
            continue;

        if ((Attachments[i].m_id.Length() >= STRLEN(xMimeBodyId)) &&
            (_strnicmp(Attachments[i].m_id.Buffer(), xMimeBodyId, STRLEN(xMimeBodyId)) == 0))
        {
            mProp->body = Attachments[i];
            continue;
        }

        if ((Attachments[i].m_id.Length() >= STRLEN(xMimeSenderCertificateId)) &&
            (_strnicmp(Attachments[i].m_id.Buffer(), xMimeSenderCertificateId, STRLEN(xMimeSenderCertificateId)) == 0))
        {
            mProp->senderCert = Attachments[i].m_data;

			//
			// Get senderSid, senderIdType according to the certificate
			//
			mProp->senderSid = GetCertSid(mProp);

			mProp->senderIdType = MQMSG_SENDERID_TYPE_NONE;
			if (mProp->senderSid.Length() != 0)
			{
			    mProp->senderIdType = MQMSG_SENDERID_TYPE_SID;
			}

            continue;
        }

        if ((Attachments[i].m_id.Length() >= STRLEN(xMimeExtensionId)) &&
            (_strnicmp(Attachments[i].m_id.Buffer(), xMimeExtensionId, STRLEN(xMimeExtensionId)) == 0))
        {
            mProp->extension = Attachments[i].m_data;
            continue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mmt\test\st.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    st.cpp

Abstract:
    Simulation of St library

Author:
    Gil Shafriri (gilsh) 11-June-2000

--*/

#include <libpch.h>
#include <no.h>
#include <st.h>
#include <xstr.h>
#include <rwlock.h>
#include "st.tmh"

class CPgmWinsockConnection : public IConnection
{
public:
	CPgmWinsockConnection(
		):
			m_socket(NoCreatePgmConnection())
	{
	}			

	void Init(const std::vector<SOCKADDR_IN>& Addr, EXOVERLAPPED* pOverlapped, SOCKADDR_IN*)
	{
		NoConnect(m_socket, Addr[0], pOverlapped); 
	}


	virtual 
	void 
	ReceivePartialBuffer(
					VOID* pBuffer,                                     
					DWORD Size, 
					EXOVERLAPPED* pov
					)
	{
		NoReceivePartialBuffer(m_socket, pBuffer, Size, pov);
	}


 	virtual 
	void 
	Send(
		const WSABUF* Buffers,                                     
		DWORD nBuffers, 
		EXOVERLAPPED* pov
		)
	{
		NoSend(m_socket, Buffers, nBuffers,  pov);
	}


	virtual void Close()
	{
		m_socket.free();
	}


private:
	mutable CReadWriteLock m_CloseConnection;
	CSocketHandle m_socket;
};


class CPgmWinsock :public ISocketTransport
{

public:
	virtual void CreateConnection(
			const std::vector<SOCKADDR_IN>& Addr, 
			EXOVERLAPPED* pOverlapped,
			SOCKADDR_IN* pAddr
			)
	{
		m_pConnection = new  CPgmWinsockConnection();
		m_pConnection->Init(Addr, pOverlapped, pAddr);
	}


	virtual R<IConnection> GetConnection()
	{
		return m_pConnection; 
	}


	bool IsPipelineSupported(void)
	{
		return true;
	}

	
	virtual
	bool
	GetHostByName(
    LPCWSTR host,
	std::vector<SOCKADDR_IN>* pAddr,
	bool fUseCache = true
    )
	{
		return NoGetHostByName(host, pAddr, fUseCache);		
	}

private:
	R<CPgmWinsockConnection> m_pConnection;
};



ISocketTransport* StCreatePgmWinsockTransport(void)
{
	return new CPgmWinsock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mmt\test\no.cpp ===
#include <libpch.h>
#include "No.h"
#include "Ex.h"
#include "MmtTestp.h"

#include "no.tmh"

using namespace std;

const char xShortOkResponse[] =		"HTTP/1.1 200 OK\r\n"
									"Content-Length: 0\r\n"
									"\r\n"
									;

const char xShortFailResponse[] =	"HTTP/1.1 500 Internal Server Error\r\n"
									"Connection: close\r\n"
									"Content-Length: 0\r\n"
									"\r\n"
									;

const char xLongOkResponse[] =		"HTTP/1.1 200 OK\r\n"
									"Header1: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header2: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Content-Length: 400\r\n"
									"Header3: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header4: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header5: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"\r\n"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									;

const char xLongFailResponse[] =	"HTTP/1.1 500 Internal Server Error\r\n"
									"Connection: close\r\n"
									"Header1: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header2: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Content-Length: 400\r\n"
									"Header3: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header4: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header5: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"\r\n"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									;

const char xOkResponseNoContentLength[] =
                            		"HTTP/1.1 200 OK\r\n"
									"\r\n"
                                    ;

const char xInformativeResponseNoContentLength[] =
                            		"HTTP/1.1 100 Continue\r\n"
									"\r\n"
									;

const char xFailResponseNoContentLength[] =
                            		"HTTP/1.1 500 Internal Server Error\r\n"
									"\r\n"
									;

const LPCSTR xResponses[] = {
	xShortOkResponse,
	xShortFailResponse,
	xLongOkResponse,
	xLongFailResponse,
    xOkResponseNoContentLength,
    xInformativeResponseNoContentLength,
    xFailResponseNoContentLength,
  
  };

struct SockInfo
{
    SockInfo(void) : 
        pBuffer(NULL),
        nBytesToRead(0),
        ByteReads(0),
        pov(NULL)
    {
    }

    CCriticalSection m_csResponse;
    list<LPCSTR> response;
    DWORD ByteReads;

    VOID* pBuffer;                                     
    DWORD nBytesToRead; 
    EXOVERLAPPED* pov;
};

typedef map<SOCKET, SockInfo*> SOCKET2INFO;
SOCKET2INFO s_mapSockInfo;


//
VOID
NoInitialize(
    VOID
    )
{
    WSADATA wsd;
    if (WSAStartup(MAKEWORD(2,2), &wsd) != 0)
    {
        TrERROR(NETWORKING, "WSAStartup failed!");
        throw exception();
    }
}


static SOCKET s_socket = 0;

SOCKET 
NoCreatePgmConnection(
    VOID
    )
{
    if (IsFailed())
    {
        throw exception();
    }

    s_mapSockInfo[++s_socket] = new SockInfo;

    TrTRACE(NETWORKING, "Create Socket 0x%Ix", s_socket);

    return s_socket;
}


VOID 
NoConnect(
    SOCKET Socket,
    const SOCKADDR_IN&,
    EXOVERLAPPED* pov
    )
{
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    if (it == s_mapSockInfo.end() || IsFailed())
    {
        if ((rand() %2) == 0)
            throw exception();

        pov->SetStatus(STATUS_UNSUCCESSFUL);
        ExPostRequest(pov);
        return;
    }

    pov->SetStatus(STATUS_SUCCESS);
    ExPostRequest(pov);
}


VOID
NoCloseConnection(
    SOCKET Socket
    )
{
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    TrTRACE(NETWORKING, "Close Socket 0x%Ix", Socket);

    if (it != s_mapSockInfo.end())
    {
        SockInfo* p = it->second;
        
        if (p->pov != NULL)
        {
            EXOVERLAPPED* pov = p->pov;

            p->pBuffer = NULL;
            p->pov = NULL;
            p->nBytesToRead = 0;

            pov->SetStatus(STATUS_UNSUCCESSFUL);
            ExPostRequest(pov);
        }

        s_mapSockInfo.erase(it);
        delete p;
    }
}


VOID
NoSend(
    SOCKET Socket,                                              
    const WSABUF*,
    DWORD, 
    EXOVERLAPPED* pov
    )
{ 
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    if (it == s_mapSockInfo.end() || IsFailed())
    {
        if ((rand() %2) == 0)
            throw exception();

        pov->SetStatus(STATUS_UNSUCCESSFUL);
        ExPostRequest(pov);
        return;
    }


    SockInfo* p = it->second;               
    {
        CS lock(p->m_csResponse);
        p->response.push_back(xResponses[rand() % TABLE_SIZE(xResponses)]);
    }

    pov->SetStatus(STATUS_SUCCESS);
    ExPostRequest(pov);

    if (p->pov != NULL)
    {
        //
        // pending reponse receive
        //
        EXOVERLAPPED* pov = p->pov;
        PVOID pBuffer = p->pBuffer;
        DWORD nBytesToRead = p->nBytesToRead;
        p->pBuffer = NULL;
        p->pov = NULL;
        p->nBytesToRead = 0;

        NoReceivePartialBuffer(Socket, pBuffer, nBytesToRead, pov);
    }
}




VOID
NoReceivePartialBuffer(
    SOCKET Socket,                                              
    VOID* pBuffer,                                     
    DWORD nBytesToRead, 
    EXOVERLAPPED* pov
    )
{
    TrTRACE(NETWORKING, "NoReceivePartialBuffer: Socket=0x%Ix Buffer=0x%p BytesToRead=%d ov=0x%p", Socket, pBuffer, nBytesToRead, pov);
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    if (it == s_mapSockInfo.end() || IsFailed())
    {
        pov->InternalHigh = 0;

        if (rand()%4 == 0)
            throw exception();

        if (rand()%4 == 1)
        {
            pov->SetStatus(STATUS_SUCCESS);
        }
        else
        {
            pov->SetStatus(STATUS_UNSUCCESSFUL);
        }

        ExPostRequest(pov);
        
        return;
    }

    SockInfo* p = it->second;               

    {
        CS lock(p->m_csResponse);
        if (p->response.empty())
        {
            p->pBuffer = pBuffer;                                   
            p->nBytesToRead = nBytesToRead;
            p->pov = pov;
            return;
        }
    }

    p->pBuffer = NULL;                                   
    p->nBytesToRead = 0;
    p->pov = NULL;

    LPCSTR response;
    {
        CS lock(p->m_csResponse);
        response = p->response.front();
    }

    DWORD length = min(nBytesToRead, (strlen(response) - p->ByteReads));

    memcpy(pBuffer, (response + p->ByteReads), length);
    p->ByteReads += length;

    pov->InternalHigh = length;
    
    bool fReadAllResponse = false;
    if (p->ByteReads == strlen(response))
    {
        CS lock(p->m_csResponse);
        p->response.pop_front();
        p->ByteReads = 0;
        fReadAllResponse = true;
    }
     
    pov->SetStatus(STATUS_SUCCESS);
    ExPostRequest(pov);
}


bool
NoGetHostByName(
	LPCWSTR host,
	std::vector<SOCKADDR_IN>* pAddr,
	bool fUseCache
    )
{
	UNREFERENCED_PARAMETER(host);
	UNREFERENCED_PARAMETER(fUseCache);

	SOCKADDR_IN Addr;

	Addr.sin_family = AF_INET;
    Addr.sin_addr.S_un.S_addr = rand();
	pAddr->push_back(Addr);

	return true;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\attachments.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Attachments.h

Abstract:
    Header for classes related to MIME attachments that are part of MSMQ http protocol.


Author:
    Gil Shafriri(gilsh) 22-MAY-01

--*/
#ifndef ATTACHMENTS_H
#define ATTACHMENTS_H

#include <xstr.h>


//-------------------------------------------------------------------
//
// CAttachment 
//
//-------------------------------------------------------------------
class CAttachment
{
public:
    xstr_t m_id;
    xbuf_t<const VOID> m_data;
	DWORD m_offset;
};


//-------------------------------------------------------------------
//
// class CAttachmentsArray - holds attachments on sending side
//
//-------------------------------------------------------------------
typedef  std::vector<CAttachment>  AttachementsVector;
class CAttachmentsArray :private  AttachementsVector
{
public:
	using  AttachementsVector::push_back;
	using  AttachementsVector::size;
	using  AttachementsVector::operator[];
	
public:
	CAttachmentsArray()
	{
		AttachementsVector::reserve(xReservedAttachmentsSize);
	}


public:
	static const DWORD  xReservedAttachmentsSize = 4;
};


class CMessageProperties;

void PacketToAttachments(const CQmPacket& pkt, CAttachmentsArray* pAttachments);
void AttachmentsToProps(const CAttachmentsArray& Attachments, CMessageProperties* pMessageProperties);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mmt\test\mmttest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MtTest.cpp

Abstract:

    Multicast Message Transport library test

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent,

--*/

#include <libpch.h>
#include <Ex.h>
#include <Mmt.h>
#include <Mp.h>
#include <No.h>
#include <spi.h>
#include <utf8.h>
#include "MmtTestp.h"
#include "group.h"

#include "MmtTest.tmh"

static const MULTICAST_ID s_id = {inet_addr("231.7.8.9"), 1801};

static DWORD s_FailedRate = 0;
static DWORD s_NoOfMessages = 1000;
static HANDLE s_hEvent;
static R<CMulticastTransport> s_pTrans(NULL);

//
// Dummy function to link ph files
//
void ReportAndThrow(LPCSTR)
{
	ASSERT(0);
}


void AppRequeueMustSucceed(CQmPacket *p)
{
    delete [] reinterpret_cast<char*>(p->GetPointerToDriverPacket());
}

bool CHttpDeliveryVesrion::IsHttp10Delivery()const
{
	return false;
}



CHttpDeliveryVesrion::CHttpDeliveryVesrion()
{
}



void UpdateNoOfsentMessages(void)
{
    if (--s_NoOfMessages == 0)
        SetEvent(s_hEvent);
}


bool IsFailed(void)
{
    if (s_FailedRate == 0)
        return FALSE;

    return ((DWORD)(rand() % 100) < s_FailedRate);
}

   
static GUID s_machineId = {1234, 12, 12, 1, 1, 1, 1, 1, 1, 1, 1};

const GUID&
McGetMachineID(
    void
    )
{
    return s_machineId;
}

bool
IsEqualMulticastId(
    MULTICAST_ID id1,
    MULTICAST_ID id2
    )
{
    return (id1.m_address == id2.m_address && id1.m_port == id2.m_port);
}


class CSessionPerfmon : public ISessionPerfmon
{
public:
    CSessionPerfmon() : m_fInstanceCreated(false) 
    {
    }

    ~CSessionPerfmon()
    {
    }
    
	void CreateInstance(LPCWSTR)
	{
		m_fInstanceCreated = true;
	}

	void UpdateBytesSent(DWORD )
	{
		ASSERT(m_fInstanceCreated);
	}

	void UpdateMessagesSent(void)
	{
		ASSERT(m_fInstanceCreated);
	}

	void UpdateBytesReceived(DWORD )
	{
		ASSERT(m_fInstanceCreated);
	}

	void UpdateMessagesReceived(void)
    {
		ASSERT(m_fInstanceCreated);
    }

private:
	bool m_fInstanceCreated;
};


VOID
AppNotifyMulticastTransportClosed(
    MULTICAST_ID id
    )
{
    ASSERT(IsEqualMulticastId(id, s_id));
	DBG_USED(id);

    R<CGroup> pGroup = new CGroup();
	R<CSessionPerfmon> pPerfmon = new CSessionPerfmon;

    bool fFailed;

    do
    {
        fFailed = false;
        try
        {
            s_pTrans = MmtCreateTransport(
                                s_id,
                                pGroup.get(),
								pPerfmon.get(),
                                CTimeDuration(10 * CTimeDuration::OneMilliSecond().Ticks()),
                                CTimeDuration(100 * CTimeDuration::OneMilliSecond().Ticks())
                                );
        }
        catch(const exception&)
        {
            fFailed = true;
        }
    } while(fFailed);
                    
    pGroup.free();
}

R<CSrmpRequestBuffers>
MpSerialize(
    const CQmPacket& pkt,
	LPCWSTR targethost,
	LPCWSTR uri
	)
{
	return new CSrmpRequestBuffers(pkt, targethost, uri);	
}


CSrmpRequestBuffers::CSrmpRequestBuffers(
							const  CQmPacket& pkt,
							LPCWSTR host, 
							LPCWSTR 
							):
							m_pkt(pkt),
							m_HttpRequestData(512),
							m_envelope('a' ,200)
{
	size_t targethostLen;
	AP<utf8_char>  m_targethost = UtlWcsToUtf8(host, &targethostLen);
	
	WSABUF buffer;
	buffer.buf = (LPSTR)m_envelope.c_str();
    buffer.len = numeric_cast<DWORD>(m_envelope.size());
    m_buffers.push_back(buffer);
}




size_t CSrmpRequestBuffers::GetNumberOfBuffers() const
{
	return m_buffers.size();
}


const WSABUF* CSrmpRequestBuffers::GetSendBuffers() const
{
	return m_buffers.begin();
}

size_t CSrmpRequestBuffers::GetSendDataLength() const
{
	size_t sum = 0;
	for(std::vector<WSABUF>::const_iterator it = m_buffers.begin(); it != m_buffers.end();++it)
	{
		sum += it->len;		
	}
	return sum;
}


BYTE*  CSrmpRequestBuffers::SerializeSendData() const
{
	size_t SendDataLength =  GetSendDataLength();
	AP<BYTE>  SendData = new BYTE[SendDataLength];
	BYTE* ptr = SendData.get(); 
	for(std::vector<WSABUF>::const_iterator it = m_buffers.begin(); it != m_buffers.end();++it)
	{
		memcpy(ptr, it->buf, it->len);
		ptr += it->len;
	}
	ASSERT(numeric_cast<size_t>((ptr -  SendData.get())) == SendDataLength);
	return 	SendData.detach();
}


CQmPacket::CQmPacket(
    CBaseHeader *pPkt, 
    CPacket *pDriverPkt,
	bool,
	bool):
    m_pDriverPacket(pDriverPkt)
{
    PCHAR pSection;

    m_pBasicHeader = pPkt;

    pSection = m_pBasicHeader->GetNextSection();
    m_pcUserMsg = (CUserHeader*) pSection;

    ASSERT(m_pcUserMsg->PropertyIsIncluded());

    pSection = m_pcUserMsg->GetNextSection();
    m_pcMsgProperty = (CPropertyHeader*) pSection;

    m_pXactSection = NULL;
    m_pSecuritySection = NULL;
}


void Usage(void)
{
	printf("Usage: MmtTest -n <no of messages> [-f xxx] [-h]\n");
    printf("\tn - Number of messages\n");
	printf("\tf - Fail rate\n");
	printf("\th - Print this message\n");
	exit(-1);
}


extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
/*++

Routine Description:

    Test Multicast Message Transport library

Arguments:

    Parameters.

Returned Value:

    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	TrInitialize();

    --argc;
    ++argv;

    s_FailedRate = 0;
    
    while (argc > 0)
	{
		if (argv[0][0] != L'-') 
			Usage();

		switch(argv[0][1])
		{
            case L'n':
            case L'N':
                s_NoOfMessages = _wtoi(argv[1]);
				argc -= 2;
				argv += 2;
                break;

            case L'f':
			case L'F':
		        s_FailedRate = _wtoi(argv[1]);
				argc -= 2;
				argv += 2;
				break;


            default:
				Usage();
		}
    }

    NoInitialize();
    ExInitialize(5);
    MmtInitialize();

    s_hEvent = CreateEvent(NULL, FALSE, FALSE, L"");

    R<CGroup> pGroup = new CGroup();
	R<CSessionPerfmon> pPerfmon = new CSessionPerfmon;

    bool fFailed = false;

    do
    {
        try
        {
            s_pTrans = MmtCreateTransport(
                                    s_id,
                                    pGroup.get(),
									pPerfmon.get(),
                                    CTimeDuration(10 * CTimeDuration::OneMilliSecond().Ticks()),
                                    CTimeDuration(100 * CTimeDuration::OneMilliSecond().Ticks())
                                    );
        }
        catch(const exception&)
        {
            fFailed = true;
        }
    } while(fFailed);
    
    pGroup.free();

    WaitForSingleObject(s_hEvent, INFINITE);

    WPP_CLEANUP();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envbody.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envbody.h

Abstract:
    Header for serialization\deserialization of the SRMP envelop body.


Author:
    Gil Shafriri(gilsh) 24-APRIL-01

--*/

#pragma once

#ifndef _MSMQ_envbody_H_
#define _MSMQ_envbody_H_

class CQmPacket;


class BodyElement
{
public:
	explicit BodyElement(const CQmPacket& pkt):m_pkt(pkt){}
   	friend std::wostream& operator<<(std::wostream& wstr, const BodyElement&);

private:
	const CQmPacket& m_pkt;
};







#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envbody.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envbody.cpp

Abstract:
    Implementing  serialization\deserialization of the SRMP envelop body.


Author:
    Gil Shafriri(gilsh) 24-APRIL-01

--*/
#include <libpch.h>
#include <qmpkt.h>
#include "envcommon.h"
#include "envbody.h"

using namespace std;

class BodyContent
{
public:	
	explicit BodyContent(const CQmPacket& pkt):m_pkt(pkt){}
   	friend std::wostream& operator<<(std::wostream& wstr, const BodyContent& Body)
	{
		if(!Body.m_pkt.IsSoapIncluded() )
			return wstr;

		const WCHAR* pSoapBody = Body.m_pkt.GetPointerToSoapBody();
		if(pSoapBody == NULL)
			return wstr;

		//
		// pSoapBody is always NULL terminated. See CSoapSection constructor.
		//
		ASSERT(Body.m_pkt.GetSoapBodyLengthInWCHARs() == wcslen(pSoapBody) +1);
		
		return 	wstr<<pSoapBody;
	}

private:
	const CQmPacket& m_pkt;
};



wostream& operator<<(wostream& wstr, const BodyElement& Body)
{
	wstr<<OpenTag(xSoapBody)
		<<BodyContent(Body.m_pkt)
		<<CloseTag(xSoapBody);

	return 	wstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\deserialize.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    deserialize.cpp

Abstract:
    Converts SRMP format to MSMQ packet

Author:
    Uri Habusha (urih) 25-May-00

Environment:													
    Platform-independent

--*/

#include <libpch.h>
#include <xml.h>
#include <mp.h>
#include <envcommon.h>
#include <mqwin64a.h>
#include <acdef.h>
#include <qmpkt.h>
#include <singelton.h>
#include "envelop.h"
#include "attachments.h"
#include "httpmime.h"
#include "proptopkt.h"

#include "deserialize.tmh"

using namespace std;

//
// class CNamespaceToId that holds mapping from namespaces strings
// to ids. Will be handed to parse and be able later to work with ids
// and not with strings (Better performance)
//
template <class T>class CSingelton;
class CNamespaceToId :public INamespaceToId
{
public:
	virtual int operator[](const xwcs_t& ns)const
	{
		NsMap::const_iterator it =  m_nsmap.find(ns);
		if(it == m_nsmap.end())
			return UNKNOWN_NAMESPACE;

		return it->second;
	}

private:
	CNamespaceToId()
	{
		m_nsmap[S_XWCS(xSoapNamespace)] = SOAP_NAMESPACE;
		m_nsmap[S_XWCS(xSrmpNamespace)] = SRMP_NAMESPACE;
		m_nsmap[S_XWCS(xSoapRpNamespace)] = SOAP_RP_NAMESPACE;
		m_nsmap[S_XWCS(xMSMQNamespace)] = MSMQ_NAMESPACE;
	}
	friend  CSingelton<CNamespaceToId>; // this object can only be created by CSingelton<CNamespaceToId>

private:
	typedef std::map<xwcs_t, int> NsMap;
	NsMap m_nsmap;

};



static
void
ParseEnvelop(
	  const xwcs_t& Envelop,
	  CMessageProperties& mProp
    )
{
	mProp.envelop = Envelop;

	CAutoXmlNode pXmlTree;
	const CNamespaceToId* pNamespaceToIdMap = &(CSingelton<CNamespaceToId>::get());

    XmlParseDocument(Envelop , &pXmlTree, pNamespaceToIdMap);
	
    EnvelopToProps(*pXmlTree,  &mProp);
}



static
void
AdjustMessagePropertiesForLocalSend(
			const QUEUE_FORMAT* pDestQueue,
			CMessageProperties& messageProperty
			)
{
    ASSERT(pDestQueue != NULL);
    ASSERT(pDestQueue->GetType() == QUEUE_FORMAT_TYPE_PUBLIC  ||
		   pDestQueue->GetType() == QUEUE_FORMAT_TYPE_PRIVATE ||
		   pDestQueue->GetType() == QUEUE_FORMAT_TYPE_DIRECT
		   );

    if (pDestQueue->GetType() == QUEUE_FORMAT_TYPE_PRIVATE)
    {
        messageProperty.destQmId = (pDestQueue->PrivateID()).Lineage;
    }
}


static
void
AdjustMessagePropertiesForMulticast(
			const QUEUE_FORMAT* pDestQueue,
			CMessageProperties& messageProperty
			)
{
	if (pDestQueue != NULL)
    {
        ASSERT(messageProperty.destQueue.GetType() == QUEUE_FORMAT_TYPE_MULTICAST);
        //
        // Use pDestQueue (provided destination queue) instead of the destination queue on the SRMP
        // packet. For multicast, the SRMP packet contains the multicast
        // address as a traget queue therefor while building the QM packet fill in the
        // target queue with the actual queue
        //
        ASSERT(pDestQueue->GetType() == QUEUE_FORMAT_TYPE_PUBLIC || pDestQueue->GetType() == QUEUE_FORMAT_TYPE_PRIVATE);

		messageProperty.destMulticastQueue.CreateFromQueueFormat(messageProperty.destQueue);
		messageProperty.destMqf.CreateFromMqf(&messageProperty.destMulticastQueue, 1);
        messageProperty.destQueue.CreateFromQueueFormat(*pDestQueue);

        //
        // Private queue is stored on the QM packet as a combination of destination QM ID and
        // queue ID. As a result for private queue, the code retreive the destination QM
        // from the queue format name.
        //
        if (pDestQueue->GetType() == QUEUE_FORMAT_TYPE_PRIVATE)
        {
            messageProperty.destQmId = (pDestQueue->PrivateID()).Lineage;
        }
    }
}



static
CACPacketPtrs
Deserialize(
    const xwcs_t& envelope,
    const CHttpReceivedBuffer& HttpReceivedBuffer,
    const QUEUE_FORMAT* pDestQueue,
	bool fLocalSend
    )
{
    CMessageProperties messageProperty;

	messageProperty.Rawdata = &HttpReceivedBuffer;

	//
	// the local send memeber is set to perform less checks on the SRMP envelope
	// when we are in local send because local send do not create full valid SRMP envelope
	//
	messageProperty.fLocalSend = fLocalSend;


    //
    // Retrieve message properties from ennvelop
    //
    ParseEnvelop(envelope, messageProperty);
	

    //
    // Retrieve message properies from MIME sections
    //
    AttachmentsToProps(HttpReceivedBuffer.GetAttachments(), &messageProperty);


	if(fLocalSend)
	{
		AdjustMessagePropertiesForLocalSend(pDestQueue, messageProperty);
	}
	else
	{
		AdjustMessagePropertiesForMulticast(pDestQueue, messageProperty);
	}

	//
    // Convert the property to packet
    //
    CACPacketPtrs pktPtrs;
	MessagePropToPacket(messageProperty, &pktPtrs);

    return pktPtrs;
}



CQmPacket*
MpDeserialize(
    const char* httpHeader,
    DWORD bodySize,
    const BYTE* body,
    const QUEUE_FORMAT* pqf,
	bool fLocalSend
    )
/*++

Routine Description:
    convert SRMP network data to MSMQ packet

Arguments:
	httpHeader - Pointer to http header
	bodySize - Http body size.
	body - http body
	pqf - destination queue if null taken from the SRMP data.
	fLocalSend - spesify if to do special conversion in the created packet for local send.

Returned Value:
	Heap allocated MSMQ packet

--*/

{
	MppAssertValid();


	basic_xstr_t<BYTE> TheBody(body, bodySize);
    CHttpReceivedBuffer HttpReceivedBuffer(TheBody, httpHeader);
	
    wstring envelope = ParseHttpMime(
                                httpHeader,
                                bodySize,
                                body,
                                &HttpReceivedBuffer.GetAttachments()
                                );

    //
    // build the QmPacket
    //

	CACPacketPtrs  ACPacketPtrs;
	ACPacketPtrs = Deserialize(
                           xwcs_t(envelope.c_str(), envelope.size()),
                           HttpReceivedBuffer,
                           pqf,
						   fLocalSend
                           );

    try
    {
        return new CQmPacket(ACPacketPtrs.pPacket, ACPacketPtrs.pDriverPacket, false);
    }
    catch (const exception&)
    {
        AppFreePacket(ACPacketPtrs);
        throw;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envcommon.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envcommon.cpp

Abstract:
    Implements common utilities for  serialization\deserialization of the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/
#include <libpch.h>
#include <fn.h>
#include <timeutl.h>
#include <mqtime.h>
#include <qmpkt.h>
#include <mp.h>
#include <xml.h>
#include <proptopkt.h>
#include "envcommon.h"
#include "mpp.h"

#include <strsafe.h>

#include "envcommon.tmh"


using namespace std;

template <class T> 
CXmlEncodeDecorator<T>::CXmlEncodeDecorator(
	const T& streamable
	):
	m_streamable(streamable)
{
};



template <class T> 
std::wostream&  
operator<<(
	std::wostream& wstr,
	const CXmlEncodeDecorator<T>& XmlEncodeDecorator
	)
/*++

Routine Description:
    Serialize an object encoded according to xml rules.

Arguments:
	wtr - Stream to serialize the object into.
	XmlEncodeDecorator - xml encoding decorator that holds the object itself.


Returned Value:
	The input stream.

Note :
	The function serialize the given object into temporary stream and then
	xml Encode the data from the temporary stream into the supplied stream.
--*/
{

	wostringstream tmp;
	tmp<<XmlEncodeDecorator.m_streamable;
	wstr<<CXmlEncode(xwcs_t(tmp.str().c_str(), tmp.str().size()));
   	return wstr;
}

//
// Explicit instantiation of templates and template functions.
//
template class CXmlEncodeDecorator<CFnSerializeMqf>;
template std::wostream& operator<<(std::wostream& wstr,const CXmlEncodeDecorator<CFnSerializeMqf>&); 
template class CXmlEncodeDecorator<QueueFormatUriContent>;
template std::wostream& operator<<(std::wostream& wstr,const CXmlEncodeDecorator<QueueFormatUriContent>&); 




wostream& operator<<(wostream& wstr, const QueueFormatUriContent& queue)
{
		if(FnIsDirectHttpFormatName(&queue.m_QueueFormat))
		{
			wstr <<queue.m_QueueFormat.DirectID();
			return wstr;
		}
 		wstr<<FN_MSMQ_URI_PREFIX_TOKEN<<CFnSerializeQueueFormat(queue.m_QueueFormat);
		return wstr;
}




wostream& operator<<(wostream& wstr, const OpenTag& elm )
{
		const WCHAR* xSeperator =  (elm.m_attributes[0] ==  L'\0' ) ? L"" : L" ";

		wstr<<L"<" <<elm.m_name <<xSeperator<<elm.m_attributes <<L">";	
		return wstr;
}


wostream& operator<<(wostream& wstr, const CloseTag& elm )
{
	wstr<< L"</" <<elm.m_name <<L">";
	return wstr;
}


wostream& operator<<(wostream& wstr, const EmptyElement& elm )
{
	wstr<<L"<" <<elm.m_name <<L"/>";
	return wstr;
}





wostream& operator<<(wostream& wstr, const GuidElement& guild)
{
	WCHAR strGuid[GUID_STR_LENGTH + 1];

    const GUID* pGuid = &guild.m_guid;
    HRESULT hr = StringCchPrintf(strGuid, TABLE_SIZE(strGuid), GUID_FORMAT, GUID_ELEMENTS(pGuid));
    ASSERT(("guid buffer is too small", hr == S_OK));
    UNREFERENCED_PARAMETER(hr);

    return (wstr << strGuid);
}


wostream& operator<<(wostream& wstr,const CurrentTimeContent& )
{
	return wstr<<CIso8601Time(MqSysTime());
}


wostream& operator<<(wostream& wstr, const MessageIdContent& mid)
{
		wstr<<xUuidReferencePrefix
			<<mid.m_oid.Uniquifier
			<<xUuidReferenceSeperator
			<<GuidElement(mid.m_oid.Lineage);

		return wstr;
}


wostream& operator<<(wostream& wstr, const OriginalMessageIdentityElement& Identity)
{
		OBJECTID* messageId = (OBJECTID*)Identity.m_pkt.GetCorrelation();
		ASSERT(IsAckMsg(Identity.m_pkt));
		ASSERT(messageId != NULL);

		wstr<<OpenTag(xId)
			<<MessageIdContent(*messageId)
			<<CloseTag(xId);

		return wstr;
}


wostream&  operator<<(wostream& wstr, const Int64Value& Int64)
{
	WCHAR buff[100];
    HRESULT hr = StringCchPrintf(buff, TABLE_SIZE(buff), L"%I64d", Int64.m_value);
    ASSERT(("guid buffer is too small", hr == S_OK));
    UNREFERENCED_PARAMETER(hr);

    return wstr << buff;
}


wostream& operator<<(wostream& wstr, const SendToElement& SendTo)
{
	QUEUE_FORMAT adminQueue;
	(const_cast<CQmPacket&>(SendTo.m_pkt)).GetAdminQueue(&adminQueue);
	ASSERT(adminQueue.GetType() != QUEUE_FORMAT_TYPE_UNKNOWN);

	wstr<<OpenTag(xSendTo)
		<<QueueFormatUriContent(adminQueue)
		<<CloseTag(xSendTo);

	return wstr;
}



//
// Check if gven packet is some kind of acknolagment (negative or positive)
//
bool IsAckMsg(const CQmPacket& pkt)
{
	
	USHORT Class = 	pkt.GetClass();
	bool fAckOrNormal = (MQCLASS_POS_RECEIVE(Class) ||  
						 MQCLASS_NEG_RECEIVE(Class) ||
						 MQCLASS_POS_ARRIVAL(Class) ||
						 MQCLASS_NEG_ARRIVAL(Class)
						);


	return fAckOrNormal && (Class != MQMSG_CLASS_NORMAL);
}

static
const 
xwcs_t
MSMQFormatNameFromUri(
				const xwcs_t& uri
				)
{
	ASSERT(FnIsMSMQUrl(uri));

	return 	xwcs_t( uri.Buffer() + FN_MSMQ_URI_PREFIX_TOKEN_LEN,
					uri.Length() -  FN_MSMQ_URI_PREFIX_TOKEN_LEN);
}



static
void
UriToQueueFormatInternal(
    const xwcs_t& uri,
    CFnQueueFormat& queueFormat
    )
{
    if(uri.Length() == 0)
        return;

	//
    // If http or https we convert it to direct format name
	//
	if(FnIsHttpHttpsUrl(uri))
	{
		queueFormat.CreateFromUrl(uri);
		return;
	}

	//
	// If msmq format name MSMQ:[MSMQ FORMAT NAME]
	//
	if(FnIsMSMQUrl(uri))
	{
		queueFormat.CreateFromFormatName(MSMQFormatNameFromUri(uri));
		return;
	}

    TrERROR(SRMP, "Illegal queue path URI %.*ls", uri);
    throw bad_srmp();
}


void
UriToQueueFormat(
    const xwcs_t& uri,
    CFnQueueFormat& queueFormat
    )
{
	CXmlDecode XmlDecode;
	XmlDecode.Decode(uri);
	
	UriToQueueFormatInternal(XmlDecode.get(), queueFormat);
}


bool
BreakMsmqStreamId(
			const xwcs_t& NetworkStreamid, 
			xwcs_t* pStreamid,
			LONGLONG* pSeqId
			)
/*++

Routine Description:
    Parse stream id that is MSMQ stream id of the format qmguid\\seqid.
	

Arguments:
    NetworkStreamid - stream id of the format qmguid\\seqid.
	pStreamid - receive the  qmguid part
	pSeqId - receives the  seqid part.

Returned Value:
    true if parsed ok - false if wrong format.

--*/
{
	const WCHAR* begin = NetworkStreamid.Buffer();
	const WCHAR* end = 	NetworkStreamid.Buffer() + NetworkStreamid.Length();
	const WCHAR* found = std::search(begin, end, xSlash, xSlash + STRLEN(xSlash) );
	if(found == begin || found == end || found + STRLEN(xSlash) == end)
	{
		return false;
	}
	*pStreamid =  xwcs_t(begin, found - begin);
	*pSeqId =  _wtoi64(found + STRLEN(xSlash));
	if (0 == *pSeqId)
	{
		return false;
	}
	return true;

}


void AdminQueueToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Admin queue node"); 
		throw bad_srmp();
	}

	xwcs_t AckToAddr = node.m_values.front().m_value;
	if(AckToAddr.Length() == 0 )
	{
		TrERROR(SRMP, "Illegal empty Admin queue value"); 
		throw bad_srmp();
	}

    UriToQueueFormat(AckToAddr, pProps->adminQueue);
}






void
StringToGuid(
    xwcs_t& str, 
    GUID* pGuid
    )
{
    const int format[] = {8,4,4,2,2,2,2,2,2,2,2};
    const int delimiter[] ={1,1,1,0,1,0,0,0,0,0,0};
    
    ULONG d[11];

    ASSERT((TABLE_SIZE(format) == 11) && (TABLE_SIZE(delimiter) == 11));
    
    if (str.Length() < GUID_STR_LENGTH)    
    {
        TrERROR(SRMP, "Bad UUID format '%.*ls...'", str);
        throw bad_srmp();
    }
    LPCWSTR p= str.Buffer();
 
    for(int i=0; i< 11; i++)
    {
        WCHAR buf[9];
        WCHAR *endptr;
        int size = format[i];
        if(delimiter[i] && p[size] != L'-')
        {
            TrERROR(SRMP, "Bad UUID format '%.*ls...'", str);
            throw bad_srmp();
        }
        memcpy(buf, p, size*sizeof(WCHAR));
        buf[size]=L'\0'; 
        d[i] = wcstoul(buf,&endptr,16);
        if(*endptr != L'\0')
        {
             TrERROR(SRMP, "Bad UUID format '%.*ls...'", str);
             throw bad_srmp();
        }
        p=p+size+delimiter[i];
    }
    pGuid->Data1=d[0];
    pGuid->Data2 = static_cast<WORD>(d[1]);
    pGuid->Data3 = static_cast<WORD>(d[2]);
    for(int i = 0; i < 8; i++)
    {
        pGuid->Data4[i] = static_cast<BYTE>(d[i+3]);
    }
}


void EmptyNodeToProps(XmlNode& , CMessageProperties* )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envdelreceipt.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envdelreceipt.cpp

Abstract:
    Implements serialization\deserialization of the delivery receipt to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <qmpkt.h>
#include "envdelreceipt.h"
#include "envcommon.h"
#include "mpp.h"
#include "envparser.h"

#include "envdelreceipt.tmh"

using namespace std;

class ReceivedAtElement
{
public:
	explicit  ReceivedAtElement(){};
	friend wostream& operator<<(wostream& wstr, const ReceivedAtElement&)
	{
		wstr <<OpenTag(xreceivedAt)<<CurrentTimeContent()<<CloseTag(xreceivedAt);
		return wstr;
	}
};


wostream& operator<<(wostream& wstr, const DeliveryReceiptElement& dReceipt)
{
		if(dReceipt.m_pkt.GetClass() != MQMSG_CLASS_ACK_REACH_QUEUE)
			return wstr;

		wstr<<OpenTag(xDeliveryReceipt)
			<<ReceivedAtElement()
			<<OriginalMessageIdentityElement(dReceipt.m_pkt)
			<<CloseTag(xDeliveryReceipt);

		return wstr;
}



void 
DeliveryReceiptToProps(
		XmlNode& DeliveryReceipt,
		CMessageProperties*  pMessageProperties
		)
/*++

Routine Description:
    Parse SRMP Delivery Receipt Request element into MSMQ properties.

Arguments:
	Properties - Delivery Receipt Request element in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.   

--*/

{
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xreceivedAt), SRMP_NAMESPACE, EmptyNodeToProps,1 ,1),
										CParseElement(S_XWCS(xId), SRMP_NAMESPACE, EmptyNodeToProps,1 ,1),
									};	

	NodeToProps(DeliveryReceipt, ParseElements, TABLE_SIZE(ParseElements), pMessageProperties);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envcomreceipt.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envcomreceipt.h

Abstract:
    Header for Serialization and Deserialization of srmp envelop commitment receipt  element.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envcomreceipt_H_
#define _MSMQ_envcomreceipt_H_

class CQmPacket;
class XmlNode;
class CMessageProperties;
class CommitmentReceiptElement
{
public:
	explicit CommitmentReceiptElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend std::wostream& operator<<(std::wostream& wstr, const CommitmentReceiptElement& cReceipt);
	
private:
	const CQmPacket& m_pkt;
};

void CommitmentReceiptToProps(XmlNode& Node, CMessageProperties* pMessageProperties);





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envcomreceiptreq.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envdelreceiptreq.h

Abstract:
    Header for Serialization and Deserialization of srmp envelop delivery receipt request element.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envdelreceiptreq_H_
#define _MSMQ_envdelreceiptreq_H_

class CQmPacket;
class XmlNode;
class CMessageProperties;
class CommitmentReceiptRequestElement
{
public:
	explicit CommitmentReceiptRequestElement(const CQmPacket& pkt):m_pkt(pkt){}
	bool IsIncluded() const; 
	friend std::wostream& operator<<(std::wostream& wstr, const CommitmentReceiptRequestElement& CommitmentReceiptRequest);
	
private:
	const CQmPacket& m_pkt;
};


void 
CommitmentReceiptRequestToProps(
	XmlNode& CommitmentReceiptRequest, 
	CMessageProperties* pMessageProperties
	);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envdelreceipt.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envdelreceipt.h

Abstract:
    Header for Serialization and Deserialization of srmp envelop delivery receipt  element.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envdelreceipt_H_
#define _MSMQ_envdelreceipt_H_

class CQmPacket;
class XmlNode;
class CMessageProperties;
class DeliveryReceiptElement
{
public:
	explicit DeliveryReceiptElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend std::wostream& operator<<(std::wostream& wstr, const DeliveryReceiptElement& dReceipt);
	
private:
	const CQmPacket& m_pkt;
};

void DeliveryReceiptToProps(XmlNode& Node, CMessageProperties* pMessageProperties);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envcomreceipt.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envcomreceipt.cpp

Abstract:
    Implements serialization\deserialization of the SRMP header  to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <mqprops.h>
#include <qmpkt.h>
#include "envcomreceipt.h"
#include "envcommon.h"
#include "mpp.h"
#include "envparser.h"

#include "envcomreceipt.tmh"

using namespace std;

class DecidedAtElement
{
public:
	explicit  DecidedAtElement(){};
	friend wostream& operator<<(wostream& wstr, const DecidedAtElement&)
	{
		wstr<<OpenTag(xDecidedAt)
			<<CurrentTimeContent()
			<<CloseTag(xDecidedAt);

		return wstr;
	}
};

class DecisionElement
{
public:
	explicit DecisionElement (const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const DecisionElement& Decision)
	{
		const WCHAR* decision = MQCLASS_POS_RECEIVE(Decision.m_pkt.GetClass()) ? xPositive : xNegative;
		wstr<<OpenTag(xDecision)
			<<decision
			<<CloseTag(xDecision);

		return wstr;
	}

private:
	const CQmPacket& m_pkt;
};


wostream& operator<<(wostream& wstr, const CommitmentReceiptElement& cReceipt)
{
		if(!MQCLASS_RECEIVE(cReceipt.m_pkt.GetClass())) 
			return wstr;

		wstr<<OpenTag(xCommitmentReceipt)
			<<DecidedAtElement()
			<<DecisionElement(cReceipt.m_pkt)
			<<OriginalMessageIdentityElement(cReceipt.m_pkt)
			<<CloseTag(xCommitmentReceipt);

		return wstr;
}






void
CommitmentReceiptToProps(
	XmlNode& CommitmentReceipt, 
	CMessageProperties* pMessageProperties
	)
{
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xDecidedAt),SRMP_NAMESPACE, EmptyNodeToProps, 1,1),
										CParseElement(S_XWCS(xDecision), SRMP_NAMESPACE, EmptyNodeToProps, 1,1),
										CParseElement(S_XWCS(xId), SRMP_NAMESPACE, EmptyNodeToProps,1, 1),
										CParseElement(S_XWCS(xCommitmentCode), SRMP_NAMESPACE, EmptyNodeToProps,0, 1),
										CParseElement(S_XWCS(xCommitmentDetail),SRMP_NAMESPACE, EmptyNodeToProps,0, 1)
								   	};	

	NodeToProps(CommitmentReceipt, ParseElements, TABLE_SIZE(ParseElements), pMessageProperties);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envcomreceiptreq.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envdelreceiptres.cpp

Abstract:
    Implements serialization\deserialization of the commitment receipt request to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <qmpkt.h>
#include <proptopkt.h>
#include "mpp.h"
#include "envcomreceiptreq.h"
#include "envparser.h"
#include "envcommon.h"

#include "envcomreceiptreq.tmh"

using namespace std;

class NegativeOnlyElement
{
public:
	NegativeOnlyElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend  wostream& operator<<(wostream& wstr, const NegativeOnlyElement& NegativeOnly)
	{
		USHORT ackType = (const_cast<CQmPacket&>(NegativeOnly.m_pkt)).GetAckType();
		if ((ackType & MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE) == 0)
			return wstr;
		
		return wstr<<EmptyElement(xNegativeOnly);
	}

private:
	const CQmPacket& m_pkt;
};
	


class PositiveOnlyElement
{
	public:
		PositiveOnlyElement(const CQmPacket& pkt):m_pkt(pkt){}
		friend  wostream& operator<<(wostream& wstr, const PositiveOnlyElement& PositiveOnly)
		{
			USHORT ackType = (const_cast<CQmPacket&>(PositiveOnly.m_pkt)).GetAckType();

			if ((ackType & MQMSG_ACKNOWLEDGMENT_POS_RECEIVE) == 0)
				return wstr; 		

			return wstr<<EmptyElement(xPositiveOnly);
		}

	private:
		const CQmPacket& m_pkt;
};



bool CommitmentReceiptRequestElement::IsIncluded() const 
{
	CQmPacket& 	pkt = const_cast<CQmPacket&>(m_pkt);
	USHORT ackType = pkt.GetAckType();

	if ((ackType & (MQMSG_ACKNOWLEDGMENT_POS_RECEIVE | MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE)) == 0)
		return false;


	QUEUE_FORMAT adminQueue;
	pkt.GetAdminQueue(&adminQueue);

	if (adminQueue.GetType() == QUEUE_FORMAT_TYPE_UNKNOWN)
		return false;

	return true;
}



wostream& operator<<(wostream& wstr, const CommitmentReceiptRequestElement&  CommitmentReceiptRequest)
{
		if(!CommitmentReceiptRequest.IsIncluded())
			return wstr;


		const CQmPacket& pkt = CommitmentReceiptRequest.m_pkt;

		wstr<<OpenTag(xCommitmentReceiptRequest)
			<<PositiveOnlyElement(pkt)
			<<NegativeOnlyElement(pkt)
    		<<SendToElement(pkt)
			<<CloseTag(xCommitmentReceiptRequest);

		return 	wstr;
}




static void PositiveOnlyToProps(XmlNode& , CMessageProperties* pProps)
{
	pProps->acknowledgeType |= MQMSG_ACKNOWLEDGMENT_POS_RECEIVE;
}


static void NegativeOnlyToProps(XmlNode& , CMessageProperties* pProps)
{
	pProps->acknowledgeType |= MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE;
}




static void SendToToProps(XmlNode& node, CMessageProperties* pProps)
{
	AdminQueueToProps(node, pProps);
}



void 
CommitmentReceiptRequestToProps(
	XmlNode& CommitmentReceiptRequest, 
	CMessageProperties* pMessageProperties
	)
/*++

Routine Description:
    Parse SRMP Commitment Receipt Request element into MSMQ properties.

Arguments:
	Properties - Commitment Receipt Request element in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.   

--*/
{
		CParseElement ParseElements[] =	{
											CParseElement(S_XWCS(xPositiveOnly),SRMP_NAMESPACE,  PositiveOnlyToProps, 0 ,1),
											CParseElement(S_XWCS(xNegativeOnly),SRMP_NAMESPACE,  NegativeOnlyToProps, 0 ,1),
											CParseElement(S_XWCS(xSendBy),SRMP_NAMESPACE,  EmptyNodeToProps, 0 ,1),
											CParseElement(S_XWCS(xSendTo),SRMP_NAMESPACE, SendToToProps, 1 ,1)
										};	

		NodeToProps(CommitmentReceiptRequest, ParseElements, TABLE_SIZE(ParseElements), pMessageProperties);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envdelreceiptreq.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envdelreceiptreq.h

Abstract:
    Header for Serialization and Deserialization of srmp envelop delivery receipt request element.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envdelreceiptreq_H_
#define _MSMQ_envdelreceiptres_H_

class CQmPacket;
class XmlNode;
class CMessageProperties;
class DeliveryReceiptRequestElement
{
public:
	explicit DeliveryReceiptRequestElement(const CQmPacket& pkt):m_pkt(pkt){}
	bool IsIncluded() const; 
	friend std::wostream& operator<<(std::wostream& wstr, const DeliveryReceiptRequestElement& dReceipt);
	
private:
	const CQmPacket& m_pkt;
};

void DeliveryReceiptRequestToProps(XmlNode& DeliveryReceiptRequest, CMessageProperties* pMessageProperties);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envdelreceiptreq.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envdelreceiptres.cpp

Abstract:
    Implements serialization\deserialization of the delivery receipt request to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <qmpkt.h>
#include <proptopkt.h>
#include <xml.h>
#include <mp.h>
#include "mpp.h"
#include "envdelreceiptreq.h"
#include "envparser.h"
#include "envcommon.h"

#include "envdelreceiptreq.tmh"

using namespace std;

bool DeliveryReceiptRequestElement::IsIncluded() const 
{
	CQmPacket& 	pkt = const_cast<CQmPacket&>(m_pkt);
	USHORT ackType = pkt.GetAckType();

	if( (ackType & MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL) == 0)
		return false;


	QUEUE_FORMAT adminQueue;
	pkt.GetAdminQueue(&adminQueue);

	if (adminQueue.GetType() == QUEUE_FORMAT_TYPE_UNKNOWN)
		return false;

	return true;
}

wostream& operator<<(wostream& wstr, const DeliveryReceiptRequestElement& DeliveryReceiptRequest)
{
		if(!DeliveryReceiptRequest.IsIncluded())
			return wstr; 

		const CQmPacket& pkt = DeliveryReceiptRequest.m_pkt;
		

		wstr<<OpenTag(xDeliveryReceiptRequest) 
			<<SendToElement(pkt)
	  		<<CloseTag(xDeliveryReceiptRequest); 

		return wstr;
}

static void SendToToProps(XmlNode& node, CMessageProperties* pProps)
{
		pProps->acknowledgeType |= MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL;
		AdminQueueToProps(node, pProps);
}



 

void 
DeliveryReceiptRequestToProps(
	XmlNode& DeliveryReceipt, 
	CMessageProperties* pMessageProperties)
/*++

Routine Description:
    Parse SRMP Delivery Receipt element into MSMQ properties.

Arguments:
	DeliveryReceipt - Delivery Receipt Request element in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.   

--*/
{
		CParseElement ParseElements[] =	{
											CParseElement(S_XWCS(xSendTo),SRMP_NAMESPACE, SendToToProps, 1, 1),
											CParseElement(S_XWCS(xSendBy),SRMP_NAMESPACE, EmptyNodeToProps, 0 ,1)
										};	

		NodeToProps(DeliveryReceipt, ParseElements, TABLE_SIZE(ParseElements), pMessageProperties);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envendpoints.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envendpoints.h

Abstract:
    Header for serialization\deserialization of the smxp element to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envendpoints_H_
#define _MSMQ_envendpoints_H_
class CQmPacket;
class XmlNode;
class CMessageProperties;
class SmXpPathElement
{
public:
	explicit SmXpPathElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend  std::wostream& operator<<(std::wostream& wstr, const SmXpPathElement& SmXpPath);

private:
	const CQmPacket& m_pkt;
};

void SmXpPathToProps(XmlNode& Node, CMessageProperties* pMessageProperties);





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envelop.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envelop.h

Abstract:
    Header for serialization\deserialization of the SRMP envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envelop_H_
#define _MSMQ_envelop_H_

class CQmPacket;
class CMessageProperties;
class XmlNode;
class EnvelopElement
{
public:
	explicit EnvelopElement(const CQmPacket& pkt);
	friend std::wostream& operator<<(std::wostream& wstr, const EnvelopElement& Envelop);

private:		
	const CQmPacket& m_pkt;
};
std::wstring GenerateEnvelope(const CQmPacket& pkt);
void EnvelopToProps(XmlNode& Envelop, CMessageProperties* pMessageProperties);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envcommon.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envcommon.h

Abstract:
    Header for common utilities for  serialization\deserialization of the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envcommon_H_
#define _MSMQ_envcommon_H_
#include <xstr.h>
struct QUEUE_FORMAT;
class CQmPacket;
class CFnQueueFormat;
class CMessageProperties;
class XmlNode;

class OpenTag
{
public:
	explicit OpenTag(
		const WCHAR* name,
		const WCHAR* attributes = L""):
		m_name(name),
		m_attributes(attributes)
		{};

	friend std::wostream& operator<<(std::wostream& wstr, const OpenTag& elm);

private:
	const WCHAR* m_name;
	const WCHAR* m_attributes;
};


class CloseTag
{
public:
	explicit CloseTag(const WCHAR* name):m_name(name){};
	friend std::wostream& operator<<(std::wostream& wstr, const CloseTag& elm );
	
private:
	const WCHAR* m_name;
};


class EmptyElement
{
public:
	explicit EmptyElement(const WCHAR* name):m_name(name){};
	friend std::wostream& operator<<(std::wostream& wstr, const EmptyElement& elm );
	
private:
	const WCHAR* m_name;
};




class QueueFormatUriContent
{
public:
	explicit QueueFormatUriContent(
		const QUEUE_FORMAT& QueueFormat
		):
		m_QueueFormat(QueueFormat)
		{
		}

	friend std::wostream& operator<<(std::wostream& wstr, const QueueFormatUriContent& queue);

private:
	const QUEUE_FORMAT& m_QueueFormat;	
};



class CurrentTimeContent
{
public:
	explicit CurrentTimeContent(){}
	friend std::wostream& operator<<(std::wostream& wstr,const CurrentTimeContent&);
};


class MessageIdContent
{
public:
	explicit MessageIdContent(const OBJECTID& oid):m_oid(oid){}
	friend std::wostream& operator<<(std::wostream& wstr, const MessageIdContent& mid);
	
private:
	const OBJECTID& m_oid;
};


class OriginalMessageIdentityElement
{
public:
	explicit OriginalMessageIdentityElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend std::wostream& operator<<(std::wostream& wstr, const OriginalMessageIdentityElement& Identity);

private:
	const CQmPacket& m_pkt;
};


class GuidElement
{
public:
	explicit GuidElement(const GUID& guid):m_guid(guid){}
	friend 	std::wostream& operator<<(std::wostream& wstr, const GuidElement& guid);

private:
	const GUID& m_guid;
};


class SendToElement
{
public:
	SendToElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend  std::wostream& operator<<(std::wostream& wstr, const SendToElement& SendTo);

private:
	const CQmPacket& m_pkt;
};



class Int64Value
{
public:
	explicit Int64Value(LONGLONG value):m_value(value){}
	friend std::wostream&  operator<<(std::wostream& wstr, const Int64Value& Int64);

private:
	LONGLONG m_value;	
};


//-------------------------------------------------------------------
//
// CXmlEncodeDecorator class for encoding stremable object into xml encoded format
//
//-------------------------------------------------------------------
template <class T> class CXmlEncodeDecorator;

template<class T> 
std::wostream&  
operator<<(
	std::wostream& wstr,
	const CXmlEncodeDecorator<T>& XmlEncodeDecorator
	);

template <class T> class CXmlEncodeDecorator
{
public:
	CXmlEncodeDecorator(const T& streamable);
	friend std::wostream&  operator<<<T>(std::wostream& wstr,const CXmlEncodeDecorator<T>&);


private:
	const T& m_streamable;	
};


template <class T> inline  const CXmlEncodeDecorator<T>  XmlEncodeDecorator(const T& streamable)
{
	return 	CXmlEncodeDecorator<T>(streamable);
}


bool IsAckMsg(const CQmPacket& pkt);
void StringToGuid(xwcs_t& str, GUID* pGuid);
void UriToQueueFormat(const xwcs_t& uri, CFnQueueFormat& queueFormat);
bool BreakMsmqStreamId(const xwcs_t& NetworkStreamid, xwcs_t* pStreamid,LONGLONG* pSeqId);
void AdminQueueToProps(XmlNode& node, CMessageProperties* pProps);
void EmptyNodeToProps(XmlNode& , CMessageProperties* );


//
// SRMP key words
//
#define xmustUnderstandTrueValue L"1"
#define xmustUnderstandAttribute  L"mustUnderstand"
#define  xSoapmustUnderstandTrue  xSoapEnv L":" xmustUnderstandAttribute L"=\"" xmustUnderstandTrueValue L"\""
#define xEnvelope     L"Envelope"
#define xSoapEnv      L"se"
#define xHeader       L"Header"
#define xBody         L"Body"



static const WCHAR xProperties[] = L"properties";
static const WCHAR xStream[] =  L"Stream";
static const WCHAR xStreamReceipt[] = L"streamReceipt";
static const WCHAR xExpiresAt[] =  L"expiresAt";
static const WCHAR xDuration[] =  L"duration";
static const WCHAR xSentAt[] =     L"sentAt";
static const WCHAR xServices[] =  L"services";
static const WCHAR xDeliveryReceiptRequest[] = L"deliveryReceiptRequest";
static const WCHAR xDeliveryReceipt[] = L"deliveryReceipt";
static const WCHAR xCommitmentReceipt[] = L"commitmentReceipt";
static const WCHAR xreceivedAt[] = L"receivedAt";
static const WCHAR xDecidedAt[] = L"decidedAt";
static const WCHAR xDecision[] =   L"decision";
static const WCHAR xNegativeOnly[] = L"negativeOnly";
static const WCHAR xPositiveOnly[] = L"positiveOnly";
static const WCHAR xPositive[] = L"positive";
static const WCHAR xNegative[] =  L"negative";
static const WCHAR xCommitmentReceiptRequest[] = L"commitmentReceiptRequest";
static const WCHAR xSendTo[] = L"sendTo";
static const WCHAR xDurable[] = L"durable" ;
static const WCHAR xStreamId[] =  L"streamId";
static const WCHAR xCurrent[] =  L"current"; 
static const WCHAR xlastOrdinal[] = L"lastOrdinal" ;
static const WCHAR xPrevious[] = L"previous";
static const WCHAR xStart[] = L"start";
static const WCHAR xSendReceiptsTo[] = L"sendReceiptsTo";
static const WCHAR xSourceQmGuid[] = L"SourceQmGuid";
static const WCHAR xSignature[] = L"Signature";
static const WCHAR xInReplyTo[] = L"inReplyTo";
static const WCHAR xFilterDuplicates[] = L"filterDuplicates";
static const WCHAR xStreamReceiptRequest[] = L"streamReceiptRequest";
static const WCHAR xCommitmentCode[] = L"commitmentCode";
static const WCHAR xCommitmentDetail[] = L"xCommitmentDetail";
static const WCHAR xEnd[] = L"end";


static const WCHAR xSoapEnvelope[] = xSoapEnv L":" xEnvelope;
static const WCHAR xSoapHeader[] =  xSoapEnv L":" xHeader;
static const WCHAR xSoapBody[] = xSoapEnv L":" xBody;
static const WCHAR xSoapmustUnderstand[] = xSoapEnv L":" L"mustUnderstand";

//
// SMXP key words
//
static const WCHAR xPath[] =  L"path";
static const WCHAR xFixed[] = L"fixed";
static const WCHAR xFwd[] = L"fwd";
static const WCHAR xRev[] = L"rev";
static const WCHAR xVia[] = L"via";
static const WCHAR xFault[] = L"fault";
static const WCHAR xTo[] =  L"to";
static const WCHAR xAction[] =  L"action";
static const WCHAR xRelatesTo[] =  L"relatesTo";
static const WCHAR xId[] =  L"id";
static const WCHAR xFrom[] = L"from";

//
// MSMQ specific key words
//
static const WCHAR  xMsmq[] = L"Msmq";
static const WCHAR xClass[] = L"Class";
static const WCHAR xPriority[] = L"Priority";
static const WCHAR xProvider[] =  L"Provider";
static const WCHAR xType[] =  L"Type";
static const WCHAR xName[] =  L"Name";
static const WCHAR xEod[] =  L"Eod";
static const WCHAR xFirst[] =  L"First";
static const WCHAR xLast[] = L"Last";
static const WCHAR xConnectorId[] =  L"xConnectorId";
static const WCHAR xHashAlgorithm[] = L"HashAlgorithm";
static const WCHAR xBodyType[] = L"BodyType";
static const WCHAR xApp[] =  L"App";
static const WCHAR xConnectorType[] =  L"ConnectorType";
static const WCHAR xTrace[] =  L"Trace";
static const WCHAR xJournal[] =  L"Journal";
static const WCHAR xDeadLetter[] =  L"DeadLetter";
static const WCHAR xSendBy[] =  L"SendBy";
static const WCHAR xCorrelation[] =  L"Correlation";
static const WCHAR xDestinationMqf[] =  L"DestinationMqf";
static const WCHAR xAdminMqf[] =  L"AdminMqf";
static const WCHAR xResponseMqf[]= L"ResponseMqf";
static const WCHAR xReplyTo[] =  L"replyTo";
static const WCHAR xTTrq[] = L"TTrq";

//
// Known xml namespaces
//
#define xSoapNamespace   L"http://schemas.xmlsoap.org/soap/envelope/"
#define xSrmpNamespace   L"http://schemas.xmlsoap.org/srmp/"
#define xSoapRpNamespace L"http://schemas.xmlsoap.org/rp/" 
#define xMSMQNamespace   L"msmq.namespace.xml"


//
// Known namespaces ids
//
const int UNKNOWN_NAMESPACE = 0;
const int SOAP_NAMESPACE = 1;
const int SRMP_NAMESPACE = 2;
const int SOAP_RP_NAMESPACE = 3;
const int MSMQ_NAMESPACE = 4;


//
// Msmq prefix for SMXP::Action
//
static const WCHAR xMsmqActionPrefix[] = L"MSMQ:";


//
// Sender stream prefix
//
const WCHAR xSenderStreamSecretePrefix[] = L"?SenderStream=";


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envelop.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envelop.cpp

Abstract:
    Implements serialization\deserialization of srmp envelop.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <qmpkt.h>
#include <proptopkt.h>
#include <xml.h>
#include "envelop.h"
#include "envheader.h"
#include "envcommon.h"
#include "mpp.h"
#include "envparser.h"
#include "envbody.h"
#include "envelop.tmh"

using namespace std;


static
void
ValidatePacket(
		const CQmPacket& pkt
		)
{
	ASSERT(!pkt.IsSrmpIncluded());
	ASSERT(!(pkt.IsEodIncluded() && pkt.IsEodAckIncluded()));
	ASSERT(!(pkt.IsOrdered() && pkt.IsEodAckIncluded()));
	ASSERT(!( IsAckMsg(pkt) && pkt.IsOrdered()));

	DBG_USED(pkt);
}

EnvelopElement::EnvelopElement(
				const CQmPacket& pkt
				):
				m_pkt(pkt)
{
	ValidatePacket(pkt);
}



wstring GenerateEnvelope(const CQmPacket& pkt)
{  
	wostringstream wstr(L"");
	wstr.exceptions(ios_base::badbit | ios_base::failbit);
	wstr<<EnvelopElement(pkt);
    return wstr.str();
}



wostream& operator<<(wostream& wstr, const EnvelopElement& Envelop)
/*++

Routine Description:
    Serialize SRMP envelop into stream
	

Arguments:
	wstr - Stream
	Envelop - Envelop stream manipulator. 

Returned Value:
    Stream after envelop was serialiased to it.

Note:
This function serializes QM packet into stream according to SRMP envelop format.

--*/
{
		const WCHAR* EnvelopAttributes = L"xmlns:" xSoapEnv L"="  L"\""  xSoapNamespace L"\""
	                            		 L" xmlns=" L"\"" xSrmpNamespace L"\""; 


		wstr<<OpenTag(xSoapEnvelope, EnvelopAttributes)
			<<HeaderElement(Envelop.m_pkt)
			<<BodyElement(Envelop.m_pkt)
			<<CloseTag(xSoapEnvelope);

		return wstr;
}







void EnvelopToProps(XmlNode& Envelop, CMessageProperties* pMessageProperties)
/*++

Routine Description:
    Parse envelop in SRMP reperesenation into MSMQ properties.

Arguments:
	Envelop - envelop in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.   

--*/
{	
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xHeader),SOAP_NAMESPACE, HeaderToProps, 1, 1),
										CParseElement(S_XWCS(xBody),  SOAP_NAMESPACE, EmptyNodeToProps, 1,1)	
									};	

	NodeToProps(Envelop, ParseElements, TABLE_SIZE(ParseElements), pMessageProperties);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envheader.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envheader.cpp

Abstract:
    Implements serialization\deserialization of the SRMP header  to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <xml.h>
#include "envheader.h"
#include "envendpoints.h"
#include "envservice.h"
#include "envstream.h"
#include "envprops.h"
#include "envstreamreceipt.h"
#include "envdelreceipt.h"
#include "envcomreceipt.h"
#include "envusrheader.h"
#include "envmsmq.h"
#include "envsec.h"
#include "envcommon.h"
#include "envparser.h"
#include "mpp.h"

#include "envheader.tmh"

using namespace std;

wostream& operator<<(wostream& wstr, const HeaderElement& Header)
{
		const CQmPacket& pkt = 	Header.m_pkt;

		wstr<<OpenTag(xSoapHeader)
			<<SmXpPathElement(pkt)
			<<PropertiesElement(pkt)
			<<ServiceElement(pkt)
			<<StreamElement(pkt)
			<<StreamReceiptElement(pkt)
			<<DeliveryReceiptElement(pkt)
			<<CommitmentReceiptElement(pkt)
			<<MsmqElement(pkt)
			<<SignatureElement(pkt)
			<<UserHeaderElement(pkt)
			<<CloseTag(xSoapHeader);

		return 	wstr;
}


static void MoveToFirst(XmlNode& node, const WCHAR* tag)
/*++

Routine Description:
    Reorder headers elements for parsing by putting msmq element first.
	It is important because parsing is different if it is not MSMQ packet.

Arguments:
	node - elements tree.
	tag - name of the tag to move to front of the list.

Returned Value:
	None.   

--*/
{
	
	for(List<XmlNode>::iterator it = node.m_nodes.begin(); it != node.m_nodes.end(); ++it)
	{
		if(it->m_tag == tag)
		{
			node.m_nodes.remove(*it);
			node.m_nodes.push_front(*it);
			return;
		}
	}
}


void HeaderToProps(XmlNode& node, CMessageProperties* pProps)
/*++

Routine Description:
    Parse SRMP header element into MSMQ properties.

Arguments:
	Header - header element in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.   

--*/
{


	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xPath),SOAP_RP_NAMESPACE,  SmXpPathToProps , 1, 1),
										CParseElement(S_XWCS(xProperties),SRMP_NAMESPACE,  PropertiesToProps, 1, 1),
										CParseElement(S_XWCS(xServices),SRMP_NAMESPACE, ServiceToProps, 0, 1),
										CParseElement(S_XWCS(xStream), SRMP_NAMESPACE, StreamToProps, 0, 1),
										CParseElement(S_XWCS(xStreamReceipt), SRMP_NAMESPACE, StreamReceiptToProps, 0, 1),
										CParseElement(S_XWCS(xDeliveryReceipt), SRMP_NAMESPACE, DeliveryReceiptToProps, 0, 1),
										CParseElement(S_XWCS(xCommitmentReceipt),SRMP_NAMESPACE,  CommitmentReceiptToProps, 0, 1),
										CParseElement(S_XWCS(xMsmq), MSMQ_NAMESPACE, MsmqToProps,0, 1),
										CParseElement(S_XWCS(xSignature), UNKNOWN_NAMESPACE, SignatureToProps, 0 ,1)
									};	
	//
	// We need to have MSMQ element parsed first  and then stream receipt. 
	//
	MoveToFirst(node, xStreamReceipt);  
	MoveToFirst(node, xMsmq);  

	NodeToProps(node, ParseElements, TABLE_SIZE(ParseElements), pProps);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envheader.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envelopheader.h

Abstract:
    Header for serialization\deserialization of the SRMP header to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envheader_H_
#define _MSMQ_envheader_H_
class  XmlNode;
class  CMessageProperties;
class  CQmPacket;

class HeaderElement
{
public:
	explicit HeaderElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend std::wostream& operator<<(std::wostream& wstr, const HeaderElement& Header);

private:		
	const CQmPacket& m_pkt;
};

void HeaderToProps(XmlNode& Header, CMessageProperties* pMessageProperties);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envendpoints.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envendpoints.cpp

Abstract:
    Implements serialization\deserialization of the smxp element to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <mqsymbls.h>
#include <mqformat.h>
#include <qmpkt.h>
#include <xml.h>
#include <mp.h>
#include <proptopkt.h>
#include "envendpoints.h"
#include "envcommon.h"
#include "mpp.h"
#include "envparser.h"
#include "qal.h"

#include "envendpoints.tmh"

using namespace std;


class MessageIdentityElement
{
public:
	explicit MessageIdentityElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MessageIdentityElement& MIdentity)
	{
		OBJECTID messageId;
		MIdentity.m_pkt.GetMessageId(&messageId);

		wstr<<OpenTag(xId)
			<<MessageIdContent(messageId)
			<<CloseTag(xId);

 		return wstr;
	}
private:
	const CQmPacket& m_pkt;
};



class ToElement
{
public:
	explicit ToElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const ToElement& To)	
	{
		QUEUE_FORMAT destQueueFormat;
		const_cast<CQmPacket&>(To.m_pkt).GetDestinationQueue(&destQueueFormat);
		
		wstr <<OpenTag(xTo)
			 <<XmlEncodeDecorator(QueueFormatUriContent(destQueueFormat))
			 <<CloseTag(xTo);

		return wstr;
  	}

private:
const CQmPacket& m_pkt;
};



class ActionElement
{
public:
	explicit ActionElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const ActionElement& Action)	
	{
		wstr<<OpenTag(xAction)
			<<ActionContent(Action.m_pkt.GetTitlePtr(), Action.m_pkt.GetTitleLength())
			<<CloseTag(xAction);

		return wstr;
	}


private:
	class ActionContent
	{
	public:
		explicit ActionContent(
					const WCHAR* pTitle,
					DWORD TitleLen
					):
					m_pTitle(pTitle),
					m_TitleLen(TitleLen)
					{}

		friend wostream& operator<<(wostream& wstr, const ActionContent& Action)	
		{
            xwcs_t MsmqActionPrefix(xMsmqActionPrefix, STRLEN(xMsmqActionPrefix));
            wstr<<CXmlEncode(MsmqActionPrefix);

			if (Action.m_TitleLen == 0)
            {
                return wstr;
            }

	   		ASSERT(Action.m_pTitle[Action.m_TitleLen - 1] == L'\0');
			xwcs_t 	wcsAction(Action.m_pTitle, Action.m_TitleLen - 1);
			return wstr<<CXmlEncode(wcsAction);
		}

	private:
	const WCHAR* m_pTitle;
	DWORD m_TitleLen;
	};


private:
	const CQmPacket& m_pkt;
};


class  RevElement
{
public:
	explicit RevElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const RevElement& Rev)	
	{
		QUEUE_FORMAT replyQueueFormat;
		const_cast<CQmPacket&>(Rev.m_pkt).GetResponseQueue(&replyQueueFormat);

		if (replyQueueFormat.GetType() == QUEUE_FORMAT_TYPE_UNKNOWN)
			return 	wstr;

		wstr<<OpenTag(xRev)
			<<ViaElement(replyQueueFormat)
			<<CloseTag(xRev);

		return wstr;
	}

private:
	class ViaElement
	{
	public:
		ViaElement(const QUEUE_FORMAT& QueueFormat):m_QueueFormat(QueueFormat){}
		friend wostream& operator<<(wostream& wstr, const ViaElement& Via)	
		{
			wstr<<OpenTag(xVia)
				<<QueueFormatUriContent(Via.m_QueueFormat)
				<<CloseTag(xVia);

			return wstr;
		}

	private:
		const QUEUE_FORMAT& m_QueueFormat;	
	};


private:
	const CQmPacket& m_pkt;
};




wostream& operator<<(wostream& wstr, const SmXpPathElement& SmXpPath)
{
		const WCHAR* xSmxpAttributes = L"xmlns=" L"\"" xSoapRpNamespace L"\" "  xSoapmustUnderstandTrue;

		wstr<<OpenTag(xPath, xSmxpAttributes)
			<<ActionElement(SmXpPath.m_pkt)
    		<<ToElement(SmXpPath.m_pkt)
			<<RevElement(SmXpPath.m_pkt)
			<<MessageIdentityElement(SmXpPath.m_pkt)
			<<CloseTag(xPath);

		return wstr;
}


static 	xwcs_t BreakOrderQueue(const xwcs_t& FullOrderQueue, xwcs_t* SenderStream)
/*++

Routine Description:
    Break destination queue into queue format name and a sender stream data appended to the
	destination queue.

	The destination queue is expected to be in the format :	<url>?SenderStream=<RandomString>.
	For example : HTTP://hotname.ntdev.microsoft.com/MSMQ/PRIVATE$/order_queue$?SenderStream=XRntV
	

Arguments:
	FullOrderQueue - Order queue url as accepted from the network.
	SenderStream - Receive the random stream data.

	
Returned Value:
	Queue format name after the random stream was cut from it.

--*/
{
	*SenderStream = xwcs_t();

	const WCHAR* begin = FullOrderQueue.Buffer();
	const WCHAR* end = 	FullOrderQueue.Buffer() + FullOrderQueue.Length();

	const WCHAR* found = std::search(
					begin,
					end,
					xSenderStreamSecretePrefix,
					xSenderStreamSecretePrefix + STRLEN(xSenderStreamSecretePrefix)
					);

	if(found == end)
		return FullOrderQueue;

	xwcs_t OrderQueue(begin, found - begin);

	begin = found + STRLEN(xSenderStreamSecretePrefix);
	
	found = std::find(
				begin,
				end,
				L'&'
				);

	if(found == end)
	{
		*SenderStream =  xwcs_t(begin, end - begin);
	}
	else
	{
		*SenderStream = xwcs_t(begin, found - begin);		
	}
	return OrderQueue;
}



static void DestinationQueueToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Destination queue node");
		throw bad_srmp();
	}

	xwcs_t DestinationQueue = node.m_values.front().m_value;
	if(DestinationQueue.Length() == 0)
	{
		TrERROR(SRMP, "Illegal empty Destination queue value");
		throw bad_srmp();
	}

	//
	// In case of stream receipt (order ack) we should seperate the queue name
	// from the sender random string append to it. This string  is
	// used for testing the validity of the stream receipt.
	//
	if(pProps->fStreamReceiptSectionIncluded)
	{
		xwcs_t SenderStream;
		DestinationQueue = BreakOrderQueue(DestinationQueue, &SenderStream);
		if(SenderStream.Length() != 0)
		{
			AP<WCHAR> wcsSenderStream = SenderStream.ToStr();
            pProps->SenderStream.free();
			pProps->SenderStream = UtlWcsToUtf8(wcsSenderStream);
		}
	}

    UriToQueueFormat(DestinationQueue, pProps->destQueue);

    //
    // Translate the recieved destination queue in case there is a mapping
    // exist
    //
    QUEUE_FORMAT_TRANSLATOR  TranslatedFN(&pProps->destQueue, CONVERT_SLASHES | MAP_QUEUE);

    //
    // if destination is not valid from point of view of application - reject it
    //
    if(	!AppIsDestinationAccepted( TranslatedFN.get(), TranslatedFN.IsTranslated()) )
    {
        TrERROR(SRMP, "Packet is not accepted by QM");
        throw bad_srmp();
    }

    if( TranslatedFN.IsCanonized() || TranslatedFN.IsTranslated())
    {
        pProps->destQueue.CreateFromQueueFormat( *TranslatedFN.get() );
    }
}


static bool ExtractMSMQMessageId(const xwcs_t& Mid, CMessageProperties* pProps)
{
	DWORD nscan = 0;
	WCHAR  GuidSeperator = 0;
	DWORD Uniquifier;
    int n = _snwscanf(
				Mid.Buffer(),
				Mid.Length(),
                UUIDREFERENCE_PREFIX L"%d%lc"  L"%n",
                &Uniquifier,
				&GuidSeperator,
				&nscan
                );

    if (n != 2)
		return false;
	

	if(xUuidReferenceSeperatorChar != GuidSeperator)
		return false;
	

	if(Mid.Buffer()+ nscan != (Mid.Buffer() + Mid.Length() - GUID_STR_LENGTH) )
		return false;
	
    xwcs_t MidGuid = xwcs_t(Mid.Buffer() + nscan, Mid.Length() - nscan);

    StringToGuid(MidGuid, &pProps->messageId.Lineage);
	pProps->messageId.Uniquifier = Uniquifier;
	return true;
}


static void MessageIdentityToProps(XmlNode& node, CMessageProperties* pProps)
{
	pProps->messageId.Uniquifier = 1;
	pProps->messageId.Lineage = GUID_NULL;

	if (!pProps->fMSMQSectionIncluded)
		return;

	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Message ID node");
		throw bad_srmp();
	}


	xwcs_t Mid = node.m_values.front().m_value;
	if(Mid.Length() == 0)
	{
		TrERROR(SRMP, "Illegal empty Message ID value");
		throw bad_srmp();
	}

	//
	// first try to see if the message id is from MSMQ format uuid:index@guid.
	//
	bool fSuccess = ExtractMSMQMessageId(Mid, pProps);
	if(fSuccess)
		return;

	//
	// The message id format is not MSMQ message id format - set fixed messages id.
	//
	TrERROR(SRMP, "%.*ls is non MSMQ messages id format -  create new message id", Mid);
}							



static void ReplyQueueToProps(XmlNode& node, CMessageProperties* pProps)
{
	//
	//according to smxp spec via element can exists but be empty
	//
	if(node.m_values.empty())
	{
		return;
	}

	xwcs_t ReplyQueue = node.m_values.front().m_value;
	if(ReplyQueue.Length() == 0)
	{
		TrERROR(SRMP, "Illegal empty Replay queue value");
		throw bad_srmp();
	}

    UriToQueueFormat(ReplyQueue, pProps->responseQueue);
}


static void RevToProps(XmlNode& node, CMessageProperties* pProps)
{
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xVia), SOAP_RP_NAMESPACE, ReplyQueueToProps, 1,1),
									};	

	NodeToProps(node, ParseElements, TABLE_SIZE(ParseElements), pProps);
}


static void ActionToProps(XmlNode& node, CMessageProperties* pProp)
{
	if(node.m_values.empty())
	{
		return;
	}

    pProp->SmxpActionBuffer->Decode(node.m_content);

    xwcs_t SmxpActionBuffer = pProp->SmxpActionBuffer->get();

    //
    // Length of the SMXP::Action is too small to hold a message title
    //
    size_t SmxpActionLength = SmxpActionBuffer.Length();
    if (SmxpActionLength <= STRLEN(xMsmqActionPrefix))
    {
        return;
    }

    //
    // The SMXP::Action does not contain the MSMQ: prefix
    //
    if (wcsncmp(SmxpActionBuffer.Buffer(), xMsmqActionPrefix, STRLEN(xMsmqActionPrefix)) != 0)
    {
        return;
    }

    //
    // The message title is the SMXP::Action content without the MSMQ: prefix
    //
    xwcs_t title(
        SmxpActionBuffer.Buffer() + STRLEN(xMsmqActionPrefix),
        SmxpActionBuffer.Length() - STRLEN(xMsmqActionPrefix)
        );

	pProp->title = title;
}


void SmXpPathToProps(XmlNode& SmXpPath, CMessageProperties* pMessageProperties)
/*++

Routine Description:
    Parse SRMP endpoints element into MSMQ properties.

Arguments:
	Endpoints - Endpoints element in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.

--*/
{
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xId),SOAP_RP_NAMESPACE, MessageIdentityToProps, 1,1),
										CParseElement(S_XWCS(xTo), SOAP_RP_NAMESPACE, DestinationQueueToProps, 1, 1),
										CParseElement(S_XWCS(xRev), SOAP_RP_NAMESPACE, RevToProps, 0,1),
										CParseElement(S_XWCS(xFrom),SOAP_RP_NAMESPACE, EmptyNodeToProps, 0 ,1),
										CParseElement(S_XWCS(xAction), SOAP_RP_NAMESPACE, ActionToProps, 1,1),
										CParseElement(S_XWCS(xRelatesTo), SOAP_RP_NAMESPACE, EmptyNodeToProps, 0,1),
										CParseElement(S_XWCS(xFixed),SOAP_RP_NAMESPACE, EmptyNodeToProps, 0,1),
										CParseElement(S_XWCS(xFwd),SOAP_RP_NAMESPACE, EmptyNodeToProps, 0,1),
										CParseElement(S_XWCS(xFault),SOAP_RP_NAMESPACE, EmptyNodeToProps, 0,1),
									};	

	NodeToProps(SmXpPath, ParseElements, TABLE_SIZE(ParseElements), pMessageProperties);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envmsmq.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envmsmq.cpp

Abstract:
    Implements serialization\deserialization of the MSMQ element to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <qmpkt.h>
#include <fn.h>
#include <xds.h>
#include <timeutl.h>
#include <mp.h>
#include "envmsmq.h"
#include "envcommon.h"
#include "mpp.h"
#include "envparser.h"
#include "proptopkt.h"

#include "envmsmq.tmh"

using namespace std;

class MsmqClassElement
{
public:
	explicit MsmqClassElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqClassElement&  MsmqClass)
	{
		wstr<<OpenTag(xClass)
			<<MsmqClass.m_pkt.GetClass()
			<<CloseTag(xClass);

		return wstr;
	}

private:		
	const CQmPacket& m_pkt;
};


class MsmqConnectorTypeElement
{
public:
	explicit MsmqConnectorTypeElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqConnectorTypeElement&  MsmqConnectorType)
	{
		const CQmPacket& pkt = MsmqConnectorType.m_pkt;

		if (!pkt.ConnectorTypeIsIncluded())
			return wstr;

		wstr<<OpenTag(xConnectorType)
			<<GuidElement(*pkt.GetConnectorType()) 
			<<CloseTag(xConnectorType);


		return wstr;
	}

private:		
	const CQmPacket& m_pkt;
};


class MsmqTraceElement
{
public:
	explicit MsmqTraceElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqTraceElement&  MsmqClass)
	{
		if ((MsmqClass.m_pkt.GetTrace() && MQMSG_SEND_ROUTE_TO_REPORT_QUEUE) == 0)
			return wstr;

		
		return wstr << EmptyElement(xTrace);
	}

private:		
	const CQmPacket& m_pkt;
};



class MsmqJournalElement
{
public:
	explicit MsmqJournalElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqJournalElement&  MsmqJournal)
	{
		if ((MsmqJournal.m_pkt.GetAuditingMode() & MQMSG_JOURNAL) == 0)
			return 	wstr;

		return wstr << EmptyElement(xJournal);
	}
private:		
	const CQmPacket& m_pkt;
};


class MsmqDeadLetterElement
{
public:
	explicit MsmqDeadLetterElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqDeadLetterElement&  MsmqDeadLetter)
	{
		if ((MsmqDeadLetter.m_pkt.GetAuditingMode() & MQMSG_DEADLETTER) == 0)
			return wstr;


		return wstr<<EmptyElement(xDeadLetter);
	}
private:		
	const CQmPacket& m_pkt;
};




class MsmqSourceQMGuidElement
{
public:
	explicit MsmqSourceQMGuidElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqSourceQMGuidElement& MsmqSourceQMGuid)
	{
		CQmPacket& pkt = const_cast<CQmPacket&>(MsmqSourceQMGuid.m_pkt); 

		wstr<<OpenTag(xSourceQmGuid)
			<<GuidElement(*pkt.GetSrcQMGuid())
			<<CloseTag(xSourceQmGuid);

		return wstr;
	}

private:		
	const CQmPacket& m_pkt;
};


	  

class MsmqResponseMqfElement
{
public:
	explicit MsmqResponseMqfElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqResponseMqfElement& MsmqResponseMqf)
	{
		const CQmPacket& pkt = MsmqResponseMqf.m_pkt;
		ULONG count = pkt.GetNumOfResponseMqfElements();
		if(count == 0)
			return wstr;

		AP<QUEUE_FORMAT> ResponseMqf = new QUEUE_FORMAT[count];
		bool fSuccess = pkt.GetResponseMqf(ResponseMqf.get(), count);
		ASSERT(fSuccess);
		DBG_USED(fSuccess);

		wstr<<OpenTag(xResponseMqf)
			<<XmlEncodeDecorator(CFnSerializeMqf(ResponseMqf.get(), count))
			<<CloseTag(xResponseMqf);

		return wstr;
	}

private:		
	const CQmPacket& m_pkt;
};


class MsmqAdminMqfElement
{
public:
	explicit MsmqAdminMqfElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqAdminMqfElement& MsmqAdminMqf)
	{
		const CQmPacket& pkt = MsmqAdminMqf.m_pkt;

		ULONG count = pkt.GetNumOfAdminMqfElements();
		if(count == 0)
			return wstr;

		AP<QUEUE_FORMAT> AdminMqf = new QUEUE_FORMAT[count];
		bool fSuccess = pkt.GetAdminMqf(AdminMqf.get(), count);
		ASSERT(fSuccess);
		DBG_USED(fSuccess);

		wstr<<OpenTag(xAdminMqf)
			<<XmlEncodeDecorator(CFnSerializeMqf(AdminMqf.get(), count))
			<<CloseTag(xAdminMqf);

		return wstr;
	}

private:		
	const CQmPacket& m_pkt;
};



class MsmqDestinationMqfElement
{
public:
	explicit MsmqDestinationMqfElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqDestinationMqfElement& MsmqDestinationMqf)
	{
		const CQmPacket& pkt = MsmqDestinationMqf.m_pkt;

		ULONG count = pkt.GetNumOfDestinationMqfElements();
		if(count == 0)
			return wstr;

		AP<QUEUE_FORMAT> DestinationMqf = new QUEUE_FORMAT[count];
		bool fSuccess = pkt.GetDestinationMqf(DestinationMqf.get(), count);
		ASSERT(fSuccess);
		DBG_USED(fSuccess);

		wstr<<OpenTag(xDestinationMqf)
			<<XmlEncodeDecorator(CFnSerializeMqf(DestinationMqf.get(), count))
			<<CloseTag(xDestinationMqf);


		return wstr;
	}

private:		
	const CQmPacket& m_pkt;
};



class MsmqCorrelationElement
{
public:
	explicit MsmqCorrelationElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqCorrelationElement&  MsmqCorrelation)
	{
		wstr <<OpenTag(xCorrelation)
			 <<MsmqCorrelationContent(MsmqCorrelation.m_pkt)
			 <<CloseTag(xCorrelation);

		return wstr;
	}

private:
	class MsmqCorrelationContent
	{
	public:
		explicit MsmqCorrelationContent(const CQmPacket& pkt):m_pkt(pkt){}
		friend wostream& operator<<(wostream& wstr, const MsmqCorrelationContent&  MsmqCorrelation)
		{
			DWORD temp;
			AP<WCHAR> pCorrelation = Octet2Base64W(MsmqCorrelation.m_pkt.GetCorrelation(), 
										PROPID_M_CORRELATIONID_SIZE, 
										&temp);

			return wstr<<pCorrelation.get();
		}
	private:
		const CQmPacket& m_pkt;
	};


private:
	const CQmPacket& m_pkt;
};



class MsmqSecurityElement
{
public:
	explicit MsmqSecurityElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqSecurityElement&  MsmqSecurity)
	{
		const CQmPacket& pkt = MsmqSecurity.m_pkt; 

		//
		// ISSUE-2001/11/28-ilanh
		// There is one case when the packet is mark as encrypted
		// When we send Ack packet for native msmq encrypted message.
		// MSMQ use the following hack in order to pass encrypted information of the original packet: 
		// 1) set ack packet encryption flag with BodySize = 0 ("False Encryption")
		// 2) The ack packet has the encryption algoritm of the original packet.
		//
		// Those value are used in the mmc for non http ack.
		//
		// This is a valid case: 
		// sending encrypted message (native msmq) and specifying admin queue as http.
		// This is not "real encrypted body" since BodySize = 0.
		//
		// Currently SRMP ignore this encryption information.
		//
		ASSERT(!pkt.IsEncrypted() || (pkt.GetBodySize() == 0));

		if (!pkt.IsSecurInc())
			return wstr;

		//
		// Get sender certificate size. If the message isn't authenticated there is no meaning 
		// to send the provider information
		//
		USHORT signatureSize;
		pkt.GetSignature(&signatureSize);

		if(signatureSize == 0)
			return wstr;

		BOOL fDefaultProvider;
		LPCWSTR providerName = NULL;
		DWORD providerType = 0;

		pkt.GetProvInfo(&fDefaultProvider, &providerName, &providerType);
		if (fDefaultProvider)
			return wstr;
		 

		wstr<<OpenTag(xProvider)
			<<ProviderTypeElement(providerType)
			<<ProviderNameElement(providerName)
			<<CloseTag(xProvider);

		return wstr;
	}


private:
	class ProviderTypeElement
	{
	public:
		ProviderTypeElement(DWORD Type):m_Type(Type){}
		friend wostream& operator<<(wostream& wstr, const ProviderTypeElement&  ProviderType)
		{
			wstr<<OpenTag(xType)
				<<ProviderType.m_Type 
				<<CloseTag(xType);

			return wstr;
		}
		
	private:
		DWORD m_Type;
	};


	class ProviderNameElement
	{
	public:
		ProviderNameElement(LPCWSTR Name):m_Name(Name){}
		friend wostream& operator<<(wostream& wstr, const ProviderNameElement&  ProviderName)
		{
			wstr<<OpenTag(xName)
				<<ProviderName.m_Name 
				<<CloseTag(xName);

			return wstr;
		}
		
	private:
		LPCWSTR m_Name;
	};


private:
	const CQmPacket& m_pkt;
};


class MsmqEodElement
{
public:
	explicit MsmqEodElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqEodElement&  MsmqEod)
	{
		const CQmPacket& pkt = MsmqEod.m_pkt;
   
		if (! pkt.IsOrdered())
			return wstr;

		wstr<<OpenTag(xEod)
			<<ConnectorElement(pkt)
			<<FirstElement(pkt)
			<<LastElement(pkt)
			<<CloseTag(xEod);

		return wstr;
	}


private:
	class ConnectorElement
	{
	public:
		ConnectorElement(const CQmPacket& pkt):m_pkt(pkt){}
		friend wostream& operator<<(wostream& wstr, const ConnectorElement&  Connector)
		{
			const GUID* pConnector = Connector.m_pkt.GetConnectorQM();
			if(pConnector == NULL)
				return wstr;

			wstr<<OpenTag(xConnectorId)
				<<GuidElement(*pConnector)
				<<CloseTag(xConnectorId);

			return wstr;
		}

	private:
		const CQmPacket& m_pkt;
	};


	class FirstElement
	{
	public:
		FirstElement(const CQmPacket& pkt):m_pkt(pkt){}
		friend wostream& operator<<(wostream& wstr, const FirstElement&  First)
		{
			if(!First.m_pkt.IsFirstInXact())
				return 	wstr;

			return wstr << EmptyElement(xFirst);
		}

	private:
		const CQmPacket& m_pkt;
	};


	class LastElement
	{
	public:
		LastElement(const CQmPacket& pkt):m_pkt(pkt){}
		friend wostream& operator<<(wostream& wstr, const LastElement&  Last)
		{
			if(!Last.m_pkt.IsLastInXact())
				return 	wstr;

			return wstr << EmptyElement(xLast);
		}

	private:
		const CQmPacket& m_pkt;
	};


private:		
	const CQmPacket& m_pkt;
};



class  MsmqHashAlgorithmElement
{
public:
	explicit MsmqHashAlgorithmElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqHashAlgorithmElement&  MsmqHashAlgorithm)
	{
		 wstr<<OpenTag(xHashAlgorithm)
			 <<MsmqHashAlgorithm.m_pkt.GetHashAlg() 
			 <<CloseTag(xHashAlgorithm);

		 return  wstr;
	}

private:		
	const CQmPacket& m_pkt;
};


class MsmqBodyTypeElement
{
public:
	explicit MsmqBodyTypeElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqBodyTypeElement&  MsmqBodyType)
	{
		 wstr<<OpenTag(xBodyType) 
			 <<MsmqBodyType.m_pkt.GetBodyType() 
			 <<CloseTag(xBodyType);

		 return wstr;
	}

private:		
	const CQmPacket& m_pkt;
};


class MsmqAppElement
{
public:
	explicit MsmqAppElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqAppElement&  MsmqApp)
	{
		wstr<<OpenTag(xApp)
			<<MsmqApp.m_pkt.GetApplicationTag()
			<<CloseTag(xApp);

		 return wstr;
	}

private:		
	const CQmPacket& m_pkt;
};


class MsmqPriorityElement
{
public:
	explicit MsmqPriorityElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqPriorityElement&  MsmqPriority)
	{
		wstr<<OpenTag(xPriority)
			<<MsmqPriority.m_pkt.GetPriority() 
			<<CloseTag(xPriority);

		return wstr;
	}

private:		
	const CQmPacket& m_pkt;
};


class MsmqAbsoluteTimeToQueueElement
{
public:
	explicit MsmqAbsoluteTimeToQueueElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqAbsoluteTimeToQueueElement&  TimeToQueue)
	{
		wstr<<OpenTag(xTTrq)
			<<MsmqAbsoluteTimeToQueueContent(TimeToQueue.m_pkt) 
			<<CloseTag(xTTrq);

		return wstr;
	}

private:
	class  MsmqAbsoluteTimeToQueueContent
	{
	public:
		explicit MsmqAbsoluteTimeToQueueContent(const CQmPacket& pkt):m_pkt(pkt){}
		friend wostream& operator<<(wostream& wstr, const MsmqAbsoluteTimeToQueueContent&  TimeToQueueContent)
		{
			DWORD  AbsoluteTimeToQueue = min(TimeToQueueContent.m_pkt.GetAbsoluteTimeToQueue(), LONG_MAX);
			return wstr<<CIso8601Time(AbsoluteTimeToQueue);
		}


	private:
	const CQmPacket& m_pkt;
	};


private:
	const CQmPacket& m_pkt;
};




std::wostream& operator<<(std::wostream& wstr, const MsmqElement& Msmq)
{
	const CQmPacket& pkt = 	Msmq.m_pkt;

	wstr<<OpenTag(xMsmq , L"xmlns=" L"\"" xMSMQNamespace L"\"")
		<<MsmqClassElement(pkt)
		<<MsmqPriorityElement(pkt)
		<<MsmqJournalElement(pkt)
		<<MsmqDeadLetterElement(pkt)
		<<MsmqCorrelationElement(pkt)
		<<MsmqTraceElement(pkt)
		<<MsmqConnectorTypeElement(pkt)
		<<MsmqAppElement(pkt)
		<<MsmqBodyTypeElement(pkt)
		<<MsmqHashAlgorithmElement(pkt)
		<<MsmqEodElement(pkt)
		<<MsmqSecurityElement(pkt)
		<<MsmqSourceQMGuidElement(pkt)
		<<MsmqDestinationMqfElement(pkt) 
		<<MsmqAdminMqfElement(pkt) 
		<<MsmqResponseMqfElement(pkt)
		<<MsmqAbsoluteTimeToQueueElement(pkt)
		<<CloseTag(xMsmq);

	return wstr;
}



static void MsmqClassToProps(XmlNode& node, CMessageProperties* pProps)
{
    if(node.m_values.empty())
    {
	    TrERROR(SRMP, "Illegal empty Class node"); 
	    throw bad_srmp();
    }

    xwcs_t Class =  node.m_values.front().m_value;
    if(Class.Length() == 0)
    {
	    TrERROR(SRMP, "Illegal empty Class value"); 
	    throw bad_srmp();
    }

    pProps->classValue = static_cast<USHORT>(_wtoi(Class.Buffer()));

    if (! MQCLASS_IS_VALID(pProps->classValue))
    {
	    TrERROR(SRMP, "Illegal Class value 0x%x", pProps->classValue); 
	    throw bad_srmp();
    }
}


static void MsmqPriorityToProps(XmlNode& node, CMessageProperties* pProp)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Priority node"); 
		throw bad_srmp();
	}

	xwcs_t Priority =  node.m_values.front().m_value;
	if(Priority.Length() == 0)
	{
		TrERROR(SRMP, "Illegal empty Priority value"); 
		throw bad_srmp();
	}

    pProp->priority = static_cast<UCHAR>(_wtoi(Priority.Buffer()));
    if (pProp->priority > MQ_MAX_PRIORITY)
    {
		TrERROR(SRMP, "Illegal Priority value %d", pProp->priority);
		throw bad_srmp();
	}
}


static void MsmqJournalToProps(XmlNode& , CMessageProperties* pProp)
{
	pProp->auditing |= MQMSG_JOURNAL;
}


static void MsmqDeadLetterToProps(XmlNode& , CMessageProperties* pProp)
{
	pProp->auditing  |= MQMSG_DEADLETTER;
}


static void MsmqCorrelationToProps(XmlNode& node, CMessageProperties* pProp)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Correlation node"); 
		throw bad_srmp();
	}

	xwcs_t Correlation =  node.m_values.front().m_value;
	if(Correlation.Length() == 0)
	{
		TrERROR(SRMP, "Illegal empty Correlation value"); 
		throw bad_srmp();
	}

    DWORD temp;
    pProp->pCorrelation.free();
    pProp->pCorrelation = Base642OctetW(Correlation.Buffer(), Correlation.Length(), &temp); 
    
    if(temp != PROPID_M_CORRELATIONID_SIZE)
    {
        TrERROR(SRMP, "Illegal correlation id size");
        throw bad_srmp();
    }
}


static void MsmqTraceToProps(XmlNode& , CMessageProperties* pProp)
{
	pProp->fTrace = true;
}


static void MsmqConnectorTypeToProps(XmlNode& node, CMessageProperties* pProp)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty ConnectorType node"); 
		throw bad_srmp();
	}

	xwcs_t ConnectorType =  node.m_values.front().m_value;

	if(ConnectorType.Length() == 0)
	{
		TrERROR(SRMP, "Illegal empty ConnectorType value"); 
		throw bad_srmp();
	}

    StringToGuid(ConnectorType , &pProp->connectorType);
}


static void MsmqAppToProps(XmlNode& node, CMessageProperties* pProp)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty App Spesific node"); 
		throw bad_srmp();
	}
	xwcs_t Appspesific =  node.m_values.front().m_value;

	if(Appspesific.Length() == 0)
	{
		TrERROR(SRMP, "Illegal empty App Spesific value"); 
		throw bad_srmp();
	}
    pProp->applicationTag = _wtoi(Appspesific.Buffer());
}


static void MsmqBodyTypeToProps(XmlNode& node, CMessageProperties* pProp)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Body Type node"); 
		throw bad_srmp();
	}

	xwcs_t Bodytype  =  node.m_values.front().m_value;

	if(Bodytype.Length() == 0)
	{
		TrERROR(SRMP, "Illegal empty Body Type value"); 
		throw bad_srmp();
	}

	pProp->bodyType = _wtoi(Bodytype.Buffer());
}



static void MsmqHashAlgorithmToProps(XmlNode& node, CMessageProperties* pProp)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Hash Algorith node"); 
		throw bad_srmp();
	}

	xwcs_t HashAlgorith  =  node.m_values.front().m_value;

	if(HashAlgorith.Length() == 0)
	{
		TrERROR(SRMP, "Illegal empty Hash Algorith value"); 
		throw bad_srmp();
	}

    pProp->hashAlgorithm = _wtoi(HashAlgorith.Buffer());
}


static void MsmqEodFirstToProps(XmlNode& , CMessageProperties* pProp)
{
	 pProp->fFirst = true;
}


static void MsmqEodLastToProps(XmlNode& , CMessageProperties* pProp)
{
	pProp->fLast = true;
}


static void MsmqConnectorIdToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Connector ID node"); 
		throw bad_srmp();
	}

	xwcs_t connectorId  =  node.m_values.front().m_value;

	if(connectorId.Length() == 0)
	{
		TrERROR(SRMP, "Illegal empty Connector ID value"); 
		throw bad_srmp();
	}
	StringToGuid(connectorId, &pProps->connectorId);
}



static void MsmqEodToProps(XmlNode& node, CMessageProperties* pProps)
{
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xFirst),MSMQ_NAMESPACE, MsmqEodFirstToProps, 0,1),
										CParseElement(S_XWCS(xLast),MSMQ_NAMESPACE, MsmqEodLastToProps,0 ,1),
										CParseElement(S_XWCS(xConnectorId),MSMQ_NAMESPACE, MsmqConnectorIdToProps,0 ,1)
									};

	NodeToProps(node, ParseElements, TABLE_SIZE(ParseElements), pProps);
}

	

static void MsmqSecurityProviderTypeToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Security Provider Type node"); 
		throw bad_srmp();
	}

	xwcs_t ProviderType = node.m_values.front().m_value;
	if(ProviderType.Length() == 0)
	{
		TrERROR(SRMP, "Illegal empty Security Provider Type value"); 
		throw bad_srmp();
	}

	pProps->providerType = _wtoi(ProviderType.Buffer());
}


static void MsmqSecurityProviderNameToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Security Provider Name node"); 
		throw bad_srmp();
	}

	xwcs_t ProviderName = node.m_values.front().m_value;
	if(ProviderName.Length() == 0)
	{
		TrERROR(SRMP, "Illegal empty Security Provider Name value"); 
		throw bad_srmp();
	}

	pProps->providerName = ProviderName;
}


static void MsmqSecurityProviderToProps(XmlNode& node, CMessageProperties* pProps)
{
	pProps->fDefaultProvider = false;
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xType),MSMQ_NAMESPACE, MsmqSecurityProviderTypeToProps,1 ,1),
										CParseElement(S_XWCS(xName),MSMQ_NAMESPACE, MsmqSecurityProviderNameToProps,1 ,1)
									};

	NodeToProps(node, ParseElements, TABLE_SIZE(ParseElements), pProps);
}


static void MsmqSourceQMGuidToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Source QM Guid node"); 
		throw bad_srmp();
	}

	xwcs_t SourceQMGuid= node.m_values.front().m_value;
	if(SourceQMGuid.Length() == 0)
	{
		TrERROR(SRMP, "Illegal empty Source QM Guid value"); 
		throw bad_srmp();
	}

    StringToGuid(SourceQMGuid, &pProps->SourceQmGuid);
}


static void MsmqDestinationMqfToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Destination mqf node"); 
		throw bad_srmp();
	}

	xwcs_t DestinationMqf = node.m_values.front().m_value;
	if(DestinationMqf.Length() == 0)
	{
		TrERROR(SRMP, "Illegal empty Destination mqf value"); 
		throw bad_srmp();
	}

	CXmlDecode XmlDecode;
	XmlDecode.Decode(DestinationMqf);

	pProps->destMqf.CreateFromMqf(XmlDecode.get());		
}


static void MsmqAdminMqfToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Admin mqf node"); 
		throw bad_srmp();
	}

	xwcs_t AdminMqf = node.m_values.front().m_value;
	if(AdminMqf.Length() == 0)
	{
		TrERROR(SRMP, "Illegal empty Admin mqf value"); 
		throw bad_srmp();
	}

	CXmlDecode XmlDecode;
	XmlDecode.Decode(AdminMqf);


	pProps->adminMqf.CreateFromMqf(XmlDecode.get());		
}


static void MsmqResponseMqfElementToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Response mqf node"); 
		throw bad_srmp();
	}
	xwcs_t ResponseMqf = node.m_values.front().m_value;
	if(ResponseMqf.Length() == 0)
	{
		TrERROR(SRMP, "Illegal empty Response mqf value"); 
		throw bad_srmp();
	}

	CXmlDecode XmlDecode;
	XmlDecode.Decode(ResponseMqf);


	pProps->responseMqf.CreateFromMqf(XmlDecode.get());		
}

void MsmqTTrqProps(XmlNode& node, CMessageProperties* pMessageProperties)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty TimeToReachQueue value"); 
		throw bad_srmp();
	}

	xwcs_t Trq = node.m_values.front().m_value;
	if(Trq.Length() == 0)
	{
		TrERROR(SRMP, "Illegal empty TimeToReachQueue value"); 
		throw bad_srmp();
	}

	SYSTEMTIME SysTime;
	UtlIso8601TimeToSystemTime(Trq, &SysTime);
	pMessageProperties->absoluteTimeToQueue = min( numeric_cast<DWORD>(UtlSystemTimeToCrtTime(SysTime)), LONG_MAX);
}


					 

void MsmqToProps(XmlNode& Msmq, CMessageProperties* pMessageProperties)
/*++

Routine Description:
    Parse SRMP MSMQ element into MSMQ properties.

Arguments:
	Msmq - MSMQ element in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.   

--*/
{
	pMessageProperties->fMSMQSectionIncluded = true;
	pMessageProperties->fDefaultProvider = true;


	 CParseElement ParseElements[] =	{
											CParseElement(S_XWCS(xClass), MSMQ_NAMESPACE, MsmqClassToProps, 1,1),
											CParseElement(S_XWCS(xPriority),MSMQ_NAMESPACE, MsmqPriorityToProps, 1,1),
											CParseElement(S_XWCS(xJournal), MSMQ_NAMESPACE, MsmqJournalToProps, 0,1),
											CParseElement(S_XWCS(xDeadLetter), MSMQ_NAMESPACE, MsmqDeadLetterToProps, 0,1),
											CParseElement(S_XWCS(xCorrelation), MSMQ_NAMESPACE, MsmqCorrelationToProps,0 ,1),
											CParseElement(S_XWCS(xTrace), MSMQ_NAMESPACE, MsmqTraceToProps,0 ,1),
											CParseElement(S_XWCS(xConnectorType),MSMQ_NAMESPACE,  MsmqConnectorTypeToProps, 0, 1),
											CParseElement(S_XWCS(xApp), MSMQ_NAMESPACE, MsmqAppToProps,0 ,1),
											CParseElement(S_XWCS(xBodyType), MSMQ_NAMESPACE, MsmqBodyTypeToProps, 1, 1),
											CParseElement(S_XWCS(xHashAlgorithm), MSMQ_NAMESPACE, MsmqHashAlgorithmToProps,0 ,1),
											CParseElement(S_XWCS(xEod), MSMQ_NAMESPACE,  MsmqEodToProps, 0, 1),
											CParseElement(S_XWCS(xProvider), MSMQ_NAMESPACE,  MsmqSecurityProviderToProps, 0,1),
											CParseElement(S_XWCS(xSourceQmGuid), MSMQ_NAMESPACE, MsmqSourceQMGuidToProps,1, 1),
											CParseElement(S_XWCS(xDestinationMqf), MSMQ_NAMESPACE,  MsmqDestinationMqfToProps, 0 ,1),
											CParseElement(S_XWCS(xAdminMqf), MSMQ_NAMESPACE, MsmqAdminMqfToProps, 0 ,1),
											CParseElement(S_XWCS(xResponseMqf),MSMQ_NAMESPACE,  MsmqResponseMqfElementToProps,0 ,1),
											CParseElement(S_XWCS(xTTrq), MSMQ_NAMESPACE, MsmqTTrqProps, 1 ,1),
										};	

	NodeToProps(Msmq, ParseElements, TABLE_SIZE(ParseElements), pMessageProperties);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envmsmq.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envmsmq.h

Abstract:
    Header for serialization\deserialization of the MSMQ element to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envmsmq_H_
#define _MSMQ_envmsmq_H_

class CQmPacket;
class XmlNode;
class CMessageProperties;
class MsmqElement
{
public:
	explicit MsmqElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend std::wostream& operator<<(std::wostream& wstr, const MsmqElement& Msmq);

private:		
	const CQmPacket& m_pkt;
};

void MsmqToProps(XmlNode& Node, CMessageProperties* pMessageProperties);





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envparser.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envparser.h

Abstract:
    Header for parsing logic of SRMP envelop.

	The parsing logic is to iterate over all xml elements  and
	for each one of the to look for the spesific parsing routing in  ParseElements
	array (The look up is done by element name). If the element is found - the appropriate
	parsing routine is called. If the element is not found , it means that it is not supported,
	in that case it is ignored unless it has "mustunderstand" attribute. In that case parsing
	is aborted and bad_srmp exception is thrown.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envparser_H_
#define _MSMQ_envparser_H_
#include <xstr.h>


class CMessageProperties;
class Envelop;
class XmlNode;

typedef void (*ParseFunc)(XmlNode& Envelop, CMessageProperties* pMessageProperties); 


struct	CParseElement
{
	CParseElement(
		const xwcs_t& ElementName, 
		int nsid,
		ParseFunc parseFunc,
		size_t MinOccurrence,
		size_t MaxOccurrence
		);
		

	bool operator==(const XmlNode& Node) const;

	xwcs_t	m_ElementName;
	int m_nsid;
	ParseFunc m_ParseFunc;
	size_t m_MinOccurrence;
	size_t m_MaxOccurrence;
	size_t m_ActualOccurrence;
};


void 
NodeToProps(
	XmlNode& Node, 
	CParseElement* ParseElements,
	size_t cbParseArraySize,
	CMessageProperties* pMessageProperties
	);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envparser.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envparser.cpp

Abstract:
    Implements the parsing logic of SRMP envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/
#include <libpch.h>
#include <xml.h>
#include <mp.h>
#include <envcommon.h>
#include "envparser.h"
#include "mpp.h"

#include "envparser.tmh"

static bool IsMustUnderstand(const XmlNode& Node)
{
	const xwcs_t* MustUnderstandValue = XmlGetAttributeValue(&Node, xmustUnderstandAttribute);
	return (MustUnderstandValue != NULL) && (*MustUnderstandValue == xmustUnderstandTrueValue);
}
			   

static void CheckNumberOfOccurrence(const CParseElement& ParseElement)
{
	if(ParseElement.m_ActualOccurrence > ParseElement.m_MaxOccurrence 
		|| ParseElement.m_ActualOccurrence  < ParseElement.m_MinOccurrence)
	{
        TrERROR(SRMP, "Illegal number of occurrence (%Iu) for element '%.*ls'", ParseElement.m_ActualOccurrence, LOG_XWCS(ParseElement.m_ElementName));       
        throw bad_srmp();
	}
}


void 
NodeToProps(
	XmlNode& Node, 
	CParseElement* ParseElements,
	size_t cbParseArraySize,
	CMessageProperties* pMessageProperties
	)
/*++

Routine Description:
    Parsing xml node and convert it to MSMQ properties.

Arguments:
	Envelop - envelop in SRMP reperesenation (xml).

	ParseElements - pointer to array of elements that are supported for this node.
					for each element ther is spesific parsing routine.

	cbParseArraySize - Number of elements in ParseElements.

	pMessageProperties - Received the parsed properties.

Returned Value:
	None.  
	
Note:
	The parsing logic is to iterate over all xml elements  and
	for each one of the to look for the spesific parsing routing in  ParseElements
	array (The look up is done by element name). If the element is found - the appropriate
	parsing routine is called. If the element is not found , it means that it is not supported,
	in that case it is ignored unless it has "mustunderstand" attribute. In that case parsing
	is aborted and bad_srmp exception is thrown.

--*/
{
	CParseElement* ParseElementsEnd = ParseElements +  cbParseArraySize;

	for(List<XmlNode>::iterator it = Node.m_nodes.begin(); it != Node.m_nodes.end(); ++it)
	{
		CParseElement* found =  std::find(
										ParseElements,
										ParseElementsEnd,
										*it
										);

		if(found !=  ParseElementsEnd)
		{
			found->m_ParseFunc(*it, pMessageProperties);
			++found->m_ActualOccurrence;
			CheckNumberOfOccurrence(*found);
			continue;
		}

		if(IsMustUnderstand(*it))
		{
            TrERROR(SRMP, "Cannot understand SRMP element %.*ls", LOG_XWCS(it->m_tag));       
            throw bad_srmp();
		}
	}
	
	//
	// check the correct number of Occurrence in each element
	//
	std::for_each(ParseElements,  ParseElementsEnd, CheckNumberOfOccurrence);
}



CParseElement::CParseElement(
		const xwcs_t& ElementName, 
		int nsid,
		ParseFunc parseFunc,
		size_t MinOccurrence,
		size_t MaxOccurrence
		):
		m_ElementName(ElementName),
		m_nsid(nsid),
		m_ParseFunc(parseFunc),
		m_MinOccurrence(MinOccurrence),
		m_MaxOccurrence(MaxOccurrence),
		m_ActualOccurrence(0)
{
}



bool CParseElement::operator==(const XmlNode& Node) const
{
	//
	// check that tags are identical
	//
	if(m_ElementName != Node.m_tag)
		return false;
		
	//
	// is m_nsid  has the unknown namespace id - dont check namespaces
	//
	if(m_nsid == UNKNOWN_NAMESPACE)
		return true;

	return m_nsid == Node.m_namespace.m_nsid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envprops.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envprops.h

Abstract:
    Header for serialization\deserialization of the properties element to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envprops_H_
#define _MSMQ_envprops_H_

class CQmPacket;
class XmlNode;
class CMessageProperties;
class PropertiesElement
{
public:
	explicit PropertiesElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend  std::wostream& operator<<(std::wostream& wstr, const PropertiesElement& Properties);
	
private:
const CQmPacket& m_pkt;
};


void PropertiesToProps(XmlNode& Node , CMessageProperties* pMessageProperties);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envprops.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envprops.cpp

Abstract:
    Implements serialization\deserialization of the properties element to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <qmpkt.h>
#include <timeutl.h>
#include <xml.h>
#include <mp.h>
#include "envprops.h"
#include "envcommon.h"
#include "mpp.h"
#include "envparser.h"
#include "proptopkt.h"

#include "envprops.tmh"

using namespace std;

class  AbsoluteTimeToLiveElement
{
public:
	explicit AbsoluteTimeToLiveElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend  wostream& operator<<(wostream& wstr, const AbsoluteTimeToLiveElement& TimeToLive)
	{
		wstr<<OpenTag(xExpiresAt)
			<<AbsoluteTimeToLiveContent(TimeToLive.m_pkt)
			<<CloseTag(xExpiresAt);

		return wstr;
 	}

private:
	class AbsoluteTimeToLiveContent
	{
	public:
		explicit AbsoluteTimeToLiveContent (const CQmPacket& pkt):m_pkt(pkt){}
		friend  wostream& operator<<(wostream& wstr, const AbsoluteTimeToLiveContent& TimeToLiveContetnt)
		{
			DWORD  AbsoluteTimeToLive = TimeToLiveContetnt.GetExpirationTime();
			return wstr<<CIso8601Time(AbsoluteTimeToLive);
		}
 	

	private:
		DWORD GetExpirationTime() const 
		{
			DWORD AbsoluteTimeToLive = m_pkt.GetAbsoluteTimeToLive();
			return 	min(AbsoluteTimeToLive, LONG_MAX);
		}

	
	private:
		const CQmPacket& m_pkt;

	};


private:
const CQmPacket& m_pkt;
};




class  SentAtElement
{
public:
	explicit SentAtElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend  wostream& operator<<(wostream& wstr, const SentAtElement&  SentAt)
	{
		 wstr<<OpenTag(xSentAt)
			 <<CIso8601Time(SentAt.m_pkt.GetSentTime())
			 <<CloseTag(xSentAt);

		 return wstr; 
	}

private:
const CQmPacket& m_pkt;
};


std::wostream& operator<<(std::wostream& wstr, const PropertiesElement& Properties)
{
		const CQmPacket& pkt = Properties.m_pkt;

		wstr<<OpenTag(xProperties, xSoapmustUnderstandTrue)
			<<AbsoluteTimeToLiveElement(pkt)
			<<SentAtElement(pkt)
			<<CloseTag(xProperties);
		
		return wstr;
}


static void ExpirationToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Expiration Time node"); 
		throw bad_srmp();
	}
	xwcs_t ExpiredAt = node.m_values.front().m_value;

   	SYSTEMTIME SysTime;
	UtlIso8601TimeToSystemTime(ExpiredAt, &SysTime);
	pProps->absoluteTimeToLive = min( numeric_cast<DWORD>(UtlSystemTimeToCrtTime(SysTime)), LONG_MAX);
}


static
DWORD
RelativeTimeToAbsoluteTime(
    DWORD RelativeTimeout
    )
{
  
    DWORD absoluteTimeout = MqSysTime() + RelativeTimeout;
    return (absoluteTimeout < RelativeTimeout) ?  INFINITE : absoluteTimeout;
}


static void DurationToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Duration Time node"); 
		throw bad_srmp();
	}
	xwcs_t Duration = node.m_values.front().m_value;
	DWORD relativeTimeToLive = numeric_cast<DWORD>(UtlIso8601TimeDuration(Duration));
	pProps->absoluteTimeToLive  = RelativeTimeToAbsoluteTime(relativeTimeToLive);
}



static void SentAtElementToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Sent Time node"); 
		throw bad_srmp();
	}
	xwcs_t SentTime = node.m_values.front().m_value;

    SYSTEMTIME SysTime;
    UtlIso8601TimeToSystemTime(SentTime, &SysTime);
	pProps->sentTime = numeric_cast<DWORD>(UtlSystemTimeToCrtTime(SysTime));
}


static void InReplyToToProps(XmlNode& , CMessageProperties* )
{
	//
	// Currently - this one is ignored
	//
}



void PropertiesToProps(XmlNode& Properties, CMessageProperties* pProps)
/*++

Routine Description:
    Parse SRMP endpoints element into MSMQ properties.

Arguments:
	Properties - Properties element in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.   

--*/
{
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xExpiresAt), SRMP_NAMESPACE, ExpirationToProps, 1 ,1),
										CParseElement(S_XWCS(xDuration), SRMP_NAMESPACE, DurationToProps, 0 ,1),
										CParseElement(S_XWCS(xSentAt), SRMP_NAMESPACE, SentAtElementToProps, 0 ,1),
										CParseElement(S_XWCS(xInReplyTo), SRMP_NAMESPACE, InReplyToToProps, 0 ,1)
									};	

	NodeToProps(Properties, ParseElements, TABLE_SIZE(ParseElements), pProps);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envsec.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envsec.h

Abstract:
    Header for serialization\deserialization of the signature  element to\from the  srmp envelop.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envsec_H_
#define _MSMQ_envsec_H_


class CQmPacket;
class XmlNode;
class CMessageProperties;
class SignatureElement
{
public:
	explicit SignatureElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend std::wostream& operator<<(std::wostream& wstr, const SignatureElement& Signature);
	
private:		
	const CQmPacket& m_pkt;
};


void SignatureToProps(XmlNode& Node, CMessageProperties* pMessageProperties);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envservice.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envelopheader.h

Abstract:
    Header for Serialization and Deserialization of srmp envelop service element

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envservice_H_
#define _MSMQ_envservice_H_

class CQmPacket;
class XmlNode;
class CMessageProperties;
class ServiceElement
{
public:
	explicit ServiceElement(const CQmPacket& pkt):m_pkt(pkt){}
	bool IsIncluded() const;
	friend std::wostream& operator<<(std::wostream& wstr, const ServiceElement&  Service);
	
private:
	const CQmPacket& m_pkt;
};

void ServiceToProps(XmlNode& Node, CMessageProperties* pMessageProperties);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envsec.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envsec.cpp

Abstract:
    Implements serialization and deserialization of the signature element of the  srmp envelop.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <qmpkt.h>
#include <xml.h>
#include <mp.h>
#include <proptopkt.h>
#include "mpp.h"
#include "envsec.h"
#include "envcommon.h"

#include "envsec.tmh"

using namespace std;

wostream& operator<<(wostream& wstr, const SignatureElement& Signature)
{
		USHORT signatureSize;
		const BYTE* pSignature = Signature.m_pkt.GetSignature(&signatureSize);
 		if (signatureSize == 0)
			return wstr;

		//
		// XMLDSIG is in utf8 format, convert it to unicode
		//
		wstring pSignatureW = UtlUtf8ToWcs(pSignature, signatureSize);

		wstr<<pSignatureW;
		return wstr;
}


void SignatureToProps(XmlNode& node, CMessageProperties* pProps)
{
	//
	// The signature on the received packet should be utf8 format.
	// the same format as the sending packet.
	//
	pProps->signature = UtlWcsToUtf8(node.m_element.Buffer(), node.m_element.Length());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envstream.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envstream.h

Abstract:
    Header for serialization\deserialization of the stream  element to\from the  srmp envelop.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_stream_H_
#define _MSMQ_stream_H_

class CQmPacket;
class XmlNode;
class CMessageProperties;
class StreamElement
{
public:
	explicit StreamElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend std::wostream& operator<<(std::wostream& wstr, const StreamElement& Stream);

private:		
	const CQmPacket& m_pkt;
};
void StreamToProps(XmlNode& Node, CMessageProperties* pMessageProperties);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envstream.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envstream.cpp

Abstract:
    Implements serialization\deserialization of the stream  element to\from the  srmp envelop.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <qmpkt.h>
#include <fn.h>
#include <privque.h>
#include <qal.h>
#include <proptopkt.h>
#include <mp.h>
#include <xml.h>
#include "envstream.h"
#include "envcommon.h"
#include "mpp.h"
#include "envparser.h"

#include "envstream.tmh"

using namespace std;

extern void GetDnsNameOfLocalMachine(WCHAR ** ppwcsDnsName);

class MachineNameToOrderQueue
{
public:
	explicit MachineNameToOrderQueue(
		const WCHAR* MachineName,
		bool fHttps
		):
		m_MachineName(MachineName),
		m_fHttps(fHttps)
		{
		}

	friend wostream operator<<(wostream& wstr, const MachineNameToOrderQueue&  mToOrderQueue)
	{
		const WCHAR* Protocol = mToOrderQueue.m_fHttps ? FN_DIRECT_HTTPS_TOKEN : FN_DIRECT_HTTP_TOKEN;

		wstr<<Protocol
		<<mToOrderQueue.m_MachineName
		<<L"/"
		<<FN_MSMQ_HTTP_NAMESPACE_TOKEN
		<<L"/"
		<<FN_PRIVATE_$_TOKEN
		<<L"/"
		<<ORDERING_QUEUE_NAME;

		return wstr;
	}

private:
	const WCHAR* m_MachineName;
	bool m_fHttps;
};



class OrderAckQueueContent
{
public:
		OrderAckQueueContent( const CQmPacket& pkt)
            :m_pkt(pkt)
        {}

        static wstring GetHttpDnsOrderQueue()
		{
			return GetDnsOrderQueue(false);
		}

		static wstring GetHttpsDnsOrderQueue()
		{
			return GetDnsOrderQueue(true);
		}

		static wstring GetHttpNetbiosOrderQueue()
		{
			return GetNetbiosOrderQueue(false);			
		}

		static wstring GetHttpsNetbiosOrderQueue()
		{
			return GetNetbiosOrderQueue(true);			
		}

private:
		static wstring GetDnsOrderQueue(bool fHttps)
		{
			AP<WCHAR> 	LocalDnsName;
			GetDnsNameOfLocalMachine(&LocalDnsName);
			if (LocalDnsName.get() == NULL)
			{
				return L"";
			}
			wostringstream 	DnsOrderQueue;
			DnsOrderQueue<<MachineNameToOrderQueue(LocalDnsName.get(), fHttps);
  			return 	DnsOrderQueue.str();
		}


		static wstring GetNetbiosOrderQueue(bool fHttps)
		{
			WCHAR LocalNetbiosName[MAX_COMPUTERNAME_LENGTH + 1];
			DWORD size = TABLE_SIZE(LocalNetbiosName);
			BOOL fSuccess = GetComputerName(LocalNetbiosName, &size);
			if(!fSuccess)
			{
				DWORD err = GetLastError();
				TrERROR(SRMP, "GetComputerName failed with error %d ",err);
				throw bad_win32_error(err);
			}

			wostringstream 	NetbiosOrderQueue;
			NetbiosOrderQueue<<MachineNameToOrderQueue(LocalNetbiosName, fHttps);
			return NetbiosOrderQueue.str();
		}



private:	
	friend wostream& operator<<(wostream& wstr, const OrderAckQueueContent& content)
	{
		QUEUE_FORMAT destQueueFormat;
		const_cast<CQmPacket&>(content.m_pkt).GetDestinationQueue(&destQueueFormat);

        AP<WCHAR> pLocalOrderQueueAlias;
		
        //
        // We need to check that we are working with http queue format, since
        // in local send case the format name may be not http. In this case we
        // need to use the default order queue.
        //
        if( FnIsDirectHttpFormatName(&destQueueFormat) &&
            QalGetMapping().GetStreamReceiptURL( destQueueFormat.DirectID(), &pLocalOrderQueueAlias))
		{
            ASSERT(NULL != pLocalOrderQueueAlias.get());
            wstr << pLocalOrderQueueAlias.get();
            return wstr;
        }

        //
        // No alias found - try to get the default receipt url
        //
        AP<WCHAR> pDefaultOrderQueueAlias;
        if( QalGetMapping().GetDefaultStreamReceiptURL(&pDefaultOrderQueueAlias) )
        {
            ASSERT(NULL != pDefaultOrderQueueAlias.get());
            wstr<<pDefaultOrderQueueAlias.get();
            return wstr;
        }

	    //
        // No default found - the order queue is the predefined one full dns http format
        // http://dnsname/msmq/private$/order_queue$
        //
		wstring HttpDnsOrderQueue = OrderAckQueueContent::GetHttpDnsOrderQueue();
		if (HttpDnsOrderQueue != L"")
		{
			return wstr<<HttpDnsOrderQueue;
		}
		return 	wstr<<OrderAckQueueContent::GetHttpNetbiosOrderQueue();
	}
private:
    const CQmPacket& m_pkt;
};



class StartStreamElement
{
public:	
	explicit StartStreamElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr,const StartStreamElement& StartStream)
	{
		if(StartStream.m_pkt.GetPrevSeqN() != 0)
			return wstr;

		wstr<<OpenTag(xStart)
			<<SendReceiptsToElement(StartStream.m_pkt)
			<<CloseTag(xStart);

		return wstr;
	}


private:
	//
	// Sender random data is appended to the order queue name. It is used to validate that
	// the future stream receipt is originated by the receiver.
	//
	class SecretSenderStreamIdContent
	{
	public:
		SecretSenderStreamIdContent(const CQmPacket& pkt):m_pkt(pkt){}
		friend wostream& operator<<(wostream& wstr,const SecretSenderStreamIdContent& SecretSenderStreamId)
		{
			if(!SecretSenderStreamId.m_pkt.IsSenderStreamIncluded())
				return wstr;


			wstr<<xSenderStreamSecretePrefix;

			const CSenderStream* pSenderStream = SecretSenderStreamId.m_pkt.GetSenderStream();
			ASSERT(pSenderStream != NULL);
			ASSERT(pSenderStream->size() != 0);
						
			//
			// Serialize the sender stream as unicode
			//
			for(ULONG i = 0 ; i < pSenderStream->size(); ++i)
			{
				WCHAR w = pSenderStream->data()[i];
				wstr.put(w);
			}
			return wstr;
		}

	private:
		const CQmPacket& m_pkt;
	};

	//
	// Order queue information
	//
	class SendReceiptsToElement
	{
	public:
		SendReceiptsToElement(const CQmPacket& pkt):m_pkt(pkt){}
		friend wostream& operator<<(wostream& wstr,const SendReceiptsToElement& SendReceiptsTo)
		{
			wstr<<OpenTag(xSendReceiptsTo)
				<<OrderAckQueueContent(SendReceiptsTo.m_pkt)
				<<SecretSenderStreamIdContent(SendReceiptsTo.m_pkt)
				<<CloseTag(xSendReceiptsTo);

			return 	wstr;
		}
	private:
		const CQmPacket& m_pkt;
	};



private:
	const CQmPacket& m_pkt;
};				


class StreamIdElement
{
public:
	StreamIdElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr,const StreamIdElement& StreamId)
	{
		const CQmPacket& pkt = StreamId.m_pkt;

		wstr<<OpenTag(xStreamId)
			<<StreamIdContent(pkt)
			<<CloseTag(xStreamId);


		return 	wstr;
	}

private:
	class  StreamIdContent
	{
	public:
		StreamIdContent(const CQmPacket& pkt):m_pkt(pkt){}
		friend wostream& operator<<(wostream& wstr, const StreamIdContent& StreamId)
		{
			const CQmPacket& pkt = StreamId.m_pkt;

			wstr<<xUriReferencePrefix
				<<GuidElement(*pkt.GetSrcQMGuid())
				<<xSlash
				<<Int64Value(pkt.GetSeqID());
			
			return 	wstr;
		}
	
	
	private:
		const CQmPacket& m_pkt;
	};

	
private:
	const CQmPacket& m_pkt;
};


class SeqNumberElement
{
public:
	SeqNumberElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr,const SeqNumberElement& SeqNumber)
	{
		const CQmPacket& pkt = SeqNumber.m_pkt;

  		wstr<<OpenTag(xCurrent)
			<<Int64Value(pkt.GetSeqN())
			<<CloseTag(xCurrent);

		return 	wstr;
	}

	
private:
	const CQmPacket& m_pkt;
};


class PrevSeqNumberElement
{
public:
	PrevSeqNumberElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr,const PrevSeqNumberElement& PrevSeqNumber)
	{
		const CQmPacket& pkt = PrevSeqNumber.m_pkt;

		wstr<<OpenTag(xPrevious)
			<<Int64Value(pkt.GetPrevSeqN())
			<<CloseTag(xPrevious);
  	
		return 	wstr;
	}

	
private:
	const CQmPacket& m_pkt;
};



std::wostream& operator<<(std::wostream& wstr, const StreamElement& Stream)
{
		CQmPacket& pkt = const_cast<CQmPacket&>(Stream.m_pkt);

		if ( !pkt.IsOrdered() )
			return wstr;
					
		wstr<<OpenTag(xStream, xSoapmustUnderstandTrue)
			<<StreamIdElement(pkt)
			<<SeqNumberElement(pkt)
			<<PrevSeqNumberElement(pkt)	
			<<StartStreamElement(pkt)
			<<CloseTag(xStream);

		return 	wstr;
}



static
void
ParseMSMQStreamId(
			const xwcs_t& streamid,
			CMessageProperties* pProp
			)
/*++

Routine Description:
    Parse stream id that is MSMQ stream id of the format qmguid\\seqid
	The qmguid will be use as the real stream id and seqid will also be extracted

Arguments:
    streamid - MSMQ stream id
	mProp - messages properties to fill.

Returned Value:
    None.

--*/
{
	bool fParsed = BreakMsmqStreamId(streamid, &pProp->EodStreamId, &pProp->EodSeqId);
	if((!fParsed) && (!pProp->fLocalSend))
	{
		TrERROR(SRMP, "The MSMQ stream id '%.*ls' is not of the format QMGUID\\SEQID", LOG_XWCS(streamid));
		throw bad_srmp();
	}
}	


static void StreamIdToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Stream id node");
		throw bad_srmp();
	}
	
	const xwcs_t StreamId = node.m_values.front().m_value;
    //
    // We must ensure that stream id is a proper string and do not contain
    // any embedded NULLs
    //
    AP<WCHAR> str = StreamId.ToStr();
    if( wcslen(str) != (size_t)StreamId.Length() )
    {
		TrERROR(SRMP, "Illegal Stream id");
		throw bad_srmp();
    }

	//
	// If we have MSMQ section so the stream id is of the format :
	// qmguid\\seqqenceid. We should treat the qm guid as the streamid
	// and also extract the seqid
	//
	if(pProps->fMSMQSectionIncluded)
	{
		ParseMSMQStreamId(StreamId, pProps);
	}
	else
	{
		pProps->EodStreamId = StreamId;
	}
}


static void SeqNumberToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Sequence Number node");
		throw bad_srmp();
	}
	const xwcs_t SecNumber = node.m_values.front().m_value;

	//
	// ISSUE-2000/10/23-gilsh - MSMQ has only 32 bit for seqNo.
	// According to srmp it can be 64 bit value.
	//
	pProps->EodSeqNo = _wtoi(SecNumber.Buffer());

	if ((0 == pProps->EodSeqNo) && (!pProps->fLocalSend))
	{
		TrERROR(SRMP, "Current sequence can not be 0");
		throw bad_srmp();
	}

}
	

static void PrevSeqNumberToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Prev Sequence Number node");
		throw bad_srmp();
	}

	const xwcs_t  SecPrevNumber = node.m_values.front().m_value;
	pProps->EodPrevSeqNo = _wtoi(SecPrevNumber.Buffer());
}


static void OrdeQueueAddressToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Order Queue node");
		throw bad_srmp();
	}

	const xwcs_t OrderQueue = node.m_values.front().m_value;

	//
    // We must ensure that Order Queue is a proper string and do not contain
    // any embedded NULLs
    //
    AP<WCHAR> str = OrderQueue.ToStr();
    if( wcslen(str) != (size_t)OrderQueue.Length() )
    {
		TrERROR(SRMP, "Illegal Order Queue with embedded NULLs");
		throw bad_srmp();
    }

	DirectQueueType qt;
	LPCWSTR end = 	OrderQueue.Buffer() + OrderQueue.Length();
	LPCWSTR url = FnParseDirectQueueType(OrderQueue.Buffer(), &qt);
	if ((NULL == url) || (url == end) || ((qt != dtHTTPS) && (qt != dtHTTP)))
	{
		TrERROR(SRMP, "Illegal Order Queue value: %.*ls",LOG_XWCS(OrderQueue));
		throw bad_srmp();
	}

    pProps->OrderQueue = OrderQueue;
}





static void StreamExpiresAtToProps(XmlNode&, CMessageProperties* )
{
	//
	// Currently - this one is ignored
	//
}



static void StartStreamToProps(XmlNode& node, CMessageProperties* pProps)
{
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xSendReceiptsTo),SRMP_NAMESPACE, OrdeQueueAddressToProps, 1,1),
										CParseElement(S_XWCS(xExpiresAt), SRMP_NAMESPACE, StreamExpiresAtToProps, 0,1),
	   								};	

	NodeToProps(node, ParseElements, TABLE_SIZE(ParseElements), pProps);
}





void StreamToProps(
	XmlNode&  Stream,
	CMessageProperties* pProps
	)
/*++

Routine Description:
    Parse SRMP Stream  element into MSMQ properties.

Arguments:
	Stream - Stream element in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.

--*/
{
	pProps->fEod = true;


	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xStreamId),SRMP_NAMESPACE, StreamIdToProps, 1,1),
										CParseElement(S_XWCS(xCurrent), SRMP_NAMESPACE, SeqNumberToProps,1 ,1),
										CParseElement(S_XWCS(xPrevious),SRMP_NAMESPACE,  PrevSeqNumberToProps, 0 ,1),
										CParseElement(S_XWCS(xEnd),SRMP_NAMESPACE,  EmptyNodeToProps, 0, 1),
										CParseElement(S_XWCS(xStart),SRMP_NAMESPACE, StartStreamToProps, 0, 1),
										CParseElement(S_XWCS(xStreamReceiptRequest), SRMP_NAMESPACE, EmptyNodeToProps, 0, 1)
										
									};	

	NodeToProps(Stream, ParseElements, TABLE_SIZE(ParseElements), pProps);

	//
	// if previus elemt was not supplied we manually put in the current - 1 so we will not allow gaps later
	//
	ASSERT (wcsncmp(ParseElements[2].m_ElementName.Buffer(), xPrevious, ParseElements[2].m_ElementName.Length()) == 0);
	if (0 == ParseElements[2].m_ActualOccurrence)
	{
		pProps->EodPrevSeqNo = pProps->EodSeqNo - 1;
	}

	if ((pProps->OrderQueue.Buffer() == NULL) && (1 == pProps->EodSeqNo))
	{
		TrERROR(SRMP, "First message in stream has to sendReceiptsTo tag");
		throw bad_srmp();
	}

	if (pProps->priority != 0)
	{
		TrERROR(SRMP, "XACT messages has to have priority 0");
		throw bad_srmp();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envstreamreceipt.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envstreamreceipt.h

Abstract:
    Header for serialization\deserialization of the stream receipt  element to\from the  srmp envelop.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_streamreceipt_H_
#define _MSMQ_streamreceipt_H_

class CQmPacket;
class XmlNode;
class CMessageProperties;
class  StreamReceiptElement
{
public:
	explicit StreamReceiptElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend std::wostream& operator<<(std::wostream& wstr, const StreamReceiptElement& StreamReceipt);
	
private:		
	const CQmPacket& m_pkt;
};

void StreamReceiptToProps(XmlNode& Node , CMessageProperties* pMessageProperties);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envservice.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envservice.cpp

Abstract:
    Implements serialization\deserialization of the signature  element to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <qmpkt.h>
#include <proptopkt.h>
#include "envservice.h"
#include "envcommon.h"
#include "mpp.h"
#include "envparser.h"
#include "envdelreceiptreq.h"
#include "envcomreceiptreq.h"

#include "envservice.tmh"

using namespace std;


class DurableElement
{
public:
	explicit DurableElement(const CQmPacket& pkt):m_pkt(pkt){}
	bool IsIncluded() const 
	{
		return	const_cast<CQmPacket&>(m_pkt).IsRecoverable() == TRUE;
	}

	friend  wostream& operator<<(wostream& wstr, const DurableElement& Durable)
	{
		if (!Durable.IsIncluded())
			return wstr;

		wstr<<EmptyElement(xDurable);
		return wstr;
	}


private:
const CQmPacket& m_pkt;
};




bool ServiceElement::IsIncluded() const
{
	return 	DurableElement(m_pkt).IsIncluded() || 
			DeliveryReceiptRequestElement(m_pkt).IsIncluded()||
			CommitmentReceiptRequestElement(m_pkt).IsIncluded();

}


wostream& operator<<(std::wostream& wstr, const ServiceElement&  Service)
{
		if(!Service.IsIncluded())
			return 	wstr;

		const CQmPacket& pkt = Service.m_pkt;
		
		wstr<<OpenTag(xServices, xSoapmustUnderstandTrue)
			<<DurableElement(pkt)
			<<DeliveryReceiptRequestElement(pkt)
			<<CommitmentReceiptRequestElement(pkt)
			<<CloseTag(xServices);


		return wstr;
}



static void DurableToProps(XmlNode& , CMessageProperties* pProps)
{
    pProps->delivery = MQMSG_DELIVERY_RECOVERABLE;
}



void ServiceToProps(XmlNode& Service , CMessageProperties* pMessageProperties)
/*++

Routine Description:
    Parse SRMP Service element into MSMQ properties.

Arguments:
	Service - Service element in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.   

--*/
{
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xDurable), SRMP_NAMESPACE, DurableToProps, 0 ,1),
										CParseElement(S_XWCS(xDeliveryReceiptRequest), SRMP_NAMESPACE,  DeliveryReceiptRequestToProps, 0 ,1),
										CParseElement(S_XWCS(xFilterDuplicates), SRMP_NAMESPACE,  EmptyNodeToProps, 0 ,1),
										CParseElement(S_XWCS(xCommitmentReceiptRequest), SRMP_NAMESPACE, CommitmentReceiptRequestToProps, 0 ,1)
									};	

	NodeToProps(Service, ParseElements, TABLE_SIZE(ParseElements), pMessageProperties);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envusrheader.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envbody.cpp

Abstract:
    Implementing  serialization of the user supplied header to the SRMP envelop


Author:
    Gil Shafriri(gilsh) 24-APRIL-01

--*/
#include <libpch.h>
#include <qmpkt.h>
#include "envcommon.h"
#include "envusrheader.h"

using namespace std;


std::wostream& operator<<(std::wostream& wstr, const UserHeaderElement& UserHeader)
{
	if(!UserHeader.m_pkt.IsSoapIncluded() )
		return wstr;

	const WCHAR* pUserHeader = UserHeader.m_pkt.GetPointerToSoapHeader();
	if(pUserHeader == NULL)
		return wstr;

	//
	// The soap header is always NULL terminated. See CSoapSection constructor.
	//
	ASSERT(UserHeader.m_pkt.GetSoapHeaderLengthInWCHARs() == wcslen(pUserHeader) +1);

	return wstr<<pUserHeader;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envusrheader.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envbody.h

Abstract:
    Header for serialization of the user supplied header to the SRMP envelop.
	

Author:
    Gil Shafriri(gilsh) 24-APRIL-01

--*/

#pragma once

#ifndef _MSMQ_envusrheader_H_
#define _MSMQ_envusrheader_H_

class CQmPacket;


class UserHeaderElement
{
public:
	explicit UserHeaderElement(const CQmPacket& pkt):m_pkt(pkt){}
   	friend std::wostream& operator<<(std::wostream& wstr, const UserHeaderElement&);

private:
	const CQmPacket& m_pkt;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\envstreamreceipt.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envstreamreceipt.cpp

Abstract:
    Implements serialization\deserialization of the stream receipt  element to\from the  srmp envelop.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <qmpkt.h>
#include <xml.h>
#include <proptopkt.h>
#include <mp.h>
#include "envstreamreceipt.h"
#include "envcommon.h"
#include "mpp.h"
#include "envparser.h"

#include "envstreamreceipt.tmh"

using namespace std;


class AckedStreamIdElement
{
public:
	AckedStreamIdElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const AckedStreamIdElement& AckedStreamId)
	{
		const CQmPacket& pkt = 	AckedStreamId.m_pkt;
		const WCHAR* pStreamid = reinterpret_cast<const WCHAR*>(pkt.GetPointerToEodAckStreamId()); 

		wstr<<OpenTag(xStreamId)
			<<pStreamid;
 		//
		// If the streamid was generated by MSMQ we should append to it the seqid
		//
		if(pkt.GetEodAckSeqId() != xNoneMSMQSeqId)
		{
			wstr<<xSlash<<Int64Value(pkt.GetEodAckSeqId());
		}

		wstr<<CloseTag(xStreamId);
		return wstr;
 	}


private:
	const CQmPacket& m_pkt;
};



class AckedStreamNumberElement
{
public:
	AckedStreamNumberElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const AckedStreamNumberElement& AckedStreamNumber)
	{
		wstr<<OpenTag(xlastOrdinal)
			<<Int64Value(AckedStreamNumber.m_pkt.GetEodAckSeqNum())
			<<CloseTag(xlastOrdinal);

		return wstr;
 	}

private:
	const CQmPacket& m_pkt;
};



wostream& operator<<(wostream& wstr, const StreamReceiptElement& StreamReceipt)
{
		const CQmPacket& pkt = 	StreamReceipt.m_pkt;
		
		if ( !pkt.IsEodAckIncluded() )
			return wstr;
			

		wstr<<OpenTag(xStreamReceipt)
			<<AckedStreamIdElement(pkt)		
			<<AckedStreamNumberElement(pkt)
	   		<<CloseTag(xStreamReceipt);

		return wstr;

}


static void AckedStreamIdToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Acked Stream id node"); 
		throw bad_srmp();
	}

	const xwcs_t AckedStreamid = node.m_values.front().m_value;
 
	//
	// The stream id was sent by MSMQ so it of the format xxx\\seqid
	// we should extract the seqid from it.
	//
	bool fParsed = BreakMsmqStreamId(AckedStreamid, &pProps->EodAckStreamId, &pProps->EodAckSeqId);
	if(!fParsed)
	{
		TrERROR(SRMP, "Wrong formatted  stream id '%.*ls' accepted in stream receipt element", LOG_XWCS(AckedStreamid));       
		throw bad_srmp();
	}
}


static void AckedStreamNumberToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(SRMP, "Illegal empty Acked stream sequence number node"); 
		throw bad_srmp();
	}

	const xwcs_t AckedSeqNumber = node.m_values.front().m_value;

	pProps->EodAckSeqNo = _wtoi64(AckedSeqNumber.Buffer());
	ASSERT(pProps->EodAckSeqNo  != 0);
}







void StreamReceiptToProps(
	 XmlNode& StreamReceipt, 
	CMessageProperties* pMessageProperties
	)
/*++

Routine Description:
    Parse SRMP Stream Receipt element into MSMQ properties.

Arguments:
	StreamReceipt - Stream Receipt element in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.   

--*/
{
	pMessageProperties->fStreamReceiptSectionIncluded = true;

	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xreceivedAt),SRMP_NAMESPACE, EmptyNodeToProps,0 ,1),
										CParseElement(S_XWCS(xStreamId),SRMP_NAMESPACE,  AckedStreamIdToProps,1 ,1),
										CParseElement(S_XWCS(xlastOrdinal),SRMP_NAMESPACE,  AckedStreamNumberToProps, 1, 1),
										CParseElement(S_XWCS(xId), SRMP_NAMESPACE, EmptyNodeToProps, 0, 1),
									};	

	NodeToProps(StreamReceipt, ParseElements, TABLE_SIZE(ParseElements), pMessageProperties);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\mpinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MpInit.cpp

Abstract:
    SRMP Serialization and Deserialization initialization

Author:
    Uri Habusha (urih) 28-May-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Mp.h"
#include "Mpp.h"

#include "MpInit.tmh"


VOID
MpInitialize(
    VOID
    )
/*++

Routine Description:
    Initializes SRMP Serialization and Deserialization library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the SRMP Serialization and Deserialization library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!MppIsInitialized());
    MppRegisterComponent();
    MppSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\mpdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MpDebug.cpp

Abstract:
    SRMP Serialization and Deserialization debugging

Author:
    Uri Habusha (urih) 28-May-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Mp.h"
#include "Mpp.h"

#include "mpdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate SRMP Serialization and Deserialization state
//
void MppAssertValid(void)
{
    //
    // MpInitalize() has *not* been called. You should initialize the
    // SRMP Serialization and Deserialization library before using any of its funcionality.
    //
    ASSERT(MppIsInitialized());

    //
    // TODO:Add more SRMP Serialization and Deserialization validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void MppSetInitialized(void)
{
    LONG fMpAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The SRMP Serialization and Deserialization library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fMpAlreadyInitialized);
}


BOOL MppIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
/*
const DebugEntry xDebugTable[] = {

    {
        "MpDumpState(queue path name)",
        "Dump SRMP Serialization and Deserialization State to debugger",
        DumpState
    ),

    //
    // TODO: Add SRMP Serialization and Deserialization debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void MppRegisterComponent(void)
{
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\proptopkt.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    proptopkt.h

Abstract:
    declare MessagePropToPacket function that converts message property structure to qm packet.

Author:
    Gil Shafriri (gilsh) 28-Nov-00

--*/

#pragma once

#ifndef _MSMQ_proptopkt_H_
#define _MSMQ_proptopkt_H_

#include <fn.h>
#include <qmpkt.h>
#include <xmlencode.h>
#include "mpp.h"
#include "attachments.h"
#include <utf8.h>
class CHttpReceivedBuffer;

class CMessageProperties 
{
public:
    CMessageProperties()
    {
        memset(this, 0, sizeof(CMessageProperties));
		destQmId = GUID_NULL;
        delivery = MQMSG_DELIVERY_EXPRESS;
        absoluteTimeToLive = INFINITE;
		absoluteTimeToQueue = INFINITE;
        acknowledgeType = DEFAULT_M_ACKNOWLEDGE;
        classValue = MQMSG_CLASS_NORMAL;
        priority = DEFAULT_M_PRIORITY;
        auditing = MQMSG_JOURNAL_NONE;
		EodSeqId = xNoneMSMQSeqId;
		fMSMQSectionIncluded = false;
		fStreamReceiptSectionIncluded = false;
        SmxpActionBuffer = new CXmlDecode();
	}

public:
    CFnQueueFormat destQueue;
    CFnQueueFormat adminQueue;
    CFnQueueFormat responseQueue;
	CFnQueueFormat destMulticastQueue;
	CFnMqf 	destMqf;
	CFnMqf 	adminMqf;
	CFnMqf 	responseMqf;
	GUID destQmId;

	QUEUE_FORMAT DebugQueue;

    OBJECTID messageId;

    DWORD absoluteTimeToLive;
	DWORD absoluteTimeToQueue;
    DWORD sentTime;
    

    UCHAR delivery;
    bool fTrace;
	bool fMSMQSectionIncluded;
	bool fStreamReceiptSectionIncluded;
	AP<utf8_char> SenderStream;

    UCHAR acknowledgeType;
    USHORT classValue;
    DWORD applicationTag;

    UCHAR auditing;
    UCHAR priority;
    GUID  connectorType;
	GUID  SourceQmGuid;

    bool fEod;
    
	xwcs_t EodStreamId;
	LONGLONG EodSeqId;
    DWORD EodSeqNo;
    DWORD EodPrevSeqNo;

	xwcs_t	 EodAckStreamId;
	LONGLONG EodAckSeqId;
	LONGLONG EodAckSeqNo;

    bool fFirst;
    bool fLast;
    GUID connectorId;
    xwcs_t OrderQueue;

	xwcs_t envelop;
	const CHttpReceivedBuffer* Rawdata;

    AP<BYTE> pCorrelation; 
    DWORD bodyType;

    P<CXmlDecode> SmxpActionBuffer;
    xwcs_t title;
    utf8_str signature;
	
    xbuf_t<const VOID> extension;
    CAttachment body;
    xbuf_t<const VOID> senderCert;
	P<VOID> pCleanSenderSid;

    xbuf_t<const VOID> senderSid;
	USHORT senderIdType;

    bool fDefaultProvider;
    xwcs_t providerName;
    DWORD providerType;
    DWORD hashAlgorithm;
	
	bool fLocalSend;
private:
	CMessageProperties(const CMessageProperties&);
	CMessageProperties& operator=(const CMessageProperties&);
}; 

class CACPacketPtrs; 
void MessagePropToPacket(const CMessageProperties&, CACPacketPtrs* pACPacketPtrs);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\httpmime.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    httpmime.h

Abstract:
    Header for parsing http request to it mime parts.


Author:
    Gil Shafriri(gilsh) 22-MARCH-01


--*/
#ifndef HTTP_MIME_H
#define HTTP_MIME_H
#include "attachments.h"


class CAttachmentsArray;


//-------------------------------------------------------------------
//
// class CHttpReceivedBuffer - holds http parts as received from the network
//
//-------------------------------------------------------------------
class  CHttpReceivedBuffer 
{
public:
		CHttpReceivedBuffer(
		const basic_xstr_t<BYTE>& Body, 
		const char* pHeader
		):
		m_Body(Body),
		m_pHeader(pHeader,strlen(pHeader))  
 		{
		}

public:
	const basic_xstr_t<BYTE> GetBody() const 
	{
		return m_Body;
	}
	
	const xstr_t GetHeader() const 
	{
		return m_pHeader;
	}

	const CAttachmentsArray& GetAttachments()const
	{
		return m_Attachments;
	}

	CAttachmentsArray& GetAttachments()
	{
		return m_Attachments;
	}


private:
	basic_xstr_t<BYTE> m_Body;
	xstr_t m_pHeader;
	CAttachmentsArray m_Attachments;
};


std::wstring 
ParseHttpMime(
	const char* pHttpHeader, 
	DWORD HttpBodySize, 
	const BYTE* pHttpBody, 
	CAttachmentsArray* pAttachments 
	);
  

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\proptopkt.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    proptopkt.cpp

Abstract:
    MessagePropToPacket implementation (proptopkt.h)

Author:
    Gil Shafriri(gilsh) 28-Nov-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <mp.h>
#include <singelton.h>
#include <cm.h>
#include <mqwin64a.h>
#include <mqsymbls.h>
#include <mqformat.h>
#include <acdef.h>
#include <_mqini.h>
#include <mp.h>

#include "proptopkt.h"
#include "httpmime.h"
#include "proptopkt.tmh"



#ifdef _DEBUG
DWORD DiffPtr(const void* end, const void* start)
{
	ptrdiff_t diff = (UCHAR*)end - (UCHAR*)start;
	return numeric_cast<DWORD>(diff);	
}
#endif

static DWORD CalculateBaseHeaderSectionSize()
{
	return  CBaseHeader::CalcSectionSize();
}


void*
BuildBaseHeaderSection(
	const CMessageProperties& mProp,
	void* const pSection,
	DWORD packetSize
	)
{
    #pragma PUSH_NEW
    #undef new


    CBaseHeader* pBase = new(pSection) CBaseHeader(packetSize);
    pBase->SetPriority(mProp.priority);
    pBase->SetTrace(mProp.fTrace);
	DWORD AbsoluteTimeToQueue = mProp.fMSMQSectionIncluded ? mProp.absoluteTimeToQueue : mProp.absoluteTimeToLive;
    pBase->SetAbsoluteTimeToQueue(AbsoluteTimeToQueue);

	void* pNextSection = pBase->GetNextSection();

	ASSERT(DiffPtr(pNextSection, pSection) == CalculateBaseHeaderSectionSize() );

	return pNextSection;

   	#pragma POP_NEW
}


static DWORD CalculateUserHeaderSectionSize(const CMessageProperties& mProp)
{
	ASSERT(mProp.destQueue.GetType() != QUEUE_FORMAT_TYPE_UNKNOWN);
    const QUEUE_FORMAT* pAdminQueue = (mProp.adminQueue.GetType() != QUEUE_FORMAT_TYPE_UNKNOWN) ? &mProp.adminQueue : NULL;
    const QUEUE_FORMAT* pResponseQueue = (mProp.responseQueue.GetType() != QUEUE_FORMAT_TYPE_UNKNOWN) ? &mProp.responseQueue : NULL;

    return CUserHeader::CalcSectionSize(
                        &mProp.SourceQmGuid,
                        &mProp.destQmId,
                        (mProp.connectorType != GUID_NULL) ? &mProp.connectorType: NULL,
                        &mProp.destQueue,
                        pAdminQueue,
                        pResponseQueue
                        );
	
}


void*
BuildUserHeaderSection(
	const CMessageProperties& mProp,
	void* const pSection,
	CUserHeader** ppUser
	)
{
	#pragma PUSH_NEW
    #undef new


	const QUEUE_FORMAT* pAdminQueue = (mProp.adminQueue.GetType() != QUEUE_FORMAT_TYPE_UNKNOWN) ? &mProp.adminQueue : NULL;
    const QUEUE_FORMAT* pResponseQueue = (mProp.responseQueue.GetType() != QUEUE_FORMAT_TYPE_UNKNOWN) ? &mProp.responseQueue : NULL;

    CUserHeader* pUser = new (pSection) CUserHeader(
                                            &mProp.SourceQmGuid,
                                            &mProp.destQmId,
                                            &mProp.destQueue,
                                            pAdminQueue,
                                            pResponseQueue,
                                            mProp.messageId.Uniquifier
                                            );

	*ppUser =  pUser;
    if (mProp.connectorType != GUID_NULL)
    {
        pUser->SetConnectorType(&mProp.connectorType);
    }

	
	DWORD TimeToLiveDelta = mProp.fMSMQSectionIncluded ? mProp.absoluteTimeToLive - mProp.absoluteTimeToQueue : 0;
    pUser->SetTimeToLiveDelta(TimeToLiveDelta);
    pUser->SetSentTime(mProp.sentTime);
    pUser->SetDelivery(mProp.delivery);
    pUser->SetAuditing(mProp.auditing);

	void* pNextSection = pUser->GetNextSection();
	ASSERT(DiffPtr(pNextSection, pSection) == CalculateUserHeaderSectionSize(mProp));

	return pNextSection;

	#pragma POP_NEW
}


static DWORD CalculateXactHeaderSectionSize(const CMessageProperties& mProp)
{
	DWORD packetSize = 0;
	if (mProp.fEod)
	{
		packetSize = CXactHeader::CalcSectionSize(
								(void*)&mProp.EodSeqId,
								mProp.connectorId == GUID_NULL ? NULL : &mProp.connectorId
								);
	}
	return packetSize;
}


void*  BuildXactHeaderSection(
			const CMessageProperties& mProp,
			void* const pSection,
			CUserHeader* pUser
			)
{
	#pragma PUSH_NEW
    #undef new

	void* pNextSection =   pSection;

	if (mProp.fEod)
	{
		pUser->IncludeXact(TRUE);

		const GUID* pConnector = ((mProp.connectorId == GUID_NULL) ? NULL : &mProp.connectorId);
		CXactHeader* pXact = new (pSection) CXactHeader(pConnector);
		pXact->SetCancelFollowUp(!(mProp.auditing & MQMSG_DEADLETTER));
		pXact->SetSeqID(mProp.EodSeqId);
		pXact->SetSeqN(mProp.EodSeqNo);
		pXact->SetPrevSeqN(mProp.EodPrevSeqNo);
		pXact->SetFirstInXact(mProp.fFirst);
		pXact->SetLastInXact(mProp.fLast);
		if (pConnector != NULL)
		{
			pXact->SetConnectorQM(pConnector);
		}

		pNextSection = pXact->GetNextSection();
	}

	ASSERT(DiffPtr(pNextSection, pSection) == CalculateXactHeaderSectionSize(mProp));
	return pNextSection;

	#pragma POP_NEW
}



static DWORD CalculateSecurityHeaderSectionSize(const CMessageProperties& mProp)
{
	DWORD packetSize = 0;

	if ((mProp.signature.size() != 0) || (mProp.senderCert.Length() != 0))
	{
		DWORD ProviderInfoSize = 0;
		if (!mProp.fDefaultProvider)
		{
			ProviderInfoSize = (mProp.providerName.Length() + 1) * sizeof(WCHAR) + sizeof(ULONG);
		}

		packetSize = CSecurityHeader::CalcSectionSize(
											static_cast<USHORT>(mProp.senderSid.Length()),
											0, // Encrypted Key Size
											static_cast<USHORT>(mProp.signature.size()),
											static_cast<USHORT>(mProp.senderCert.Length()),
											static_cast<USHORT>(ProviderInfoSize)
											);
	}
	return packetSize;
}


void*
BuildSecurityHeaderSection(
	const CMessageProperties& mProp,
	void* const	pSection,
	CUserHeader* pUser
	)
{
	#pragma PUSH_NEW
    #undef new
	
	void* pNextSection = pSection;

    if ((mProp.signature.size() != 0) || (mProp.senderCert.Length() != 0))
    {
        pUser->IncludeSecurity(TRUE);

        CSecurityHeader* pSec = new (pSection) CSecurityHeader();


        pSec->SetSenderIDType(mProp.senderIdType);

		if (mProp.senderSid.Length() != 0)
        {
            pSec->SetSenderID(
                    reinterpret_cast<const BYTE*>(mProp.senderSid.Buffer()),
                    static_cast<USHORT>(mProp.senderSid.Length())
                    );
        }

        if (mProp.signature.size() != 0)
        {
            pSec->SetSignature(
                    mProp.signature.data(),
                    static_cast<USHORT>(mProp.signature.size())
                    );
        }

        if (mProp.senderCert.Length() != 0)
        {
            pSec->SetSenderCert(
                    static_cast<const BYTE*>(mProp.senderCert.Buffer()),
                    mProp.senderCert.Length()
                    );
        }

        if ((mProp.signature.size() != 0) || (mProp.senderCert.Buffer() != NULL))
        {
            SP<WCHAR> pProvider;
            StackAllocSP(pProvider, (mProp.providerName.Length() + 1) * sizeof(WCHAR));

            mProp.providerName.CopyTo(pProvider.get());

            DWORD ProviderInfoSize = 0;
            if (!mProp.fDefaultProvider)
            {
                ProviderInfoSize = (mProp.providerName.Length() + 1) * sizeof(WCHAR) + sizeof(ULONG);
            }

            pSec->SetProvInfoEx(
                        static_cast<USHORT>(ProviderInfoSize),
                        mProp.fDefaultProvider,
                        pProvider.get(),
                        mProp.providerType
                        );
        }

        pNextSection = pSec->GetNextSection();
    }
	
	ASSERT(DiffPtr(pNextSection, pSection) == CalculateSecurityHeaderSectionSize(mProp));

	return pNextSection;

	#pragma POP_NEW
}


static DWORD CalculatePropertyHeaderSectionSize(const CMessageProperties& mProp)
{
	return  CPropertyHeader::CalcSectionSize(
							mProp.title.Length() != 0 ? mProp.title.Length()+1 : 0,
							mProp.extension.Length(),
							0
							);


}


void*  BuildPropertyHeaderSection(const CMessageProperties& mProp, void* const pSection)
{
	#pragma PUSH_NEW
    #undef new

    CPropertyHeader* pProp = new (pSection) CPropertyHeader;
	pProp->SetClass(mProp.classValue);
	if(mProp.pCorrelation.get() != NULL)
	{
		pProp->SetCorrelationID(mProp.pCorrelation.get());
	}

    pProp->SetAckType(mProp.acknowledgeType);
    pProp->SetApplicationTag(mProp.applicationTag);
    pProp->SetBodyType(mProp.bodyType);
    pProp->SetHashAlg(mProp.hashAlgorithm);

    if(mProp.title.Length() != 0)
    {
        //
        //  NOTE: Setting the title to the message MUST occure before setting the body
        //

        //
        // Title should include String terminator. Since serialization throw the
        // string terminator, the deserialization should add it before setting
        // the title;
        SP<WCHAR> pTitle;
        StackAllocSP(pTitle, (mProp.title.Length() + 1) * sizeof(WCHAR));
        mProp.title.CopyTo(pTitle.get());

        pProp->SetTitle(pTitle.get(), mProp.title.Length() + 1);
    }

    if (mProp.extension.Length() != 0)
    {
        //
        //  NOTE: Setting the Message Extension to property section MUST occure
        //        before setting the body and after setting the title
        //
        pProp->SetMsgExtension(
            static_cast<const BYTE*>(mProp.extension.Buffer()),
            mProp.extension.Length()
            );
    }


	void* pNextSection = pProp->GetNextSection();
	ASSERT(DiffPtr(pNextSection, pSection) == CalculatePropertyHeaderSectionSize(mProp));

	return 	pNextSection;

	#pragma POP_NEW
}


static DWORD CalculateMqfSectionSize(const CMessageProperties& mProp)
{
	DWORD packetSize = 0;
	if(mProp.destMqf.GetCount() != 0 || mProp.adminMqf.GetCount()  != 0  || mProp.responseMqf.GetCount()  !=0)
	{
		packetSize += CDebugSection::CalcSectionSize(&mProp.DebugQueue);
		packetSize += CBaseMqfHeader::CalcSectionSize(mProp.destMqf.GetQueueFormats(), mProp.destMqf.GetCount());
		packetSize += CBaseMqfHeader::CalcSectionSize(mProp.adminMqf.GetQueueFormats(), mProp.adminMqf.GetCount());
		packetSize += CBaseMqfHeader::CalcSectionSize(mProp.responseMqf.GetQueueFormats(), mProp.responseMqf.GetCount());
		packetSize += CMqfSignatureHeader::CalcSectionSize(0);
	}
	return packetSize;
}

void*
BuildMqfHeaderSection(
	const CMessageProperties& mProp,
	void* const pSection,
	CUserHeader* pUser,
	CBaseHeader* pBase
	)
{
	#pragma PUSH_NEW
    #undef new
	void* pNextSection = pSection;

  	if(mProp.destMqf.GetCount() != 0 || mProp.adminMqf.GetCount()  != 0  || mProp.responseMqf.GetCount()  !=0)
	{
        //
        // Build DUMMY Debug header
        //
        pBase->IncludeDebug(TRUE);
	    CDebugSection * pDebug = new (pSection) CDebugSection(&mProp.DebugQueue);
        pNextSection = pDebug->GetNextSection();

        //
        // Build Destination MQF header
        //
        pUser->IncludeMqf(true);

        const USHORT x_DESTINATION_MQF_HEADER_ID = 100;
        CBaseMqfHeader * pDestinationMqf = new (pNextSection) CBaseMqfHeader(
                                                              mProp.destMqf.GetQueueFormats(),
                                                              mProp.destMqf.GetCount(),
                                                              x_DESTINATION_MQF_HEADER_ID
                                                              );
        pNextSection = pDestinationMqf->GetNextSection();

        //
        // Build Admin MQF header
        //
        const USHORT x_ADMIN_MQF_HEADER_ID = 200;
        CBaseMqfHeader * pAdminMqf = new (pNextSection) CBaseMqfHeader(
                                                        mProp.adminMqf.GetQueueFormats(),
                                                        mProp.adminMqf.GetCount(),
                                                        x_ADMIN_MQF_HEADER_ID
                                                        );
        pNextSection = pAdminMqf->GetNextSection();

        //
        // Build Response MQF header
        //
        const USHORT x_RESPONSE_MQF_HEADER_ID = 300;
        CBaseMqfHeader * pResponseMqf = new (pNextSection) CBaseMqfHeader(
														   mProp.responseMqf.GetQueueFormats(),
														   mProp.responseMqf.GetCount(),
														   x_RESPONSE_MQF_HEADER_ID
														   );
        pNextSection = pResponseMqf->GetNextSection();

		//
		// Build MQF Signature header
		//
		// Capture user buffer and size and probe the buffer
		//
		const USHORT x_MQF_SIGNATURE_HEADER_ID = 350;
		CMqfSignatureHeader * pMqfSignature = new (pNextSection) CMqfSignatureHeader(
			                                                     x_MQF_SIGNATURE_HEADER_ID,
			                                                     0,
																 NULL
																 );
		pNextSection = pMqfSignature->GetNextSection();

	}

	ASSERT(DiffPtr(pNextSection, pSection) == CalculateMqfSectionSize(mProp));

	return 	pNextSection;

	#pragma POP_NEW
}


static DWORD CalculateSrmpEnvelopeHeaderSectionSize(const CMessageProperties& mProp)
{

	return CSrmpEnvelopeHeader::CalcSectionSize(mProp.envelop.Length());
}


void*
BuildSrmpEnvelopeHeaderSection(
	const CMessageProperties& mProp,
	void* const pSection,
	CUserHeader* pUser
	)
{
	#pragma PUSH_NEW
    #undef new

	pUser->IncludeSrmp(true);

	//
	// Envelop
	//
	const USHORT x_SRMP_ENVELOPE_ID = 400;
	CSrmpEnvelopeHeader* pSrmpEnvelopeHeader = new (pSection) CSrmpEnvelopeHeader(
	                                                          const_cast<WCHAR*>(mProp.envelop.Buffer()),
															  mProp.envelop.Length(),
															  x_SRMP_ENVELOPE_ID
															  );

	void* pNextSection  = pSrmpEnvelopeHeader->GetNextSection();

	ASSERT(DiffPtr(pNextSection, pSection) == CalculateSrmpEnvelopeHeaderSectionSize(mProp));

	return pNextSection;

	#pragma POP_NEW
}



static  DWORD  CalculateCompoundMessageHeaderSectionSize(const CMessageProperties& mProp)
{
	return  CCompoundMessageHeader::CalcSectionSize(
											mProp.Rawdata->GetHeader().Length(),
											mProp.Rawdata->GetBody().Length()
											);
}


void*
BuildCompoundMessageHeaderSection(
	const CMessageProperties& mProp,
	void* const pSection,
	CUserHeader* pUser
	)
{
	#pragma PUSH_NEW
    #undef new

	pUser->IncludeSrmp(true);

	DWORD MsgBodyOffset = mProp.body.m_offset;
	DWORD MsgBodySize =   mProp.body.m_data.Length();

	const USHORT x_COMPOUND_MESSAGE_ID = 500;
	CCompoundMessageHeader* pCompoundMessageHeader = new (pSection) CCompoundMessageHeader(
		                                                         (UCHAR*)mProp.Rawdata->GetHeader().Buffer(),
																 mProp.Rawdata->GetHeader().Length(),
																 (UCHAR*)mProp.Rawdata->GetBody().Buffer(),
																 mProp.Rawdata->GetBody().Length(),
																 MsgBodySize,
																 MsgBodyOffset,
																 x_COMPOUND_MESSAGE_ID
																 );

	void* pNextSection = pCompoundMessageHeader->GetNextSection();
		
	ASSERT(DiffPtr(pNextSection, pSection) == CalculateCompoundMessageHeaderSectionSize(mProp));

	return pNextSection;

	#pragma POP_NEW
}



static DWORD CalculateEodHeaderSectionSize(const CMessageProperties& mProp)
{
	DWORD packetSize = 0;
	if(mProp.EodStreamId.Length() != 0)
	{
		DWORD EodStreamIdLen = (mProp.EodStreamId.Length()+1 )*sizeof(WCHAR);
		DWORD OrderQueueLen = (DWORD)(mProp.OrderQueue.Length() ? (mProp.OrderQueue.Length()+1 )*sizeof(WCHAR) : 0);
		packetSize += CEodHeader::CalcSectionSize(EodStreamIdLen, OrderQueueLen);
	}
	return packetSize;
}


void*
BuildEodHeaderSection(
	const CMessageProperties& mProp,
	void* const pSection,
	CUserHeader* pUser
	)
{
	#pragma PUSH_NEW
    #undef new
	
	void* pNextSection = pSection;
	if(mProp.EodStreamId.Length() != NULL)
	{
		pUser->IncludeEod(true);
		const USHORT x_EOD_ID = 600;
		AP<WCHAR> pStreamid =  mProp.EodStreamId.ToStr();
		AP<WCHAR> pOrderQueue = mProp.OrderQueue.Length() ? mProp.OrderQueue.ToStr() : NULL;
		DWORD EodStreamIdLen = (mProp.EodStreamId.Length() + 1)*sizeof(WCHAR);
		DWORD OrderQueueLen = (DWORD)(pOrderQueue.get() ? (mProp.OrderQueue.Length() + 1)*sizeof(WCHAR) : 0);

		
	    CEodHeader* pEodHeader = new (pSection) CEodHeader(
												   x_EOD_ID,	
                                                   EodStreamIdLen,
												   (UCHAR*)pStreamid.get(),
												   OrderQueueLen,
												   (UCHAR*)pOrderQueue.get()
												   );												

		pNextSection = pEodHeader->GetNextSection();
	}

	ASSERT(DiffPtr(pNextSection, pSection) == CalculateEodHeaderSectionSize(mProp));

	return 	pNextSection;

	#pragma POP_NEW
}



static DWORD CalculateSenderStreamHeaderSectionSize(const CMessageProperties& mProp)
{
	DWORD packetSize = 0;
	if(mProp.SenderStream.get() != NULL)
	{
		packetSize = CSenderStreamHeader::CalcSectionSize();
	}
	return packetSize;
}



static DWORD CalculateEodAckHeaderSectionSize(const CMessageProperties& mProp)
{
	DWORD packetSize = 0;
	if(mProp.EodAckStreamId.Length() != 0)
	{
		DWORD EodAckStreamIdLen = (mProp.EodAckStreamId.Length() +1 )*sizeof(WCHAR);
		packetSize += CEodAckHeader::CalcSectionSize(EodAckStreamIdLen );
	}
	return packetSize;
}




void*
BuildSenderStreamHeaderSection(
	const CMessageProperties& mProp,
	void* const pSection,
	CUserHeader* pUser
	)
{
	#pragma PUSH_NEW
    #undef new

	void* pNextSection =  pSection;
	
	if(mProp.SenderStream.get() != NULL)
	{
		pUser->IncludeSenderStream(true);
		const USHORT x_SENDER_STREAM_SECDTION_ID = 1000;

		CSenderStream SenderStream(
			mProp.SenderStream.get(),
			strlen((char*)mProp.SenderStream.get())
			);

		CSenderStreamHeader* pSenderStreamHeader = new (pSection) CSenderStreamHeader(
														 SenderStream,
                                                         x_SENDER_STREAM_SECDTION_ID
                                                         );

		pNextSection = pSenderStreamHeader->GetNextSection();
	}

	ASSERT(DiffPtr(pNextSection, pSection) == CalculateSenderStreamHeaderSectionSize(mProp));


	return pNextSection;

	#pragma POP_NEW
}




void*
BuildEodAckHeaderSection(
	const CMessageProperties& mProp,
	void* const pSection,
	CUserHeader* pUser
	)
{
	#pragma PUSH_NEW
    #undef new

	void* pNextSection =  pSection;
	if(mProp.EodAckStreamId.Length() != 0)
	{
		pUser->IncludeEodAck(true);
		const USHORT x_EOD_ACK_ID = 700;
		AP<WCHAR> pStreamid =  mProp.EodAckStreamId.ToStr();
	    CEodAckHeader* pEodAckHeader = new (pSection) CEodAckHeader(
												   x_EOD_ACK_ID,	
                                                   const_cast<LONGLONG*>(&mProp.EodAckSeqId),
												   const_cast<LONGLONG*>(&mProp.EodAckSeqNo),
											       (mProp.EodAckStreamId.Length()+1)*sizeof(WCHAR),
												   (UCHAR*)pStreamid.get()
												   );

		pNextSection = pEodAckHeader->GetNextSection();
	}

	ASSERT(DiffPtr(pNextSection, pSection) == CalculateEodAckHeaderSectionSize(mProp));


	return pNextSection;

	#pragma POP_NEW
}

static
DWORD
CalculatePacketSize(
    const CMessageProperties& mProp
    )
{
	DWORD packetSize =0;
	packetSize +=  CalculateBaseHeaderSectionSize();
	packetSize +=  CalculateUserHeaderSectionSize(mProp);
	packetSize +=  CalculateXactHeaderSectionSize(mProp);
	packetSize +=  CalculateSecurityHeaderSectionSize(mProp);
	packetSize +=  CalculatePropertyHeaderSectionSize(mProp);
	packetSize +=  CalculateMqfSectionSize(mProp);
	packetSize +=  CalculateSrmpEnvelopeHeaderSectionSize(mProp);
	packetSize +=  CalculateCompoundMessageHeaderSectionSize(mProp);
	packetSize +=  CalculateEodHeaderSectionSize(mProp);
	packetSize +=  CalculateEodAckHeaderSectionSize(mProp);
	packetSize +=  CalculateSenderStreamHeaderSectionSize(mProp);


	return packetSize;
}




static
void
BuildPacket(
    CBaseHeader* pBase,
    DWORD packetSize,
    const CMessageProperties& mProp
    )
{
	void* pNextSection = pBase;

	pNextSection = BuildBaseHeaderSection(mProp, pNextSection, packetSize);
	CUserHeader* pUser;
	pNextSection = BuildUserHeaderSection(mProp, pNextSection, &pUser);
	pNextSection = BuildXactHeaderSection(mProp, pNextSection, pUser);
	pNextSection = BuildSecurityHeaderSection(mProp, pNextSection, pUser);
	pNextSection = BuildPropertyHeaderSection(mProp, pNextSection);
	pNextSection = BuildMqfHeaderSection(mProp, pNextSection, pUser, pBase);
	pNextSection = BuildSrmpEnvelopeHeaderSection(mProp, pNextSection, pUser);
	pNextSection = BuildCompoundMessageHeaderSection(mProp, pNextSection, pUser);
	pNextSection = BuildEodHeaderSection(mProp, pNextSection, pUser);
	pNextSection = BuildEodAckHeaderSection(mProp, pNextSection, pUser );
	pNextSection = BuildSenderStreamHeaderSection(mProp, pNextSection, pUser );


	ASSERT(DiffPtr(pNextSection, pBase) == packetSize);
}


static void CheckProps(const CMessageProperties& props)
{
	if(props.fMSMQSectionIncluded && props.absoluteTimeToQueue > props.absoluteTimeToLive)
	{
		TrERROR(SRMP, "Illegal Time time to reach queue, is grater then expiration time");
		throw bad_srmp();
	}
}




void
MessagePropToPacket(
	const CMessageProperties& messageProperty,
	CACPacketPtrs* pACPacketPtrs
	)
/*++

Routine Description:
    Create msmq packet from mesages properties.
	

Arguments:
    messageProperty - messages property.
	pACPacketPtrs - Receives the created packet.


Returned Value:
    None.
--*/
{
	CheckProps(messageProperty);

	
	//
    // Caculate MSMQ packet Size and check if exceed limit
    //
    DWORD pktSize = CalculatePacketSize(messageProperty);
	if(pktSize > CSingelton<CMessageSizeLimit>::get().Limit())
	{
		TrERROR(SRMP,"Packet size %d is too big to be stored in MSMQ storage", pktSize);
		throw bad_packet_size();
	}


    //
    // Aloocate memory for MSMQ packet
    //
    CACPacketPtrs pktPtrs;
    AppAllocatePacket(
             messageProperty.destQueue,
             messageProperty.delivery,
             pktSize,
             pktPtrs
             );

    //
    // Create MSMQ Packet
    //
    try
    {
        BuildPacket(pktPtrs.pPacket, pktSize, messageProperty);
    }
    catch (const exception&)
    {
        AppFreePacket(pktPtrs);
        throw;
    }

   	*pACPacketPtrs =   pktPtrs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\mpp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Mpp.h

Abstract:
    SRMP Serialization and Deserialization private functions.

Author:
    Uri Habusha (urih) 28-May-00

--*/

#pragma once

#ifndef _MSMQ_Mpp_H_
#define _MSMQ_Mpp_H_
#include <xstr.h>

const WCHAR xSlash[] =  L"\\";
#define UUIDREFERENCE_PREFIX     L"uuid:"
#define UUIDREFERENCE_SEPERATOR  L"@"
#define BOUNDARY_HYPHEN "--"

const WCHAR xUuidReferencePrefix[] = L"uuid:";
const DWORD xUuidReferencePrefixLen = STRLEN(xUuidReferencePrefix);
const WCHAR xUriReferencePrefix[] = L"uri:";

const WCHAR xUuidReferenceSeperator[] = L"@";
const WCHAR xUuidReferenceSeperatorChar = L'@';
const LONGLONG xNoneMSMQSeqId = _I64_MAX;




#ifdef _DEBUG

void MppAssertValid(void);
void MppSetInitialized(void);
BOOL MppIsInitialized(void);
void MppRegisterComponent(void);

#else // _DEBUG

#define MppAssertValid() ((void)0)
#define MppSetInitialized() ((void)0)
#define MppIsInitialized() TRUE
#define MppRegisterComponent() ((void)0)

#endif // _DEBUG





#endif // _MSMQ_Mpp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\serialize.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    convMsmq.cpp

Abstract:
    Converts MSMQ packet to SRMP packet

Author:
    Uri Habusha (urih) 25-May-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <mp.h>
#include <qmpkt.h>
#include "mpp.h"
#include "envcommon.h"
#include "envelop.h"

#include "serialize.tmh"

using namespace std;


R<CSrmpRequestBuffers>
MpSerialize(
    const CQmPacket& pkt,
	LPCWSTR targethost,
	LPCWSTR uri
	)
{
	MppAssertValid();
	ASSERT(targethost != NULL);
	ASSERT(uri != NULL);
	return new CSrmpRequestBuffers(pkt, targethost, uri);	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\httpmime.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    httpmime.cpp

Abstract:
     Imlementing  parsing http request to it's mime parts (httpmime.h)

Author:
    Gil Shafriri(gilsh) 22-MARCH-01

--*/
#include <libpch.h>
#include <xstr.h>
#include <mp.h>
#include <utf8.h>
#include "httpmime.h"
#include "attachments.h"
#include "mpp.h"

#include "httpmime.tmh"

using namespace std;

const char xContentType[] = "Content-Type:";
const char xContentLength[] = "Content-Length:";
const char xContentId[] = "Content-Id:";
const char xEndOfHttpHeaderRequest[] = "\r\n\r\n";
const char xMimeContentTypeValue[] = "multipart/related";
const char xEnvelopeContentTypeValue[] = "text/xml";


inline LPCSTR removeLeadingSpace(LPCSTR p, LPCSTR pEnd)
{
    for(; ((pEnd > p) && iswspace(*p)); ++p)
    {
        NULL;
    }

    return p;
}


inline LPCSTR removeTralingSpace(LPCSTR p, LPCSTR pEnd)
{
    for(; ((pEnd >= p) && iswspace(*pEnd)); --pEnd)
    {
        NULL;
    }

    return pEnd;
}


static
const BYTE*
ParseBoundaryLineDelimeter(
    const BYTE* pBoundary,
	const BYTE* pEnd,
    xstr_t boundary
    )
{
	

    //
    // The boundary delimiter line is then defined as a line
    // consisting entirely of two hyphen characters ("-", decimal value 45)
    // followed by the boundary parameter value from the Content-Type header
    // field, optional linear whitespace, and a terminating CRLF.
    //

    LPCSTR p = reinterpret_cast<LPCSTR>(pBoundary);
    //
    // Check exisiting of two hyphen characters
    //
    
    if((pBoundary + STRLEN(BOUNDARY_HYPHEN) >= pEnd) ||
       strncmp(p, BOUNDARY_HYPHEN, STRLEN(BOUNDARY_HYPHEN)) != 0)
	{	
		TrERROR(SRMP, "wrong mime format");
        throw bad_request();
	}

    p += STRLEN(BOUNDARY_HYPHEN);

    //
    // Check exisiting of boundary parameter value
    //
    if((p + boundary.Length() >= reinterpret_cast<const char*>(pEnd)) ||
    	strncmp(p, boundary.Buffer(), boundary.Length()) != 0)
	{
		TrERROR(SRMP, "no mime boundary found");
        throw bad_request();
	}
    p += boundary.Length();
    p = removeLeadingSpace(p, (char*)pEnd);

    return (BYTE*)(p);
}



static xstr_t FindHeaderField(LPCSTR p, DWORD length, LPCSTR fieldName)
{
	const char xFieldSeperator[] = "\r\n";


    //
    // HTTP header must terminate with '\r\n\r\n'. We already parse
    // the header and find it as a legal HTTP header.
    //
    ASSERT_BENIGN(length >= 4);

    LPCSTR pEnd = p + length;
    unsigned int fieldLen = strlen(fieldName);

    p = search (p, pEnd, fieldName, fieldName + fieldLen);	
    if((p == pEnd) || ((p + fieldLen) == pEnd))
    {
	TrERROR(SRMP, "could not find header field");
        throw bad_request();	
    }

    p += fieldLen;
    p = removeLeadingSpace(p, pEnd);

    LPCSTR pEndOfField = search (p, pEnd, xFieldSeperator, xFieldSeperator + STRLEN(xFieldSeperator));	
    if((pEndOfField == pEnd) || ((pEndOfField + STRLEN(xFieldSeperator)) == pEnd))
    {
	TrERROR(SRMP, "could not find field seperator");
        throw bad_request();	
    }

    pEndOfField = removeTralingSpace(p, pEndOfField);

    return xstr_t(p, (pEndOfField - p + 1));
}



static
const
char*
SearchForAttachmentEnd(
	const char* pAttachmentStart,
	const BYTE* pEndHttpBody,
	xstr_t boundary
	)
/*++

Routine Description:
    Return the end of multipart MIME attachment by looking
	for the boundary string
	

Arguments:
    pAttachmentStart - Attachment data start.
	pEndHttpBody - Http body end.


Returned Value:
    Pointer to end of the attachment.
--*/
{
	const char* pEnd = (char*)pEndHttpBody;
	
	const char* pFound = std::search(
		pAttachmentStart,
		pEnd,
		boundary.Buffer(),
		boundary.Buffer() + boundary.Length()
		);

	if(pFound == pEnd)
		return NULL;								

	pFound -= STRLEN(BOUNDARY_HYPHEN);

	if (pFound < pAttachmentStart)
		return NULL;
	
	if((pFound + STRLEN(BOUNDARY_HYPHEN) >= pEnd) ||
		strncmp(BOUNDARY_HYPHEN, pFound, STRLEN(BOUNDARY_HYPHEN)))
		return NULL;
																
	return 	pFound;
}



bool CheckBoundaryLocation(const char* pAttachmentStart,
					          const BYTE* pEndHttpBody,
					          const xstr_t& boundary,
                              DWORD contentLength)
{
    const char *pEnd = (char*)pEndHttpBody;
    const char *pAttachmentEnd = pAttachmentStart + contentLength;
    const char *pBoundaryStart = pAttachmentEnd + STRLEN(BOUNDARY_HYPHEN);
    
	
	if((pBoundaryStart  >= pEnd) ||
		strncmp(BOUNDARY_HYPHEN, pAttachmentEnd, STRLEN(BOUNDARY_HYPHEN)))
		return false;
  

    if((pBoundaryStart + boundary.Length() >= pEnd) ||
		strncmp(boundary.Buffer(), pBoundaryStart, boundary.Length()))
		return false;
										
	return true;
}


static DWORD FindEndOfHeader(LPCSTR p, DWORD length)
{
    LPCSTR pEnd = p + length;
    LPCSTR pEndOfHeader = search(
                            p,
                            pEnd,
                            xEndOfHttpHeaderRequest,
                            xEndOfHttpHeaderRequest + STRLEN(xEndOfHttpHeaderRequest)
                            );

    if((pEndOfHeader == pEnd) || ((pEndOfHeader + STRLEN(xEndOfHttpHeaderRequest)) == pEnd))
    {
		TrERROR(SRMP, "could not find end of header");
        throw bad_request();	
    }

    pEndOfHeader += STRLEN(xEndOfHttpHeaderRequest);
    return numeric_cast<DWORD>((pEndOfHeader - p));
}



static xstr_t FindBoundarySeperator(xstr_t contentType)
{
    LPCSTR p = contentType.Buffer();
    LPCSTR pEnd = p + contentType.Length();

    //
    // looking for boundary attribute
    //
	const char xBoundary[] = "boundary=";

    p = search (p, pEnd, xBoundary, xBoundary + STRLEN(xBoundary));	
    if((p == pEnd) || ((p + STRLEN(xBoundary)) == pEnd))
    {
		TrERROR(SRMP, "no seperator boundery found!!");
        throw bad_request();	
    }

    p += STRLEN(xBoundary);
    p = removeLeadingSpace(p, pEnd);

    //
    // mime attribute value can be enclosed by '"' or not
    //
    if (*p =='"')
        ++p;

    //
    // looking for end of boundary attribute. It can be '\r\n' or ';'
    //
    LPCSTR ptemp = strchr(p, ';');
    if ((ptemp != NULL) && (pEnd > ptemp))
    {
        pEnd = --ptemp;
    }

    pEnd = removeTralingSpace(p, pEnd);

    if (*pEnd =='"')
        --pEnd;

    return xstr_t(p, (pEnd - p + 1));
}



static
DWORD
GetAttachmentLengthByBoundarySearch(
					const char* pAttachmentStart,
					const BYTE* pEndHttpBody,
					const xstr_t& boundary
					)

/*++

Routine Description:
    Return the length of multipart MIME attachment by looking
	for the boundary string
	

Arguments:
    pAttachmentStart - Poniter to Attachment data start.
	pEndHttpBody - Poniter to Http body end.
	boundary - boundary string


Returned Value:
	Length of MIME attachment.
--*/
{
		const char* pAttachmentEnd = SearchForAttachmentEnd(
										pAttachmentStart,
										pEndHttpBody,
										boundary
										);

		if(pAttachmentEnd == NULL)
		{
			TrERROR(SRMP, "wrong mime format - could not find boundary");
			throw bad_request();			
		}
		ASSERT(pAttachmentEnd > pAttachmentStart);

		return numeric_cast<DWORD>(pAttachmentEnd - pAttachmentStart);							
}



static
DWORD
GetAttachmentLength(
	const char* pAttachmentHeader,
	DWORD AttachmentHeaderSize,
	const BYTE* pEndHttpBody,
	const xstr_t& boundary
	)
/*++

Routine Description:
    Return the length of multipart MIME.
	
	

Arguments:
    pAttachmentHeader - Poniter to Attachment header.
	AttachmentHeaderSize - Attachment header start.
	pEndHttpBody - Poniter to Http body end.
	boundary - Boundary string.


Returned Value:
	Length of MIME attachment.

Note:
	The function first tries to find the MIME attachment length by looking at the
	Conternt-Length header in the MIME header. This is MSMQ to MSMQ optimization.
	If Conternt-Length it looks for the boundary that should terminate the MIME
	attachment according to the MIME spec.

--*/
{
	xstr_t contentLength;
	DWORD len = 0;
	try
	{
		contentLength = FindHeaderField(
								pAttachmentHeader,
								AttachmentHeaderSize,
								xContentLength
								);

		len = atoi(contentLength.Buffer());

		ASSERT_BENIGN(GetAttachmentLengthByBoundarySearch(pAttachmentHeader + AttachmentHeaderSize, pEndHttpBody, boundary) == len);
        
        if (!CheckBoundaryLocation(pAttachmentHeader + AttachmentHeaderSize, pEndHttpBody, boundary, len))
        {
           TrERROR(SRMP, "wrong mime format -- could not find boundary");
           throw bad_request();	
        }
    }
	catch(exception&)
	{
		return GetAttachmentLengthByBoundarySearch(pAttachmentHeader + AttachmentHeaderSize, pEndHttpBody, boundary);
	}

    return len;
}



static
const BYTE*
GetSection(
    const BYTE* pSection,
    size_t sectionLength,
    CAttachmentsArray* pAttachments	,
	const BYTE* pHttpBody,
	const BYTE* pEndHttpBody,
	const xstr_t& boundary
    )
{
	
	ASSERT(pHttpBody <= pSection);


    const char* pHeader = reinterpret_cast<const char*>(pSection);

    //
    // Find the end of Envelope header
    //
    DWORD headerSize = FindEndOfHeader(pHeader, numeric_cast<DWORD>(sectionLength));

    //
    // Find Content-Id value;
    //
	CAttachment attachment;
    attachment.m_id = FindHeaderField(pHeader, headerSize, xContentId);


    //
    // Get section size
    //
	DWORD size  = GetAttachmentLength(pHeader, headerSize, pEndHttpBody, boundary);


	const BYTE* pNextSection = 	pSection + headerSize + size;
	//
	// check overflow
	//
	if(pNextSection >= pEndHttpBody)
	{
		TrERROR(SRMP, "Request over flow!");
		throw bad_request();	
	}

	const BYTE* pAttachmentData = pSection  + headerSize;
    attachment.m_data = xbuf_t<const VOID>((pAttachmentData), size);
	attachment.m_offset	= numeric_cast<DWORD>(pAttachmentData - pHttpBody);

	pAttachments->push_back(attachment);

    return pNextSection;
}



static
wstring
GetAttachments(
    const BYTE* pHttpBody,
    DWORD HttpBodySize,
    CAttachmentsArray* pAttachments,
    const xstr_t& boundary
    )
{
	const BYTE* p = pHttpBody;
    const BYTE* pEndHttpBody = p + HttpBodySize;
    const char* pAttachmentHeader = (char*)(p);

    //
    // Find the end of Envelope header
    //
    DWORD AttachmentHeaderSize = FindEndOfHeader(pAttachmentHeader, HttpBodySize);
	const BYTE* BoundaryEnd = ParseBoundaryLineDelimeter((BYTE*)pAttachmentHeader, pEndHttpBody, boundary);
	ASSERT((BYTE*)pAttachmentHeader + AttachmentHeaderSize > BoundaryEnd);
	size_t RemainAttachmentHeaderSize = AttachmentHeaderSize - (BoundaryEnd - (BYTE*)pAttachmentHeader);

	DWORD envelopeSize = GetAttachmentLength(
						(char*)BoundaryEnd,
						numeric_cast<DWORD>(RemainAttachmentHeaderSize),
						pEndHttpBody,
						boundary
						);

    //
	// check overflow
	//
	const BYTE* pStartEnv =  p + AttachmentHeaderSize;
	const BYTE* pEndEnv =  pStartEnv + envelopeSize;
	if(pEndEnv >= pEndHttpBody)
	{
		TrERROR(SRMP, "Request over flow!");
		throw bad_request();	
	}

    wstring envelope = UtlUtf8ToWcs(pStartEnv, envelopeSize);

    p = pEndEnv;

	//
	// Loop over the mime parts that are seperated by boundary seperator
	//
    for(;;)
    {
	
		//
        // After each section should appear Multipart boundary seperator
        //
        p = ParseBoundaryLineDelimeter(p, pEndHttpBody, boundary);
		if(p == pEndHttpBody)
			break;


		//
		// "--" at the end of the boundary is a mark  for the last mime part
		//
		bool fEnd =  UtlIsStartSec(
				(char*)p,
				(char*)pEndHttpBody,
				BOUNDARY_HYPHEN,
				BOUNDARY_HYPHEN + STRLEN(BOUNDARY_HYPHEN)
				);

		if(fEnd)
			break;

		ASSERT(pEndHttpBody > p);

        p = GetSection(
			p,
			(pEndHttpBody - p),
			pAttachments,
			pHttpBody,
			pEndHttpBody,
			boundary
			);

    }

    return envelope;
}


wstring
ParseHttpMime(
    const char* pHttpHeader,
    DWORD HttpBodySize,
    const BYTE* pHttpBody,
    CAttachmentsArray* pAttachments
    )
{
    //
    // Get Content-Type
    //
    xstr_t contentType = FindHeaderField(pHttpHeader, strlen(pHttpHeader), xContentType);

    if (contentType == xEnvelopeContentTypeValue)
    {
        //
        // Simple message. The message doesn't contain external reference
        //
       return  UtlUtf8ToWcs(pHttpBody, HttpBodySize);
    }

    if ((contentType.Length() >= STRLEN(xMimeContentTypeValue)) &&
        (_strnicmp(contentType.Buffer(), xMimeContentTypeValue,STRLEN(xMimeContentTypeValue)) == 0))
    {
        return GetAttachments(
			pHttpBody,
			HttpBodySize,
			pAttachments,
			FindBoundarySeperator(contentType));
    }

    TrERROR(SRMP, "Bad HTTP request. Unsupported Content-Type field");
    throw bad_request();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\msm\lib\msminit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmInit.cpp

Abstract:
    Multicast Session Manager initialization

Author:
    Shai Kariv (shaik) 05-Sep-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Msm.h"
#include "Msmp.h"

#include "msminit.tmh"

VOID
MsmInitialize(
    VOID
    )
/*++

Routine Description:
    Initializes Multicast Session Manager library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the Multicast Session Manager library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!MsmpIsInitialized());
    MsmpRegisterComponent();

    //
    // retrieve configuartion parameters from the registry
    //
    MsmpInitConfiguration();

    MsmpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\lib\srmpreqbuffer.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    srmpreqbuffer.cpp

Abstract:
    Implements CSrmpRequestBuffers (mp.h) that creates SRMP request buffer ready
	to send from msmq packet.

Author:
    Gil Shafriri(gilsh) 28-Nov-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <wininet.h>
#include <mp.h>
#include <singelton.h>
#include <mc.h>
#include <bufutl.h>
#include <utf8.h>
#include <qmpkt.h>
#include <fntoken.h>
#include <fn.h>
#include <cm.h>
#include <mpp.h>
#include "envelop.h"
#include "attachments.h"

#include "srmpreqbuffer.tmh"


#define BOUNDARY_VALUE "MSMQ - SOAP boundary, %d"
const char xEnvelopeContentType[] = "text/xml";
const char xApplicationContentType[] = "application/octet-stream";
const char xMultipartContentType[] = "multipart/related";
const char xHttpHeaderTerminater[] = "\r\n\r\n";


bool CHttpDeliveryVesrion::IsHttp10Delivery() const
{
	return m_Http10Delivery != 0;
}



CHttpDeliveryVesrion::CHttpDeliveryVesrion()
{
		CmQueryValue(
				RegEntry(NULL, L"Http10Delivery", 0),
				&m_Http10Delivery
				);	

}


static const char* GetHttpVersionStr()
{
	if(CSingelton<CHttpDeliveryVesrion>::get().IsHttp10Delivery())
	{
		return "HTTP/1.0";
	}
	return "HTTP/1.1";
}



static const xstr_t FindHttpHeader(const char* pStartHeader,DWORD size)
{
	const char* pEndHeader = std::search(
								 pStartHeader,
								 pStartHeader + size,
								 xHttpHeaderTerminater,
								 xHttpHeaderTerminater + STRLEN(xHttpHeaderTerminater)
								 );

   ASSERT(pEndHeader !=   pStartHeader + size);
   pEndHeader +=   STRLEN(xHttpHeaderTerminater);
   return xstr_t(pStartHeader, pEndHeader - pStartHeader);
}



static bool FilterHeaderField(const xstr_t& HeaderField)
/*++

Routine Description:
    return true if http header field needs to be filtered out from the new http header.

Arguments:


Returned Value:
   true if header field should be filtered out.

--*/
{
		static const char* HttpHeadersToFilter[] = {"Host:"};
		for(int i = 0; i< TABLE_SIZE(HttpHeadersToFilter); ++i)
		{
		   	bool fFound = UtlIsStartSec(
									HeaderField.Buffer(),
				                    HeaderField.Buffer() + HeaderField.Length(),
									HttpHeadersToFilter[i],
									HttpHeadersToFilter[i] + strlen(HttpHeadersToFilter[i]),
									UtlCharNocaseCmp<char>()
									);

		    if(fFound)
				return true;

		}
		return false;
}


static
void
EscapeAppend(
	CPreAllocatedResizeBuffer<utf8_char>& ResultBuffer,
	const utf8_char* uri,
	size_t cbUri
	)

/*++

Routine Description:
    Convert the given utf-8 array of bytes to url encoding so IIS
	could handle it. Reserved on not allowed  caracters needs to be escape by prefixing them with % follow
	by their caracter code.

Arguments:
	UriBuffer - buffer to append escaping result to.
	uri - utf8 bytes to escape if needed.
    cbUri - length in bytes of the buffer utf8 points to.


Returned Value:
   None

Note:
Currently only the spaces treated as special caracters.

--*/

{
	const char hex[] = "0123456789ABCDEF";

    for(size_t i =0 ; i<cbUri; ++i)
    {
		if(uri[i] == ' ' || (uri[i] & 0x80) || !isalnum(uri[i]))
        {
            ResultBuffer.append(utf8_char('%'));
            ResultBuffer.append(utf8_char(hex[uri[i]>>4]));
            ResultBuffer.append(utf8_char(hex[uri[i] & 0x0F]));
			continue;
        }
	
        ResultBuffer.append(utf8_char(uri[i]));
    }
	
}



/*++

Routine Description:
    Convert the given unicode uri to utf-8 format escaping caracter if needed so IIS
	could handle it. Reserved and illegal caracters escaped by prefixing them with % follow
	by their caracter code.

Arguments:
	EscapeUriBuffer - buffer to append conversion result to.
	uri - Uri to adjust

Returned Value:
   None

Note:
Currently only the spaces treated as special caracters.

--*/
static void EncodeUri(CPreAllocatedResizeBuffer<utf8_char>& UriBuffer, LPCWSTR uri)
{
	//
	// We should find the start of the local path because we don't translate
	// special caracters befor it.
	//
	LPCWSTR pPath = FnFindResourcePath(uri);
	ASSERT(pPath != NULL);
	ASSERT(pPath >=  uri);
 	
	for(bool fAfterHostPart = false; *uri != L'\0'; ++uri)
	{
		utf8_char utf8[4];
		size_t len = UtlWcToUtf8(*uri, utf8, TABLE_SIZE(utf8));
		ASSERT (len <= TABLE_SIZE(utf8));

		
		//
		// We dont escape L'/' because it has special meaning of sperating the url parts
		//
		if(*uri == L'/' && uri >= pPath )
		{
			fAfterHostPart = true;
			UriBuffer.append(utf8 ,len);
			continue;
		}
		
	
		//
		// We don't escape anything before the host name ends
		//
		if(!fAfterHostPart)
		{
			UriBuffer.append(utf8 ,len);
			continue;
		}

		
		//
		// On all other cases - we escape the utf8 caracters if needed.
		//
		EscapeAppend(UriBuffer, utf8, len);
			
	}

	UriBuffer.append('\0');
}


WCHAR* DecodeURI(LPCWSTR szURI)
{
    DWORD  dwLen = wcslen(szURI);
    if( !dwLen )
        throw bad_win32_error( ERROR_INTERNET_INVALID_URL );

    AP<WCHAR> sDecodedURI = new WCHAR[++dwLen]; // increase the length for NULL termination
	DWORD     dwGLE   = NO_ERROR;
    BOOL      bResult = TRUE;

    bResult = InternetCanonicalizeUrl(szURI, sDecodedURI, &dwLen, ICU_DECODE | ICU_NO_ENCODE );

    if( !bResult && ( dwGLE = GetLastError()) == ERROR_INSUFFICIENT_BUFFER)
    {
        sDecodedURI.free();
        sDecodedURI = new WCHAR[dwLen];

        bResult = InternetCanonicalizeUrl(szURI, sDecodedURI, &dwLen, ICU_DECODE | ICU_NO_ENCODE );
        dwGLE   = GetLastError();
    }

    if( !bResult )
        throw bad_win32_error(dwGLE);

    return sDecodedURI.detach();
}

WCHAR* DecodeURI(const xwcs_t& sURI )
{
    AP<WCHAR> sbuf = sURI.ToStr();
    return DecodeURI(sbuf);
}


CSrmpRequestBuffers::CSrmpRequestBuffers(
							const  CQmPacket& pkt,
							LPCWSTR host,
							LPCWSTR uri
							):
							m_pkt(pkt),
							m_HttpRequestData(512),
							m_targethost(UtlWcsToUtf8(host))
							

{

   EncodeUri(*m_uri.get(), uri);

	//
	// If we have to forward existing messages(SFD) we have to do diferenet logic
	// then creating new SRMP  messages
	//
	if(pkt.IsSrmpIncluded())
	{
		SFDSerializeMessage();
		return;
	}

	//
	// create new SRMP message - because we are the source machine
	//
    SourceSerializeMessage();
}


/*++
Routine Description:
    return the number of winsock buffer available for send


Arguments:
None

Returned Value:
The number of winsock buffer available for send

--*/
size_t CSrmpRequestBuffers::GetNumberOfBuffers() const
{
	return m_buffers.size();
}


/*++
Routine Description:
    Return pointer to array of send buffers

Arguments:
None

Returned Value:
Pointer to array of send buffers
--*/
const WSABUF* CSrmpRequestBuffers::GetSendBuffers() const
{
	return m_buffers.begin();
}


std::wstring CSrmpRequestBuffers::GetEnvelop() const
{
	return UtlUtf8ToWcs(m_envelope);
}


/*++
Routine Description:
    Return the total data in bytes to send over the network.

Arguments:
None

Returned Value:
Total data in bytes to send over the network.
--*/
size_t CSrmpRequestBuffers::GetSendDataLength() const
{
	size_t sum = 0;
	for(std::vector<WSABUF>::const_iterator it = m_buffers.begin(); it != m_buffers.end();++it)
	{
		sum += it->len;		
	}
	return sum;
}


/*++
Routine Description:
    Return pointer to serialized network data. This function will be used
	by local http send that needs to save on the packet the "Compound" message property.

Arguments:
None

Returned Value:
Pointer to serialized network data.

Note:
The caller is responsible to call delete[] on the returned pointer.
--*/
BYTE*  CSrmpRequestBuffers::SerializeSendData() const
{
	size_t SendDataLength =  GetSendDataLength();
	AP<BYTE>  SendData = new BYTE[SendDataLength];
	BYTE* ptr = SendData.get();
	for(std::vector<WSABUF>::const_iterator it = m_buffers.begin(); it != m_buffers.end();++it)
	{
		memcpy(ptr, it->buf, it->len);
		ptr += it->len;
	}
	ASSERT(numeric_cast<size_t>((ptr -  SendData.get())) == SendDataLength);

	return 	SendData.detach();
}


const char* CSrmpRequestBuffers::GetHttpHeader() const
/*++
Routine Description:
    Return pointer http header from the send buffers

Arguments:
None

Returned Value:
	pointer http header from the send buffers


Note:
The pointer is owned by  CSrmpRequestBuffers object - caller should not free it
--*/
{
	std::vector<WSABUF>::const_iterator it = m_buffers.begin();
	ASSERT(it !=   m_buffers.end());
	return it->buf;
}



size_t CSrmpRequestBuffers::GetHttpBodyLength() const
{
	return GetSendDataLength() -   GetHttpHeaderLength();
}


size_t CSrmpRequestBuffers::GetHttpHeaderLength() const
{
	std::vector<WSABUF>::const_iterator it = m_buffers.begin();
	ASSERT(it !=   m_buffers.end());
	return it->len;
}


BYTE*  CSrmpRequestBuffers::SerializeHttpBody() const
/*++
Routine Description:
    Return pointer to serialized http body data.
	
	
Arguments:
None

Returned Value:
pointer to serialized http body data.


Note:
The caller is responsible to call delete[] on the returned pointer.
--*/

{
	size_t BodyLength =  GetHttpBodyLength();
	AP<BYTE>  HttpBody = new BYTE[BodyLength + (2 * sizeof(BYTE))];
	BYTE* ptr = HttpBody.get();
	std::vector<WSABUF>::const_iterator it = m_buffers.begin();
	ASSERT(it != m_buffers.end());

	//
	// We have to skip the http header in order to get to the http body
	//
	it++;

	//
	// Serialize http body blocks
	//
	for(;it != m_buffers.end();++it)
	{
		memcpy(ptr, it->buf, it->len);
		ptr += it->len;
	}
	ASSERT(numeric_cast<size_t>((ptr -  HttpBody.get())) == BodyLength);

	//
	// Pad with two null termination for unicode parsing functions that ovperates on the body
	// for example swscanf.
	//
    HttpBody[BodyLength] = '\0';
    HttpBody[BodyLength + 1] = '\0';

	return 	HttpBody.detach();
}




void CSrmpRequestBuffers::CreateHttpRequestHeaders(const CAttachmentsArray& attachments)
{
	if (attachments.size() != 0)
    {
        //
        // Message refering to external payload. Create MIME header
        //
        CreateMultipartHeaders(attachments);
		return;
    }

    //
    // Simple message, that doesn't contains external reference
    //
    CreateSimpleHttpHeader();
}



DWORD
CSrmpRequestBuffers::GenerateEnvelopeAttachmentHeader(
    DWORD dataSize,
    DWORD boundaryId
    )
{
	size_t n = UtlSprintfAppend(
				&m_HttpRequestData,
                BOUNDARY_HYPHEN BOUNDARY_VALUE "\r\n"
                "Content-Type: %s; charset=UTF-8\r\n"
                "Content-Length: %d\r\n"
                "\r\n",
                boundaryId,
                xEnvelopeContentType,
                dataSize
                );

    return numeric_cast<DWORD>(n);
}


DWORD
CSrmpRequestBuffers::GenerateMultipartAttachmentHeader(
	DWORD dataSize,
    const xstr_t& contentId,
    DWORD boundaryId
    )
{
    const GUID* pGuid = &McGetMachineID();
    size_t n = UtlSprintfAppend(
				&m_HttpRequestData,
                BOUNDARY_HYPHEN BOUNDARY_VALUE "\r\n"
                "Content-Type: %s\r\n"
                "Content-Length: %d\r\n"
                "Content-Id: " MIME_ID_FMT_A "\r\n"
                "\r\n",
                boundaryId,
                xApplicationContentType,
                dataSize,
                contentId.Length(), contentId.Buffer(),
                GUID_ELEMENTS(pGuid)
                );

    return numeric_cast<DWORD>(n);
}



void CSrmpRequestBuffers::CreateMultipartHeaders(const CAttachmentsArray& attachments)
{
	DWORD boundaryId = rand();
	ASSERT(m_buffers.size() == 0);

    DWORD totalSize = 0;
    DWORD envLen = numeric_cast<DWORD>(m_envelope.size());


	//
	// http header - is the first buffer to send. set with null values - we don't know yet it's size
	//
	WSABUF buffer;
	buffer.buf = NULL;
	buffer.len =  0;
	m_buffers.push_back(buffer);


	//
	// On each data item we format into m_HttpRequestData we need to set NULL
	// in the coresponding sends buffer (wsabuf[bufIndex].buf) . This because the
	// pointer to data is not known untill ends of formatting (because of possible memory realocation).
	// The NULL indicates that we should set this pointer to the real data
	// by the function 	SetBufferPointers , called at the end of formatting.
	//
    DWORD headerSize = GenerateEnvelopeAttachmentHeader(envLen, boundaryId);

	//
	// envelop header
	//
	buffer.buf = NULL;
	buffer.len =  headerSize;
	totalSize += buffer.len;
	m_buffers.push_back(buffer);


	//
	// Envelop body
	//
    buffer.buf = (LPSTR)m_envelope.c_str();
    buffer.len = envLen;
    totalSize += buffer.len;
	m_buffers.push_back(buffer);


	//
	// Attachments
	//
    for (DWORD i = 0; i < attachments.size(); ++i)
    {
        if (attachments[i].m_id.Length() == 0)
            break;

        headerSize = GenerateMultipartAttachmentHeader(
							    attachments[i].m_data.Length(),
                                attachments[i].m_id,
                                boundaryId
                                );
		//
		// Attachment headers
		//
        buffer.buf = NULL;
        buffer.len = headerSize;
        totalSize +=  buffer.len;
		m_buffers.push_back(buffer);


		//
		// Attachement  body
		//
        buffer.buf = (LPSTR)(attachments[i].m_data.Buffer());
        buffer.len = attachments[i].m_data.Length();
        totalSize +=  buffer.len;
		m_buffers.push_back(buffer);

    }

    //
    // Add boundry seperator in the end of the request
    //
    size_t n = UtlSprintfAppend(
							&m_HttpRequestData,
							BOUNDARY_HYPHEN BOUNDARY_VALUE BOUNDARY_HYPHEN "\r\n",
							boundaryId
							);


	buffer.buf = NULL;
    buffer.len = numeric_cast<DWORD>(n);
    totalSize += buffer.len;
    m_buffers.push_back(buffer);


    //
    // Create HTTP header
    //
	const char* HttpVersion = GetHttpVersionStr();
	TrTRACE(SRMP,"Format message with http version %s",HttpVersion);

    headerSize = numeric_cast<DWORD>(
						UtlSprintfAppend(
						&m_HttpRequestData,
                        "POST %s %s\r\n"
                        "Host: %s\r\n"
                        "Content-Type: %s; boundary=\"" BOUNDARY_VALUE "\"; type=text/xml\r\n"
                        "Content-Length: %d\r\n"
						"SOAPAction: \"MSMQMessage\"\r\n"
                        "Proxy-Accept: NonInteractiveClient\r\n"
                        "\r\n",
                        m_uri.begin(),
						HttpVersion,
                        m_targethost.get(),
                        xMultipartContentType,
                        boundaryId,
                        totalSize
                        ));

    //
	// Fix the size of the http header
	//
    m_buffers[0].len = headerSize;

   	//
	//Now we need to fix set the send buffers to the formatted data.
	//Only at the end of the formatting we can do so - because the formatted buffers
	//can be realocated so pointer  are invalid untill the formating ends.
	//
	SetBufferPointers();

}



void CSrmpRequestBuffers::CreateSimpleHttpHeader()
{
	ASSERT(m_buffers.size() == 0);

	DWORD envLen = numeric_cast<DWORD>(m_envelope.size());
	const char* HttpVersion = GetHttpVersionStr();
	TrTRACE(SRMP,"Format message with http version %s",HttpVersion);

    DWORD headerSize = numeric_cast<DWORD>(
							UtlSprintfAppend(
							&m_HttpRequestData,
                            "POST %s %s\r\n"	
                            "Host: %s\r\n"
                            "Content-Type: %s\r\n"
                            "Content-Length: %d\r\n"
							"SOAPAction: \"MSMQMessage\"\r\n"
                            "Proxy-Accept: NonInteractiveClient\r\n"
                            "\r\n",
                            m_uri.begin(),
							HttpVersion,
                            m_targethost.get(),
                            xEnvelopeContentType,
                            envLen
                            ));


    WSABUF  buffer;
	buffer.buf = NULL;
	buffer.len = headerSize;
	m_buffers.push_back(buffer);


	buffer.buf =  (LPSTR)m_envelope.c_str();
	buffer.len =  envLen;
	m_buffers.push_back(buffer);


	SetBufferPointers();
}


void CSrmpRequestBuffers::SetBufferPointers()
/*++

Routine Description:
    Set pointers in the sends buffers to the data.
	Only buffers that  has NULL data pointer needs to be set.

Arguments:
  None

Returned Value:
   None

--*/
{
	ASSERT(m_buffers.size() != 0);

	size_t pos = 0;
	for(DWORD i = 1; i<m_buffers.size(); ++i)
	{
		ASSERT(pos <= m_HttpRequestData.size());
		if(m_buffers[i].buf  == NULL)
		{
			m_buffers[i].buf =	const_cast<char*>(m_HttpRequestData.begin() + pos);
			pos += m_buffers[i].len;
		}
	}
	ASSERT(m_buffers[0].buf == NULL);
	m_buffers[0].buf = const_cast<char*>(m_HttpRequestData.begin() + pos);
	pos += 	m_buffers[0].len;
	ASSERT(pos == m_HttpRequestData.size());
}



void CSrmpRequestBuffers::SourceSerializeMessage()
{
	CAttachmentsArray attachments;
	PacketToAttachments(m_pkt, &attachments);

	m_envelope =  UtlWcsToUtf8(GenerateEnvelope(m_pkt));

	CreateHttpRequestHeaders(attachments);
}


static void CheckRequestLine(const xstr_t& RequestLine)
{
	const char xPost[] = "POST";
	ASSERT(UtlIsStartSec(
					RequestLine.Buffer(),
					RequestLine.Buffer() + RequestLine.Length(),
					xPost,
					xPost + STRLEN(xPost),
					UtlCharNocaseCmp<char>()
					));

	DBG_USED(RequestLine);
	DBG_USED(xPost);
}



void CSrmpRequestBuffers::CreateSFDHeader(const xstr_t& OrgHeader)
/*++

Routine Description:
      create http header based on the original http header.
	  In general , Hdears fileds are copied from the original header except
	  few field must be removed from the new header - for exmaple the Host:
	  field.
	
Arguments:
    OrgHeader - original header.
	
Returned Value:
   None

--*/
{
	ASSERT(m_HttpRequestData.size() == 0);

	
	UtlSprintfAppend(
				&m_HttpRequestData,
				"POST %s HTTP/1.1\r\n"
                "Host: %s\r\n",
				m_uri.begin(),
                m_targethost.get()
				);

    CStrToken StrToken (
					OrgHeader,
					"\r\n"
					);
	//
	// Loop over all the fields in the original header and check if to
	// include them in the new header or not. The first line is the post
	// method and is not included anyway
	//
	for(CStrToken::iterator it = StrToken.begin(); it != StrToken.end(); ++it)
	{
		if(it == StrToken.begin())
		{
			CheckRequestLine(*it);
			continue;
		}

		if(!FilterHeaderField(*it))
		{
			UtlSprintfAppend(
				&m_HttpRequestData,
                "%.*s\r\n",
				it->Length(),
				it->Buffer()
				);
	
		}
	}

	//
	// set the created header on the send buffer
	//
	WSABUF buffer;
	buffer.buf = m_HttpRequestData.begin();
	buffer.len = numeric_cast<DWORD>(m_HttpRequestData.size());
	m_buffers.push_back(buffer);
}




void CSrmpRequestBuffers::SFDSerializeMessage()
/*++

Routine Description:
    Serialize messages in an SFD. In SFD we should deliver
	the original messages just with some changes to the http header

Arguments:

Returned Value:
   None

--*/
{
	//
	// Get the priginal messages and find where http header ends
	//
	const char* pOrgHeaderStart =  (char*)m_pkt.GetPointerToCompoundMessage();
	DWORD OrgMessageSize = m_pkt.GetCompoundMessageSizeInBytes();
	
	//
	// Create the new http header based on the original header
	//
	xstr_t OrgHeader = FindHttpHeader(pOrgHeaderStart, OrgMessageSize);
	CreateSFDHeader(OrgHeader);
	ASSERT(m_buffers.size() == 1);


	//
	// Set the rest of original message(everything that comes after the http header)
	// on the send buffer
	//
	WSABUF buffer;
	buffer.buf =  const_cast<char*>(OrgHeader.Buffer()) + OrgHeader.Length();
	buffer.len =  OrgMessageSize -  OrgHeader.Length();
	m_buffers.push_back(buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\msm\lib\msmdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmDebug.cpp

Abstract:
    Multicast Session Manager debugging

Author:
    Shai Kariv (shaik) 05-Sep-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Msm.h"
#include "Msmp.h"

#include "msmdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Multicast Session Manager state
//
void MsmpAssertValid(void)
{
    //
    // MsmInitalize() has *not* been called. You should initialize the
    // Multicast Session Manager library before using any of its funcionality.
    //
    ASSERT(MsmpIsInitialized());

    //
    // TODO:Add more Multicast Session Manager validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void MsmpSetInitialized(void)
{
    LONG fMsmAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Multicast Session Manager library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fMsmAlreadyInitialized);
}


BOOL MsmpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
/*
const DebugEntry xDebugTable[] = {

    {
        "MsmDumpState(queue path name)",
        "Dump Multicast Session Manager State to debugger",
        DumpState
    ),

    //
    // TODO: Add Multicast Session Manager debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void MsmpRegisterComponent(void)
{
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\test\mptest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MpTest.cpp

Abstract:
    SRMP Serialization and Deserialization library test

Author:
    Uri Habusha (urih) 28-May-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "_mqini.h"
#include <Mp.h>
#include <xml.h>
#include <mqexception.h>
#include <utf8.h>
#include <cm.h>
#include "mqwin64a.h"
#include "acdef.h"
#include "qmpkt.h"
#include "qal.h"


#include "MpTest.tmh"

using namespace std;


extern CBaseHeader* CreatePacket();

//
// Dummy function to link ph files
//
void ReportAndThrow(LPCSTR)
{
	ASSERT(0);
}

void GetDnsNameOfLocalMachine(WCHAR ** ppwcsDnsName)
{
    const WCHAR xLoclMachineDnsName[] = L"www.foo.com";
    *ppwcsDnsName = newwcs(xLoclMachineDnsName);
}


static GUID s_machineId = {1234, 12, 12, 1, 1, 1, 1, 1, 1, 1, 1};
const GUID&
McGetMachineID(
    void
    )
{
    return s_machineId;
}



CQmPacket::CQmPacket(CBaseHeader *pPkt,
					 CPacket *pDriverPkt,
					 bool,
					 bool):
                m_pDriverPacket(pDriverPkt)
{
    PCHAR pSection;

    m_pBasicHeader = pPkt;

    ASSERT(m_pBasicHeader->VersionIsValid());

    pSection = m_pBasicHeader->GetNextSection();

    if (m_pBasicHeader->GetType() == FALCON_USER_PACKET)
    {
        //
        // User Packet
        //
        m_pcUserMsg = (CUserHeader*) pSection;
        pSection = m_pcUserMsg->GetNextSection();
        //
        // Xact Section
        //
        if (m_pcUserMsg->IsOrdered())
        {
            m_pXactSection = (CXactHeader *)pSection ;
            pSection = m_pXactSection->GetNextSection();
        }
        else
        {
            m_pXactSection = NULL;
        }

        //
        // Security Section
        //
        if (m_pcUserMsg->SecurityIsIncluded())
        {
            m_pSecuritySection = (CSecurityHeader *)pSection ;
            pSection = m_pSecuritySection->GetNextSection();
        }
        else
        {
            m_pSecuritySection = NULL;
        }

        //
        // Message propery section
        //
        if (m_pcUserMsg->PropertyIsIncluded())
        {
            m_pcMsgProperty = (CPropertyHeader*) pSection;
            pSection = m_pcMsgProperty->GetNextSection();
        }
        else
        {
            m_pcMsgProperty = NULL;
        }

        //
        // Debug Section
        //
        if (m_pBasicHeader->DebugIsIncluded())
        {
            m_pDbgPkt = (CDebugSection *)pSection;
            pSection = m_pDbgPkt->GetNextSection();
        }
        else
        {
            m_pDbgPkt = NULL;
        }

        //
        // MQF sections: Destination, Admin, Response
        // When MQF is included, the Debug section must be included too,
        // to prevent reporting QMs 1.0/2.0 to append their Debug section.
        //
        if (m_pcUserMsg->MqfIsIncluded())
        {
            ASSERT(m_pBasicHeader->DebugIsIncluded());

            m_pDestinationMqfHeader = section_cast<CBaseMqfHeader*>(pSection);
            pSection = m_pDestinationMqfHeader->GetNextSection();

            m_pAdminMqfHeader = section_cast<CBaseMqfHeader*>(pSection);
            pSection = m_pAdminMqfHeader->GetNextSection();

            m_pResponseMqfHeader = section_cast<CBaseMqfHeader*>(pSection);
            pSection = m_pResponseMqfHeader->GetNextSection();

			m_pMqfSignatureHeader =  section_cast<CMqfSignatureHeader* >(pSection);
			pSection= m_pMqfSignatureHeader->GetNextSection();			
        }
        else
        {
            m_pDestinationMqfHeader = m_pAdminMqfHeader = m_pResponseMqfHeader = NULL;
			m_pMqfSignatureHeader  = NULL;
        }

        //
        // SRMP sections: envelope and compound message
        //
        if (m_pcUserMsg->SrmpIsIncluded())
        {
            m_pSrmpEnvelopeHeader = section_cast<CSrmpEnvelopeHeader*>(pSection);
            pSection = m_pSrmpEnvelopeHeader->GetNextSection();

            m_pCompoundMessageHeader = section_cast<CCompoundMessageHeader*>(pSection);
            pSection = m_pCompoundMessageHeader->GetNextSection();
        }
        else
        {
            m_pSrmpEnvelopeHeader = NULL;
            m_pCompoundMessageHeader = NULL;
        }

        //
        // EOD section
        //
        if (m_pcUserMsg->EodIsIncluded())
        {
            m_pEodHeader = section_cast<CEodHeader*>(pSection);
            pSection = m_pEodHeader->GetNextSection();
        }
        else
        {
            m_pEodHeader = NULL;
        }

		//
        // EOD ack section
        //
        if (m_pcUserMsg->EodAckIsIncluded())
        {
            m_pEodAckHeader = section_cast<CEodAckHeader*>(pSection);
            pSection = m_pEodAckHeader->GetNextSection();
        }
        else
        {
            m_pEodAckHeader = NULL;
        }


		if(m_pcUserMsg->SenderStreamIsIncluded())
		{
			m_pSenderStreamHeader = section_cast<CSenderStreamHeader*>(pSection);
            pSection = m_pSenderStreamHeader->GetNextSection();
		}

        //
        // Session Section
        //
        if (m_pBasicHeader->SessionIsIncluded())
        {
            m_pSessPkt = (CSessionSection *)pSection;
        }
        else
        {
            m_pSessPkt = NULL;
        }
    }
}


static void Usage()
{
    printf("Usage: MpTest [-n x]\n");
    printf("\t*-n*\t*Number of messages*\n");
    printf("\n");
    printf("Example, MppTest -n 3\n");
    exit(-1);

} // Usage



static
bool
CompareQueue(
    const QUEUE_FORMAT& origQueue,
    const QUEUE_FORMAT& newQueue
    )
{
    if (origQueue.GetType() != newQueue.GetType())
    {
        printf("Queue type mismatch. Expected: %d, Actual: %d", origQueue.GetType(), newQueue.GetType());
        return false;
    }

    if (origQueue.Suffix() != newQueue.Suffix())
    {
        printf("Queue Suffix mismatch. Expected: %d, Actual: %d", origQueue.Suffix(), newQueue.Suffix());
        return false;
    }

    if (origQueue.GetType() ==  QUEUE_FORMAT_TYPE_UNKNOWN)
        return true;

    if (origQueue.GetType() == QUEUE_FORMAT_TYPE_PUBLIC)
    {
        if (memcmp(&origQueue.PublicID(), &newQueue.PublicID(), sizeof(GUID)) == 0)
            return true;

        printf("Queue public ID mismatch.");
        return false;
    }

    if (origQueue.GetType() == QUEUE_FORMAT_TYPE_PRIVATE)
    {
        if (memcmp(&origQueue.PrivateID(), &newQueue.PrivateID(), sizeof(OBJECTID)) == 0)
            return true;

        printf("Queue private ID mismatch.");
        return false;
    }

    if (origQueue.GetType() == QUEUE_FORMAT_TYPE_DIRECT)
    {
        if (wcscmp(origQueue.DirectID(), newQueue.DirectID()) == 0)
            return true;

        printf("Queue direct ID mismatch. Expected: %ls, Actual: %ls", origQueue.DirectID(), newQueue.DirectID());
        return false;
    }

    return false;
}


static
bool
Compare(
    CQmPacket& origPkt,
    CQmPacket& newPkt,
	DWORD SizeDiff
    )
{
    if (origPkt.GetType() != newPkt.GetType())
    {
        printf("packet type mismatch. Expected: %d, Actual: %d", origPkt.GetType(), newPkt.GetType());
        return false;
    }

    if (origPkt.GetPriority() != newPkt.GetPriority())
    {
        printf( "packet priority mismatch. Expected: %d, Actual: %d", origPkt.GetPriority(), newPkt.GetPriority());
        return false;
    }

    if (origPkt.GetTrace() != newPkt.GetTrace())
    {
        printf( "packet tracing mismatch. Expected: %d, Actual: %d", origPkt.GetTrace(), newPkt.GetTrace());
        return false;
    }

    if (memcmp(origPkt.GetSrcQMGuid(), newPkt.GetSrcQMGuid(), sizeof(GUID)) != 0)
    {
        printf( "Source Id mismatch. ");
        return false;
    }

    OBJECTID origMsgId;
    origPkt.GetMessageId(&origMsgId);

    OBJECTID newMsgId;
    newPkt.GetMessageId(&newMsgId);

    if (origMsgId.Uniquifier != newMsgId.Uniquifier)
    {
        printf( "Message Id mismatch. ");
        return false;
    }

    if (memcmp(&origMsgId.Lineage, &newMsgId.Lineage, sizeof(GUID)) != 0)
    {
        printf( "Message Id mismatch. ");
        return false;
    }

    if (origPkt.GetDeliveryMode() != newPkt.GetDeliveryMode())
    {
        printf( "Delivery mode mismatch. Expected: %d, Actual: %d", origPkt.GetDeliveryMode(), newPkt.GetDeliveryMode());
        return false;
    }

    if (origPkt.GetAuditingMode() != newPkt.GetAuditingMode())
    {
        printf( "auditing mismatch. Expected: %d, Actual: %d", origPkt.GetAuditingMode(), newPkt.GetAuditingMode());
        return false;
    }

    if (origPkt.IsPropertyInc() != newPkt.IsPropertyInc())
    {
        printf( "Property section included mismatch. Expected: %d, Actual: %d", origPkt.IsPropertyInc(), newPkt.IsPropertyInc());
        return false;
    }

    if (origPkt.IsSecurInc() != newPkt.IsSecurInc())
    {
        printf( "Security section include mismatch. Expected: %d, Actual: %d", origPkt.IsSecurInc(), newPkt.IsSecurInc());
        return false;
    }

    if (origPkt.IsOrdered() != newPkt.IsOrdered())
    {
        printf( "Transaction section include mismatch. Expected: %d, Actual: %d", origPkt.IsOrdered(), newPkt.IsOrdered());
        return false;
    }
	

	if (origPkt.IsFirstInXact() != newPkt.IsFirstInXact())
    {
        printf( "First XACT  mismatch. Expected: %d, Actual: %d", origPkt.IsFirstInXact(), newPkt.IsFirstInXact());
        return false;
    }

    if (origPkt.IsLastInXact() != newPkt.IsLastInXact())
    {
        printf( "Last in XACT mismatch. Expected: %d, Actual: %d", origPkt.IsLastInXact(), newPkt.IsLastInXact());
        return false;
    }

//
// BUGBUG - currently we don't support eod so many validation is not applicable - 13-sep-2000
//

    if (origPkt.GetSeqID() != newPkt.GetSeqID())
    {
        printf( "XACT Sequnce ID mismatch. Expected: %I64d, Actual: %I64d", origPkt.GetSeqID(), newPkt.GetSeqID());
        return false;
    }


    if (origPkt.GetSeqN() != newPkt.GetSeqN())
    {
        printf( "XACT Sequnce number mismatch. Expected: %d, Actual: %d", origPkt.GetSeqN(), newPkt.GetSeqN());
        return false;
    }

    if (origPkt.GetPrevSeqN() != newPkt.GetPrevSeqN())
    {
        printf( "XACT Prev-Sequnce number mismatch. Expected: %d, Actual: %d", origPkt.GetPrevSeqN(), newPkt.GetPrevSeqN());
        return false;
    }

	

	if ((origPkt.GetConnectorQM() != NULL) && (newPkt.GetConnectorQM() != NULL))
    {
        if (memcmp(origPkt.GetConnectorQM(), newPkt.GetConnectorQM(), sizeof(GUID)) != 0)
        {
            printf( "Connector ID mismatch");
            return false;
        }
    }
    else
    {
        if ((origPkt.GetConnectorQM() != NULL) || (newPkt.GetConnectorQM() != NULL))
        {
            printf( "Connector ID mismatch");
            return false;
        }
    }



    QUEUE_FORMAT origQueue;
    QUEUE_FORMAT newQueue;

    origPkt.GetDestinationQueue(&origQueue);
    QUEUE_FORMAT_TRANSLATOR RealDestinationQueue(&origQueue, DECODE_URL | MAP_QUEUE);
    newPkt.GetDestinationQueue(&newQueue);

    if (! CompareQueue(*RealDestinationQueue.get(), newQueue))
    {
        printf( "Destination queue mismatch.");
        return false;
    }

    origPkt.GetAdminQueue(&origQueue);
    newPkt.GetAdminQueue(&newQueue);

    if (! CompareQueue(origQueue, newQueue))
    {
        printf( "Admin queue mismatch.");
        return false;
    }
    bool fAdminQueue = (origQueue.GetType() !=  QUEUE_FORMAT_TYPE_UNKNOWN);

    origPkt.GetResponseQueue(&origQueue);
    newPkt.GetResponseQueue(&newQueue);

    if (! CompareQueue(origQueue, newQueue))
    {
        printf( "Response queue mismatch.");
        return false;
    }


    if (origPkt.GetSentTime() != newPkt.GetSentTime())
    {
		printf( "SentTime mismatch.");
        return false;
	}


    if (origPkt.GetClass() != newPkt.GetClass())
    {
        printf( "Class mismatch. Expected: %d, Actual: %d", origPkt.GetClass(), newPkt.GetClass());
        return false;
    }
	


    if (fAdminQueue && (origPkt.GetAckType() != newPkt.GetAckType()))
    {
        printf("Ack type mismatch. Expected: %d, Actual: %d", origPkt.GetAckType(), newPkt.GetAckType());
        return false;
    }

    if (memcmp(origPkt.GetCorrelation(), newPkt.GetCorrelation(), PROPID_M_CORRELATIONID_SIZE) != 0)
    {
        printf( "Correlation mismatch");
        return false;
    }

    if (origPkt.GetApplicationTag() != newPkt.GetApplicationTag())
    {
        printf( "Application tag mismatch. Expected: %d, Actual: %d", origPkt.GetApplicationTag(), newPkt.GetApplicationTag());
        return false;
    }

    if (origPkt.GetBodyType() != newPkt.GetBodyType())
    {
        printf( "Body type mismatch. Expected: %d, Actual: %d", origPkt.GetBodyType(), newPkt.GetBodyType());
        return false;
    }

    if (origPkt.GetTitleLength() != newPkt.GetTitleLength())
    {
        printf( "Title length mismatch. Expected: %d, Actual: %d", origPkt.GetTitleLength(), newPkt.GetTitleLength());
        return false;
    }

    if (origPkt.GetTitleLength())
    {
        if (memcmp(origPkt.GetTitlePtr(), newPkt.GetTitlePtr(), (origPkt.GetTitleLength()*sizeof(WCHAR)) ) != 0)
        {
            printf( "Title mismatch: \n\tExpected: %.*ls., \n\tActual: %.*ls.\n", origPkt.GetTitleLength(), origPkt.GetTitlePtr(), newPkt.GetTitleLength(), newPkt.GetTitlePtr());
            return false;
        }
    }

    if (origPkt.GetMsgExtensionSize() != newPkt.GetMsgExtensionSize())
    {
        printf( "Extension size mismatch. Expected: %d, Actual: %d", origPkt.GetMsgExtensionSize(), newPkt.GetMsgExtensionSize());
        return false;
    }

    if (origPkt.GetMsgExtensionSize())
    {
        if (memcmp(origPkt.GetMsgExtensionPtr(), newPkt.GetMsgExtensionPtr(), origPkt.GetMsgExtensionSize()) != 0)
        {
            printf( "Extension mismatch.");
            return false;
        }
    }


    DWORD origBodySize;
    DWORD newBodySize;

    const UCHAR* pOrigBody = newPkt.GetPacketBody(&origBodySize);
    const UCHAR* pNewBody = origPkt.GetPacketBody(&newBodySize);

    if (origBodySize != newBodySize)
    {
        printf( "Body size mismatch. Expected: %d, Actual: %d", origBodySize, newBodySize);
        return false;
    }

    if (memcmp(pOrigBody,  pNewBody, origBodySize) != 0)
    {
        printf( "Body  mismatch.");
        return false;
    }

	DWORD OldPacketSize = origPkt.GetSize();
	DWORD NewPacketSize = newPkt.GetSize();
	if (OldPacketSize != NewPacketSize -  SizeDiff)
    {
        printf( "packet size mismatch. Expected: %d, Actual: %d",OldPacketSize, NewPacketSize -  SizeDiff);
        return false;
    }



    return true;
}


void
AppAllocatePacket(
             const QUEUE_FORMAT& ,
             UCHAR,
             DWORD pktSize,
             CACPacketPtrs& pktPtrs
             )
{
    pktPtrs.pPacket = reinterpret_cast<CBaseHeader*>(new UCHAR[pktSize]);
    pktPtrs.pDriverPacket = NULL;
}


PSID
AppGetCertSid(
	const BYTE*  /* pCertBlob */,
	ULONG        /* ulCertSize */,
	bool		 /* fDefaultProvider */,
	LPCWSTR      /* pwszProvName */,
	DWORD        /* dwProvType */
	)
{
	return NULL;
}


void
AppFreePacket(
    CACPacketPtrs& pktPtrs
    )
{
    delete [] pktPtrs.pPacket;
}


static DWORD GetSrmpSectionSize(size_t envsize, size_t HttpHeaderSize, size_t HttpBodySize )
{
	//
    // SRMP envelope
    //
    DWORD Size = CSrmpEnvelopeHeader::CalcSectionSize(numeric_cast<DWORD>(envsize));

    //
    // CompoundMessage
    //
    Size += CCompoundMessageHeader::CalcSectionSize(
                numeric_cast<DWORD>(HttpHeaderSize),
                numeric_cast<DWORD>(HttpBodySize)
                );

	return  Size;
}

static DWORD GetEodSectionSize(const CQmPacket& newPkt)
{
	if(!newPkt.IsEodIncluded())
		return 0;

 	DWORD EodStreamIdLen = newPkt.GetEodStreamIdSizeInBytes();
	DWORD OrderAckAddressLen = 	newPkt.GetEodOrderQueueSizeInBytes();

	
	return CEodHeader::CalcSectionSize(EodStreamIdLen, OrderAckAddressLen);
}


static DWORD GetSenderStreamSectionSize(const CQmPacket& newPkt)
{
	if(!newPkt.IsSenderStreamIncluded())
		return 0;

 		
	return CSenderStreamHeader::CalcSectionSize();
}


static WCHAR* GetQueueAliasPath(void)
{
    //
    // Get mapping directory according to mapping special registry key
    //
    RegEntry registry(0, MSMQ_MAPPING_PATH_REGNAME);
    AP<WCHAR> pRetStr;
    CmQueryValue(registry, &pRetStr);
    if(pRetStr.get() == NULL)
    {
        //
        // Get msmq root path and append to it "mapping" string
        //
        RegEntry registry(0, MSMQ_ROOT_PATH);
        CmQueryValue(registry, &pRetStr);
        if(pRetStr.get() == NULL)
        {
            ASSERT(("Could not find storage directory in registry",0));
            return NULL;
        }
        return newwcscat(pRetStr.get() , DIR_MSMQ_MAPPING);
    }
    return pRetStr.detach();
}

extern "C" int __cdecl _tmain(int argc, LPCTSTR /*argv*/[])
/*++

Routine Description:
    Test Convertors to and from SRMP library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{	
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

    TrInitialize();
	CmInitialize(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MSMQ\\Parameters", KEY_ALL_ACCESS);
	XmlInitialize();
	QalInitialize(AP<WCHAR>(GetQueueAliasPath()));
    if (argc != 1)
        Usage();

    MpInitialize();

    for(DWORD n = 100; n > 0; --n)
    {
        TrTRACE(SRMP, "Packet No %d", n);

	    //
        // Create MSMQ Packet
        //
        CBaseHeader* pkt = CreatePacket();

        AP<UCHAR> orgrel = reinterpret_cast<UCHAR*>(pkt);
        CQmPacket origPkt(pkt, NULL);

        //
        // SRMP Serialization
        //
        R<CSrmpRequestBuffers> SrmpRequestBuffers =  MpSerialize(
											origPkt,
											L"localhost",
											L"//myqueue"
											);

		wstring envstr = SrmpRequestBuffers->GetEnvelop();

	
        printf("SRMP - %ls", envstr.c_str());

        //
        // SRMP deserialization
        //
		AP<BYTE> HttpBody =  SrmpRequestBuffers->SerializeHttpBody();
		DWORD HttpBodySize = numeric_cast<DWORD>(SrmpRequestBuffers->GetHttpBodyLength());
		const char * HttpHeader = SrmpRequestBuffers->GetHttpHeader();
       	P<CQmPacket> newPkt = MpDeserialize(HttpHeader, HttpBodySize, HttpBody, NULL);


		//
		// We should adjust the packet size not to include the envelop && eod  section - because
		// it was not created by the test. It was created by the parser (receiver).
		//
		DWORD srmpSectionSize =  GetSrmpSectionSize(envstr.size(), strlen(HttpHeader), HttpBodySize );
	    DWORD EodSectionSize = GetEodSectionSize(*newPkt);
		DWORD SenderStreamSectionSize  = GetSenderStreamSectionSize(origPkt);
		DWORD origBodySize;
        origPkt.GetPacketBody(&origBodySize);
	
        if (! Compare(origPkt, *newPkt, srmpSectionSize + EodSectionSize - SenderStreamSectionSize - ALIGNUP4_ULONG(origBodySize)))
		{
			printf("test failed \n");
            return -1;
		}
    }

    TrTRACE(SRMP, "Complete successfully");

    WPP_CLEANUP();
    return 0;

} // _tmain


//
// Nedded for linking with fn.lib
//
LPCWSTR
McComputerName(
	void
	)
{
	return NULL;
}

//
// Nedded for linking with fn.lib
//
DWORD
McComputerNameLen(
	void
	)
{
	return 0;
}

//
// Nedded for linking with qal.lib
//
void AppNotifyQalWin32FileError(LPCWSTR , DWORD )throw()
{

}

void AppNotifyQalDirectoryMonitoringWin32Error(LPCWSTR , DWORD )throw()
{

}

void AppNotifyQalDuplicateMappingError(LPCWSTR, LPCWSTR )throw()
{

}


void AppNotifyQalInvalidMappingFileError(LPCWSTR )throw()
{

}


void AppNotifyQalXmlParserError(LPCWSTR )throw()
{

}

bool AppNotifyQalMappingFound(LPCWSTR, LPCWSTR)throw()
{
	return true;
}


bool AppIsDestinationAccepted(const QUEUE_FORMAT* , bool )
{
    return true;
}


void
CrackUrl(
    LPCWSTR,
    xwcs_t&,
    xwcs_t&,
    USHORT*,
	bool*
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mp\test\packet.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    packet.cpp

Abstract:
    generates valid MSMQ packet

Author:
    Uri Habusha (urih) 25-May-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <mqwin64a.h>
#include <xstr.h>
#include <fn.h>
#include "ph.h"

#include "packet.tmh"

using namespace std;


const WCHAR xTitle[] = L"<This mess<=age was #; generated for <<&\">> testing purpose only";
const UCHAR xExtension[] = "extension data";
const UCHAR xBody[] = "aaaaa bbbbb ccccc dddddd eeeee fffff gggggg kkkkkkkk lllllllllllll";
const UCHAR xCorelationId[PROPID_M_CORRELATIONID_SIZE] = "set correclation Id";
const DWORD xDeltaInqueue = 200000;


class CProperties 
{
public:
    CProperties(void) 
    {
        memset(this, 0, sizeof(CProperties));

        delivery = MQMSG_DELIVERY_EXPRESS;
        absoluteTimeToQueue = LONG_MAX;
        acknowledgeType = DEFAULT_M_ACKNOWLEDGE;
        classValue = MQMSG_CLASS_NORMAL;
        priority = DEFAULT_M_PRIORITY;
        auditing = MQMSG_JOURNAL_NONE;
    }

public:
    GUID sourceId;
    GUID destId;

    P<QUEUE_FORMAT> pDestQueue;
    P<QUEUE_FORMAT> pAdminQueue;
    P<QUEUE_FORMAT> pResponseQueue;
	CFnMqf destMqf;
	CFnMqf adminMqf;
	CFnMqf responseMqf;
	QUEUE_FORMAT DebugQueue;

    OBJECTID messageId;

    DWORD absoluteTimeToQueue;
    long sentTime;

    UCHAR delivery;
    bool fTrace;

    UCHAR acknowledgeType;
    USHORT classValue;
    DWORD applicationTag;

    UCHAR auditing;
    UCHAR priority;
    GUID connectorType;

    bool fEod;
	LONGLONG EodAckseqId;
	LONGLONG EodAckseqNo;
	const WCHAR* EodAckStreamId;


    LONGLONG seqId;
    DWORD seqNo;
    DWORD prevSeqNo;
    bool fFirst;
    bool fLast;
    GUID connectorId;

    DWORD titleLength;
    LPCWSTR pTitle;

    DWORD extensionSize;
    const BYTE* pExtension;
	
    DWORD bodySize;
    DWORD bodyType;
    const BYTE* pBody;

    UCHAR correlation[PROPID_M_CORRELATIONID_SIZE]; 

    DWORD senderCertSize;
    const BYTE* pSenderCert;

    DWORD signatureSize;
    const BYTE* pSignature;

    bool fDefaultProvider;
    LPCWSTR providerName;
    DWORD providerType;

}; 


const WCHAR xDestQueue[] = L"http://www.foo.com\\q1";
const WCHAR xAdminQueue[] = L"http://www.foo.com\\q2";

static
QUEUE_FORMAT*
GenerateQueueFormat(
    bool fDestQueue
    )
{
    if (fDestQueue)
    {
        return new QUEUE_FORMAT(const_cast<LPWSTR>(xDestQueue));
    }

    QUEUE_FORMAT_TYPE type = static_cast<QUEUE_FORMAT_TYPE>(rand() % static_cast<int>(QUEUE_FORMAT_TYPE_DIRECT + 1));
    

    switch (type)
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
        {
            GUID id;
            UuidCreate(&id);
        
            return new QUEUE_FORMAT(id);
        }

        case QUEUE_FORMAT_TYPE_PRIVATE:
        {
            GUID id;
            UuidCreate(&id);
        
            return new QUEUE_FORMAT(id, rand());
        }

        case QUEUE_FORMAT_TYPE_DIRECT:
        {
            return new QUEUE_FORMAT(const_cast<LPWSTR>(xAdminQueue));
        }
    }

    return NULL;
}


static
DWORD
CalculatePacketSize(
    CProperties& mProp
    )
{
    DWORD packetSize;
    
    packetSize  = CBaseHeader::CalcSectionSize();

    ASSERT(mProp.pDestQueue->GetType() != QUEUE_FORMAT_TYPE_UNKNOWN);

    packetSize += CUserHeader::CalcSectionSize(
                        &mProp.sourceId,
                        &mProp.destId,
                        (mProp.connectorType != GUID_NULL) ? &mProp.connectorType: NULL,
                        mProp.pDestQueue,
                        mProp.pAdminQueue,
                        mProp.pResponseQueue
                        );

    if (mProp.fEod)
    {
        packetSize += CXactHeader::CalcSectionSize(
										&mProp.seqId, 
										mProp.connectorId == GUID_NULL ? NULL : &mProp.connectorId
										);

		packetSize += CSenderStreamHeader::CalcSectionSize(); 
    }

    if ((mProp.pSignature != NULL) || mProp.pSenderCert != NULL)
    {
        DWORD ProviderInfoSize = 0;
        if (!mProp.fDefaultProvider)
        {
            ProviderInfoSize = (wcslen(mProp.providerName) + 1) * sizeof(WCHAR) + sizeof(ULONG);
        }

        packetSize += CSecurityHeader::CalcSectionSize(
                                            0, // Sender ID size
                                            0, // Encrypted Key Size
                                            static_cast<USHORT>(mProp.signatureSize), 
                                            static_cast<USHORT>(mProp.senderCertSize),
                                            static_cast<USHORT>(ProviderInfoSize)
                                            );
    }

    packetSize += CPropertyHeader::CalcSectionSize(
                        mProp.titleLength,
                        mProp.extensionSize,
                        mProp.bodySize
                        );


	if(mProp.EodAckStreamId != NULL)
	{
		packetSize += CEodAckHeader::CalcSectionSize((wcslen(mProp.EodAckStreamId) +1) *sizeof(WCHAR));		
	}

	if(mProp.destMqf.GetCount() != 0 || mProp.adminMqf.GetCount()  != 0  || mProp.responseMqf.GetCount()  !=0)
	{
		packetSize += CDebugSection::CalcSectionSize(&mProp.DebugQueue);
		packetSize += CBaseMqfHeader::CalcSectionSize(mProp.destMqf.GetQueueFormats(), mProp.destMqf.GetCount());
		packetSize += CBaseMqfHeader::CalcSectionSize(mProp.adminMqf.GetQueueFormats(), mProp.adminMqf.GetCount());
		packetSize += CBaseMqfHeader::CalcSectionSize(mProp.responseMqf.GetQueueFormats(), mProp.responseMqf.GetCount());
		packetSize += CMqfSignatureHeader::CalcSectionSize(0);
	}
	

    return packetSize;
}


static
void
BuildPacket(
    CBaseHeader* pBase,
    DWORD packetSize,
    CProperties& mProp
    )
{
    PVOID pSection = pBase;

    #pragma PUSH_NEW
    #undef new

    //
    //  Build the basic header
    //
    pBase = new(pSection) CBaseHeader(packetSize);
    pBase->SetPriority(mProp.priority);
    pBase->SetTrace(mProp.fTrace);
    pBase->SetAbsoluteTimeToQueue(mProp.absoluteTimeToQueue);

    pSection = pBase->GetNextSection();

    //
    // Build user header
    //

    CUserHeader* pUser = new (pSection) CUserHeader(
                                            &mProp.messageId.Lineage,
                                            &GUID_NULL,
                                            mProp.pDestQueue,
                                            mProp.pAdminQueue,
                                            mProp.pResponseQueue,
                                            mProp.messageId.Uniquifier
                                            );

    if (mProp.connectorType != GUID_NULL)
    {
        pUser->SetConnectorType(&mProp.connectorType);
    }

    pUser->SetTimeToLiveDelta(xDeltaInqueue);
    pUser->SetSentTime(mProp.sentTime);
    pUser->SetDelivery(mProp.delivery);
    pUser->SetAuditing(mProp.auditing);

    pSection = pUser->GetNextSection();

    //
    // Build the xact header.
    //

    if (mProp.fEod)
    {
        pUser->IncludeXact(TRUE);

        const GUID* pConnector = ((mProp.connectorId == GUID_NULL) ? NULL : &mProp.connectorId);
        CXactHeader* pXact = new (pSection) CXactHeader(pConnector);

        pXact->SetSeqID(mProp.seqId);
        pXact->SetSeqN(mProp.seqNo);
        pXact->SetPrevSeqN(mProp.prevSeqNo);
        pXact->SetFirstInXact(mProp.fFirst);
        pXact->SetLastInXact(mProp.fLast);
        if (pConnector != NULL)
        {
            pXact->SetConnectorQM(pConnector);
        }

        pSection = pXact->GetNextSection();
    }

    //
    // Build the security header.
    //
    if ((mProp.pSignature != NULL) || mProp.pSenderCert != NULL)
    {
        pUser->IncludeSecurity(TRUE);

        CSecurityHeader* pSec = new (pSection) CSecurityHeader();
        

        if (mProp.pSignature != NULL)
        {
            pSec->SetAuthenticated(TRUE);
            pSec->SetSignature(mProp.pSignature, static_cast<USHORT>(mProp.signatureSize));
        }

        if (mProp.pSenderCert != NULL)
        {
            pSec->SetSenderCert(mProp.pSenderCert, mProp.senderCertSize);
        }

        if (mProp.pSignature != NULL)
        {
            DWORD ProviderInfoSize = 0;
            if (!mProp.fDefaultProvider)
            {
                ProviderInfoSize = (wcslen(mProp.providerName) + 1) * sizeof(WCHAR) + sizeof(ULONG);
            }

            pSec->SetProvInfoEx(
                        static_cast<USHORT>(ProviderInfoSize),
                        mProp.fDefaultProvider, 
                        mProp.providerName,
                        mProp.providerType
                        );
        }

        pSection = pSec->GetNextSection();
    }


    // Build Message Property
    //
    CPropertyHeader* pProp = new (pSection) CPropertyHeader;

    pProp->SetClass(mProp.classValue);
    pProp->SetCorrelationID(mProp.correlation);
    pProp->SetAckType(mProp.acknowledgeType);
    pProp->SetApplicationTag(mProp.applicationTag);
    pProp->SetBodyType(mProp.bodyType);

    if(mProp.titleLength != 0)
    {
        //
        //  NOTE: Setting the title to the message MUST occure before setting the body
        //
        pProp->SetTitle(mProp.pTitle, mProp.titleLength);
    }

    if (mProp.extensionSize != 0)
    {
        //
        //  NOTE: Setting the Message Extension to property section MUST occure
        //        before setting the body and after setting the title
        //
        pProp->SetMsgExtension(mProp.pExtension, mProp.extensionSize);
    }

    if(mProp.bodySize != 0)
    {
        pProp->SetBody(mProp.pBody, mProp.bodySize, mProp.bodySize);
    }

	pSection = pProp->GetNextSection();


	//
	// mqf  + debug headers
	//
	if(mProp.destMqf.GetCount() != 0 || mProp.adminMqf.GetCount()  != 0  || mProp.responseMqf.GetCount()  !=0)
	{
		 //
        // Build DUMMY Debug header
        //
        pBase->IncludeDebug(TRUE);
	    CDebugSection * pDebug = new (pSection) CDebugSection(&mProp.DebugQueue);
        pSection = pDebug->GetNextSection();

        //
        // Build Destination MQF header
        //
        pUser->IncludeMqf(true);

        const USHORT x_DESTINATION_MQF_HEADER_ID = 100;
        CBaseMqfHeader * pDestinationMqf = new (pSection) CBaseMqfHeader(
                                                              mProp.destMqf.GetQueueFormats(),
                                                              mProp.destMqf.GetCount(),
                                                              x_DESTINATION_MQF_HEADER_ID
                                                              );
        pSection = pDestinationMqf->GetNextSection();

        //
        // Build Admin MQF header
        //
        const USHORT x_ADMIN_MQF_HEADER_ID = 200;
        CBaseMqfHeader * pAdminMqf = new (pSection) CBaseMqfHeader(
                                                        mProp.adminMqf.GetQueueFormats(),
                                                        mProp.adminMqf.GetCount(),
                                                        x_ADMIN_MQF_HEADER_ID
                                                        );
        pSection = pAdminMqf->GetNextSection();

        //
        // Build Response MQF header
        //
        const USHORT x_RESPONSE_MQF_HEADER_ID = 300;
        CBaseMqfHeader * pResponseMqf = new (pSection) CBaseMqfHeader(
														   mProp.responseMqf.GetQueueFormats(),
														   mProp.responseMqf.GetCount(),
														   x_RESPONSE_MQF_HEADER_ID
														   );
        pSection = pResponseMqf->GetNextSection();

		//
		// Build MQF Signature header
		//
		//
		const USHORT x_MQF_SIGNATURE_HEADER_ID = 350;
		CMqfSignatureHeader * pMqfSignature = new (pSection) CMqfSignatureHeader(
			                                                     x_MQF_SIGNATURE_HEADER_ID,
			                                                     0,
																 NULL
																 );
		pSection = pMqfSignature->GetNextSection();
                       

	}

	
	//
	// Build EOD ack section
	//
	if (mProp.EodAckStreamId != NULL)
    {
       	pUser->IncludeEodAck(TRUE);
		const USHORT x_EOD_ACK_ID = 700;
	    UCHAR* pStreamid = (UCHAR*)mProp.EodAckStreamId;
		DWORD  StreamidLen = (wcslen(mProp.EodAckStreamId) +1) * sizeof(WCHAR); 
		CEodAckHeader* EodAckHeader = new (pSection) CEodAckHeader(
												   x_EOD_ACK_ID,	
                                                   &mProp.EodAckseqId,
												   &mProp.EodAckseqNo,
												   StreamidLen,
												   pStreamid
												   );


	   pSection  = EodAckHeader->GetNextSection();
	   										
   }

   if(mProp.fEod)
   {
		const UCHAR xDumyStream[] = "Dumy stream";
	    CSenderStream SenderStream(xDumyStream, STRLEN(xDumyStream));
		pUser->IncludeSenderStream(TRUE);
		const USHORT x_SENDER_STREAM_SECDTION_ID = 1000;
		CSenderStreamHeader* pSenderStreamHeader = new (pSection) CSenderStreamHeader(
														 SenderStream,
                                                         x_SENDER_STREAM_SECDTION_ID
                                                         );

		pSection = pSenderStreamHeader->GetNextSection();
   }


   #pragma POP_NEW

}


UCHAR ackType[] = {
    MQMSG_ACKNOWLEDGMENT_NONE,
    MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL,
    MQMSG_ACKNOWLEDGMENT_POS_RECEIVE,
    MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE
};

UCHAR auditingType[] = {
    MQMSG_JOURNAL_NONE,
    MQMSG_DEADLETTER,
    MQMSG_JOURNAL,
    MQMSG_JOURNAL | MQMSG_DEADLETTER,
}; 

static
void
GenerateMqf(
	CFnMqf* pmqf
	)
{
	if( (rand() % 2) == 0)
		return;

	const WCHAR* Mqf[] = {L"direct=http://msmq\\gilsh10\\private$\\t,direct=http://msmq\\gilsh10\\private$\\t2",
						  L"direct=os:gilsh10\\private$\\<>t,direct=os:gilsh10\\private$\\t2",
						  L"direct=https://gilsh10\\msmq\\private$\\t>,direct=os:gilsh10\\private$\\t2"
						};
							
	size_t index = 	rand()%TABLE_SIZE(Mqf);
	pmqf->CreateFromMqf(Mqf[index]);		
}


static
VOID
SetMessageProperties(
    CProperties& mProp
    )
{
    UuidCreate(&mProp.sourceId);
    mProp.destId = GUID_NULL;

    mProp.pDestQueue = GenerateQueueFormat(true);
    mProp.pResponseQueue = GenerateQueueFormat(false);
	GenerateMqf(&mProp.destMqf);
	GenerateMqf(&mProp.adminMqf);
	GenerateMqf(&mProp.responseMqf);

   

    mProp.messageId.Lineage = mProp.sourceId;
    mProp.messageId.Uniquifier = rand();

    mProp.absoluteTimeToQueue = ((rand() % 3) == 0) ? rand() : LONG_MAX - xDeltaInqueue; 
	if(mProp.absoluteTimeToQueue > 	 LONG_MAX - xDeltaInqueue)
	{
		mProp.absoluteTimeToQueue = LONG_MAX - xDeltaInqueue;
	}
	

    time_t sentTime;
    time(&sentTime);
    mProp.sentTime = LOW_DWORD(sentTime);

    mProp.delivery = (UCHAR)(((rand() % 2) == 0) ? MQMSG_DELIVERY_EXPRESS : MQMSG_DELIVERY_RECOVERABLE);
    mProp.fTrace = ((rand() % 4) == 0);

    mProp.acknowledgeType = ackType[rand() % TABLE_SIZE(ackType)];
    if (mProp.acknowledgeType != MQMSG_ACKNOWLEDGMENT_NONE)
    {
        mProp.pAdminQueue = GenerateQueueFormat(false);
    }


    mProp.classValue = MQMSG_CLASS_NORMAL;
    mProp.applicationTag = rand();

    mProp.auditing = auditingType[rand() % TABLE_SIZE(auditingType)];
    mProp.priority = 3;
    UuidCreate(&mProp.connectorType);

    mProp.fEod = ((rand() %3) == 0);
    if (mProp.fEod)
    {
        mProp.delivery = MQMSG_DELIVERY_RECOVERABLE;

        mProp.seqId = rand();
        mProp.seqNo = rand();
        mProp.prevSeqNo = mProp.seqNo - 1;
        mProp.fFirst = ((rand() % 2) == 0);
        mProp.fLast = ((rand() % 2) == 0);
        if ((rand() % 2) == 0)
        {
            UuidCreate(&mProp.connectorId);
        }
        else
        {  
            mProp.connectorId = GUID_NULL;
        }
    }
	else
	{
		if((rand() %2) == 0)
		{
			mProp.EodAckseqId = 0x12345678;
			mProp.EodAckseqNo  = 22;
			mProp.EodAckStreamId = L"acked stream id";
			mProp.classValue = MQMSG_CLASS_ORDER_ACK;
		}
	}

    mProp.titleLength = STRLEN(xTitle) + 1;
    mProp.pTitle = xTitle;

    mProp.extensionSize = STRLEN(xExtension);
    mProp.pExtension = xExtension;

	
	mProp.bodyType = rand();
	mProp.bodySize = STRLEN(xBody);
	mProp.pBody =  xBody;
	
	

    for (DWORD i = 0; i < PROPID_M_CORRELATIONID_SIZE; ++i)
    {
        mProp.correlation[i] = static_cast<UCHAR>(i); 
    }

    mProp.senderCertSize = 0;
    mProp.pSenderCert = NULL;

    mProp.signatureSize = 0;
    mProp.pSignature = NULL;

    mProp.fDefaultProvider = true;
}


CBaseHeader* CreatePacket(void)
{
    CProperties mProp;

    SetMessageProperties(mProp);

    DWORD packetSize = CalculatePacketSize(mProp);

    PUCHAR pkt = new UCHAR[packetSize];

    BuildPacket(reinterpret_cast<CBaseHeader*>(pkt), packetSize, mProp);
	
    return reinterpret_cast<CBaseHeader*>(pkt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\msm\lib\msmlisten.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmListen.cpp

Abstract:
    Multicast Listener implementation

Author:
    Shai Kariv (shaik) 05-Sep-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <winsock.h>
#include <Mswsock.h>
#include <WsRm.h>
#include <Cm.h>
#include "MsmListen.h"
#include "MsmReceive.h"
#include "Msmp.h"

#include <strsafe.h>

#include "msmlisten.tmh"

static void MsmpDumpPGMReceiverStats(const SOCKET s);
static CTimeDuration s_AcceptRetryTimeout( 10 * 1000 * CTimeDuration::OneMilliSecond().Ticks() );
static CTimeDuration s_ReceiverCleanupTimeout( 120 * 1000 * CTimeDuration::OneMilliSecond().Ticks() );

void MsmpInitConfiguration(void)
{
    CmQueryValue(
        RegEntry(NULL, L"MulticastAcceptRetryTimeout", 10 * 1000),   // 10 seconds
        &s_AcceptRetryTimeout
        );
                      
    CmQueryValue(
        RegEntry(NULL, L"MulticastReceiversCleanupTimeout", 120 * 1000),  // 2 minutes 
        &s_ReceiverCleanupTimeout
        );
}


CMulticastListener::CMulticastListener(
    MULTICAST_ID id
    ):
    m_MulticastId(id),
    m_ov(AcceptSucceeded, AcceptFailed),
    m_retryAcceptTimer(TimeToRetryAccept),
	m_cleanupTimer(TimeToCleanupUnusedReceiever),
	m_fCleanupScheduled(FALSE)
/*++

Routine Description:
    Bind to multicast group. Schedule async accept on the socket.

Arguments:
    id - The multicast group IP address and port.

Returned Value:
    None.

--*/
{
    TrTRACE(NETWORKING, "Create multicast listener for %d:%d", id.m_address, id.m_port);

    DWORD flags = WSA_FLAG_MULTIPOINT_C_LEAF | WSA_FLAG_MULTIPOINT_D_LEAF | WSA_FLAG_OVERLAPPED;
    *&m_ListenSocket = WSASocket(AF_INET, SOCK_RDM, IPPROTO_RM, NULL, 0, flags);
    if (m_ListenSocket == INVALID_SOCKET)
    {
        DWORD ec = WSAGetLastError();

        TrERROR(NETWORKING, "Failed to create PGM listen socket, error %d", ec);
        throw bad_win32_error(ec);
    }

    SOCKADDR_IN address;
    address.sin_family = AF_INET;
    address.sin_port   = htons(numeric_cast<u_short>(m_MulticastId.m_port));
    address.sin_addr.s_addr = m_MulticastId.m_address;

    BOOL reuse = TRUE;
    int rc = setsockopt(m_ListenSocket, SOL_SOCKET, SO_REUSEADDR, (char *)&reuse, sizeof(reuse)); 
    if (rc == SOCKET_ERROR)
    {
        DWORD ec = WSAGetLastError();

        TrERROR(NETWORKING, "Failed to setsockopt to PGM socket. %!winerr!", ec);
        throw  bad_win32_error(ec);
    }
    	
	rc = bind(m_ListenSocket, (SOCKADDR *)&address, sizeof(address));
    if (rc == SOCKET_ERROR)
    {
        DWORD ec = WSAGetLastError();

        TrERROR(NETWORKING, "Failed to bind to PGM socket, error %d", ec);
        throw bad_win32_error(ec);
    }
    
	rc = listen(m_ListenSocket, 1);
    if (rc == SOCKET_ERROR)
    {
        DWORD ec = WSAGetLastError();

        TrERROR(NETWORKING, "Failed to listen to PGM socket, error %d", ec);
        throw  bad_win32_error(ec);
    }

    ExAttachHandle(reinterpret_cast<HANDLE>(*&m_ListenSocket));

    //
    // Begin aynchronous accept, to insure failure overcome
    //
    AddRef();
    ExSetTimer(&m_retryAcceptTimer, CTimeDuration(0));
} 


void
CMulticastListener::IssueAccept(
    void
    )
/*++

Routine Description:
    Issue async accept request.

Arguments:
    None.

Returned Value:
    None.

--*/
{
  	ASSERT(m_ReceiveSocket == INVALID_SOCKET);

    DWORD flags = WSA_FLAG_MULTIPOINT_C_LEAF | WSA_FLAG_MULTIPOINT_D_LEAF | WSA_FLAG_OVERLAPPED;
	*&m_ReceiveSocket = WSASocket(AF_INET, SOCK_RDM, IPPROTO_RM, NULL, 0, flags);
    if (m_ReceiveSocket == INVALID_SOCKET)
    {
        DWORD rc = WSAGetLastError();

        TrERROR(NETWORKING, "Failed to create PGM receive socket, error %d", rc);
        throw bad_win32_error(rc);
    }

    //
    // Get the CS so no one will close the listner while we try to accept
    //
    CS lock(m_cs);

	if(m_ListenSocket == INVALID_SOCKET)
	{
		m_ReceiveSocket.free();
		return;
	}

    //
    // Increment ref count on this object.
    // The completion routines decrement the ref count.
    //
    R<CMulticastListener> ref = SafeAddRef(this);
    
    DWORD BytesReceived;
    BOOL f = AcceptEx(
                m_ListenSocket, 
                m_ReceiveSocket, 
                m_AcceptExBuffer, 
                0, 
                40, 
                40, 
                &BytesReceived, 
                &m_ov
                );

    DWORD rc = WSAGetLastError();
    if (!f && rc != ERROR_IO_PENDING)
    {
        TrERROR(NETWORKING, "Failed to issue AcceptEx on socket, error %d", rc);
		m_ReceiveSocket.free();
        throw bad_win32_error(rc);
    }

    //
    // All went well. Completion routines will complete the work.
    //
    ref.detach();
} 



void
CMulticastListener::AcceptSucceeded(
    void
    )
{
	//
	// These pointers don't leak since they are assigned by GetAcceptExSockaddrs to point into the 
	// buffer m_AcceptExBuffer
	//
	SOCKADDR* localSockAddr;
	SOCKADDR* remoteSockAddr;

	int localSockaddrLength, remoteSockaddrLength; 
	GetAcceptExSockaddrs(
		m_AcceptExBuffer,
		0,
		40, 
		40,
		&localSockAddr,
		&localSockaddrLength,
		&remoteSockAddr,
		&remoteSockaddrLength
		);


	WCHAR storeRemoteAddr[256] = L"";
	LPSTR remoteAddr = inet_ntoa((reinterpret_cast<sockaddr_in*>(remoteSockAddr))->sin_addr);
	if (remoteAddr != NULL)
	{
		HRESULT hr = StringCchPrintf(storeRemoteAddr, TABLE_SIZE(storeRemoteAddr), L"%hs", remoteAddr);
		ASSERT(("Address buffer is too small", SUCCEEDED(hr)));
		UNREFERENCED_PARAMETER(hr);
	}

    //
    // Get the receive socket to local variable.
    // The member receive socket is detached so that we can reissue async accept.
    //
    CSocketHandle socket(m_ReceiveSocket.detach());

    try
    {
        IssueAccept();
    }
    catch (const bad_win32_error& )
    {
        AddRef();
        ExSetTimer(&m_retryAcceptTimer, s_AcceptRetryTimeout);
    }  

    //
    // Pass responsibility on Auto socket to the receiver. Don't call detach.
    //
    CreateReceiver(socket, storeRemoteAddr);
}


void 
WINAPI 
CMulticastListener::AcceptSucceeded(
    EXOVERLAPPED* pov
    )
{
    ASSERT(SUCCEEDED(pov->GetStatus()));
    R<CMulticastListener> pms = CONTAINING_RECORD(pov, CMulticastListener, m_ov);

    pms->AcceptSucceeded();

} 


void
CMulticastListener::AcceptFailed(
    void
    )
{
    
    MsmpDumpPGMReceiverStats(m_ListenSocket);
    //
    // Failed to issue an accept. secudel accept retry
    //
    AddRef();
    ExSetTimer(&m_retryAcceptTimer, s_AcceptRetryTimeout);
} 


void 
WINAPI 
CMulticastListener::AcceptFailed(
    EXOVERLAPPED* pov
    )
{
    ASSERT(FAILED(pov->GetStatus()));
    TrERROR(NETWORKING, "Accept failed, error %d", pov->GetStatus());

    R<CMulticastListener> pms = CONTAINING_RECORD(pov, CMulticastListener, m_ov);

    pms->AcceptFailed();

}


void 
CMulticastListener::RetryAccept(
    void
    )
{
    //
    // Check listner validity. If the listener already closed, don't try to issue a new accept.
    //
    if (m_ListenSocket == INVALID_SOCKET)
        return;

    m_ReceiveSocket.free();

    try
    {
        IssueAccept();
    }
    catch (const bad_win32_error& )
    {
        AddRef();
        ExSetTimer(&m_retryAcceptTimer, s_AcceptRetryTimeout);
    }
}


void 
WINAPI 
CMulticastListener::TimeToRetryAccept(
    CTimer* pTimer
    )
{
    R<CMulticastListener> pms = CONTAINING_RECORD(pTimer, CMulticastListener, m_retryAcceptTimer);
    pms->RetryAccept();
}


void 
CMulticastListener::CleanupUnusedReceiver(
	void
	)
/*++

Routine Description:
    Cleanup unused receivers.  The routine scans the receivers and checkes if it was used in 
	the last cleanup interval. If the receiver was in ideal state, the routine shutdown the 
	receiver and remove it from the active receiver list 

Arguments:
    None.

Returned Value:
    None.

Note:
	The routine rearm the cleanup timer if still has an active receivers.
--*/
{
	//
	// Get the critical secction, so no other thread will chnage the receiver list
	// while the routine scans the list
	//
	CS lock(m_cs);

    //
    // Check listner validity. If the listener already closed exit
    //
    if (m_ListenSocket == INVALID_SOCKET)
        return;

	//
	// Scan the receiver list
	//
	ReceiversList::iterator it = m_Receivers.begin(); 
    while(it != m_Receivers.end())
	{
		R<CMulticastReceiver> pReceiver = *it;
		
		if(pReceiver->IsUsed())
        { 
			//
			// Mark the receiver as unused. 
			//
			pReceiver->SetIsUsed(false);

            ++it;
            continue;
        }

        //
		// The receiver isn't used. Shut it down and remove the receiver from the list
		//
        TrTRACE(NETWORKING, "Shutdown unused receiver. pr = 0x%p", pReceiver.get());

		pReceiver->Shutdown();
		it = m_Receivers.erase(it);
	}

	//
	// If not exist an active receiver, clear the flag that indicates if 
	// cleanup was scheduled or not
	//
	if (m_Receivers.empty())
	{
		InterlockedExchange(&m_fCleanupScheduled, FALSE);
		return;
	}

	//
	// still has an active receivers, rearm the cleanup timer
	//
	AddRef();
	ExSetTimer(&m_cleanupTimer, s_ReceiverCleanupTimeout);
}


void 
WINAPI 
CMulticastListener::TimeToCleanupUnusedReceiever(
    CTimer* pTimer
    )
{
    R<CMulticastListener> pms = CONTAINING_RECORD(pTimer, CMulticastListener, m_cleanupTimer);

    TrTRACE(NETWORKING, "Call cleanup unused receiever on listener 0x%p", pms.get()); 
    pms->CleanupUnusedReceiver();
}


void
CMulticastListener::CreateReceiver(
    CSocketHandle& socket,
	LPCWSTR remoteAddr
    )
/*++

Routine Description:
    Create a new receiver object and start receive.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    R<CMulticastReceiver> pReceiver = new CMulticastReceiver(socket, m_MulticastId, remoteAddr);

    try
    {
		CS lock(m_cs);
        m_Receivers.push_back(pReceiver);
    }
    catch (const bad_alloc&)
    {
        TrERROR(NETWORKING, "Failed to insert to list of receivers");
        pReceiver->Shutdown();

        throw;
    }

	if (InterlockedExchange(&m_fCleanupScheduled, TRUE) == FALSE)
	{
		AddRef();
		ExSetTimer(&m_cleanupTimer, s_ReceiverCleanupTimeout);
	}
} 


void
CMulticastListener::Close(
    void
    ) 
    throw()
/*++

Routine Description:

    Stop listen on the multicast group address. Close all receivers.

Arguments:

    None.

Returned Value:

    None.

--*/
{
    CS lock(m_cs);

    if (m_ListenSocket == INVALID_SOCKET)
    {
        //
        // The receiver already closed
        //
        ASSERT(m_Receivers.empty());

        return;
    }

    //
    // Try to cancel the accept retry. If succeeded decrement the reference count
    //
    if (ExCancelTimer(&m_retryAcceptTimer))
    {
        Release();
    }

	//
	// Try to cancel cleanup timer
	//
	if (ExCancelTimer(&m_cleanupTimer))
    {
        Release();
    }

    MsmpDumpPGMReceiverStats(m_ListenSocket);
    
    //
    // Stop listening
    //
    closesocket(m_ListenSocket.detach());

    //
    // Close receivers
    //
    ReceiversList::iterator it;
    for (it = m_Receivers.begin(); it != m_Receivers.end(); )
    {
        (*it)->Shutdown();
		it = m_Receivers.erase(it); 
    }
}







void MsmpDumpPGMReceiverStats(const SOCKET s) 
/*++

Routine Description:

	Get statistic information from the PGM sockets.

Arguments:

    socket - PGM socket.

Returned Value:

    None.

--*/
{
	if(!WPP_LEVEL_COMPID_ENABLED(rsTrace, NETWORKING))
    {
		return;
	}
		
	RM_RECEIVER_STATS	RmReceiverStats;
	INT BufferLength = sizeof(RM_RECEIVER_STATS);
	memset(&RmReceiverStats,0,BufferLength);
	ULONG ret = getsockopt( s, IPPROTO_RM, RM_RECEIVER_STATISTICS,(char *)&RmReceiverStats,&BufferLength);
	if ( ERROR_SUCCESS != ret )
	{
		TrERROR(NETWORKING, "GetReceiverStats: Failed to retrieve receiver stats! error = %d",WSAGetLastError());
		return;
	}
	TrTRACE(NETWORKING,"NumODataPacketsReceived = <%I64d>",RmReceiverStats.NumODataPacketsReceived);
	TrTRACE(NETWORKING,"NumRDataPacketsReceived = <%I64d>",RmReceiverStats.NumRDataPacketsReceived);
	TrTRACE(NETWORKING,"NumDuplicateDataPackets = <%I64d>",RmReceiverStats.NumDuplicateDataPackets);
	TrTRACE(NETWORKING,"DataBytesReceived       = <%I64d>",RmReceiverStats.DataBytesReceived);
	TrTRACE(NETWORKING,"TotalBytesReceived      = <%I64d>",RmReceiverStats.TotalBytesReceived);
	TrTRACE(NETWORKING,"RateKBitsPerSecOverall  = <%I64d>",RmReceiverStats.RateKBitsPerSecOverall);
	TrTRACE(NETWORKING,"RateKBitsPerSecLast     = <%I64d>",RmReceiverStats.RateKBitsPerSecLast);
	TrTRACE(NETWORKING,"TrailingEdgeSeqId       = <%I64d>",RmReceiverStats.TrailingEdgeSeqId);
	TrTRACE(NETWORKING,"LeadingEdgeSeqId        = <%I64d>",RmReceiverStats.LeadingEdgeSeqId);
	TrTRACE(NETWORKING,"AverageSequencesInWindow= <%I64d>",RmReceiverStats.AverageSequencesInWindow);
	TrTRACE(NETWORKING,"MinSequencesInWindow    = <%I64d>",RmReceiverStats.MinSequencesInWindow);
	TrTRACE(NETWORKING,"MaxSequencesInWindow    = <%I64d>",RmReceiverStats.MaxSequencesInWindow);
	TrTRACE(NETWORKING,"FirstNakSequenceNumber  = <%I64d>",RmReceiverStats.FirstNakSequenceNumber);
	TrTRACE(NETWORKING,"NumPendingNaks          = <%I64d>",RmReceiverStats.NumPendingNaks);
	TrTRACE(NETWORKING,"NumOutstandingNaks      = <%I64d>",RmReceiverStats.NumOutstandingNaks);
	TrTRACE(NETWORKING,"NumDataPacketsBuffered  = <%I64d>",RmReceiverStats.NumDataPacketsBuffered);
	TrTRACE(NETWORKING,"TotalSelectiveNaksSent  = <%I64d>",RmReceiverStats.TotalSelectiveNaksSent);
	TrTRACE(NETWORKING,"TotalParityNaksSent     = <%I64d>",RmReceiverStats.TotalParityNaksSent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\msm\lib\msmbind.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmBind.cpp

Abstract:
    Multicast Session Manager bind queue to multicast address implementation.

Author:
    Shai Kariv (shaik) 10-Sep-00

Environment:
    Platform-independent.

--*/

#include <libpch.h>
#include <mqwin64a.h>
#include <mqsymbls.h>
#include <qformat.h>
#include <mqformat.h>
#include "Msm.h"
#include "Msmp.h"
#include "MsmListen.h"
#include "MsmMap.h"

#include "msmbind.tmh"

using namespace std;

static bool s_fDisconnect = false;

//
// Critcal section uses to synchronize bind and unbind operation
// 
static CCriticalSection s_csBindUnbind(CCriticalSection::xAllocateSpinCount);

static
void
MsmpCreateListener(
    const QUEUE_FORMAT& QueueFormat,
    MULTICAST_ID        MulticastId
    )
/*++

Routine Description:
    Bind queue to multicast group.
    It is expected that the queue is not currently bound to any group.

Arguments:
    QueueFormat - Identifies the queue.
    MulticastId - Identifies the multicast group (address and port).

Returned Value:
    None.

--*/
{
    //
    // Create a multicast listener object to listen on the address
    //
    R<CMulticastListener> pListener = new CMulticastListener(MulticastId);
    
    //
    // Add the <queue, listener> pair to the mapping database
    //
    try
    {
        MsmpMapAdd(QueueFormat, MulticastId, pListener);
    }
    catch (const exception&)
    {
        pListener->Close();
        throw;
    }

}


void
MsmBind(
    const QUEUE_FORMAT& QueueFormat,
    MULTICAST_ID        MulticastId
    )
/*++

Routine Description:

    Bind or rebind a queue to the specified multicast group.

Arguments:

    QueueFormat - Identifier of the queue.

    MulticastId - Identifier of the multicast group (address and port).

Returned Value:

    None. Throws exception.

--*/
{
    MsmpAssertValid();

    ASSERT((
        "Only private and public queues format names expected!", 
        QueueFormat.GetType() == QUEUE_FORMAT_TYPE_PRIVATE || QueueFormat.GetType() == QUEUE_FORMAT_TYPE_PUBLIC
        ));

    //
    // Ensure that no other thread tries to bind or unbind at the smae time. It can
    // cause database inconsistency.
    //
    CS lock(s_csBindUnbind);

	//
	// The multicast is in disconnect state so no message is received. Later when 
	// it becomes connect again all the queues rebinds 
	//
	if (s_fDisconnect)
		return;

    //
    // Look for previous binding of the queue. If the queue already bind to same
    // address no further acction is required. Otherwise before binding to the new 
    // address the code unbind to previous address 
    //
    MULTICASTID_VALUES bindedIds = MsmpMapGetBoundMulticastId(QueueFormat);
    if (!bindedIds.empty())
    {
        ASSERT(("Queue can't be bounded to more than one multicast address", (bindedIds.size() == 1)));

        MULTICAST_ID bindId = *(bindedIds.begin());
        if (MulticastId.m_address == bindId.m_address &&
            MulticastId.m_port == bindId.m_port)
        {
            //
            // Already bound to the specified multicast group. No-op.
            //
            return;
        }

        //
        // Unbind the queue. 
        //
        MsmUnbind(QueueFormat);
    }

    WCHAR strQueueFormat[256];
    DWORD temp;

    MQpQueueFormatToFormatName(&QueueFormat, strQueueFormat, TABLE_SIZE(strQueueFormat), &temp, FALSE);
    TrTRACE(NETWORKING, "Bind queue %ls to multicast id %d:%d", strQueueFormat, MulticastId.m_address, MulticastId.m_port);

    //
    // Look for existing listenr for multicast address
    //
    R<CMulticastListener> pListener = MsmpMapGetListener(MulticastId);

    //
    // Listener already exist. Only add the queue format to the map
    //
    if (pListener.get() != NULL)
    {
        MsmpMapAdd(QueueFormat, MulticastId, pListener);
        return;
    }

    //
    // A new listener is required
    //
    MsmpCreateListener(QueueFormat, MulticastId);
} 


VOID
MsmUnbind(
    const QUEUE_FORMAT& QueueFormat
    )
    throw()
/*++

Routine Description:

    Unbind queue from the multicast group it is currently bound to.

Arguments:

    QueueFormat - Identies the queue.

Returned Value:

    None.

--*/
{
    MsmpAssertValid();

    ASSERT((
        "Only private and public queues format names expected!", 
        QueueFormat.GetType() == QUEUE_FORMAT_TYPE_PRIVATE || QueueFormat.GetType() == QUEUE_FORMAT_TYPE_PUBLIC
        ));

    //
    // Ensure that no other thread tries to bind or unbind at the smae time. It can
    // cause database inconsistency.
    //
    CS lock(s_csBindUnbind);

    #ifdef _DEBUG
        WCHAR strQueueFormat[256];
        DWORD temp;

        MQpQueueFormatToFormatName(&QueueFormat, strQueueFormat, TABLE_SIZE(strQueueFormat), &temp, FALSE);
        TrTRACE(NETWORKING, "UnBind queue %ls to assigned multicast address", strQueueFormat);
    #endif

    //
    // Remove the <queue, listener> pair from mapping database
    //
    MsmpMapRemove(QueueFormat);
} 


VOID
MsmDisconnect(
    VOID
    )
    throw()
/*++

Routine Description:

    Disconnect all the listner and receiver from the network. So no message is received

Arguments:

    None.

Returned Value:

    None.

--*/
{
    MsmpAssertValid();

    //
    // Ensure that no other thread tries to bind or unbind at the smae time. It can
    // cause database inconsistency.
    //
    CS lock(s_csBindUnbind);

	if(s_fDisconnect)
		return;

	s_fDisconnect = true;

    //
    // Remove all the multicast queues from the DS. As a result all the listner are closed
    //
    MsmpMapRemoveAll();

	TrTRACE(NETWORKING, "Multicast disconnection. No further multicast messages are received until the multicast connect again");
}


VOID
MsmConnect(
    VOID
    )
/*++

Routine Description:

    connect all the multicast queues

Arguments:

    None.

Returned Value:

    None.

--*/
{
    MsmpAssertValid();

    //
    // Ensure that no other thread tries to bind or unbind at the smae time. It can
    // cause database inconsistency.
    //
    CS lock(s_csBindUnbind);

	if (!s_fDisconnect)
		return;

	s_fDisconnect = false;

	AppConnectMulticast();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\msm\lib\msmp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Msmp.h

Abstract:
    Multicast Session Manager private functions.

Author:
    Shai Kariv (shaik) 05-Sep-00

--*/

#pragma once

#ifndef _MSMQ_Msmp_H_
#define _MSMQ_Msmp_H_

#include <rwlock.h>
#include <mqexception.h>


#ifdef _DEBUG

void MsmpAssertValid(void);
void MsmpSetInitialized(void);
BOOL MsmpIsInitialized(void);
void MsmpRegisterComponent(void);

#else // _DEBUG

#define MsmpAssertValid() ((void)0)
#define MsmpSetInitialized() ((void)0)
#define MsmpIsInitialized() TRUE
#define MsmpRegisterComponent() ((void)0)

#endif // _DEBUG

void MsmpInitConfiguration(void);


#endif // _MSMQ_Msmp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\msm\lib\msmlisten.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmListen.h

Abstract:
    Multicast Listener declaration

Author:
    Shai Kariv (shaik) 05-Sep-00

--*/

#pragma once

#ifndef _MSMQ_MsmListen_H_
#define _MSMQ_MsmListen_H_

#include <mqwin64a.h>
#include <qformat.h>
#include <Ex.h>
#include "MsmReceive.h"


class CMulticastListener : public CReference
{
public:
    typedef std::list< R<CMulticastReceiver> > ReceiversList;

public:

    //
    // Constructor. Create the object and bind to the multicast group.
    //
    CMulticastListener(MULTICAST_ID id);

    //
    // Close the listener
    //
    void Close(void) throw();

    //
    // Return the multicast address and port
    //
    const MULTICAST_ID& MulticastId(void) const throw() 
    { 
        return m_MulticastId; 
    }

    //
    // Async accept completion handlers, class scope.
    //
    static void WINAPI AcceptSucceeded(EXOVERLAPPED* pov);
    static void WINAPI AcceptFailed(EXOVERLAPPED* pov);

    static void WINAPI TimeToRetryAccept(CTimer* pTimer);
    static void WINAPI TimeToCleanupUnusedReceiever(CTimer* pTimer);

private:

    //
    // Async accept completion handlers
    //
    void AcceptSucceeded(void);
    void AcceptFailed(void);
    void RetryAccept(void);

    //
    // Issue async accept request
    //
    void IssueAccept(void);

    //
    // Create a new receiver object and start receiving
    //
    void CreateReceiver(CSocketHandle& socket, LPCWSTR remoteAddr);

	void CleanupUnusedReceiver(void);

private:
    CCriticalSection m_cs;

    //
    // The multicast address and port
    //
    MULTICAST_ID m_MulticastId;

    //
    // This socket listens to the multicast address
    //
    CSocketHandle m_ListenSocket;

    //
    // This socket is used for receive. It is asynchronous variable that store 
    // in the object untill the asynchronous accept is completed
    //
    CSocketHandle m_ReceiveSocket;

    //
    // Async accept overlapped
    //
    EXOVERLAPPED m_ov;

    //
    // The connections to the multicast group
    //
    ReceiversList m_Receivers;

    CTimer m_retryAcceptTimer;

	LONG m_fCleanupScheduled;
	CTimer m_cleanupTimer;
	BYTE  m_AcceptExBuffer[100];

}; 

#endif // _MSMQ_MsmListen_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\msm\lib\msmreceive.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmReceive.cpp

Abstract:
    Multicast Receiver implementation

Author:
    Shai Kariv (shaik) 12-Sep-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <msi.h>
#include <mqwin64a.h>
#include <qformat.h>
#include <qmpkt.h>
#include <No.h>
#include "MsmListen.h"
#include "MsmReceive.h"
#include "MsmMap.h"
#include "Msm.h"
#include "Msmp.h"
#include "msi.h"
#include <mqsymbls.h>
#include <mqformat.h>

#include "msmreceive.tmh"

using namespace std;

//
// ISSUE-2000/10/17-urih must move DataTransferLength, FindEndOfResponseHeader and
// GetContentLength to global library (http library).
//


inline DWORD DataTransferLength(EXOVERLAPPED& ov)
{
    //
    // In win64, InternalHigh is 64 bits. Since the max chunk of data
    // we transfer in one operation is always less than MAX_UNIT we can cast
    // it to DWORD safetly
    //
    ASSERT(0xFFFFFFFF >= ov.InternalHigh);
	return static_cast<DWORD>(ov.InternalHigh);
}


DWORD CMulticastReceiver::FindEndOfResponseHeader(LPCSTR buf, DWORD length)
{
    if (4 > length)
        return 0;

    for(DWORD i = 0; i < length - 3; ++i)
    {
        if (buf[i] != '\r')
            continue;

        if ((buf[i+1] == '\n') && (buf[i+2] == '\r') && (buf[i+3] == '\n'))
        {
            return (i + 4);
        }
    }

    return 0;
}


const char xContentlength[] = "Content-Length:";

DWORD CMulticastReceiver::GetContentLength(LPCSTR p, DWORD length)
{
    const LPCSTR pEnd = p + length - 4;

    //
    // HTTP header must terminate with '\r\n\r\n'. We already parse
    // the header and find it as a legal HTTP header.
    //
    ASSERT(length >= 4);
    ASSERT(strncmp(pEnd, "\r\n\r\n", 4) == 0);


    while (p + STRLEN(xContentlength) < pEnd)
    {
        if (_strnicmp(p, xContentlength , STRLEN(xContentlength)) == 0)
		{
            DWORD cl = 0;
			_snscanf(p + STRLEN(xContentlength), pEnd - (p + STRLEN(xContentlength)), "%u", &cl);
			if(cl == 0)
			{
				TrERROR(NETWORKING, "Illegal HTTP header. Illegal Content-Length in http header");
				throw exception();
			}
			
			return cl;
		}

        for(;;)
        {
            if ((p[0] == '\r') && (p[1] == '\n'))
            {
                p += 2;
                break;
            }

            ++p;
        }
    }

    //
    // Response header doesn't contain 'Content-Length' field. 
    //
    TrERROR(NETWORKING, "Illegal HTTP header. Content-Length field wasn't found");
    throw exception();
}


void WINAPI CMulticastReceiver::ReceiveFailed(EXOVERLAPPED* pov)
/*++

Routine Description:
    Callback routine. The routine is called when receive of respond failed
  
Arguments:
    pov - Pointer to EXOVERLAPPED
    
Returned Value:
    None.

--*/
{
    ASSERT(FAILED(pov->GetStatus()));


    //
    // get the message transport object
    //
    R<CMulticastReceiver> pmt = CONTAINING_RECORD(pov, CMulticastReceiver, m_ov);

    TrERROR(NETWORKING, "Failed to receive data on multicast socket, shutting down. pmt=0x%p Status=0x%x", pmt.get(), pov->GetStatus());
    pmt->Shutdown();
}


void CMulticastReceiver::ReceiveHeaderSucceeded(void)
/*++

Routine Description:
    The routine is called when receive response completes succesfully.
  
Arguments:
    None
  
Returned Value:
    None.

--*/
{
    //
    // For byte streams, zero bytes having been read indicates graceful closure
    // and that no more bytes will ever be read. 
    //
	DWORD cbTransfered = DataTransferLength(m_ov);
    if (cbTransfered == 0)
    {
        TrERROR(NETWORKING, "Failed to receive response, connection was closed. pmt=0x%p", this);
        throw exception();
    }

    TrTRACE(NETWORKING, "Received header. chunk bytes=%d, total bytes=%d", cbTransfered, m_HeaderValidBytes);

	//
	// Mark the receiver as used, so it will not be close in next cleanup phase
	//
    SetIsUsed(true);

    //
    // Find out if the entire header was received
    //
    m_HeaderValidBytes += cbTransfered;

    m_ProcessedSize = FindEndOfResponseHeader(m_pHeader, m_HeaderValidBytes);
    if (m_ProcessedSize != 0)
    {
		//
		// Update performance counters. Don't use the number of bytes that received since it contains
		// an extra data that recalculates later on ReceiveBodySucceeded function.
		//
		if (m_pPerfmon.get() != NULL)
		{
			m_pPerfmon->UpdateBytesReceived(m_ProcessedSize);
		}

        //
        // The enire header was received. Go and read the attached message
        //
        ReceiveBody();
        return;
    }


    if(m_HeaderAllocatedSize == m_HeaderValidBytes)
    {
        //
        // Header buffer is too small. Reallocate header buffer
        //
        ReallocateHeaderBuffer(m_HeaderAllocatedSize + xHeaderChunkSize);
    }

    //
    // Validate that we didn't read past the buffer
    //
    ASSERT(m_HeaderAllocatedSize > m_HeaderValidBytes);

    //
    // Receive next chunk of response header
    //
    ReceiveHeaderChunk();
}


void WINAPI CMulticastReceiver::ReceiveHeaderSucceeded(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when receive completes succesfully.
  
Arguments:
    pov - Pointer to EXOVERLAPPED
    
Returned Value:
    None.

--*/
{
    ASSERT(SUCCEEDED(pov->GetStatus()));


    //
    // get the receiver object
    //
    R<CMulticastReceiver> pmt = CONTAINING_RECORD(pov, CMulticastReceiver, m_ov);

    try
    {
        pmt->ReceiveHeaderSucceeded();
    }
    catch(const exception&)
    {
        TrERROR(NETWORKING, "Failed to process received response header, shutting down. pmt=0x%p", pmt.get());
        pmt->Shutdown();
        throw;
    }

}


void CMulticastReceiver::ReceiveBodySucceeded(void)
{
	DWORD cbTransfered = DataTransferLength(m_ov);

    //
    // For byte streams, zero bytes having been read indicates graceful closure
    // and that no more bytes will ever be read. 
    //
    if (cbTransfered == 0)
    {
        TrERROR(NETWORKING, "Failed to receive body, connection was closed. pmt=0x%p", this);
        throw exception();
    }

    ASSERT(cbTransfered <= (m_bodyLength - m_readSize));

	//
	// Mark the receiver as used, so it will not be close in next cleanup phase
	//
    SetIsUsed(true);

    m_readSize += cbTransfered;

	//
	// Update performance counters
	//
	if (m_pPerfmon.get() != NULL)
	{
		m_pPerfmon->UpdateBytesReceived(cbTransfered);
	}

    TrTRACE(NETWORKING, "Received body. chunk bytes=%d, bytes remaining=%d", cbTransfered, (m_bodyLength - m_readSize));

    if (m_readSize == m_bodyLength)
    {
		//
		// Pad last four bytes of the buffer with zero. It is needed
		// for the QM parsing not to fail. four bytes padding and not two
		// are needed because we don't have currently solution to the problem
		// that the end of the buffer might be not alligned on WCHAR bouderies.
		//
		memset(&m_pBody[m_bodyLength], 0, 2 * sizeof(WCHAR));

        //
        // The entire body was read successfully, go process this packet.
        //
        ProcessPacket();

        //
        // begin the receive of next packet
        //
        ReceivePacket();
        return;
    }

    //
    // Receive next chunk of entity body
    //
    ReceiveBodyChunk();
}


void WINAPI CMulticastReceiver::ReceiveBodySucceeded(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when receive completes succesfully.
  
Arguments:
    pov - Pointer to EXOVERLAPPED
    
Returned Value:
    None.

--*/
{
    ASSERT(SUCCEEDED(pov->GetStatus()));


    //
    // get the receiver object
    //
    R<CMulticastReceiver> pmt = CONTAINING_RECORD(pov, CMulticastReceiver, m_ov);

    try
    {
        pmt->ReceiveBodySucceeded();
    }
    catch(const exception&)
    {
        TrERROR(NETWORKING, "Failed to process received body, shutting down. pmt=0x%p", pmt.get());
        pmt->Shutdown();
        throw;
    }
}


R<ISessionPerfmon> 
CMulticastReceiver::CreatePerfmonInstance(
	LPCWSTR remoteAddr
	)
{
	try
	{
		WCHAR strMulticastId[MAX_PATH];
		MQpMulticastIdToString(m_MulticastId, strMulticastId, TABLE_SIZE(strMulticastId));

		return AppGetIncomingPgmSessionPerfmonCounters(strMulticastId, remoteAddr);
	}
	catch(const bad_alloc&)
	{
		return NULL;
	}
}


CMulticastReceiver::CMulticastReceiver(
    CSocketHandle& socket,
    const MULTICAST_ID& MulticastId,
	LPCWSTR remoteAddr
    ):
    m_socket(socket.detach()),
    m_MulticastId(MulticastId),
    m_pHeader(new char[xHeaderChunkSize]),
    m_HeaderAllocatedSize(xHeaderChunkSize),
    m_HeaderValidBytes(0),
    m_ProcessedSize(0),
    m_bodyLength(0),
    m_readSize(0),
    m_ov(ReceiveHeaderSucceeded, ReceiveFailed),
    m_fUsed(TRUE),
    m_pPerfmon(CreatePerfmonInstance(remoteAddr))
{
    ASSERT(("Must have a valid socket to receive", m_socket != INVALID_SOCKET));
    ExAttachHandle(reinterpret_cast<HANDLE>(*&m_socket));

    ReceivePacket();
}


void CMulticastReceiver::ReallocateHeaderBuffer(DWORD Size)
{
    ASSERT(Size > m_HeaderAllocatedSize);
    char* p = new char[Size];
    memcpy(p, m_pHeader, m_HeaderAllocatedSize);
    m_pHeader.free();
    m_pHeader = p;
    m_HeaderAllocatedSize = Size;
}


void CMulticastReceiver::ReceiveHeaderChunk(void)
{
    ASSERT(("Can't read 0 bytes from the network", ((m_HeaderAllocatedSize - m_HeaderValidBytes) > 0)));

    //
    // Increment refernce count for asynchronous context
    //
    R<CMulticastReceiver> ar = SafeAddRef(this);

    //
    // Protect m_socket from shutdown
    //
    CSR readLock(m_pendingShutdown);

    //
    // Receive next response header chunk
    //
    NoReceivePartialBuffer(
        m_socket, 
        m_pHeader + m_HeaderValidBytes, 
        m_HeaderAllocatedSize - m_HeaderValidBytes, 
        &m_ov
        ); 
    
    ar.detach();
}


DWORD CMulticastReceiver::HandleMoreDataExistInHeaderBuffer(void)
{
    ASSERT(("Body should be exist", (m_pBody.get() != NULL)));

    if (m_HeaderValidBytes == m_ProcessedSize) 
    {
        //
        // All the data already proccessed
        //
        return 0;
    }

    DWORD copySize = min(m_bodyLength,  (m_HeaderValidBytes - m_ProcessedSize));
    memcpy(m_pBody, (m_pHeader + m_ProcessedSize), copySize);
    m_ProcessedSize += copySize;
    
    return copySize;
}


void CMulticastReceiver::ReceiveBodyChunk(void)
{
    ASSERT(("Can't read 0 bytes from the network", ((m_bodyLength - m_readSize) > 0)));

    //
    // Increment refernce count for asynchronous context
    //
    R<CMulticastReceiver> ar = SafeAddRef(this);

    //
    // Protect m_socket
    //
    CSR readLock(m_pendingShutdown);


    //
    // Receive the entity body chunck to the same buffer, as it is ignored
    //
    NoReceivePartialBuffer(
        m_socket, 
        m_pBody + m_readSize, 
        m_bodyLength - m_readSize,
        &m_ov
        ); 

    ar.detach();
}


void CMulticastReceiver::ReceiveBody(void)
{
    //
    // Get the packet size
    //
    m_bodyLength = GetContentLength(m_pHeader, m_ProcessedSize);
    
    ASSERT(("Invalid body length", m_bodyLength != 0));
    ASSERT(("Previous body shouldn't be exist", (m_pBody.get() == NULL)));

    //
    // Allocate buffer for the packet. Allocate more 4 bytes to add null termination.
	// Allocates 4 bytes and not 2 to solve alligned on WCHAR bouderies	problem
    //
    m_pBody = new BYTE[m_bodyLength + 2* sizeof(WCHAR)];
    m_readSize = 0;

    #pragma PUSH_NEW
    #undef new

            new (&m_ov) EXOVERLAPPED(ReceiveBodySucceeded, ReceiveFailed);

    #pragma POP_NEW

    //
    // In previous phase we read more than we needed. Copy the spare data to the header 
    // update the counter and behave like next read is completed
    //
    DWORD extraDataSize = HandleMoreDataExistInHeaderBuffer();

    if (extraDataSize == 0)
    {
        ReceiveBodyChunk();
        return;
    }

    //
    // The body contains data, go and process it before calling reading next chunk
    //
    m_ov.InternalHigh = extraDataSize;
    R<CMulticastReceiver> ar = SafeAddRef(this);

    m_ov.SetStatus(STATUS_SUCCESS);
    ExPostRequest(&m_ov);

    ar.detach();
}


void CMulticastReceiver::ReceivePacket(void)
{
    if (m_HeaderValidBytes > m_ProcessedSize) 
    {
        memmove(m_pHeader, (m_pHeader + m_ProcessedSize), (m_HeaderValidBytes - m_ProcessedSize));
        m_HeaderValidBytes = (m_HeaderValidBytes - m_ProcessedSize);
    }
    else
    {
        m_HeaderValidBytes = 0;
    }

    m_ProcessedSize = 0;


    //
    // Initialize the Overlapped with receive response call back routines
    //
    #pragma PUSH_NEW
    #undef new

        new (&m_ov) EXOVERLAPPED(
                                ReceiveHeaderSucceeded, 
                                ReceiveFailed
                                );

    #pragma POP_NEW

    //
    // Receive first chunk of response header
    //
    ReceiveHeaderChunk();
}


void CMulticastReceiver::ProcessPacket(void)
{
    try
    {
        TrTRACE(NETWORKING, "Receive multicast packet on id %d:%d", m_MulticastId.m_address, m_MulticastId.m_port);

        QUEUEFORMAT_VALUES qf = MsmpMapGetQueues(m_MulticastId);

        //
        // NULL terminate the http header: \r\n\r\n ==> \r\n00
        //
        DWORD end = FindEndOfResponseHeader(m_pHeader, m_HeaderValidBytes);
        if(end < 4)
		{
			TrERROR(NETWORKING, "Header too short in Multicast receiver Process Packet");
			ASSERT(("Header too short in Multicast receiver Process Packet", 0));
			throw exception();
		}

        m_pHeader[end - 2] = 0;
        m_pHeader[end - 1] = 0;

        for(QUEUEFORMAT_VALUES::iterator it = qf.begin(); it != qf.end(); ++it)
        {
            AppAcceptMulticastPacket(m_pHeader.get(), m_bodyLength, m_pBody.get(), *it);
        }

		//
		// Update performance number of the number the response messages
		//
		if (m_pPerfmon.get() != NULL)
		{
			m_pPerfmon->UpdateMessagesReceived();	
		}
    }
    catch(const exception&)
    {
        TrERROR(
            NETWORKING, 
            "Reject multicast packet on %d:%d due to processing failure (queue already unbind or illegal SRM packet", 
            m_MulticastId.m_address, 
            m_MulticastId.m_port
            );
    }

    m_pBody.free();
    m_readSize = 0;
    m_bodyLength = 0;
}


void CMulticastReceiver::Shutdown(void) throw()
{
    //
    // Protect m_socket, m_state 
    //
    CSW writeLock(m_pendingShutdown);

    if (m_socket == INVALID_SOCKET) 
    {
          return;
    }

    closesocket(m_socket.detach());

    //
    // Set the receiver as unused
    //
    SetIsUsed(false);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\msm\lib\msmmap.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmMap.cpp

Abstract:
    Multicast Session to queue mapping implementation.

Author:
    Shai Kariv (shaik) 05-Sep-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <mqwin64a.h>
#include <qformat.h>
#include <Fn.h>
#include <Msm.h>
#include <rwlock.h>
#include <doublekeymap.h>
#include "Msmp.h"
#include "msmmap.h"
#include "MsmListen.h"

#include "msmmap.tmh"

using namespace std;

static CReadWriteLock s_rwlock;

typedef CDoubleKeyMap<QUEUE_FORMAT, MULTICAST_ID, CFunc_QueueFormatCompare, CFunc_MulticastIdCompare > MAP_QF_2_MC;
typedef map<MULTICAST_ID, R<CMulticastListener>, CFunc_MulticastIdCompare> MAP_MC_2_LISTENER;

static MAP_MC_2_LISTENER s_MulticastId2Listner;
static MAP_QF_2_MC s_Queueformat2MulticastId;


MULTICASTID_VALUES
MsmpMapGetBoundMulticastId(
    const QUEUE_FORMAT& QueueFormat
    )
    throw()
{
    CSR lock (s_rwlock);
    return s_Queueformat2MulticastId.get_key2set(QueueFormat);
}


QUEUEFORMAT_VALUES
MsmpMapGetQueues(
    const MULTICAST_ID& multicastId
    )
    throw()
{
    CSR lock (s_rwlock);
    return s_Queueformat2MulticastId.get_key1set(multicastId);
}


R<CMulticastListener>
MsmpMapGetListener(
    const MULTICAST_ID& multicastId
    )
    throw()
{
    CSR lock (s_rwlock);

    MAP_MC_2_LISTENER::iterator it = s_MulticastId2Listner.find(multicastId);
    if (it == s_MulticastId2Listner.end())
        return NULL;

    return it->second;
}


void MsmpMapRemove(const QUEUE_FORMAT& QueueFormat) throw()
{
    CSW lock (s_rwlock);

    //
    // Get a list of Multicast addresses that the Queue is bind too
    //
    MAP_QF_2_MC::KEY2SET multicastIds = s_Queueformat2MulticastId.get_key2set(QueueFormat);

    //
    // The Queue isn't bind to any multicast address
    //
    if (multicastIds.empty())
        return;

    //
    // Remove the mapping between the queue and the multicast address
    //
    s_Queueformat2MulticastId.erase_key1(QueueFormat);

    for (MAP_QF_2_MC::KEY2SET::iterator it = multicastIds.begin(); it != multicastIds.end(); ++it)
    {
        
        //
        // There is at least one more queue that binds to the multicast address. Don't
        // close the listener
        //
        if (! s_Queueformat2MulticastId.key2_empty(*it))
            continue;

        //
        // It is the last queue that is bind to the multicast address. Close
        // the listener and remove it from the map
        //
        MAP_MC_2_LISTENER::iterator itmc = s_MulticastId2Listner.find(*it);
        ASSERT(("Expected listner not found", itmc != s_MulticastId2Listner.end()));

        R<CMulticastListener> pListener = itmc->second;
        pListener->Close();

        s_MulticastId2Listner.erase(itmc);
    }
}


void MsmpMapRemoveAll(void) throw()
{
	//
	// scan all the active listner and remove all the pending queues
	//
	for(;;)
	{
		MULTICAST_ID mid;

		{
			CSR lock (s_rwlock);

			MAP_MC_2_LISTENER::iterator it = s_MulticastId2Listner.begin();
			if (it == s_MulticastId2Listner.end())
				break;
			//
			// Get the multicast address
			//
			mid = s_MulticastId2Listner.begin()->first;

		}

		//
		// Get a list of all the pending queues
		//
        QUEUEFORMAT_VALUES qf = MsmpMapGetQueues(mid);

        for(QUEUEFORMAT_VALUES::iterator it = qf.begin(); it != qf.end(); ++it)
        {
            MsmpMapRemove(*it);
        }
	}
}


void
MsmpMapAdd(
    const QUEUE_FORMAT& QueueFormat,
    const MULTICAST_ID& multicastId,
    R<CMulticastListener>& pListener
    )
{
    CSW lock (s_rwlock);
    s_Queueformat2MulticastId.insert(QueueFormat, multicastId);

    try
    {
        s_MulticastId2Listner[multicastId] = pListener;   
    }
    catch(const exception&)
    {
        s_Queueformat2MulticastId.erase(QueueFormat, multicastId);

        TrERROR(NETWORKING, "Failed to Add a listener to MSM DataBase");
        throw;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\msm\test\msmtest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmTest.cpp

Abstract:
    Multicast Session Manager library test

Author:
    Shai Kariv (shaik) 05-Sep-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <msi.h>
#include <Ex.h>
#include <No.h>
#include <Cm.h>
#include <Msm.h>
#include <spi.h>

#include "MsmTest.tmh"

static DWORD s_FailedRate = 0;
static DWORD s_NoOfMessages = 1000;
static HANDLE s_hEvent;

//
// The guid of a public queue
//
const GUID xQueueId1 = { /* c4f259a1-9c90-42a8-8e83-10e65d084719 */
    0xc4f259a1,
    0x9c90,
    0x42a8,
    {0x8e, 0x83, 0x10, 0xe6, 0x5d, 0x08, 0x47, 0x19}
};

const GUID xQueueId2 = { /* c4f259a1-9c90-42a8-8e83-10e65d084720 */
    0xc4f259a1,
    0x9c90,
    0x42a8,
    {0x8e, 0x83, 0x10, 0xe6, 0x5d, 0x08, 0x47, 0x20}
};

const GUID xQueueId3 = { /* c4f259a1-9c90-42a8-8e83-10e65d084721 */
    0xc4f259a1,
    0x9c90,
    0x42a8,
    {0x8e, 0x83, 0x10, 0xe6, 0x5d, 0x08, 0x47, 0x21}
};

const GUID xQueueId4 = { /* c4f259a1-9c90-42a8-8e83-10e65d084722 */
    0xc4f259a1,
    0x9c90,
    0x42a8,
    {0x8e, 0x83, 0x10, 0xe6, 0x5d, 0x08, 0x47, 0x22}
};

QUEUE_FORMAT q1(xQueueId1);
QUEUE_FORMAT q2(xQueueId2);
QUEUE_FORMAT q3(xQueueId3);
QUEUE_FORMAT q4(xQueueId4);

const MULTICAST_ID xMulticastId1 = { 1234, 5678 };
const MULTICAST_ID xMulticastId2 = { 4567, 1234 };
const MULTICAST_ID xMulticastId3 = { 3893, 2323 };

extern "C"
BOOL
APIENTRY
AcceptEx (
    IN SOCKET,
    IN SOCKET,
    IN PVOID,
    IN DWORD,
    IN DWORD,
    IN DWORD,
    OUT LPDWORD,
    IN LPOVERLAPPED lpOverlapped
    )
{
    ASSERT(lpOverlapped != NULL);

    EXOVERLAPPED* pov = static_cast<EXOVERLAPPED*>(lpOverlapped);

    pov->SetStatus(STATUS_SUCCESS);
    ExPostRequest(pov);

    return TRUE;
}


extern "C"
void
APIENTRY
GetAcceptExSockaddrs( 
  PVOID ,       
  DWORD ,  
  DWORD ,  
  DWORD ,  
  LPSOCKADDR *,  
  LPINT ,  
  LPSOCKADDR *,  
  LPINT   
)
{
}


void CmQueryValue(const RegEntry&, CTimeDuration* pValue)
{
    *pValue = CTimeDuration(rand());
}


bool IsFailed(void)
{
    if (s_FailedRate == 0)
        return FALSE;

    return ((DWORD)(rand() % 100) < s_FailedRate);
}


void
AppAcceptMulticastPacket(
    const char* ,
    DWORD ,
    const BYTE* ,
    const QUEUE_FORMAT& 
    )
{
}


void AppConnectMulticast(void)
{
}


class CSessionPerfmon : public ISessionPerfmon
{
public:
    CSessionPerfmon() : m_fInstanceCreated(false) 
    {
    }

    ~CSessionPerfmon()
    {
    }
    
	void CreateInstance(LPCWSTR)
	{
		m_fInstanceCreated = true;
	}

	void UpdateBytesSent(DWORD )
	{
		ASSERT(m_fInstanceCreated);
	}

	void UpdateMessagesSent(void)
	{
		ASSERT(m_fInstanceCreated);
	}

	void UpdateBytesReceived(DWORD )
	{
		ASSERT(m_fInstanceCreated);
	}

	void UpdateMessagesReceived(void)
    {
		ASSERT(m_fInstanceCreated);
    }

private:
	bool m_fInstanceCreated;
};


R<ISessionPerfmon>
AppGetIncomingPgmSessionPerfmonCounters(
	LPCWSTR strMulticastId,
	LPCWSTR 
	)
{
	R<CSessionPerfmon> pPerfmon = new CSessionPerfmon;
	pPerfmon->CreateInstance(strMulticastId);

	return pPerfmon;
}


void Usage(void)
{
	printf("Usage: msmtest -n <no of messages> [-f xxx] [-h]\n");
    printf("\tn - Number of messages\n");
	printf("\tf - Fail rate\n");
	printf("\th - Print this message\n");
	exit(-1);
}


extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
/*++

Routine Description:
    Test Message Transport library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	TrInitialize();

    --argc;
    ++argv;

    s_FailedRate = 0;
    
    while (argc > 0)
	{
		if (argv[0][0] != L'-') 
			Usage();

		switch(argv[0][1])
		{
            case L'n':
            case L'N':
                s_NoOfMessages = _wtoi(argv[1]);
				argc -= 2;
				argv += 2;
                break;

            case L'f':
			case L'F':
		        s_FailedRate = _wtoi(argv[1]);
				argc -= 2;
				argv += 2;
				break;


            default:
				Usage();
		}
    }

    ExInitialize(5);
    NoInitialize();
    MsmInitialize();


	//
	// Check connect/disconnect
	//
	MsmBind(q1, xMulticastId1);
	MsmBind(q2, xMulticastId2);
	MsmBind(q3, xMulticastId3);
	MsmBind(q4, xMulticastId2);

	MsmDisconnect();
	MsmUnbind(q2);
	MsmBind(q2, xMulticastId2);
	MsmConnect();

    s_hEvent = CreateEvent(NULL, FALSE, FALSE, L"");

    bool fFailed = false;

    do
    {
        try
        {
            MsmBind(q1, xMulticastId1);
        }
        catch(const exception&)
        {
            fFailed = true;
        }
    } while(fFailed);
    
    WaitForSingleObject(s_hEvent, INFINITE);


    WPP_CLEANUP();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\msm\lib\msmmap.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmMap.h

Abstract:
    Multicast Session to queue mapping declaration.

Author:
    Shai Kariv (shaik) 05-Sep-00

--*/

#pragma once

#ifndef _MSMQ_MsmMap_H_
#define _MSMQ_MsmMap_H_


class CMulticastListener;

inline bool operator < (const GUID& k1, const GUID& k2)
{
    return (memcmp(&k1, &k2, sizeof(GUID)) < 0);
}

//
// less function, using to compare QUEUE_FORMAT in STL data structure
//
struct CFunc_QueueFormatCompare : public std::binary_function<const QUEUE_FORMAT&, const QUEUE_FORMAT&, bool>
{
    bool operator() (const QUEUE_FORMAT& qf1, const QUEUE_FORMAT& qf2) const
    {
        if (qf1.GetType() != qf2.GetType())
        {
            return (qf1.GetType() < qf2.GetType());
        }

        if (qf1.GetType() == QUEUE_FORMAT_TYPE_PUBLIC)
        {
            return (qf1.PublicID() < qf2.PublicID());
        }

        ASSERT(("Must be private format name here!", qf1.GetType() == QUEUE_FORMAT_TYPE_PRIVATE));

        if (qf1.PrivateID().Uniquifier != qf2.PrivateID().Uniquifier)
        {
            return (qf1.PrivateID().Uniquifier < qf2.PrivateID().Uniquifier);
        }

        return (qf1.PrivateID().Lineage < qf2.PrivateID().Lineage);
    }
};


struct CFunc_MulticastIdCompare : public std::binary_function<const MULTICAST_ID&, const MULTICAST_ID&, bool>
{
    bool operator() (const MULTICAST_ID& k1, const MULTICAST_ID& k2) const
    {
        return ((k1.m_address < k2.m_address) ||
                ((k1.m_address == k2.m_address) && (k1.m_port < k2.m_port)));
    }
};


typedef std::set<MULTICAST_ID, CFunc_MulticastIdCompare> MULTICASTID_VALUES;
typedef std::set<QUEUE_FORMAT, CFunc_QueueFormatCompare> QUEUEFORMAT_VALUES;


void
MsmpMapAdd(
    const QUEUE_FORMAT& QueueFormat,
    const MULTICAST_ID& multicastId,
    R<CMulticastListener>& pListener
    );


void 
MsmpMapRemove(
    const QUEUE_FORMAT& QueueFormat
    ) 
    throw();


void 
MsmpMapRemoveAll(
    void
    ) 
    throw();


MULTICASTID_VALUES
MsmpMapGetBoundMulticastId(
    const QUEUE_FORMAT& QueueFormat
    )
    throw();


QUEUEFORMAT_VALUES
MsmpMapGetQueues(
    const MULTICAST_ID& multicastId
    )
    throw();


R<CMulticastListener>
MsmpMapGetListener(
    const MULTICAST_ID& multicastId
    )
    throw();


#endif // _MSMQ_MsmMap_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\msm\lib\msmreceive.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmReceive.h

Abstract:
    Multicast Receiver declaration

Author:
    Shai Kariv (shaik) 12-Sep-00

--*/

#pragma once

#ifndef _MSMQ_MsmReceive_H_
#define _MSMQ_MsmReceive_H_

#include <ex.h>
#include <rwlock.h>
#include <spi.h>


class CMulticastReceiver : public CReference
{
private:
    enum {
        xHeaderChunkSize = 256,
        xBodyChunkSize = 256,
    };

public:
    CMulticastReceiver(
        CSocketHandle& socket, 
        const MULTICAST_ID& MulticastId,
		LPCWSTR remoteAddr
        );

    void Shutdown(void) throw();


	bool IsUsed(void)
	{
		return (m_fUsed == TRUE);
	}


	void SetIsUsed(bool fUsed)
	{
		InterlockedExchange(&m_fUsed, static_cast<LONG>(fUsed));
	}

public:
    static VOID WINAPI ReceiveFailed(EXOVERLAPPED* pov);
    static VOID WINAPI ReceiveHeaderSucceeded(EXOVERLAPPED* pov);
    static VOID WINAPI ReceiveBodySucceeded(EXOVERLAPPED* pov);

private:
    static DWORD FindEndOfResponseHeader(LPCSTR buf, DWORD length);
    static DWORD GetContentLength(LPCSTR p, DWORD length);


private:
    void ReceiveHeaderChunk(void);
    void ReceiveHeaderSucceeded(void);

    void ReceiveBodyChunk(void);
    void ReceiveBodySucceeded(void);

    void ReceiveBody(void);
    void ReceivePacket(void);
    
    DWORD HandleMoreDataExistInHeaderBuffer(void);
    void ProcessPacket(void);

    void ReallocateHeaderBuffer(DWORD Size);

	R<ISessionPerfmon> CreatePerfmonInstance(LPCWSTR remoteAddr);

private:
    mutable CReadWriteLock m_pendingShutdown;
    
    MULTICAST_ID m_MulticastId;

    AP<char> m_pHeader;
    DWORD m_HeaderAllocatedSize;

    DWORD m_HeaderValidBytes;
    DWORD m_ProcessedSize;

    AP<BYTE> m_pBody;
    DWORD m_readSize;
    DWORD m_bodyLength;

    //
    // This socket is used for receive
    //
    CSocketHandle m_socket;

    //
    // Async receive overlapped
    //
    EXOVERLAPPED m_ov;

	long m_fUsed;

	R<ISessionPerfmon> m_pPerfmon;
};

#endif // _MSMQ_MsmReceive_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\msm\test\msmtestp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmTestp.h

Abstract:
    Multicast session manager test, private header.

Author:
    Uri Habusha (urih) 31-Oct-99

--*/

#pragma once

bool IsFailed(void);
void UpdateNoOfsentMessages(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mt\lib\mt.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Mt.cpp

Abstract:
    Message Transport implementation

Author:
    Uri Habusha (urih) 11-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <st.h>
#include "Mt.h"
#include "Mtp.h"
#include "MtObj.h"

#include "mt.tmh"

R<CTransport>
MtCreateTransport(
    const xwcs_t& targetHost,
    const xwcs_t& nextHop,
    const xwcs_t& nextUri,
    USHORT targetPort,
	USHORT nextHopPort,
	LPCWSTR queueUrl,
	IMessagePool* pMessageSource,
	ISessionPerfmon* pPerfmon,
	const CTimeDuration& responseTimeout,
    const CTimeDuration& cleanupTimeout,
	bool  fSecure,
    DWORD SendWindowinBytes
    )
{
    MtpAssertValid();

    ASSERT((targetHost.Length() != 0) && (targetHost.Buffer() != NULL));
    ASSERT((nextHop.Length() != 0) && (nextHop.Buffer() != NULL));
    ASSERT((nextUri.Length() != 0) && (nextUri.Buffer() != NULL));
    ASSERT(queueUrl != NULL);
    ASSERT(pMessageSource != NULL);

	ISocketTransport* pWinsock; 
	if(!fSecure)
	{
		pWinsock = StCreateSimpleWinsockTransport();
	}
	else
	{
		bool fUseProxy = (nextHop 	!= 	targetHost);
		pWinsock = StCreateSslWinsockTransport(targetHost, targetPort, fUseProxy);
	}
	P<ISocketTransport> Winsock(pWinsock);

    TrTRACE(
		NETWORKING, 
		"Create new message transport.  SendWindowinBytes = %d", 
        SendWindowinBytes
		);


	CMessageTransport* p = new CMessageTransport(
										targetHost,
										nextHop,
										nextUri,
										nextHopPort,
										queueUrl, 
										pMessageSource,
										pPerfmon,
										responseTimeout, 
										cleanupTimeout,
										Winsock,
                                        SendWindowinBytes
										);
    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\msm\test\no.cpp ===
#include <libpch.h>
#include "No.h"
#include "Ex.h"
#include "MsmTestp.h"

#include "no.tmh"

using namespace std;

const char xShortOkResponse[] =		"HTTP/1.1 200 OK\r\n"
									"Content-Length: 0\r\n"
									"\r\n"
									;

const char xShortFailResponse[] =	"HTTP/1.1 500 Internal Server Error\r\n"
									"Connection: close\r\n"
									"Content-Length: 0\r\n"
									"\r\n"
									;

const char xLongOkResponse[] =		"HTTP/1.1 200 OK\r\n"
									"Header1: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header2: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Content-Length: 400\r\n"
									"Header3: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header4: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header5: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"\r\n"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									;

const char xLongFailResponse[] =	"HTTP/1.1 500 Internal Server Error\r\n"
									"Connection: close\r\n"
									"Header1: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header2: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Content-Length: 400\r\n"
									"Header3: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header4: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header5: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"\r\n"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									;

const char xOkResponseNoContentLength[] =
                            		"HTTP/1.1 200 OK\r\n"
									"\r\n"
                                    ;

const char xInformativeResponseNoContentLength[] =
                            		"HTTP/1.1 100 Continue\r\n"
									"\r\n"
									;

const char xFailResponseNoContentLength[] =
                            		"HTTP/1.1 500 Internal Server Error\r\n"
									"\r\n"
									;

const LPCSTR xResponses[] = {
	xShortOkResponse,
	xShortFailResponse,
	xLongOkResponse,
	xLongFailResponse,
    xOkResponseNoContentLength,
    xInformativeResponseNoContentLength,
    xFailResponseNoContentLength,
  
  };

struct SockInfo
{
    SockInfo(void) : 
        pBuffer(NULL),
        nBytesToRead(0),
        ByteReads(0),
        pov(NULL)
    {
    }

    CCriticalSection m_csResponse;
    list<LPCSTR> response;
    DWORD ByteReads;

    VOID* pBuffer;                                     
    DWORD nBytesToRead; 
    EXOVERLAPPED* pov;
};

typedef map<SOCKET, SockInfo*> SOCKET2INFO;
SOCKET2INFO s_mapSockInfo;


//
VOID
NoInitialize(
    VOID
    )
{
}


static SOCKET s_socket = 0;

SOCKET 
NoCreateStreamConnection(
    VOID
    )
{
    if (IsFailed())
    {
        throw exception();
    }

    s_mapSockInfo[++s_socket] = new SockInfo;

    TrTRACE(NETWORKING, "Create Socket 0x%Ix", s_socket);

    return s_socket;
}


VOID 
NoConnect(
    SOCKET Socket,
    const SOCKADDR_IN&,
    EXOVERLAPPED* pov
    )
{
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    if (it == s_mapSockInfo.end() || IsFailed())
    {
        if ((rand() %2) == 0)
            throw exception();

        pov->SetStatus(STATUS_UNSUCCESSFUL);
        ExPostRequest(pov);
        return;
    }

    pov->SetStatus(STATUS_SUCCESS);
    ExPostRequest(pov);
}


VOID
NoCloseConnection(
    SOCKET Socket
    )
{
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    TrTRACE(NETWORKING, "Close Socket 0x%Ix", Socket);

    if (it != s_mapSockInfo.end())
    {
        SockInfo* p = it->second;
        
        if (p->pov != NULL)
        {
            EXOVERLAPPED* pov = p->pov;

            p->pBuffer = NULL;
            p->pov = NULL;
            p->nBytesToRead = 0;

            pov->SetStatus(STATUS_UNSUCCESSFUL);
            ExPostRequest(pov);
        }

        s_mapSockInfo.erase(it);
        delete p;
    }
}


VOID
NoSend(
    SOCKET Socket,                                              
    const WSABUF*,
    DWORD, 
    EXOVERLAPPED* pov
    )
{ 
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    if (it == s_mapSockInfo.end() || IsFailed())
    {
        if ((rand() %2) == 0)
            throw exception();

        pov->SetStatus(STATUS_UNSUCCESSFUL);
        ExPostRequest(pov);
        return;
    }


    SockInfo* p = it->second;               
    {
        CS lock(p->m_csResponse);
        p->response.push_back(xResponses[rand() % TABLE_SIZE(xResponses)]);
    }

    pov->SetStatus(STATUS_SUCCESS);
    ExPostRequest(pov);

    if (p->pov != NULL)
    {
        //
        // pending reponse receive
        //
        EXOVERLAPPED* pov = p->pov;
        PVOID pBuffer = p->pBuffer;
        DWORD nBytesToRead = p->nBytesToRead;
        p->pBuffer = NULL;
        p->pov = NULL;
        p->nBytesToRead = 0;

        NoReceivePartialBuffer(Socket, pBuffer, nBytesToRead, pov);
    }
}


VOID
NoReceivePartialBuffer(
    SOCKET Socket,                                              
    VOID* pBuffer,                                     
    DWORD nBytesToRead, 
    EXOVERLAPPED* pov
    )
{
    TrTRACE(NETWORKING, "NoReceivePartialBuffer: Socket=0x%Ix Buffer=0x%p BytesToRead=%d ov=0x%p", Socket, pBuffer, nBytesToRead, pov);
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    if (it == s_mapSockInfo.end() || IsFailed())
    {
        pov->InternalHigh = 0;

        if (rand()%4 == 0)
            throw exception();

        if (rand()%4 == 1)
        {
            pov->SetStatus(STATUS_SUCCESS);
        }
        else
        {
            pov->SetStatus(STATUS_UNSUCCESSFUL);
        }

        ExPostRequest(pov);
        
        return;
    }

    SockInfo* p = it->second;               

    {
        CS lock(p->m_csResponse);
        if (p->response.empty())
        {
            p->pBuffer = pBuffer;                                   
            p->nBytesToRead = nBytesToRead;
            p->pov = pov;
            return;
        }
    }

    p->pBuffer = NULL;                                   
    p->nBytesToRead = 0;
    p->pov = NULL;

    LPCSTR response;
    {
        CS lock(p->m_csResponse);
        response = p->response.front();
    }

    DWORD length = min(nBytesToRead, (strlen(response) - p->ByteReads));

    memcpy(pBuffer, (response + p->ByteReads), length);
    p->ByteReads += length;

    pov->InternalHigh = length;
    
    bool fReadAllResponse = false;
    if (p->ByteReads == strlen(response))
    {
        CS lock(p->m_csResponse);
        p->response.pop_front();
        p->ByteReads = 0;
        fReadAllResponse = true;
    }
     
    pov->SetStatus(STATUS_SUCCESS);
    ExPostRequest(pov);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mt\lib\mtmessagetrace.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtMessageTrace.h

Abstract:
    Message Trace class - designed to log message in befor sent to network

Author:
   Gil Shafriri (gilsh) 12-Feb-2001

--*/  
#ifndef MtMessageTrace_H
#define MtMessageTrace_H


#ifdef _DEBUG

class CMtMessageTrace
{
public:
	static void Initialize();
	static void LogSendData(const WSABUF* buffers, size_t size);

private:
	static CCriticalSection m_cs;
	static AP<WCHAR> m_LogFileLocaPath;
	static CHandle m_hFile;
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mt\lib\mtinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtInit.cpp

Abstract:
    Message Transport initialization

Author:
    Uri Habusha (urih) 11-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Mt.h"
#include "Mtp.h"
#include "MtMessageTrace.h"

#include "mtinit.tmh"

VOID
MtInitialize(
    VOID
    )
/*++

Routine Description:
    Initializes Message Transport library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the Message Transport library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!MtpIsInitialized());
    MtpRegisterComponent();

#ifdef _DEBUG
	CMtMessageTrace::Initialize();
#endif

    MtpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mt\lib\mtget.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtConnect.cpp

Abstract:
    Message Transport class - Connect implementation

Author:
    Uri Habusha (urih) 11-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Mt.h"
#include "Mtp.h"
#include "MtObj.h"

#include "mtget.tmh"

void CMessageTransport::GetNextEntry(void)
{
	if(m_fPause)
	{
		TrTRACE(NETWORKING,"GetNextEntry was not executed because the transport is in pause mode");
		return;
	}

    try
    { 
        AddRef();
        m_pMessageSource->GetFirstEntry(&m_requestEntry, m_requestEntry.GetAcPacketPtrs());
    }
    catch (const exception&)
    {    
        Release();
        throw;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mt\lib\mtdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtDebug.cpp

Abstract:
    Message Transport debugging

Author:
    Uri Habusha (urih) 11-Aug-99

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Mt.h"
#include "Mtp.h"

#include "mtdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Message Transport state
//
void MtpAssertValid(void)
{
    //
    // MtInitalize() has *not* been called. You should initialize the
    // Message Transport library before using any of its funcionality.
    //
    ASSERT(MtpIsInitialized());

    //
    // TODO:Add more Message Transport validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void MtpSetInitialized(void)
{
    LONG fMtAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Message Transport library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fMtAlreadyInitialized);
}


BOOL MtpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
/*
const DebugEntry xDebugTable[] = {

    {
        "MtDumpState(queue path name)",
        "Dump Message Transport State to debugger",
        DumpState
    ),

    //
    // TODO: Add Message Transport debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void MtpRegisterComponent(void)
{
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mt\lib\mtmessagetrace.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtMessageTrace.cpp

Abstract:
    Implementing Message Trace class (MtMessageTrace.h)

Author:
   Gil Shafriri (gilsh) 12-Feb-2001

--*/  


#include <libpch.h>

#ifdef _DEBUG

#include <cm.h>
#include <tr.h>
#include "mtp.h"
#include "MtMessageTrace.h"

#include "MtMessageTrace.tmh"

AP<WCHAR> CMtMessageTrace::m_LogFileLocaPath = NULL;
CCriticalSection CMtMessageTrace::m_cs;
CHandle CMtMessageTrace::m_hFile;


void CMtMessageTrace::Initialize()
{
	CmQueryValue(
        RegEntry(NULL, L"HttpMessageTraceFilePath"),
        &m_LogFileLocaPath
        );
			  
	
	if(m_LogFileLocaPath.get() == NULL)
		return;


	CHandle hFile = CreateFile(
				m_LogFileLocaPath,
				GENERIC_WRITE,
				FILE_SHARE_READ,
				NULL,
				CREATE_ALWAYS,
			  	FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
				NULL
				);

	
	if(hFile == INVALID_HANDLE_VALUE )
	{
		TrERROR(NETWORKING, "could not create logfile %ls error %x ",m_LogFileLocaPath.get(), GetLastError());
		m_LogFileLocaPath.free();
		return;
	}

	*(&m_hFile) = hFile.detach();
}



void CMtMessageTrace::LogSendData(const WSABUF* buffers, size_t size)
{
	if(m_LogFileLocaPath.get() == NULL)
		return;

	CS cs(m_cs);
  
	const char StartLogStr[]= "\r\n **** Start http Message data **** \r\n";
	DWORD Written; 
 	WriteFile(m_hFile, StartLogStr, STRLEN(StartLogStr) , &Written, NULL);

	for(size_t i =0; i< size; ++i)
	{
		WriteFile(m_hFile, buffers[i].buf, buffers[i].len, &Written, NULL);
	}

	const char EndLogStr[]= "\r\n **** End http Message data **** \r\n";
	WriteFile(m_hFile, EndLogStr, STRLEN(EndLogStr) , &Written, NULL);
}






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mt\lib\mtconnect.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtConnect.cpp

Abstract:
    Message Transport class - Connect implementation

Author:
    Uri Habusha (urih) 11-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Tm.h"
#include "Mt.h"
#include "Mtp.h"
#include "MtObj.h"

#include "mtconnect.tmh"

void CMessageTransport::RequeuePacket(void)
/*++

Routine Description:
    The routine returns entry to the queue

Arguments:
    None.

Returned Value:
    None.

--*/
{
    CACPacketPtrs& acPtrs = m_requestEntry.GetAcPacketPtrs();

    ASSERT(acPtrs.pDriverPacket != NULL);
    ASSERT(acPtrs.pPacket != NULL);

    CQmPacket Entry(acPtrs.pPacket, acPtrs.pDriverPacket);
    AppRequeueMustSucceed(&Entry);

    acPtrs.pPacket = NULL;
    acPtrs.pDriverPacket = NULL;
}



void CMessageTransport::InitPerfmonCounters(void)
{
	m_pPerfmon->CreateInstance(QueueUrl());
}


void CMessageTransport::ConnectionSucceeded(void)
/*++

Routine Description:
    The routine is called when create a connection completes successfully

Arguments:
    None.

Returned Value:
    None.

--*/
{
    m_pConnection = m_SocketTransport->GetConnection();
	ASSERT(m_pConnection.get()  != NULL);

    TrTRACE(NETWORKING, "Connected to '%ls'",  m_host);

    State(csConnected);

    //
    // Create Session permormance counter structure
    //
	InitPerfmonCounters();

    //
    // Start the transport cleanup timer
    //
    StartCleanupTimer();

    //
    // Now, connection was established. The message Transport is ready to
    // get a message for sending
    //
    GetNextEntry();

    //
    // Allow receive on the socket.
    //
    ReceiveResponse();
}


void WINAPI CMessageTransport::ConnectionSucceeded(EXOVERLAPPED* pov)
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

    R<CMessageTransport> pmt = CONTAINING_RECORD(pov, CMessageTransport, m_connectOv);

    //
    // Connect has completed successfully, go and start delivering the messages.
    // If delivery failes here, the cleanup timer will eventually shutdown this
    // transport, so no explict shutdown is nesscessary.
    //
    // Do not schedule a retry here if this failes as this is the first send,
    // and any failure indicates a fatal error. (unlike after first delivery).
    //
    pmt->ConnectionSucceeded();
}


void WINAPI CMessageTransport::ConnectionFailed(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when create a connection failed

Arguments:
    None.

Returned Value:
    None.

--*/
{
    ASSERT(FAILED(pov->GetStatus()));

    R<CMessageTransport> pmt = CONTAINING_RECORD(pov, CMessageTransport, m_connectOv);
     	
    TrERROR(NETWORKING, "Failed to connect to '%ls'. pmt=0x%p", pmt->m_host, pmt.get());
    pmt->Shutdown();
}


void CMessageTransport::Connect(void)
/*++

Routine Description:
    The routine creates a winsock connection with the destination. The operation
    is a synchronous and on completion a call back routine is called

Arguments:
    None.

Returned Value:
    None.

Note:
    No Timers are running concurrently, so this function can not be interrupted
    by Shutdown. No need to protect m_socket etc.

--*/
{
	std::vector<SOCKADDR_IN> Address;
    bool fRet = m_SocketTransport->GetHostByName(m_host, &Address);
    if(!fRet)
    {
		//
		// For those who debug  address resolution faliure :
		// If proxy is required check if the  proxy is defined for MSMQ by proxycfg.exe tool.
		//
        TrERROR(NETWORKING, "Failed to resolve address for '%ls'", m_host);
        throw exception();
    }
	ASSERT(Address.size() > 0);

	for(std::vector<SOCKADDR_IN>::iterator it = Address.begin(); it != Address.end(); ++it)
	{
		it->sin_port = htons(m_port);		
	}


    TrTRACE(NETWORKING, "Resolved address for '%ls'. Address=" LOG_INADDR_FMT,  m_host, LOG_INADDR(Address[0]));

    //
    // Create a socket for the connection (no need to protect m_socket)
    //
    TrTRACE(NETWORKING, "Got socket for connection. socket=0x%p, pmt=0x%p", socket, this);


    //
    // Start asynchronous connection
    //
    try
    {
        AddRef();
        m_SocketTransport->CreateConnection(Address, &m_connectOv);
    }
    catch(const exception&)
    {
		TrERROR(NETWORKING, "Failed to connect to '%ls'", m_host);
        Release();
        throw;
    }
}


void CMessageTransport::Shutdown(Shutdowntype Shutdowntype) throw()
/*++

Routine Description:
    Called when the transport meeds to be unloaded from memory

Arguments:
	Shutdowntype - The reason for cleanup.

Returned Value:
    None.

--*/

{
    //
    // Now Shutdown is in progress, cancel all timers
    //
    TryToCancelCleanupTimer();
    CancelResponseTimer();

	//
    // Protect m_socket, m_state
    //
    CS cs(m_pendingShutdown);
	
	if (State() == csShutdownCompleted)
    {
          return;
    }
	
	//
	// If shut down was called because an error - reprot it.
	//
	if(Shutdowntype == RETRYABLE_DELIVERY_ERROR)
	{
		m_pMessageSource->OnRetryableDeliveryError();
	}


	if (m_pConnection.get() != NULL)
    {
        m_pConnection->Close();
    }


    //
    // Cancle peding request from the queue
    //
    m_pMessageSource->CancelRequest();


	 //
    // Removes the message transport from transport manager data structure, and creates
    // a new transport to the target
    //
    AppNotifyTransportClosed(QueueUrl());

    State(csShutdownCompleted);
	TrTRACE(NETWORKING,"Shutdown completed (Refcount = %d)",GetRef());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mt\lib\mtobj.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Mt.cpp

Abstract:
    Message Transport class - implementation

Author:
    Uri Habusha (urih) 11-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Mt.h"
#include "Mtp.h"
#include "MtObj.h"
#include "MtSendMng.h"

#include "mtobj.tmh"

bool CMessageTransport::TryToCancelCleanupTimer(void)
{
    if (!ExCancelTimer(&m_cleanupTimer))
        return false;

    Release();
    return true;
}

void CMessageTransport::StartCleanupTimer(void)
{
    ASSERT(!m_cleanupTimer.InUse());

    m_fUsed = false;

    AddRef();
    ExSetTimer(&m_cleanupTimer, m_cleanupTimeout);
}


void WINAPI CMessageTransport::TimeToCleanup(CTimer* pTimer)
{
    R<CMessageTransport> pmt = CONTAINING_RECORD(pTimer, CMessageTransport, m_cleanupTimer);

    if (pmt->m_fUsed)
    {
        pmt->StartCleanupTimer();
        return;
    }

    TrERROR(NETWORKING, "Transport is idle, shutting down. pmt=0x%p", pmt.get());
    pmt->Shutdown(OK);
}

static WCHAR* ConvertTargetUriToString(const xwcs_t& Uri)
{
/*++

Routine Description:
    Conver uri buffer to string - converting the first L'\' to L'/'
	because proxy look for L'/' caracter as termination of the host name in the uri.

Arguments:
    Uri - Uri buffer

Returned Value:
    converted Uri string (caller should delete[])

--*/
	WCHAR* strUri =  Uri.ToStr();
	ASSERT(wcslen(strUri) ==  static_cast<const size_t&>(Uri.Length()));
	WCHAR* find = std::find(strUri, strUri+Uri.Length(), L'\\');
	if(find != strUri+Uri.Length())
	{
		*find =  L'/';
	}
	return strUri;
}


CMessageTransport::CMessageTransport(
    const xwcs_t& targetHost,
    const xwcs_t& nextHop,
    const xwcs_t& nextUri,
    USHORT port,
    LPCWSTR queueUrl,
    IMessagePool* pMessageSource,
	ISessionPerfmon* pPerfmon,
	const CTimeDuration& responseTimeout,
    const CTimeDuration& cleanupTimeout,
	P<ISocketTransport>& SocketTransport,
    DWORD SendWindowinBytes
    ) :
    CTransport(queueUrl),
    m_targetHost(targetHost.ToStr()),
    m_host(nextHop.ToStr()),
    m_uri(ConvertTargetUriToString(nextUri)),
    m_port(port),
    m_pMessageSource(SafeAddRef(pMessageSource)),
    m_requestEntry(GetPacketForSendingSucceeded, GetPacketForSendingFailed),
    m_connectOv(ConnectionSucceeded, ConnectionFailed),
    m_responseOv(ReceiveResponseHeaderSucceeded, ReceiveResponseFailed),
    m_responseTimer(TimeToResponseTimeout),
	m_responseTimeout(responseTimeout),
    m_fResponseTimeoutScheduled(false),
    m_fUsed(false),
    m_cleanupTimer(TimeToCleanup),
    m_cleanupTimeout(cleanupTimeout),
	m_SocketTransport(SocketTransport.detach()),
	m_pPerfmon(SafeAddRef(pPerfmon)),
    m_SendManager(SendWindowinBytes),
	m_fPause(false)
{
	ASSERT(("Invalid parameter", pMessageSource != NULL));
	ASSERT(("Invalid parameter", pPerfmon != NULL));

	    TrTRACE(
		NETWORKING,
		"Create new message transport. pmt = 0x%p, host = %ls, port = %d, uri = %ls, response timeout = %d ms",
		this,
		m_host,
        m_port,
        m_uri,
		responseTimeout.InMilliSeconds()
		);

    Connect();
}


CMessageTransport::~CMessageTransport()
{
	TrTRACE(NETWORKING,"CMessageTransport Destructor called");

	//
    // Requeue all the messages that had been sent and were not responsed
    //
  	RequeueUnresponsedPackets();

	//
	// We close the message pool here instead of letting it self destruct since
	// the close process may be prolonged in cases of low system resources
	//
    m_pMessageSource->Close();

    ASSERT(State() == csShutdownCompleted);
    ASSERT(m_response.empty());
    ASSERT(!m_responseTimer.InUse());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mt\lib\mtp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Mtp.h

Abstract:
    Message Transport private functions.

Author:
    Uri Habusha (urih) 11-Aug-99

--*/

#pragma once

#include <ex.h>

inline DWORD DataTransferLength(EXOVERLAPPED& ov)
{
    //
    // In win64, InternalHigh is 64 bits. Since the max chunk of data
    // we transfer in one operation is always less than MAX_UNIT we can cast
    // it to DWORD safetly
    //
    ASSERT(0xFFFFFFFF >= ov.InternalHigh);
	return static_cast<DWORD>(ov.InternalHigh);
}




#ifdef _DEBUG

void MtpAssertValid(void);
void MtpSetInitialized(void);
BOOL MtpIsInitialized(void);
void MtpRegisterComponent(void);

#else // _DEBUG

#define MtpAssertValid() ((void)0)
#define MtpSetInitialized() ((void)0)
#define MtpIsInitialized() TRUE
#define MtpRegisterComponent() ((void)0)

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mt\lib\mtobj.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Mtp.h

Abstract:
    Message Transport class.

Author:
    Uri Habusha (urih) 11-Aug-99

--*/

#pragma once

#ifndef __MTOBJ_H__
#define __MTOBJ_H__

#include "msi.h"
#include "spi.h"

#include <mqwin64a.h>
#include "acdef.h"
#include "List.h"
#include "qmpkt.h"

#include <ex.h>
#include <rwlock.h>
#include <st.h>
#include <buffer.h>
#include "Mp.h"
#include "MtSendMng.h"


typedef std::basic_string<unsigned char> utf8_str;


class CMessageTransport : public CTransport
{
public:
	enum Shutdowntype{PAUSE, OK, RETRYABLE_DELIVERY_ERROR};

public:

    CMessageTransport(
        const xwcs_t& targetHost,
        const xwcs_t& nextHop,
        const xwcs_t& nextUri,
        USHORT port,
        LPCWSTR queueUrl,
        IMessagePool* pMessageSource,
		ISessionPerfmon* pPerfmon,
        const CTimeDuration& responseTimeout,
        const CTimeDuration& cleanupTimeout,
		P<ISocketTransport>& SocketTransport,
        DWORD SendWindowinBytes
        );

    virtual ~CMessageTransport();


    LPCWSTR ConnectedHost(void) const
    {
        return m_host;
    }


    LPCWSTR ConnectedUri(void) const
    {
        return m_uri;
    }


    USHORT ConnectedPort(void) const
    {
        return m_port;
    }

	
	virtual void Pause(void)
	{
		CS lock (m_csResponse);
		m_fPause = true;

		if(m_response.empty())
		{
			Shutdown(PAUSE);
		}
	}


private:
    class CRequestOv : public EXOVERLAPPED
    {
    public:
        CRequestOv(
            COMPLETION_ROUTINE pSuccess,
            COMPLETION_ROUTINE pFailure
        ):
            EXOVERLAPPED(pSuccess, pFailure)
        {
            m_pMsg.pPacket = NULL;
            m_pMsg.pDriverPacket = NULL;
        }


        CACPacketPtrs& GetAcPacketPtrs(void)
        {
            return m_pMsg;
        }


    private:
        CACPacketPtrs m_pMsg;
    };


    class CSendOv: public EXOVERLAPPED
    {
    public:
        CSendOv( COMPLETION_ROUTINE pSuccess,
            COMPLETION_ROUTINE pFailure,
            CMessageTransport* pmt,
            const R<CSrmpRequestBuffers>& pSrmpRequestBuffers
        ):
            EXOVERLAPPED(pSuccess, pFailure),
            m_pSrmpRequestBuffers(pSrmpRequestBuffers),
            m_pmt(SafeAddRef(pmt))
        {
        };

    public:
        DWORD GetSendDataLength() const
        {
            return numeric_cast<DWORD>(m_pSrmpRequestBuffers->GetSendDataLength());
        }
        R<CMessageTransport> MessageTransport() const
        {
            return m_pmt;
        }
    private:
        R<CMessageTransport> m_pmt;
        R<CSrmpRequestBuffers> m_pSrmpRequestBuffers;
    };



    class CResponseOv : public EXOVERLAPPED
    {
    public:
        enum {
            xHeaderChunkSize = 256,
            xBodyChunkSize = 256,
            xMaxHeaderSize = 0x8000 // 32 Kb
        };

    public:
        CResponseOv(
            COMPLETION_ROUTINE pSuccess,
            COMPLETION_ROUTINE pFailure
        ):
            EXOVERLAPPED(pSuccess, pFailure),
            m_pHeader(new char[xHeaderChunkSize]),
            m_HeaderAllocatedSize(xHeaderChunkSize),
            m_HeaderValidBytes(0),
            m_BodyToRead(0),
            m_ProcessedSize(0),
            m_ResponseStatus(0)
        {
        };

		void operator=(const EXOVERLAPPED& ov)
		{
			EXOVERLAPPED::operator=(ov);
		}

        char* Header() const
        {
            return m_pHeader;
        }


        DWORD HeaderAllocatedSize() const
        {
            return m_HeaderAllocatedSize;
        }


        DWORD BodyChunkSize() const
        {
            return (DWORD)min(TABLE_SIZE(m_Body), m_BodyToRead);
        }


        void ReallocateHeaderBuffer(DWORD Size)
        {
            ASSERT(Size > m_HeaderAllocatedSize);
            char* p = new char[Size];
            memcpy(p, m_pHeader, m_HeaderAllocatedSize);
            m_pHeader.free();
            m_pHeader = p;
            m_HeaderAllocatedSize = Size;
        }

        bool IsMoreResponsesExistInBuffer(void) const
        {
            return (m_HeaderValidBytes > m_ProcessedSize);
        }

		

    private:
        AP<char> m_pHeader;
        DWORD m_HeaderAllocatedSize;

    public:
        DWORD m_HeaderValidBytes;
        DWORD m_ProcessedSize;

        char m_Body[xBodyChunkSize];
        DWORD m_BodyToRead;
        USHORT m_ResponseStatus;
    };


    class CConnectOv : public EXOVERLAPPED
    {
    public:
        CConnectOv(
            COMPLETION_ROUTINE pSuccess,
            COMPLETION_ROUTINE pFailure
        ):
        EXOVERLAPPED(pSuccess, pFailure)
		{
		}
	};

private:
    static void WINAPI ConnectionSucceeded(EXOVERLAPPED* pov);
    static void WINAPI ConnectionFailed(EXOVERLAPPED* pov);
    static void WINAPI GetPacketForConnectingSucceeded(EXOVERLAPPED* pov);
    static void WINAPI GetPacketForConnectingFailed(EXOVERLAPPED* pov);


    static void WINAPI SendSucceeded(EXOVERLAPPED* pov);
    static void WINAPI SendFailed(EXOVERLAPPED* pov);
    static void WINAPI GetPacketForSendingSucceeded(EXOVERLAPPED* pov);
    static void WINAPI GetPacketForSendingFailed(EXOVERLAPPED* pov);


    //
    // Receive functions
    //
    static void WINAPI ReceiveResponseHeaderSucceeded(EXOVERLAPPED* pov);
    static void WINAPI ReceiveResponseBodySucceeded(EXOVERLAPPED* pov);
    static void WINAPI ReceiveResponseFailed(EXOVERLAPPED* pov);

    static DWORD FindEndOfResponseHeader(LPCSTR buf, DWORD length);
    static DWORD GetContentLength(LPCSTR buf, DWORD headerLength, USHORT HttpStatus);
	
    static void WINAPI TimeToResponseTimeout(CTimer* pTimer);

    //
    // General functions
    //
    static void WINAPI TimeToCleanup(CTimer* pTimer);
	

private:
	friend class CHttpStatusCodeMapper;

    //
    // Get packet for sending
    //
    void GetNextEntry(void);


	//
    // Requeue packet
    //
    void RequeuePacket(void);

	//
	// Functions to handle http status code
	//
	void OnAbortiveHttpError(USHORT HttpStatusCode);
	void OnRetryableHttpError(USHORT HttpStatusCode);
	void OnHttpDeliverySuccess(USHORT HttpStatusCode);
	void OnHttpDeliveryContinute(USHORT HttpStatusCode);
	void OnRedirection(USHORT  HttpStatusCode );
	xstr_t GetNewLocation(LPCSTR p, DWORD length);
	bool IsPipeLineMode() const;
	

    //
    // Create connection
    //
    void ConnectionSucceeded(void);
    void Connect(void);
	void InitPerfmonCounters(void);



    //
    // Send packet
    //
    void SendSucceeded(DWORD cbSendSize);
    void DeliverPacket(CQmPacket* pPacket);
    CQmPacket* CreateDeliveryPacket(void);
	void InsertPacketToResponseList(CQmPacket* pPacket);
	bool PrepareDelivery(CQmPacket* pPacket);
	void SafePutPacketOnHold(CQmPacket* pPacket);

    //
    // Receive response
    //
    void ReceiveResponseHeaderSucceeded(void);
    void ReceiveResponseBodySucceeded(void);
    void ReceiveResponse(void);
    void ReceiveResponseHeaderChunk(void);
    void ReceiveResponseBodyChunk(void);
    void ProcessResponse(LPCSTR ResponseBuf, DWORD length);
    void CompleteProcessResponse(USHORT mqclass);
    void ReceiveResponseBody(void);
    void StartResponseTimeout(void);
    void CancelResponseTimer(void);


    void HandleExtraResponse(void);

    //
    // Shut-Down
    //
    void RequeueUnresponsedPackets(void);
    void Shutdown(Shutdowntype Shutdowntype = RETRYABLE_DELIVERY_ERROR) throw();

    //
    // Cleanup
    //
    void StartCleanupTimer(void);
    bool TryToCancelCleanupTimer(void);

    void MarkTransportAsUsed(void)
    {
        m_fUsed = true;
    }


private:
    mutable CCriticalSection m_pendingShutdown;

    R<IConnection> m_pConnection;
    R<IMessagePool> m_pMessageSource;

    mutable CCriticalSection m_csResponse;

    List<CQmPacket> m_response;
    CResponseOv m_responseOv;
    bool m_fResponseTimeoutScheduled;


    CRequestOv m_requestEntry;
    CConnectOv m_connectOv;


    CTimer m_responseTimer;
    CTimeDuration m_responseTimeout;

    bool m_fUsed;
    CTimer m_cleanupTimer;
    CTimeDuration m_cleanupTimeout;

    AP<WCHAR> m_targetHost;
    AP<WCHAR> m_host;
    AP<WCHAR> m_uri;
    USHORT m_port;
	

	P<ISocketTransport> m_SocketTransport;
	R<ISessionPerfmon> m_pPerfmon;

    CMtSendManager m_SendManager;
	bool m_fPause;
};

#endif // __MTOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mt\lib\mtsendmng.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtSendMng.h

Abstract:
    Message Transport Send Manager Class - designed to control sends in pipeline mode 

Author:
    Milena Salman (msalman) 11-Feb-01

--*/

#pragma once

#ifndef __MTSENDMNG_H__
#define __MTSENDMNG_H__

class CMtSendManager
{
public:
    enum MtSendState{
        eSendEnabled=0,
        eSendDisabled
    };
    CMtSendManager(DWORD m_SendWindowinBytes);
    MtSendState ReportPacketSend(DWORD cbSendSize);
    MtSendState ReportPacketSendCompleted(DWORD cbSendSize);
private:
    mutable CCriticalSection m_cs;
    bool m_Suspended;
    DWORD m_SendWindowinBytes;  // total size of packets that can be sent without waiting for completion
    DWORD m_SentBytes;  // size of sent packets
};


#endif // __MTSENDMNG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mt\lib\mtsend.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtConnect.cpp

Abstract:
    Message Transport class - Send implementation

Author:
    Uri Habusha (urih) 11-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <Mt.h>
#include <mp.h>
#include <strutl.h>
#include <utf8.h>
#include "Mtp.h"
#include "MtObj.h"
#include "MtMessageTrace.h"

#include "mtsend.tmh"

using namespace std;

void WINAPI CMessageTransport::GetPacketForSendingSucceeded(EXOVERLAPPED* pov)
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

	CRequestOv* pRequest = static_cast<CRequestOv*>(pov);
    R<CMessageTransport> pmt = CONTAINING_RECORD(pRequest, CMessageTransport, m_requestEntry);
    
    TrTRACE(NETWORKING, "Got a message to deliver. pmt = 0x%p", pmt.get());

	P<CQmPacket> pPkt = pmt->CreateDeliveryPacket();

    try
    {
		//
		// test if we should send the packet now (ordered packet send policy)
		//
		if(!AppCanDeliverPacket(pPkt))
		{
			pmt->SafePutPacketOnHold(pPkt.detach());
			pmt->GetNextEntry();
			return;
		}

	
		if(pmt->PrepareDelivery(pPkt))
		{
			pmt->DeliverPacket(pPkt.detach());	
			return;
		}

		//
		// if PrepareDelivery failed we are in pause mode - requeue the packet
		//
		pmt->m_pMessageSource->Requeue(pPkt.detach());	
    }
    catch(const exception&)
    {
		TrERROR(NETWORKING, "Failed to deliver message, shutting down. pmt=0x%p", pmt.get());
		if (NULL != pPkt.get())
			pmt->m_pMessageSource->Requeue(pPkt.detach());	
	    pmt->Shutdown();
        throw;
    }
}


void WINAPI CMessageTransport::GetPacketForSendingFailed(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when getting entry request from a queue failed.
  
Arguments:
    None.
  
Returned Value:
    None.

--*/
{
    ASSERT(FAILED(pov->GetStatus()));

	CRequestOv* pRequest = static_cast<CRequestOv*>(pov);
    R<CMessageTransport> pmt = CONTAINING_RECORD(pRequest, CMessageTransport, m_requestEntry);

    TrERROR(NETWORKING, "Failed to get a new entry from queue %ls/%ls. Shutting down. pmt = 0x%p", pmt->m_host, pmt->m_uri, pmt.get());
    pmt->Shutdown();
}


void WINAPI CMessageTransport::SendFailed(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when send a message failed
  
Arguments:
    pov - Pointer to EXOVERLAPPED
    
Returned Value:
    None.

--*/
{
    ASSERT(FAILED(pov->GetStatus()));


    P<CSendOv> pSendOv = static_cast<CSendOv*>(pov);
    R<CMessageTransport> pmt = pSendOv->MessageTransport();
    TrERROR(NETWORKING, "Failed to send message to '%ls', shutting down. pmt=0x%p", pmt->m_host, pmt.get());
    pmt->Shutdown();
    
}


void CMessageTransport::SendSucceeded(DWORD cbSendSize)
/*++

Routine Description:
    Callback routine. The routine is called when send a message succeeded
  
Arguments:
    pov - Pointer to EXOVERLAPPED
  
Returned Value:
    None.
					    
--*/
{
    TrTRACE(
		NETWORKING, 
		"Send message to '%ls via %ls uri=%ls' succeeded. pmt=0x%p", 
		m_targetHost,
		m_host, 
		m_uri, 
		this
		);

	StartResponseTimeout();

   
    MarkTransportAsUsed();

	//
	// Update performance counters
	//
	m_pPerfmon->UpdateBytesSent(cbSendSize);
	m_pPerfmon->UpdateMessagesSent();

	//
	// If the socket transport support pipelining - ask the driver to bring
	// next packet for delivery. If pipelining not supported we will do it only 
	// when all response is read for the current request.
	//

    if(IsPipeLineMode())
	{
        //ask the driver to bring next packet now only if sends were suspended due to exceeding send windows 
        //and can be resumed now , otherwise it is done in CMessageTransport::DeliverPacket
        if (m_SendManager.ReportPacketSendCompleted(cbSendSize) == CMtSendManager::eSendEnabled)
        { 
		    GetNextEntry();
        }
	}
}


void WINAPI CMessageTransport::SendSucceeded(EXOVERLAPPED* pov)
{
  
    ASSERT(SUCCEEDED(pov->GetStatus()));
  
    P<CSendOv> pSendOv = static_cast<CSendOv*>(pov);
    DWORD SendDataLength = pSendOv->GetSendDataLength();
    R<CMessageTransport> pmt = pSendOv->MessageTransport();
   
    //
    // Send has completed successfully, go and request the next message for delivery.
    // If the request failes, the cleanup timer will eventually shutdown this
    // transport, so no explict shutdown is nesscessary.
    //    
 
	
    pmt->SendSucceeded(SendDataLength);
  
}


bool CMessageTransport::PrepareDelivery(CQmPacket* pPacket)
/*++

Routine Description:
	Prepare packet for delivery by insert it into the response list.
     
Arguments:
   pPacket - pointer to the packet
  
Returned Value:
     In case that the  user paused the transport the function return false - otherwise
	 true is returned.
					    
--*/
{
	CS lock(m_csResponse);
	if(m_fPause)
		return false;

	InsertPacketToResponseList(pPacket);
	return true;
}


void CMessageTransport::InsertPacketToResponseList(CQmPacket* pPacket)
{
	CS lock(m_csResponse);
	m_response.push_back(*pPacket);
}



void CMessageTransport::SafePutPacketOnHold(CQmPacket* pPacket)
/*++

Routine Description:
    Delay packet delivery by inserting it to on hold list.
	If insertion failed (exception) - we insert it to response list for cleanup
	and rethrow the exception.
  
Arguments:
    CQmPacket* pPacket - packet to put on hold
  
Returned Value:
    None.

--*/
{

	TrTRACE(
		NETWORKING,
		"Http Packet delivery delayed : SeqID=%x / %x , SeqN=%d ,Prev=%d",
		HIGH_DWORD(pPacket->GetSeqID()),
		LOW_DWORD(pPacket->GetSeqID()),
		pPacket->GetSeqN(),
		pPacket->GetPrevSeqN()
		);

	try
	{
		AppPutPacketOnHold(pPacket);
	}
	catch(const exception&)
	{
		InsertPacketToResponseList(pPacket);
		throw;
	}
}



CQmPacket* CMessageTransport::CreateDeliveryPacket(void)
{
    //
    // Get the entry from the request overlapped. 
    //
    CACPacketPtrs& acPkts = m_requestEntry.GetAcPacketPtrs();
    CQmPacket* pEntry;

    try
    {
        pEntry = new CQmPacket(acPkts.pPacket, acPkts.pDriverPacket);

        acPkts.pDriverPacket = NULL;
        acPkts.pPacket = NULL;
    }
    catch(const exception&)
    {
        TrERROR(NETWORKING, "Failed to store the packet in UnAcked list");
        RequeuePacket();
        Shutdown();
        throw;
    }
    return pEntry;
}




void CMessageTransport::DeliverPacket(CQmPacket* pEntry)
/*++

Routine Description:
    The routine delivers an entry to the destination. The deliver is asynchornous.
    On completion a call back routine is called.
  
Arguments:
    None.
  
Returned Value:
    None.

--*/
{
    
    //
    // Mark the transport as used
    //
    MarkTransportAsUsed();


	R<CSrmpRequestBuffers> pSrmpRequestBuffers = MpSerialize(
									                        *pEntry,
									                        m_targetHost,
									                        m_uri
									                        );

    ASSERT(pSrmpRequestBuffers->GetNumberOfBuffers() != 0);
    //
    // Increment object refernce count, to insure that the object will
    // not be destroyed before asynchronous send operation is completed
    //
    
    P<CSendOv> pSendOv = new CSendOv(SendSucceeded, SendFailed, this, pSrmpRequestBuffers);
   

#ifdef _DEBUG
	CMtMessageTrace::LogSendData(
		pSrmpRequestBuffers->GetSendBuffers(), 
		pSrmpRequestBuffers->GetNumberOfBuffers()
		);
	
#endif
	//
	// Log to tracing that a message was sent.
	// Do this only if we are in the proper tracing level
	//
	if (WPP_LEVEL_COMPID_ENABLED(rsTrace, PROFILING))
	{
		OBJECTID TraceMessageId;
		pEntry->GetMessageId(&TraceMessageId);

		TrTRACE(PROFILING, "MESSAGE TRACE - State:%ls   Queue:%ls  ID:%!guid!\\%u   Delivery:0x%x   Class:0x%x   Label:%.*ls", 
			L"HTTP Message being sent on wire", 
			QueueUrl(), 
			&TraceMessageId.Lineage,
			TraceMessageId.Uniquifier, 
			pEntry->GetDeliveryMode(),
			pEntry->GetClass(),
			xwcs_t(pEntry->GetTitlePtr(), pEntry->GetTitleLength()));
	}
	
    m_pConnection->Send(
					pSrmpRequestBuffers->GetSendBuffers(), 
					numeric_cast<DWORD>(pSrmpRequestBuffers->GetNumberOfBuffers()), 
					pSendOv
					);

	pSendOv.detach();
    
    //
	// If the socket transport support pipelining - ask the driver to bring
	// next packet for delivery. If pipelining not supported we will do it only 
	// when all response is read for the current request.
	//

    if(IsPipeLineMode())
	{
        DWORD cbSendSize = numeric_cast<DWORD>(pSrmpRequestBuffers->GetSendDataLength());

        //check if next packet can be sent 
        if (m_SendManager.ReportPacketSend(cbSendSize) == CMtSendManager::eSendEnabled ) 
        {
            //next packet can be sent. go and request the next message for delivery.  
		    GetNextEntry();
        }
	}

    TrTRACE(NETWORKING, "Send message to '%ls' via %ls. pmt=0x%p ",m_targetHost, m_host, this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mt\test\group.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    group.cpp

Abstract:
    group stub for MT test

Author:
    Uri Habusha (urih) 11-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Ex.h"
#include "MtTestp.h"
#include "group.h" 
#include "phbase.h"
#include "phuser.h"
#include "phprop.h"

#include "group.tmh"

WCHAR directHttpFormatName[] = L"http://foo\\msmq\\q1";
const QUEUE_FORMAT destQueue(directHttpFormatName);
const GUID sourceQm = { 0 };
const GUID destQm = { 0 };

static ULONG s_msgId = 0;



ULONG CGroup::CalcPacketSize(void)
{
    ULONG ulPacketSize;

    ulPacketSize  = CBaseHeader::CalcSectionSize();

    ulPacketSize += CUserHeader::CalcSectionSize(&sourceQm, &destQm, NULL, &destQueue, NULL, NULL);

    ulPacketSize += CPropertyHeader::CalcSectionSize(0, 0, 0);

    return ulPacketSize;
}


char* CGroup::CreatePacket(void)
{
    ULONG ulPacketSize = CalcPacketSize();

    char* pPacket = new char[ulPacketSize];
    char* pSection = pPacket;

    // Initialize the EXOVERLAPPED with send callback routines
    //
    #pragma PUSH_NEW
    #undef new

        CBaseHeader* pBase = new(pSection) CBaseHeader(ulPacketSize);
        pSection = pBase->GetNextSection();

        CUserHeader* pUser = new(pSection) CUserHeader(
                                                &sourceQm, 
                                                &destQm,
                                                &destQueue,
                                                NULL,
                                                NULL,
                                                ++s_msgId
                                                );
        pSection = pUser->GetNextSection();

        new(pSection) CPropertyHeader();

    #pragma POP_NEW

    return pPacket;
}


void WINAPI CGroup::TimeToReturnPacket(CTimer* pTimer)
{
    R<CGroup> pGroup = CONTAINING_RECORD(pTimer, CGroup, m_getSleep);
    pGroup->TimeToReturnPacket();
}

void CGroup::TimeToReturnPacket(void)
{
    CS lock(m_cs);

    ASSERT(m_fGetScheduled);
    if(! m_request.empty())
    {
        CGroup::CRequest& request = m_request.front();
    
        EXOVERLAPPED* pov = request.m_pov;
        CACPacketPtrs* pAcPackts = request.m_pAcPackts;

        m_request.pop_front();

    
        char* pPkt = CreatePacket();

        pAcPackts->pPacket = reinterpret_cast<CBaseHeader*>(pPkt);
        pAcPackts->pDriverPacket = reinterpret_cast<CPacket*>(pPkt);

    
        pov->SetStatus(STATUS_SUCCESS);
        ExPostRequest(pov);
    }

    if (m_request.empty())
    {
        m_fGetScheduled = false;
        return;
    }

    R<CGroup> ref = SafeAddRef(this);
    CTimeDuration sleepInterval(rand()/1000);
    ExSetTimer(&m_getSleep, sleepInterval);
    ref.detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mt\lib\mtsendmng.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtSendMng.h

Abstract:
    Implementation of Message Transport Send Manager Class.

Author:
    Milena Salman (msalman) 11-Feb-01

--*/

#include <libpch.h>
#include "Mtp.h"
#include "MtSendMng.h"

#include "MtSendMng.tmh"

CMtSendManager::CMtSendManager(DWORD SendWindowinBytes):
m_Suspended(false),
m_SendWindowinBytes(SendWindowinBytes),
m_SentBytes(0)
{
  	TrTRACE(
		NETWORKING, 
		"Message Transport Manager Parameters: SendWindowinBytes = %d\n", 
        m_SendWindowinBytes
	);
}

CMtSendManager::MtSendState CMtSendManager::ReportPacketSend(DWORD cbSendSize)
{

/*++

Routine Description:
    CMtSendManager::ReportPacketSend called after sending packet 
    Updates "number of sent packets" and "size of sent packets" counters,
    Check if total number of uncompleted sends and total size of sent packets 
    do not exceed predefined window sizes

Arguments:
    size of sent packet

Returned Value:
   CMtSendManager::eSendEnabled if next packet should be sent (updated counters do not exceed window sizes)
    CMtSendManager::eSendDisabled if next packet should not be sent (updated counters exceed window sizes)

--*/
    CS lock(m_cs);
    m_SentBytes += cbSendSize;
    if (m_SentBytes <= m_SendWindowinBytes)
    {
	    return eSendEnabled;
    }
    else
    {
         m_Suspended = true;
         TrTRACE(NETWORKING, "Send suspended: SentBytes=%d/%d", m_SentBytes, m_SendWindowinBytes); 
         return eSendDisabled;
    }
}


CMtSendManager::MtSendState CMtSendManager::ReportPacketSendCompleted(DWORD cbSendSize)
{
/*++

Routine Description:
    CMtSendManager::ReportPacketSendCompleted called on successful send completion 
    Updates "number of sent packets" and "size of sent packets" counters
    If sends were suspended, checks if total number of uncompleted sends and total size of sent packets 
    do not exceed predefined window sizes

Arguments:
    size of sent packet  

Returned Value:
    CMtSendManager::eSendEnabled if next packet should be sent (sends were suspeneded and updated counters do not exceed window sizes)
    CMtSendManager::eSendDisabled if next packet should not be sent (sends were not suspened or updated counters exceed window sizes)

--*/
        CS lock(m_cs);
        m_SentBytes -= cbSendSize;
        if (m_Suspended && m_SentBytes <= m_SendWindowinBytes)
        {
            m_Suspended = false;
            TrTRACE(NETWORKING, "Send resumed: SentBytes=%d/%d", m_SentBytes, m_SendWindowinBytes); 
            return eSendEnabled;
        }
        return eSendDisabled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mt\test\mttestp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtTestp.h

Abstract:
    Message Transport test, private header.

Author:
    Uri Habusha (urih) 31-Oct-99

--*/

#pragma once

bool IsFailed(void);
void UpdateNoOfsentMessages(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mt\test\group.h ===
#include "msi.h"

#include "mqwin64a.h"
#include "qmpkt.h"
#include "MtTestp.h"


class CGroup: public IMessagePool
{
private:
    class CRequest
    {
    public:
        CRequest(EXOVERLAPPED* pov, CACPacketPtrs& acPacketPtrs) :
            m_pov(pov),
            m_pAcPackts(&acPacketPtrs)
            {
            }
    public:
        EXOVERLAPPED* m_pov;
        CACPacketPtrs* m_pAcPackts;
    };

public:
    CGroup() :
        m_getSleep(TimeToReturnPacket),
        m_fGetScheduled(false)
    {
    }

    virtual ~CGroup()
    {
        ExCancelTimer(&m_getSleep);
    }




    void Requeue(CQmPacket* p)
    {
        delete [] reinterpret_cast<char*>(p->GetPointerToDriverPacket());
    }
    

    void EndProcessing(CQmPacket* p, USHORT)
    {
        delete [] reinterpret_cast<char*>(p->GetPointerToDriverPacket());

        UpdateNoOfsentMessages();
    }


    void LockMemoryAndDeleteStorage(CQmPacket*)
    {
        ASSERT(("CGroup::LockMemoryAndDeleteStorage should not be called!", 0));

        throw exception();
    }


    void GetFirstEntry(EXOVERLAPPED* pov, CACPacketPtrs& acPacketPtrs)
    {
        CS lock(m_cs);

        m_request.push_back(CRequest(pov, acPacketPtrs));
        if (!m_fGetScheduled)
        {
            SafeAddRef(this);

            CTimeDuration sleepInterval(rand()/1000);
            ExSetTimer(&m_getSleep, sleepInterval);
            m_fGetScheduled = true;
        }
    }

    void CancelRequest(void)
    {
        CS lock(m_cs);

        for(std::list<CRequest>::iterator it = m_request.begin(); it != m_request.end(); )
        {
            EXOVERLAPPED* pov = (*it).m_pov;
            pov->SetStatus(STATUS_CANCELLED);
            ExPostRequest(pov);
            
            it = m_request.erase(it);
        }
    }

private:
    static void WINAPI TimeToReturnPacket(CTimer* pTimer);
    
    static ULONG CalcPacketSize(void);
    static char* CreatePacket();

private:
    void TimeToReturnPacket();

private:
    CCriticalSection    m_cs;                   // Critical section

    std::list<CRequest> m_request;

    bool m_fGetScheduled;
    CTimer m_getSleep;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mt\lib\mtresponse.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtConnect.cpp

Abstract:
    Message Transport class - receive respond implementation

Author:
    Uri Habusha (urih) 11-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <singelton.h>
#include <utf8.h>
#include <cm.h>
#include "Mt.h"
#include "Mtp.h"
#include "MtObj.h"


#include "mtresponse.tmh"

const char xHttpScheme[] = "http://";
const char xHttpHeaderTerminater[] = "\r\n\r\n";

//
// Class that holds mapping from http error code to
// handler function
//
class CHttpStatusCodeMapper
{
public:
	CHttpStatusCodeMapper()
	{
		m_StatusMapping[100] = &CMessageTransport::OnHttpDeliveryContinute;


		m_StatusMapping[200] = &CMessageTransport::OnHttpDeliverySuccess;
		m_StatusMapping[201] = &CMessageTransport::OnHttpDeliverySuccess;
		m_StatusMapping[202] = &CMessageTransport::OnHttpDeliverySuccess;
		m_StatusMapping[203] = &CMessageTransport::OnHttpDeliverySuccess;
		m_StatusMapping[204] = &CMessageTransport::OnHttpDeliverySuccess;
		m_StatusMapping[205] = &CMessageTransport::OnHttpDeliverySuccess;

		m_StatusMapping[300] = &CMessageTransport::OnRedirection;
		m_StatusMapping[301] = &CMessageTransport::OnRedirection;
		m_StatusMapping[302] = &CMessageTransport::OnRedirection;
		m_StatusMapping[303] = &CMessageTransport::OnRedirection;
		m_StatusMapping[305] = &CMessageTransport::OnRedirection;
		m_StatusMapping[307] = &CMessageTransport::OnRedirection;

		m_StatusMapping[408] = &CMessageTransport::OnRetryableHttpError;
		
		m_StatusMapping[500] = &CMessageTransport::OnRetryableHttpError;
		m_StatusMapping[501] = &CMessageTransport::OnRetryableHttpError;
		m_StatusMapping[502] = &CMessageTransport::OnRetryableHttpError;
		m_StatusMapping[503] = &CMessageTransport::OnRetryableHttpError;
		m_StatusMapping[504] = &CMessageTransport::OnRetryableHttpError;


		//
		// error code 403 has special setting in regsitry for configure it behaviour
		//
		DWORD HttpRetryOnError403 = 0;
		CmQueryValue(
				RegEntry(NULL, L"HttpRetryOnError403"),
				&HttpRetryOnError403
				);


		if(HttpRetryOnError403 != 0)
		{
			m_StatusMapping[403] = &CMessageTransport::OnRetryableHttpError;									
		}


	}

public:
	typedef void (CMessageTransport::* StatusCodeHandler) (USHORT StatusCode);
	StatusCodeHandler operator[](USHORT StatusCode)  const
	{
		std::map<int, StatusCodeHandler>::const_iterator it =  m_StatusMapping.find(StatusCode);
		if(it ==  m_StatusMapping.end()	 )
			return &CMessageTransport::OnAbortiveHttpError;

		return it->second;
	}
	
private:
	std::map<int, StatusCodeHandler> m_StatusMapping;
};



//
// Class that holds the timeout(miliseconds) to wait
//  before next trial to  requeue packet if previous requeue failed.
//
class CRequeueTimeOut
{
public:
	DWORD GetTimeout() const
	{
		return m_timeout;
	}

private:
	CRequeueTimeOut()
	{
		CmQueryValue(
					RegEntry(NULL, L"RequeueTimeOut", 30000),
					&m_timeout
					);	
	}
private:
	friend CSingelton<CRequeueTimeOut>;
	DWORD m_timeout;
};



void CMessageTransport::HandleExtraResponse(void)
{
    ASSERT(m_responseOv.IsMoreResponsesExistInBuffer());
    //
    // Initialize the Overlapped with receive response call back routines
    //
    m_responseOv =  EXOVERLAPPED(
                                ReceiveResponseHeaderSucceeded,
                                ReceiveResponseFailed
                                );


    //
    // In previous phase we read more than we needed. Copy the spare data to the head of
    // the buffer, update the counter and behave like next read is completed
    //
    memcpy(
        m_responseOv.Header(),
        m_responseOv.Header() + m_responseOv.m_ProcessedSize,
        m_responseOv.m_HeaderValidBytes - m_responseOv.m_ProcessedSize
        );


    m_responseOv.InternalHigh = m_responseOv.m_HeaderValidBytes - m_responseOv.m_ProcessedSize;
    m_responseOv.m_HeaderValidBytes = 0;

    R<CMessageTransport> ar = SafeAddRef(this);

    m_responseOv.SetStatus(STATUS_SUCCESS);
    ExPostRequest(&m_responseOv);

    ar.detach();
}


DWORD CMessageTransport::FindEndOfResponseHeader(LPCSTR buf, DWORD length)
{
    if (4 > length)
        return 0;

    for(DWORD i = 0; i < length - 3; ++i)
    {
        if (buf[i] != '\r')
            continue;

        if ((buf[i+1] == '\n') && (buf[i+2] == '\r') && (buf[i+3] == '\n'))
        {
            return (i + 4);
        }
    }

    return 0;
}



xstr_t CMessageTransport::GetNewLocation(LPCSTR p, DWORD length)
/*++

Routine Description:
    Return the redirected location from the http response. Called when the http response
	30x accepted , which means that the target url was redirected to other url.

Arguments:
    p - Point to http response header start.
	length - The length of the http respose header.

Returned Value:
    The redirected url or empty xstr_t if not found.

Note:
	The new url is specified in the Location header

--*/
{
	const char xLocation[] = "\r\nLocation:";
	const char xHeaderTerminator[] = "\r\n";

	const LPCSTR pEnd = p + length;
	p = std::search(
					p,
					pEnd,
					xLocation,
					xLocation + STRLEN(xLocation)
					);
	if(p == pEnd)
		return xstr_t();

	const LPCSTR pStartLocation = p + STRLEN(xLocation);
	p = std::search(
		pStartLocation,
		pEnd,
		xHeaderTerminator,
		xHeaderTerminator + STRLEN(xHeaderTerminator)
		);

	if(p == pEnd)
		return xstr_t();

	return xstr_t(pStartLocation, p - pStartLocation);			
}



DWORD CMessageTransport::GetContentLength(LPCSTR p, DWORD length, USHORT HttpStatus)
{
	const char xContentlength[] = "Content-Length:";

    const LPCSTR pEnd = p + length - 4;

    //
    // HTTP header must terminate with '\r\n\r\n'. We already parse
    // the header and find it as a legal HTTP header.
    //
    ASSERT(length >= 4);
    ASSERT(strncmp(pEnd, xHttpHeaderTerminater, 4) == 0);


    while (p < pEnd)
    {
        if (_strnicmp(p, xContentlength , STRLEN(xContentlength)) == 0)
            return atoi(p + STRLEN(xContentlength));

        for(;;)
        {
            if ((p[0] == '\r') && (p[1] == '\n'))
            {
                p += 2;
                break;
            }

            ++p;
        }
    }

	//
	// BUGBUG:workaround, since IIS send 100 response without Content-Length field
	//												Uri Habusha, 16-May-200
	//
    if (HttpStatus == 100)
        return 0;

    //
    // Response header doesn't contain 'Content-Length' field.
    //
    throw exception();
}


void WINAPI CMessageTransport::TimeToResponseTimeout(CTimer* pTimer)
{
    R<CMessageTransport> pmt = CONTAINING_RECORD(pTimer, CMessageTransport, m_responseTimer);

    TrERROR(NETWORKING, "Failed to receive response in time, shutting down.pmt=0x%p", pmt.get());
    pmt->Shutdown();
}


void CMessageTransport::StartResponseTimeout(void)
{
    CS lock(m_csResponse);

    //
    // Check that the waiting list isn't empty and there is a pending message that
    // waiting for response.
    // The list can be empty although only now the sending is completed and handling.
    // The scenario is: UMS adds the message to waiting for response list before the
    // sending is started; However the timer is armed only after the sending is completed.
    // In the meantime, the response has been received, and the message removed from the list.
    //
    if (m_response.empty() || m_fResponseTimeoutScheduled)
        return;

    m_fResponseTimeoutScheduled = true;

    AddRef();
    ExSetTimer(&m_responseTimer, m_responseTimeout);
}



void CMessageTransport::CancelResponseTimer(void)
{
    //
    // Canceling the timer and setting of the flag should be atomic operation. Otherwise,
    // there is a scenario in which the timer is not setting although there is a pending
    // message that waiting for response.
    // This can be occurred if before setting the flag to false, there is a thread
    // switch and StartResponseTimeout routine is activated. Although the timer isn't
    // setting the flag is true, as a result the routine doesn't set the timer and UMS doen't
    // identifies connection problem
    //
    CS lock(m_csResponse);

    if (!ExCancelTimer(&m_responseTimer))
        return;

    ASSERT(m_fResponseTimeoutScheduled);
    m_fResponseTimeoutScheduled = false;

    //
    // Decrement refernce count taken for the timer
    //
    Release();
}



bool CMessageTransport::IsPipeLineMode() const
{
	bool fHttp10Delivery = CSingelton<CHttpDeliveryVesrion>::get().IsHttp10Delivery();
	return !fHttp10Delivery && m_SocketTransport->IsPipelineSupported();
}



void CMessageTransport::CompleteProcessResponse(USHORT mqclass)
{
    //
    // Protect waiting for response list
    //
    CS lock (m_csResponse);

	CancelResponseTimer();

    if (m_response.empty())
    {
        ASSERT((State() == csShutdownCompleted));
        return;
    }


    P<CQmPacket> pPkt = &m_response.front();
    m_response.pop_front();


	//
	// Test if gave ownership to the qm (case of order packet)
	//
	if(AppPostSend(pPkt, mqclass))
	{
		pPkt.detach();
	}
	else
	{
		m_pMessageSource->EndProcessing(pPkt, mqclass);
	}



	//
	// If we are in pause state and got response on all messages
	// - we can shutdown
	//
	if(m_response.empty() && m_fPause)
	{
		Shutdown(PAUSE);
		return;
	}

	
	//
	// If http 1.0 delivery we close the connection
	//
	if(CSingelton<CHttpDeliveryVesrion>::get().IsHttp10Delivery())
	{
		TrTRACE(SRMP,"Http 1.0 delivery - MSMQ close the connection");
		Shutdown(OK);
		return;		
	}	

	//
	// If we are not in pipeline mode (https) we should ask the driver
	// to bring us next packet for delivery, because only now we finished
	// reading response for the current request.
	//
	if(!IsPipeLineMode())
	{
		ASSERT(m_response.empty());
		GetNextEntry();
	}
}


void CMessageTransport::ReceiveResponseHeaderChunk(void)
{
    //
    // Increment refernce count for asynchronous context
    //
    R<CMessageTransport> ar = SafeAddRef(this);


    //
    // Receive next response header chunk
    //
    m_pConnection->ReceivePartialBuffer(
        m_responseOv.Header() + m_responseOv.m_HeaderValidBytes,
        m_responseOv.HeaderAllocatedSize() - m_responseOv.m_HeaderValidBytes,
        &m_responseOv
        );


    ar.detach();
}



void CMessageTransport::ReceiveResponse(void)
{
    if (m_responseOv.IsMoreResponsesExistInBuffer())
    {
        HandleExtraResponse();
        return;
    }

    //
    // Initialize the Overlapped with receive response call back routines
    //
    m_responseOv = EXOVERLAPPED(ReceiveResponseHeaderSucceeded, ReceiveResponseFailed);
    m_responseOv.m_HeaderValidBytes = 0;


    //
    // Receive first chunk of response header
    //
    ReceiveResponseHeaderChunk();
}


void CMessageTransport::ProcessResponse(LPCSTR buf, DWORD length)
{
	if (length <= STRLEN("HTTP/1.1"))
	{
		//
		// buffer is not valid response, close socket
		//
		throw exception();
	}
    m_responseOv.m_ResponseStatus = static_cast<USHORT>(atoi(buf + STRLEN("HTTP/1.1")));

    TrTRACE(NETWORKING, "Received HTTP response, Http Status=%d. pmt=0x%p", m_responseOv.m_ResponseStatus, this);


    // Response was received. Cancel the response timer
    //
    CancelResponseTimer();

	CHttpStatusCodeMapper::StatusCodeHandler Handler = CSingelton<CHttpStatusCodeMapper>::get()[m_responseOv.m_ResponseStatus];
	(this->*Handler)(m_responseOv.m_ResponseStatus);
}


void CMessageTransport::ReceiveResponseHeaderSucceeded(void)
/*++

Routine Description:
    The routine is called when receive response completes succesfully.

Arguments:
    None

Returned Value:
    None.

--*/
{
    //
    // For byte streams, zero bytes having been read indicates graceful closure
    // and that no more bytes will ever be read.
    //
	DWORD bytesTransfered = DataTransferLength(m_responseOv);
    if (bytesTransfered == 0)
    {
        TrERROR(NETWORKING, "Failed to receive response, connection was closed. pmt=0x%p", this);
        throw exception();
    }



    TrTRACE(NETWORKING, "Received response header. chunk bytes=%d, total bytes=%d", bytesTransfered, m_responseOv.m_HeaderValidBytes);


    //
    // Signal idle timer that this transport is active
    //
    MarkTransportAsUsed();

    //
    // Find out if the entire header was received
    //
    m_responseOv.m_HeaderValidBytes += bytesTransfered;

    m_responseOv.m_ProcessedSize = FindEndOfResponseHeader(
                                        m_responseOv.Header(),
                                        m_responseOv.m_HeaderValidBytes
                                        );
    if (m_responseOv.m_ProcessedSize != 0)
    {
       //
        // The enire header was received. Process the response.
        // Go and read the attached message (if one exist).
        //
        ProcessResponse(m_responseOv.Header(), m_responseOv.m_ProcessedSize);
        ReceiveResponseBody();
        return;
    }


    if(m_responseOv.HeaderAllocatedSize() == m_responseOv.m_HeaderValidBytes)
    {
        //
        // Header buffer is too small. Reallocate header buffer
        //
        if( m_responseOv.HeaderAllocatedSize() + CResponseOv::xHeaderChunkSize > CResponseOv::xMaxHeaderSize)
        {
            TrERROR(NETWORKING, "Response is too large, connection was closed. pmt=0x%p", this);
            throw exception();
        }

        m_responseOv.ReallocateHeaderBuffer(m_responseOv.HeaderAllocatedSize() + CResponseOv::xHeaderChunkSize);
    }

    //
    // Validate that we didn't read past the buffer
    //
    ASSERT(m_responseOv.HeaderAllocatedSize() > m_responseOv.m_HeaderValidBytes);

    //
    // Receive next chunk of response header
    //
    ReceiveResponseHeaderChunk();
}


void WINAPI CMessageTransport::ReceiveResponseHeaderSucceeded(EXOVERLAPPED* pov)
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

    CResponseOv* pResponse = static_cast<CResponseOv*>(pov);
    R<CMessageTransport> pmt = CONTAINING_RECORD(pResponse, CMessageTransport, m_responseOv);

    try
    {
        pmt->ReceiveResponseHeaderSucceeded();
    }
    catch(const exception&)
    {
        TrERROR(NETWORKING, "Failed to process received response header, shutting down. pmt=0x%p", pmt.get());
        pmt->Shutdown();
        throw;
    }
}


void WINAPI CMessageTransport::ReceiveResponseFailed(EXOVERLAPPED* pov)
/*++

Routine Description:
    Callback routine. The routine is called when receive of respond failed

Arguments:
    pov - Pointer to EXOVERLAPPED

Returned Value:
    None.

--*/
{
    ASSERT(FAILED(pov->GetStatus()));

    //
    // get the message transport object
    //
    CResponseOv* pResponse = static_cast<CResponseOv*>(pov);
    R<CMessageTransport> pmt = CONTAINING_RECORD(pResponse, CMessageTransport, m_responseOv);

    TrERROR(NETWORKING, "Failed to receive respond, shutting down. pmt=0x%p Status=0x%x", pmt.get(), pmt->m_responseOv.GetStatus());

    pmt->Shutdown();
}


void CMessageTransport::ReceiveResponseBodyChunk()
{
    //
    // Increment refernce count for asynchronous context
    //
    R<CMessageTransport> ar = SafeAddRef(this);

    //
    // Receive the entity body chunck to the same buffer, as it is ignored
    //
    m_pConnection->ReceivePartialBuffer(
        m_responseOv.m_Body,
        m_responseOv.BodyChunkSize(),
        &m_responseOv
        );

    ar.detach();
}


void CMessageTransport::ReceiveResponseBody()
{
    try
    {
        m_responseOv.m_ProcessedSize += GetContentLength(
                                            m_responseOv.Header(),
                                            m_responseOv.m_ProcessedSize,
                                            m_responseOv.m_ResponseStatus
                                            );
    }
    catch(const exception&)
    {
        //
        // Response doesn't contains 'Content-Length' Header. Close the connection.
        //
        throw;
    }

    if (m_responseOv.m_HeaderValidBytes >= m_responseOv.m_ProcessedSize)
    {
	    ReceiveResponse();
		StartResponseTimeout();
        return;
    }


    m_responseOv =  EXOVERLAPPED(ReceiveResponseBodySucceeded, ReceiveResponseFailed);
    m_responseOv.m_BodyToRead = m_responseOv.m_ProcessedSize - m_responseOv.m_HeaderValidBytes;


    //
    // Receive first chunk of entity body
    //
    ReceiveResponseBodyChunk();
}


void CMessageTransport::ReceiveResponseBodySucceeded(void)
{
    //
    // For byte streams, zero bytes having been read indicates graceful closure
    // and that no more bytes will ever be read.
    //
	DWORD bytesTransfered = DataTransferLength(m_responseOv);
    if (bytesTransfered == 0)
    {
        TrERROR(NETWORKING, "Failed to receive response body, connection was closed. pmt=0x%p", this);
        throw exception();
    }

    ASSERT(bytesTransfered <= m_responseOv.m_BodyToRead);

    TrTRACE(NETWORKING, "Received response body. chunk bytes=%d, bytes remaining=%d", bytesTransfered, m_responseOv.m_BodyToRead);

    //
    // Mark the transport as used
    //
    MarkTransportAsUsed();

    m_responseOv.m_BodyToRead -= bytesTransfered;

    if (m_responseOv.m_BodyToRead == 0)
    {
        //
        // The entire body was read successfully.
        //
	    ReceiveResponse();
		StartResponseTimeout();
	    return;
    }

    //
    // Receive next chunk of entity body
    //
    ReceiveResponseBodyChunk();
}


void WINAPI CMessageTransport::ReceiveResponseBodySucceeded(EXOVERLAPPED* pov)
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

    CResponseOv* pResponse = static_cast<CResponseOv*>(pov);
    R<CMessageTransport> pmt = CONTAINING_RECORD(pResponse, CMessageTransport, m_responseOv);

    try
    {
        pmt->ReceiveResponseBodySucceeded();
    }
    catch(const exception&)
    {
        TrERROR(NETWORKING, "Failed to process received response body, shutting down. pmt=0x%p", pmt.get());
        pmt->Shutdown();
        throw;
    }
}



void CMessageTransport::RequeueUnresponsedPackets(void)
{
		//
		// return all unresponse packets to the queue
		//
		while (!m_response.empty())
		{
			CQmPacket*  pPacket = &m_response.front();
			m_response.pop_front();
			m_pMessageSource->Requeue(pPacket);
		}
}






void CMessageTransport::OnRedirection(USHORT  HttpStatusCode )
/*++

Routine Description:
   Called when http errors 30x returned from the server which means redirection
   of the request to a new url. The new url is set on the message source and
   the transport is shutdown. Next time the transport will be loaded - the new target will
   be used.
	
Arguments:
    HttpStatusCode - http error code.

Returned Value:
    None.

--*/
{
	TrERROR(NETWORKING, "Received HTTP redirection response '%d'. pmt=0x%p", HttpStatusCode, this);

	xstr_t NewLocation = GetNewLocation(m_responseOv.Header(), m_responseOv.m_ProcessedSize);
	if(NewLocation.Length() == 0)
	{
		TrERROR(NETWORKING, "could not find new location from response header of error %d ", HttpStatusCode);
		OnAbortiveHttpError(HttpStatusCode);		
		return;
	}

	P<WCHAR> NewLocationstr = UtlUtf8ToWcs(
						(utf8_char*)NewLocation.Buffer(),
						NewLocation.Length(),
						NULL
						);

	m_pMessageSource->OnRedirected(NewLocationstr.get());
	Shutdown(OK);
}


void CMessageTransport::OnAbortiveHttpError(USHORT  HttpStatusCode )
/*++

Routine Description:
    The routine is called when retryable abortive error returned from the server.
	The message is deleted with the correct class code and the
	transport will be shutdown. The queue will be remaind in the Non active group
	ready to deliver the next message.
	

Arguments:
    HttpStatusCode - http error code.

Returned Value:
    None.

--*/
{
	CompleteProcessResponse(CREATE_MQHTTP_CODE(HttpStatusCode));
	TrERROR(NETWORKING, "Received HTTP abortive  error response '%d'. pmt=0x%p", HttpStatusCode, this);
	Shutdown(RETRYABLE_DELIVERY_ERROR);
}



void CMessageTransport::OnHttpDeliverySuccess(USHORT   /* HttpStatusCode */)
/*++

Routine Description:
    The routine is called when http status OK returned from the server.
	The message is deleted and delivery continute.


Arguments:
    HttpStatusCode - http error code.

Returned Value:
    None.

--*/
{
	CompleteProcessResponse(MQMSG_CLASS_NORMAL);
}



void CMessageTransport::OnRetryableHttpError(USHORT HttpStatusCode )
/*++

Routine Description:
    The routine is called when retryable http  error returned from the server.
	Execption is thrown , the transport will be shutdown and
	the queue will be moved to the waiting list to delay the deivery for a while.


Arguments:
    HttpStatusCode - http error code.

Returned Value:
    None.

--*/
{
    TrERROR(NETWORKING, "Received HTTP retryable error response '%d'. pmt=0x%p", HttpStatusCode, this);
    throw exception();
}



void CMessageTransport::OnHttpDeliveryContinute(USHORT /* HttpStatusCode */)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mt\test\no.cpp ===
#include <libpch.h>
#include "No.h"
#include "Ex.h"
#include "MtTestp.h"

#include "no.tmh"

using namespace std;

const char xShortOkResponse[] =		"HTTP/1.1 200 OK\r\n"
									"Content-Length: 0\r\n"
									"\r\n"
									;

const char xShortFailResponse[] =	"HTTP/1.1 500 Internal Server Error\r\n"
									"Connection: close\r\n"
									"Content-Length: 0\r\n"
									"\r\n"
									;

const char xLongOkResponse[] =		"HTTP/1.1 200 OK\r\n"
									"Header1: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header2: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Content-Length: 400\r\n"
									"Header3: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header4: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header5: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"\r\n"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									;

const char xLongFailResponse[] =	"HTTP/1.1 500 Internal Server Error\r\n"
									"Connection: close\r\n"
									"Header1: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header2: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Content-Length: 400\r\n"
									"Header3: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header4: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header5: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"\r\n"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									;

const char xOkResponseNoContentLength[] =
                            		"HTTP/1.1 200 OK\r\n"
									"\r\n"
                                    ;

const char xInformativeResponseNoContentLength[] =
                            		"HTTP/1.1 100 Continue\r\n"
									"\r\n"
									;

const char xFailResponseNoContentLength[] =
                            		"HTTP/1.1 500 Internal Server Error\r\n"
									"\r\n"
									;

const LPCSTR xResponses[] = {
	xShortOkResponse,
	xShortFailResponse,
	xLongOkResponse,
	xLongFailResponse,
    xOkResponseNoContentLength,
    xInformativeResponseNoContentLength,
    xFailResponseNoContentLength,
  
  };

struct SockInfo
{
    SockInfo(void) : 
        pBuffer(NULL),
        nBytesToRead(0),
        ByteReads(0),
        pov(NULL)
    {
    }

    CCriticalSection m_csResponse;
    list<LPCSTR> response;
    DWORD ByteReads;

    VOID* pBuffer;                                     
    DWORD nBytesToRead; 
    EXOVERLAPPED* pov;
};

typedef map<SOCKET, SockInfo*> SOCKET2INFO;
SOCKET2INFO s_mapSockInfo;


//
VOID
NoInitialize(
    VOID
    )
{
}


static SOCKET s_socket = 0;

SOCKET 
NoCreateStreamConnection(
    VOID
    )
{
    if (IsFailed())
    {
        throw exception();
    }

    s_mapSockInfo[++s_socket] = new SockInfo;

    TrTRACE(NETWORKING, "Create Socket 0x%Ix", s_socket);

    return s_socket;
}


VOID 
NoConnect(
    SOCKET Socket,
    const SOCKADDR_IN&,
    EXOVERLAPPED* pov
    )
{
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    if (it == s_mapSockInfo.end() || IsFailed())
    {
        if ((rand() %2) == 0)
            throw exception();

        pov->SetStatus(STATUS_UNSUCCESSFUL);
        ExPostRequest(pov);
        return;
    }

    pov->SetStatus(STATUS_SUCCESS);
    ExPostRequest(pov);
}


VOID
NoCloseConnection(
    SOCKET Socket
    )
{
	SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    TrTRACE(NETWORKING, "Close Socket 0x%Ix", Socket);

    if (it != s_mapSockInfo.end())
    {
        SockInfo* p = it->second;
        
        if (p->pov != NULL)
        {
            EXOVERLAPPED* pov = p->pov;

            p->pBuffer = NULL;
            p->pov = NULL;
            p->nBytesToRead = 0;

            pov->SetStatus(STATUS_UNSUCCESSFUL);
            ExPostRequest(pov);
        }

        s_mapSockInfo.erase(it);
        delete p;
    }
}





VOID
NoSend(
    SOCKET Socket,                                              
    const WSABUF*,
    DWORD, 
    EXOVERLAPPED* pov
    )
{ 
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    if (it == s_mapSockInfo.end() || IsFailed())
    {
        if ((rand() %2) == 0)
            throw exception();

        pov->SetStatus(STATUS_UNSUCCESSFUL);
        ExPostRequest(pov);
        return;
    }


    SockInfo* p = it->second;               
    {
        CS lock(p->m_csResponse);
        p->response.push_back(xResponses[rand() % TABLE_SIZE(xResponses)]);
    }

    pov->SetStatus(STATUS_SUCCESS);
    

	if (p->pov != NULL)
    {
        //
        // pending reponse receive
        //
        EXOVERLAPPED* pov = p->pov;
        PVOID pBuffer = p->pBuffer;
        DWORD nBytesToRead = p->nBytesToRead;
        p->pBuffer = NULL;
        p->pov = NULL;
        p->nBytesToRead = 0;

        NoReceivePartialBuffer(Socket, pBuffer, nBytesToRead, pov);
    }
	else
	{
		ExPostRequest(pov);
	}

}


VOID
NoReceivePartialBuffer(
    SOCKET Socket,                                              
    VOID* pBuffer,                                     
    DWORD nBytesToRead, 
    EXOVERLAPPED* pov
    )
{
    TrTRACE(NETWORKING, "NoReceivePartialBuffer: Socket=0x%Ix Buffer=0x%p BytesToRead=%d ov=0x%p", Socket, pBuffer, nBytesToRead, pov);
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    if (it == s_mapSockInfo.end() || IsFailed())
    {
        pov->InternalHigh = 0;

        if (rand()%4 == 0)
		{
			printf("NoReceivePartialBuffer throw on pov=%p \n", pov);
            throw exception();
		}

        if (rand()%4 == 1)
        {
            pov->SetStatus(STATUS_SUCCESS);
        }
        else
        {
            pov->SetStatus(STATUS_UNSUCCESSFUL);
        }

        ExPostRequest(pov);
        
        return;
    }

    SockInfo* p = it->second;               

    {
        CS lock(p->m_csResponse);
        if (p->response.empty())
        {
            p->pBuffer = pBuffer;                                   
            p->nBytesToRead = nBytesToRead;
            p->pov = pov;
            return;
        }
    }

    p->pBuffer = NULL;                                   
    p->nBytesToRead = 0;
    p->pov = NULL;

    LPCSTR response;
    {
        CS lock(p->m_csResponse);
        response = p->response.front();
    }

    DWORD length = min(nBytesToRead, (strlen(response) - p->ByteReads));

    memcpy(pBuffer, (response + p->ByteReads), length);
    p->ByteReads += length;

    pov->InternalHigh = length;
    
    bool fReadAllResponse = false;
    if (p->ByteReads == strlen(response))
    {
        CS lock(p->m_csResponse);
        p->response.pop_front();
        p->ByteReads = 0;
        fReadAllResponse = true;
    }
     
    pov->SetStatus(STATUS_SUCCESS);
    ExPostRequest(pov);
}



bool
NoGetHostByName(
	LPCWSTR host,
	std::vector<SOCKADDR_IN>* pAddr,
	bool fUseCache
    )
{
	UNREFERENCED_PARAMETER(host);
	UNREFERENCED_PARAMETER(fUseCache);

	SOCKADDR_IN Addr;

	Addr.sin_family = AF_INET;
    Addr.sin_addr.S_un.S_addr = rand();
	pAddr->push_back(Addr);

	return true;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mtm\lib\mtm.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    Mtm.cpp

Abstract:

    Multicast Transport Manager general functions

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include <mqwin64a.h>
#include <mqsymbls.h>
#include <mqformat.h>
#include "Mtm.h"
#include "Mtmp.h"
#include "mmt.h"

#include "mtm.tmh"

VOID 
MtmCreateTransport(
    IMessagePool* pMessageSource,
	ISessionPerfmon* pPerfmon,
	MULTICAST_ID id
    ) 
/*++

Routine Description:

    Handle new queue notification. Create a new message transport.

Arguments:

    pMessageSource  - Pointer to message source interface.

    id - The multicast address and port.

Returned Value:

    None.

--*/
{
    MtmpAssertValid();

    ASSERT(pMessageSource != NULL);

	MtmpCreateNewTransport(
			pMessageSource, 
			pPerfmon,
            id
			);
} // MtmCreateTransport


VOID
MtmTransportClosed(
    MULTICAST_ID id
    )
/*++

Routine Description:

    Notification for closing connection. Removes the transport from the
    internal database and checkes if a new transport should be created (the associated 
    queue is in idle state or not)

Arguments:

    id - The multicast address and port.

Returned Value:

    None.

--*/
{
    MtmpAssertValid();

    WCHAR buffer[MAX_PATH];
    MQpMulticastIdToString(id, buffer, TABLE_SIZE(buffer));
    TrTRACE(NETWORKING, "MtmTransportClosed. transport to: %ls", buffer);

    MtmpRemoveTransport(id);

} // MtmTransportClosed


VOID 
MtmTransportPause(
    MULTICAST_ID id
    )
{
	R<CMulticastTransport> mcTransport = MtmGetTransport(id);
	if (mcTransport.get() == NULL)
		return;

	if(WPP_LEVEL_COMPID_ENABLED(rsTrace, NETWORKING))
	{
		WCHAR buffer[MAX_PATH];
		MQpMulticastIdToString(id, buffer, TABLE_SIZE(buffer));
		TrTRACE(NETWORKING, "Pause multicast transport to: %ls", buffer);
	}

	mcTransport->Pause();
}


VOID
MtmDisconnect(
	VOID
	)
{
	for(R<CMulticastTransport> p = MtmFindFirst(); (p.get() != NULL); p = MtmFindFirst())
	{
		if(WPP_LEVEL_COMPID_ENABLED(rsTrace, NETWORKING))
		{
			WCHAR buffer[MAX_PATH];
			MQpMulticastIdToString(p->MulticastId(), buffer, TABLE_SIZE(buffer));
			TrTRACE(NETWORKING, "Pause multicast transport to: %ls", buffer);
		}

		p->Pause();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mt\test\st.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    st.cpp

Abstract:
    Simulation of St library

Author:
    Gil Shafriri (gilsh) 11-June-2000

--*/

#include <libpch.h>
#include <st.h>
#include <no.h>
#include <xstr.h>


#include "MtTestp.h"
#include "st.tmh"

class CWinsockConnection : public IConnection	
{					 
public:
	CWinsockConnection(
			):
			m_socket(NoCreateStreamConnection())
	{
		
	}			

	void Init(const std::vector<SOCKADDR_IN> Addr, EXOVERLAPPED* pOverlapped,SOCKADDR_IN* )
	{
		NoConnect(m_socket, Addr[0], pOverlapped);
	}


	virtual 
	void 
	ReceivePartialBuffer(
					VOID* pBuffer,                                     
					DWORD Size, 
					EXOVERLAPPED* pov
					)
	{
		printf("send called on ovl=%p \n", pov);
		NoReceivePartialBuffer(m_socket, pBuffer, Size, pov);
	}


 	virtual 
	void 
	Send(
		const WSABUF* Buffers,                                     
		DWORD nBuffers, 
		EXOVERLAPPED* pov
		)
	{
		printf("send called on ovl=%p \n", pov);
		NoSend(m_socket, Buffers, nBuffers,  pov);
	}


	virtual void Close()
	{
		printf("closed called \n");
		NoCloseConnection(m_socket);
		m_socket.free();
	}


private:
	CSocketHandle m_socket;
};



class CSimpleWinsock :public ISocketTransport
{

public:
	virtual void CreateConnection(
		const std::vector<SOCKADDR_IN>& Addr, 
			EXOVERLAPPED* pOverlapped,
			SOCKADDR_IN* pAddr
			)
	{
		m_pConnection = new  CWinsockConnection();
		m_pConnection->Init(Addr, pOverlapped, pAddr); 
	}


	virtual R<IConnection> GetConnection()
	{
		return m_pConnection; 
	}


	bool IsPipelineSupported(void)
	{
		return true;
	}

	
	virtual
	bool
	GetHostByName(
    LPCWSTR host,
	std::vector<SOCKADDR_IN>* pAddr,
	bool fUseCache = true
    )
	{
		return NoGetHostByName(host, pAddr, fUseCache);		
	}

private:
	R<CWinsockConnection> m_pConnection;
};


ISocketTransport* StCreateSslWinsockTransport(
	const xwcs_t& /*ServerName*/,
	USHORT /*port*/,
	bool /*Proxy*/
	)
{
	return new CSimpleWinsock();
}


ISocketTransport* StCreateSimpleWinsockTransport(void)
{
	return new 	CSimpleWinsock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mt\test\mttest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MtTest.cpp

Abstract:
    Message Transport library test

Author:
    Uri Habusha (urih) 11-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <Ex.h>
#include <No.h>
#include <Mt.h>
#include <Mp.h>
#include <spi.h>
#include <cm.h>
#include <utf8.h>
#include "MtTestp.h"
#include "group.h"

#include "MtTest.tmh"

const WCHAR queueUrl[] = L"http://foo\\msmq\\q1";

const WCHAR host[] = L"foo";

const WCHAR uri[] = L"msmq\\q1";
const xwcs_t nextUri(uri, STRLEN(uri));

static DWORD s_FailedRate = 0;
static DWORD s_NoOfMessages = 1000;
static HANDLE s_hEvent;

//
// Dummy function to link ph files
//
void ReportAndThrow(LPCSTR)
{
	ASSERT(0);
}

void AppRequeueMustSucceed(CQmPacket *p)
{
    delete [] reinterpret_cast<char*>(p->GetPointerToDriverPacket());
}


bool CHttpDeliveryVesrion::IsHttp10Delivery()const
{
	return false;
}



CHttpDeliveryVesrion::CHttpDeliveryVesrion()
{
}


class CSessionPerfmon : public ISessionPerfmon
{
public:
    CSessionPerfmon() : m_fInstanceCreated(false) 
    {
    }

    ~CSessionPerfmon()
    {
    }
    
	void CreateInstance(LPCWSTR)
	{
		m_fInstanceCreated = true;
	}

	void UpdateBytesSent(DWORD )
	{
		ASSERT(m_fInstanceCreated);
	}

	void UpdateMessagesSent(void)
	{
		ASSERT(m_fInstanceCreated);
	}

	void UpdateBytesReceived(DWORD )
	{
		ASSERT(m_fInstanceCreated);
	}

	void UpdateMessagesReceived(void)
    {
		ASSERT(m_fInstanceCreated);
    }

private:
	bool m_fInstanceCreated;
};


static R<CTransport> s_pTrans(NULL);

void UpdateNoOfsentMessages(void)
{
    if (--s_NoOfMessages == 0)
        SetEvent(s_hEvent);
}


bool IsFailed(void)
{
    if (s_FailedRate == 0)
        return FALSE;

    return ((DWORD)(rand() % 100) < s_FailedRate);
}

   
static GUID s_machineId = {1234, 12, 12, 1, 1, 1, 1, 1, 1, 1, 1};

const GUID&
McGetMachineID(
    void
    )
{
    return s_machineId;
}





VOID
AppNotifyTransportClosed(
    LPCWSTR queuePath
    )
{
    ASSERT(wcscmp(queuePath, queueUrl) ==0);
	DBG_USED(queuePath);

    R<CGroup> pGroup = new CGroup();
	R<CSessionPerfmon> pPerfmon = new CSessionPerfmon;


    bool fFailed;

    do
    {
        fFailed = false;
        try
        {
            s_pTrans = MtCreateTransport(
                                xwcs_t(host, STRLEN(host)),
                                xwcs_t(uri, STRLEN(uri)),
                                xwcs_t(uri, STRLEN(uri)),
                                80,
								80,
                                queueUrl,
                                pGroup.get(),
								pPerfmon.get(),
                                CTimeDuration (100 * CTimeDuration::OneMilliSecond().Ticks()),
                                CTimeDuration(100 * CTimeDuration::OneMilliSecond().Ticks()),
								false,
                                200000
                                );
        }
        catch(const exception&)
        {
            fFailed = true;
        }
    } while(fFailed);
                    
    pGroup.free();
}




R<CSrmpRequestBuffers>
MpSerialize(
    const CQmPacket& pkt,
	LPCWSTR targethost,
	LPCWSTR uri
	)
{
	return new CSrmpRequestBuffers(pkt, targethost, uri);	
}


CSrmpRequestBuffers::CSrmpRequestBuffers(
							const  CQmPacket& pkt,
							LPCWSTR host, 
							LPCWSTR 
							):
							m_pkt(pkt),
							m_HttpRequestData(512),
							m_envelope('a' ,200)
{

	size_t targethostLen;
	m_targethost = UtlWcsToUtf8(host, &targethostLen);

	WSABUF buffer;
	buffer.buf = (LPSTR)m_envelope.c_str();
    buffer.len = numeric_cast<DWORD>(m_envelope.size());
    m_buffers.push_back(buffer);
}



size_t CSrmpRequestBuffers::GetNumberOfBuffers() const
{
	return m_buffers.size();
}


const WSABUF* CSrmpRequestBuffers::GetSendBuffers() const
{
	return m_buffers.begin();
}

size_t CSrmpRequestBuffers::GetSendDataLength() const
{
	size_t sum = 0;
	for(std::vector<WSABUF>::const_iterator it = m_buffers.begin(); it != m_buffers.end();++it)
	{
		sum += it->len;		
	}
	return sum;
}


BYTE*  CSrmpRequestBuffers::SerializeSendData() const
{
	size_t SendDataLength =  GetSendDataLength();
	AP<BYTE>  SendData = new BYTE[SendDataLength];
	BYTE* ptr = SendData.get(); 
	for(std::vector<WSABUF>::const_iterator it = m_buffers.begin(); it != m_buffers.end();++it)
	{
		memcpy(ptr, it->buf, it->len);
		ptr += it->len;
	}
	ASSERT(numeric_cast<size_t>((ptr -  SendData.get())) == SendDataLength);
	return 	SendData.detach();
}




CQmPacket::CQmPacket(
    CBaseHeader *pPkt, 
    CPacket *pDriverPkt,
    bool,
    bool):
        m_pDriverPacket(pDriverPkt)
{
    PCHAR pSection;

    m_pBasicHeader = pPkt;

    pSection = m_pBasicHeader->GetNextSection();
    m_pcUserMsg = (CUserHeader*) pSection;

    ASSERT(m_pcUserMsg->PropertyIsIncluded());

    pSection = m_pcUserMsg->GetNextSection();
    m_pcMsgProperty = (CPropertyHeader*) pSection;

    m_pXactSection = NULL;
    m_pSecuritySection = NULL;
}


void Usage(void)
{
	printf("Usage: mttest -n <no of messages> [-f xxx] [-h]\n");
    printf("\tn - Number of messages\n");
	printf("\tf - Fail rate\n");
	printf("\th - Print this message\n");
	exit(-1);
}


extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
/*++

Routine Description:
    Test Message Transport library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
	TrInitialize();
	CmInitialize(HKEY_LOCAL_MACHINE, L"Software\\Microsoft", KEY_ALL_ACCESS);


    --argc;
    ++argv;

    s_FailedRate = 0;
    
    while (argc > 0)
	{
		if (argv[0][0] != L'-') 
			Usage();

		switch(argv[0][1])
		{
            case L'n':
            case L'N':
                s_NoOfMessages = _wtoi(argv[1]);
				argc -= 2;
				argv += 2;
                break;

            case L'f':
			case L'F':
		        s_FailedRate = _wtoi(argv[1]);
				argc -= 2;
				argv += 2;
				break;


            default:
				Usage();
		}
    }

    ExInitialize(5);
    NoInitialize();
    MtInitialize();

    s_hEvent = CreateEvent(NULL, FALSE, FALSE, L"");

    R<CGroup> pGroup = new CGroup();
	R<CSessionPerfmon> pPerfmon = new CSessionPerfmon;

    bool fFailed = false;

    do
    {
        try
        {
            s_pTrans = MtCreateTransport(
                                    xwcs_t(host, STRLEN(host)),
                                    xwcs_t(uri, STRLEN(uri)),
                                    xwcs_t(uri, STRLEN(uri)),
                                    80,
									80,
                                    queueUrl,
                                    pGroup.get(),
									pPerfmon.get(),
                                    CTimeDuration (100 * CTimeDuration::OneMilliSecond().Ticks()),
                                    CTimeDuration(100 * CTimeDuration::OneMilliSecond().Ticks()),
									false,
                                    200000
                                    );
        }
        catch(const exception&)
        {
            fFailed = true;
        }
    } while(fFailed);
    
    pGroup.free();

    WaitForSingleObject(s_hEvent, INFINITE);

    return 0;
}





bool AppCanDeliverPacket(CQmPacket*)
{
	int static count =0;
	if(count++ == 10)
		return false;

	return true;
}


void AppPutPacketOnHold(CQmPacket* )
{
			
}

bool AppPostSend(CQmPacket*, USHORT)
{
	 return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mtm\lib\mtminit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MtmInit.cpp

Abstract:

    Multicast Transport Manager initialization

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include "Mtm.h"
#include "Mtmp.h"

#include "mtminit.tmh"

VOID
MtmInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes Multicast Transport Manager library

Arguments:

    None.

Returned Value:

    None.

--*/
{
    //
    // Validate that the Multicast Transport Manager library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!MtmpIsInitialized());
    MtmpRegisterComponent();

    MtmpInitConfiguration();

    MtmpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mtm\lib\mtmdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MtmDebug.cpp

Abstract:

    Multicast Transport Manager debugging

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Mtm.h"
#include "Mtmp.h"

#include "mtmdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Multicast Transport Manager state
//
VOID MtmpAssertValid(VOID)
{
    //
    // MtmInitalize() has *not* been called. You should initialize the
    // Multicast Transport Manager library before using any of its funcionality.
    //
    ASSERT(MtmpIsInitialized());
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

VOID MtmpSetInitialized(VOID)
{
    LONG fAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Multicast Transport Manager library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fAlreadyInitialized);
}


BOOL MtmpIsInitialized(VOID)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
VOID MtmpRegisterComponent(VOID)
{
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mtm\lib\mtmconfig.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MtmConfig.cpp

Abstract:

    Multicast Transport Manager configuration.

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include <timetypes.h>
#include <Cm.h>
#include "Mtmp.h"

#include "mtmconfig.tmh"

static CTimeDuration s_remoteRetryTimeout;
static CTimeDuration s_remoteCleanupTimeout;


VOID
MtmpGetTransportTimes(
    CTimeDuration& RetryTimeout,
    CTimeDuration& CleanupTimeout
    )
{
    RetryTimeout = s_remoteRetryTimeout;
    CleanupTimeout = s_remoteCleanupTimeout;
}

    
static 
VOID
InitTransportTimeouts(
    VOID
    )
{
    CmQueryValue(
        RegEntry(NULL, L"MulticastConnectionRetryTimeout", 10 * 1000),  // 10 seconds 
        &s_remoteRetryTimeout
        );

    CmQueryValue(
        RegEntry(NULL, L"MulticastCleanupInterval", 5 * 60 * 1000),  // 5 minutes
        &s_remoteCleanupTimeout
        );
}


VOID MtmpInitConfiguration(VOID)
{
    InitTransportTimeouts();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mtm\lib\mtmp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    Mtmp.h

Abstract:

    Multicast Transport Manager private functions.

Author:

    Shai Kariv  (shaik)  27-Aug-00

--*/

#pragma once

#ifndef _MSMQ_Mtmp_H_
#define _MSMQ_Mtmp_H_

#include <mqsymbls.h>
#include <mqwin64a.h>
#include <qformat.h>


#ifdef _DEBUG

VOID MtmpAssertValid(VOID);
VOID MtmpSetInitialized(VOID);
BOOL MtmpIsInitialized(VOID);
VOID MtmpRegisterComponent(VOID);

#else // _DEBUG

#define MtmpAssertValid() ((VOID)0)
#define MtmpSetInitialized() ((VOID)0)
#define MtmpIsInitialized() TRUE
#define MtmpRegisterComponent() ((VOID)0)

#endif // _DEBUG

VOID 
MtmpInitConfiguration(
    VOID
    );

VOID 
MtmpGetTransportTimes(
    CTimeDuration& RetryTimeout,
    CTimeDuration& CleanupTimeout
    );

VOID 
MtmpRemoveTransport(
    MULTICAST_ID id
    );


class IMessagePool;
class ISessionPerfmon;

VOID
MtmpCreateNewTransport(
    IMessagePool * pMessageSource,
	ISessionPerfmon* pPerfmon,
    MULTICAST_ID id
    );

#endif // _MSMQ_Mtmp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mtm\test\mtmtest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MtmTest.cpp

Abstract:

    Multicast Transport manager library test

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent,

--*/

#include <libpch.h>
#include "Mtm.h"
#include "Cm.h"
#include "Mmt.h"
#include "msi.h"
#include "Mtmp.h"
#include "timetypes.h"

#include "MtmTest.tmh"

class CGroup : public IMessagePool
{
public:
    CGroup() :
        IMessagePool()
    {
        AddRef();
    }

    ~CGroup()
    {
    }
    

    VOID Requeue(CQmPacket* )
    {
        throw exception();
    }


    VOID EndProcessing(CQmPacket*, USHORT)
    {
        throw exception();
    }

    VOID LockMemoryAndDeleteStorage(CQmPacket* )
    {
        throw exception();
    }

    VOID GetFirstEntry(EXOVERLAPPED* , CACPacketPtrs& )
    {
        throw exception();
    }
    
    VOID CancelRequest(VOID)
    {
        throw exception();
    }
};


class CTestTransport : public CMulticastTransport
{
public:
    CTestTransport(
        MULTICAST_ID id
        ) :
        CMulticastTransport(id)
    {
    }

	virtual void Pause(void)
	{
		MtmTransportClosed(MulticastId());
	}
};


R<CMulticastTransport>
MmtCreateTransport(
    MULTICAST_ID id,
	IMessagePool *,
	ISessionPerfmon*, 
    const CTimeDuration&,
    const CTimeDuration&
    )
{
    return new CTestTransport(id);
}



static BOOL s_fCanCloseQueue = TRUE;

VOID CmQueryValue(const RegEntry&, CTimeDuration* pValue)
{
    *pValue = CTimeDuration(rand());
}


VOID MtmpInitConfiguration(VOID)
{
    NULL;
}


VOID 
MtmpGetTransportTimes(
    CTimeDuration& RetryTimeout,
    CTimeDuration& CleanupTimeout
    )
{
    RetryTimeout = CTimeDuration(rand());
    CleanupTimeout = CTimeDuration(rand());
}


const MULTICAST_ID xMulticastId[] = {
//
//  address, port
//    
    1000, 80,
    1010, 90,
    1020, 100,
    1020, 110,
    1010, 95,
    1000, 85
    };
            

VOID CheckError(bool f, DWORD line)
{
    if (f)
        return;

    TrERROR(NETWORKING, "Failed. Error in line %d", line);
    exit(1);
}


bool IsEqualMulticastId(MULTICAST_ID id1, MULTICAST_ID id2)
{
    return (id1.m_address == id2.m_address && id1.m_port == id2.m_port);
}


extern "C" int  __cdecl _tmain(int /*argc*/, LPCTSTR /*argv*/[])
/*++

Routine Description:

    Test Multicast Transport Manager library

Arguments:

    Parameters.

Returned Value:

    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	TrInitialize();

    MtmInitialize();

    //
    // Add transport to Mtm
    //
    MtmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xMulticastId[0]);

    //
    // Get first transport in TM. 
    //
    R<CMulticastTransport> tr = MtmFindFirst();
    CheckError((tr.get() != NULL), __LINE__);
    CheckError(IsEqualMulticastId(tr->MulticastId(), xMulticastId[0]), __LINE__);
                                               
    //
    // Get previous transport. Should failed since there is only one transport 
    //
    R<CMulticastTransport> tr2 = MtmFindPrev(*tr.get());
    CheckError((tr2.get() == NULL), __LINE__);

    //
    // remove the transport from Mtm map
    //
    MtmTransportClosed(tr->MulticastId());
    tr.free();

    //
    // Add new transport
    //
    MtmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xMulticastId[1]);

    //
    // Get pointer to the transport. So afterwards the test can ask the next and prev
    //
    tr = MtmFindFirst();
    CheckError((tr.get() != NULL), __LINE__);
    CheckError(IsEqualMulticastId(tr->MulticastId(), xMulticastId[1]), __LINE__);


    //
    // add new transports to Mtm map
    //
    MtmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xMulticastId[0]);
    MtmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xMulticastId[2]);

    //
    // Get previous transport
    //
    tr2 = MtmFindPrev(*tr.get());
    CheckError((tr2.get() != NULL), __LINE__);
    CheckError(IsEqualMulticastId(tr2->MulticastId(), xMulticastId[0]), __LINE__);
    tr2.free();


    //
    // remove the added transports
    //
    MtmTransportClosed(tr->MulticastId());

    R<CMulticastTransport> tr1 = MtmGetTransport(xMulticastId[2]);
    MtmTransportClosed(tr1->MulticastId());

    //
    // Find the previous transport of non-existing transport
    //
    tr2 = MtmFindPrev(*tr.get());
    CheckError((tr2.get() != NULL), __LINE__);
    CheckError(IsEqualMulticastId(tr2->MulticastId(), xMulticastId[0]), __LINE__);
    tr2.free();

    //
    // Find the next transport of non-existing transport
    // 
    tr2 = MtmFindNext(*tr.get());
    CheckError((tr2.get() == NULL), __LINE__);

    tr.free();


    //
    // Add new transports to Mtm 
    //
    MtmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xMulticastId[1]);
    MtmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xMulticastId[2]);
    MtmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xMulticastId[3]);

    //
    // Enumerate the transport in order
    //
    DWORD i = 0;
    for(tr = MtmFindFirst(); tr.get() != NULL; tr = MtmFindNext(*tr.get()), ++i)
    {
        CheckError(IsEqualMulticastId(tr->MulticastId(), xMulticastId[i]), __LINE__);
    }


    //
    // Close transports
    //
    R<CMulticastTransport> tr3 = MtmGetTransport(xMulticastId[3]);
    MtmTransportClosed(tr3->MulticastId());

    R<CMulticastTransport> tr4 = MtmGetTransport(xMulticastId[0]);
    MtmTransportClosed(tr4->MulticastId());

    R<CMulticastTransport> tr5 = MtmGetTransport(xMulticastId[2]);
    MtmTransportClosed(tr5->MulticastId());


    //
    // Find the first transport in Mtm map, that is the only one
    //
    tr = MtmFindFirst();
    CheckError((tr.get() != NULL), __LINE__);
    CheckError(IsEqualMulticastId(tr->MulticastId(), xMulticastId[1]), __LINE__);
    tr.free();

    //
    // Close the queue, but act like there is message in the queue
    //
    s_fCanCloseQueue = FALSE;
    R<CMulticastTransport> tr6 = MtmGetTransport(xMulticastId[1]);
    MtmTransportClosed(tr6->MulticastId());

    tr = MtmFindFirst();
    CheckError((tr.get() == NULL), __LINE__);

    MtmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xMulticastId[4]);
    MtmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xMulticastId[5]);

    tr = MtmGetTransport(xMulticastId[4]);
    CheckError((tr.get() != NULL), __LINE__);
    tr.free();

	//
	// Pause trnsport of exist address
	//
	MtmTransportPause(xMulticastId[4]);

	//
	// Pause transport of unexist address
	//
	MtmTransportPause(xMulticastId[3]);

	MtmDisconnect();

    TrTRACE(NETWORKING, "Test passed successfully...");
    
    WPP_CLEANUP();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\mtm\lib\mtmmap.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MtmMap.cpp

Abstract:

    Queue name to Transport mapping

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include <mqsymbls.h>
#include <mqwin64a.h>
#include <mqformat.h>
#include "Mtm.h"
#include "Mmt.h"
#include "rwlock.h"
#include "stlcmp.h"
#include "timetypes.h"
#include "Mtmp.h"

#include "mtmmap.tmh"

using namespace std;

//
// less function, using to compare MULTICAST_ID in STL data structure
//
struct CFunc_MulticastIdCompare : public std::binary_function<MULTICAST_ID, MULTICAST_ID, bool>
{
    bool operator() (MULTICAST_ID id1, MULTICAST_ID id2) const
    {
        if (id1.m_address != id2.m_address)
        {
            bool res = (id1.m_address < id2.m_address);
            return res;
        }

        return (id1.m_port < id2.m_port);
    }
};


typedef map<MULTICAST_ID, R<CMulticastTransport>, CFunc_MulticastIdCompare> TMAP;

static TMAP s_transports;
static CReadWriteLock s_rwlock;


inline
TMAP::iterator
MtmpFind(
    MULTICAST_ID id
    )
{
    return s_transports.find(id);
}


VOID
MtmpRemoveTransport(
    MULTICAST_ID id
    )
/*++

Routine Description:

    Remove a transport from the transport database

Arguments:

    id - The multicast address and port.

Returned Value:

    None.

--*/
{
    CSW writeLock(s_rwlock);

    TMAP::iterator it = MtmpFind(id);

    //
    // The transport can be removed with the same name more than once
    // see comment below at MtmpCreateNewTransport.
    //
    if(it == s_transports.end())
        return;

    TrTRACE(NETWORKING, "MtmpRemoveTransport. transport to : 0x%p", &it->second);

    s_transports.erase(it);
}


R<CMulticastTransport>
MtmGetTransport(
    MULTICAST_ID id
    )
/*++

Routine Description:

    Find a transport by a queue name in the database

Arguments:

    id - The multicast address and port.

Returned Value:

    None.

--*/
{
    MtmpAssertValid();
    
    CSR readLock(s_rwlock);

    WCHAR buffer[MAX_PATH];
    MQpMulticastIdToString(id, buffer, TABLE_SIZE(buffer));
    TrTRACE(NETWORKING, "MtmGetTransport. Multicast address: %ls", buffer);

    TMAP::iterator it = MtmpFind(id);

    if(it == s_transports.end())
        return NULL;

    return it->second;
}


VOID
MtmpCreateNewTransport(
    IMessagePool * pMessageSource,
	ISessionPerfmon* pPerfmon,
    MULTICAST_ID id
    )
{
    //
    // The state of the map isn't consistent until the function
    // is completed (add a null transport for place holder). Get the CS to 
    // insure that other process doesn't enumerate the data structure during this time
    //
    CSW writeLock(s_rwlock);

    WCHAR buffer[MAX_PATH];
    MQpMulticastIdToString(id, buffer, TABLE_SIZE(buffer));
    TrTRACE(NETWORKING, "MtmpCreateNewTransport. multicast address: %ls, message source: 0x%p", buffer, pMessageSource);

    //
    // Add the multicast address to the map. We do it before creating the transport to insure 
    // that after creation we always succeed to add the new transport to the data 
    // structure (place holder)
    //
    pair<TMAP::iterator, bool> pr = s_transports.insert(TMAP::value_type(id, NULL));

    TMAP::iterator it = pr.first;

    if (! pr.second)
    {
        //
        // BUGBUG: The queue can close while it has an active message transport. As
        //         a result the CQueueMgr moved the queue from the group and remove it. 
        //         Now the Mtm is asked to create Mmt for this queue but it already has one.  
        //         So the Mtm releases the previous transport before creating a new one.
        //         When we will have a Connection Cordinetor we need to handle it better
        //                          Uri Habusha, 16-May-2000
        //
        s_transports.erase(it);

        pr = s_transports.insert(TMAP::value_type(id, NULL));

        it = pr.first;
        ASSERT(pr.second);
    }

    try
    {
        //
        // Get transport timeouts
        //
        CTimeDuration retryTimeout;
        CTimeDuration cleanupTimeout;

        MtmpGetTransportTimes(retryTimeout, cleanupTimeout);

        //
        // Replace the NULL transport in place holder, with the created transport
        //
        it->second = MmtCreateTransport(
                                id,
                                pMessageSource,
								pPerfmon,
                                retryTimeout,
                                cleanupTimeout
                                );
    }
    catch(const exception&)
    {
        //
        // Remove the place holder from the map
        //
        ASSERT(it->second.get() == NULL);

        s_transports.erase(it);

        throw;
    }

    TrTRACE(
        NETWORKING, 
        "Succeeded to create multicast message transport (pmt = 0x%p) to %ls",
        (it->second).get(),
        buffer
        );
} // MtmpCreateNewTransport


R<CMulticastTransport>
MtmFindFirst(
    VOID
    )
/*++

Routine Description:

    Find first transport in s_transports. The function returns a pointer to the
    CMulticastTransport, from which the caller can get the transport state and name.
    
    The caller must release the transport reference count

Arguments:

    None.

Returned Value:

    Pointer to CMulticastTransport. NULL is returned If the map is empty.

--*/
{
    MtmpAssertValid();
        
    CSR readLock(s_rwlock);

    if(s_transports.empty())
        return NULL;

    return s_transports.begin()->second;
}


R<CMulticastTransport>
MtmFindLast(
    VOID
    )
/*++

Routine Description:

    Find last transport in s_transports. The function returns a pointer to the
    CMulticastTransport, from which the caller can get the transport state and name.
    
    The caller must release the transport reference count

Arguments:

    None.

Returned Value:

    Pointer to CMulticastTransport. NULL is returned If the map is empty.

--*/
{
    MtmpAssertValid();
        
    CSR readLock(s_rwlock);

    if(s_transports.empty())
        return NULL;

    return s_transports.rbegin()->second;
}


R<CMulticastTransport>
MtmFindNext(
    const CMulticastTransport& transport
    )
/*++

Routine Description:

    Find next transport in s_transport.

Arguments:

    transport - reference to transport.

Returned Value:

    The next CMulticastTransport in the database. NULL is returned if there is no more data

--*/
{
    MtmpAssertValid();

    
    CSR readLock(s_rwlock);

    TMAP::iterator it = s_transports.upper_bound(transport.MulticastId());

    //
    // No element found
    //
    if(it == s_transports.end())
        return NULL;

    return it->second;
}


R<CMulticastTransport>
MtmFindPrev(
    const CMulticastTransport& transport
    )
/*++

Routine Description:

    Find prev transport in s_transport.

Arguments:

    transport - reference to transport.

Returned Value:

    The prev CMulticastTransport in the database. NULL is returned if there is no more data

--*/
{
    MtmpAssertValid();

    
    CSR readLock(s_rwlock);

    TMAP::iterator it = s_transports.lower_bound(transport.MulticastId());

    //
    // No element found
    //
    if(it == s_transports.begin())
        return NULL;

    --it;

    return it->second;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\no\lib\nodebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    NoDebug.cpp

Abstract:
    Network Output debugging

Author:
    Uri Habusha (urih) 12-Aug-99

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Nop.h"

#include "nodebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Network Send state
//
void NopAssertValid(void)
{
    //
    // NoInitalize() has *not* been called. You should initialize the
    // Network Send library before using any of its funcionality.
    //
    ASSERT(NopIsInitialized());

    //
    // TODO:Add more Network Send validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void NopSetInitialized(void)
{
    LONG fNoAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Network Send library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fNoAlreadyInitialized);
}


BOOL NopIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
/*
const DebugEntry xDebugTable[] = {

    {
        "NoDumpState(queue path name)",
        "Dump Network Send State to debugger",
        DumpState
    ),

    //
    // TODO: Add Network Send debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void NopRegisterComponent(void)
{
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\no\lib\noaddr.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    noaddr.cpp

Abstract:
    Contains address resolution routine

Author:
    Uri Habusha (urih) 22-Aug-99

Enviroment:
    Platform-independent

--*/

#include "libpch.h"
#include <svcguid.h>
#include <Winsock2.h>
#include <No.h>
#include <buffer.h>
#include "Nop.h"

#include "noaddr.tmh"

using namespace std;

//
// Class that ends winsock look up in it's dtor
//
class CAutoEndWSALookupService
{
public:
	CAutoEndWSALookupService(
		HANDLE h = NULL
		):
		m_h(h)
		{
		}

	~CAutoEndWSALookupService()
	{
		if(m_h != NULL)
		{
			WSALookupServiceEnd(m_h);
		}
	}

	HANDLE& get()
	{
		return m_h;		
	}

private:
	HANDLE m_h;	
};


static
void
push_back_no_duplicates(
	vector<SOCKADDR_IN>* pAddr,
	const SOCKADDR_IN*  pAddress
	)
/*++

Routine Description:
    Push_back the new address if not already in the address vector

Parameters:
	pAddr - pointer to existing vector of addresses, the function will add the new address to this vector.
	pAddress - new address.
	
Returned Value:
	None	

--*/
{
	//
	// Check if this is a new address.
	// If the Address already exist don't put her in the return address vector.
	//

	DWORD cAddrs = numeric_cast<DWORD>(pAddr->size());
	ULONG IpAddress = pAddress->sin_addr.S_un.S_addr;
	for (DWORD i = 0; i < cAddrs; i++)
	{
		if(IpAddress == (*pAddr)[i].sin_addr.S_un.S_addr)
		{
			//
			// The new address already exist in the address vector
			//
			TrTRACE(NETWORKING, "Duplicate ip address, ip = %!ipaddr!", IpAddress);
			return;
		}
	}

	TrTRACE(NETWORKING, "Adding ip address to the vector list, ip = %!ipaddr!", IpAddress);
	pAddr->push_back(*pAddress);
}


bool
NoGetHostByName(
    LPCWSTR host,
	vector<SOCKADDR_IN>* pAddr,
	bool fUseCache
    )
/*++

Routine Description:
    Return list of addreses for given unicode machine name

Parameters:
    host - A pointer to the null-terminated name of the host to resolve. 
	pAddr - pointer to vector of addresses the function should fill.
	fUseCache - indicate if to use cache for machine name translation (default use cache).
 
Returned Value:
    true on Success false on failure. 

--*/

{
	ASSERT(pAddr != NULL);
	static const int xResultBuffersize =  sizeof(WSAQUERYSET) + 1024;
   	CStaticResizeBuffer<char, xResultBuffersize> ResultBuffer;


    //
    // create the query
    //
	GUID HostnameGuid = SVCID_INET_HOSTADDRBYNAME;
    AFPROTOCOLS afp[] = { {AF_INET, IPPROTO_UDP}, {AF_INET, IPPROTO_TCP } };

	PWSAQUERYSET pwsaq = (PWSAQUERYSET)ResultBuffer.begin();
    memset(pwsaq, 0, sizeof(*pwsaq));
    pwsaq->dwSize = sizeof(*pwsaq);
    pwsaq->lpszServiceInstanceName = const_cast<LPWSTR>(host);
    pwsaq->lpServiceClassId = &HostnameGuid;
    pwsaq->dwNameSpace = NS_ALL;
    pwsaq->dwNumberOfProtocols = TABLE_SIZE(afp);
    pwsaq->lpafpProtocols = &afp[0];
	ResultBuffer.resize(sizeof(WSAQUERYSET));


	//
	// get query handle
	//
	DWORD flags =  LUP_RETURN_ADDR;
	if(!fUseCache)
	{
		flags |= LUP_FLUSHCACHE;		
	}

	CAutoEndWSALookupService hLookup;
    int retcode = WSALookupServiceBegin(
								pwsaq,
                                flags,
                                &hLookup.get()
								);

  	

	if(retcode !=  0)
	{
		TrERROR(NETWORKING, "WSALookupServiceBegin got error %!winerr! , Flags %d, host:%ls ", WSAGetLastError(), flags, host);
		return false;
	}	


	//
	// Loop and get addresses for the given machine name
	//
 	for(;;)
	{
		DWORD dwLength = numeric_cast<DWORD>(ResultBuffer.capacity());
		retcode = WSALookupServiceNext(
								hLookup.get(),
								0,
								&dwLength,
								pwsaq
								);

		if(retcode != 0)
		{
			int ErrorCode = WSAGetLastError();
			if(ErrorCode == WSA_E_NO_MORE)
				break;

			//
			// Need more space
			//
			if(ErrorCode == WSAEFAULT)
			{
				ResultBuffer.reserve(dwLength + sizeof(WSAQUERYSET));
				pwsaq = (PWSAQUERYSET)ResultBuffer.begin();
				continue;
			}

			TrERROR(NETWORKING, "WSALookupServiceNext got error %!winerr! , Flags %d, host:%ls ", ErrorCode, flags, host);
			return false;
		}

		DWORD NumOfAddresses = pwsaq->dwNumberOfCsAddrs;
		ASSERT(NumOfAddresses != 0);
		const CSADDR_INFO*   pSAddrInfo =  (CSADDR_INFO *)pwsaq->lpcsaBuffer;
		const CSADDR_INFO*   pSAddrInfoEnd = pSAddrInfo + NumOfAddresses;

		while(pSAddrInfo != pSAddrInfoEnd)
		{
			const SOCKADDR_IN*  pAddress = (SOCKADDR_IN*)pSAddrInfo->RemoteAddr.lpSockaddr;
			ASSERT(pAddress != NULL);

			push_back_no_duplicates(pAddr, pAddress);
			++pSAddrInfo;
		}
 	}
	return true; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\no\lib\noinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    NoInit.cpp

Abstract:
    Network Output initialization

Author:
    Uri Habusha (urih) 12-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "No.h"
#include "Nop.h"

#include "noinit.tmh"

//
// version of Winsock we need
//
const WORD x_WinsockVersion = MAKEWORD(2, 0);

VOID
NoInitialize(
    VOID
    )
/*++

Routine Description:
    Initializes Network Send library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the Network Send library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!NopIsInitialized());

    NopRegisterComponent();

    //
    // Start WinSock 2.  If it fails, we don't need to call
    // WSACleanup().
    //
    WSADATA WSAData;
    if (WSAStartup(x_WinsockVersion, &WSAData))
    {
		TrERROR(NETWORKING, "Start winsock 2.0 Failed. Error %d", GetLastError());
        throw exception();
    }
	
	// 
	// Initialization done
	//
    NopSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\no\lib\noconnect.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    Noconnect.cpp

Abstract:
    This module contains the HTTP connection between 2 URT machines.

Author:
    Uri Habusha (urih), 4-Agu-99

Enviroment:
    Platform-indepdent

--*/

#include "libpch.h"
#include <WsRm.h>
#include "Ex.h"
#include "No.h"
#include "Nop.h"

#include <mswsock.h>

#include "mqexception.h"

#include "noconnect.tmh"


using namespace std;

const GUID xGuidConnectEx = WSAID_CONNECTEX;





VOID
NoCloseConnection(
    SOCKET Socket
    )
/*++

Routine Description:
    The function closes an existing connection

Arguments:
    Socket - a socket, identifying a connection to close

Return Value:
    None.

--*/
{
    NopAssertValid();

    TrTRACE(NETWORKING, "NoCloseConnection - Socket=0x%Ix", Socket);

    closesocket(Socket);
}


VOID
NoConnect(
    SOCKET Socket,
    const SOCKADDR_IN& Addr,
    EXOVERLAPPED* pov
    )
/*++

Routine Description:
    The routine asynchronously connects to the destination IP address using
    the given socket.
    The following steps are used
    1) Attach the socket handle to the completion port.
    2) Get the socket ConnectEx function address
    3) Bind the socket
    4) Use ConnectEx

Arguments:
    Socket - An unbinded stream socket
    Addr - The destination IP address
    pOveralpped - overlapped structure using latter to post the connection result.

Return Value:
    None.

--*/
{
    NopAssertValid();

    TrTRACE(NETWORKING, "Trying to connect to " LOG_INADDR_FMT ", pov=0x%p, Socket=0x%Ix", LOG_INADDR(Addr), pov, Socket);

    ASSERT(Addr.sin_family == AF_INET);
    
	//
    // Associate the  socket to I/O completion port. Ne infrastructure
    // use I/O completion port mechanism therfore all the socket must be associated 
    // with the I/O port.
    //
    ExAttachHandle(reinterpret_cast<HANDLE>(Socket));

	//
	// Get the ConnectEx function address
	//
	LPFN_CONNECTEX lpfConnectEx = NULL;
	int rc;
	DWORD dwReturnedSize;
	rc = WSAIoctl(
				Socket,
				SIO_GET_EXTENSION_FUNCTION_POINTER ,
				const_cast<GUID *> (&xGuidConnectEx), 
				sizeof xGuidConnectEx,
				&lpfConnectEx,
				sizeof lpfConnectEx,
				&dwReturnedSize,
				NULL,
				NULL
				  );
		
	if ((NULL == lpfConnectEx) || (0 != rc))
	{
		rc = WSAGetLastError();
		TrERROR(NETWORKING, "Failed to get ConnectEx function address Error=%!winerr!", rc);
    	throw bad_win32_error(rc);
	}


    //
    // Bind the socket since ConnectEx needs a bounded socket.
    // 
    SOCKADDR_IN address;
	address.sin_family = AF_INET;
   	address.sin_port = htons(0);    
	address.sin_addr.s_addr = AppGetBindInterfaceIp();
	if (bind(Socket, (const SOCKADDR*)&address, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
	{
		//
		// If the socket was already bound (WSAEINVAL returned), it is OK
		//
		rc = WSAGetLastError();
		if (WSAEINVAL != rc)
		{
			TrERROR(NETWORKING, "Failed to bind the socket Error=%!winerr!", rc);
    		throw bad_win32_error(rc);
		}
	}
    

    //
    // establishes a connection to another socket application.
    // 
    TrTRACE(NETWORKING, "Calling ConnectEx to make the connection ");
    BOOL fSuccess = lpfConnectEx(
                Socket,
                reinterpret_cast<const SOCKADDR*>(&Addr),
                sizeof(Addr),
                NULL,
                NULL,
                NULL,
                pov
                );

    if (fSuccess)
    	return;
    
	rc = WSAGetLastError();
	if (rc == ERROR_IO_PENDING)
		return;
	
	TrERROR(NETWORKING, "Failed to establish connection with " LOG_INADDR_FMT ". Error=%!winerr!", LOG_INADDR(Addr), rc);
	throw bad_win32_error(rc);
}


static
SOCKET
NopCreateConnection(
    int   Type,
    int   Protocol,
    DWORD Flags
    )
/*++

Routine Description:

    The routine creates an unbinded socket.

Arguments:

    Type     - Type specification of the new socket.

    Protocol - Protocl to be used with the socket.

    Flags    - Socket attributes flags.

Return Value:

    SOCKET.

--*/
{
    NopAssertValid();

    //
    // Create a socket for this connection.
    //
    SOCKET Socket = WSASocket(
                        AF_INET,
                        Type,
                        Protocol,
                        NULL,
                        NULL,
                        Flags
                        );

    if(Socket == INVALID_SOCKET) 
    {
        TrERROR(NETWORKING, "Failed to create a socket. type=%d, protocol=%d, flags=%d, Error=%d", Type, Protocol, Flags, WSAGetLastError());
        throw exception();
    } 

    TrTRACE(NETWORKING, "NopCreateConnection, Socket=0x%Ix, type=%d, protocol=%d, flags=%d", Socket, Type, Protocol, Flags);
    return Socket;
}


SOCKET
NoCreateStreamConnection(
    VOID
    )
{
    return NopCreateConnection(
               SOCK_STREAM,
               0,
               WSA_FLAG_OVERLAPPED
               );
} // NoCreateStreamConnection


SOCKET
NoCreatePgmConnection(
    VOID
    )
{
    return NopCreateConnection(
               SOCK_RDM, 
               IPPROTO_RM, 
               WSA_FLAG_OVERLAPPED | WSA_FLAG_MULTIPOINT_C_LEAF | WSA_FLAG_MULTIPOINT_D_LEAF
               );
} // NoCreatePgmConnection
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\no\test\connect.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    connect.cpp

Abstract:
    connect functions

Author:
    Uri Habusha (urih) 2-May-2000

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Ex.h"
#include "No.h"
#include "NoTest.h"

#include "connect.tmh"

using namespace std;

class ConnectOv : public EXOVERLAPPED
{
public:
    ConnectOv(
        LPWSTR hostName, 
        LPWSTR destHost,
        USHORT port,
        LPWSTR resource,
        HANDLE hEvent
        );

public:
    static void WINAPI ConnectSuccessed(EXOVERLAPPED* pov);
    static void WINAPI ConnectFailed(EXOVERLAPPED* pov);

private:
    void CreateSendRequest(void);

private:
    SOCKET m_socket;
    CTimeInstant m_time;

    AP<WCHAR> m_destHost;
    AP<WCHAR> m_host;
    AP<WCHAR> m_resource;
    USHORT m_port;

    HANDLE m_hEvent;
};


ConnectOv::ConnectOv(
    LPWSTR hostName,
    LPWSTR destHost,
    USHORT port,
    LPWSTR resource,
    HANDLE hEvent
    ) :
    EXOVERLAPPED(ConnectSuccessed, ConnectFailed),
    m_host(hostName),
    m_destHost(destHost), 
    m_resource(resource),
    m_port(port),
    m_hEvent(hEvent),
    m_socket(INVALID_SOCKET),
    m_time(ExGetCurrentTime())
{
	vector<SOCKADDR_IN> sockAddress;
    bool fSucc = NoGetHostByName(m_host, &sockAddress);
    if (!fSucc)
    {
        TrERROR(NETWORKING, "Failed to resolve Address of %ls Machine", m_host);
        throw exception();
    }

    SOCKADDR_IN Addr = sockAddress[0];
    TrTRACE(NETWORKING, "Resolved address for '%ls'. Address=" LOG_INADDR_FMT, m_host, LOG_INADDR(Addr));

    Addr.sin_port = htons(m_port);


    m_socket = NoCreateStreamConnection();
    if (m_socket == INVALID_SOCKET)
    {
        TrERROR(NETWORKING, "Failed to create socket. Error %d", GetLastError());
        throw exception();
    }

    NoConnect(m_socket, Addr, this);

}


void
WINAPI
ConnectOv::ConnectSuccessed(
    EXOVERLAPPED* pov
    )
{
    
    ASSERT(SUCCEEDED(pov->GetStatus()));

    P<ConnectOv> pcov = static_cast<ConnectOv*>(pov);

    ULONGLONG connectTime = (ExGetCurrentTime() - pcov->m_time).Ticks() / CTimeDuration::OneMilliSecond().Ticks();
    TrTRACE(NETWORKING, "Create connection with %ls complete successfully. Notified after %I64d ms ", pcov->m_host, connectTime);
 
    WaitForResponse(pcov->m_socket, pcov->m_hEvent);
    SendRequest(pcov->m_socket, pcov->m_destHost.detach(), pcov->m_resource.detach());
}


void
WINAPI
ConnectOv::ConnectFailed(
    EXOVERLAPPED* pov
    )
{
    ASSERT(FAILED(pov->GetStatus()));

    P<ConnectOv> pcov = static_cast<ConnectOv*>(pov);

    ULONGLONG connectTime = (ExGetCurrentTime() - pcov->m_time).Ticks() / CTimeDuration::OneMilliSecond().Ticks();
    TrERROR(NETWORKING, "Failed to create connection with %ls. Notified after %I64d ms", pcov->m_host, connectTime);

    if (SetEvent(pcov->m_hEvent) == 0)
    {
        TrERROR(NETWORKING, "Faield to set event. Error %d", GetLastError());
    }
}


void 
TestConnect(
    LPCWSTR hostname,
    LPCWSTR destHost,
    USHORT port,
    LPCWSTR resource,
    HANDLE hEvent
    )
{
    new ConnectOv(newwcs(hostname), newwcs(destHost), port, newwcs(resource), hEvent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\no\lib\nosend.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    Noio.cpp

Abstract:
    This module contains the general routine for sending/receiving .

Author:
    Uri Habusha (urih)  18-Jan-98

Enviroment:
    Platform-independent

--*/

#include "libpch.h"
#include "Ex.h"
#include "No.h"
#include "Nop.h"
#include "mqexception.h"

#include "nosend.tmh"

//
// Send Operation overlapped structure
//
class CSendOv : public EXOVERLAPPED
{
public:
    CSendOv(
        EXOVERLAPPED* pContext,
        SOCKET Socket
        ) :
		EXOVERLAPPED(SendSucceeded, SendFailed), 
		m_pContext(pContext),
		m_Socket(Socket)
	{
	}
    
    void SendLength(DWORD length)
    {
        m_SendLength = length;
    }

    DWORD SendLength(void)
    {
        return m_SendLength;
    }

    DWORD BytesSent(void)
    {
        //
        // In win64, InternalHigh is 64 bits. Since the max chunk of data
        // we read in one operation is always less than MAX_UNIT we can cast
        // it to DWORD safetly
        //
        ASSERT(0xFFFFFFFF >= InternalHigh);

		return static_cast<DWORD>(InternalHigh);
    }

    
private:
	static void	WINAPI SendSucceeded(EXOVERLAPPED* pov);
	static void	WINAPI SendFailed(EXOVERLAPPED* pov);

private:
    SOCKET m_Socket;
    EXOVERLAPPED* m_pContext;
  
    
        DWORD m_SendLength;
    

};



void
WINAPI
CSendOv::SendFailed(
    EXOVERLAPPED* pov
    )
/*++

Routine Description:
    The routine calls when send operation failes.

    the routine retrieve the caller overlapped, close the socket,set the operation 
    result to failure error code and call to execute the completion routine
    
Arguments:
    pointer to the calling overlapped structure
     
Returned Value:
    None.
    
--*/
{
    P<CSendOv> pSendOv = static_cast<CSendOv*>(pov);

    ASSERT(pov->GetStatus() != STATUS_SUCCESS);

    TrERROR(NETWORKING, "Send on socket 0x%Ix Failed. Error %d", pSendOv->m_Socket, pov->GetStatus());

    EXOVERLAPPED* pContext = pSendOv->m_pContext;
    pContext->CompleteRequest(pov->GetStatus());
}


void
WINAPI
CSendOv::SendSucceeded(
    EXOVERLAPPED* pov
    )
/*++

Routine Description:
    The routine calls when send operation completes successfully.

    the routine retrieve the caller overlapped, set the operation 
    result to STATUS_SUCCESS and call to execute the completion routine
    
Arguments:
    pointer to the calling overlapped structure
     
Returned Value:
    None.
    
--*/
{
    P<CSendOv> pSendOv = static_cast<CSendOv*>(pov);

    ASSERT(pov->GetStatus() == STATUS_SUCCESS);
	EXOVERLAPPED* pContext = pSendOv->m_pContext;

	//
	// gilsh - fix for bug 5583 - in rare cases (winsock bug) - The operation completed 
	// successfully but the number of sending bytes 
	// wasnt equivalent to the number of bytes that were requested to be sent. 
	// In that rare case we consider it as faliure. 
	//
	if( pSendOv->SendLength() != pSendOv->BytesSent() )
	{
		TrERROR( 
			NETWORKING,
			"Unexpected winsock behavior, SendLength=%d BytesSent=%d",
			pSendOv->SendLength(),
			pSendOv->BytesSent()
			);
 
		pContext->CompleteRequest(STATUS_UNSUCCESSFUL);
		return;
	}

	TrTRACE(NETWORKING, "Send operation on socket 0x%Ix completed Successfully", pSendOv->m_Socket);
	pContext->CompleteRequest(STATUS_SUCCESS);
}


VOID
NoSend(
    SOCKET Socket,                                              
    const WSABUF* sendBuf,                                     
    DWORD nBuffers, 
    EXOVERLAPPED* pov
    )
/*++

Routine Description:
    The routine sends data to connected socket. The routine uses WriteFile
    to Asynchronous send. When the send of the Data completed the program gets
    notification using the completion port mechanism.

Arguments:
    Socket - handle to connected socket.
    sendBuf - a buffer containing the data to be transfered
    nBuffers - The length of data should be transfered
    pov - pointer to ovelapped structure pass to WriteFile

Return Value:
    None.

--*/
{
    NopAssertValid();

    ASSERT(nBuffers != 0);

    P<CSendOv> pSendOv = new CSendOv(pov, Socket);
   

	//
	// We compute the send length to verify that when send return succsefully -
	// all byte were actually sent. Because of winsock bug - in rare cases it not always
	// true
	//
    DWORD length = 0;
    for (DWORD i = 0; i < nBuffers; ++i)
    {
        length += sendBuf[i].len;
    }
    pSendOv->SendLength(length);

   

    int rc;
    DWORD NumberOfBytesSent;
    rc = WSASend(
            Socket,
            const_cast<WSABUF*>(sendBuf),
            nBuffers,
            &NumberOfBytesSent,
            0,
            pSendOv,
            NULL
            );

    if (rc == SOCKET_ERROR)
	{
		DWORD gle = WSAGetLastError();
		if (gle != ERROR_IO_PENDING)
		{
			TrERROR(NETWORKING, "Send Operation Failed. Error %!winerr!", gle);
			throw bad_win32_error(gle);
		}
	}

    pSendOv.detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\no\lib\nop.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Nop.h

Abstract:
    Network Output private functions.

Author:
    Uri Habusha (urih) 12-Aug-99

--*/

#pragma once

#ifdef _DEBUG

void NopAssertValid(void);
void NopSetInitialized(void);
BOOL NopIsInitialized(void);
void NopRegisterComponent(void);

#else // _DEBUG

#define NopAssertValid() ((void)0)
#define NopSetInitialized() ((void)0)
#define NopIsInitialized() TRUE
#define NopRegisterComponent() ((void)0)

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\no\lib\norecv.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    Noio.cpp

Abstract:
    This module contains the general routine for sending/receiving .

Author:
    Uri Habusha (urih)  18-Jan-98

Enviroment:
    Platform-independent

--*/

#include "libpch.h"
#include "Ex.h"
#include "No.h"
#include "Nop.h"
#include "mqexception.h"

#include "norecv.tmh"

//-------------------------------------------------------------------
//
// class CReceiveOv
//
//-------------------------------------------------------------------
class CReceiveOv : public EXOVERLAPPED {
public:
    CReceiveOv(
        EXOVERLAPPED* pContext,
        SOCKET Socket,
        char* Buffer,
        DWORD Size
		) : 
		EXOVERLAPPED(ReceiveSucceeded, ReceiveFailed), 
		m_pContext(pContext),
		m_Socket(Socket),
		m_Buffer(Buffer),
		m_Size(Size)
	{
	}

private:
	void ReceiveSucceeded();


	DWORD BytesReceived() const
	{
        //
        // In win64, InternalHigh is 64 bits. Since the max chunk of data
        // we read in one operation is always less than MAX_UNIT we can cast
        // it to DWORD safetly
        //
        ASSERT(0xFFFFFFFF >= InternalHigh);

		return static_cast<DWORD>(InternalHigh);
	}


private:
	static void	WINAPI ReceiveSucceeded(EXOVERLAPPED* pov);
	static void	WINAPI ReceiveFailed(EXOVERLAPPED* pov);

private:

    SOCKET m_Socket;
    char* m_Buffer;
	DWORD m_Size;
    EXOVERLAPPED* m_pContext;

};


void CReceiveOv::ReceiveSucceeded()
/*++

Routine Description:
    The routine calls when receive operation completes successfully.
	It continues to receive thill the entier caller buffer is satisfied.
	When the entire buffer is receive the caller gets notified.

Arguments:
    None.
     
Returned Value:
    None.
    
--*/
{
	P<CReceiveOv> ar(this);

    //
    // For byte streams, zero bytes having been read indicates graceful closure
    // and that no more bytes will ever be read. 
    //
    if(BytesReceived() == 0)
    {
		TrERROR(NETWORKING, "Receive from socket 0x%Ix failed. Bytes receive=0", m_Socket);
		m_pContext->CompleteRequest(STATUS_UNSUCCESSFUL);
        return;
    }

    if(BytesReceived() == m_Size)
    {

		TrTRACE(NETWORKING, "Receive from socket 0x%Ix completed successfully", m_Socket);
		m_pContext->CompleteRequest(STATUS_SUCCESS);
		return;
	}

    //
    // Partial read. continue ...
    //
    m_Buffer += BytesReceived();
    m_Size -= BytesReceived();

	try
	{
		NoReceivePartialBuffer(m_Socket, m_Buffer, m_Size, this);
		ar.detach();
	}
	catch(const exception&)
	{
		TrERROR(NETWORKING, "Failed to continue and receive eniter buffer. context=0x%p", m_pContext);
		m_pContext->CompleteRequest(STATUS_UNSUCCESSFUL);
	}

}


void WINAPI CReceiveOv::ReceiveSucceeded(EXOVERLAPPED* pov)
{
    ASSERT(pov->GetStatus() == STATUS_SUCCESS);

    CReceiveOv* pReceiveOv = static_cast<CReceiveOv*>(pov);
	pReceiveOv->ReceiveSucceeded();
}


void WINAPI CReceiveOv::ReceiveFailed(EXOVERLAPPED* pov)
/*++

Routine Description:
    The routine is called when receive operation failes. It notifiy the
	original caller about the receive outcome.
    
Arguments:
    pointer to the calling overlapped structure
     
Returned Value:
    None.
    
--*/
{
    P<CReceiveOv> pReceiveOv = static_cast<CReceiveOv*>(pov);

    ASSERT(FAILED(pov->GetStatus()));

    TrERROR(NETWORKING, "Receive from socket 0x%Ix failed. Status=%d", pReceiveOv->m_Socket, pov->GetStatus());

    //
    // retrieve information from receive OVERLAPPED
    //
    EXOVERLAPPED* pContext = pReceiveOv->m_pContext;
    pContext->CompleteRequest(pov->GetStatus());
}


VOID
NoReceiveCompleteBuffer(
    SOCKET Socket,                                              
    VOID* pBuffer,                                     
    DWORD Size, 
    EXOVERLAPPED* pov
    )
/*++

Routine Description:

    The routine receive data on connected socket. The routine uses ReadFile
    for Asynchronous receive. When receive of the Data completed the program gets
    notification using the completion port mechanism.

Arguments:
    Socket - handle to connected socket.
    pBuffer - a buffer to store the data transfered
    Size - Buffer Size and no. of bytes to read
    pov - pointer to ovelapped structure pass to ReadFile

Return Value:
	None.

--*/
{
    NopAssertValid();

    P<CReceiveOv> pReceiveOv = new CReceiveOv(
										pov,
										Socket,
										static_cast<char*>(pBuffer),
										Size
										);

    NoReceivePartialBuffer(Socket, pBuffer, Size, pReceiveOv);
	pReceiveOv.detach();
}


VOID
NoReceivePartialBuffer(
    SOCKET Socket,                                              
    VOID* pBuffer,                                     
    DWORD Size, 
    EXOVERLAPPED* pov
    )
/*++

Routine Description:

    The routine receive data on connected socket. The routine uses ReadFile
    for Asynchronous receive. When partial receive completes the caller gets
    notification using the completion port mechanism.

Arguments:
    Socket - The connection socket handle
    pBuffer - a buffer to store the data transfered
    Size - Buffer Size
    pov - pointer to ovelapped structure pass to ReadFile

Return Value:
	None.

--*/
{
    NopAssertValid();

    DWORD Flags = 0;
    DWORD nBytesReceived;
    WSABUF Chunk = { Size, static_cast<char*>(pBuffer) };

    int rc = WSARecv(
				Socket,
				&Chunk,
				1,
				&nBytesReceived,
				&Flags,
				pov,
				NULL
				);

    if (rc == SOCKET_ERROR)
	{
		DWORD gle = WSAGetLastError();
		if (gle != ERROR_IO_PENDING)
		{
			TrERROR(NETWORKING, "Receive Operation Failed. Error %!winerr!", gle);
			throw bad_win32_error(gle);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\no\test\notest.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    NoTest.cpp

Abstract:
    Network Output library test

Author:
    Uri Habusha (urih) 12-Aug-99

Environment:
    Platform-independent,

--*/

#pragma once

#ifndef __NOTEST_H__
#define __NOTEST_H__

extern DWORD g_nMessages;
extern DWORD g_messageSize;

void 
TestConnect(
    LPCWSTR hostname,
    LPCWSTR dsetHost,
    USHORT port,
    LPCWSTR resource,
    HANDLE hEvent
    );

void
WaitForResponse(
    SOCKET s,
    HANDLE hEvent
    );

void
SendRequest(
    SOCKET s,
    LPWSTR host,
    LPWSTR resource
    );


#endif // __NOTEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\qal\lib\qalglob.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Qalglob.cpp

Abstract:
    Holds some global function and data for qal.lib


Author:
    Gil Shafriri (gilsh) 22-Nov-00

Environment:
    Platform-independent.
--*/
#include <libpch.h>
#include <qal.h>
#include <mqexception.h>
#include "qalp.h"
#include "qalglob.tmh"

static P<CQueueAlias> s_pQueueAlias;

void   QalInitialize(LPCWSTR pDir)
/*++

Routine Description:
	Initialize the qal library - must be called  first
	befor any other function. The function creates one instance of	CQueueAlias
	object used by MSMQ.

Arguments:
	pDir - the mapping directory where xml mapping files located.


Returned value:
	None
--*/
{
	ASSERT(!QalpIsInitialized());
	QalpRegisterComponent();
	s_pQueueAlias	 = new 	CQueueAlias(pDir);
}


CQueueAlias& QalGetMapping(void)
/*++

Routine Description:
	return the queue mapping object


Returned value:
	Reference to  CQueueAlias object.

Note :
This function is used instead of the consructor of CQueueAlias (which is private)
to ensure that only one instance of this class will ever created.
--*/
{
	ASSERT(s_pQueueAlias.get() != NULL);
	return *(s_pQueueAlias.get());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\qal\lib\qaldebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stDebug.cpp

Abstract:
    Queue Alias debugging

Author:
    Gil Shafriri (gilsh) 05-Jun-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "qalp.h"

#include "qaldebug.tmh"

#ifdef _DEBUG

//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;


BOOL QalpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Validate Queue Alias state
//
void QalpAssertValid(void)
{
    ASSERT(QalpIsInitialized());
}



void QalpSetInitialized(void)
{
    LONG fstAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Socket Transport library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fstAlreadyInitialized);
}



//---------------------------------------------------------
//
// Tracing and Debug registration
//
void QalpRegisterComponent(void)
{
}




#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\no\test\response.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    response.cpp

Abstract:
    response functions

Author:
    Uri Habusha (urih) 2-May-2000

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Ex.h"
#include "No.h"
#include "NoTest.h"

#include "response.tmh"

static bool FindEndOfResponse(LPCSTR buf, DWORD length, DWORD& headerSize)
{
    headerSize = 0;

    if (4 > length)
        return false;

    for(DWORD i = 0; i < length - 3; ++i)
    {
        if (buf[i] != '\r')
            continue;

        if ((buf[i+1] == '\n') && (buf[i+2] == '\r') && (buf[i+3] == '\n'))
        {
            headerSize = i + 4;
            return true;
        }
    }

    return false;
}


class ResponseOv: public EXOVERLAPPED
{
public:
    ResponseOv(SOCKET s, HANDLE h, DWORD nMessages);

public:
    static void WINAPI ResponseSuccess(EXOVERLAPPED* pov);
    static void WINAPI ResponseFailed(EXOVERLAPPED* pov);

private:
    SOCKET m_socket;
    char m_buff[4096];

    DWORD m_bytesRead;
    DWORD m_nMessages;
    HANDLE m_hEvent;
};


ResponseOv::ResponseOv(
    SOCKET s, 
    HANDLE h, 
    DWORD nMessages
    ) :
    EXOVERLAPPED(ResponseSuccess, ResponseFailed),
    m_socket(s),
    m_bytesRead(0),
    m_nMessages(nMessages),
    m_hEvent(h)
{
    NoReceivePartialBuffer(m_socket, m_buff, TABLE_SIZE(m_buff), this);
};


void
WINAPI
ResponseOv::ResponseFailed(
    EXOVERLAPPED* pov
    )
{
    ASSERT(FAILED(pov->GetStatus()));

    P<ResponseOv> prov = static_cast<ResponseOv*>(pov);

    TrERROR(NETWORKING, "Failed to receive response on socket %Ix", prov->m_socket);

    if (SetEvent(prov->m_hEvent) == 0)
    {
        TrERROR(NETWORKING, "Faield to set event. Error %d", GetLastError());
    }
}


void
WINAPI
ResponseOv::ResponseSuccess(
    EXOVERLAPPED* pov
    )
{
    ResponseOv* prov = static_cast<ResponseOv*>(pov);

    TrTRACE(NETWORKING, "Response received %Id bytes", pov->InternalHigh);

    ASSERT(0xFFFFFFFF >= pov->InternalHigh);
    prov->m_bytesRead += static_cast<DWORD>(pov->InternalHigh);

    DWORD headerSize;
    if(!FindEndOfResponse(prov->m_buff, prov->m_bytesRead, headerSize))
    {
        //
        // Receive the next response chunk
        //
        NoReceivePartialBuffer(
            prov->m_socket,
            prov->m_buff + prov->m_bytesRead,
            TABLE_SIZE(prov->m_buff) - prov->m_bytesRead,
            pov
            );

        return;
    }

    prov->m_buff[prov->m_bytesRead] = '\0';
    TrTRACE(NETWORKING, "Response: %s", prov->m_buff);

    if (--prov->m_nMessages == 0)
    {
        if (SetEvent(prov->m_hEvent) == 0)
        {
            TrERROR(NETWORKING, "Faield to set event. Error %d", GetLastError());
        }
        
        delete prov;

        return;
    }

    //
    // Handle extra data that was read
    //
    if (prov->m_bytesRead > headerSize)
    {
        memcpy(prov->m_buff, (prov->m_buff + headerSize), (prov->m_bytesRead - headerSize));
        prov->m_bytesRead = prov->m_bytesRead - headerSize;
        prov->m_bytesRead = 0;

        ResponseSuccess(prov);
        return;
    }

    //
    // Receive HTTP response
    //
    NoReceivePartialBuffer(
        prov->m_socket,
        prov->m_buff,
        TABLE_SIZE(prov->m_buff),
        prov
        );

}



void
WaitForResponse(
    SOCKET s,
    HANDLE hEvent
    )
{
    new ResponseOv(s, hEvent, g_nMessages);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\no\test\send.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    send.cpp

Abstract:
    send functions

Author:
    Uri Habusha (urih) 2-May-2000

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Ex.h"
#include "No.h"
#include "NoTest.h"

#include "send.tmh"

const LPCSTR xMessages[] = {
/*0*/
       "<HEADERS>\n"
            "<MSM>\n"
                "<TO>%ls/%ls</TO>\n"
                "<FROM>http://www.home.com</FROM>\n"
                "<MSG>"
                    "<ID>%I64d</ID>"
                    "<CHN>%d</CHN>"
                "</MSG>"
            "</MSM>\n"
        "</HEADERS>\n"
        "<MyPayload>\n"
            "<MyType>XML</MyType>\n"
            "<MyName>Ticker</MyName>\n"
            "<quote name=\"MSFT\" time=\"12:53\" value=\"203.57\" splits=\"98\"/>\n"
        "</MyPayload>\n",
};


const char xFillBuffer[] = "abcdefghijklmnopqrstuvwxyz1234567890";


class SendOv : public EXOVERLAPPED
{
public:
    SendOv(
        SOCKET s, 
        LPWSTR host, 
        LPWSTR resource, 
        DWORD n
        );

public:
    static void WINAPI SendSuccessed(EXOVERLAPPED* pov);
    static void WINAPI SendFailed(EXOVERLAPPED* pov);

private:
    void SendHttpRequest(void);
    char* CreateMessage(void);

private:
    SOCKET m_socket;
    char m_request[256];
    char* m_pMsg;

    AP<WCHAR> m_host;
    AP<WCHAR> m_resource;

    DWORD m_nMessages;
    LARGE_INTEGER m_msgId;
};


SendOv::SendOv(
    SOCKET s, 
    LPWSTR host, 
    LPWSTR resource, 
    DWORD n
    ) :
    EXOVERLAPPED(SendSuccessed, SendFailed),
    m_socket(s),
    m_nMessages(n),
    m_host(host),
    m_resource(resource),
    m_pMsg(NULL)
{
    m_msgId.HighPart = static_cast<DWORD>(time(NULL));

    SendHttpRequest();
};



void
WINAPI
SendOv::SendFailed(
    EXOVERLAPPED* pov
    )
{
    ASSERT(FAILED(pov->GetStatus()));

    P<SendOv> psov = static_cast<SendOv*>(pov);

    TrERROR(NETWORKING, "failed to send HTTP request on socket = %Ix", psov->m_socket);
}


void
WINAPI
SendOv::SendSuccessed(
    EXOVERLAPPED* pov
    )
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

    SendOv* psov = static_cast<SendOv*>(pov);

    //
    // Send next message
    //
    if (--psov->m_nMessages > 0)
    {
        psov->SendHttpRequest();
        return;
    }

    delete [] psov->m_pMsg;
    delete psov;
}


void SendOv::SendHttpRequest(void)
{
    delete [] m_pMsg;
    m_pMsg = CreateMessage();

    DWORD MessageLength = strlen(m_pMsg);

    sprintf(
        m_request, 
        "POST %ls HTTP/1.1\r\n"
        "Content-Length: %d\r\n"
        "Host: %ls\r\n"
        "Connection: keep-Alive\r\n"
        "\r\n",
        m_resource,
        MessageLength,
        m_host
        );

    WSABUF HttpRequestBuf[] = {
        {strlen(m_request), m_request},
        {MessageLength, m_pMsg},
    };

    NoSend(m_socket, HttpRequestBuf, TABLE_SIZE(HttpRequestBuf), this);
}


char* SendOv::CreateMessage(void)
{
    DWORD size;
    if (g_messageSize != INFINITE)
    {
        size = g_messageSize;
    }
    else
    {
        size = (rand() % (1024)) + 256;
    }

    char* Message = new char[size];

    int n = _snprintf(
                Message,
                size,
                xMessages[rand() % TABLE_SIZE(xMessages)],
                m_host,
                m_resource,
                ++m_msgId.QuadPart,
                (rand() % 3) + 1
                );

    if (0 > n)
    {
        ASSERT(g_messageSize != INFINITE);

        printf("The specified message size, is too small. Can't specified the UMP header\n");
        exit(-1);
    }

    Message[size-1] = '\0';
    --size;

    for (char* p = (Message + n); n > 0; p += n)
    {      
        size -= n;
        n = _snprintf(p, size, xFillBuffer);
    }

    return Message;
}




void
SendRequest(
    SOCKET s,
    LPWSTR host,
    LPWSTR resource
    )
{
    new SendOv(s, host, resource, g_nMessages);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\no\test\notest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    NoTest.cpp

Abstract:
    Network Output library test

Author:
    Uri Habusha (urih) 12-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Ex.h"
#include "No.h"
#include "NoTest.h"

#include "NoTest.tmh"

const USHORT HTTP_DEFAULT_PORT = 80;


static LPCWSTR* s_pQueueList = NULL;
static DWORD s_noOfQueues = 0;

static WCHAR s_proxyName[256];
static USHORT s_proxyPort;
static bool s_fUseProxy = false;

DWORD g_nMessages = INFINITE;
DWORD g_messageSize = 100;

static USHORT s_port = HTTP_DEFAULT_PORT;


DWORD
AppGetBindInterfaceIp(
	void
	)
{
	return INADDR_ANY;
}


static 
bool 
CrackUrl(
    LPCWSTR url,
    LPWSTR hostName,
    USHORT& port,
    LPWSTR resourceName
    )
/*++

Routine Description:

    Cracks an URL into its constituent parts. 

Arguments:

    url      - pointer to URL to crack. The url is null terminated string

    hostName - Address of a string value that contains the host name. The 
               routine assume that the buffer is big enough to hold the host name
               part of the URL.

    port - HTTP port number. If it doesn't specified in URL the default HTTP port
            is returned

Return Value:

    bool
        Success - true

        Failure - false. 

--*/
{
    ASSERT(url != NULL);

    const WCHAR httpScheme[] = L"http://";
    const DWORD httpSchemeLength = wcslen(httpScheme);
    const WCHAR HostNameBreakChars[] = L";:@?/";

    if (_wcsnicmp(url, httpScheme, httpSchemeLength) != 0)
        return false;

    //
    // Advance the URL to point on the host name
    //
    LPCWSTR HostNameBegin = url + httpSchemeLength;

    //
    // find the end of host name in url. it is terminated by "/", "?", ";",
    // ":" or by the end of URL
    //
    LPCWSTR HostNameEnd = wcspbrk(HostNameBegin, HostNameBreakChars);

    //
    // calculate the host name length
    //
    DWORD HostNameLength;
    if (HostNameEnd == NULL)
    {
        HostNameLength = wcslen(HostNameBegin);
    }
    else
    {
        DWORD_PTR temp = HostNameEnd - HostNameBegin;
        ASSERT(0xFFFFFFFF >= temp);

        HostNameLength = static_cast<DWORD>(temp);
    }

    //
    // copy the host name from URL to user buffer and add terminted
    // string in the end
    //
    wcsncpy(hostName, HostNameBegin, HostNameLength);
    hostName[HostNameLength] = L'\0';

    //
    // get the port number
    //
    port = HTTP_DEFAULT_PORT;
    resourceName[0] = L'\0';
    if(HostNameEnd == NULL)
        return true;

    if(*HostNameEnd == L':')
    {
        port = static_cast<USHORT>(_wtoi(HostNameEnd + 1));
        HostNameEnd = wcspbrk(HostNameEnd + 1, HostNameBreakChars);
    }

    if(HostNameEnd == NULL)
        return true;

    if(*HostNameEnd == L'/')
    {
        wcscpy(resourceName, HostNameEnd + 1);
    }

    return true;
}


bool
ParseCommand(
    int argc, 
    LPCTSTR argv[]
    )
{

    s_pQueueList = NULL;
    s_noOfQueues = 0;
    s_fUseProxy = false;
    //
    // Parse command line
    //
    --argc;
    ++argv;
    while (argc != 0)
    {
        if (argv[0][0] != L'-')
        {
            goto usage;
        }

        switch(argv[0][1])
        {
        case L'n':
        case L'N':
            g_nMessages = _wtoi(argv[1]);
            argc -= 2;
            argv += 2;
            break;

        case L's':
        case L'S':
            g_messageSize = _wtoi(argv[1]);
            argc -= 2;
            argv += 2;
            break;

        case L'c':
        case L'C':
            {
                ++argv;
                --argc;  
                s_pQueueList = argv;
                s_noOfQueues = 0;

                WCHAR hostName[256];
                WCHAR resourceName[256];
                USHORT port;

                while ((argc != 0) && CrackUrl(argv[0], hostName, port, resourceName))
                {
                    ++s_noOfQueues;
                    ++argv;
                    --argc;  
                } 
                break;
            }

        case L'p':
        case L'P':
            {
                WCHAR resourceName[256];
                
                if ((argc == 0) || 
                    (! CrackUrl(argv[1], s_proxyName, s_proxyPort, resourceName)) ||
                    resourceName[0] != L'\0'
                    )
                {
                    printf("Failed to parse test parameters. Illegal proxy name\n");
                    goto usage;
                }
                s_fUseProxy = true;

                argc -= 2;
                argv += 2;
                break;
            }

        default:
            goto usage;
        }
    }

    if (s_noOfQueues != 0)
    {
        return true;
    }

usage:
    printf("Usage:\n"
           "\tNoTest -c <list of queues url> -n <number of messages> -s <message size> -p <proxy url>[-? | -h]\n");
    printf("\tc - List of destination queues url\n");
    printf("\tn - Number of messages to send\n");
    printf("\ts - Message Size\n");
    printf("\tp - Proxy url\n");
    printf("\t?/h - Help message\n");
    printf("Example:\n");
    printf("\tNoTest -c http://urih0/queue1  http://urih5/queue2 -n 10 -s 1000 -p http://proxy:8080\n");
    
    return false;
}

static void TestNameResolution()
{
	//
	// Get unicode machine name
	//
	WCHAR wcname[MAX_COMPUTERNAME_LENGTH + 1];
	DWORD len = TABLE_SIZE(wcname);
	BOOL fRet = GetComputerName(wcname, &len);
	if(!fRet)
	{
		TrERROR(NETWORKING, "could not  get computer name");
		throw exception();
	}

	//
	// Unicode name resolution
	//
  	std::vector<SOCKADDR_IN> wAddr;
	if(!NoGetHostByName(wcname, &wAddr))
	{
		TrERROR(NETWORKING, "unicode get name resolution of the local machine failed");
		throw exception();
	}
	ASSERT(wAddr.size() > 0);
}


extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
/*++

Routine Description:
    Test Network Send library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

    if (!ParseCommand(argc, argv))
    {
        return -1;
    }

    printf("Send messages to:\n");
    for (DWORD i = 0; i < s_noOfQueues; ++i)
    {
        printf("\t%ls\n", s_pQueueList[i]);
    }
    
    TrInitialize();

    ExInitialize(5);

    NoInitialize();

	TestNameResolution();
	

    HANDLE* CompleteEvent = new HANDLE[s_noOfQueues];

    for (DWORD i = 0; i < s_noOfQueues; ++i)
    {
        CompleteEvent[i] = CreateEvent(NULL,FALSE, FALSE, NULL);
        
        WCHAR hostName[256];
        WCHAR resourceName[256];
        USHORT port;

        bool f = CrackUrl(s_pQueueList[i], hostName, port, resourceName);
        ASSERT(f);
		DBG_USED(f);

        if (s_fUseProxy)
        {
            TestConnect(s_proxyName, hostName, s_proxyPort, s_pQueueList[i], CompleteEvent[i]);
            continue;
        }

        TestConnect(hostName, hostName, port, resourceName, CompleteEvent[i]);
    }


    WaitForMultipleObjects(s_noOfQueues, CompleteEvent, TRUE, INFINITE);

    WPP_CLEANUP();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\qal\lib\qalpcfg.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    qalpcfg.h

Abstract:
    Queue Aliase storage configuration class

Author:
    Gil Shafriri (Gilsh)

--*/



#ifndef QALPCFG_H
#define QALPCFG_H


//---------------------------------------------------------
//
// Queue Alias Storage configuration
//
//-------------------------------------------------------
class CQueueAliasStorageCfg
{
public:	
	static void SetQueueAliasDirectory(LPCWSTR pDir);
	static LPWSTR GetQueueAliasDirectory(void);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\qal\lib\qalp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    qalp.h

Abstract:
	header for class CQueueAliasPersist -
	class that implements persistence of Queue\Alias mapping.
	It let the class user to persist\unpersist\enumerate Queues Aliases.

Author:
    Gil Shafriri (gilsh) 12-Apr-00

--*/



#ifndef _MSMQ_qalp_H_
#define _MSMQ_qalp_H_

#ifdef _DEBUG
void QalpRegisterComponent(void);
BOOL QalpIsInitialized(void);
#else
#define QalpRegisterComponent() ((void)0);
#define QalpIsInitialized() (TRUE);
#endif


#endif // _MSMQ_qalp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\qal\lib\qal.cpp ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

    Module Name:    qal.cpp

    Abstract:

    Author:
        Vlad Dovlekaev  (vladisld)      1/29/2002

    History:

--*/

#include <libpch.h>
#include <Qal.h>
#include <privque.h>
#include "qalp.h"
#include "qalpcfg.h"
#include "qalpxml.h"
#include "mqexception.h"
#include "fn.h"
#include "fntoken.h"
#include "rex.h"
#include "strsafe.h"
#include "mp.h"


#include "qal.tmh"



std::wstring GetDefaultStreamReceiptURL(LPCWSTR szDir);
extern void  GetDnsNameOfLocalMachine( WCHAR ** ppwcsDnsName );
extern void  CrackUrl(LPCWSTR url, xwcs_t& hostName, xwcs_t& uri, USHORT* port, bool* pfSecure);
	
template <class T, long FixedSize = 256>
class CStackAllocT
{
public:
    CStackAllocT(long nSize)
        :p( nSize > FixedSize ?new T[nSize] :m_Fixed)
    {}

    ~CStackAllocT()
    {
        if( p != NULL && p != m_Fixed )
        {
            delete[] p;
        }
    }

    T* p; // pointer to buffer
protected:
    T m_Fixed[FixedSize];
};


//---------------------------------------------------------
//
//  Lexicographical map
//
//---------------------------------------------------------
class CLexMap
{
    typedef std::pair< std::wstring, std::wstring > StrPair;
    typedef std::vector< StrPair >       StrVector;
    typedef StrVector::iterator          StrVectorIt;
    typedef StrVector::const_iterator    StrVectorItConst;

public:

    CLexMap():m_bExcludeLocalNames(false){}

    void InsertItem     ( const xwcs_t& sFrom, const xwcs_t& sTo, bool bNotifyDublicate = true );
    void InsertException( const xwcs_t& sException);
    bool Lookup         ( LPCWSTR szIn, LPWSTR*  pszOut ) const;

private:
    void PrepareURIForLexer( LPCWSTR wszURI, std::stringstream& sUTF8 );
    static bool IsInternalURI(LPCWSTR wszURI );
private:

    struct alias_eq: public std::binary_function< StrPair, WCHAR*, bool>
    {
        bool operator () ( const StrPair& lhs, LPCWSTR rhs ) const
        {
            return !_wcsicmp( lhs.first.c_str(), rhs);
        }
    };

private:
    StrVector    m_Results;
    CRegExpr     m_map;
    CRegExpr     m_exceptions;
    bool         m_bExcludeLocalNames;
};


//---------------------------------------------------------
//
//  class CQueueAliasImp - holds CQueueAlias private data
//
//---------------------------------------------------------
class CQueueAliasImp : public CReference
{

public:
	CQueueAliasImp(LPCWSTR pMappingDir)
        :m_sAliasDir(pMappingDir)
	{
		LoadMaps();
	}

	bool GetInboundQueue (LPCWSTR pOriginalUri, LPWSTR* ppTargetUri ) const;
    bool GetOutboundQueue(LPCWSTR pOriginalUri, LPWSTR* ppTargetUri ) const;
	bool GetStreamReceiptURL(LPCWSTR pFormatName, LPWSTR* ppStreamReceiptURL )const;
    bool GetDefaultStreamReceiptURL(LPWSTR* ppStreamReceiptURL) const;
	R<CQueueAliasImp> clone();

private:
	void LoadMaps();
private:
	
    std::wstring m_sAliasDir;
    std::wstring m_sDefaultStreamReceiptURL;
    CLexMap      m_InboundQueueMap;
    CLexMap      m_StreamReceiptMap;
    CLexMap      m_OutboundQueueMap;
};




void CLexMap::InsertItem( const xwcs_t & sFrom,
                          const xwcs_t & sTo,
                          bool  fNotifyDuplicate)
/*++

Routine Description:
	insert new mapping into maps in memory.
    NOTE: Please keep it exception safe !!!

Arguments:
	IN -  pFormatName - Queue format name

	IN -  pAliasFormatName - alias formatname.

--*/
{
    AP<WCHAR> sFromDecoded = sFrom.ToStr();
    AP<WCHAR> sToDecoded   = sTo.ToStr();

    //
    // Convert the backslashes to slashes
    //
    FnReplaceBackSlashWithSlash(sFromDecoded);
    FnReplaceBackSlashWithSlash(sToDecoded);

    //
    // Check for duplication
    //
    StrVectorIt itFound = std::find_if( m_Results.begin(),
                                        m_Results.end(),
                                        std::bind2nd( alias_eq(), (LPCWSTR)sFromDecoded));
    if( itFound != m_Results.end())
    {
        TrERROR(GENERAL, "mapping from %ls to %ls ignored because of duplicate mapping", (LPCWSTR)sFromDecoded, (LPCWSTR)sToDecoded);
        if( fNotifyDuplicate )
            AppNotifyQalDuplicateMappingError((LPCWSTR)sFromDecoded, (LPCWSTR)sToDecoded);
        return;
    }

    //
    // Notify the application
    //
    TrTRACE(GENERAL,"%ls -> %ls  mapping found", (LPCWSTR)sFromDecoded, (LPCWSTR)sToDecoded);
    if(!AppNotifyQalMappingFound((LPCWSTR)sFromDecoded, (LPCWSTR)sToDecoded))
    {
        TrERROR(GENERAL, "mapping from %ls to %ls rejected", (LPCWSTR)sFromDecoded, (LPCWSTR)sToDecoded	);
        return;
    }

    //
    // Normalize the Alias name
    //
    std::stringstream ssFrom;
    PrepareURIForLexer( (LPCWSTR)sFromDecoded, ssFrom);

    //
    // Build the regExpr using the normalized names
    //
    CRegExpr temp( ssFrom, std::ios::traits_type::eof(), numeric_cast<int>(m_Results.size()));
    temp |= m_map;

    //
    // update the internal state
    //
    m_Results.push_back( StrPair( (LPCWSTR)sFromDecoded, (LPCWSTR)sToDecoded) );
    m_map.swap(temp);
}

void CLexMap::InsertException( const xwcs_t & sException)
/*++

Routine Description:
	insert new exception to the map.

Arguments:
	IN - sException - ...
				
--*/
{
    if( !_wcsnicmp(L"local_names", sException.Buffer(), sException.Length()) )
    {
        m_bExcludeLocalNames = true;
        return;
    }

    AP<WCHAR> sDecoded = sException.ToStr();

    //
    // Replace backslashes to slashes
    //
    FnReplaceBackSlashWithSlash(sDecoded);

    //
    // Normalize the Alias name
    //
    std::stringstream ssFrom;
    PrepareURIForLexer( (LPCWSTR)sDecoded, ssFrom);

    //
    // Build the regExpr using the normalized names
    //
    CRegExpr temp( ssFrom, std::ios::traits_type::eof(), 1);
    temp |= m_exceptions;

    //
    // update the internal state
    //
    m_exceptions.swap(temp);
}



bool
CLexMap::Lookup( LPCWSTR szIn, LPWSTR*  pszOut ) const
{
	ASSERT(szIn);
    ASSERT(pszOut);

    if( m_map.empty() )
        return false;
    //
    // Convert the string to lowercase
    //
    int iMaxSize = wcslen(szIn) + 1;

    CStackAllocT<WCHAR> szLower( iMaxSize );

    HRESULT hr = StringCchCopy(szLower.p, iMaxSize, szIn);
    if( FAILED(hr))
    {
        throw bad_hresult(hr);
    }
    CharLower( szLower.p );

    //
    // Convert the string to UTF8
    //
    int size = WideCharToMultiByte(CP_UTF8, 0, szLower.p, -1, NULL, 0, NULL, NULL);
    if( 0 == size )
        throw bad_hresult(GetLastError());

    CStackAllocT<char> szUtf8( size + 1 );

    size = WideCharToMultiByte(CP_UTF8, 0, szLower.p, -1, szUtf8.p, size+1, NULL, NULL);
    if( 0 == size )
        throw bad_hresult(GetLastError());

    //
    // Match against the lexer
    //
    const char* end = NULL;
    int index = m_map.match( szUtf8.p, &end);
    if( -1 == index || *end != '\0')
        return false;

    //
    // Match against the exceptions
    //
    if( !m_exceptions.empty())
    {
        int result = m_exceptions.match( szUtf8.p, &end);
        if( 1 == result && *end == '\0')
            return false;
    }

    //
    // Match againsts local names
    //
    if( m_bExcludeLocalNames && IsInternalURI(szIn) )
    {
        return false;
    }

    *pszOut = newwcs(m_Results[index].second.c_str());
	return true;
}

void
CLexMap::PrepareURIForLexer( LPCWSTR wszURI, std::stringstream& sUTF8 )
{
    ASSERT(wszURI);

    //
    // Convert the string to lowercase
    //
    int iMaxSize = wcslen(wszURI)+1;

    CStackAllocT<WCHAR> szLower( iMaxSize );

    HRESULT hr = StringCchCopy(szLower.p, iMaxSize, wszURI);
    if( FAILED(hr))
    {
        throw bad_hresult(hr);
    }
    CharLower( szLower.p );

    //
    // Convert the string to UTF8
    //
    int size = WideCharToMultiByte(CP_UTF8, 0, szLower.p, -1, NULL, 0, NULL, NULL);
    if( 0 == size )
        throw bad_hresult(GetLastError());

    CStackAllocT<char> szUtf8( size + 1 );

    size = WideCharToMultiByte(CP_UTF8, 0, szLower.p, -1, szUtf8.p, size+1, NULL, NULL);
    if( 0 == size )
        throw bad_hresult(GetLastError());

    //
    // Escape all the "un-allowed" regular expression reserved symbols
    //
    for(LPCSTR szptr = szUtf8.p; *szptr != '\0'; ++szptr )
    {
        if( strchr("*", *szptr ))
        {
            sUTF8 << ".*";
        }
        else if( strchr("|*+?().][\\^:-", *szptr))
        {
            sUTF8 << '\\' << *szptr;
        }
        else
        {
            sUTF8 << *szptr;
        }
    }
}


bool CLexMap::IsInternalURI(LPCWSTR wszURI )
{
    xwcs_t host;
    xwcs_t uri;
    USHORT port;
	bool   fSecure;

    try{
        CrackUrl(wszURI, host, uri, &port, &fSecure);

        LPCWSTR start = host.Buffer();
        LPCWSTR end   = start + host.Length();

        //
        // Could not find '.' in the name - so it is internal machine
        //
        return std::find(start , end, L'.') == end;
    }
    catch(exception&)
    {
        return false;
    }
}


inline R<CQueueAliasImp> CQueueAliasImp::clone()
{
	return new 	CQueueAliasImp(m_sAliasDir.c_str());
}



static BOOL GetLocalMachineDnsName(AP<WCHAR>& pDnsName)
/*++

Routine Description:
	Returns full DNS name of local machine

Arguments:
	OUT pszMachineName  - dns name of the machine
				
Returned value:
	true - if function succeeds otherwise false

--*/
{
	
DWORD dwNumChars = 0;
	 if(!GetComputerNameEx(
				ComputerNameDnsFullyQualified, 
				NULL, 
				&dwNumChars
				))
	{
		DWORD gle = GetLastError();
		if(gle != ERROR_MORE_DATA)
		{
			TrERROR(GENERAL, "GetComputerNameEx failed. Last error: %!winerr!", gle);
			return FALSE;
		}
	}

	pDnsName = new WCHAR[dwNumChars + 1];
    if(!GetComputerNameEx(
				ComputerNameDnsFullyQualified, 
				pDnsName.get(),
				&dwNumChars
				))
	{
		DWORD gle = GetLastError();
		TrERROR(GENERAL, "GetComputerNameEx failed. Last error: %!winerr!", gle);
		return FALSE;
	}
    return TRUE;
}

std::wstring GetLocalSystemQueueName(LPCWSTR wszQueueName, bool fIsDnsName)
/*++

Routine Description:
	Returns the oder queue name for local machine

Arguments:
	None
				
Returned value:
	local order queue name

--*/
{
    std::wstringstream wstr;
    LPCWSTR pszMachineName = NULL;
	WCHAR       LocalNetbiosName[MAX_COMPUTERNAME_LENGTH + 1];
    AP<WCHAR> dnsName;
    
	if(fIsDnsName)
	{
		if(!GetLocalMachineDnsName(dnsName))
			return L"";

		pszMachineName = dnsName.get();
	}
	else
    {
        DWORD size    = TABLE_SIZE(LocalNetbiosName);
        BOOL fSuccess = GetComputerName(LocalNetbiosName, &size);
        if(!fSuccess)
        {
            DWORD err = GetLastError();
            TrERROR(SRMP, "GetComputerName failed with error %!winerr! ",err);
            throw bad_win32_error(err);
        }
        pszMachineName = LocalNetbiosName;
    }

    wstr<<FN_DIRECT_HTTP_TOKEN
        <<pszMachineName
        <<L"/"
        <<FN_MSMQ_HTTP_NAMESPACE_TOKEN
        <<L"/"
        <<FN_PRIVATE_$_TOKEN
        <<L"/"
        <<wszQueueName;

    return wstr.str();
}


void CQueueAliasImp::LoadMaps(void)
/*++

Routine Description:
	load all mapping from xml files to memory

Arguments:
	None
				
Returned value:
	None

--*/
{
	//
    // Get the name of local order queue
    //
	
	std::wstring sLocalOrderQueueName  = GetLocalSystemQueueName(ORDERING_QUEUE_NAME,false);
	std::wstring sLocalOrderQueueNameDns  = GetLocalSystemQueueName(ORDERING_QUEUE_NAME,true);

	
	//
	//Adding admin queues to exception with machine name and full Dns name
	//
	std::wstring sCurrentAdminQueueName = GetLocalSystemQueueName(ADMINISTRATION_QUEUE_NAME,false);			
	m_InboundQueueMap.InsertException(xwcs_t(sCurrentAdminQueueName.c_str(),sCurrentAdminQueueName.size()));

	sCurrentAdminQueueName = GetLocalSystemQueueName(ADMINISTRATION_QUEUE_NAME,true);
	if(sCurrentAdminQueueName.size() >  0)
		m_InboundQueueMap.InsertException(xwcs_t(sCurrentAdminQueueName.c_str(),sCurrentAdminQueueName.size()));
		
	sCurrentAdminQueueName = GetLocalSystemQueueName(NOTIFICATION_QUEUE_NAME,false);
	m_InboundQueueMap.InsertException(xwcs_t(sCurrentAdminQueueName.c_str(),sCurrentAdminQueueName.size()));

	sCurrentAdminQueueName = GetLocalSystemQueueName(NOTIFICATION_QUEUE_NAME,true);
	if(sCurrentAdminQueueName.size() >  0)
		m_InboundQueueMap.InsertException(xwcs_t(sCurrentAdminQueueName.c_str(),sCurrentAdminQueueName.size()));

	sCurrentAdminQueueName = GetLocalSystemQueueName(ORDERING_QUEUE_NAME,false);
	m_InboundQueueMap.InsertException(xwcs_t(sCurrentAdminQueueName.c_str(),sCurrentAdminQueueName.size()));

	sCurrentAdminQueueName = GetLocalSystemQueueName(ORDERING_QUEUE_NAME,true);
	if(sCurrentAdminQueueName.size() >  0)
		m_InboundQueueMap.InsertException(xwcs_t(sCurrentAdminQueueName.c_str(),sCurrentAdminQueueName.size()));
	
	sCurrentAdminQueueName = GetLocalSystemQueueName(TRIGGERS_QUEUE_NAME,false);
	m_InboundQueueMap.InsertException(xwcs_t(sCurrentAdminQueueName.c_str(),sCurrentAdminQueueName.size()));

	sCurrentAdminQueueName = GetLocalSystemQueueName(TRIGGERS_QUEUE_NAME,true);
	if(sCurrentAdminQueueName.size() >  0)
		m_InboundQueueMap.InsertException(xwcs_t(sCurrentAdminQueueName.c_str(),sCurrentAdminQueueName.size()));
	
		
    //
    // Load old in-bound queue map
    //
    for( CInboundOldMapIterator it( m_sAliasDir.c_str() ); it.isValid(); ++it )
	{
        if( !it.isException() )
            m_InboundQueueMap.InsertItem(it->first, it->second);
        else
            m_InboundQueueMap.InsertException(it->first);
	}

    //
    // Load in-bound queue map ( the new version of q-mappings - actually just name changes)
    //
    for( CInboundMapIterator it( m_sAliasDir.c_str() ); it.isValid(); ++it )
    {
        if( !it.isException() )
            m_InboundQueueMap.InsertItem(it->first, it->second);
        else
            m_InboundQueueMap.InsertException(it->first);
    }

    for( COutboundMapIterator it( m_sAliasDir.c_str() ); it.isValid(); ++it )
    {
        if( !it.isException() )
            m_OutboundQueueMap.InsertItem(it->first, it->second);
        else
            m_OutboundQueueMap.InsertException(it->first);
    }

    //
    // Load stream receipt mappings
    //
	for( CStreamReceiptMapIterator it( m_sAliasDir.c_str() ); it.isValid(); ++it )
	{
        if( !it.isException() )
            m_StreamReceiptMap.InsertItem(it->first, it->second);
        else
            m_StreamReceiptMap.InsertException(it->first);
 		
        //
        // Automaticaly insert the q-mapping which maps the local address to local
        // order queue ( ignore the duplication errors )
        //
        if(sLocalOrderQueueNameDns.size() > 0)
       		 m_InboundQueueMap.InsertItem(it->second, xwcs_t(sLocalOrderQueueNameDns.c_str(),sLocalOrderQueueNameDns.size()), false);
        m_InboundQueueMap.InsertItem(it->second, xwcs_t(sLocalOrderQueueName.c_str(),sLocalOrderQueueName.size()), false);
	}



    //
    // Load the default Stream Receipt alias
    //
    m_sDefaultStreamReceiptURL = ::GetDefaultStreamReceiptURL(m_sAliasDir.c_str());
}



bool
CQueueAliasImp::GetInboundQueue (LPCWSTR pOriginalUri, LPWSTR* ppTargetUri ) const
{
    return m_InboundQueueMap.Lookup(pOriginalUri,ppTargetUri);
}

bool
CQueueAliasImp::GetOutboundQueue(LPCWSTR pOriginalUri, LPWSTR* ppTargetUri ) const
{
    return m_OutboundQueueMap.Lookup(pOriginalUri, ppTargetUri);
}

bool
CQueueAliasImp::GetStreamReceiptURL( LPCWSTR pFormatName, LPWSTR* ppAliasFormatName )const
{
	return m_StreamReceiptMap.Lookup(pFormatName,ppAliasFormatName);
} 	

bool
CQueueAliasImp::GetDefaultStreamReceiptURL(LPWSTR* ppStreamReceiptURL) const
{
    ASSERT(ppStreamReceiptURL);
    if( m_sDefaultStreamReceiptURL.size() <= 0)
    {
        *ppStreamReceiptURL = NULL;
        return false;
    }

    *ppStreamReceiptURL = newwcs(m_sDefaultStreamReceiptURL.c_str());
    return true;
}



//---------------------------------------------------------
//
//  CQueueAlias Implementation
//
//---------------------------------------------------------
CQueueAlias::CQueueAlias(
	LPCWSTR pMappingDir
	):
	m_imp(new CQueueAliasImp(pMappingDir))

/*++

Routine Description:
	constructor - load all queues mapping into two maps :
		one that maps from queue to alias and one from alias to
		queue.

Arguments:
	None


Returned value:
	None

--*/
{
}


CQueueAlias::~CQueueAlias()
{
}


bool
CQueueAlias::GetStreamReceiptURL(
	LPCWSTR pFormatName,
    LPWSTR* ppStreamReceiptURL
  	)const
/*++

Routine Description:
	Get alias for given queue.

Arguments:
	IN - pFormatName - queue format name	    .

	OUT - ppAliasFormatName - receive the alias
	for the queue after the function returns.
				
Returned value:
	true if alias was found for the queue. If not found - false is returned.

--*/
{
	ASSERT(pFormatName);
	ASSERT(ppStreamReceiptURL);
	CS cs(m_cs);
	return m_imp->GetStreamReceiptURL(pFormatName, ppStreamReceiptURL);
} 	


bool
CQueueAlias::GetInboundQueue(
	LPCWSTR  pAliasFormatName,
	LPWSTR*  ppFormatName
	)const
/*++

Routine Description:
	Get queue for given alias

Arguments:
	IN -  pAliasFormatName - alias formatname. it must be canonized URI

	OUT - ppFormatName - receive the queue for the alias  after the function returns.
				
Returned value:
	true if queue was found for the alias. If not found - false is returned.

--*/
{
	ASSERT(pAliasFormatName);
	ASSERT(ppFormatName);
		
	CS cs(m_cs);
	return m_imp->GetInboundQueue(pAliasFormatName, ppFormatName);
} 	

bool
CQueueAlias::GetOutboundQueue(
    LPCWSTR pOriginalUri,
    LPWSTR* ppTargetUri
    ) const
{
	ASSERT(ppTargetUri);
		
	CS cs(m_cs);
	return m_imp->GetOutboundQueue(pOriginalUri, ppTargetUri);
}



bool
CQueueAlias::GetDefaultStreamReceiptURL(
    LPWSTR* ppStreamReceiptURL
    ) const
{
	ASSERT(ppStreamReceiptURL);
		
	CS cs(m_cs);
	return m_imp->GetDefaultStreamReceiptURL(ppStreamReceiptURL);
}


QUEUE_FORMAT_TRANSLATOR::QUEUE_FORMAT_TRANSLATOR(const QUEUE_FORMAT* pQueueFormat, DWORD flags):
    m_fTranslated(false),
    m_fCanonized(false)
/*++
Routine Description:
	Translate given queue format according to local mapping	 (qal.lib)

Arguments:
	IN - pQueueFormat - queue format to translate.


Returned Value:


--*/
{
    m_qf = *pQueueFormat;

	//
	// If not direct - not translation
	//
    if(pQueueFormat->GetType() != QUEUE_FORMAT_TYPE_DIRECT)
	{
		return;		
	}

    //
    // If not http[s] - no translation
    //
    DirectQueueType dqt;
    FnParseDirectQueueType(pQueueFormat->DirectID(), &dqt);
    if( dqt != dtHTTP && dqt != dtHTTPS )
    {
        return;
    }

	if ((flags & CONVERT_SLASHES) == CONVERT_SLASHES)
	{
		ASSERT((flags & DECODE_URL) == 0);
		
		m_sURL = newwcs(pQueueFormat->DirectID());

		//
		// Convert all '\' to '/'.
		//
		FnReplaceBackSlashWithSlash(m_sURL);
		m_qf.DirectID(m_sURL);
	}

	if ((flags & DECODE_URL) == DECODE_URL)
	{
		ASSERT((flags & CONVERT_SLASHES) == 0);
		
		m_sURL = DecodeURI(pQueueFormat->DirectID());
		m_fCanonized  = true;
		m_qf.DirectID(m_sURL);
	}

	AP<WCHAR> MappedURL;	
	if ((flags & MAP_QUEUE) == MAP_QUEUE)
	{
		//
	    // Try to translate the URI
	    //
		m_fTranslated = QalGetMapping().GetInboundQueue(m_qf.DirectID(), &MappedURL);
	    if(m_fTranslated)
		{
			m_qf.DirectID(MappedURL);
	        MappedURL.swap(m_sURL);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\qal\test\qalcfg.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Qal.cpp

Abstract:
   test simulation of class CQueueAliasCfg (qal.h).



Author:
    Gil Shafriri (gilsh) 5-May-00

Environment:
    Platform-independent.
--*/

#include <libpch.h>
#include <tr.h>
#include <qal.h>
#include "..\..\qal\lib\qalpxml.h"
#include "..\..\qal\lib\qalpcfg.h"

#include "QalCfg.tmh"

void CQueueAliasStorageCfg::SetQueueAliasDirectory(LPCWSTR /*pDir*/)
{

};

LPWSTR CQueueAliasStorageCfg::GetQueueAliasDirectory(void)
{
	static int fail=0;
	fail++;
	if( (fail % 10) == 0)
	{
		return NULL;
	}
	WCHAR froot[MAX_PATH];
	DWORD ret = GetEnvironmentVariable(L"froot",froot,MAX_PATH);
	ASSERT(ret != 0);
	UNREFERENCED_PARAMETER(ret);

	std::wstring  path = std::wstring(froot) + L"\\src\\lib\\qal\\test";
	return newwcs (path.c_str());

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\qal\lib\qalpxml.cpp ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

    Module Name:    qalpxml.cpp

    Abstract:
        Implementation of q-mappings iterators

    Author:
        Vlad Dovlekaev  (vladisld)      1/29/2002

    History:
        1/29/2002   vladisld    Created
--*/

#include <libpch.h>
#include <mqexception.h>
#include <utf8.h>
#include <qal.h>
#include <strutl.h>
#include "qalp.h"
#include "qalpxml.h"

#include "qalpxml.tmh"

LPCWSTR CInboundMapXMLDef::x_szNameSpace= L"msmq-queue-redirections.xml";
LPCWSTR CInboundMapXMLDef::x_szRootNode= L"redirections";
LPCWSTR CInboundMapXMLDef::x_szMapNode= L"redirection";
LPCWSTR CInboundMapXMLDef::x_szExceptionsNode= L"exceptions";
LPCWSTR CInboundMapXMLDef::x_szExceptionNode= L"exception";
LPCWSTR CInboundMapXMLDef::x_szFromValueName= L"!from";
LPCWSTR CInboundMapXMLDef::x_szToValueName= L"!to";

LPCWSTR CInboundOldMapXMLDef::x_szNameSpace= L"msmq-queue-mapping.xml";
LPCWSTR CInboundOldMapXMLDef::x_szRootNode= L"mapping";
LPCWSTR CInboundOldMapXMLDef::x_szMapNode= L"queue";
LPCWSTR CInboundOldMapXMLDef::x_szExceptionsNode= L"exceptions";
LPCWSTR CInboundOldMapXMLDef::x_szExceptionNode= L"exception";
LPCWSTR CInboundOldMapXMLDef::x_szFromValueName= L"!alias";
LPCWSTR CInboundOldMapXMLDef::x_szToValueName= L"!name";

LPCWSTR COutboundMapXMLDef::x_szNameSpace= L"msmq_outbound_mapping.xml";
LPCWSTR COutboundMapXMLDef::x_szRootNode= L"outbound_redirections" ;
LPCWSTR COutboundMapXMLDef::x_szMapNode=  L"redirection";
LPCWSTR COutboundMapXMLDef::x_szExceptionsNode= L"exceptions";
LPCWSTR COutboundMapXMLDef::x_szExceptionNode= L"exception";
LPCWSTR COutboundMapXMLDef::x_szFromValueName= L"!destination";
LPCWSTR COutboundMapXMLDef::x_szToValueName= L"!through";

LPCWSTR CStreamReceiptXMLDef::x_szNameSpace= L"msmq-streamreceipt-mapping.xml";
LPCWSTR CStreamReceiptXMLDef::x_szRootNode= L"StreamReceiptSetup";
LPCWSTR CStreamReceiptXMLDef::x_szMapNode= L"setup";
LPCWSTR CStreamReceiptXMLDef::x_szExceptionsNode= L"exceptions";
LPCWSTR CStreamReceiptXMLDef::x_szExceptionNode= L"exception";
LPCWSTR CStreamReceiptXMLDef::x_szFromValueName= L"!LogicalAddress";
LPCWSTR CStreamReceiptXMLDef::x_szToValueName= L"!StreamReceiptURL";


//
// Stream receipt schema tags
//
const LPCWSTR xStreamReceiptNameSpace = L"msmq-streamreceipt-mapping.xml";
const LPCWSTR xStreamReceiptNodeTag = L"StreamReceiptSetup";
const LPCWSTR xDefaultNodeTag       = L"!default";
const LPCWSTR xSetupNodeTag         = L"setup";
const LPCWSTR xLogicalAddress       = L"!LogicalAddress";
const LPCWSTR xStreamReceiptURL     = L"!StreamReceiptURL";


const BYTE xUtf8FileMark[]          = {0XEF, 0XBB, 0xBF};
const BYTE xUnicodeFileMark[]       = {0xFF, 0xFE};


class bad_unicode_file : public std::exception
{
};

static bool IsUtf8File(const BYTE* pBuffer, DWORD size)
/*++

Routine Description:
	Check if a given file buffer is utf8 format and not  simple ansi.

Arguments:
	IN - pBuffer - pointer to file data.
	IN - size - the size in  BYTES of the buffer pBuffer points to.

Returned value:
	true if utf8 file (starts with {0XEF, 0XBB, 0xBF} )
	
--*/
{
	ASSERT(pBuffer != NULL);
	return UtlIsStartSec(
					pBuffer,
					pBuffer + size,
					xUtf8FileMark,
					xUtf8FileMark + TABLE_SIZE(xUtf8FileMark)
					);
					
}


static bool IsUnicodeFile(const BYTE* pBuffer, DWORD size)
/*++

Routine Description:
	Check if a given file buffer is unicode file


Arguments:
	IN - pBuffer - pointer to file data.
	IN - size - the size in  BYTES of the buffer pBuffer points to.

Returned value:
	true if unicode file (starts with {0xFF, 0xFE} ) - false otherwise.
	bad_unicode_file exception is thrown if file format is invalid.
--*/
{
	ASSERT(pBuffer != NULL);

	bool fUnicodeFile = UtlIsStartSec(
								pBuffer,
								pBuffer + size,
								xUnicodeFileMark,
								xUnicodeFileMark + TABLE_SIZE(xUnicodeFileMark)
								);
					

	if(fUnicodeFile && (size % sizeof(WCHAR) != 0))
	{
		throw bad_unicode_file();
	}

	return fUnicodeFile;
}



LPWSTR LoadFile(LPCWSTR pFileName, DWORD* pSize, DWORD* pDataStartOffset)
/*++

Routine Description:
	Load  xml file into memory and return pointer to it's memory.
	If the file is utf8 format and not unicode - convert it (in memory)
	to unicode and return pointer to it's memory.

Arguments:
	pFileName - full file path to load to memory.
	pSize - return file size in WCHARS
	pDataStartOffset - return the offset of the data start in WCHARS from file start.


Returned value:
	Pointer to NULL terminated unicode string that is the file content.

--*/


{
	CFileHandle hFile = CreateFile(
							pFileName,
							GENERIC_READ,
							FILE_SHARE_READ,
							NULL,        // IpSecurityAttributes
							OPEN_EXISTING,
							NULL,      // dwFlagsAndAttributes
							NULL      // hTemplateFile
							);
    if(hFile == INVALID_HANDLE_VALUE)
	{
		DWORD err = GetLastError();
	    TrERROR(GENERAL,"CreateFile() failed for %ls with Error=%d",pFileName, err);
        throw bad_win32_error(err);
	}

    DWORD size = GetFileSize(hFile, NULL);
	if(size == 0xFFFFFFFF)
	{
		DWORD err = GetLastError();
		TrERROR(GENERAL,"GetFileSize() failed for %ls with Error=%d", pFileName, err);
		throw bad_win32_error(err);
	}
	
	AP<BYTE> pFileBuffer = new BYTE[size];
	DWORD ActualRead;
	BOOL fsuccess = ReadFile(hFile, pFileBuffer, size, &ActualRead, NULL);
	if(!fsuccess)
	{
		DWORD err = GetLastError();
		TrERROR(GENERAL,"Reading file %ls failed with Error=%d", pFileName, err);
		throw bad_win32_error(err);
	}
	ASSERT(ActualRead == size);

	//
	// If unicode file - just return pointer to the file data - the data itself starts
	// one UNICODE byte after the caracter 0xFEFF (mark for unicode file)
	//
	if(IsUnicodeFile(pFileBuffer.get(), size))
	{
		*pSize =  size/sizeof(WCHAR);
		*pDataStartOffset = TABLE_SIZE(xUnicodeFileMark)/sizeof(WCHAR);
		ASSERT(*pDataStartOffset == 1);
		return reinterpret_cast<WCHAR*>(pFileBuffer.detach());
	}

	//
	// If non UNICODE - then if ansy , the data starts at the file start.
	// if UTF8,  the data starts after the bytes (EF BB BF)
	//
	DWORD DataStartOffest = (DWORD)(IsUtf8File(pFileBuffer.get(), size) ? TABLE_SIZE(xUtf8FileMark) : 0);
	ASSERT(DataStartOffest <=  size);

	//
	// Assume the file is utf8 (or ansi) - convert it to unicode
	//
	size_t ActualSize;
	AP<WCHAR> pwBuffer = UtlUtf8ToWcs(pFileBuffer.get() + DataStartOffest , size - DataStartOffest,  &ActualSize);
	*pSize = numeric_cast<DWORD>(ActualSize);
	*pDataStartOffset = 0;
	return 	pwBuffer.detach();
}


xwcs_t GetValue(const XmlNode* pXmlNode)
{
	List<XmlValue>::iterator it = pXmlNode->m_values.begin();
	if(it ==  pXmlNode->m_values.end())
	{
		return xwcs_t();
	}

	LPCWSTR szPtr = it->m_value.Buffer();
    int     len   = it->m_value.Length();

    while( len > 0 )
    {
        if(!iswspace(szPtr[len]))
            break;
        len--;
    }

    return xwcs_t( it->m_value.Buffer(), len);
}

xwcs_t GetValue(const XmlNode* pXmlNode,LPCWSTR pTag)
{
	const XmlNode* pQnode = XmlFindNode(pXmlNode,pTag);
	if(pQnode == NULL)
	{
		return xwcs_t();
	}
	
    return GetValue( pQnode );
}


HANDLE CFilesIterator::GetSearchHandle( LPCWSTR szDir, LPCWSTR szFilter )
{
    if( NULL == szDir || NULL == szFilter)
        return INVALID_HANDLE_VALUE;

    AP<WCHAR> pFullPath = newwcscat(szDir, szFilter);
    return ::FindFirstFile(pFullPath, &m_FileInfo);
}

void CFilesIterator::Advance()
{
    if( !isValid() )
        return;

    if( !FindNextFile(m_hSearchFile, &m_FileInfo) )
    {
        DWORD dwError = GetLastError();
        if( dwError != ERROR_NO_MORE_FILES )
        {
            TrERROR(GENERAL,"FindNextFile() failed for with error %d", dwError);
            throw bad_hresult(dwError);
        }

        m_hSearchFile.free();
    }
}

std::wstring GetDefaultStreamReceiptURL(LPCWSTR szDir)
{
    for(CFilesIterator it(szDir, L"\\*.xml"); it.isValid(); ++it)
    {
        try
        {
            CAutoXmlNode   pTree;
            AP<WCHAR>	   pDoc;
            DWORD          DocSize = 0, DataStartOffet = 0;
            const XmlNode* pNode = NULL;

            pDoc  = LoadFile(it->c_str(), &DocSize, &DataStartOffet);

            XmlParseDocument(xwcs_t(pDoc + DataStartOffet, DocSize - DataStartOffet),&pTree);//lint !e534

            pNode = XmlFindNode(pTree, xStreamReceiptNodeTag);

            //
            // if we could not find "root" node - move to next file
            //
            if( NULL == pNode)
            {
                TrTRACE(GENERAL, "Could not find '%ls' node in file '%ls'", xStreamReceiptNodeTag, it->c_str());
                //AppNotifyQalInvalidMappingFileError(it->c_str());
                continue;
            }

            //
            // if the namespace is wrong -  move to next file
            //
            if(pNode->m_namespace.m_uri != xStreamReceiptNameSpace)
            {
                TrERROR(GENERAL, "Node '%ls' is not in namespace '%ls' in file '%ls'", xStreamReceiptNodeTag, xStreamReceiptNameSpace, it->c_str());
                AppNotifyQalInvalidMappingFileError(it->c_str());
                continue;
            }

            xwcs_t xsUrl = GetValue(pNode, xDefaultNodeTag);
            if(xsUrl.Length() > 0)
            {
                return std::wstring(xsUrl.Buffer(), xsUrl.Length());
            }
        }
        catch(const bad_document&)
        {
            AppNotifyQalInvalidMappingFileError(it->c_str());
        }
        catch(const bad_win32_error& err)
        {
            TrERROR(GENERAL, "Mapping file %ls is ignored. Failed to read file content, Error %d", it->c_str(), err.error());
            AppNotifyQalWin32FileError(it->c_str(), err.error());
        }
        catch(const exception&)
        {
            TrERROR(GENERAL, "Mapping file %ls is ignored. Unknown error", it->c_str());
        }
    }
    return std::wstring();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\qal\lib\qalpxml.h ===
/*++

/*++Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.

    Module Name:    qalpxml.h

    Abstract:
        Defines the series of iterators used to iterate over q-mappings

    Author:
        Vlad Dovlekaev  (vladisld)      1/29/2002

    History:
        1/29/2002   vladisld    - Created

--*/

#ifndef _MSMQ_qalpxml_H_
#define _MSMQ_qalpxml_H_

#include <list.h>
#include <xml.h>
#include <mqexception.h>

////////////////////////////////////////////////////////////////////////////////
// Typedefs
typedef std::pair< xwcs_t, xwcs_t > XStrPair;

////////////////////////////////////////////////////////////////////////////////
// Function prototypes
xwcs_t GetValue(const XmlNode* pXmlNode);
xwcs_t GetValue(const XmlNode* pXmlNode,LPCWSTR pTag);
LPWSTR LoadFile(LPCWSTR pFileName, DWORD* pSize, DWORD* pDataStartOffset);

///////////////////////////////////////////////////////////////////////////////
///  CXMLIterator
///
///  The main purpose of this simple iterator is to wrap the functionality of
///  List<XMLNode>::iterator class while holding references to all the accompanying
///  classes like XMLTree and Document
///
class CXMLIterator: public std::iterator<std::forward_iterator_tag, XmlNode, long>
{

public:
    CXMLIterator():m_node(NULL), m_it(NULL){}

    CXMLIterator(const List<XmlNode>* node,
                 AP<WCHAR>&           pDoc,
                 CAutoXmlNode&        XmlTree)
        :m_node     (node),
         m_it       (node->begin()),
         m_pDoc     (pDoc.detach()),
         m_XmlTree  (XmlTree.detach())
    {}	

	const value_type& operator* ()    {return *m_it; }

	const value_type* operator->()    {return (&**this);  }

	CXMLIterator&     operator++()    {Advance(); return (*this); }

//    CXMLIterator   operator++(int)    {CXMLIterator tmp = *this; Advance(); return (tmp); }

    bool equal(const CXMLIterator& rhs) const {return ( isValid() == rhs.isValid() ); }

    bool isValid() const              { return !(!m_node || m_node->end() == m_it); }

    void swap( CXMLIterator& rhs ) throw()
    {
        std::swap( m_node, rhs.m_node);
        std::swap( m_it,   rhs.m_it);
        m_pDoc.swap(rhs.m_pDoc);
        m_XmlTree.swap(rhs.m_XmlTree);
    }

private:
     CXMLIterator(const CXMLIterator&);// not implemented
     CXMLIterator& operator=(const CXMLIterator&); //not implemented

     void Advance()
     {
         if( isValid() )
             ++m_it;
     }

private:
    const List<XmlNode>*    m_node;
    List<XmlNode>::iterator m_it;
    AP<WCHAR>               m_pDoc;
    CAutoXmlNode            m_XmlTree;
};
inline bool operator==(const CXMLIterator& X, const CXMLIterator& Y)
{return (X.equal(Y)); }
inline bool operator!=(const CXMLIterator& X, const CXMLIterator& Y)
{return (!(X == Y)); }


///////////////////////////////////////////////////////////////////////////////
// CFilesIterator
//
// This is a general purpose iterator for filenames in given directory
//
class CFilesIterator: public std::iterator<std::forward_iterator_tag, std::wstring, long>
{
public:
    CFilesIterator(){}

    CFilesIterator(LPCWSTR szDir, LPCWSTR szFilter)
        :m_sDir(szDir),
        m_hSearchFile( GetSearchHandle(szDir, szFilter) )
    {}

	const value_type& operator* ()      {return (m_sFullName = m_sDir + L"\\" + m_FileInfo.cFileName);}

	const value_type* operator->()      {return (&**this);  }

	CFilesIterator&   operator++()      {Advance(); return (*this); }

    //CFilesIterator   operator++(int)    {CFilesIterator tmp = *this; Advance(); return (tmp); }

    bool equal(const CFilesIterator& rhs) const {return (m_hSearchFile== rhs.m_hSearchFile); }

    bool isValid() const { return !(INVALID_HANDLE_VALUE == m_hSearchFile); }

private:
    CFilesIterator(const CFilesIterator&);// not implemented
    CFilesIterator& operator=(const CFilesIterator&); //not implemented

    void Advance();
    HANDLE GetSearchHandle( LPCWSTR szDir, LPCWSTR szFilter );

private:

    std::wstring      m_sFullName;
    std::wstring      m_sDir;
	WIN32_FIND_DATA   m_FileInfo;
	CSearchFileHandle m_hSearchFile;
};

inline bool operator==(const CFilesIterator& X, const CFilesIterator& Y)
{return (X.equal(Y)); }
inline bool operator!=(const CFilesIterator& X, const CFilesIterator& Y)
{return (!(X == Y)); }


////////////////////////////////////////////////////////////////////////////////
// CQueueMapIteratorBase
//
// Iterates through the given XML node type nodes in all .xml files in given directory
//
template< typename XMLDef >
class CQueueMapIteratorBase: public std::iterator<std::forward_iterator_tag, XStrPair, long>
{
public:

    CQueueMapIteratorBase():m_bInitialized(false){}

    CQueueMapIteratorBase(LPCWSTR szDir)
        :m_FilesIt(szDir, L"\\*.xml"),
         m_bInitialized(false),
         m_bException(false)
    { Advance(); }
	
    const value_type&       operator* () {return m_Item; }

	const value_type*       operator->() {return (&**this); }

	CQueueMapIteratorBase&  operator++() {Advance(); return (*this); }

    //CQueueMapIteratorBase   operator++(int)    {CQueueMapIteratorBase tmp = *this; Advance(); return (tmp); }

    bool equal(const CQueueMapIteratorBase& x) const  {return ( isValid() == x.isValid()); }

    bool isValid() const { return m_FilesIt.isValid() || m_XMLIt.isValid(); }
    bool isException() const { return m_bException; }

private:
    CQueueMapIteratorBase(const CQueueMapIteratorBase&);// not implemented
    CQueueMapIteratorBase& operator=(const CQueueMapIteratorBase&); //not implemented

private:
	void Advance();
    void AdvanceFile();

private:
    bool           m_bInitialized;
    bool           m_bException;
    XStrPair       m_Item;
    CFilesIterator m_FilesIt;
    CXMLIterator   m_XMLIt;
};

template< typename T>
inline bool operator==(const CQueueMapIteratorBase<T>& X, const CQueueMapIteratorBase<T>& Y)
{return (X.equal(Y)); }

template< typename T>
inline bool operator!=(const CQueueMapIteratorBase<T>& X, const CQueueMapIteratorBase<T>& Y)
{return (!(X == Y)); }

template< typename XMLDef>
void CQueueMapIteratorBase<XMLDef>::Advance()
{
    while( isValid() )
    {
        //
        // if end of mapping in this file - move to next one
        //
        if( !(++m_XMLIt).isValid() )
        {
            AdvanceFile();		

            if( !m_XMLIt.isValid() )
                continue;
        }

        //
        // if we are on the wrong node, move to next tag
        //
        if( m_XMLIt->m_tag == XMLDef::x_szMapNode)
        {
            m_Item.first  = GetValue(&*m_XMLIt, XMLDef::x_szFromValueName);
            m_Item.second = GetValue(&*m_XMLIt, XMLDef::x_szToValueName);
            m_bException  = false;

            if(m_Item.first.Length() == 0 || m_Item.second.Length() == 0)
            {
                AppNotifyQalInvalidMappingFileError(m_FilesIt->c_str());
                continue;
            }
        }
        else if(m_XMLIt->m_tag == XMLDef::x_szExceptionNode )
        {
            m_Item.first  = GetValue(&*m_XMLIt);
            m_Item.second = xwcs_t();
            m_bException  = true;

            if(m_Item.first.Length() == 0 )
            {
                AppNotifyQalInvalidMappingFileError(m_FilesIt->c_str());
                continue;
            }
        }
        else
        {
            continue;
        }

        return;
    }
}

template< typename XMLDef>
void CQueueMapIteratorBase<XMLDef>::AdvanceFile()
{
    while( isValid() )
    {
        if( !m_bInitialized )
        {
            m_bInitialized = true;
        }
        else
        {
            if(!(++m_FilesIt).isValid())
                return;
        }

        try
        {
            CAutoXmlNode   pTree;
            AP<WCHAR>	   pDoc;
            DWORD          DocSize, DataStartOffet;
            const XmlNode* pNode = NULL;

            pDoc  = LoadFile(m_FilesIt->c_str(), &DocSize, &DataStartOffet);

            XmlParseDocument(xwcs_t(pDoc + DataStartOffet, DocSize - DataStartOffet),&pTree);//lint !e534

            pNode = XmlFindNode(pTree, XMLDef::x_szRootNode);

            //
            // if we could not find "root" node - move to next file
            //
            if( NULL == pNode)
            {
                //TrERROR(GENERAL, "Could not find '%ls' node in file '%ls'", xMappingNodeTag, m_FilesIt->c_str());
                //AppNotifyQalInvalidMappingFileError(m_FilesIt->c_str());
                continue;
            }

            //
            // if the namespace is wrong -  move to next file
            //
            if(pNode->m_namespace.m_uri != XMLDef::x_szNameSpace)
            {
                //TrERROR(GENERAL, "Node '%ls' is not in namespace '%ls' in file '%ls'", xMappingNodeTag, xMappingNameSpace, m_FilesIt->c_str());
                AppNotifyQalInvalidMappingFileError(m_FilesIt->c_str());
                continue;
            }

            CXMLIterator temp (&pNode->m_nodes,pDoc,pTree);
            m_XMLIt.swap(temp);
            return;

        }
        catch(const bad_document& )
        {
            //TrERROR(GENERAL, "Mapping file %ls is ignored. Failed to parse file at location=%ls", m_FilesIt->c_str(), errdoc.Location());
            AppNotifyQalInvalidMappingFileError(m_FilesIt->c_str());
        }
        catch(const bad_win32_error& err)
        {
            //TrERROR(GENERAL, "Mapping file %ls is ignored. Failed to read file content, Error %d", m_FilesIt->c_str(), err.error());
            AppNotifyQalWin32FileError(m_FilesIt->c_str(), err.error());
        }
        catch(const exception&)
        {
            //TrERROR(GENERAL, "Mapping file %ls is ignored. Unknown error", m_FilesIt->c_str());
        }
    }
}

struct CInboundMapXMLDef
{
    static LPCWSTR x_szNameSpace;
    static LPCWSTR x_szRootNode;
    static LPCWSTR x_szMapNode;
    static LPCWSTR x_szExceptionsNode;
    static LPCWSTR x_szFromValueName;
    static LPCWSTR x_szToValueName;
    static LPCWSTR x_szExceptionNode;
};

struct CInboundOldMapXMLDef
{
    static LPCWSTR x_szNameSpace;
    static LPCWSTR x_szRootNode;
    static LPCWSTR x_szMapNode;
    static LPCWSTR x_szExceptionsNode;
    static LPCWSTR x_szFromValueName;
    static LPCWSTR x_szToValueName;
    static LPCWSTR x_szExceptionNode;
};

struct COutboundMapXMLDef
{
    static LPCWSTR x_szNameSpace;
    static LPCWSTR x_szRootNode;
    static LPCWSTR x_szMapNode;
    static LPCWSTR x_szExceptionsNode;
    static LPCWSTR x_szFromValueName;
    static LPCWSTR x_szToValueName;
    static LPCWSTR x_szExceptionNode;
};

struct CStreamReceiptXMLDef
{
    static LPCWSTR x_szNameSpace;
    static LPCWSTR x_szRootNode;
    static LPCWSTR x_szMapNode;
    static LPCWSTR x_szExceptionsNode;
    static LPCWSTR x_szFromValueName;
    static LPCWSTR x_szToValueName;
    static LPCWSTR x_szExceptionNode;
};

typedef CQueueMapIteratorBase<CInboundMapXMLDef>    CInboundMapIterator;
typedef CQueueMapIteratorBase<CInboundOldMapXMLDef> CInboundOldMapIterator;
typedef CQueueMapIteratorBase<COutboundMapXMLDef>   COutboundMapIterator;
typedef CQueueMapIteratorBase<CStreamReceiptXMLDef> CStreamReceiptMapIterator;

#endif // _MSMQ_qalpxml_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\qal\test\qaltest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    RexTest.cpp

Abstract:
    Regular Expression based Queues Alias library test

Author:
    Vlad Dovlekaev (vladisld) 27-Dec-01

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <stdio.h>
#include <tr.h>
#include <xml.h>
#include <Qal.h>

#pragma warning(disable:4100)
#include "..\..\qal\lib\qalpxml.h"
#include "..\..\qal\lib\qalpcfg.h"

#include "qaltest.tmh"

static bool TestInit();
static void Usage();
static int RunTest();
static int PrintAll(CQueueAlias&);

int count = 1;

extern "C"
int
__cdecl
_tmain(
    int argc,
    LPCTSTR* argv
    )
/*++

Routine Description:
    Test Queues Alias library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

    if(argc == 2  && (wcscmp(argv[1],L"/?") ==0 || wcscmp(argv[1],L"\?") ==0)  )
    {
        Usage();
        return 1;
    }

    if(argc == 3  && wcscmp(argv[1],L"/c") == 0 )
    {
        count = _wtol(argv[2]);
    }

    if(!TestInit())
    {
        TrTRACE(GENERAL, "Could not initialize test");
        return 1;
    }

    int ret=RunTest();

    WPP_CLEANUP();
    return ret;
}

static void Usage()
{
    wprintf(L"qaltest [/c count] \n");
    wprintf(L"-l : run forever (leak test) \n");
}

static
bool
TestInit()
{
    TrInitialize();
    XmlInitialize();
    return true;
}

static
int
RunTest()
{
    try
    {
        LPCWSTR pDir = CQueueAliasStorageCfg::GetQueueAliasDirectory();
        CQueueAlias queueAliasEx(pDir);

        printf("Running Test %d times from directory: %S\n", count, pDir );
        printf("start 1");
        TrTRACE(GENERAL, "Start QueueAlias");
        DWORD dwTickCount = GetTickCount();
        for(DWORD  i = 0; i < (DWORD)count; ++i )
        {
            if( PrintAll(queueAliasEx))
                return 1;
        }
        printf(" - %d\n", GetTickCount() - dwTickCount);
        TrTRACE(GENERAL, "QueueAlias print took: %d ticks", GetTickCount() - dwTickCount);
    }
    catch(const exception&)
    {
        TrTRACE(GENERAL, "Got c++ exception");
    }
    TrTRACE(GENERAL, "Test ok");
    return 0;
}

static int PrintAll(CQueueAlias& QueueAlias)
{
    //TrTRACE(GENERAL,"Printing all aliases with REX");
    AP<WCHAR> TestWrongQueue;
    AP<WCHAR> DefaultStreamReceiptURL;
    int       iRet = 0;

    bool fSuccess=QueueAlias.GetInboundQueue(L"http://www.company.com/a55", &TestWrongQueue);
    if( fSuccess )
    {
        printf("\nWrong Alias->Queue:%S-%S\n", L"http://www.company.com/a55", (LPWSTR)TestWrongQueue);
        iRet = 1;
    }
    else
        printf("\nWrong Alias->Queue:%S-(no match)\n", L"http://www.company.com/a55");
    ASSERT(!fSuccess);

    fSuccess = QueueAlias.GetDefaultStreamReceiptURL(&DefaultStreamReceiptURL);
    if( fSuccess )
        printf("Default StreamReceiptURL:%S\n", (LPWSTR)DefaultStreamReceiptURL);
    else
    {
        printf("Default StreamReceiptURL: (null)\n");
        iRet = 1;
    }
    ASSERT(fSuccess);

    for(CInboundOldMapIterator it(L"\\msmq\\src\\lib\\qal\\test\\"); it.isValid(); ++it)
    {
        std::wstring  sAlias(it->first.Buffer(), it->first.Length());
        std::wstring  sQueue(it->second.Buffer(), it->second.Length());
        AP<WCHAR> TestQueue;

        //
        // Check for the '*' at the end
        //
        printf("Testing: %S -> %S\n", sAlias.c_str(), sQueue.c_str() );
        if( *sAlias.rbegin() == L'*' )
        {
            *sAlias.rbegin() = L'5';
        }

        fSuccess=QueueAlias.GetInboundQueue( sAlias.c_str(), &TestQueue);
        if( fSuccess )
            printf("Alias->Queue:%S-%S\n", sAlias.c_str(), (LPWSTR)TestQueue);
        else
        {
            printf("Alias->Queue:%S-(no match)\n", sAlias.c_str());
            iRet = 1;
        }

        ASSERT(fSuccess);
        ASSERT(wcscmp(TestQueue, sQueue.c_str()) == 0);
//        TrTRACE(GENERAL, "'%ls' = '%ls'", (LPWSTR)pQueue, (LPWSTR)pAlias);
    }

    for(CStreamReceiptMapIterator it(L"\\msmq\\src\\lib\\qal\\test1\\"); it.isValid(); ++it)
    {
        std::wstring  sAlias(it->first.Buffer(), it->first.Length());
        std::wstring  sQueue(it->second.Buffer(), it->second.Length());
        AP<WCHAR> TestURL;

        //
        // Check for the '*' at the end
        //
        printf("Testing: %S -> %S\n", sAlias.c_str(), sQueue.c_str() );
        if( *sAlias.rbegin() == L'*' )
        {
            *sAlias.rbegin() = L'5';
        }

        fSuccess=QueueAlias.GetStreamReceiptURL( sAlias.c_str(), &TestURL);
        if( fSuccess )
            printf("LogAddress->StreamReceiptQueue:%S-%S\n", sAlias.c_str(), (LPWSTR)TestURL);
        else
        {
            printf("LogAddress->StreamReceiptQueue:%S-(no match)\n", sAlias.c_str());
            iRet = 1;
        }

        ASSERT(fSuccess);
        if( wcscmp(TestURL, sQueue.c_str()) )
        {
            printf("TestURL (%s) is not equal to result (%s)\n", TestURL, sQueue.c_str());
            iRet = 1;
        }
//        TrTRACE(GENERAL, "'%ls' = '%ls'", (LPWSTR)pQueue, (LPWSTR)pAlias);
    }

    return iRet;
}

//
// Error reporting function that needs to implement by qal.lib user
//
void AppNotifyQalDuplicateMappingError(LPCWSTR, LPCWSTR) throw()
{

}

void AppNotifyQalInvalidMappingFileError(LPCWSTR ) throw()
{

}

void AppNotifyQalXmlParserError(LPCWSTR )throw()
{

}


void AppNotifyQalWin32FileError(LPCWSTR , DWORD )throw()
{

}


bool AppNotifyQalMappingFound(LPCWSTR, LPCWSTR)throw()
{
    return true;
}


void GetDnsNameOfLocalMachine(WCHAR ** ppwcsDnsName)
{
    const WCHAR xLoclMachineDnsName[] = L"www.foo.com";
    *ppwcsDnsName = newwcs(xLoclMachineDnsName);
}

static GUID s_machineId = {1234, 12, 12, 1, 1, 1, 1, 1, 1, 1, 1};
const GUID&
McGetMachineID(
    void
    )
{
    return s_machineId;
}

PSID
AppGetCertSid(
	const BYTE*  /* pCertBlob */,
	ULONG        /* ulCertSize */,
	bool		 /* fDefaultProvider */,
	LPCWSTR      /* pwszProvName */,
	DWORD        /* dwProvType */
	)
{
	return NULL;
}

void ReportAndThrow(LPCSTR)
{
	ASSERT(0);
}

void AppNotifyQalDirectoryMonitoringWin32Error(LPCWSTR , DWORD )throw()
{

}

bool AppIsDestinationAccepted(const QUEUE_FORMAT* , bool )
{
    return true;
}


LPCWSTR
McComputerName(
	void
	)
{
	return NULL;
}

DWORD
McComputerNameLen(
	void
	)
{
	return 0;
}

void
CrackUrl(
    LPCWSTR,
    xwcs_t&,
    xwcs_t&,
    USHORT*,
	bool*
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\lib\rd.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    Rd.cpp

Abstract:
    Routing Decision Interface

Author:
    Uri Habusha (urih) 10-Apr-2000

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Rd.h"
#include "Rdp.h"
#include "RdDs.h"
#include "RdDesc.h"

#include "rd.tmh"

static CRoutingDecision* s_pRouteDecision;


VOID
RdRefresh(
    VOID
    )
{
    RdpAssertValid();

    s_pRouteDecision->Refresh();
}


VOID
RdGetRoutingTable(
    const GUID& DstMachineId,
    CRouteTable& RoutingTable
    )
{
    RdpAssertValid();

    s_pRouteDecision->GetRouteTable(DstMachineId, RoutingTable);

    //
    // Cleanup 
    //
    CRouteTable::RoutingInfo* pFirstPriority = RoutingTable.GetNextHopFirstPriority();
    CRouteTable::RoutingInfo* pSecondPriority = RoutingTable.GetNextHopSecondPriority();

    for(CRouteTable::RoutingInfo::const_iterator it = pFirstPriority->begin(); it != pFirstPriority->end(); ++it)
    {
        CRouteTable::RoutingInfo::iterator it2 = pSecondPriority->find(*it);
        if (it2 != pSecondPriority->end())
        {
            pSecondPriority->erase(it2);
        }
    }
}


void
RdGetConnector(
    const GUID& foreignId,
    GUID& connectorId
    )
{
    RdpAssertValid();

    return s_pRouteDecision->GetConnector(foreignId, connectorId);
}


void 
RdpInitRouteDecision (
    bool fRoutingServer,
    CTimeDuration rebuildInterval
    )
{
    ASSERT(s_pRouteDecision == NULL);

    if (fRoutingServer)
    {
        s_pRouteDecision = new CServerDecision(rebuildInterval);
        return;
    }

    s_pRouteDecision = new CClientDecision(rebuildInterval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\lib\rdad.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
  rdad.h

Abstract:
    Interface routine to AD

Author:
    Uri Habusha (urih), 10-Apr-2000

--*/

#pragma once

#ifndef __RDAD_H__
#define __RDAD_H__

void
RdpGetMachineData(
    const GUID& id, 
    CACLSID& siteIds,
    CACLSID& outFrss,
    CACLSID& inFrss,
    LPWSTR* pName,
    bool* pfFrs,
    bool* pfForeign
    );


void
RdpGetSiteData(
    const GUID& id, 
    bool* pfForeign,
    LPWSTR* pName
    );


void 
RdpGetSiteLinks(
    SITELINKS& siteLinks
    );


void 
RdpGetSites(
    SITESINFO& sites
    );


void
RdpGetSiteFrs(
    const GUID& siteId,
    GUID2MACHINE& listOfFrs
    );


void
RdpGetConnectors(
    const GUID& site,
    CACLSID& connectorIds
    );


//
// BUGBUG: Temporary, until we get Mc into the build. urih 30-Apr-2000
//
const GUID&
McGetMachineID(
    void
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\lib\rdad.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    RdAd.cpp

Abstract:
    Retreive information from AD

Author:
    Uri Habusha (urih), 10-Apr-2000

--*/

#include <libpch.h>
#include <mqexception.h>
#include "rd.h"
#include "rdp.h"
#include "rdds.h"
#include "rdad.h"
#include "mqtypes.h"
#include "ad.h"
#include "mqprops.h"

#include "rdad.tmh"

static 
void
CleanVars(
    DWORD num,
    MQPROPVARIANT * pVar
    )
/*++

  Routine Description:
    The routine cleans up allocated values in variants

  Arguments:
    num - number of variants to clena
    pVar - pointer to vars

  Returned Value:
    none 
    

 --*/
{
    for (DWORD i = 0; i < num; i++, pVar++)
    {
        switch (pVar->vt)
        {
            case VT_CLSID:
                delete pVar->puuid;
				pVar->vt = VT_NULL;
                break;

            case VT_LPWSTR:
                delete []pVar->pwszVal;
				pVar->vt = VT_NULL;
                break;
            
			case (VT_VECTOR | VT_CLSID):
                delete[] pVar->cauuid.pElems;
				pVar->vt = VT_NULL;
                break;
            
			default:
                break;
        }
    }
}


void
RdpGetMachineData(
    const GUID& id, 
    CACLSID& siteIds,
    CACLSID& outFrss,
    CACLSID& inFrss,
    LPWSTR* pName,
    bool* pfFrs,
    bool* pfForeign
    )
/*++

  Routine Description:
    The routine retrieves the requested machine values from AD

  Arguments:

  Returned Value:
    none 
    
 --*/
{
    PROPID prop[] = {
			PROPID_QM_SITE_IDS,
			PROPID_QM_OUTFRS,
			PROPID_QM_INFRS,
			PROPID_QM_PATHNAME,
			PROPID_QM_SERVICE_ROUTING,
			PROPID_QM_FOREIGN,
			};
		             
    MQPROPVARIANT var[TABLE_SIZE(prop)];

	for(DWORD i = 0; i < TABLE_SIZE(prop); ++i)
	{
		var[i].vt = VT_NULL;
	}

    HRESULT hr;
    hr = ADGetObjectPropertiesGuid(
                eMACHINE,
                NULL,   // pwcsDomainController,
				false,	// fServerName
                &id,
                TABLE_SIZE(prop),
                prop,
                var
                );

    if (FAILED(hr))
    {
        CleanVars(
            TABLE_SIZE(prop),
            var
            );
        TrERROR(ROUTING, "Failed to retrive machine properties %!guid!, Error: %x", &id, hr);
        throw bad_ds_result(hr);
    }
    //
    //  Fill in the results
    //
    ASSERT(prop[0] == PROPID_QM_SITE_IDS);
    siteIds = var[0].cauuid;

    ASSERT(prop[1] == PROPID_QM_OUTFRS);
    outFrss = var[1].cauuid;
    
	ASSERT(prop[2] == PROPID_QM_INFRS);
    inFrss = var[2].cauuid;
    
	ASSERT(prop[3] == PROPID_QM_PATHNAME);
    *pName = var[3].pwszVal;
    
	ASSERT(prop[4] ==  PROPID_QM_SERVICE_ROUTING);
    *pfFrs = (var[4].bVal > 0) ? true : false;
    
	ASSERT(prop[5] == PROPID_QM_FOREIGN);
    *pfForeign = (var[5].bVal > 0) ? true : false;
}


void
RdpGetSiteData(
    const GUID& id, 
    bool* pfForeign,
    LPWSTR* pName
    )
/*++

  Routine Description:
    The routine retrieves the requested site values from AD

  Arguments:

  Returned Value:
    none 
    
 --*/
{
    PROPID prop[] = {
                PROPID_S_FOREIGN,
                PROPID_S_PATHNAME
                };

    MQPROPVARIANT var[TABLE_SIZE(prop)];

	for(DWORD i = 0; i < TABLE_SIZE(prop); ++i)
	{
		var[i].vt = VT_NULL;
	}

    HRESULT hr;
    hr = ADGetObjectPropertiesGuid(
                eSITE,
                NULL,   // pwcsDomainController,
				false,	// fServerName
                &id,
                TABLE_SIZE(prop),
                prop,
                var
                );
    if (FAILED(hr))
    {
        CleanVars(
            TABLE_SIZE(prop),
            var
            );
        TrERROR(ROUTING, "Failed to retrive site properties %!guid!, Error: %x", &id, hr);
        throw bad_ds_result(hr);
    }
    //
    //  Fill in the results
    //
    ASSERT(prop[0] == PROPID_S_FOREIGN);
    *pfForeign = (var[0].bVal > 0) ? true : false;

    ASSERT(prop[1] == PROPID_S_PATHNAME);
    *pName = var[1].pwszVal;
}


void 
RdpGetSiteLinks(
    SITELINKS& siteLinks
    )
/*++

  Routine Description:
    The routine query all routing links from AD

  Arguments:

  Returned Value:
    none 
    
 --*/
{
    //
    //  Query for all sites link
    //
    PROPID prop[] ={ 
			PROPID_L_GATES,
		    PROPID_L_NEIGHBOR1,
			PROPID_L_NEIGHBOR2,
			PROPID_L_COST
			};
	
    MQCOLUMNSET columns;
    columns.cCol =  TABLE_SIZE(prop);
    columns.aCol =  prop;

    HRESULT hr;
    HANDLE h;
    hr = ADQueryAllLinks(
                NULL,       //  pwcsDomainController,
				false,		// fServerName
                &columns,
                &h
                );
    if (FAILED(hr))
    {
        TrERROR(ROUTING, "Failed to query all site link Error: %x", hr);
        throw bad_ds_result(hr);
    }

    CADQueryHandle hQuery(h);
    MQPROPVARIANT var[TABLE_SIZE(prop)];

	for(DWORD i = 0; i < TABLE_SIZE(prop); ++i)
	{
		var[i].vt = VT_NULL;
	}

    DWORD num = TABLE_SIZE(prop);

	try
	{
		while(SUCCEEDED(hr = ADQueryResults( hQuery, &num, var)))
		{
			if ( num == 0)
			{
				//
				// no more results
				//
				break;
			}

			R<const CSiteLink> pSiteLink = new CSiteLink(
										var[0].cauuid,
										var[1].puuid,
										var[2].puuid,
										var[3].ulVal
										);

			siteLinks.push_back(pSiteLink);  
            
			for ( DWORD i = 0; i < TABLE_SIZE(prop); i++)
            {
                var[i].vt = VT_NULL;
            }
		}

		if (FAILED(hr))
		{
            TrERROR(ROUTING, "Failed to query next site link properties Error: %x", hr);
			throw bad_ds_result(hr);
		}

	}
	catch( const exception&)
	{
		siteLinks.erase(siteLinks.begin(), siteLinks.end());
        CleanVars(
            TABLE_SIZE(prop),
            var
            );
		throw; 
	}
}


void 
RdpGetSites(
    SITESINFO& sites
    )
{
    //
    // query all sites
    //
    PROPID prop[] = {PROPID_S_SITEID}; 
    MQCOLUMNSET columns;
    columns.cCol =  TABLE_SIZE(prop);
    columns.aCol =  prop;

    HRESULT hr;
    HANDLE h;
    hr =  ADQueryAllSites(
                NULL,       //pwcsDomainController
				false,		// fServerName
                &columns,
                &h
                );
    if (FAILED(hr))
    {
        TrERROR(ROUTING, "Failed to query all sites Error: %x", hr);
        throw bad_ds_result(hr);
    }

    CADQueryHandle hQuery(h);
    MQPROPVARIANT var[TABLE_SIZE(prop)] = {{VT_NULL,0,0,0,0}};
    DWORD num = TABLE_SIZE(prop);

    try
    {
        while(SUCCEEDED(hr = ADQueryResults( hQuery, &num, var)))
        {
            if ( num == 0)
            {
                break;
            }

			P<GUID> pClean = var[0].puuid;
            CSite * pSite = new CSite(*var[0].puuid);

            sites[&pSite->GetId()] = pSite;
            for ( DWORD i = 0; i < TABLE_SIZE(prop); i++)
            {
                var[i].vt = VT_NULL;
            }
        }

		if (FAILED(hr))
		{
            TrERROR(ROUTING, "Failed to query next site properites. Error: %x", hr);
			throw bad_ds_result(hr);
		}
    }
	catch( const exception&)
	{    
		for (SITESINFO::iterator it = sites.begin(); it != sites.end(); )
		{
			delete it->second;
			it = sites.erase(it);
		}
		throw; 
	}
}


void
RdpGetSiteFrs(
    const GUID& siteId,
    GUID2MACHINE& listOfFrs
    )
{

    //
    //  Query for all sites link
    //
    PROPID prop[] ={ PROPID_QM_MACHINE_ID,PROPID_QM_SITE_IDS,PROPID_QM_OUTFRS,
                     PROPID_QM_INFRS,PROPID_QM_PATHNAME,PROPID_QM_SERVICE_ROUTING,
                     PROPID_QM_FOREIGN}; 
    MQCOLUMNSET columns;
    columns.cCol =  TABLE_SIZE(prop);
    columns.aCol =  prop;

    HRESULT hr;
    HANDLE h;
    hr = ADQuerySiteServers(
                NULL,       //  pwcsDomainController,
				false,		// fServerName
                &siteId,
                eRouter,
                &columns,
                &h
                );
    if (FAILED(hr))
    {
        TrERROR(ROUTING, "Failed to query all site servers for site %!guid!. Error: %x", &siteId, hr);
        throw bad_ds_result(hr);
    }
    CADQueryHandle hQuery(h);
    MQPROPVARIANT var[TABLE_SIZE(prop)];

	for(DWORD i = 0; i < TABLE_SIZE(prop); ++i)
	{
		var[i].vt = VT_NULL;
	}

    DWORD num = TABLE_SIZE(prop);

    try
    {
        while(SUCCEEDED(hr = ADQueryResults( hQuery, &num, var)))
        {
            if ( num == 0)
            {
                //
                // no more results
                //
                break;
            }
            
			R<CMachine> pMachine = new CMachine(
                    *var[0].puuid,  // qm-id
                    var[1].cauuid,  // site ids
                    var[2].cauuid,  // out rs
                    var[3].cauuid,  // in rs
                    var[4].pwszVal, // pathname
                    (var[5].bVal > 0) ? true : false, // routing server
                    (var[6].bVal > 0) ? true : false  // foreign
                    );

            listOfFrs[&pMachine->GetId()] = pMachine;
            
			for ( DWORD i = 0; i < TABLE_SIZE(prop); i++)
            {
                var[i].vt = VT_NULL;
            }
			delete var[0].puuid;
        }

		if (FAILED(hr))
		{
            TrERROR(ROUTING, "Failed to query next site server properties for site %!guid!. Error: %x", &siteId, hr);
			throw bad_ds_result(hr);
		}
    }
	catch(const exception&)
	{   
		listOfFrs.erase(listOfFrs.begin(), listOfFrs.end());
        CleanVars(
            TABLE_SIZE(prop),
            var
            );
		throw; 
	}
}


void
RdpGetConnectors(
    const GUID& site,
    CACLSID& connectorIds
    )
{
    connectorIds.cElems = 0;
    connectorIds.pElems = NULL;
    //
    // query all connecoter of the specified class
    //
    PROPID prop[] = {PROPID_QM_MACHINE_ID}; 
    MQCOLUMNSET columns;
    columns.cCol =  TABLE_SIZE(prop);
    columns.aCol =  prop;

    HRESULT hr;
    HANDLE h;

    hr =  ADQueryConnectors(
                NULL,       //pwcsDomainController
				false,		// fServerName
                &site,
                &columns,
                &h
                );
    if (FAILED(hr))
    {
        TrERROR(ROUTING, "Failed to query all connectors to foreign site %!guid!. Error: %x", &site, hr);
        throw bad_ds_result(hr);
    }

    CADQueryHandle hQuery(h);
    MQPROPVARIANT var[TABLE_SIZE(prop)] ={{VT_NULL,0,0,0,0}};
    DWORD num = TABLE_SIZE(prop);

    const x_numAllocate = 10;
    DWORD numAllocated = x_numAllocate;
    AP<GUID> pResults = new GUID[x_numAllocate];
    DWORD next = 0;

    while(SUCCEEDED(hr = ADQueryResults( hQuery, &num, var)))
    {
        if ( num == 0)
        {
            break;
        }

        P<GUID> pClean = var[0].puuid;
        
		//
        //  add one more result
        //
        if ( next == numAllocated)
        {
            //
            //  allocate more
            //
            AP<GUID> pTemp = pResults.detach();
            DWORD numPrevAllocated = numAllocated;
            numAllocated = numAllocated + x_numAllocate;
            *&pResults = new GUID[ numAllocated];
            memcpy(pResults, pTemp, numPrevAllocated * sizeof(GUID));

        }
        
		pResults[next] = *var[0].puuid;
        next++;
        for ( DWORD i = 0; i < TABLE_SIZE(prop); i++)
        {
            var[i].vt = VT_NULL;
        }

    }
    if (FAILED(hr))
    {
        TrERROR(ROUTING, "Failed to query next connector to foreign site %!guid!. Error: %x", &site, hr);
        throw bad_ds_result(hr);
    }

    connectorIds.pElems = pResults.detach();
    connectorIds.cElems = next;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\lib\rddebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    RdDebug.cpp

Abstract:
    Configuration Manager debugging

Author:
    Uri Habusha (urih) 10-Apr-2000

Environment:
    Platform-independent, _DEBUG only

--*/

#include "libpch.h"
#include "Rd.h"
#include "Rdp.h"

#include "rddebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Configuration Manager state
//
void RdpAssertValid(void)
{
    //
    // RdInitalize() has *not* been called. You should initialize the
    // Configuration Manager library before using any of its funcionality.
    //
    ASSERT(RdpIsInitialized());
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void RdpSetInitialized(void)
{
    LONG fRdAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Configuration Manager library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fRdAlreadyInitialized);
}


BOOL RdpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
/*
const DebugEntry xDebugTable[] = {

    {
        "RdDumpState(queue path name)",
        "Dump Configuration Manager State to debugger",
        DumpState
    ),

    //
    // TODO: Add Configuration Manager debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void RdpRegisterComponent(void)
{
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\lib\rdclient.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:
    rdClient.cpp

Abstract:
    Implementation of Independent client Routing Decision.

Author:
    Uri Habusha (urih), 11-Apr-2000

--*/

#include "libpch.h"
#include "Rd.h"
#include "Rdp.h"          
#include "RdDs.h"
#include "RdDesc.h"
#include "RdAd.h"

#include "rdclient.tmh"

void
CClientDecision::Refresh(
    void
    )
/*++

  Routine Description:
    Refreshes the routine decision internal data structure.

    The routine frees the previous data, and access the DS to get updated data.
    The routine retreives information for the local machine. If data retreival
    succeedes the routine updates the build time.

    If updating the internal data failed, the routine raise an exception.

  
  Arguments:
    None.
    
  Returned Value:
    None. An exception is raised if the operation fails

  Note:
    Brfore the routine refreshes the internal data it erases the previous data and
    sets the last build time varaible to 0. If an exception is raised during retrieving 
    the data from AD or building the internal DS, the routine doesn't update the 
    last build time. This gurantee that next time the Routing Decision is called 
    the previous Data structures will be cleaned-up and rebuilt.
 --*/
{
    CSW lock(m_cs);

    TrTRACE(ROUTING, "Refresh Routing Decision internal data");

    //
    // Cleanup previous information
    //
    CleanupInformation();

    //
    // Get local machine information
    //
    GetMyMachineInformation();

    //
    // check that In/Out FRSs realy belong to this machine sites
    //
    m_pMyMachine->RemoveInvalidInOutFrs(m_mySites);

    //
    // Update last refresh time
    //
    CRoutingDecision::Refresh();
}



void 
CClientDecision::RouteToFrs(
    const CSite& site,
    const CRouteTable::RoutingInfo* pPrevRouteList,
    CRouteTable::RoutingInfo* pRouteList
    )
{
    //
    // If the machine is independent client. Also route to Any FRS in 
    // the site this is the second priority
    //
    const GUID2MACHINE& SiteFrss = site.GetSiteFRS();
    for(GUID2MACHINE::const_iterator it = SiteFrss.begin(); it != SiteFrss.end(); ++it)
    {
        const CMachine* pRoute = it->second.get();

        //
        // If the destination is also RS we already route to it directly
        //
        if (RdpIsMachineAlreadyUsed(pPrevRouteList, pRoute->GetId()))
        {
            continue;
        }

        pRouteList->insert(SafeAddRef(pRoute));
    }
}


void
CClientDecision::RouteToInFrs(
    CRouteTable& RouteTable,
    const CMachine* pDest
    )
{
    TrTRACE(ROUTING, "The Destination: %ls has IN FRSs. route to one of them", pDest->GetName());

    //
    // The destination computer must have IN FRSs
    //
    ASSERT(pDest->HasInFRS());

    CRouteTable::RoutingInfo* pFirstPriority = RouteTable.GetNextHopFirstPriority();
    CRouteTable::RoutingInfo interSite;

    //
    // The destination machine has InFrs. Deliver the message to InFrs Machines
    // 
    const GUID* InFrsArray = pDest->GetAllInFRS();
    for (DWORD i = 0; i < pDest->GetNoOfInFRS(); ++i)
    {
        R<const CMachine> pRoute = GetMachineInfo(InFrsArray[i]);
        
        //
        // check that In-FRS is valid FRS in destiantion machine SITES
        //
        if (RdpIsCommonGuid(pDest->GetSiteIds(), pRoute->GetSiteIds()))
        {
            //
            // The next hop is one of the valid IN-FRS. 
            // 
            if (RdpIsCommonGuid(m_pMyMachine->GetSiteIds(),pRoute->GetSiteIds()))
            {
                //
                // In first priority try to forward the message to IN-FRS in my
                // site.
                //
                pFirstPriority->insert(pRoute);
            }
            else
            {
                //
                // In-FRS and my machine are not in same site. 
                //
                interSite.insert(pRoute);
            }
        }
    }

    if (pFirstPriority->empty())
    {
        for(CRouteTable::RoutingInfo::const_iterator it = interSite.begin(); it != interSite.end(); ++it)
        {
           pFirstPriority->insert(*it);
        }
    }
}


void 
CClientDecision::RouteToMySitesFrs(
    CRouteTable::RoutingInfo* pRouteList
    )
{
    TrTRACE(ROUTING, "The destination and my machine don't have a common site. Route to my sites RS");

    ASSERT(pRouteList->empty());

    //
    // The source and destination don't have common site. route to FRSs of the source sites
    //
    for(SITESINFO::iterator it = m_mySites.begin(); it != m_mySites.end(); ++it)
    {
        const CSite* pSite = it->second;
        RouteToFrs(*pSite, NULL, pRouteList);
    }
}


void
CClientDecision::Route(
    CRouteTable& RouteTable, 
    const CMachine* pDest
    )
{
    TrTRACE(ROUTING, "Building Routing table. Destination machine: %ls", pDest->GetName());

    if (pDest->HasInFRS())
    {
        RouteToInFrs(RouteTable, pDest);
    }

    CRouteTable::RoutingInfo* pFirstPriority = RouteTable.GetNextHopFirstPriority();
    CRouteTable::RoutingInfo* pNextPriority = RouteTable.GetNextHopSecondPriority();

    if (pFirstPriority->empty())
    {
        if (pDest->IsForeign())
        {
            TrTRACE(ROUTING, "Destination Machine: %ls is foreign machine. Don't route directly", pDest->GetName());
            
            pNextPriority = pFirstPriority;
        }
        else
        {
            TrTRACE(ROUTING, "Destination machine: %ls Doesn't have IN FRS in our common sites. try direct connection", pDest->GetName());

            //
            // The machine doesn't have InFRS. Use Direct route
            //
            pFirstPriority->insert(SafeAddRef(pDest));
        }
    }

    //
    // If the source and destination have a common site route to RS in the common site 
    // 
    const GUID* pCommonSiteId = m_pMyMachine->GetCommonSite(pDest->GetSiteIds(), false);
    if (pCommonSiteId == NULL)
    {
        //
        // The local machine and destination don't have a common site. Route
        // to my site FRS
        //
        RouteToMySitesFrs(pNextPriority);
        return;
    }

    //
    // There is a common site to local machine and destination. Route to FRS in
    // each common site
    //
    const CACLSID& destSites = pDest->GetSiteIds();
    const GUID* GuidArray = destSites.pElems;
	for (DWORD i=0; i < destSites.cElems; ++i)
	{
        //
        // look if a common site
        //
		if (RdpIsGuidContained(m_pMyMachine->GetSiteIds(), GuidArray[i]))
        {
            pCommonSiteId = &GuidArray[i];
            const CSite* pSite = m_mySites[pCommonSiteId];

            RouteToFrs(
                *pSite, 
                pFirstPriority,
                pNextPriority
                );
        }
    }
}


void
CClientDecision::RouteToOutFrs(
    CRouteTable::RoutingInfo* pRouteList
    )
/*++

  Routine Description:
    The routine route to out FRS of the local machine

  Arguments:
    pointer to routing table

  Returned value:
    None. The routine can raised exception

 --*/
{
    //
    // FRS can't have a list of out FRS
    //
    ASSERT(!m_pMyMachine->IsFRS());
    
    const GUID* pOutFrsId = m_pMyMachine->GetAllOutFRS();

    for(DWORD i = 0; i < m_pMyMachine->GetNoOfOutFRS(); ++i)
    {
        //
        // Get the machine name of the FRS machine identifier
        //
        pRouteList->insert(GetMachineInfo(pOutFrsId[i]));
    }
}


void 
CClientDecision::GetRouteTable(
    const GUID& DestMachineId,
    CRouteTable& RouteTable
    )
/*++

  Routine Description:
    The routine calculates and returnes the routing table for destination Machine.

  Arguments:
    DestMachineId - identefier of the destination machine
    RouteTable - refernce to the routing tabel

  Returned Value:
    None. An exception is raised if the operation fails

 --*/
{
    if (NeedRebuild())
        Refresh();

    CSR lock(m_cs);

    //
    // The internal data was corrupted. Before the routine gets the CS, refresh called
    // again and failed to refresh the internal data.
    //
    if (NeedRebuild())
        throw exception();
    
    //
    // Local machine can't be foreign machine
    //
    ASSERT(!m_pMyMachine->IsForeign());

    if (m_pMyMachine->HasOutFRS())
    {
        //
        // The local machine has out FRS, route to the out FRS
        //
        TrTRACE(ROUTING, "Building Routing table. Route to OUT FRSs");

        RouteToOutFrs(RouteTable.GetNextHopFirstPriority());
        return; 
    }

    //
    // My machine is not configured with OutFRS. Get the target machine information
    //
    R<const CMachine> destMachine = GetMachineInfo(DestMachineId);

    //
    // The destination machine can't be the local machine
    //
    ASSERT(destMachine->GetId() != m_pMyMachine->GetId());

    //
    // Independent client, is agnostic to inter/intra site routing.
    // First connect directly to the destination and second to local site FRS
    //
    Route(RouteTable, destMachine.get());
}


bool
CClientDecision::IsFrsInMySites(
    const GUID& id
    )
{
    for(SITESINFO::iterator it = m_mySites.begin(); it != m_mySites.end(); ++it)
    {
        const CSite* pSite = it->second;

        const GUID2MACHINE& SiteFrss = pSite->GetSiteFRS();
        for(GUID2MACHINE::const_iterator its = SiteFrss.begin(); its != SiteFrss.end(); ++its)
        {
            const CMachine* pRoute = its->second.get();
            if (pRoute->GetId() == id)
                return true;
        }
    }

    return false;
}


void
CClientDecision::GetConnector(
    const GUID& foreignMachineId,
    GUID& connectorId
    )
{
    if (NeedRebuild())
        Refresh();

    CSR lock(m_cs);

    //
    // The internal data was corrupted. Before the routine gets the CS, refresh called
    // again and failed to refresh the internal data.
    //
    if (NeedRebuild())
        throw exception();
    
    //
    // Local machine can't be foreign machine
    //
    ASSERT(!m_pMyMachine->IsForeign());

    //
    // Get the target foreign machine information
    //
    R<const CMachine> destMachine = GetMachineInfo(foreignMachineId);
    ASSERT(destMachine->IsForeign());
    ASSERT(destMachine->GetSiteIds().cElems != 0);

    //
    // My machine and the foreign site doesn't have a common site (Foreign machine
    // can have only foreign sites and IC can't have a foreign site).
    // look for a connector to the foreign machine in the enterprize
    //
	std::vector<GUID> ConnectorVector;
	std::vector<GUID> LessGoodConnectorVector;
	const CACLSID& foreignSiteIds = destMachine->GetSiteIds();
		
    for (DWORD i = 0; i < foreignSiteIds.cElems; ++i)
    {
        CACLSID connectorsIds;
        RdpGetConnectors(foreignSiteIds.pElems[i], connectorsIds);

        if (connectorsIds.cElems == 0)
            continue;

        AP<GUID> pIds = connectorsIds.pElems;

		for (DWORD j = 0; j < connectorsIds.cElems; ++j)
        {
            if (IsFrsInMySites(pIds[j]))
            {
				ConnectorVector.push_back(pIds[j]);
            }
        }

		LessGoodConnectorVector.push_back(pIds[0]);
    }

	if (ConnectorVector.size() != 0)
	{
		srand((unsigned) time(NULL));
		connectorId = ConnectorVector[rand()%ConnectorVector.size()];
		return;
	}

    if (LessGoodConnectorVector.size() != 0)
	{
		srand((unsigned) time(NULL));
		connectorId = LessGoodConnectorVector[rand()%LessGoodConnectorVector.size()];
		return;
	}

    TrERROR(ROUTING, "Cannot find a connector to foreign mahcine %!guid!", &foreignMachineId);
    throw bad_route();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\lib\rddesc.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:
    rddecs.cpp

Abstract:
    Implementation of Routing Decision.

Author:
    Uri Habusha (urih), 11-Apr-2000

--*/

#include "libpch.h"
#include "Rd.h"
#include "Cm.h"
#include "Rdp.h"          
#include "RdDs.h"
#include "RdDesc.h"
#include "RdAd.h"

#include "rddesc.tmh"

using namespace std;

bool CRoutingDecision::NeedRebuild(void) const
{
    return ((ExGetCurrentTime() - m_lastBuiltAt) >= m_rebuildInterval);
}


void 
CRoutingDecision::CleanupInformation(
    void
    )
/*++

  Routine Description:
    cleans up the internal data structure.

  Arguments:
    None.

  Returned Value:
    None. 

 --*/
{
    m_cachedMachines.erase(m_cachedMachines.begin(), m_cachedMachines.end());

    for (SITESINFO::iterator it1 = m_mySites.begin(); it1 != m_mySites.end();)
    {
        delete it1->second;
        it1 = m_mySites.erase(it1);
    }

    UpdateBuildTime(0);
}


void
CRoutingDecision::GetMyMachineInformation(
    void
    )
/*++

  Routine Description:
    Featch machine information from AD. If the Machine has out FRS, this is the 
    only possible routing and no more information is required. Otherwise, featch
    the site information.

  Arguments:
    None.

  Returned Value:
    None. An exception is raised if the operation fails

 --*/
{
    //
    // Get Machine information. Machine name, machine ID, Machine In/Out FRSs
    //
    m_pMyMachine->Update(McGetMachineID());

    //
    // Although the machine has out FRS, MSMQ needs to featch the site information, in
    // order to check that the OUT FRSs are valid (belong to machine sites)
    //

    //
    // Get my sites and the site gates
    //
    const CACLSID& SiteIds = m_pMyMachine->GetSiteIds();
    for (DWORD i = 0 ; i < SiteIds.cElems; ++i)
    {
        CSite* pSiteInfo = new CSite(SiteIds.pElems[i]);
        m_mySites[&pSiteInfo->GetId()] = pSiteInfo;
    }
}


R<const CMachine>
CRoutingDecision::GetMachineInfo(
    const GUID& id
    )
/*++

  Routine Description:
    The routine returns machine information for specific machine id. The routine 
    first looks if the information for the required machine already featched from
    the AD. The infomation can be cached either in the FRS machines list or in the 
    chached Data-Structure. If the data wasn't found the routine featch the data
    from AD and stores it in internal cache before returning the data. 

  Arguments:
    id - machine identification

  Returned Value:
    pointer to CMachine for the required machine. 
    
  Note:
    An exception is raised if the operation fails

 --*/
{
    //
    // Look for the machine in Local cache
    //
    {
        CSR lock(m_csCache);

        GUID2MACHINE::iterator it = m_cachedMachines.find(&id);
        if (it != m_cachedMachines.end())
            return it->second;
    }


    //
    // Look for the machine in Site FRS. This information is retreive in any case
    // so look first on it
    //
    for (SITESINFO::iterator its = m_mySites.begin(); its != m_mySites.end(); ++its)
    {
        const CSite* pSite = its->second;

        const GUID2MACHINE& MySiteFrsMachines = pSite->GetSiteFRS();

        GUID2MACHINE::const_iterator it = MySiteFrsMachines.find(&id);
        if (it != MySiteFrsMachines.end())
            return it->second;
    }

    R<CMachine> pRoute = new CMachine();
    pRoute->Update(id);

    {
        CSW loc(m_csCache);
        TrTRACE(ROUTING, "Add Machine %ls to the Routing Decision cache", pRoute->GetName());
    
        pair<GUID2MACHINE::iterator, bool> p;
        p = m_cachedMachines.insert(GUID2MACHINE::value_type(&pRoute->GetId(), pRoute));

        if (!p.second)
        {
            //
            // The machine already added between the checking and the insertion
            //
            return p.first->second;
        }
    }

    return pRoute;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\lib\rddesc.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
  rddecs.h

Abstract:
    Definition of Routing Decision class.

Author:
    Uri Habusha (urih), 11-Apr-2000

--*/

#pragma once

#ifndef __ROUTDECS_H__
#define __ROUTDECS_H__

#include "rwlock.h"
#include "Ex.h"

class CRoutingDecision
{
public:
    CRoutingDecision(
        CTimeDuration rebuildInterval
        ) :
        m_pMyMachine(new CMachine),
        m_rebuildInterval(rebuildInterval),
        m_lastBuiltAt(0)
    {
    }
    
    
    virtual ~CRoutingDecision()
    {
        CleanupInformation();
    }


    virtual void Refresh(void)
    {
        UpdateBuildTime(ExGetCurrentTime());
    }


    virtual
    void
    GetRouteTable(
        const GUID& DestMachineId,
        CRouteTable& RouteTable
        ) = 0;

    virtual
    void
    GetConnector(
        const GUID& foreignMachineId,
        GUID& connectorId
        ) = 0;

protected:
    void GetMyMachineInformation(void);
    R<const CMachine> GetMachineInfo(const GUID& MachineId);

    void CleanupInformation(void);
    bool NeedRebuild(void) const;


private:
    void UpdateBuildTime(CTimeInstant time)
    { 
        m_lastBuiltAt = time;
    }


protected:
    CReadWriteLock m_cs;

    R<CMachine> m_pMyMachine;
    SITESINFO m_mySites;

private:
    CTimeInstant m_lastBuiltAt;
    CTimeDuration m_rebuildInterval;

    CReadWriteLock m_csCache;
    GUID2MACHINE m_cachedMachines;
};


//---------------------------------------------------------
//
// class CClientDecision
//
//---------------------------------------------------------

class CClientDecision: public CRoutingDecision
{
public:
    CClientDecision(
        CTimeDuration rebuildInterval
        ) :
        CRoutingDecision(rebuildInterval)
    {
    }


    void
    GetRouteTable(
        const GUID& DestMachineId,
        CRouteTable& RouteTable
        );


    void
    GetConnector(
        const GUID& foreignMachineId,
        GUID& connectorId
        );

    
    void Refresh(void);

private:
    void 
    RouteToOutFrs(
        CRouteTable::RoutingInfo* pRouteList
        );

    void
    RouteToInFrs(
        CRouteTable& RouteTable,
        const CMachine* pDest
        );

    void 
    RouteToFrs(
        const CSite& site,
        const CRouteTable::RoutingInfo* pPrevRouteList,
        CRouteTable::RoutingInfo* pRouteList
        );

    void 
    RouteToMySitesFrs(
        CRouteTable::RoutingInfo* pRouteList
        );
    
    void
    Route(
        CRouteTable& RouteTable, 
        const CMachine* pDest
        );   

    bool
    IsFrsInMySites(
        const GUID& pId
        );


};


//---------------------------------------------------------
//
// class CServerDecision
//
//---------------------------------------------------------

class CServerDecision : public CRoutingDecision
{
public:
    CServerDecision(
        CTimeDuration rebuildInterval
        ) :
        CRoutingDecision(rebuildInterval)
    {
    }
    

    ~CServerDecision()
    {
        CleanupInformation();
    }

    
    void
    GetRouteTable(
        const GUID& DestMachineId,
        CRouteTable& RouteTable
        );


    void
    GetConnector(
        const GUID& foreignMachineId,
        GUID& connectorId
        );


    void Refresh(void);

private:
	void
    GetRouteTableInternal(
        const GUID& DestMachineId,
        CRouteTable& RouteTable
        );

    void
    RouteIntraSite(
        const CMachine* pDestMachine,
        CRouteTable& RouteTable
        );

    void
    RouteToInFrsIntraSite(
        const CMachine* pDest,
        CRouteTable::RoutingInfo* pRouteList
        );

    void
    RouteInterSite(
        const CMachine* pDestMachine,
        CRouteTable& RouteTable 
        );

    void
    RouteToInFrsInterSite(
        const CMachine* pDestMachine,
        CRouteTable& RouteTable
        );
    
    R<const CSiteLink>
    FindSiteLinkToDestSite(
        const CMachine* pDestMachineInfo,
        const GUID** ppNextSiteId,
        const GUID** ppDestSiteId,
        const GUID** ppNeighbourSiteId,
        bool* pfLinkGateAlongTheRoute
        );

    void
    RouteToLinkGate(
        const CACLSID& LinkGates,
        CRouteTable& RouteTable
        );

    void
    RouteToFrsInSite(
        const GUID* pSiteId,
        const CRouteTable::RoutingInfo* pPrevRouteList,
        CRouteTable::RoutingInfo* pRouteList
        );

    bool
    IsMyMachineLinkGate(
        const CACLSID& LinkGates
        );

    void UpdateSiteLinksInfo(void);
    void UpdateSitesInfo(void);
    void CalculateNextSiteHop(void);

    void CleanupInformation(void);

private:
    SITESINFO m_sitesInfo;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\lib\rdinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    RdInit.cpp

Abstract:
    Routing Decision initialization

Author:
    Uri Habusha (urih) 10-Apr-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Rd.h"
#include "Rdp.h"

#include "rdinit.tmh"

VOID
RdInitialize(
    bool fRoutingServer,
    CTimeDuration rebuildInterval
    )
/*++

Routine Description:
    Initializes Routing Decision library

Arguments:
    fRoutingServer - boolean flag. Indicates if local machine is Routing server or not
    rebuildInterval - Indicates how often to rebuild the internal data structure

Returned Value:
    None.

--*/
{
    //
    // Validate that the Routing Decision library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!RdpIsInitialized());
    RdpRegisterComponent();

    //
    // Create Route descision Object
    //
    RdpInitRouteDecision(fRoutingServer, rebuildInterval);


    RdpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\lib\rdnextsite.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
    routeds.cpp

Abstract:
    Implementation of MachineRouteInfo class.

Author:
    Uri Habusha (urih), 12- Apr-2000

--*/

#include <libpch.h>
#include <rd.h>
#include "rdp.h"
#include "rdds.h"
#include "rddesc.h"
#include "RdAd.h"

#include "rdnextsite.tmh"

using namespace std;

class CRoutingNode
{
public:
    CRoutingNode(
        const CSite* pDestSite, 
        const CSite* pNeighbourSite,
        const CSite* pReachViaSite,
        bool fLinkGateAlongTheRoute
        ):
        m_pDestSite(pDestSite),
        m_pNeighbourSite(pNeighbourSite),
        m_pReachViaSite(pReachViaSite),
        m_fLinkGateAlongTheRoute(fLinkGateAlongTheRoute)
    {
    };


    virtual ~CRoutingNode()
    {
    };

    
    const CSite* GetDestSite(void) const
    {
        return m_pDestSite;
    };


    const CSite* GetNeighbourSite(void) const
    {
        return m_pNeighbourSite;
    }


    const CSite* ReachViaSite(void) const
    {
        return m_pReachViaSite;
    };


    bool IsSiteGateAlongTheRoute(void) const
    {
        return m_fLinkGateAlongTheRoute;
    }


private:
    const CSite* m_pDestSite;
    const CSite* m_pNeighbourSite;
    const CSite* m_pReachViaSite;

    bool m_fLinkGateAlongTheRoute;
};


void CServerDecision::CalculateNextSiteHop(void)
{
    ASSERT(m_sitesInfo.empty());

    UpdateSitesInfo();
    
    for(SITESINFO::iterator it = m_mySites.begin(); it != m_mySites.end(); ++it)
    {
        CSite* pMySite = it->second;

        //
        // foreign site is virtual site
        //
        if (pMySite->IsForeign())
            continue;

        pMySite->CalculateNextSiteHop(m_sitesInfo);
    }
}


void CServerDecision::UpdateSitesInfo(void)
{
    RdpGetSites(m_sitesInfo);

    //
    //  Set siteLinks info
    //
    UpdateSiteLinksInfo();
}


void CServerDecision::UpdateSiteLinksInfo(void)
/*++

  Routine Description:
    The routine retrives the site link information from the DS and associate 
    it to the relevant sites in the map of site 

  Arguments:
    map of the enterprise sites

  Returned value:
    MQ_OK if completes successfully. Error otherwise

  NOTE: bad_alloc exception is handled in the upper level

 --*/
{
    //
    // read all site links information
    //

    SITELINKS siteLinks;
    RdpGetSiteLinks(siteLinks);

    for(SITELINKS::iterator it = siteLinks.begin(); it != siteLinks.end(); )
    {
        const CSiteLink* pSiteLink = it->get();

        //
        // All the sites should be in the sitesInfo structure
        //
        SITESINFO::iterator itSite;
        
        itSite = m_sitesInfo.find(pSiteLink->GetNeighbor1());
        ASSERT(itSite != m_sitesInfo.end());
        CSite* pSiteInfo1 = itSite->second;

        itSite = m_sitesInfo.find(pSiteLink->GetNeighbor2());
        ASSERT(itSite != m_sitesInfo.end());
        CSite* pSiteInfo2 = itSite->second;


        pSiteInfo1->AddSiteLink(pSiteLink);
        pSiteInfo2->AddSiteLink(pSiteLink);

        it = siteLinks.erase(it);
    }
}


void CSite::CalculateNextSiteHop(const SITESINFO& SitesInfo)
{

    typedef multimap<DWORD, CRoutingNode> DIJKSTRA_TABLE;
    DIJKSTRA_TABLE DijkstraTable;

    //
    // DIJKSTRA initilization. Add the current site
    //
    ASSERT(SitesInfo.find(&GetId()) != SitesInfo.end());
    const CSite* pLocalSite = SitesInfo.find(&GetId())->second;
    DijkstraTable.insert(DIJKSTRA_TABLE::value_type(0, CRoutingNode(pLocalSite, NULL, pLocalSite, false)));

    //
    // Iterate through all the site links for all sites in enterprise
    //
    while (!DijkstraTable.empty())
    {
        //
        // Get the site with minimum cost
        //
        pair<const DWORD, CRoutingNode> NextHop = *(DijkstraTable.begin());
        DijkstraTable.erase(DijkstraTable.begin());

        const CSite* pSiteInfo = (NextHop.second).GetDestSite();
        if (m_nextSiteHop.find(&pSiteInfo->GetId()) != m_nextSiteHop.end())
        {
            //
            // Already exist. Ignore it
            //
            continue;
        }

        //
        // A new site add it to next hop
        //
        const CSite* pReachViaSite = (NextHop.second).ReachViaSite();
        const CSite* pNeighbourSite = (NextHop.second).GetNeighbourSite();

        m_nextSiteHop[&pSiteInfo->GetId()] = CNextSiteHop(
                                                &pReachViaSite->GetId(),
                                                &pNeighbourSite->GetId(),
                                                pReachViaSite->IsForeign(),
                                                NextHop.second.IsSiteGateAlongTheRoute(),
                                                NextHop.first
                                                );

        //
        // foreign site is virtual site that MSMQ can't route via it
        //
        if (pSiteInfo->IsForeign())
            continue;

        //
        // Add all the sites that can be reach via this site to the Dijkstra table
        //
        const SITELINKS& SiteLinks = pSiteInfo->GetSiteLinks();
        for (SITELINKS::iterator it = SiteLinks.begin(); it != SiteLinks.end(); ++it)
        {
            const CSiteLink* pSiteLink = it->get();
            DWORD cost = NextHop.first + pSiteLink->GetCost();

            const GUID* NeighborId = pSiteLink->GetNeighborOf(pSiteInfo->GetId());
    
            ASSERT(SitesInfo.find(NeighborId) !=  SitesInfo.end());
            const CSite* pNeighborSite = SitesInfo.find(NeighborId)->second;

            bool fLinkGateAlongRoute = NextHop.second.IsSiteGateAlongTheRoute() ||
                                       (pSiteLink->GetLinkGates().cElems != 0);
            //
            // For first iteration, the ReachViaSite should be the next site
            // 
            if (pSiteInfo->GetId() == GetId())
            {
                CRoutingNode NextHop(pNeighborSite, pSiteInfo, pNeighborSite, fLinkGateAlongRoute);
                DijkstraTable.insert(DIJKSTRA_TABLE::value_type(cost, NextHop));
            }
            else
            {
                CRoutingNode NextHop(pNeighborSite, pSiteInfo, pReachViaSite, fLinkGateAlongRoute);
                DijkstraTable.insert(DIJKSTRA_TABLE::value_type(cost, NextHop));
            }
        }
    }

#ifdef _DEBUG
    for(NEXT_SITE_HOP::iterator itn = m_nextSiteHop.begin(); itn != m_nextSiteHop.end(); ++itn)
    {
        CSite* pDestSite = (SitesInfo.find(itn->first))->second;
        const CNextSiteHop& NextHop = itn->second;
        CSite* pViaSite = (SitesInfo.find(NextHop.m_pNextSiteId))->second;

        TrTRACE(ROUTING, "Site: %ls Reach via site:%ls cost %d (foreign %d)",  
                    pDestSite->GetName(), pViaSite->GetName(), NextHop.m_cost, NextHop.m_fTargetSiteIsForeign);
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\lib\rdds.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

  rdds.h

Abstract:

    Definition of Machine Info class.

Author:

    Uri Habusha (urih), 10-Apr-2000


--*/

#pragma once

#ifndef __RDDS_H__
#define __RDDS_H__


class CSite;
typedef std::map<const GUID*, CSite*, guid_less> SITESINFO;


class CMachine;
typedef std::map<const GUID*, R<CMachine>, guid_less> GUID2MACHINE;

class CSiteLink;
typedef std::list< R<const CSiteLink> > SITELINKS;


//---------------------------------------------------------
//
// class CSiteLink
//
//---------------------------------------------------------

class CSiteLink : public CReference
{
public:
    CSiteLink(
        CACLSID& linkGates, 
        GUID* pNeighbor1, 
        GUID* pNeighbor2, 
        DWORD cost
        ) :
        m_linkGates(linkGates),
        m_pNeighbor1(pNeighbor1),
        m_pNeighbor2(pNeighbor2),
        m_cost(cost)
    {
        RdpRandomPermutation(m_linkGates);
    }


    virtual ~CSiteLink();


    const CACLSID& GetLinkGates(void) const
    {
        return m_linkGates;
    };


    const GUID* GetNeighborOf(const GUID& siteId) const
    {
        if (siteId == *m_pNeighbor1)
            return m_pNeighbor2;
    
        if (siteId == *m_pNeighbor2)
            return m_pNeighbor1;

        return NULL;
    };


    const GUID* GetNeighbor1(void) const
    {
        return m_pNeighbor1;
    }


    const GUID* GetNeighbor2(void) const
    {
        return m_pNeighbor2;
    }


    DWORD GetCost() const
    {
        return m_cost;
    }

private:
    CACLSID m_linkGates;

    P<GUID> m_pNeighbor1;
    P<GUID> m_pNeighbor2;

    DWORD m_cost;  
};


//---------------------------------------------------------
//
// class CSite
//
//---------------------------------------------------------

class CSite
{
public: 
    CSite(const GUID& siteId);
    virtual ~CSite();

   
    R<const CSiteLink> GetSiteLinkToSite(const GUID& destSiteId) const;
    void CalculateNextSiteHop(const SITESINFO& SitesInfo);

    bool IsMyFrs(const GUID& frsId) const;

    const GUID& GetId(void) const
    {
        return m_id;
    }


    LPCWSTR GetName(void) const
    {
        return m_name;
    }


    void AddSiteLink(const CSiteLink* pSiteLink)
    {
        m_siteLinks.push_back(SafeAddRef(pSiteLink));
    };


    bool IsForeign(void) const
    {
        return m_fForeign;
    }


    const GUID2MACHINE& GetSiteFRS(void) const
    {
        return m_frsMachines;
    };

    
    void 
    GetNextSiteToReachDest(
        const CACLSID& DestSiteIds,
        bool fDestForeign,
        const GUID** ppReachViaSite,
        const GUID** ppDestSite,
        const GUID** ppNeighbourSite,
        bool* pfLinkGateAlongTheRoute,
        DWORD* pCost
        ) const;

private:
    const SITELINKS& GetSiteLinks(void) const
    {
        return m_siteLinks;
    };


    void UpdateMySiteFrs(void);


private:
    class CNextSiteHop
    {
    public:
        CNextSiteHop()
        {
            // default construtor is required by stl container
        }

        CNextSiteHop(
            const GUID* pNextSiteId,
            const GUID* pNeighbourSiteId,
            bool fForeign,
            bool fLinkGateAlongTheRoute,
            DWORD cost
            ) : 
            m_pNextSiteId(pNextSiteId),
            m_pNeighbourSiteId(pNeighbourSiteId),
            m_fTargetSiteIsForeign(fForeign),
            m_fLinkGateAlongTheRoute(fLinkGateAlongTheRoute),
            m_cost(cost) 
        {
        }

        const GUID* m_pNextSiteId;
        const GUID* m_pNeighbourSiteId;
        bool m_fTargetSiteIsForeign; 
        bool m_fLinkGateAlongTheRoute;
        DWORD m_cost;
    };


private:
    typedef std::map<const GUID*, CNextSiteHop, guid_less> NEXT_SITE_HOP;

    GUID m_id;
    AP<WCHAR> m_name;
    bool m_fForeign;
    bool m_fLinkGateAlongTheRoute;

    GUID2MACHINE m_frsMachines;
    SITELINKS m_siteLinks;

    NEXT_SITE_HOP m_nextSiteHop;
};
 


//---------------------------------------------------------
//
// class CMachine
//
//---------------------------------------------------------

class CMachine  : public CRouteMachine
{
public:
    CMachine();
    CMachine(
        const GUID& MyMachineId,
        const CACLSID& siteIds,
        const CACLSID& outFrss,
        const CACLSID& inFrss,
        LPWSTR pName,
        bool fFrs,
        bool fForeign
        );

    ~CMachine();

    void Update(const GUID& MyMachineId);

    bool IsMySite(const GUID& SiteId) const;
    
    const GUID* 
    GetCommonSite(
        const CACLSID& SiteIds,
        bool fCheckForeign,
        const SITESINFO* pMySitesInfo = NULL
        ) const;
    
    void
    RemoveInvalidInOutFrs(
        const SITESINFO& mySites
        );


    const GUID& GetId(void) const
    {
        return m_id;
    }


    LPCWSTR GetName(void) const
    {
        return m_name;
    }


    bool IsForeign(void) const
    {
        return m_fForeign;
    }

    const CACLSID& GetSiteIds(void) const
    {
        return m_siteIds;
    };


    DWORD GetNoOfInFRS() const 
    {
        return m_inFRSList.cElems;
    };


    DWORD GetNoOfOutFRS() const 
    {
        return m_outFRSList.cElems;
    };


    bool HasOutFRS() const
    {
        return (GetNoOfOutFRS() !=0);
    };


    bool HasInFRS()  const
    {
        return (GetNoOfInFRS() !=0);
    };


    const GUID* GetAllInFRS() const
    {
        return m_inFRSList.pElems;
    };

    
    const GUID* GetAllOutFRS() const 
    {
        return m_outFRSList.pElems;
    };

    
    bool IsFRS() const
    {
        return m_fIsFRS;
    };


    bool IsMyInFrs(const GUID& frsId) const
    {
        return RdpIsGuidContained(m_inFRSList, frsId);
    };


private:

    static
    bool 
    IsFrsInSites(
        const GUID& frsId,
        const SITESINFO& sites
        );

private:
    GUID m_id;
    LPWSTR m_name;

    CACLSID m_siteIds;
    CACLSID m_outFRSList;
    CACLSID m_inFRSList;

    bool m_fIsFRS;
    bool m_fForeign;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\lib\rdds.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    rdds.cpp

Abstract:
    Implementation of MachineRouteInfo class.

Author:
    Uri Habusha (urih), 10-Apr-2000

--*/

#include <libpch.h>
#include "rd.h"
#include "rdp.h"
#include "rdds.h"
#include "rdad.h"

#include "rdds.tmh"

CMachine::CMachine(
    void
    ) :
    m_id(GUID_NULL),
    m_name(NULL),
    m_fIsFRS(false),
    m_fForeign(false)
{
    m_siteIds.cElems = 0;
    m_siteIds.pElems = NULL;
    m_outFRSList.cElems = 0;
    m_outFRSList.pElems = NULL;
    m_inFRSList.cElems = 0;
    m_inFRSList.pElems = NULL;
};

CMachine::CMachine(
    const GUID& MyMachineId,
    const CACLSID& siteIds,
    const CACLSID& outFrss,
    const CACLSID& inFrss,
    LPWSTR pName,
    bool fFrs,
    bool fForeign
    ) :
    m_id(MyMachineId),
    m_siteIds(siteIds),
    m_outFRSList(outFrss),
    m_inFRSList(inFrss),
    m_name(pName),
    m_fIsFRS(fFrs),
    m_fForeign(fForeign)
{
    RdpRandomPermutation(m_siteIds);
    RdpRandomPermutation(m_outFRSList);
    RdpRandomPermutation(m_inFRSList);
}




bool
CMachine::IsMySite(
    const GUID& siteId
    ) const
{
    for (DWORD i = 0; i < m_siteIds.cElems; ++i)
    {
        if (siteId == m_siteIds.pElems[i])
            return true;
    }

    return false;
}


const GUID* 
CMachine::GetCommonSite(
    const CACLSID& SiteIds,
    bool fCheckForeign,
    const SITESINFO* pMySitesInfo       // = NULL
    ) const
{
    for (DWORD i = 0; i < SiteIds.cElems; ++i)
    {
        if (IsMySite(SiteIds.pElems[i]))
        {
            if (fCheckForeign)
            {
                //
                // Local machine is RS, and can be part of Foreign site. However,
                // it is virtual site and can't be used for routing, ignore it
                //

                ASSERT(pMySitesInfo != NULL);
                ASSERT(IsFRS());

                //
                // Site must exist in Data-Base
                //
                ASSERT(pMySitesInfo->find(&SiteIds.pElems[i]) != pMySitesInfo->end());

                const CSite* pSite = pMySitesInfo->find(&SiteIds.pElems[i])->second;
                if (pSite->IsForeign())
                    continue;
            }

            return &SiteIds.pElems[i];
        }
    }

    return NULL;
}


bool 
CMachine::IsFrsInSites(
    const GUID& frsId,
    const SITESINFO& sites
    )
{
    for (SITESINFO::const_iterator itSite = sites.begin(); itSite != sites.end(); ++itSite)
    {
        CSite* pSite = itSite->second;

        if (pSite->IsMyFrs(frsId))
            return true;
    }
    return false;
}


void
CMachine::RemoveInvalidInOutFrs(
    const SITESINFO& sites
    )
{
    if (HasInFRS())
    {
        for (DWORD i =0; i < GetNoOfInFRS(); ++i)
        {
            GUID* pInFrs = m_inFRSList.pElems;

            if (! IsFrsInSites(pInFrs[i], sites))
            {
                for (DWORD j = i; j < GetNoOfInFRS(); ++j)
                {
                    pInFrs[j] = pInFrs[j+1];
                }
                --m_inFRSList.cElems;
            }
        }
    }

    if (HasOutFRS())
    {
        for (DWORD i =0; i < GetNoOfOutFRS(); ++i)
        {
            GUID* pOutFrs = m_outFRSList.pElems;

            if (! IsFrsInSites(pOutFrs[i], sites))
            {
                for (DWORD j = i; j < GetNoOfOutFRS(); ++j)
                {
                    pOutFrs[j] = pOutFrs[j+1];
                }
                --m_outFRSList.cElems;
            }
        }
    }
}


CMachine::~CMachine()
{
    delete [] m_name;
    delete [] m_siteIds.pElems;
    delete [] m_outFRSList.pElems;
    delete [] m_inFRSList.pElems;
}


void 
CMachine::Update(
    const GUID& machineId
    )
{
    //
    // free the previous data
    //
    delete [] m_name;
    delete [] m_siteIds.pElems;
    delete [] m_outFRSList.pElems;
    delete [] m_inFRSList.pElems;

    //
    // Clear the previous data
    //
    m_name = NULL;
    m_siteIds.cElems = 0;
    m_siteIds.pElems = NULL;
    m_outFRSList.cElems = 0;
    m_outFRSList.pElems = NULL;
    m_inFRSList.cElems = 0;
    m_inFRSList.pElems = NULL;

    //
    // have own copy of the QMId
    //
    m_id = machineId;

    RdpGetMachineData(
                m_id, 
                m_siteIds,
                m_outFRSList,
                m_inFRSList,
                &m_name,
                &m_fIsFRS,
                &m_fForeign
                );
    
    RdpRandomPermutation(m_siteIds);
    RdpRandomPermutation(m_outFRSList);
    RdpRandomPermutation(m_inFRSList);
}




CSite::CSite(
    const GUID& siteId
    ) : 
    m_id(siteId)
{
    RdpGetSiteData(m_id, &m_fForeign, &m_name);

    UpdateMySiteFrs();
}


CSite::~CSite()
{         
    m_siteLinks.erase(m_siteLinks.begin(), m_siteLinks.end());
    m_frsMachines.erase(m_frsMachines.begin(), m_frsMachines.end());
    m_nextSiteHop.erase(m_nextSiteHop.begin(), m_nextSiteHop.end());
}


bool
CSite::IsMyFrs(
    const GUID& frsId
    ) const
{
    return (m_frsMachines.find(&frsId) != m_frsMachines.end());
}


void 
CSite::GetNextSiteToReachDest(
    const CACLSID& DestSiteIds,
    bool fDestIsForeign,
    const GUID** ppReachViaSite,
    const GUID** ppDestSite,
    const GUID** ppNeighbourSite,  
    bool* pfLinkGateAlongTheRoute,
    DWORD* pCost
    ) const
{
    *ppReachViaSite = NULL;
    *pCost = INFINITE;

    for (DWORD i = 0; i < DestSiteIds.cElems; ++i)
    {
        //
        // Need to route to next site. Look for the sitelink that should be used 
        // for routing
        //
        NEXT_SITE_HOP::const_iterator it = m_nextSiteHop.find(&DestSiteIds.pElems[i]);
        if (it != m_nextSiteHop.end())
        {
            const CNextSiteHop& NextHop = it->second;
           
            if (
                //
                // The cost must be better
                //
                (NextHop.m_cost < *pCost) && 

                //
                // Use foreign site only to route to foreign destination. 
                // This code is special for connector machine, since only
                // connector can reside in foreign and regular sites.
                //
                ((!fDestIsForeign && ! NextHop.m_fTargetSiteIsForeign) || fDestIsForeign))
            {
                *ppDestSite = &DestSiteIds.pElems[i];
                *ppReachViaSite = NextHop.m_pNextSiteId;
                *ppNeighbourSite = NextHop.m_pNeighbourSiteId;
                *pfLinkGateAlongTheRoute = NextHop.m_fLinkGateAlongTheRoute;
                *pCost = NextHop.m_cost;
            }
        }
    }
}


R<const CSiteLink>
CSite::GetSiteLinkToSite(
    const GUID& destSiteId
    ) const
{
    ASSERT(m_siteLinks.begin() != m_siteLinks.end());

    for (SITELINKS::iterator it = m_siteLinks.begin(); it != m_siteLinks.end(); ++it)
    {
        const CSiteLink* pSiteLink = it->get();
        const GUID* pSrcSite = pSiteLink->GetNeighborOf(destSiteId);

        if (pSrcSite != NULL)
        {
            ASSERT(*pSrcSite == m_id);
            return SafeAddRef(pSiteLink);
        }
    }

    //
    // The function is called only when there is a site link between
    // my site and the destination site.
    //
    ASSERT(0);
    return NULL;
}


void
CSite::UpdateMySiteFrs(
    void
    )
{
    ASSERT(m_frsMachines.empty());

    TrTRACE(ROUTING, "Get Site: %ls, FRS machines.", GetName());

    RdpGetSiteFrs(GetId(), m_frsMachines);
}


CSiteLink::~CSiteLink()
{
    delete [] m_linkGates.pElems;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\lib\rdserver.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:
    RdServer.cpp

Abstract:
    Implementation of Routing server Routing Decision.

Author:
    Uri Habusha (urih), 11-Apr-2000

--*/

#include "libpch.h"
#include "Rd.h"
#include "Cm.h"
#include "Rdp.h"          
#include "RdDs.h"
#include "RdDesc.h"
#include "RdAd.h"

#include "rdserver.tmh"

void 
CServerDecision::CleanupInformation(
    void
    )
{
    for (SITESINFO::iterator it = m_sitesInfo.begin(); it != m_sitesInfo.end(); )
    {
        delete it->second;
        it = m_sitesInfo.erase(it);
    }

    CRoutingDecision::CleanupInformation();
}


void
CServerDecision::Refresh(
    void
    )
/*++

  Routine Description:
    Initializes the routine decision internal data structure.

    The routine free the previous data, and access the DS to get updated data.
    The routine featchs information for the local machine and sites. If data fetching
    succeded the routine updates the build time.

    If updating the internal data failed, the routine raise an exception.

  
  Arguments:
    None.
    
  Returned Value:
    None. An exception is raised if the operation fails

  Note:
    Brfore the routine refreshes the internal data it erases the previous data and
    sets the last build time varaible to 0. If an exception is raised during retrieving 
    the data from AD or building the internal DS, the routine doesn't update the 
    last build time. This promise that next time the Routing Decision is called 
    the previous Data structures will be cleaned-up and rebuilt.

 --*/
{
    CSW lock(m_cs);

    TrTRACE(ROUTING, "Refresh Routing Decision internal data.");

    //
    // Cleanup previous information
    //
    CleanupInformation();

    //
    // Get local machine information
    //
    GetMyMachineInformation();

    //
    // My machine should be RS, otherwise we shouldn't reach here
    //
    ASSERT(m_pMyMachine->IsFRS());

    //
    // Routing server can't have OUT FRS list
    //
    ASSERT(! m_pMyMachine->HasOutFRS());

    //
    // Calculate site link and next site hop
    //
    CalculateNextSiteHop();

    //
    // Update last refresh time
    //
    CRoutingDecision::Refresh();
}


void
CServerDecision::RouteToInFrsIntraSite(
    const CMachine* pDest,
    CRouteTable::RoutingInfo* pRouteList
    )
{
    TrTRACE(ROUTING, "Route to destination: %ls, IN FRSs", pDest->GetName());

    ASSERT(pDest->HasInFRS());

    //
    // The destination machine has InFrs. Deliver the message to InFrs Machines
    // 
    const GUID* InFrsArray = pDest->GetAllInFRS();
    for (DWORD i = 0; i < pDest->GetNoOfInFRS(); ++i)
    {
        R<const CMachine> pRoute = GetMachineInfo(InFrsArray[i]);

        //
        // Check that in-Frs is in the same site as the source machine
        //
        const GUID* pCommonSiteId = m_pMyMachine->GetCommonSite(
                                                pRoute->GetSiteIds(), 
                                                (! pDest->IsForeign()),
                                                &m_mySites
                                                );
        if (pCommonSiteId != NULL)
        {
            pRouteList->insert(pRoute);
        }
    }
}


void
CServerDecision::RouteIntraSite(
    const CMachine* pDest,
    CRouteTable& RouteTable
    )
/*++ 

  Routine Description:
    Both, the source and destination machines are in the sam site. The routine finds 
    the possibile next hops for in site destination.

    Intra site, routing algorithm for independent client is:
        - First priority, direct connection to the destination or to valid 
          in-frss (if exist in same site).
        - Second priority. connection with one of RS in site.

    Intra site, routing algorithm for RS is:
        - First priority. direct connection to the destination machine or to valid
          in-Frs (if exist and the source isn't one of them)

  Arguments:
    RouteTable - routing table that the routine fills
    pDest - information of the destination machine

  Returned Value:
    None. the routine fills the routine table

  Note:
    The routine can throw an exeption

 --*/
{
    TrTRACE(ROUTING, "IntraSite routing to: %ls.", pDest->GetName());

    //
    // The destination and local machine should be in the same 
    // site. Otherwise it is not Intra site routing
    //
    ASSERT(m_pMyMachine->GetCommonSite(pDest->GetSiteIds(), (!pDest->IsForeign()), &m_mySites) != NULL);
    
    CRouteTable::RoutingInfo* pFirstPriority = RouteTable.GetNextHopFirstPriority();

    if (pDest->HasInFRS() && 
        ! pDest->IsMyInFrs(m_pMyMachine->GetId()))
    {
        RouteToInFrsIntraSite(pDest, pFirstPriority);

        if (!pFirstPriority->empty())
            return;

        //
        // Didn't find IN Frs that belong to my sites. Ignore In FRSs
        //        
    }

    //
    // The destination machine doesn't have InFRS or my machine is set 
    // as InFRS machine of the destination. Use Direct connection from 
    // FRS to Destination machine in Same site. Don't try alternative path
    //
    pFirstPriority->insert(SafeAddRef(pDest));
}


bool
CServerDecision::IsMyMachineLinkGate(
    const CACLSID& LinkGates
    )
{
   //
    // Scan all the site gates of the link and find if the source machine 
    // is one of the site gate. MSMQ doesn't need to route to the site gate
    //
    for (DWORD i = 0; i< LinkGates.cElems; ++i)
    {
        if (LinkGates.pElems[i] == m_pMyMachine->GetId())
        {
            return true;
        }
    }

    return false;
}


void
CServerDecision::RouteToLinkGate(
    const CACLSID& LinkGates,
    CRouteTable& RouteTable
    )
{
    //
    // Our link need to have a Link Gates. Otherwise the code 
    // doesn't reach this point
    //
    ASSERT(LinkGates.cElems > 0);

    for (DWORD i = 0; i< LinkGates.cElems; ++i)
    {
        ASSERT(LinkGates.pElems[i] != m_pMyMachine->GetId());

        //
        // Direct route to link gate
        //
        R<const CMachine> pRoute = GetMachineInfo(LinkGates.pElems[i]);
        (RouteTable.GetNextHopFirstPriority())->insert(pRoute);
    }
}


void
CServerDecision::RouteToInFrsInterSite(
    const CMachine* pDest,
    CRouteTable& RouteTable
    )
{
    ASSERT(! pDest->IsMyInFrs(m_pMyMachine->GetId()));

    //
    // The destination machine has InFrs. Deliver the message to InFrs Machines
    //
    const GUID* InFrsArray = pDest->GetAllInFRS();

    for (DWORD i = 0; i < pDest->GetNoOfInFRS(); ++i)
    {
        R<const CMachine> pRoute = GetMachineInfo(InFrsArray[i]);
        
        //
        // check that In-FRS is valid FRS in destiantion machine SITES
        //
        if (RdpIsCommonGuid(pDest->GetSiteIds(), pRoute->GetSiteIds()))
        {
            //
            // The next hop is one of the valid IN-FRS. 
            // 
            GetRouteTableInternal(InFrsArray[i], RouteTable);
        }
    }
}


R<const CSiteLink>
CServerDecision::FindSiteLinkToDestSite(
    const CMachine* pDest,
    const GUID** ppNextSiteId,
    const GUID** ppDestSiteId,
    const GUID** ppNeighbourSite,
    bool* pfLinkGateAlongTheRoute
    )
{
    const GUID* pMySiteId = NULL;
    DWORD NextSiteCost = INFINITE;

    const CACLSID& DestSiteIds = pDest->GetSiteIds();

    //
    // Need to route to next site. Look for the sitelink that should be used 
    // for routing
    //
    for (SITESINFO::iterator it = m_mySites.begin(); it != m_mySites.end(); ++it)
    {
        const GUID* pTempDestSiteId;
        const GUID* pTempViaSiteId;
        const GUID* pNeighbourSiteId;
        bool fLinkGateAlongTheRoute;
        DWORD TempCost;
        const CSite* pSite = it->second;

        pSite->GetNextSiteToReachDest(
                                DestSiteIds, 
                                pDest->IsForeign(), 
                                &pTempViaSiteId,
                                &pTempDestSiteId,
                                &pNeighbourSiteId,
                                &fLinkGateAlongTheRoute,
                                &TempCost
                                );

        if(NextSiteCost > TempCost)
        {
            pMySiteId = &pSite->GetId();
            *ppNextSiteId = pTempViaSiteId;
            *ppDestSiteId = pTempDestSiteId;
            *ppNeighbourSite = pNeighbourSiteId;
            *pfLinkGateAlongTheRoute = fLinkGateAlongTheRoute;
            NextSiteCost = TempCost;
        }
    }

    if (pMySiteId == NULL)
    {
        //
        // Can't route to destination site. there is no connectivity
        //
        TrWARNING(ROUTING, "Failed to route to destination site. There is no connectivity");
		return NULL;
    }

    const CSite* pMySite = m_sitesInfo.find(pMySiteId)->second;
    
    return pMySite->GetSiteLinkToSite(**ppNextSiteId);
}


void
CServerDecision::RouteToFrsInSite(
    const GUID* pSiteId,
    const CRouteTable::RoutingInfo* pPrevRouteList,
    CRouteTable::RoutingInfo* pRouteList
    )
{
    //
    // find site object
    //
    ASSERT(m_sitesInfo.find(pSiteId) != m_sitesInfo.end());
    CSite* pSite = m_sitesInfo.find(pSiteId)->second;

    const GUID2MACHINE& DestSiteFRS = pSite->GetSiteFRS();
    for(GUID2MACHINE::const_iterator it1 = DestSiteFRS.begin(); it1 != DestSiteFRS.end(); ++it1)
    {
        R<const CMachine> pRoute = GetMachineInfo(*it1->first);

        if (RdpIsMachineAlreadyUsed(pPrevRouteList, pRoute->GetId()))
        {
            //
            // We already route to this machine directly
            //
            continue;
        }

        pRouteList->insert(pRoute);
    }
}


void
CServerDecision::RouteInterSite(
    const CMachine* pDest,
    CRouteTable& RouteTable
    )
{
    TrTRACE(ROUTING, "InterSite routing to: %ls", pDest->GetName());

    if (pDest->HasInFRS())
    {
        RouteToInFrsInterSite(pDest, RouteTable);
        return;
    }

    const GUID* pNextSiteId = NULL;
    const GUID* pDestSiteId = NULL;
    const GUID* pNeighbourSite = NULL;
    bool fLinkGateAlongTheRoute;

	R<const CSiteLink> pSiteLink = FindSiteLinkToDestSite(
                                        pDest, 
                                        &pNextSiteId, 
                                        &pDestSiteId, 
                                        &pNeighbourSite,
                                        &fLinkGateAlongTheRoute
                                        );
	if(pSiteLink.get() == NULL)
	{
		//
		// There is no routing link between the sites. try direct connection
		//
		CRouteTable::RoutingInfo* pFirstPriority = RouteTable.GetNextHopFirstPriority();
		pFirstPriority->insert(SafeAddRef(pDest));
		return;
	}

    if (fLinkGateAlongTheRoute && 
        !IsMyMachineLinkGate(pSiteLink->GetLinkGates()))
    {
        //
        // If the next link has a link gates route the message to these link gates
        //
        if (pSiteLink->GetLinkGates().cElems != 0)
        {
            //
            // Local machine need a LinkGate:
            //      - Destination is in other Site,
            //      - Our Link is configured with Link Gates and Local machine is not a LinkGate,
            //
            RouteToLinkGate(pSiteLink->GetLinkGates(), RouteTable);
            return;
        }

        //
        // the next link doesn't have a link gate. Route the message to RSs in the 
        // next site along the best route.
        //
        RouteToFrsInSite(pNextSiteId, NULL, RouteTable.GetNextHopFirstPriority());
        return;
    }

    //
    // My machine is link gate, but next site isn't destination site, route
    // the message to RSs in next site along the best route.
    //
    if (IsMyMachineLinkGate(pSiteLink->GetLinkGates()) && 
        !RdpIsGuidContained(pDest->GetSiteIds(), *pNextSiteId))
    {
        ASSERT(fLinkGateAlongTheRoute);

        RouteToFrsInSite(pNextSiteId, NULL, RouteTable.GetNextHopFirstPriority());
        return;
    }

    //
    // Local machine is site gate and the next site is the destiantion site, or the 
    // site doesn't have a link gate along the route.
    // 

    //
    // Direct route
    //
    CRouteTable::RoutingInfo* pFirstPriority = RouteTable.GetNextHopFirstPriority();
    pFirstPriority->insert(SafeAddRef(pDest));

    //
    // As A Second priority route to FRS in destination site
    //
    RouteToFrsInSite(
                pNextSiteId, 
                RouteTable.GetNextHopFirstPriority(),
                RouteTable.GetNextHopSecondPriority()
                );
}


void 
CServerDecision::GetRouteTable(
    const GUID& DestMachineId,
    CRouteTable& RouteTable
    )
/*++

  Routine Description:
    The routine calculates and returnes the routing table for destination Machine.

  Arguments:
    DestMachineId - identefier of the destination machine
    fRebuild - boolean flag, that indicates if internal cache should be rebuild
    pRouteTable - pointer to the routing tabel

  Returned Value:
    None. An exception is raised if the operation fails

 --*/
{
    if (NeedRebuild())
        Refresh();

	GetRouteTableInternal(DestMachineId, RouteTable);
}

void 
CServerDecision::GetRouteTableInternal(
    const GUID& DestMachineId,
    CRouteTable& RouteTable
    )
/*++

  Routine Description:
    The routine calculates and returnes the routing table for destination Machine.

  Arguments:
    DestMachineId - identefier of the destination machine
    fRebuild - boolean flag, that indicates if internal cache should be rebuild
    pRouteTable - pointer to the routing tabel

  Returned Value:
    None. An exception is raised if the operation fails

 --*/
{
    CSR lock(m_cs);

    if (NeedRebuild())
        throw exception();

    //
    // Routing server can't desclared with out RS list
    //
    ASSERT (! m_pMyMachine->HasOutFRS());

    //
    // Get the target machine information
    //
    R<const CMachine> pDest = GetMachineInfo(DestMachineId);

    //
    // The destination machine can't be the local machine
    //
    ASSERT(pDest->GetId() != m_pMyMachine->GetId());

    //
    // Check if inter-site. Both the local machine and destination should have a common 
    // site.
    //
    const GUID* pCommonSiteId = m_pMyMachine->GetCommonSite(
                                                    pDest->GetSiteIds(),
                                                    (! pDest->IsForeign()),
                                                    &m_mySites
                                                    );

    if (pCommonSiteId != NULL)
    {
        //
        // Intra site routing
        //
        RouteIntraSite(pDest.get(), RouteTable);
        return;
    }

    //
    // Inter site routing
    //
    RouteInterSite(pDest.get(), RouteTable);
}


void
CServerDecision::GetConnector(
    const GUID& foreignMachineId,
    GUID& connectorId
    )
{
    if (NeedRebuild())
        Refresh();

    CSR lock(m_cs);

    //
    // The internal data was corrupted. Before the routine gets the CS, refresh called
    // again and failed to refresh the internal data.
    //
    if (NeedRebuild())
        throw exception();
 
    //
    // Get the target foreign machine information
    //
    R<const CMachine> destMachine = GetMachineInfo(foreignMachineId);
    ASSERT(destMachine->IsForeign());

    TrTRACE(ROUTING, "Find connector to route to %ls", destMachine->GetName());

    const GUID* pNextSite = NULL;
    const GUID* pDestSite = NULL;
    const GUID* pNeighbourSite = NULL;
    bool fLinkGateAlongTheRoute;
    //
    // Get the best foreign site to reach the foreign machine and the
    // neighbour site that contain the connector machine
    //
    R<const CSiteLink> pLink = FindSiteLinkToDestSite(
                                                destMachine.get(),
                                                &pNextSite,
                                                &pDestSite,
                                                &pNeighbourSite,
                                                &fLinkGateAlongTheRoute
                                                );

	if (pLink.get() == NULL)
	{
        //
        // Can't route to destination site. there is no connectivity
        //
        TrERROR(ROUTING, "Failed to route to destination site. There is no connectivity");
        throw bad_route();
	}

    //
    // Get the connector machine for the foreign site
    //
    CACLSID ConnectorsIds;
    RdpGetConnectors(*pDestSite, ConnectorsIds);

    //
    // At least one connector should be exist in foreign site, otherwise
    // MSMQ can't reach the foreign machine. 
    //
    if (ConnectorsIds.cElems == 0)
    {
        TrERROR(ROUTING, "Failed to find possible route to foreign machine: %ls", destMachine->GetName());
        throw bad_route();
    }

    //
    // If local machine is connector by itself use it 
    //
    if (RdpIsGuidContained(ConnectorsIds, m_pMyMachine->GetId()))
    {
        //
        // local machine is connector
        //
        connectorId = m_pMyMachine->GetId();
        return;
    }

    //
    // Get the niegbour site connectors/FRS's
    //
    CACLSID NeighbourConnectors;
    RdpGetConnectors(*pNeighbourSite, NeighbourConnectors);
    RdpRandomPermutation(NeighbourConnectors);

    ASSERT(NeighbourConnectors.cElems != 0);

    //
    // Find the union of foreign site and neigbour site connectors. 
    //
    for (DWORD i = 0; i < NeighbourConnectors.cElems; ++i)
    {
        if (RdpIsGuidContained(ConnectorsIds, NeighbourConnectors.pElems[i]))
        {
            connectorId = NeighbourConnectors.pElems[i];
            return;
        }
    }

    TrERROR(ROUTING, "Failed to find possible route to foreign machine: %ls", destMachine->GetName());
    throw bad_route();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\lib\rdutil.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    util.cpp

Abstract:
    Implementation of utility routines for routing.

Author:
    Uri Habusha (urih), 11-Apr-2000

--*/

#include "libpch.h"
#include "rd.h"
#include "rdp.h"

#include "rdutil.tmh"

using namespace std;

bool
RdpIsGuidContained(
    const CACLSID& caclsid,
    const GUID& SearchGuid
    )
{
	const GUID* GuidArray = caclsid.pElems;
	for (DWORD i=0; i < caclsid.cElems; ++i)
	{
		if (GuidArray[i] == SearchGuid)
			return true;
	}

	return false;
}


bool
RdpIsCommonGuid(
    const CACLSID& caclsid1,
    const CACLSID& caclsid2
    )
{
	const GUID* GuidArray = caclsid1.pElems;
	for (DWORD i=0; i < caclsid1.cElems; ++i)
	{
		if (RdpIsGuidContained(caclsid2, GuidArray[i]))
			return true;
	}

	return false;
}
void
RdpRandomPermutation(
    CACLSID& e
    )
{
    if (e.cElems <=1)
        return;

    for(DWORD i = e.cElems; i>1;)
    {
        DWORD r = rand() % i;

        --i;
        swap(e.pElems[i], e.pElems[r]);
    }
}
   

bool
RdpIsMachineAlreadyUsed(
    const CRouteTable::RoutingInfo* pRouteList,
    const GUID& id
    )
{
    if (pRouteList == NULL)
        return false;

    //
    // BUGBUG: performance - use stl set find instead of linear search. urih 30-Apr-2000
    //
    for(CRouteTable::RoutingInfo::const_iterator it = pRouteList->begin(); it != pRouteList->end(); ++it)
    {
        if (id == (*it)->GetId())
            return true;
    }

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\lib\rdp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Rdp.h

Abstract:
    Routing Decision private functions.

Author:
    Uri Habusha (urih) 10-Apr-00

--*/

#pragma once

#ifndef _MSMQ_Rdp_H_
#define _MSMQ_Rdp_H_

#include "timetypes.h"


#ifdef _DEBUG

void RdpAssertValid(void);
void RdpSetInitialized(void);
BOOL RdpIsInitialized(void);
void RdpRegisterComponent(void);

#else // _DEBUG

#define RdpAssertValid() ((void)0)
#define RdpSetInitialized() ((void)0)
#define RdpIsInitialized() TRUE
#define RdpRegisterComponent() ((void)0)

#endif // _DEBUG

struct guid_less : public std::binary_function<const GUID*, const GUID*, bool> 
{
    bool operator()(const GUID* k1, const GUID* k2) const
    {
        return (memcmp(k1, k2, sizeof(GUID)) < 0);
    }
};

void
RdpInitRouteDecision(
    bool fRoutingServer,
    CTimeDuration rebuildInterval
    );


bool
RdpIsGuidContained(
    const CACLSID& caclsid,
    const GUID& SearchGuid
    );


bool
RdpIsCommonGuid(
    const CACLSID& caclsid1,
    const CACLSID& caclsid2
    );


void
RdpRandomPermutation(
    CACLSID& e
    );


bool
RdpIsMachineAlreadyUsed(
    const CRouteTable::RoutingInfo* pRouteList,
    const GUID& id
    );

#endif // _MSMQ_Rdp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\test\cmachine.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    cmachine.cpp

Abstract:
    DS stub - machine object implementation

Author:
    Uri Habusha (urih) 10-Apr-2000

Environment:
    Platform-independent

--*/

#include "libpch.h"
#include "dsstubp.h"
#include "csite.h"
#include "cmachine.h"
#include "mqprops.h"

#include "cmachine.tmh"

using namespace std;

static DBMachines s_machinesDataBase;

CMachineObj::CMachineObj(
    wstring& Name, 
    bool DSService, 
    bool RoutingService, 
    bool DependentClient,
    bool fForeign
    ) :
    m_Name(Name),
    m_fDSService(DSService),
    m_fRoutingService(RoutingService),
    m_fDependentClient(DependentClient),
    m_fForeign(fForeign)
{
    UuidCreate(&m_Id);
}


bool CMachineObj::IsBelongToSite(const CSiteObj* pSite)
{
    for (SiteList::iterator it = m_sites.begin(); it != m_sites.end(); ++it)
    {
        if (*it == pSite)
            return true;
    }

    return false;
}

void
CMachineObj::GetOutFrsProperty(
    PROPVARIANT& pVar
    ) const
{
    DWORD index = 0;
    GUID* pElems = NULL;

    if (!m_outFrs.empty())
    {
        pElems = new GUID[m_outFrs.size()];
        for (MachineList::iterator it = m_outFrs.begin(); it != m_outFrs.end(); ++it)
        {
            const CMachineObj* pMachine = *it;
            pElems[index] = pMachine->GetMachineId();

            ++index;
        }

        ASSERT(index == m_outFrs.size());
    }

    pVar.cauuid.cElems = index;
    pVar.cauuid.pElems = pElems;

    pVar.vt = (VT_CLSID|VT_VECTOR);
}


void
CMachineObj::GetInFrsProperty(
    PROPVARIANT& pVar
    ) const
{
    DWORD index = 0;
    GUID* pElems = NULL;

    if (!m_inFrs.empty())
    {
        pElems = new GUID[m_inFrs.size()];
        for (MachineList::iterator it = m_inFrs.begin(); it != m_inFrs.end(); ++it)
        {
            const CMachineObj* pMachine = *it;
            pElems[index] = pMachine->GetMachineId();

            ++index;
        }

        ASSERT(index == m_inFrs.size());
    }

    pVar.cauuid.cElems = index;
    pVar.cauuid.pElems = pElems;

    pVar.vt = (VT_CLSID|VT_VECTOR);
}


void
CMachineObj::GetProperties(
    DWORD cp,
    const PROPID aProp[],
    PROPVARIANT apVar[]
    ) const
{
    for (DWORD i = 0; i < cp ; ++i)
    {
        switch (aProp[i])
        {
            case PROPID_QM_SITE_IDS:
            {
                apVar[i].cauuid.pElems =new GUID[m_sites.size()];
                apVar[i].cauuid.cElems = 0;

                for(SiteList::iterator it = m_sites.begin(); it != m_sites.end(); ++it)
                {
                    const CSiteObj* pSite = *it;
                    apVar[i].cauuid.pElems[apVar[i].cauuid.cElems] = pSite->GetSiteId();
                    ++apVar[i].cauuid.cElems;
                }

                break;
            }

            case PROPID_QM_MACHINE_ID: 
                apVar[i].puuid = new GUID;
                apVar[i].vt = VT_CLSID;
        
                memcpy(apVar[i].puuid, &m_Id, sizeof(GUID));
                break;

            case PROPID_QM_PATHNAME:
                apVar[i].pwszVal = new WCHAR[wcslen(m_Name.data()) + 1];
                apVar[i].vt = VT_LPWSTR;

                wcscpy(apVar[i].pwszVal, m_Name.data());
                break;


            case PROPID_QM_OUTFRS:
                GetOutFrsProperty(apVar[i]);
                break;

            case PROPID_QM_INFRS:
                GetInFrsProperty(apVar[i]);
                break;

            case PROPID_QM_FOREIGN:
                apVar[i].vt = VT_UI1;
                apVar[i].bVal = m_fForeign;
                break;

            case PROPID_QM_SERVICE_ROUTING:
                apVar[i].vt = VT_UI1;
                apVar[i].bVal = m_fRoutingService;
                break;

            case PROPID_QM_SERVICE_DSSERVER:
                apVar[i].vt = VT_UI1;
                apVar[i].bVal = m_fDSService;
                break;

            case PROPID_QM_SERVICE_DEPCLIENTS:
                apVar[i].vt = VT_UI1;
                apVar[i].bVal = m_fDependentClient;
                break;

            default:
                throw exception();
        }
    }
}


const CMachineObj* 
DBMachines::FindMachine(
    wstring MachineName
    )
{
    MachineMap::iterator it = m_Machines.find(MachineName);
    if (it ==  m_Machines.end())
        return NULL;

    return it->second;
}


const CMachineObj* 
DBMachines::FindMachine(
    const GUID& id
    )
{
    for (MachineMap::iterator it = m_Machines.begin(); it != m_Machines.end(); ++it)
    {
        if (it->second->GetMachineId() == id)
            return it->second;
    }
        
    return NULL;
}

enum MachinePropValue
{
    eName = 1,
    eSiteName,
    eOutFrs,
    eInFrs,
    eRouting,
    eDSServer,
    eDependentClient,
    eForeign,
};

PropertyValue MachineProperties[] = {
    { L"PROPID_QM_PATHNAME",             eName },
    { L"PROPID_QM_SITE_NAME",            eSiteName },       
    { L"PROPID_QM_OUTFRS",               eOutFrs },
    { L"PROPID_QM_INFRS",                eInFrs },
    { L"PROPID_QM_SERVICE_ROUTING",      eRouting },
    { L"PROPID_QM_SERVICE_DSSERVER",     eDSServer },
    { L"PROPID_QM_SERVICE_DEPCLIENTS",   eDependentClient },
    { L"PROPID_QM_FOREIGN",              eForeign },
};


static
void 
ParseSitesProperty(
    CMachineObj* pMachine, 
    wstring& SitesName
    )
{
    while(!SitesName.empty())
    {
        wstring siteName = GetNextNameFromList(SitesName);

        if (!siteName.empty())
        {
            CSiteObj* pSite = const_cast<CSiteObj*>(FindSite(siteName));
            if (pSite == NULL)
            {
                printf("Site %s doesn't exist. Can't be add Machine %s\n",
                        siteName, pMachine->GetMachineName());
                continue;
            }
            
            pSite->AddMachine(pMachine);
            pMachine->AddSite(pSite);
        }
    }
}


static
void
ParseInOutFrsProperty(
    CMachineObj* pMachine, 
    wstring& InOutFrs,
    bool fOutFrs
    )
{
    while(!InOutFrs.empty())
    {
        wstring FrsName = GetNextNameFromList(InOutFrs);

        if (!FrsName.empty())
        {
            const CMachineObj* pFrsMachine = s_machinesDataBase.FindMachine(FrsName);
            if (pFrsMachine == NULL)
            {
                printf("IN FRS %s doesn't exist. Can't be add Machine %s\n",
                        FrsName, pMachine->GetMachineName());
                continue;
            }
            
            if (!pFrsMachine->RoutingService())
            {
                printf("Machine %s cannot use as InFrs. It isn't Routing Service\n", FrsName);
                continue;
            }

            if (fOutFrs)
            {
                pMachine->AddOutFrs(pFrsMachine);
            }
            else
            {
                pMachine->AddInFrs(pFrsMachine);
            }
        }

    }
}


void CreateMachineObject(void)
{
    wstring MachineName;
    wstring SitesName;
    wstring OutFrs;
    wstring InFrs;

    bool fRoutingService = false;  
    bool fSetRoutingService = false;

    bool fDSService = false;
    bool fSetDSService  = false;

    bool fDependentClient = false;
    bool fSetDependentClient = false;

    bool fForeign = false;
    bool fSetForeign = false;

    GetNextLine(g_buffer);
    while(!g_buffer.empty())
    {
        //
        // New object
        //
        if (g_buffer.compare(0,1,L"[") == 0)
            break;

        //
        // line must be <property_name> = <property_value>
        //
        wstring PropName;
        wstring PropValue;
        if (!ParsePropertyLine(g_buffer, PropName, PropValue))
        {
            GetNextLine(g_buffer);
            continue;
        }

        switch(ValidateProperty(PropName, MachineProperties, TABLE_SIZE(MachineProperties)))
        {
            case  eName:
                MachineName = PropValue;
                RemoveTralingBlank(MachineName);
                break;

            case  eSiteName:
                SitesName = PropValue;
                break;

            case eOutFrs:
                OutFrs = PropValue;
                break;
    
            case eInFrs:
                InFrs = PropValue;
                break;

            case eRouting:
                if (_wcsnicmp(PropValue.data(), L"TRUE", wcslen(L"TRUE")) == 0)
                {
                    fRoutingService = true;
                }
                fSetRoutingService = true;
                break;

            case eDSServer:
                if (_wcsnicmp(PropValue.data(), L"TRUE", wcslen(L"TRUE")) == 0)
                {
                    fDSService = true;
                }
                fSetDSService = true;
                break;

            case eDependentClient:
                if (_wcsnicmp(PropValue.data(), L"TRUE", wcslen(L"TRUE")) == 0)
                {
                    fDependentClient = true;
                }
                fSetDependentClient = true;
                break;

            case eForeign:
                if (_wcsnicmp(PropValue.data(), L"TRUE", wcslen(L"TRUE")) == 0)
                {
                    fForeign = true;
                }
                fSetForeign = true;
                break;

            default:
                FileError("Illegal Machine Property");
        }

        GetNextLine(g_buffer);
    }

    if (MachineName.empty())
    {
        FileError("Machine Name is mandatory. Ignore the Machine decleration");
        throw exception();
    }

    CMachineObj* pMachine = const_cast<CMachineObj*>(s_machinesDataBase.FindMachine(MachineName));
    if (pMachine == NULL)
    {
        pMachine = new CMachineObj(
                            MachineName, 
                            fDSService, 
                            fRoutingService,
                            fDependentClient, 
                            fForeign
                            ); 
    }
    else
    {
        if (fSetRoutingService) 
            pMachine->RoutingService(fRoutingService);

        if (fSetDSService) 
            pMachine->DSService(fDSService);
        
        if (fSetDependentClient) 
            pMachine->DependentClientService(fDependentClient);
        
        if (fSetForeign) 
            pMachine->Foreign(fForeign);
    }

    //
    // Parse the site property
    //
    ParseSitesProperty(pMachine, SitesName);
    if (pMachine->GetSites().empty())
    {
        FileError("Machine must be joined atleast to 1 site");
        delete pMachine;
        return;
    }

    //
    // Insert machine to the machine DB
    //
    s_machinesDataBase.AddMachine(pMachine);

    //
    // Parse In/Out FRS of machine
    //
    ParseInOutFrsProperty(pMachine, OutFrs, true);
    ParseInOutFrsProperty(pMachine, InFrs, false);
}


const CMachineObj* FindMachine(const wstring& MachineName)
{
    return s_machinesDataBase.FindMachine(MachineName);
}

const CMachineObj* FindMachine(const GUID& pMachineId)
{
    return s_machinesDataBase.FindMachine(pMachineId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\test\cmachine.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
  cmachine.h

Abstract:
    DS Stub machine object interface

Author:
    Uri Habusha (urih), 11-Apr-2000

--*/

#pragma once

#ifndef __CMACHINE_H__
#define __CMACHINE_H__

class CMachineObj
{
public:
    CMachineObj(
        std::wstring& Name, 
        bool DSService, 
        bool RoutingService, 
        bool DependentClient,
        bool fForeign
        );

    void
    GetProperties(
        DWORD cp,
        const PROPID aProp[],
        PROPVARIANT apVar[]
        ) const;

    
    bool IsBelongToSite(const CSiteObj* pSite);


    const std::wstring& GetMachineName(void) const 
    { 
        return m_Name; 
    };


    const GUID& GetMachineId(void) const 
    { 
        return m_Id; 
    };
    

    void AddSite(const CSiteObj* pSite) 
    { 
        m_sites.push_back(pSite); 
    };


    void AddInFrs(const CMachineObj* pMachine) 
    { 
        m_inFrs.push_back(pMachine); 
    };


    void AddOutFrs(const CMachineObj* pMachine) 
    {
        m_outFrs.push_back(pMachine);
    };


    const SiteList& GetSites(void) const 
    { 
        return m_sites;
    };


    const MachineList& GetInFrs(void) 
    { 
        return m_inFrs; 
    };


    const MachineList& GetOutFrs(void) 
    { 
        return m_outFrs; 
    };


    void RoutingService(bool f) 
    { 
        m_fRoutingService = f; 
    };


    bool RoutingService(void) const 
    { 
        return m_fRoutingService; 
    };


    void DSService(bool f) 
    { 
        m_fDSService = f;
    };


    bool DSService(void) const 
    { 
        return m_fDSService; 
    };


    void DependentClientService(bool f) 
    { 
        m_fDependentClient = f; 
    };


    bool DependentClientService(void) const 
    { 
        return m_fDependentClient; 
    };


    void Foreign(bool f) 
    { 
        m_fForeign = f;
    };


    bool Foreign(void) const 
    { 
        return m_fForeign; 
    };


private:
    void GetOutFrsProperty(PROPVARIANT& pVar) const;
    void GetInFrsProperty(PROPVARIANT& pVar) const;

private:
    std::wstring m_Name;
    GUID m_Id;
    SiteList m_sites;
    MachineList m_inFrs;
    MachineList m_outFrs;
    bool m_fDSService;
    bool m_fRoutingService;
    bool m_fDependentClient;
    bool m_fForeign;
};


class DBMachines
{
public:
    void AddMachine(CMachineObj* pMachine) 
    { 
        m_Machines[pMachine->GetMachineName()] = pMachine; 
    };


    const CMachineObj* FindMachine(std::wstring MachineName);
    const CMachineObj* FindMachine(const GUID& pMachineId);

private:
    typedef std::map<std::wstring, const CMachineObj*> MachineMap;

    MachineMap m_Machines;
};



#endif // __CMACHINE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\test\csite.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    csite.cpp

Abstract:
    DS stub - site object implementation

Author:
    Uri Habusha (urih) 10-Apr-2000

Environment:
    Platform-independent

--*/

#include "libpch.h"
#include <dsstubp.h>
#include <mqprops.h>

#include "csite.tmh"

using namespace std;

DBSite g_siteDataBase;

CSiteObj::CSiteObj(
    wstring Name, 
    bool fForeign
    ) :
    m_Name(Name),
    m_fForeign(fForeign)
{
    UuidCreate(&m_Id);
}


const CSiteLinkObj* 
CSiteObj::GetSiteLink(CSiteObj* pNeighbor)
{
    for(SiteLinkList::iterator it = m_SiteLink.begin(); it != m_SiteLink.end(); ++it)
    {
        const CSiteLinkObj* pSiteLink = *it;
        if (pSiteLink->IsSiteLinkBetween(this, pNeighbor))
            return pSiteLink;
    }

    return NULL;
}

const CSiteObj* 
DBSite::FindSite(
    const wstring& SiteName
    ) const
{
    SiteMap::const_iterator it = m_Sites.find(SiteName);
    if (it ==  m_Sites.end())
        return NULL;

    return it->second;
}


const CSiteObj* 
DBSite::FindSite(
    const GUID& id
    ) const
{
    for (SiteMap::const_iterator it = m_Sites.begin(); it != m_Sites.end(); ++it)
    {
        if (it->second->GetSiteId() == id)
            return it->second;
    }
        
    return NULL;
}


enum SitePropValue
{
    eSiteName = 1,
    eSiteForeign
};

PropertyValue SiteProperties[] = {
    { L"PROPID_S_PATHNAME",      eSiteName },
    { L"PROPID_S_FOREIGN",       eSiteForeign },
};

void CreateSiteObject(void)
{
    wstring SiteName;
    bool fForeign = false;

    GetNextLine(g_buffer);
    while(!g_buffer.empty())
    {
        //
        // New object
        //
        if (g_buffer.compare(0,1,L"[") == 0)
            break;

        //
        // line must be <property_name> = <property_value>
        //
        wstring PropName;
        wstring PropValue;
        if (!ParsePropertyLine(g_buffer, PropName, PropValue))
        {
            GetNextLine(g_buffer);
            continue;
        }


        switch(ValidateProperty(PropName, SiteProperties, TABLE_SIZE(SiteProperties)))
        {
            case  eSiteName:
                SiteName = PropValue;
                RemoveTralingBlank(SiteName);
                break;

            case eSiteForeign:
                if (_wcsnicmp(PropValue.data(), L"TRUE", wcslen(L"TRUE")) == 0)
                {
                    fForeign = true;
                }
                break;

            default:
                throw exception();

        }
        GetNextLine(g_buffer);
    }

    if (SiteName.empty())
    {
        FileError("Site Name is mandatory. Ignore the site");
        throw exception();
    }

    CSiteObj* pSite = new CSiteObj(SiteName, fForeign); 
    g_siteDataBase.AddSite(pSite);
}


void
CSiteObj::GetProperties(
    DWORD cp,
    const PROPID aProp[],
    PROPVARIANT apVar[]
    ) const
{
    for (DWORD i = 0; i < cp ; ++i)
    {
        switch (aProp[i])
        {
            case PROPID_S_PATHNAME:
                apVar[i].pwszVal = new WCHAR[wcslen(m_Name.data()) + 1];
                apVar[i].vt = VT_LPWSTR;

                swprintf(apVar[i].pwszVal, L"%s", m_Name.data());
                break;

            case PROPID_S_FOREIGN:
                apVar[i].vt = VT_UI1;
                apVar[i].bVal = m_fForeign;
                break;

            case PROPID_S_GATES:
            {
                apVar[i].cauuid.pElems =new GUID[m_SiteGates.size()];
                apVar[i].cauuid.cElems = 0;

                for(MachineList::iterator it = m_SiteGates.begin(); it != m_SiteGates.end(); ++it)
                {
                    const CMachineObj* pMachine = *it;
                    apVar[i].cauuid.pElems[apVar[i].cauuid.cElems] = pMachine->GetMachineId();
                    ++apVar[i].cauuid.cElems;
                }

                break;
            }

            default:
                throw exception();
        }
    }
}

const CSiteObj* FindSite(const wstring& SiteName)
{
    return g_siteDataBase.FindSite(SiteName);
}

const CSiteObj* FindSite(const GUID& pSiteId)
{
    return g_siteDataBase.FindSite(pSiteId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\test\csitelink.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
  csite.h

Abstract:
    DS Stub site link object interface

Author:
    Uri Habusha (urih), 11-Apr-2000

--*/

#pragma once 


#ifndef __CSITELINK_H___
#define __CSITELINK_H___


class CSiteLinkObj
{
public:
    CSiteLinkObj(    
        const CSiteObj* pNeighbor1, 
        const CSiteObj* pNeighbor2,
        DWORD cost
        );

    
    BOOL 
    IsSiteLinkBetween(
        const CSiteObj* pNeighbor1,
        const CSiteObj* pNeighbor2
        ) const;

    
    void AddSiteGates(const CMachineObj* pMachine) 
    { 
        m_SiteGates.push_back(pMachine); 
    };


    const MachineList& GetSiteLinkGates(void) const 
    {
        return m_SiteGates; 
    };


    const GUID& GetSiteLinkId(void) const
    {
        return m_Id;
    }

    const CSiteObj* GetNeighbor1(void) const
    {
        return m_pNeighbor1;
    }


    const CSiteObj* GetNeighbor2(void) const
    {
        return m_pNeighbor2;
    }


    const MachineList& GetSiteGates(void) const
    {
        return m_SiteGates;
    }

    
    DWORD GetCost(void) const
    {
        return m_cost;
    }


private:
    GUID m_Id;
    const CSiteObj* m_pNeighbor1;
    const CSiteObj* m_pNeighbor2;
    MachineList m_SiteGates;
    DWORD m_cost;
};

inline
BOOL 
CSiteLinkObj::IsSiteLinkBetween(
    const CSiteObj* pNeighbor1,
    const CSiteObj* pNeighbor2
    ) const 
{
    return (((pNeighbor1 == m_pNeighbor1) && (pNeighbor2 == m_pNeighbor2)) ||
            ((pNeighbor1 == m_pNeighbor2) && (pNeighbor2 == m_pNeighbor1)));
}


struct sitelink_less : public std::binary_function<const CSiteLinkObj*, const CSiteLinkObj*, bool> 
{
    bool operator()(const CSiteLinkObj* k1, const CSiteLinkObj* k2) const
    {
        return ((k1->GetSiteLinkId() == k2->GetSiteLinkId()) ? false : true);
    }
};


class DBSiteLink
{
public:
    DBSiteLink() :
      m_it(m_SiteLink.begin())
    {
    }


    void AddSiteLink(CSiteLinkObj* pSite) 
    { 
        m_SiteLink.insert(pSite); 
    };


    const CSiteLinkObj* GetFirstSiteLink(void) const
    {
        m_it = m_SiteLink.begin();
        if (m_it != m_SiteLink.end())
            return *m_it;

        return NULL;
    }


    const CSiteLinkObj* GetNextSiteLink(void) const
    {
        ++m_it;
        if (m_it != m_SiteLink.end())
            return *m_it;

        return NULL;
    }


private:
    typedef std::set<const CSiteLinkObj*, sitelink_less> SiteLinkMap;

    SiteLinkMap m_SiteLink;
    mutable SiteLinkMap::const_iterator m_it;
};


extern DBSiteLink g_siteLinkDataBase;

#endif //__CSITELINK_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\test\csitelink.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    csitelink.cpp

Abstract:
    DS stub - site-link object implementation

Author:
    Uri Habusha (urih) 10-Apr-2000

Environment:
    Platform-independent

--*/

#include "libpch.h"
#include "dsstub.h"
#include "dsstubp.h"

#include "csitelink.tmh"

using namespace std;

DBSiteLink g_siteLinkDataBase;


CSiteLinkObj::CSiteLinkObj(
    const CSiteObj* pNeighbor1, 
    const CSiteObj* pNeighbor2,
    DWORD cost
    ) :
    m_pNeighbor1(pNeighbor1),
    m_pNeighbor2(pNeighbor2),
    m_cost(cost)
{
    UuidCreate(&m_Id);
}



enum SiteLinkPropValue
{
    eNeighbor1,
    eNeighbor2,
    eCost,
    eGates
};


PropertyValue SiteLinkProperties[] = {
    { L"PROPID_L_NEIGHBOR1",      eNeighbor1 },
    { L"PROPID_L_NEIGHBOR2",      eNeighbor2 },
    { L"PROPID_L_COST",           eCost },
    { L"PROPID_L_GATES",          eGates },
};


static
void 
ParseSiteGates(
    CSiteLinkObj* pSiteLink, 
    wstring& SiteGates,
    CSiteObj* pNeighbor1, 
    CSiteObj* pNeighbor2
    )
{
    while(!SiteGates.empty())
    {
        wstring siteGateName = GetNextNameFromList(SiteGates);

        if (!siteGateName.empty())
        {
            CMachineObj* pMachine = const_cast<CMachineObj*>(FindMachine(siteGateName));
            if (pMachine == NULL)
            {
                printf(" Site Gate machine %s doesn't exist.\n", siteGateName);
                continue;
            }
            
            pSiteLink->AddSiteGates(pMachine);
            if  (pMachine->IsBelongToSite(pNeighbor1))
            {
                pNeighbor1->AddSiteGate(pMachine);
            }
            else
            {
                if (pMachine->IsBelongToSite(pNeighbor2))
                {
                    pNeighbor2->AddSiteGate(pMachine);
                }
                else
                {
                    FileError("Site Gate Machine doesn't belong to any of the sites");
                }
            }
        }
    }
}


void CreateSiteLinkObject(void)
{
    DWORD Cost =1;
    wstring Neighbor1;
    wstring Neighbor2;
    wstring SiteGates;

    GetNextLine(g_buffer);
    while(!g_buffer.empty())
    {
        //
        // New object
        //
        if (g_buffer.compare(0,1,L"[") == 0)
            break;

        wstring PropName;
        wstring PropValue;
        if (!ParsePropertyLine(g_buffer, PropName, PropValue))
        {
            GetNextLine(g_buffer);
            continue;
        }

        switch(ValidateProperty(PropName, SiteLinkProperties, TABLE_SIZE(SiteLinkProperties)))
        {
            case  eNeighbor1:
                Neighbor1 = PropValue;
                RemoveBlanks(Neighbor1);
                break;

            case  eNeighbor2:
                Neighbor2 = PropValue;
                RemoveBlanks(Neighbor2);
                break;

            case eCost:
                Cost = _wtoi(PropValue.c_str());
                break;

            case eGates:
                SiteGates = PropValue;
                break;

            default:
                ASSERT(0);
        }
        GetNextLine(g_buffer);
    }

    if (Neighbor1.empty() || Neighbor2.empty())
    {
        FileError("Neighbor1 & Negihbor2 are mandatory for Site Link. Ignore the site Link");
        return;
    }

    CSiteObj* pNeighbor1 = const_cast<CSiteObj*>(FindSite(Neighbor1)); 
    CSiteObj* pNeighbor2 = const_cast<CSiteObj*>(FindSite(Neighbor2));
    
    if ((pNeighbor1 == NULL) || (pNeighbor2 == NULL))
    {
        FileError("Illegal Site member");
        return;
    }

    
    CSiteLinkObj* pSiteLink = const_cast<CSiteLinkObj*>(pNeighbor1->GetSiteLink(pNeighbor2));

    if(pSiteLink == NULL)
    {
        pSiteLink = new CSiteLinkObj(pNeighbor1, pNeighbor2, Cost);

        pNeighbor1->AddSiteLink(pSiteLink);
        pNeighbor2->AddSiteLink(pSiteLink);

        g_siteLinkDataBase.AddSiteLink(pSiteLink);
    }

    //
    // Parse the Site Gates
    //
    ParseSiteGates(pSiteLink, SiteGates, pNeighbor1, pNeighbor2);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\test\csite.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
  csite.h

Abstract:
    DS Stub site object interface

Author:
    Uri Habusha (urih), 11-Apr-2000

--*/

#pragma once

#ifndef __CSITE_H___
#define __CSITE_H___


class CSiteObj
{
public:
    CSiteObj(
        std::wstring name, 
        bool fForeign
        );

    void
    GetProperties(
        DWORD cp,
        const PROPID aProp[],
        PROPVARIANT aVar[] 
        ) const;

    const std::wstring& GetSiteName(void) const 
    {
        return m_Name;
    };


    const GUID& GetSiteId(void) const
    { 
        return m_Id; 
    };


    void AddSiteGate(CMachineObj* pMachine) 
    { 
        m_SiteGates.push_back(pMachine); 
    };


    void AddMachine(CMachineObj* pMachine) 
    { 
        m_Machines.push_back(pMachine); 
    };


    void AddSiteLink(CSiteLinkObj* pSiteLink) 
    {
        m_SiteLink.push_back(pSiteLink); 
    };


    bool IsForeign(void) const 
    { 
        return m_fForeign; 
    };

    
    const MachineList& GetSiteMachines(void) const
    {
        return m_Machines;
    }


    const CSiteLinkObj* GetSiteLink(CSiteObj* pNeighbor);
private:
    std::wstring m_Name;
    GUID m_Id;
    MachineList m_SiteGates;
    MachineList m_Machines;
    SiteLinkList m_SiteLink;

    bool m_fForeign;
};

class DBSite
{
public:
    void AddSite(CSiteObj* pSite) 
    { 
        m_Sites[pSite->GetSiteName()] = pSite; 
    };

    const CSiteObj* GetFirstSite(void) const
    {
        m_it = m_Sites.begin();
        if (m_it != m_Sites.end())
            return m_it->second;

        return NULL;
    }


    const CSiteObj* GetNextSite(void) const
    {
        ++m_it;
        if (m_it != m_Sites.end())
            return m_it->second;

        return NULL;
    }


    const CSiteObj* FindSite(const std::wstring& SiteName) const;
    const CSiteObj* FindSite(const GUID& pSiteId) const;

private:
    typedef std::map<std::wstring, const CSiteObj*> SiteMap;

    SiteMap m_Sites;
    mutable SiteMap::const_iterator m_it;
};

extern DBSite g_siteDataBase;


#endif //__CSITE_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\test\dsstub.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    dsstub.cpp

Abstract:
    DS stub - intilization

Author:
    Uri Habusha (urih) 10-Apr-2000

Environment:
    Platform-independent

--*/

#include "libpch.h"
#include "dsstub.h"
#include "dsstubp.h"

#include "dsstub.tmh"

using namespace std;

enum ObjectTypes              
{
    eSite = 1,
    eMachine,
    eSiteLink,
    eNone
};

PropertyValue ObjectType[] = {
    { L"[site]",      eSite },
    { L"[machine]",   eMachine },
    { L"[sitelink]",    eSiteLink }
};


inline ObjectTypes GetObjectType(const wstring& buffer)
{
    return static_cast<ObjectTypes>(ValidateProperty(buffer, ObjectType, TABLE_SIZE(ObjectType)));
}

void
DSStubInitialize(
    LPCWSTR InitFilePath
    )
{
    DspIntialize(InitFilePath);

    GetNextLine(g_buffer);
    while (!g_buffer.empty())
    {
        switch (GetObjectType(g_buffer))
        {
            case eSite:
                CreateSiteObject();
                break;

            case eMachine:
                CreateMachineObject();
                break;

            case eSiteLink:
                CreateSiteLinkObject();
                break;

            default:
                FileError("Illegal Object Type");
                throw exception();

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\test\dsstub.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
  dsstub.h

Abstract:
  DS Stub interface

Author:
    Uri Habusha (urih), 11-Apr-2000

--*/

#pragma once 

#ifndef __DSSTUB_H__
#define __DSSTUB_H__

void
DSStubInitialize(
    LPCWSTR InitFilePath
    );


const GUID& GetMachineId(LPCWSTR MachineName);
void RemoveLeadingBlank(std::wstring& str);
void RemoveTralingBlank(std::wstring& str);


inline void RemoveBlanks(std::wstring& str)
{
    RemoveLeadingBlank(str);
    RemoveTralingBlank(str);
};


#endif // __DSSTUB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\test\dsstubp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
  dsstubp.h

Abstract:
    DS Stub private functions definition

Author:
    Uri Habusha (urih), 11-Apr-2000

--*/

#pragma once

#ifndef __DSSTUBP_H__
#define __DSSTUBP_H__



class CSiteObj;
typedef std::list<const CSiteObj*>  SiteList;

class CMachineObj;
typedef std::list<const CMachineObj*>  MachineList;

class CSiteLinkObj;
typedef std::list<const CSiteLinkObj*> SiteLinkList;


#include "csite.h"
#include "cmachine.h"
#include "csitelink.h"


extern std::wstring g_buffer;

struct PropertyValue
{
    WCHAR PropName[32];
    DWORD PropValue;
};


void 
DspIntialize(
    LPCWSTR InitFilePath
    );

void 
FileError(
    LPSTR msg
    );

void 
GetNextLine(
    std::wstring& buffer
    );

DWORD 
ValidateProperty(
    std::wstring buffer, 
    PropertyValue propValue[], 
    DWORD noProps
    );

void 
RemoveLeadingBlank(
    std::wstring& str
    );

void 
RemoveTralingBlank(
   std::wstring& str
   );


BOOL 
ParsePropertyLine(
    std::wstring& buffer,
    std::wstring& PropName,
    std::wstring& PropValue
    );


std::wstring 
GetNextNameFromList(
    std::wstring& strList
    );


void 
CreateSiteObject(
    void
    );

void 
CreateMachineObject(
    void
    );

void 
CreateSiteLinkObject(
    void
    );

const CSiteObj* 
FindSite(
    const std::wstring& SiteName
    );

const CSiteObj* 
FindSite(
    const GUID& pSiteId
    );

const CMachineObj* 
FindMachine(
    const std::wstring& MachineName
    );

const CMachineObj* 
FindMachine(
    const GUID& pMachineId
    );


#endif //__DSSTUBP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\test\dsstubp.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    dsstubp.cpp

Abstract:
    DS stub - private routines using for reading the ini file

Author:
    Uri Habusha (urih) 10-Apr-2000

Environment:
    Platform-independent

--*/

#include "libpch.h"
#include "dsstub.h"
#include "dsstubp.h"

#include "dsstubp.tmh"

using namespace std;

wstring g_buffer;
DWORD lineNo = 0;
wfstream iFile;


DWORD 
ValidateProperty(
    wstring buffer, 
    PropertyValue propValue[],
    DWORD noProps
    )
{
    WCHAR* str1 = const_cast<WCHAR*>(buffer.data());
    for (DWORD i =0; i < noProps; ++i)
    {
        if (_wcsnicmp(str1, propValue[i].PropName, wcslen(propValue[i].PropName)) != 0)
            continue;

        wstring temp = buffer.substr(wcslen(propValue[i].PropName));
        if (temp.find_first_not_of(L" \t") == temp.npos)
            return propValue[i].PropValue;
    }

    TrERROR(ROUTING,"Illegal or Unsuported Property %ls",  str1);
    throw exception();
}

void RemoveLeadingBlank(wstring& str)
{
    DWORD_PTR pos = str.find_first_not_of(L" \t");
    if (pos != str.npos)
    {
        str = str.substr(pos);
        return;
    }

    str.erase();
}

void RemoveTralingBlank(wstring& str)
{
    DWORD_PTR endpos = str.find_first_of(L" \t");
    str = str.substr(0, endpos);
}

void GetNextLine(wstring& buffer)
{
    buffer.erase();
    while (!iFile.eof())
    {
        ++lineNo;

        getline(iFile, buffer);

        RemoveLeadingBlank(buffer);

        //
        // Ignore blank line
        //
        if (buffer.empty())
            continue;

        //
        // ignore comment
        //
        if (buffer.compare(0,2,L"//") == 0)
            continue;

        return;
    }
}


void
DspIntialize(
    LPCWSTR InitFilePath
    )
{
    char filePath[256];
    sprintf(filePath, "%ls", InitFilePath);

    iFile.open(filePath, ios::in);
    if (!iFile.is_open())
    {
        printf("Open DS initialization file Failed. %s\n", strerror(errno));
        throw exception();
    }

    lineNo = 0;
}


void FileError(LPSTR msg)
{
    TrERROR(ROUTING, "%s. Line %d", msg, lineNo);
}


BOOL 
ParsePropertyLine(
    wstring& buffer,
    wstring& PropName,
    wstring& PropValue
    )
{
    //
    // line must be <property_name> = <property_value>
    //
    DWORD_PTR pos = buffer.find_first_of(L"=");
    if (pos == g_buffer.npos)
    {
        FileError("wrong site propery - Ignore it");
        return FALSE;
    }

    PropName = buffer.substr(0, pos-1);
    PropValue = buffer.substr(g_buffer.find_first_not_of(L" \t", pos+1));
    if(PropValue.empty())
    {
        FileError("wrong site propery - Ignore it");
        return FALSE;
    }
    
    return TRUE;
}

wstring
GetNextNameFromList(
      wstring& strList
      )
{
    wstring str;

    DWORD_PTR CommaPos = strList.find_first_of(L",");
    str = strList.substr(0, CommaPos);

    if (CommaPos == strList.npos)
    {
        strList.erase();
    }
    else
    {
        strList = strList.substr(CommaPos+1);
    }

    RemoveBlanks(str);
    return str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\test\rdad.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    rdad.cpp

Abstract:
    Implemntation of Routing decision active directory routine. 

Author:
    Uri Habusha (urih) 10-Apr-2000

Environment:
    Platform-independent

--*/

#include "libpch.h"
#include "Rd.h"
#include "Rdp.h"
#include "RdDs.h"
#include "RdAd.h"
#include "dsstub.h"
#include "dsstubp.h"
#include "mqprops.h"

#include "rdad.tmh"

const GUID& GetMachineId(LPCWSTR MachineName)
{
    const CMachineObj* pMachine = FindMachine(MachineName);
    if (pMachine == NULL)
    {
        TrERROR(ROUTING, "Failed to featch information for %ls machine", MachineName);
        throw exception();
    }

    return pMachine->GetMachineId();
}


void
RdpGetMachineData(
    const GUID& id, 
    CACLSID& siteIds,
    CACLSID& outFrss,
    CACLSID& inFrss,
    LPWSTR* pName,
    bool* pfFrs,
    bool* pfForeign
    )
{
    PROPVARIANT aVar[10];
    PROPID      aProp[10];
    DWORD cProp = 0;

    aVar[cProp].vt = VT_NULL;
    aProp[cProp] = PROPID_QM_SITE_IDS;
    ++cProp;

    aVar[cProp].vt = VT_NULL;
    aProp[cProp] = PROPID_QM_OUTFRS;
    ++cProp;

    aVar[cProp].vt = VT_NULL;
    aProp[cProp] = PROPID_QM_INFRS;
    ++cProp;

    aVar[cProp].vt = VT_NULL;
    aProp[cProp] = PROPID_QM_PATHNAME;
    ++cProp;

    aVar[cProp].vt = VT_NULL;
    aProp[cProp] = PROPID_QM_SERVICE_ROUTING;
    ++cProp;

    aVar[cProp].vt = VT_NULL;
    aProp[cProp] = PROPID_QM_FOREIGN;
    ++cProp;

    const CMachineObj* pMachine = FindMachine(id);
    pMachine->GetProperties(cProp, aProp, aVar);

    siteIds = aVar[0].cauuid;
    outFrss = aVar[1].cauuid;
    inFrss = aVar[2].cauuid;
    *pName = aVar[3].pwszVal;
    *pfFrs = (aVar[4].bVal == TRUE);
    *pfForeign = (aVar[5].bVal == TRUE);
}



void
RdpGetSiteData(
    const GUID& id, 
    bool* pfForeign,
    LPWSTR* pName
    )
{
    PROPVARIANT aVar[2];
    PROPID aProp[2];
    
    aVar[0].vt = VT_NULL;
    aProp[0] = PROPID_S_FOREIGN;

    aVar[1].vt = VT_NULL;
    aProp[1] = PROPID_S_PATHNAME;

    const CSiteObj* pSite = FindSite(id);
    pSite->GetProperties(2, aProp, aVar);

    *pfForeign = (aVar[0].bVal == TRUE);
    *pName = aVar[1].pwszVal;
}


void 
RdpGetSiteLinks(
    SITELINKS& siteLinks
    )
{
    const CSiteLinkObj* pSiteLink = g_siteLinkDataBase.GetFirstSiteLink();

    while (pSiteLink != NULL)
    {
        GUID* firstSiteId = new GUID;
        *firstSiteId = pSiteLink->GetNeighbor1()->GetSiteId();

        GUID* secondSiteId = new GUID;
        *secondSiteId = pSiteLink->GetNeighbor2()->GetSiteId();

        const MachineList& LinkGatesMachine = pSiteLink->GetSiteGates();

        CACLSID LinkGates = {0, 0};
        if (!LinkGatesMachine.empty())
        {
            LinkGates.pElems = new GUID[LinkGatesMachine.size()];
            for (MachineList::iterator it = LinkGatesMachine.begin(); it != LinkGatesMachine.end(); ++it)
            {
                const CMachineObj* pMachine = *it;
                LinkGates.pElems[LinkGates.cElems] = pMachine->GetMachineId();
                ++LinkGates.cElems;
            }
        }

        R<CSiteLink> pLink = new CSiteLink(
                                        LinkGates,
                                        firstSiteId, 
                                        secondSiteId,
                                        pSiteLink->GetCost()
                                        );

        siteLinks.push_back(pLink);

        pSiteLink = g_siteLinkDataBase.GetNextSiteLink();
    }
}


void 
RdpGetSites(
    SITESINFO& sites
    )
{
    const CSiteObj* pSite = g_siteDataBase.GetFirstSite();

    while (pSite != NULL)
    {
        P<WCHAR> siteName = new WCHAR[pSite->GetSiteName().length() + 1];
        wcscpy(siteName, const_cast<LPWSTR>(pSite->GetSiteName().data()));

        CSite*  pSiteInfo = new CSite(pSite->GetSiteId());
        
        //
        // Add the site to the site list map
        //
        sites[&pSiteInfo->GetId()] = pSiteInfo;

        siteName.detach();

        pSite = g_siteDataBase.GetNextSite();
    }

}


void
RdpGetSiteFrs(
    const GUID& siteId,
    GUID2MACHINE& listOfFrs
    )
{
    const CSiteObj* pSite = FindSite(siteId);
    const MachineList& siteMachine = pSite->GetSiteMachines();

    for(MachineList::iterator it = siteMachine.begin(); it != siteMachine.end(); ++it)
    {
        const CMachineObj* pMachine = *it;

        if (pMachine->RoutingService())
        {
            CMachine* pRouteMachine = new CMachine;
            pRouteMachine->Update(pMachine->GetMachineId());

            listOfFrs[&pRouteMachine->GetId()] = pRouteMachine;
        }
    }
}


void
RdpGetConnectors(
    const GUID& site,
    CACLSID& connectorIds
    )
{
    const CSiteObj* pSite = FindSite(site);
    const MachineList& siteMachine = pSite->GetSiteMachines();

    DWORD NoOfConnector = 0;
    for(MachineList::iterator it = siteMachine.begin(); it != siteMachine.end(); ++it)
    {
        if ((*it)->RoutingService())
        {
            ++NoOfConnector;
        }
    }

    AP<GUID> pIds = new GUID[NoOfConnector];
    DWORD i = 0;

    for(MachineList::iterator it = siteMachine.begin(); it != siteMachine.end(); ++it)
    {
        const CMachineObj* pMachine = *it;

        if (pMachine->RoutingService())
        {
            pIds[i] = pMachine->GetMachineId();
            ++i;
        }
    }

    ASSERT(i == NoOfConnector);

    connectorIds.cElems = NoOfConnector;
    connectorIds.pElems = pIds.detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rd\test\rdtest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    RdTest.cpp

Abstract:
    Routing Decision library test

Author:
    Uri Habusha (urih) 10-Apr-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Rd.h"
#include "dsstub.h"

#include "RdTest.tmh"

using namespace std;


const DWORD RoutingRebuildInterval = 60 * 1000;
static GUID s_SourceMachineId;

const GUID&
McGetMachineID(
    void
    )
{
    return s_SourceMachineId;
}



static void Usage()
{
    printf("Usage: RdTest <test ini file> \n");
    printf("\ttest ini file - Ini file that describes the DS, routing source and");
    printf("\t\tdestination and expected result");
    printf("\n");
    printf("Example, RdTest intarSiteRouting.ini\n");
    exit(-1);

} // Usage


bool 
GetTestParameters(
    LPCWSTR FilePath,
    LPWSTR DsIniFile,
    DWORD& NoOfTest,
    bool& fServer
    )
{
    
    GetPrivateProfileString(
        L"TestParameters",
        L"DSFile",
        L"ERROR",
        DsIniFile,
        256,
        FilePath
        );
    
    if(wcscmp(DsIniFile, L"ERROR") == 0)
        return false;
    
    WCHAR Buffer[256];
    GetPrivateProfileString(
        L"TestParameters",
        L"NoOfTest",
        L"ERROR",
        Buffer,
        256,
        FilePath
        );

    if(wcscmp(Buffer, L"ERROR") == 0)
        return false;

    NoOfTest = _wtol(Buffer);

    GetPrivateProfileString(
        L"TestParameters",
        L"RoutingType",
        L"ERROR",
        Buffer,
        256,
        FilePath
        );

    if(_wcsicmp(Buffer, L"SERVER") == 0)
    {
        fServer = true;
    }
    else if (_wcsicmp(Buffer, L"CLIENT") == 0)
    {
        fServer = false;
    }
    else
    {
        return false;
    }

    return true;
}


bool
GetRouteTestParameters(
    LPCWSTR FilePath,
    LPCWSTR TestAppl,
    wstring& SourceMachine,
    wstring& DestinationMachine,
    bool& fRouteTest
    )
{
    WCHAR Buffer[256];
    
    GetPrivateProfileString(
        TestAppl,
        L"source",
        L"ERROR",
        Buffer,
        256,
        FilePath
        );
    if(wcscmp(Buffer, L"ERROR") == 0)
        return false;
    
    SourceMachine = Buffer;

    GetPrivateProfileString(
        TestAppl,
        L"Destination",
        L"ERROR",
        Buffer,
        256,
        FilePath
        );
    if(wcscmp(Buffer, L"ERROR") == 0)
        return false;

    DestinationMachine = Buffer;

    //
    // Get test type. Can be route table or connector
    //
    fRouteTest = true;
    GetPrivateProfileString(
        TestAppl,
        L"TestType",
        L"ERROR",
        Buffer,
        256,
        FilePath
        );

    if(_wcsicmp(Buffer, L"CONNECTOR") == 0)
        fRouteTest = false;

    return true;
}


bool
CheckResult(
    wstring Expected,
    CRouteTable::RoutingInfo& routeInfo
    )
{
    DWORD NoOfMachines = 0;

    RemoveBlanks(Expected);
    DWORD PrevPos = (DWORD)(Expected.empty() ? Expected.npos : 0);

    while(PrevPos != Expected.npos)
    {
        DWORD_PTR pos = Expected.find_first_of(L',', PrevPos);
        wstring  RouteMachine= Expected.substr(PrevPos, (pos-PrevPos));
        RemoveBlanks(RouteMachine);
        PrevPos = (DWORD)(pos + ((pos != Expected.npos) ? 1 : 0)); 

        for(CRouteTable::RoutingInfo::iterator it = routeInfo.begin(); it != routeInfo.end(); ++it)
        {
            R<const CRouteMachine> pRoute = *it;
            if (_wcsicmp(pRoute->GetName(), RouteMachine.data()) == 0)
                break;
        }
        if (it == routeInfo.end())
            return false;

        ++NoOfMachines;
    }

    if (NoOfMachines != routeInfo.size())
        return false;

    return true;
}


void 
PrintRouteMachineName(
    const CRouteTable::RoutingInfo* routeInfo
    )
{
    for(CRouteTable::RoutingInfo::const_iterator it = routeInfo->begin(); it != routeInfo->end(); ++it)
    {
        printf("%ls ",(*it)->GetName());
    }
}


bool
GetExpectedResult(
    LPCWSTR FilePath,
    LPCWSTR TestAppl,
    wstring TestResult[2]
    )
{
    WCHAR Buffer[256];
    
    GetPrivateProfileString(
        TestAppl,
        L"firstPriority",
        L"ERROR",
        Buffer,
        256,
        FilePath
        );
    if(wcscmp(Buffer, L"ERROR") == 0)
        return false;
    
    TestResult[0] = Buffer;

    GetPrivateProfileString(
        TestAppl,
        L"SecondPriority",
        L"ERROR",
        Buffer,
        256,
        FilePath
        );
    if(wcscmp(Buffer, L"ERROR") != 0)
        TestResult[1] = Buffer;

    return true;
}


void
CheckTestResult(
    LPCWSTR TestFilePath,
    LPCWSTR TestAppl,
    CRouteTable& RouteTable
    )
{
    bool fTestPass = true;

    wstring ExpectedResult[2];
    bool fSucc = GetExpectedResult(
                    TestFilePath,
                    TestAppl,
                    ExpectedResult
                    );
    if (!fSucc)
    {
        TrERROR(ROUTING, "Can't retreive the test result for test %ls", TestAppl);
        throw exception();
    }

    bool f;
    f = CheckResult(ExpectedResult[0], *RouteTable.GetNextHopFirstPriority());
    if (!f)
    {
        fTestPass = false;
        printf("unmached result for first priority routing:\n");
        printf("\tExpected: %ls\n", ExpectedResult[0].data());
        printf("Getting Result:");
        PrintRouteMachineName(RouteTable.GetNextHopFirstPriority());
        printf("\n");
    }

    f = CheckResult(ExpectedResult[1], *RouteTable.GetNextHopSecondPriority());
    if (!f)
    {
        fTestPass = false;
        printf("unmached result for Second priority routing:\n");
        printf("\tExpected: %S\n", ExpectedResult[1].data());
        printf("\tGetting Result:");
        PrintRouteMachineName(RouteTable.GetNextHopSecondPriority());
        printf("\n");
    }

    if (fTestPass)
    {
        printf("TEST PASS\n");
    }
    else
    {
        printf("TEST FAILED\n");
        throw exception();
    }
}


void
CheckConnectorTestResult(
    LPCWSTR TestFilePath,
    LPCWSTR TestAppl,
    const GUID& ConnectorId
    )
{
    bool fTestPass = true;

    WCHAR ConnectorName[256];
    
    GetPrivateProfileString(
        TestAppl,
        L"ConnectorName",
        L"ERROR",
        ConnectorName,
        256,
        TestFilePath
        );
    if(wcscmp(ConnectorName, L"ERROR") == 0)
    {
        TrERROR(ROUTING, "Can't retreive the test result for test %ls", TestAppl);
        throw exception();
    }

    if (GetMachineId(ConnectorName) != ConnectorId)
    {
        fTestPass = false;
        printf("unmached result for Connector machine:\n");
        printf("\tExpected: %ls\n", ConnectorName);
        printf("\n");
    }

    if (fTestPass)
    {
        printf("TEST PASS\n");
    }
    else
    {
        printf("TEST FAILED\n");
        throw exception();
    }
}


extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
/*++

Routine Description:
    Test Routing Decision library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

    if (argc != 2)
        Usage();

    TrInitialize();

    //
    // convert ini file name from UNICODE to ACII
    //
    WCHAR DsIniFile[256];
    DWORD NoOfTest;
    bool fServer;
    bool fSucc = GetTestParameters(argv[1], DsIniFile, NoOfTest, fServer);
    if(!fSucc)
    {
        TrERROR(ROUTING, "Wrong test ini file. Can't find DS init file or Number of tests");
        exit(-1);
    }

    try
    {
        DSStubInitialize(DsIniFile);
    }
    catch (const exception&)
    {
        TrERROR(ROUTING, "Failed to initialize the DS stub. Please Check the Ini file %ls", DsIniFile);
        return -1;
    }

    CTimeDuration rebuildInterval(RoutingRebuildInterval* CTimeDuration::OneMilliSecond().Ticks());
    RdInitialize(fServer, rebuildInterval);

    wstring PrevSourceMachine;
    try
    {
        for(DWORD TestIndex = 1;TestIndex <= NoOfTest; ++TestIndex)
        {
            WCHAR TestAppl[30];
            swprintf(TestAppl, L"Test%d", TestIndex);

            //
            // Get the Source Machine from test ini file
            //
            wstring SourceMachine;
            wstring DestinationMachine;
            bool fRouteTest;
            bool fSucc = GetRouteTestParameters(
                            argv[1],
                            TestAppl,
                            SourceMachine,
                            DestinationMachine,
                            fRouteTest
                            );

            if (!fSucc)
            {
                TrERROR(ROUTING, "Failed to retrieve test parameters. File: %ls", argv[1]); 
                return -1;
            }

            //
            // Replace the current Machine ID in the registery with the 
            // test source machine ID
            //
            s_SourceMachineId = GetMachineId(SourceMachine.data());
            GUID DestinationMachineId = GetMachineId(DestinationMachine.data());

            printf("\n Test%d\n=================\n", TestIndex);


            //
            // Check if the routing Dtat-structure need to rebuild,
            // since we changed the source machine
            //
                            RdRefresh();
/*
            if (wcscmp(PrevSourceMachine.data(), SourceMachine.data()) != 0)
            {
                RdRefresh();

                //
                // Store the current source machine
                //
                PrevSourceMachine = SourceMachine;
            }
*/

            if (fRouteTest)
            {
                printf("Get a route Table from %S to %S...\n", 
                            SourceMachine.data(), DestinationMachine.data());
                CRouteTable RouteTable;
                RdGetRoutingTable(DestinationMachineId, RouteTable);

                CheckTestResult(
                    argv[1],
                    TestAppl,
                    RouteTable
                    );

                continue;
            }

            printf("Get connctor to route from %S to %S...\n", 
                        SourceMachine.data(), DestinationMachine.data());

            GUID ConnectorId;
            RdGetConnector(DestinationMachineId, ConnectorId);
            
            CheckConnectorTestResult(argv[1], TestAppl, ConnectorId);

        }
    }
    catch(const exception&)
    {
        TrERROR(ROUTING, "Failed to calculate the routing table");
        return -1;
    }

    WPP_CLEANUP();
    return 0;

} // _tmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\chrclass.cpp ===
/****************************************************************************/
/*  File:       chrclass.cc                                                 */
/*  Author:     J. Kanze                                                    */
/*  Date:       04/03/91                                                    */
/* ------------------------------------------------------------------------ */
/*  Modified:   14/04/92    J. Kanze                                        */
/*      Converted to CCITT naming conventions.                              */
/*  Modified:   13/06/2000  J. Kanze                                        */
/*      Ported to current library conventions, iterators.                   */
/* ------------------------------------------------------------------------ */

#include <libpch.h>
#include <inc/setofchr.h>
#include <inc/message.h>
#include <inc/iteristr.h>
#include <inc/ios.h>
#include <errno.h>

#include "chrclass.tmh"

//      The parser is not really very OO -- just a classical recursive
//      decent parser.  I suppose that with the rewrite (13/06/2000),
//      I could have changed this, but it works.  So all I did was add
//      support for the named character categories (which didn't exist
//      when I originally wrote the code).

CRexCharClass::CRexCharClass( std::istream& source )
{
    parse( source ) ;
}

CRexCharClass::CRexCharClass( char const* ptr )
{
    CRexIteratorIstream< char const* > source( ptr , ptr + strlen( ptr ) ) ;
    parse( source ) ;
    if( good() && source.get() != REX_eof )
    {
        status = extraCharacters ;
        clear() ;
    }
}

CRexCharClass::CRexCharClass( std::string const& src )
{
    CRexIteratorIstream< std::string::const_iterator >
    source( src.begin() , src.end() ) ;
    parse( source ) ;
    if( good() && source.get() != REX_eof )
    {
        status = extraCharacters ;
        clear() ;
    }
}

std::string
CRexCharClass::errorMsg( Status errorCode )
{
    static char const *const
    messages[] =
    {
        "" ,
        "extra characters at end of string" ,
        "illegal escape sequence" ,
        "numeric overflow in octal or hex escape sequence" ,
        "missing hex digits after \\x" ,
        "illegal range specifier" ,
        "closing ] not found" ,
        "unknown character class specifier" ,
        "empty string"
    } ;
    ASSERT( static_cast< unsigned >( errorCode ) < TABLE_SIZE( messages ) ); //CRexCharClass: Impossible value for error code
    return(s_rex_message.get( messages[ errorCode ] ) );
}

// ==========================================================================
//      setNumericEscape:
//      =================
//
//      This routine is invoked for the numeric escape sequences (\x,
//      \[0-7]), once the relevant characters have been extracted.  It
//      converts the characters to a numeric value, and if the
//      conversion is successful *and* the value is in the range
//      [0..UCHAR_MAX], sets the corresponding character.  Otherwise,
//      sets an error.
// --------------------------------------------------------------------------
void
CRexCharClass::setNumericEscape( std::string const& chrs , int base )
{
    errno = 0 ;
    unsigned long       tmp = strtoul( chrs.c_str() , NULL , base ) ;
    if( errno != 0 || tmp > UCHAR_MAX )
    {
        status = overflowInEscapeSequence ;
    }
    else
    {
        set( static_cast< unsigned char >( tmp ) ) ;
    }
}

// ==========================================================================
//      escapedChar:
//      ============
//
//      This routine is designed to handle the various escape
//      sequences defined in the ISO C standard.
//
//      If no error is encountered, it will set the corresponding
//      character, advance the stream to the first character following
//      the escape sequence, and leave the status unchanged.
//
//      If an error is encountered, the pointer is advanced to the
//      character causing the error, and the status is set to the
//      error.
//
//      This routine is much simpler than its length (and its MacCabe
//      complexity) would indicate.  Basically, it is just a big
//      switch.  (Most of it could be written as a look-up loop, but
//      although this would make the code somewhat shorter, and reduce
//      the MacCabe complexity considerably, I don't think that it
//      would actually make the code any clearer, and it would
//      certainly not help performance.)
// --------------------------------------------------------------------------
void
CRexCharClass::escapedChar( std::istream& source )
{
    int                 ch = source.get() ;
    switch( ch )
    {
        case 'A' :
        case 'a' :
            set( '\a' ) ;
            break ;

        case 'B' :
        case 'b' :
            set( '\b' ) ;
            break ;

        case 'F' :
        case 'f' :
            set( '\f' ) ;
            break ;

        case 'N' :
        case 'n' :
            set( '\n' ) ;
            break ;

        case 'R' :
        case 'r' :
            set( '\r' ) ;
            break ;

        case 'T' :
        case 't' :
            set( '\t' ) ;
            break ;

        case 'V' :
        case 'v' :
            set( '\v' ) ;
            break ;

        case 'X' :
        case 'x' :
            {
                std::string      buf ;
                while( isxdigit( source.peek() ) )
                {
                    buf.append( 1 , static_cast< char >( source.get() ) ) ;
                }
                if( buf.size() == 0 )
                {
                    status = missingHexDigits ;
                }
                else
                {
                    setNumericEscape( buf , 16 ) ;
                }
            }
            break ;

        case '0' :
        case '1' :
        case '2' :
        case '3' :
        case '4' :
        case '5' :
        case '6' :
        case '7' :
            {
                std::string      buf( 1 , static_cast< char >( ch ) ) ;
                while( buf.size() < 3
                       && source.peek() >= '0'
                       && source.peek() < '8' )
                {
                    buf.append( 1 , static_cast< char >( source.get() ) ) ;
                }
                setNumericEscape( buf , 8 ) ;
            }
            break ;

        default :
            if( ch == REX_eof )
            {
                status = unexpectedEndOfFile ;
            }
            else
            {
                if( isalnum( ch ) )
                {
                    status = illegalEscapeSequence ;
                }
                else
                {
                    set( static_cast< unsigned char >( ch ) ) ;
                }
            }
            break ;
    }
}

// ==========================================================================
//      setExplicitRange:
//      =================
//
//      Sets a literal character range.
// --------------------------------------------------------------------------
static int
__cdecl isBlank( int ch )
{
    return(ch == ' ' || ch == '\t' );
}

void
CRexCharClass::setExplicitRange( std::string const& rangeName )
{
    typedef int (__cdecl* Handler)( int ) ;
    class ExplicitRangeMap
    {
        typedef std::map< std::string , Handler >
        Map ;
    public:
        ExplicitRangeMap()
        {
            myMap[ "alnum" ] = &isalnum ;
            myMap[ "alpha" ] = &isalpha ;
            myMap[ "blank" ] = &isBlank ;
            myMap[ "cntrl" ] = &iscntrl ;
            myMap[ "digit" ] = &isdigit ;
            myMap[ "graph" ] = &isgraph ;
            myMap[ "lower" ] = &islower ;
            myMap[ "print" ] = &isprint ;
            myMap[ "punct" ] = &ispunct ;
            myMap[ "space" ] = &isspace ;
            myMap[ "upper" ] = &isupper ;
            myMap[ "xdigit" ] = &isxdigit ;
        }
        Handler   operator[]( std::string const& key ) const
        {
            Map::const_iterator entry = myMap.find( key ) ;

            return(entry == myMap.end() ? NULL
                  : entry->second );
        }
    private:
        Map                 myMap ;
    } ;

    static ExplicitRangeMap const map ;
    int (__cdecl*  handler)( int ) = map[ rangeName ] ;

    if( handler == NULL )
    {
        status = unknownCharClassSpec ;
    }
    else
    {
        for( int j = 0 ; j <= UCHAR_MAX ; ++ j )
        {
            if( (*handler)( j ) )
            {
                set( static_cast< unsigned char >( j ) ) ;
            }
        }
    }
}

// ==========================================================================
//      setRange:
//      =========
//
//      Determine a range of values and set them.  Range must be
//      valid.
// --------------------------------------------------------------------------
void
CRexCharClass::setRange( unsigned char first , unsigned char last )
{
    static char const *const
    tbl[] =
    {
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ" ,
        "abcdefghijklmnopqrstuvwxyz" ,
        "0123456789" ,
    } ;

    //      Try and find the first character in the table.
    // ----------------------------------------------------------------------
    char const*         begin = NULL ;
    for( unsigned i = 0 ; begin == NULL && i < TABLE_SIZE( tbl ) ; ++ i )
    {
        begin = strchr( tbl[ i ] , first ) ;
    }

    //      The first is not in table, an error.
    // ----------------------------------------------------------------------
    if( begin == NULL || *begin == '\0' )
    {
        status = illegalRangeSpecifier ;
    }
    else
    {
        //      More difficult: the second must be in the same list as
        //      the first, and come after it.
        // ------------------------------------------------------------------
        char const*         end = strchr( begin , last ) ;
        if( end == NULL || *end == '\0' )
        {
            status = illegalRangeSpecifier ;
        }
        else
        {
            set( std::string( begin , end + 1 ) ) ;
        }
    }
}

// ==========================================================================
//      parseCharClass:
//      ===============
//
//      Parse a character class expression.
//
//      On entrance: ptr should point to the opening bracket of a
//      character class, the bit vector should be empty, and status
//      should be set to ok.
//
//      If all goes well, on return: the ptr will be advanced to the
//      first character following the class, the bit vector will
//      represent the set of characters designated by the class, and
//      status will be unmodified.
//
//      If an error is detected, the ptr will be positioned on the
//      character where the error was detected, the contents of the
//      bit vector will be undefined, and status will contain the
//      error code.
// --------------------------------------------------------------------------

void
CRexCharClass::parseCharClass( std::istream& source )
{
    int                 ch = source.get() ;

    //      Check for a negated character class.
    // ----------------------------------------------------------------------
    bool                negated = false ;
    if( ch == '^' && source.peek() != ']' )
    {
        negated = true ;
        ch = source.get() ;
    }

    //      Loop over all of the characters in the class.
    // ----------------------------------------------------------------------
    do
    {
        //      End of string before closing ']', must be error.
        // ------------------------------------------------------------------
        if( ch == REX_eof )
        {
            status = unexpectedEndOfFile ;
        }

        //      Escape character, use escapedChar to get the escape
        //      sequence.
        // ------------------------------------------------------------------
        else if( ch == REX_asciiEsc )
        {
            escapedChar( source ) ;
        }

        //      Explicit character class.
        // ------------------------------------------------------------------
        else if( ch == ':' )
        {
            std::string      spec ;
            while( islower( source.peek() ) )
            {
                spec.append( 1 , static_cast< char >( source.get() ) ) ;
            }
            if( source.peek() != ':' )
            {
                set( ':' ) ;
                set( spec ) ;
            }
            else
            {
                source.get() ;          // Skip trailing ':'
                setExplicitRange( spec ) ;
            }
        }

        //      Range specifier: this is where the fun starts.  (Note
        //      that we want this to work independantly of the code
        //      set, and that in EBCDIC, amongst others, the letters
        //      are *not* sequential.)
        // ------------------------------------------------------------------
        else if( source.peek() == '-' )
        {
            source.get() ;
            if( source.peek() == REX_eof )
            {
                status = unexpectedEndOfFile ;
            }
            else if( source.peek() == ']' )
            {
                set( static_cast< unsigned char >( ch ) ) ;
                set( '-' ) ;
            }
            else
            {
                setRange( (unsigned char)ch , (unsigned char)source.get() ) ;
            }
        }
        else
        {
            set( static_cast< unsigned char >( ch ) ) ;
        }
        ch = source.get() ;
    } while( status == ok && ch != ']' ) ;

    //      If the class was negated, do the same for the set.
    // ----------------------------------------------------------------------
    if( negated )
    {
        complement() ;
    }
}

void
CRexCharClass::parse( std::istream& source )
{
    status = ok ;
    int                 ch = source.get() ;
    switch( ch )
    {
        case '[' :
            parseCharClass( source ) ;
            break ;

        case REX_asciiEsc :
            escapedChar( source ) ;
            break ;

//      case '?' :
//          parseTrigraph( *this , source ) ;
//          break ;

        default :
            if( ch == REX_eof )
            {
                status = emptySequence ;
            }
            else
            {
                set( static_cast< unsigned char >( ch ) ) ;
            }
            break ;
    }

    if( status != ok )
    {
        source.setstate( std::ios::failbit ) ;
        clear() ;
    }
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\message.cpp ===
/****************************************************************************/
/*  File:       message.cc                                                  */
/*  Author:     J. Kanze                                                    */
/*  Date:       04/01/1996                                                  */
/*      Copyright (c) 1996 James Kanze                                      */
/* ------------------------------------------------------------------------ */

#include <libpch.h>
#include <inc/message.h>

CRexMessageImpl*     CRexMessage::ourImpl ;

#include "message.tmh"

//      Implementation par defaut :
//      ===========================
//
//      Dans un monde ideal, le suivant ne serait pas necessaire.
//      Malheureusement... Pour l'instant, je n'ai pas encore eu le
//      temps de faire une veritable implementation, alors, on utilise
//      l'implementation triviale.
// --------------------------------------------------------------------------

#ifndef REX_IMPLEMENTED

class CRexMessageImpl
{
public:
                        CRexMessageImpl() ;
    std::string      get( std::string const& msgId ) const ;
} ;

CRexMessageImpl::CRexMessageImpl()
{
}

std::string
CRexMessageImpl::get( std::string const& msgId ) const
{
    return msgId ;
}
#endif

CRexMessage::CRexMessage()
{
    if ( ourImpl == NULL ) {
        ourImpl = new CRexMessageImpl ;
    }
}

std::string
CRexMessage::get( std::string const& msgId ) const throw()
{
    return ourImpl->get( msgId ) ;
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\bitvimpl.cpp ===
/****************************************************************************/
/*  File:       bitvimpl.cc                                                 */
/*  Author:     J. Kanze                                                    */
/*  Date:       06/01/1994                                                  */
/*      Copyright (c) 1994 James Kanze                                      */
/* ------------------------------------------------------------------------ */

#include <libpch.h>
#include <inc/bitvimpl.h>
#include <ctype.h>

#include "bitvimpl.tmh"

CBitVectorImpl::BitIndex const
                    CBitVectorImpl::infinity
    = ~ static_cast< CBitVectorImpl::BitIndex >( 0 ) ;

inline CBitVectorImpl::BitIndex
CBitVectorImpl::byteIndex( BitIndex bitNo )
{
    return bitNo / bitsPerByte ;
}

inline CBitVectorImpl::BitIndex
CBitVectorImpl::bitInByte( BitIndex bitNo )
{
    return bitNo % bitsPerByte ;
}

inline CBitVectorImpl::BitIndex
CBitVectorImpl::byteCount( BitIndex bitCount )
{
    return (bitCount / bitsPerByte) + (bitCount % bitsPerByte != 0 ) ;
}

void
CBitVectorImpl::clear( Byte* buf , BitIndex bitCount )
{
    std::fill_n( buf , byteCount( bitCount ) , 0 ) ;
}

void
CBitVectorImpl::init( Byte* buffer ,
                        BitIndex bitCount ,
                        unsigned long initValue )
{
    for ( ; bitCount >= bitsPerByte ; bitCount -= bitsPerByte )
    {
        *buffer ++ = initValue ;
        if ( bitsPerByte < CHAR_BIT * sizeof( initValue ) ) {
            initValue >>= bitsPerByte ;
        } else {
            initValue = 0 ;
        }
    }
    if ( bitCount > 0 ) {
        *buffer = initValue & ~ (~0 << bitCount) ;
    }
}

void
CBitVectorImpl::init( Byte* buffer ,
                        BitIndex bitCount ,
                        std::string const& initValue )
{
    clear( buffer , bitCount ) ;
    BitIndex            i = 0 ;
    for ( std::string::const_iterator p = initValue.begin() ;
                                         p != initValue.end() ;
                                         ++ p ) {
        switch ( *p ) {
        case '1' :
        case 't' :
        case 'T' :
            ASSERT( i < bitCount ); //Init string too long for CBitVector
            set( buffer , i ) ;
            i ++ ;
            break ;

        case '0' :
        case 'f' :
        case 'F' :
            ASSERT( i < bitCount ); //Init string too long for CBitVector
            i ++ ;
            break ;

        default :
            ASSERT( isspace( static_cast< unsigned char >( *p ) ) ); //Illegal character in init string for CBitVector
            break ;
        }
    }
}

unsigned long
CBitVectorImpl::asLong( Byte const* buffer , BitIndex bitCount )
{
    unsigned long       result = buffer[ 0 ] ;
    int                 bits = bitsPerByte ;
    static int const    bitsInLong = CHAR_BIT * sizeof( long ) ;
    if ( bitsPerByte < bitsInLong && byteCount( bitCount ) > 1 ) {
        int                 i = 1 ;
        int                 top = byteCount( bitCount ) ;
        while ( bits < bitsInLong && i < top ) {
            result |= buffer[ i ] << (i * bitsPerByte) ;
            ++i;
        }
    }
    return result ;
}

std::string
CBitVectorImpl::asString( Byte const* buffer , BitIndex bitCount )
{
    std::string      result( bitCount , '0' ) ;
    for ( BitIndex i = 0 ; i < bitCount ; i ++ ) {
        if ( isSet( buffer , i ) ) {
            result[ i ] = '1' ;
        }
    }
    return result ;
}

bool
CBitVectorImpl::isSet( Byte const* buffer , BitIndex bitNo )
{
    return
        (buffer[ byteIndex( bitNo ) ] & (1 << bitInByte( bitNo ))) != 0 ;
}

bool
CBitVectorImpl::isEmpty( Byte const* buffer , BitIndex bitCount )
{
    return std::find_if( buffer ,
                            buffer + byteCount( bitCount ) ,
                            std::bind2nd(
                                std::not_equal_to< Byte >() , 0 ) )
        == buffer + byteCount( bitCount ) ;
}

CBitVectorImpl::BitIndex
CBitVectorImpl::count( Byte const* buffer , BitIndex bitCount )
{
    BitIndex            result = 0 ;
    for ( BitIndex i = 0 ; i < byteCount( bitCount ) ; ++ i ) {
        Byte                tmp = buffer[ i ] ;
        while ( tmp != 0 )
        {
            ++ result ;
            tmp &= tmp - 1 ;
        }
    }
    return result ;
}

//      find:
//      =====
//
//      Note that the obvious algorithm has not been used.  In one
//      application using a (much) earlier version of this class,
//      profiling showed over 95% of the time in this routine.
//      Changing from the original algorithm to this one resulted in a
//      speed-up of a factor of 6 in the application.
// --------------------------------------------------------------------------
CBitVectorImpl::BitIndex
CBitVectorImpl::find( Byte const* buffer ,
                        BitIndex bitCount ,
                        BitIndex from ,
                        bool value )
{
    Byte                toggleMask = (value) ? 0 : ~0 ;
    BitIndex            result = infinity ;

    Byte const*         p = buffer + byteIndex( from ) ;

    //      First byte is special, as some of its bytes have already
    //      been examined (potentially, at least).  Logically, the
    //      duplicated part of the code should be a function, but as
    //      we are concerned about speed...  (Inlining doesn't
    //      necessarily help.  The duplicated part contains a loop,
    //      and many compilers simply refuse to inline it.)
    // ----------------------------------------------------------------------
    {
        Byte                tmp = (*p ^ toggleMask) >> bitInByte( from ) ;
        if ( tmp == 0 ) {
            from += bitsPerByte - bitInByte( from ) ;
        } else {
            while ( (tmp & 1) == 0 ) {
                from ++ ;
                tmp >>= 1 ;
            }
            result = from ;
        }
    }

    //      Handle all of the bits in the rest of the bytes.  Note
    //      that we may actually test bits beyond the end of the
    //      vector (and even find a result, if we are looking for
    //      false).  However, doing this and then testing the
    //      validity of the bit found before returning is probably
    //      faster (and certainly simpler) than the extra conditions
    //      necessary to avoid testing these bits.
    // ----------------------------------------------------------------------
    while ( (size_t)result >= bitCount && from < bitCount ) {
        p ++ ;
        Byte                tmp = *p ^ toggleMask ;
        if ( tmp == 0 ) {
            from += bitsPerByte ;
        } else {
            while ( (tmp & 1) == 0 ) {
                from ++ ;
                tmp >>= 1 ;
            }
            result = from ;
        }
    }
    return (result < bitCount) ? result : infinity ;
}

void
CBitVectorImpl::set( Byte* buffer , BitIndex bitNo )
{
    buffer[ byteIndex( bitNo ) ] |= 1 << bitInByte( bitNo ) ;
}

void
CBitVectorImpl::set( Byte* buffer ,
                       Byte const* other ,
                       BitIndex bitCount )
{
    std::transform( buffer , buffer + byteCount( bitCount ) ,
                       other ,
                       buffer ,
                       Set() ) ;
}

void
CBitVectorImpl::setAll( Byte* buffer , BitIndex bitCount )
{
    for ( ; bitCount >= bitsPerByte ; bitCount -= bitsPerByte ) {
        *buffer ++ = ~0 ;
    }
    if ( bitCount > 0 ) {
        *buffer = ~ (~0 << bitCount) ;
    }
}

void
CBitVectorImpl::reset( Byte* buffer , BitIndex bitNo )
{
    buffer[ byteIndex( bitNo ) ] &= ~ (1 << bitInByte( bitNo )) ;
}

void
CBitVectorImpl::reset( Byte* buffer ,
                         Byte const* other ,
                         BitIndex bitCount )
{
    std::transform( buffer , buffer + byteCount( bitCount ) ,
                       other ,
                       buffer ,
                       Reset() ) ;
}

void
CBitVectorImpl::resetAll( Byte* buffer , BitIndex bitCount )
{
    clear( buffer , bitCount ) ;
}

void
CBitVectorImpl::complement( Byte* buffer , BitIndex bitNo )
{
    buffer[ byteIndex( bitNo ) ] ^= 1 << bitInByte( bitNo ) ;
}

void
CBitVectorImpl::complement( Byte* buffer ,
                              Byte const* other ,
                              BitIndex bitCount )
{
    std::transform( buffer , buffer + byteCount( bitCount ) ,
                       other ,
                       buffer ,
                       Toggle() ) ;
}

void
CBitVectorImpl::complementAll( Byte* buffer , BitIndex bitCount )
{
    for ( ; bitCount >= bitsPerByte ; bitCount -= bitsPerByte ) {
        *buffer = ~ *buffer ;
        buffer ++ ;
    }
    if ( bitCount > 0 ) {
        *buffer ^= ~ (~0 << bitCount) ;
    }
}

void
CBitVectorImpl::intersect( Byte* buffer ,
                             Byte const* other ,
                             BitIndex bitCount )
{
    std::transform( buffer , buffer + byteCount( bitCount ) ,
                       other ,
                       buffer ,
                       Intersect() ) ;
}

bool
CBitVectorImpl::isSubsetOf( Byte const* lhs ,
                              Byte const* rhs ,
                              BitIndex bitCount )
{
    //      Note: a isSubsetOf b if and only if a union b == a, ie:
    //      all elements of b are also in a.  Thus, the second part of
    //      the test (which breaks the loop if an element of lhs is
    //      not in rhs).
    // ----------------------------------------------------------------------
    BitIndex cnt = byteCount( bitCount ) ;
    for ( ; cnt > 0 && (*lhs & *rhs) == *lhs ; -- cnt ) {
        ++ rhs ;
        ++ lhs ;
    }
    return cnt == 0 ;
}

unsigned
CBitVectorImpl::hash( Byte const* buffer , BitIndex bitCount )
{
    unsigned            h = 0 ;
    for ( BitIndex cnt = byteCount( bitCount ) ; cnt > 0 ; cnt -- ) {
        h = 2047 * h + *buffer ;
        ++ buffer ;
    }
    return h ;
}

int
CBitVectorImpl::compare( Byte const* buffer ,
                           Byte const* other ,
                           BitIndex bitCount )
{
    BitIndex cnt = byteCount( bitCount ) ;
    for ( ; cnt > 0 && *buffer == *other ; -- cnt ) {
        ++ buffer ;
        ++ other ;
    }
    return (cnt == 0) ? 0 : *buffer - *other ;
}

CBitVectorImpl::BitIndex
CBitVectorImpl::getByteCount( BitIndex bitCount )
{
    return byteCount( bitCount ) ;
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\dynbitv.cpp ===
/****************************************************************************/
/*  File:       dynbitv.cc                                                  */
/*  Author:     J. Kanze                                                    */
/*  Date:       06/01/1994                                                  */
/*      Copyright (c) 1994 James Kanze                                      */
/* ------------------------------------------------------------------------ */

#include <libpch.h>
#include <inc/dynbitv.h>
#include <inc/counter.h>
#include <inc/iosave.h>

#include "dynbitv.tmh"

#ifndef min
    #define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

inline CRexDynBitVector::BitIndex
CRexDynBitVector::byteCount( BitIndex bitCount )
{
    return(Impl::getByteCount( bitCount ) );
}

inline CRexDynBitVector::BitIndex
CRexDynBitVector::bitCount() const
{
    return(myBuffer.size() * bitsPerByte );
}

inline CRexDynBitVector::Byte*
CRexDynBitVector::buffer()
{
    return(&myBuffer[ 0 ] );
}

inline CRexDynBitVector::Byte const*
CRexDynBitVector::buffer() const
{
    return(&myBuffer[ 0 ] );
}

CRexDynBitVector::CRexDynBitVector()
:   myTrailingPart( false )
{
}

CRexDynBitVector::CRexDynBitVector( unsigned long initValue )
:   myTrailingPart( false )
{
    enlargeActivePart( sizeof( long ) * CHAR_BIT ) ;
    Impl::init( buffer() , bitCount() , initValue ) ;
}

CRexDynBitVector::CRexDynBitVector( std::string const& initValue )
:   myTrailingPart( false )
{
    init( initValue ) ;
}

CRexDynBitVector::CRexDynBitVector( char const* initValue )
:   myTrailingPart( false )
{
    init( initValue ) ;
}

unsigned long
CRexDynBitVector::asLong() const
{
    ASSERT( ! myTrailingPart ); //Bounds check error converting CRexDynBitVector
    return(Impl::asLong( buffer() , bitCount() ) );
}

std::string
CRexDynBitVector::asString() const
{
    ASSERT( ! myTrailingPart ); //Bounds check error converting CRexDynBitVector
    std::string         result = Impl::asString( buffer() , bitCount() ) ;
    size_t              last1 = result.rfind( '1' ) ;
    if( last1 != std::string::npos )
    {
        result.erase( last1 + 1 ) ;
    }
    else
    {
        result = "" ;
    }
    return(result );
}

bool
CRexDynBitVector::isSet( BitIndex bitNo ) const
{
    return(bitNo >= bitCount()
          ?   myTrailingPart
          :   Impl::isSet( buffer() , bitNo ) );
}

bool
CRexDynBitVector::isEmpty() const
{
    return(! myTrailingPart && Impl::isEmpty( buffer() , bitCount() ) );
}

CRexDynBitVector::BitIndex
CRexDynBitVector::find( bool targetValue , BitIndex from ) const
{
    BitIndex            result = infinity ;
    if( from < bitCount() )
    {
        result = Impl::find( buffer() , bitCount() , from , targetValue ) ;
    }
    if( result == infinity && targetValue == myTrailingPart )
    {
        result = from > bitCount() ? from : bitCount() ;
    }
    return(result );
}

CRexDynBitVector::BitIndex
CRexDynBitVector::count() const
{
    return(myTrailingPart
          ?   infinity
          :   Impl::count( buffer() , bitCount() ) );
}

CRexDynBitVector::BitIndex
CRexDynBitVector::activeLength() const
{
    return(bitCount() );
}

bool
CRexDynBitVector::isSubsetOf( CRexDynBitVector const& other ) const
{
    bool                result = myTrailingPart <= other.myTrailingPart ;
    if( result )
    {
        BitIndex commonLength = min( bitCount() , other.bitCount() );

        result = Impl::isSubsetOf( buffer() , other.buffer() , commonLength ) ;
        if( result )
        {
            if( bitCount() > other.bitCount() )
            {
                result = other.myTrailingPart
                         || Impl::isEmpty( buffer()
                                           + byteCount( other.bitCount() ) ,
                                           bitCount() - other.bitCount() ) ;
            }
            else if( bitCount() < other.bitCount() )
            {
                result = ! myTrailingPart
                         || ( std::find_if(
                                          other.myBuffer.begin() + byteCount( bitCount() ) ,
                                          other.myBuffer.end() ,
                                          std::bind2nd( std::not_equal_to< Byte >() ,
                                                        ~0 ) )
                              == other.myBuffer.end() ) ;
            }
        }
    }
    return(result );
}

void
CRexDynBitVector::set( BitIndex bitNo )
{
    enlargeActivePart( bitNo + 1 ) ;
    Impl::set( buffer() , bitNo ) ;
}

void
CRexDynBitVector::set( CRexDynBitVector const& other )
{
    enlargeActivePart( other.bitCount() ) ;
    Impl::set( buffer() , other.buffer() , other.bitCount() ) ;
    if( other.myTrailingPart )
    {
        myBuffer.resize( other.myBuffer.size() , ~0 ) ;
        myTrailingPart = true ;
    }
}

void
CRexDynBitVector::set()
{
    myTrailingPart = true ;
    std::vector< Byte > tmp ;
    std::swap( myBuffer , tmp ) ;
}

void
CRexDynBitVector::reset( BitIndex bitNo )
{
    enlargeActivePart( bitNo + 1 ) ;
    Impl::reset( buffer() , bitNo ) ;
}

void
CRexDynBitVector::reset( CRexDynBitVector const& other )
{
    enlargeActivePart( other.bitCount() ) ;
    Impl::reset( buffer() , other.buffer() , other.bitCount() ) ;
    if( other.myTrailingPart )
    {
        myBuffer.resize( other.myBuffer.size() , 0 ) ;
        myTrailingPart = false ;
    }
}

void
CRexDynBitVector::reset()
{
    myTrailingPart = false ;
    std::vector< Byte > tmp ;
    std::swap( myBuffer , tmp ) ;
}

void
CRexDynBitVector::complement( BitIndex bitNo )
{
    enlargeActivePart( bitNo + 1 ) ;
    Impl::complement( buffer() , bitNo ) ;
}

void
CRexDynBitVector::complement( CRexDynBitVector const& other )
{
    enlargeActivePart( other.bitCount() ) ;
    Impl::complement( buffer() , other.buffer() , other.bitCount() ) ;
    if( other.myTrailingPart )
    {
        for( std::vector< Byte >::iterator iter = myBuffer.begin() + other.myBuffer.size() ;
           iter != myBuffer.end() ;
           ++ iter )
        {
            *iter = ~ *iter ;
        }
        myTrailingPart = !myTrailingPart ;
    }
}

void
CRexDynBitVector::complement()
{
    Impl::complementAll( buffer() , bitCount() ) ;
    myTrailingPart = ! myTrailingPart ;
}

void
CRexDynBitVector::intersect( CRexDynBitVector const& other )
{
    enlargeActivePart( other.bitCount() ) ;
    Impl::intersect( buffer() , other.buffer() , other.bitCount() ) ;
    if( !other.myTrailingPart )
    {
        myBuffer.resize( other.myBuffer.size() ) ;
        myTrailingPart = false ;
    }
}

//      Note: to be compatible with the equality function, we must
//      normalize the value in some way, so that whether some of the
//      final bits are represented by an actual word in the vector, or
//      by myTrailingPart, will not change the hash (as long as the
//      value of the bits is the same).
unsigned
CRexDynBitVector::hash() const
{
    int                 byteIndex = myBuffer.size() ;
    Byte                insignificant = myTrailingPart ? ~0 : 0 ;
    while( byteIndex > 0 && myBuffer[ byteIndex - 1 ] == insignificant )
    {
        -- byteIndex ;
    }
    return(Impl::hash( buffer() , byteIndex * bitsPerByte ) * 3
          + myTrailingPart );
}

int
CRexDynBitVector::compare( CRexDynBitVector const& other ) const
{
    BitIndex commonLength = min( bitCount() , other.bitCount() ) ;
    int      result       = Impl::compare( buffer() , other.buffer() , commonLength ) ;

    if( result == 0 )
    {
        if( bitCount() > other.bitCount() )
        {
            Byte fill = other.myTrailingPart ? ~0 : 0 ;

            for( std::vector< Byte >::const_iterator iter = myBuffer.begin() + other.myBuffer.size() ;
                 result == 0 && iter != myBuffer.end() ;
                 ++ iter )
            {
                if( *iter != fill )
                {
                    result = other.myTrailingPart ? -1 : 1 ;
                }
            }
        }
        else
        {
            Byte                fill = myTrailingPart ? ~0 : 0 ;
            for( std::vector< Byte >::const_iterator iter = other.myBuffer.begin() + myBuffer.size() ;
                 result == 0 && iter != other.myBuffer.end() ;
                 ++ iter )
            {
                if( *iter != fill )
                {
                    result = myTrailingPart ? 1 : -1 ;
                }
            }
        }
    }
    if( result == 0 && myTrailingPart != other.myTrailingPart )
    {
        result = myTrailingPart ? 1 : -1 ;
    }
    return(result );
}

void
CRexDynBitVector::init( std::string const& initValue )
{
    CRexCounter< BitIndex >
    charCount ;
    for( std::string::const_iterator iter = initValue.begin() ;
       iter != initValue.end() ;
       ++ iter )
    {
        switch( *iter )
        {
            case '0' :
            case 'f' :
            case 'F' :
            case '1' :
            case 't' :
            case 'T' :
                ++ charCount ;
                break ;
        }
    }
    if( charCount > 0 )
    {
        enlargeActivePart( charCount ) ;
        CBitVectorImpl::init( buffer() , bitCount() , initValue ) ;
    }
}

void
CRexDynBitVector::enlargeActivePart( BitIndex minBitCount )
{
    BitIndex            newSize = byteCount( minBitCount ) ;
    if( newSize > myBuffer.size() )
    {
        myBuffer.resize( newSize , myTrailingPart ? ~0 : 0 ) ;
    }
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\regxdfa.cpp ===
/****************************************************************************/
/*  File:       regxdfa.cc                                                  */
/*  Author:     J. Kanze                                                    */
/*  Date:       31/03/1994                                                  */
/*      Copyright (c) 1994 James Kanze                                      */
/* ------------------------------------------------------------------------ */

#include <libpch.h>
#include "regeximp.h"
#include <inc/iosave.h>

#include "regxdfa.tmh"

CRexRegExpr_Impl::DFAStateTable::DFAState::DFAState(
                                                   SetOfNFAStates const& stateSignature ,
                                                   int stateAcceptCode ,
                                                   TransitionCode dflt )
:   acceptCode( stateAcceptCode )
,   signature( stateSignature )
{
    std::fill_n( transitionTable ,
                 static_cast< int >( charCount ) ,
                 dflt ) ;
}

CRexRegExpr_Impl::SetOfNFAStates const
CRexRegExpr_Impl::DFAStateTable::state0 ;
CRexRegExpr_Impl::SetOfNFAStates const
CRexRegExpr_Impl::DFAStateTable::state1(
                                       1UL << CRexRegExpr_Impl::DFAStateTable::failState ) ;

void
CRexRegExpr_Impl::DFAStateTable::construct( NFAStateTable const& nfa )
{
    ASSERT( myTable.size() == 0);
    mySource = &nfa ;
    myTable.push_back( CRexRefCntPtr< DFAState >(new DFAState( state0 , -1 , failState )) ) ;
    myTable.push_back( CRexRefCntPtr< DFAState >(new DFAState( state1 , nfa.getAcceptCode( state1 ) )) ) ;
}

void
CRexRegExpr_Impl::DFAStateTable::clear()
{
    mySource = NULL ;
    std::vector< CRexRefCntPtr< DFAState > >
    tmp ;
    myTable.swap( tmp ) ;
}

void
CRexRegExpr_Impl::DFAStateTable::makeCompleteTable()
{
    //      Generate the transitions for all characters in all states
    //      (except the fail state).  Note that the end condition
    //      (stateCnt) may change while the loop is exectuting, due to
    //      the creation of new states.
    // ----------------------------------------------------------------------
    for( Transition state = 0 ;
       state < myTable.size() ;
       ++ state )
    {
        DFAState&           stateDesc = *myTable[ state ] ;
        for( unsigned c = 0 ; c < charCount ; ++ c )
        {
            stateDesc.transitionTable[ c ] = newState( stateDesc , (unsigned char)c ) ;
        }
    }
}

void
CRexRegExpr_Impl::DFAStateTable::dump( std::ostream& output ) const
{
    CRexIOSave          s( output ) ;
    output.fill( '0' ) ;
    for( Transition state = 0 ; state < myTable.size() ; ++ state )
    {
        DFAState const&     stateDesc = *myTable[ state ] ;
        output << "State "
        << state
        << ": ("
        << stateDesc.acceptCode
        << ") "
        << DisplayNFA( stateDesc.signature ) ;
        int                 transitionsDefined = 0 ;
        {
            for( int c = 0 ; c < charCount ; ++ c )
            {
                if( stateDesc.transitionTable[ c ] != unsetTransition
                    && stateDesc.transitionTable[ c ] != failState )
                {
                    ++ transitionsDefined ;
                }
            }
        }
        int                 transitionsInLine = 0 ;
        output << " (" << transitionsDefined << " transitions)" << '\n' ;
        {
            for( int c = 0 ; c < charCount ; ++ c )
            {
                if( stateDesc.transitionTable[ c ] != unsetTransition
                    && stateDesc.transitionTable[ c ] != failState )
                {
                    output << "  "
                    << std::hex << std::setw( 2 ) << c
                    << "->"
                    << std::dec << std::setw( 2 )
                    << stateDesc.transitionTable[ c ] ;
                    transitionsInLine ++ ;
                    if( transitionsInLine >= 8 )
                    {
                        output << '\n' ;
                        transitionsInLine = 0 ;
                    }
                }
            }
            if( transitionsInLine != 0 )
            {
                output << '\n' ;
            }
        }
    }
}

CRexRegExpr_Impl::DFAStateTable::Transition
CRexRegExpr_Impl::DFAStateTable::newState( DFAState& currState ,
                                           unsigned char c )
{
    Transition          next ;
    if( currState.transitionTable[ c ] != unsetTransition )
    {
        next = currState.transitionTable[ c ] ;
    }
    else
    {
        SetOfNFAStates      nextNFA
        = mySource->getFollows( currState.signature , c ) ;
        for( next = 0 ;
           next < myTable.size() && myTable[ next ]->signature != nextNFA ;
           ++ next )
        {
        }
        if( next == myTable.size() )
        {

            myTable.push_back(
                             CRexRefCntPtr< DFAState >(
                                                      new DFAState(
                                                                  nextNFA , mySource->getAcceptCode( nextNFA ) ) ) );
        }
    }
    return(next );
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\regexpr.cpp ===
/****************************************************************************/
/*  File:       regexpr.cc                                                  */
/*  Author:     J. Kanze                                                    */
/*  Date:       28/12/1993                                                  */
/*      Copyright (c) 1993 James Kanze                                      */
/* ------------------------------------------------------------------------ */

#include <libpch.h>
#include "regeximp.h"
#include <inc/message.h>
#include <inc/ios.h>
#include <inc/iteristr.h>

#include "regexpr.tmh"

CRegExpr::CRegExpr()
    :   myImpl( new CRexRegExpr_Impl )
{
}

CRegExpr::CRegExpr( std::istream& source , int delim , int acceptCode )
    :   myImpl( new CRexRegExpr_Impl )
{
    myImpl->parse( source , delim , acceptCode ) ;
}

CRegExpr::CRegExpr( char const* source , int acceptCode )
    :   myImpl( new CRexRegExpr_Impl )
{
    CRexIteratorIstream< char const* >
                        src( source , source + strlen( source ) ) ;
    myImpl->parse( src , REX_eof , acceptCode ) ;
}

CRegExpr::CRegExpr( std::string const& source , int acceptCode )
    :   myImpl( new CRexRegExpr_Impl )
{
    CRexIteratorIstream< std::string::const_iterator >
                        src( source.begin() , source.end() ) ;
    myImpl->parse( src , REX_eof , acceptCode ) ;
}

CRegExpr::CRegExpr( CRegExpr const& other )
    :   myImpl( new CRexRegExpr_Impl( *other.myImpl ) )
{
}

CRegExpr::~CRegExpr()
{
    delete myImpl ;
}

CRegExpr&
CRegExpr::operator=( CRegExpr const& other )
{
    CRexRegExpr_Impl*    newInstance( new CRexRegExpr_Impl( *other.myImpl ) ) ;
    delete myImpl ;
    myImpl = newInstance ;
    return *this ;
}

bool
CRegExpr::empty() const
{
    return (!myImpl || myImpl->myState == CRexRegExpr_Impl::noParseTree );
}

CRegExpr::Status
CRegExpr::errorCode() const
{
    return myImpl->getErrorState() ;
}

std::string
CRegExpr::errorMsg( Status errorCode )
{
    std::string      result ;
    if ( (errorCode & illegalCharClass) != 0 ) {
        result = std::string( s_rex_message.get( "Illegal character class: " ) )
            + CRexCharClass::errorMsg(
                static_cast< CRexCharClass::Status >(
                    errorCode & (illegalCharClass - 1) ) ) ;
    } else {
        char const *const   tbl[] =
        {
            "" ,
            "regular expression was empty" ,
            "mismatched parentheses" ,
            "garbage at end of string" ,
            "missing term for or" ,
            "uninitialized regular expression used" ,
        } ;
        ASSERT( static_cast< unsigned >( errorCode ) < TABLE_SIZE( tbl ) ); //CRegExpr: Impossible value for error code
        result = s_rex_message.get( tbl[ errorCode ] ) ;
    }
    return result ;
}


void
CRegExpr::merge( CRegExpr const& other )
{
    myImpl->merge( *other.myImpl ) ;
}

void
CRegExpr::buildCompleteDFA() const
{
    myImpl->buildTo( CRexRegExpr_Impl::dfaBuilt ) ;
}

int
CRegExpr::getStateCount() const
{
    return myImpl->getStateCount() ;
}

CRegExpr::TransitionState
CRegExpr::getTransition( TransitionState state , unsigned char chr ) const
{
    return myImpl->nextState( state , chr ) ;
}

int
CRegExpr::getAcceptCode( TransitionState state ) const
{
    return myImpl->accept( state ) ;
}

int
CRegExpr::match( char const* start , char const** endPtr ) const
{
    std::pair< int , char const* > result = match( start , start + strlen( start ) ) ;

    if ( result.first != -1 && endPtr != NULL )
    {
        *endPtr = result.second ;
    }
    return result.first ;
}

void
CRegExpr::initForMatch() const
{
    myImpl->buildTo( CRexRegExpr_Impl::dfaInitialized ) ;
}

CRegExpr::TransitionState
CRegExpr::processTransition( int& accept ,
                               TransitionState state ,
                               char ch ) const
{
    TransitionState result = myImpl->nextState( state , ch ) ;
    accept = myImpl->accept( result ) ;
    return result ;
}

void
CRegExpr::dumpTree( std::ostream& output ) const
{
    myImpl->dumpTree( output ) ;
}

void
CRegExpr::dumpNfaAutomat( std::ostream& output ) const
{
    myImpl->dumpNfaAutomat( output ) ;
}

void
CRegExpr::dumpDfaAutomat( std::ostream& output ) const
{
    myImpl->dumpDfaAutomat( output ) ;
}

void
CRegExpr::dump( std::ostream& output ) const
{
    dumpTree( output ) ;
    dumpNfaAutomat( output ) ;
    dumpDfaAutomat( output ) ;
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\regeximp.h ===
/****************************************************************************/
/*  File:       regeximp.h                                                  */
/*  Author:     J. Kanze                                                    */
/*  Date:       28/12/1993                                                  */
/*      Copyright (c) 1993 James Kanze                                      */
/* ------------------------------------------------------------------------ */

#include <inc/rex.h>
#include <inc/setofchr.h>
#include <inc/dynbitv.h>
#include <inc/refcnt.h>

class CRexRegExpr_Impl
{
public :
    enum State
    {
        noParseTree = 0 ,
        parseTreeBuilt ,
        nfaBuilt ,
        dfaInitialized ,
        dfaBuilt ,
        error = 0x80                    //  With ErrorState or'ed in low bits.
    } ;

    //      Copy ctor and dtor per default, no assignment.
    // ----------------------------------------------------------------------
                        CRexRegExpr_Impl() ;

    void                parse( std::istream& source ,
                               int delim ,
                               int acceptCode ) ;
    CRegExpr::Status  getErrorState() const ;
    void                merge( CRexRegExpr_Impl const& other ) ;

    void                buildTo( State targetState ) ;

    CRegExpr::TransitionState
                        nextState( CRegExpr::TransitionState currState ,
                                   unsigned char chr ) ;
    int                 getStateCount() const ;
    int                 accept( CRegExpr::TransitionState state ) const ;

    void                dumpTree( std::ostream& output ) const ;
    void                dumpNfaAutomat( std::ostream& output ) const ;
    void                dumpDfaAutomat( std::ostream& output ) const ;
private :
    CRexRegExpr_Impl const&
                        operator=( CRexRegExpr_Impl const& other ) ;

public:

    //      First, some private types:
    //      ==========================
    //
    //      State is the internal state of the regular expression, or
    //      rather, of its representation.  In all but the first case,
    //      or an actual error, the ErrorState will be ok.
    //
    //      The next three types are used for the different
    //      representations of the regular expression: a parse tree,
    //      an NFA and a DFA.  Because of the complexity of these
    //      latter, they are actually defined in a separate file, and
    //      included here.
    // ----------------------------------------------------------------------
    class ParseTree ;
    class NFAStateTable ;
    class DFAStateTable ;

    typedef unsigned         LeafId ;
    typedef CRexDynBitVector  SetOfNFAStates ;
    typedef CRexSetOfChar     SetOfChar ;

#include "regxtree.h"
#include "regxnfa.h"
#include "regxdfa.h"

    State               myState ;
    ParseTree           myTree ;
    NFAStateTable       myNFA ;
    DFAStateTable       myDFA ;

    class DisplayNFA
    {
    public :
        DisplayNFA( SetOfNFAStates const& states ) ;
        friend std::ostream&
                            operator<<( std::ostream& out ,
                                        DisplayNFA const& val ) ;
    private :
        SetOfNFAStates const&
                            obj ;
    } ;

    class DisplaySOC
    {
    public :
        DisplaySOC( SetOfChar const& set ) ;
        friend std::ostream&
                            operator<<( std::ostream& out ,
                                        DisplaySOC const& val ) ;
    private :
        SetOfChar const&    obj ;
    } ;

/*    friend std::ostream&
    operator<<( std::ostream& out , CRexRegExpr_Impl::DisplayNFA const& val );

    friend std::ostream&
    operator<<( std::ostream& out , CRexRegExpr_Impl::DisplaySOC const& val );
*/
} ;

#include    "regxtree.inl"
#include    "regxnfa.inl"
#include    "regxdfa.inl"

inline
CRexRegExpr_Impl::CRexRegExpr_Impl()
    :    myState( noParseTree )
{
}

inline void
CRexRegExpr_Impl::parse( std::istream& source ,
                        int delim ,
                        int acceptCode )
{
    ASSERT( myState == noParseTree);
    myTree.parse( source , delim , acceptCode ) ;
    myState = static_cast< State > (myTree.errorCode() == CRegExpr::ok
                                    ?   parseTreeBuilt
                                    :   (error | myTree.errorCode()) ) ;
}

inline CRegExpr::Status
CRexRegExpr_Impl::getErrorState() const
{
    return myTree.errorCode() ;
}

inline CRegExpr::TransitionState
CRexRegExpr_Impl::nextState( CRegExpr::TransitionState currState ,
                            unsigned char chr )
{
    return myDFA.nextState( currState , chr ) ;
}

inline int
CRexRegExpr_Impl::getStateCount() const
{
    return myDFA.getStateCount() ;
}

inline int
CRexRegExpr_Impl::accept( CRegExpr::TransitionState state ) const
{
    return myDFA.accept( state ) ;
}

inline void
CRexRegExpr_Impl::dumpTree( std::ostream& output ) const
{
	myTree.dump( output ) ;
}

inline void
CRexRegExpr_Impl::dumpNfaAutomat( std::ostream& output ) const
{
	myNFA.dump( output ) ;
}

inline void
CRexRegExpr_Impl::dumpDfaAutomat( std::ostream& output ) const
{
	myDFA.dump( output ) ;
}

inline
CRexRegExpr_Impl::DisplayNFA::DisplayNFA( SetOfNFAStates const& states )
    :   obj( states )
{
}

inline
CRexRegExpr_Impl::DisplaySOC::DisplaySOC( SetOfChar const& set )
    :   obj( set )
{
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\regxdfa.h ===
/****************************************************************************/
/*  File:       regxdfa.h                                                 */
/*  Author:     J. Kanze                                                    */
/*  Date:       28/12/1993                                                  */
/*      Copyright (c) 1993 James Kanze                                      */
/* ------------------------------------------------------------------------ */
//      DFA states:
//      ===========
//
//      This file is designed to be included in regeximp.h.  In
//      particular, the type defined in this file should be a member
//      of CRexRegExprImpl.
// --------------------------------------------------------------------------

class DFAStateTable
{
public :
    typedef CRegExpr::TransitionState
                        Transition ;
    enum TransitionCode {
        failState ,
        startState ,
        unsetTransition = static_cast< unsigned int >( ~0 )
    } ;

    enum {
        charCount = UCHAR_MAX + 1
    } ;

    class DFAState : public CRexRefCntObj
    {
        friend class        DFAStateTable ;
                            DFAState( SetOfNFAStates const& stateSignature ,
                                      int stateAcceptCode ,
                                      TransitionCode dflt = unsetTransition ) ;

        int                 acceptCode ;
        SetOfNFAStates      signature ;
        Transition          transitionTable[ charCount ] ;
    } ;

                        DFAStateTable() ;
                        ~DFAStateTable() ;

    void                construct( NFAStateTable const& nfa ) ;
    void                clear() ;

    DFAState&           operator[]( int index ) ;
    DFAState const&     operator[]( int index ) const ;

    int                 getStateCount() const ;
    int                 accept( int state ) const ;

    Transition          nextState( int currState , unsigned char chr ) ;
    void                makeCompleteTable() ;

    void                dump( std::ostream& output ) const ;

private :
    NFAStateTable const*
                        mySource ;
    std::vector< CRexRefCntPtr< DFAState > >
                        myTable ;

    static SetOfNFAStates const
                        state0 ;
    static SetOfNFAStates const
                        state1 ;

    Transition          newState( DFAState& currState , unsigned char chr ) ;
} ;
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\regxnfa.cpp ===
/****************************************************************************/
/*  File:       regxnfa.inl                                                 */
/*  Author:     J. Kanze                                                    */
/*  Date:       30/03/1994                                                  */
/*      Copyright (c) 1994 James Kanze                                      */
/* ------------------------------------------------------------------------ */

#include <libpch.h>
#include "regeximp.h"

#include "regxnfa.tmh"


void
CRexRegExpr_Impl::NFAStateTable::clear()
{
    std::vector< NFAState >
                        tmp ;
    myTable.swap( tmp ) ;
}

void
CRexRegExpr_Impl::NFAStateTable::construct( ParseTree& tree )
{
    //      Only construct once.
    // ----------------------------------------------------------------------
    ASSERT( myTable.size() == 0 ) ;

    //      Skip start state (always state 0).
    // ----------------------------------------------------------------------
    createNewState( SetOfChar() ) ;

    //      Annotate the tree.
    // ----------------------------------------------------------------------
    class Annotater : public ParseTree::Visitor
    {
    public:
        Annotater( NFAStateTable& thisTbl )
            :	nfa( thisTbl )
        {
        }
        virtual void        visitNode(
                                ParseTree::ParseTreeNode& targetNode ) const
        {	
            targetNode.annotate( nfa ) ;
	}

    private:
        NFAStateTable&		nfa ;
    } ;
    tree.visit( Annotater( *this ) ) ;

    //      Build the start state.
    // ----------------------------------------------------------------------
    myTable[ 0 ].nextStates = tree.leftMost() ;
}

CRexRegExpr_Impl::SetOfNFAStates
CRexRegExpr_Impl::NFAStateTable::getFollows( SetOfNFAStates const& thisState ,
                                            unsigned char currChar ) const
{
    SetOfNFAStates      result ;
    for ( SetOfNFAStates::Iterator i = thisState.iterator() ;
                                   ! i.isDone() ;
                                   i.next() ) {
        for ( SetOfNFAStates::Iterator j
                  = myTable[ i.current() ].nextStates.iterator() ;
                                       ! j.isDone() ;
                                       j.next() ) {
            if ( myTable[ j.current() ].legalChars.contains( currChar ) ) {
                result.set( j.current() ) ;
            }
        }
    }
    return result ;
}

int
CRexRegExpr_Impl::NFAStateTable::getAcceptCode(
                    SetOfNFAStates const& thisState ) const
{
    int                 result = -1 ;
    for ( SetOfNFAStates::Iterator i = thisState.iterator() ;
                                   result == -1 && ! i.isDone() ;
                                   i.next() ) {
        result = myTable[ i.current() ].acceptCode ;
    }
    return result ;
}

CRexRegExpr_Impl::LeafId
CRexRegExpr_Impl::NFAStateTable::createNewState( SetOfChar const& charClass )
{
    myTable.push_back( NFAState( charClass ) ) ;
    return myTable.size() - 1 ;
}

void
CRexRegExpr_Impl::NFAStateTable::setFollows( SetOfNFAStates const& currState ,
                                            SetOfNFAStates const& nextState )
{
    for ( CRexDynBitVector::Iterator state = currState.iterator() ;
                                    ! state.isDone() ;
                                    state.next() ) {
        myTable[ state.current() ].nextStates |= nextState ;
    }
}

void
CRexRegExpr_Impl::NFAStateTable::dump( std::ostream& out ) const
{
    out << "NFA: Number of states: " << myTable.size() << '\n' ;
    for ( unsigned state = 0 ; state < myTable.size() ; state ++ )
    {
        out << std::setw( 3 ) << state ;
        if ( (myTable)[ state ].acceptCode != -1 ) {
            out << " (" << (myTable)[ state ].acceptCode << ")" ;
        }
        out << " : "
            << DisplayNFA( (myTable)[ state ].nextStates )
            << DisplaySOC( (myTable)[ state ].legalChars )
            << '\n' ;
    }
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\regximpl.cpp ===
/****************************************************************************/
/*  File:       regximpl.cc                                                 */
/*  Author:     J. Kanze                                                    */
/*  Date:       28/12/1993                                                  */
/*      Copyright (c) 1993 James Kanze                                      */
/* ------------------------------------------------------------------------ */

#include <libpch.h>
#include "regeximp.h"
#include <inc/iosave.h>

#include "regximpl.tmh"

void
CRexRegExpr_Impl::merge( CRexRegExpr_Impl const& other )
{
    switch ( myState ) {
    case noParseTree:
        myTree = other.myTree ;
        if ( myTree.errorCode() == CRegExpr::ok ) {
            myState = parseTreeBuilt ;
        } else {
            myState = other.myState ;
        }
        break ;

    case parseTreeBuilt:
    case nfaBuilt:
    case dfaInitialized:
    case dfaBuilt:
        myNFA.clear() ;
        myDFA.clear() ;
        myTree.merge( other.myTree ) ;
        if ( myTree.errorCode() == CRegExpr::ok ) {
            myState = parseTreeBuilt ;
        } else {
            myState = other.myState ;
        }
        break ;

    default:                            // Error, so keep error state.
        break ;
    }
}

void
CRexRegExpr_Impl::buildTo( State targetState )
{
    while ( myState < targetState ) {
        switch ( myState ) {
        case noParseTree :
            ASSERT( 0 ); // No regular expression for automat
            abort() ;
            break ;

        case parseTreeBuilt :
            myNFA.construct( myTree ) ;
            myState = nfaBuilt ;
            break ;

        case nfaBuilt :
            myDFA.construct( myNFA ) ;
            myState = dfaInitialized ;
            break ;

        case dfaInitialized :
            myDFA.makeCompleteTable() ;
            myState = dfaBuilt ;
            break ;

        case dfaBuilt :
            ASSERT( 0 ); //Impossible case
            break ;

        default :
            ASSERT( 0 ); //Attempt to use regular expression with error
            break ;
        }
    }
}

std::ostream&
operator<<( std::ostream& out , CRexRegExpr_Impl::DisplayNFA const& val )
{
    CRexRegExpr_Impl::SetOfNFAStates const&
                        obj = val.obj ;
    if ( obj.isEmpty() ) {
        out << "[]" ;
    } else {
        CRexIOSave           s( out ) ;
        out.setf( std::ios::dec , std::ios::basefield ) ;
        char                leadingSep = '[' ;
        for ( CRexDynBitVector::Iterator iter = val.obj.iterator() ;
                                        ! iter.isDone() ;
                                        iter.next() ) {
            out << leadingSep << (size_t)iter.current() ;
            leadingSep = ',' ;
        }
        out << ']' ;
    }
    return out ;
}

std::ostream&
operator<<( std::ostream& out , CRexRegExpr_Impl::DisplaySOC const& val )
{
    CRexRegExpr_Impl::SetOfChar
                        obj ;
    if ( val.obj.count() > UCHAR_MAX / 2 ) {
        obj = ~ val.obj ;
    } else {
        obj = val.obj ;
    }
    CRexIOSave           s( out ) ;
    out.setf( std::ios::hex , std::ios::basefield ) ;
    out << '[' ;
    for ( CRexSetOfChar::iterator i = obj.begin() ;
                                 i != obj.end() ;
                                 ++ i ) {
        if ( isprint( i.current()  ) ) {
            out << static_cast< char >( i.current() ) ;
        } else {
            out << "\\x" << std::setw( 2 ) << i.current() ;
        }
    }
    out << ']' ;
    return out ;
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\regxnfa.h ===
/****************************************************************************/
/*  File:       regxnfa.h                                                 */
/*  Author:     J. Kanze                                                    */
/*  Date:       28/12/1993                                                  */
/*      Copyright (c) 1993 James Kanze                                      */
/* ------------------------------------------------------------------------ */
//      NFA states:
//      ===========
//
//      This file is designed to be included in regeximp.h.  In
//      particular, the type defined in this file should be a member
//      of CRexRegExprImpl.
// --------------------------------------------------------------------------

class NFAStateTable
{
public :
    class NFAState
    {
        friend class        NFAStateTable ;
    public :
                            NFAState() ;
                            NFAState( SetOfChar const& charClass ) ;
        void                setAccept( int newAcceptCode ) ;
    private :
        int                 acceptCode ;
        SetOfNFAStates      nextStates ;
        SetOfChar           legalChars ;
    } ;

    void                clear() ;
    void                construct( ParseTree& tree ) ;
    unsigned            createNewState( SetOfChar const& legalChars ) ;

    bool                defined() const ;
    SetOfNFAStates      getFollows( SetOfNFAStates const& thisState ,
                                    unsigned char currChar ) const ;
    int                 getAcceptCode(
                            SetOfNFAStates const& thisState ) const ;

    NFAState&           operator[]( LeafId state ) ;
    void                setFollows( SetOfNFAStates const& currState ,
                                    SetOfNFAStates const& nextState ) ;

    void                dump( std::ostream& out ) const ;

private :
    std::vector< NFAState >
                        myTable ;
} ;
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\regxdfa.inl ===
/****************************************************************************/
/*  File:       regxdfa.ihh                                                 */
/*  Author:     J. Kanze                                                    */
/*  Date:       31/03/1994                                                  */
/*      Copyright (c) 1994 James Kanze                                      */
/* ------------------------------------------------------------------------ */

inline
CRexRegExpr_Impl::DFAStateTable::DFAStateTable()
    :   mySource( NULL )
{
}

inline
CRexRegExpr_Impl::DFAStateTable::~DFAStateTable()
{
    clear() ;
}

inline CRexRegExpr_Impl::DFAStateTable::DFAState&
CRexRegExpr_Impl::DFAStateTable::operator[]( int index )
{
    ASSERT( (unsigned)index < myTable.size());
    return *myTable[ index ] ;
}

inline CRexRegExpr_Impl::DFAStateTable::DFAState const&
CRexRegExpr_Impl::DFAStateTable::operator[]( int index ) const
{
    ASSERT( (unsigned)index < myTable.size());
    return *myTable[ index ] ;
}

inline int
CRexRegExpr_Impl::DFAStateTable::getStateCount() const
{
    return myTable.size() ;
}

inline int
CRexRegExpr_Impl::DFAStateTable::accept( int state ) const
{
    return myTable[ state ]->acceptCode ;
}

// ==========================================================================
//      Normally, this one is too complicated to make it inline.  But
//      it is the most frequently called function when matching, and
//      once we've gotten started, the `if' should be false more than
//      99% of the time.  In addition, of course, it is only called in
//      two places (`match' and `makeCompleteTable'), so the
//      space-time trade-off probably justifies making it inline.
// --------------------------------------------------------------------------

inline CRegExpr::TransitionState
CRexRegExpr_Impl::DFAStateTable::nextState( int currState , unsigned char c )
{
    DFAState&           currStateDesc = *myTable[ currState ] ;
    Transition&         t = currStateDesc.transitionTable[ c ] ;
    if ( t == unsetTransition ) {
        t = newState( currStateDesc , c ) ;
    }
    return t ;
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\regxtree.cpp ===
/****************************************************************************/
/*  File:       regxtree.cc                                                 */
/*  Author:     J. Kanze                                                    */
/*  Date:       28/12/1993                                                  */
/*      Copyright (c) 1993 James Kanze                                      */
/* ------------------------------------------------------------------------ */

#include <libpch.h>
#include "regeximp.h"

#include "regxtree.tmh"

void
CRexRegExpr_Impl::ParseTree::parse(
                                 std::istream&  expr ,
                                 int                 delim ,
                                 int                 acceptCode )
{
    static CRexSetOfChar const metaChars( "|*+?()" ) ;

    ASSERT( errorCode() == CRegExpr::emptyExpr ) ;
    if( (delim < 0 && delim != REX_eof)
        || delim > UCHAR_MAX
        || metaChars.contains( delim ) )
    {
        myRoot = CRegExpr::illegalDelimiter ;
    }
    else
    {
        myRoot = parseOrNode( expr , delim ) ;
        if( myRoot.isValid() && expr.peek() != delim )
        {
            myRoot = (expr.peek() == ')'
                      ?   CRegExpr::unmatchedParen
                      :   CRegExpr::garbageAtEnd) ;
        }
    }
    if( myRoot.isValid() )
    {
        myRoot = new AcceptNode( myRoot.node() , acceptCode ) ;
    }
}

// ==========================================================================
//      parseOrNode:
//
//      Note the possible error condition: if an `or' operator ('|')
//      is given, it must be followed by a second non-empty regular
//      expression.
// --------------------------------------------------------------------------

CRexRegExpr_Impl::ParseTree::FallibleNodePtr
CRexRegExpr_Impl::ParseTree::parseOrNode(
                                       std::istream&  expr ,
                                       int                 delim )
{
    FallibleNodePtr     result = parseCatNode( expr , delim ) ;
    while( result.isValid() && expr.peek() == '|' )
    {
        expr.get() ;
        if( expr.peek() == REX_eof || expr.peek() == delim )
        {
            result = CRegExpr::emptyOrTerm ;
        }
        else
        {
            result = constructChoiceNode( result ,
                                          parseCatNode( expr , delim ) ) ;
        }
    }
    return(result );
}

// ==========================================================================
//      parseCatNode:
// --------------------------------------------------------------------------

CRexRegExpr_Impl::ParseTree::FallibleNodePtr
CRexRegExpr_Impl::ParseTree::parseCatNode(
                                        std::istream&  expr ,
                                        int                 delim )
{
    static CRexSetOfChar const
    catStops( "|)" ) ;

    FallibleNodePtr     result = parseClosureNode( expr , delim ) ;
    while( result.isValid()
           && expr.peek() != delim
           && expr.peek() != REX_eof
           && ! catStops.contains( expr.peek() ) )
    {
        result = constructConcatNode( result ,
                                      parseClosureNode( expr , delim ) ) ;
    }
    return(result );
}

// ==========================================================================
//      parseClosureNode:
//      =================
//
//      The syntax (and precedence) of all closure nodes is the same,
//      so we only have one function.
//
//      An even more elegant solution would be a map of the closure
//      character to a function which returns the new node.  Elegance
//      is nice, but the following works, is short and easy to
//      understand, and so...
// --------------------------------------------------------------------------

CRexRegExpr_Impl::ParseTree::FallibleNodePtr
CRexRegExpr_Impl::ParseTree::parseClosureNode(
                                            std::istream&  expr ,
                                            int                 delim )
{
    static CRexSetOfChar const
    closures( "*+?" ) ;

    FallibleNodePtr     result = parseLeafNode( expr , delim ) ;
    while( result.isValid()
           && expr.peek() != delim
           && expr.peek() != REX_eof
           && closures.contains( expr.peek() ) )
    {
        switch( expr.get() )
        {
            case '*' :
                result = new KleinClosureNode( result.node() ) ;
                break ;

            case '+' :
                result = new PositiveClosureNode( result.node() ) ;
                break ;

            case '?' :
                result = new OptionalNode( result.node() ) ;
                break ;
        }
    }
    return(result );
}

// ==========================================================================
//      parseLeafNode:
//      ==============
//
//      Most of the real functionality of this one is wrapped up in
//      CRexSetOfChar and CRexCharClass (particularly the latter).  The
//      only special cases are the `.'  and `('.
// --------------------------------------------------------------------------

CRexRegExpr_Impl::ParseTree::FallibleNodePtr
CRexRegExpr_Impl::ParseTree::parseLeafNode(
                                         std::istream&  expr ,
                                         int                 delim )
{
    FallibleNodePtr     result ;
    switch( expr.peek() )
    {
        case '(' :
            {
                expr.get() ;
                result = parseOrNode( expr , delim ) ;
                if( expr.peek() == ')' )
                {
                    expr.get() ;
                }
                else
                {
                    result = CRegExpr::unmatchedParen ;
                }
            }
            break ;

        case '.' :
            {
                expr.get() ;
                static CRexSetOfChar const theLot( CRexSetOfChar::except , '\n' );
                result = new LeafNode( theLot ) ;
            }
            break ;

        default :
            if( expr.peek() == REX_eof || expr.peek() == delim )
            {
                result = CRegExpr::unexpectedEOF ;
            }
            else
            {
                CRexCharClass chrClass( expr ) ;
                if( ! chrClass.good() )
                {
                    result = static_cast< CRegExpr::Status >(
                                                              CRegExpr::illegalCharClass | chrClass.errorCode() ) ;
                }
                else
                {
                    result = new LeafNode( chrClass ) ;
                }
            }
            break ;
    }
    return(result );
}

CRexRegExpr_Impl::ParseTree::FallibleNodePtr
CRexRegExpr_Impl::ParseTree::constructChoiceNode( FallibleNodePtr const& left ,
                                                 FallibleNodePtr const& right )
{
    FallibleNodePtr     result ;
    switch( left.state() )
    {
        case CRegExpr::ok :
            {
                switch( right.state() )
                {
                    case CRegExpr::ok :
                        result = new ChoiceNode( left.node() , right.node() ) ;
                        break ;

                    case CRegExpr::emptyExpr :
                        result = left ;
                        break ;

                    default :
                        result = right ;
                        break ;
                }
            }
            break ;

        case CRegExpr::emptyExpr :
            result = right ;
            break ;

        default :
            result = left ;
            break ;
    }
    return(result );
}

CRexRegExpr_Impl::ParseTree::FallibleNodePtr
CRexRegExpr_Impl::ParseTree::constructConcatNode( FallibleNodePtr const& left ,
                                                 FallibleNodePtr const& right )
{
    FallibleNodePtr     result ;
    switch( left.state() )
    {
        case CRegExpr::ok :
            {
                switch( right.state() )
                {
                    case CRegExpr::ok :
                        result = new ConcatNode( left.node() , right.node() ) ;
                        break ;

                    case CRegExpr::emptyExpr :
                        result = left ;
                        break ;

                    default :
                        result = right ;
                        break ;
                }
            }
            break ;

        case CRegExpr::emptyExpr :
            result = right ;
            break ;

        default :
            result = left ;
            break ;
    }
    return(result );
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\regxnode.cpp ===
/****************************************************************************/
/*  File:       regxnode.cc                                                 */
/*  Author:     J. Kanze                                                    */
/*  Date:       28/12/1993                                                  */
/*      Copyright (c) 1993 James Kanze                                      */
/* ------------------------------------------------------------------------ */

#include <libpch.h>
#include "regeximp.h"

#include "regxnode.tmh"
//      Base class...
// ==========================================================================
void
CRexRegExpr_Impl::ParseTree::ParseTreeNode::visit( Visitor const& fnc )
{
    fnc.visitNode( *this ) ;
}

void
CRexRegExpr_Impl::ParseTree::ParseTreeNode::dumpNodeHeader(
                        std::ostream&  out ,
                        int                 indent ) const {
    out << std::string( 4 * indent , ' ' )
        << nodeName()
        << ": "
        << (myMayBeEmpty ? "true" : "false")
        << " "
        << DisplayNFA( myLeftLeaves )
        << " "
        << DisplayNFA( myRightLeaves ) ;
}

//      LeafNode...
// ==========================================================================
CRexRegExpr_Impl::ParseTree::LeafNode::LeafNode(
                    SetOfChar const& matchingChars )
    :    myId( 0 )
    ,    myMatchingChars( matchingChars )
{
}

void
CRexRegExpr_Impl::ParseTree::LeafNode::annotate( NFAStateTable& nfa )
{
    myId = nfa.createNewState( myMatchingChars ) ;
    myLeftLeaves.set( myId ) ;
    myRightLeaves.set( myId ) ;
    myMayBeEmpty = false ;
}

void
CRexRegExpr_Impl::ParseTree::LeafNode::dump(
                        std::ostream&  out ,
                        int                 indent ) const
{
    dumpNodeHeader( out , indent ) ;
    out << ": " << myId << " " << DisplaySOC( myMatchingChars ) << '\n' ;
}

char const*
CRexRegExpr_Impl::ParseTree::LeafNode::nodeName() const
{
    return "LEAF" ;
}

//      AcceptNode...
// ==========================================================================
CRexRegExpr_Impl::ParseTree::AcceptNode::AcceptNode(
                        CRexRefCntPtr< ParseTreeNode >
                                            tree ,
                        int                 acceptCode )
    :   mySubtree( tree )
    ,   myId( acceptCode )
{
}

void
CRexRegExpr_Impl::ParseTree::AcceptNode::visit( Visitor const& fnc )
{
    mySubtree->visit( fnc ) ;
    fnc.visitNode( *this ) ;
}

void
CRexRegExpr_Impl::ParseTree::AcceptNode::annotate( NFAStateTable& nfa )
{
    myLeftLeaves = mySubtree->leftLeaves() ;
    myRightLeaves = mySubtree->rightLeaves() ;
    myMayBeEmpty = mySubtree->mayBeEmpty() ;
    for ( CRexDynBitVector::Iterator iter = myRightLeaves.iterator() ;
                                    ! iter.isDone() ;
                                    iter.next() ) {
        nfa[ iter.current() ].setAccept( myId ) ;
    }
    if ( myMayBeEmpty ) {
        nfa[ 0 ].setAccept( myId ) ;
    }
}

void
CRexRegExpr_Impl::ParseTree::AcceptNode::dump(
                        std::ostream&  out ,
                        int                 indent ) const
{
    dumpNodeHeader( out , indent ) ;
    out << ": " << myId << '\n' ;
    mySubtree->dump( out , indent + 1 ) ;
}

char const*
CRexRegExpr_Impl::ParseTree::AcceptNode::nodeName() const
{
    return "ACCEPT" ;
}

//      ClosureNode...
// ==========================================================================
void
CRexRegExpr_Impl::ParseTree::ClosureNode::visit( Visitor const& fnc )
{
    mySubtree->visit( fnc ) ;
    fnc.visitNode( *this ) ;
}

void
CRexRegExpr_Impl::ParseTree::ClosureNode::setLeaves()
{
    myLeftLeaves = mySubtree->leftLeaves() ;
    myRightLeaves = mySubtree->rightLeaves() ;
}

void
CRexRegExpr_Impl::ParseTree::ClosureNode::dump(
                        std::ostream&  out ,
                        int                 indent ) const
{
    dumpNodeHeader( out , indent ) ;
    out << '\n' ;
    mySubtree->dump( out , indent + 1 ) ;
}

CRexRegExpr_Impl::ParseTree::ClosureNode::ClosureNode(
                    CRexRefCntPtr< ParseTreeNode > closedSubtree )
    :   mySubtree( closedSubtree )
{
}

//      KleinClosureNode...
// ==========================================================================
CRexRegExpr_Impl::ParseTree::KleinClosureNode::KleinClosureNode(
                    CRexRefCntPtr< ParseTreeNode > closedSubtree )
    :   ClosureNode( closedSubtree )
{
}

void
CRexRegExpr_Impl::ParseTree::KleinClosureNode::annotate( NFAStateTable& nfa )
{
    setLeaves() ;
    myMayBeEmpty = true ;
    nfa.setFollows( mySubtree->rightLeaves() , mySubtree->leftLeaves() ) ;
}

char const*
CRexRegExpr_Impl::ParseTree::KleinClosureNode::nodeName() const
{
    return "KCLOSURE" ;
}

//      PositiveClosureNode...
// ==========================================================================
CRexRegExpr_Impl::ParseTree::PositiveClosureNode::PositiveClosureNode(
                        CRexRefCntPtr< ParseTreeNode > closedSubtree )
    :   ClosureNode( closedSubtree )
{
}

void
CRexRegExpr_Impl::ParseTree::PositiveClosureNode::annotate( NFAStateTable& nfa )
{
    setLeaves() ;
    myMayBeEmpty = mySubtree->mayBeEmpty() ;
    nfa.setFollows( mySubtree->rightLeaves() , mySubtree->leftLeaves() ) ;
}

char const*
CRexRegExpr_Impl::ParseTree::PositiveClosureNode::nodeName() const
{
    return "PCLOSURE" ;
}

//      OptionalNode...
// ==========================================================================
CRexRegExpr_Impl::ParseTree::OptionalNode::OptionalNode(
                        CRexRefCntPtr< ParseTreeNode > closedSubtree )
    :   ClosureNode( closedSubtree )
{
}

void
CRexRegExpr_Impl::ParseTree::OptionalNode::annotate( NFAStateTable& )
{
    setLeaves() ;
    myMayBeEmpty = true ;
}

char const*
CRexRegExpr_Impl::ParseTree::OptionalNode::nodeName() const
{
    return "QCLOSURE" ;
}

//      LinkNode...
// ==========================================================================
CRexRegExpr_Impl::ParseTree::LinkNode::LinkNode(
                        CRexRefCntPtr< ParseTreeNode > leftSubtree ,
                        CRexRefCntPtr< ParseTreeNode > rightSubtree )
    :   myLeft( leftSubtree )
    ,   myRight( rightSubtree )
{
}

void
CRexRegExpr_Impl::ParseTree::LinkNode::visit( Visitor const& fnc )
{
    myLeft->visit( fnc ) ;
    myRight->visit( fnc ) ;
    fnc.visitNode( *this ) ;
}

void
CRexRegExpr_Impl::ParseTree::LinkNode::dump(
                        std::ostream&  out ,
                        int                 indent ) const
{
    dumpNodeHeader( out , indent ) ;
    out << '\n' ;
    myLeft->dump( out , indent + 1 ) ;
    myRight->dump( out , indent + 1 ) ;
}

//      ConcatNode...
// ==========================================================================
CRexRegExpr_Impl::ParseTree::ConcatNode::ConcatNode(
                    CRexRefCntPtr< ParseTreeNode > leftSubtree ,
                    CRexRefCntPtr< ParseTreeNode > rightSubtree )
    :   LinkNode( leftSubtree , rightSubtree )
{
}

void
CRexRegExpr_Impl::ParseTree::ConcatNode::annotate( NFAStateTable& nfa )
{
    myLeftLeaves = myLeft->leftLeaves() ;
    if ( myLeft->mayBeEmpty() ) {
        myLeftLeaves |= myRight->leftLeaves() ;
    }
    myRightLeaves = myRight->rightLeaves() ;
    if ( myRight->mayBeEmpty() ) {
        myRightLeaves |= myLeft->rightLeaves() ;
    }
    myMayBeEmpty = myLeft->mayBeEmpty() && myRight->mayBeEmpty() ;
    nfa.setFollows( myLeft->rightLeaves() , myRight->leftLeaves() ) ;
}

char const*
CRexRegExpr_Impl::ParseTree::ConcatNode::nodeName() const
{
    return "CAT" ;
}

//      ChoiceNode...
// ==========================================================================
CRexRegExpr_Impl::ParseTree::ChoiceNode::ChoiceNode(
                    CRexRefCntPtr< ParseTreeNode > leftSubtree ,
                    CRexRefCntPtr< ParseTreeNode > rightSubtree )
    :   LinkNode( leftSubtree , rightSubtree )
{
}

void
CRexRegExpr_Impl::ParseTree::ChoiceNode::annotate( NFAStateTable& nfa )
{
    myLeftLeaves = myLeft->leftLeaves() | myRight->leftLeaves() ;
    myRightLeaves = myLeft->rightLeaves() | myRight->rightLeaves() ;
    myMayBeEmpty = myLeft->mayBeEmpty() || myRight->mayBeEmpty() ;
}

char const*
CRexRegExpr_Impl::ParseTree::ChoiceNode::nodeName() const
{
    return "OR" ;
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\regxtree.h ===
/****************************************************************************/
/*  File:       regxtree.h                                                */
/*  Author:     J. Kanze                                                    */
/*  Date:       28/12/1993                                                  */
/*      Copyright (c) 1993 James Kanze                                      */
/* ------------------------------------------------------------------------ */
//      Definition for ParseTree:
//      =========================
//
//      This file is designed to be included in regeximp.h.  In
//      particular, the type defined in this file should be a member
//      of CRexRegExpr_Impl.
// --------------------------------------------------------------------------

class ParseTree
{
public:
                        ParseTree() ;

    void                parse( std::istream&  expr ,
                               int                 delim ,
                               int                 acceptCode ) ;

    //      errorCode:
    //      ==========
    //
    //      Indicates the current state of the tree.
    // ----------------------------------------------------------------------
    CRegExpr::Status  errorCode() const ;

    //      leftMost, visit:
    //      ================
    //
    //      These functions are used to access the information
    //      necessary to build the NFA.
    // ----------------------------------------------------------------------
    SetOfNFAStates const&
                        leftMost() const ;

    //      merge:
    //      ======
    //
    //      Creates a new parse tree by or'ing this and other.  The
    //      new tree replaces this.
    // ----------------------------------------------------------------------
    void                merge( ParseTree const& other ) ;

    //      dump:
    //      =====
    //
    //      Just for debugging, displays the tree in human readable
    //      form.
    // ----------------------------------------------------------------------
    void                dump( std::ostream& output ) const ;

    class Visitor ;                     //  Forward decl., needed in Nodes.

    //      ParseTreeNode:
    //      ==============
    //
    //      This is the base type of all of the nodes of the
    //      ParseTree.
    // ----------------------------------------------------------------------
    class ParseTreeNode : public CRexRefCntObj
    {
    public:
        virtual             ~ParseTreeNode() {} ;

        //      access functions:
        //      =================
        //
        //      The following functions are used to read the
        //      attributes of a parse node.
        // ------------------------------------------------------------------
        bool                mayBeEmpty() const ;
        SetOfNFAStates const&
                            leftLeaves() const ;
        SetOfNFAStates const&
                            rightLeaves() const ;

        //      visit:
        //      ======
        //
        //      Visit the tree in depth first order.
        //
        //      The version in the base class is valid for classes
        //      without children.  Classes with children should first
        //      call visit on the children, then this visit.
        // ------------------------------------------------------------------
        virtual void        visit( Visitor const& fnc ) ;

        //      manipulate semantic attributes:
        //      ===============================
        //
        //      The following functions are designed to be called from
        //      the Visitor, and serve to manipulate the semantic
        //      attributes when visiting the tree
        // ------------------------------------------------------------------
        virtual void        annotate( NFAStateTable& nfa ) = 0 ;

        //      debugging functions:
        // ------------------------------------------------------------------
        virtual void        dump( std::ostream&  out ,
                                  int                 indent = 0 ) const = 0 ;
        virtual const char* nodeName() const = 0 ;

    protected:
        //      Constructor:
        //      ============
        //
        //      Assignment and copy are *not* supported.
        //
        //      The constructor is protected, since this is an
        //      abstract class and cannot be instantiated in itself.
        // ------------------------------------------------------------------
                            ParseTreeNode() ;

        //      attributes:
        //      ===========
        //
        //      The following are the semantic attributes of the parse
        //      tree nodes.  Since they will in general be
        //      set/modified by the derived classes, they are
        //      protected, and not private.  (Not generally a good
        //      idea, but since this entire class is a *private* data
        //      type of CRegExpr, they are not as accessible as it
        //      would immediately seem.)
        // ------------------------------------------------------------------
        bool                myMayBeEmpty ;
        SetOfNFAStates      myLeftLeaves ;
        SetOfNFAStates      myRightLeaves ;

        //      dumpNodeHeader:
        //      ===============
        //
        //      This just dumps the information common to all nodes.
        // ------------------------------------------------------------------
        void                dumpNodeHeader(
                                std::ostream&  out ,
                                int                 indent ) const ;

    private:

        //      Copy constructor and assignment:
        //      ================================
        //
        //      These are private, and there is no implementation (so
        //      copy and assignment are *not* supported).
        // ------------------------------------------------------------------
                            ParseTreeNode( ParseTreeNode const& other ) ;
        ParseTreeNode const&
                            operator=( ParseTreeNode const& other ) ;
    } ;

    //      visit:
    //      ======
    //
    //      This function is used to make a depth first traversal of
    //      the parse tree.  (It is the responsibility of the using
    //      function to ensure that the tree exists, eg.  errorState()
    //      == CRegExpr::ok.)
    // ----------------------------------------------------------------------
    class Visitor
    {
    public:
        virtual             ~Visitor() {}
        virtual void        visitNode( ParseTreeNode& targetNode ) const = 0 ;
    } ;
    void                visit( Visitor const& fnc ) ;

private:
    //      LeafNode:
    //      =========
    //
    //      This node represents a leaf in the parse tree.
    // ----------------------------------------------------------------------
    class LeafNode : public ParseTreeNode
    {
    public:
                            LeafNode( SetOfChar const& matchingChars ) ;

        virtual void        annotate( NFAStateTable& nfa ) ;
        virtual void        dump( std::ostream& out , int indent ) const ;
        virtual char const* nodeName() const ;
    private:
        LeafId              myId ;
        SetOfChar           myMatchingChars ;
    } ;

    //      AcceptNode:
    //      ===========
    //
    //      A match comporting this node means accept, with the
    //      designated accept code.
    // ----------------------------------------------------------------------
    class AcceptNode : public ParseTreeNode
    {
    public:
                            AcceptNode( CRexRefCntPtr< ParseTreeNode > tree ,
                                        int acceptId = 0 ) ;

        virtual void        visit( Visitor const& fnc ) ;
        virtual void        annotate( NFAStateTable& nfa ) ;
        virtual void        dump( std::ostream& out , int indent ) const ;
        virtual char const* nodeName() const ;
    private:
        CRexRefCntPtr< ParseTreeNode >
                            mySubtree ;
        int                 myId ;
    } ;

    //      Closure Nodes:
    //      ==============
    //
    //      One for Klein closure (0 or more occurances), one for
    //      positive closure (1 or more occurances), and one for a
    //      ?-closure (0 or 1 occurances, not really a closure at all,
    //      but similar enough to be treated as one here).
    // ----------------------------------------------------------------------
    class ClosureNode : public ParseTreeNode
    {
    public:
        virtual void        visit( Visitor const& fnc ) ;
        virtual void        dump( std::ostream& out , int indent ) const ;

    protected:
                            ClosureNode(
                                CRexRefCntPtr< ParseTreeNode > closedSubtree ) ;
        void                setLeaves() ;

    protected:
        CRexRefCntPtr< ParseTreeNode >
                            mySubtree ;
    } ;

    class KleinClosureNode : public ClosureNode
    {
    public:
                            KleinClosureNode(
                                CRexRefCntPtr< ParseTreeNode > closedSubtree ) ;

        virtual void        annotate( NFAStateTable& nfa ) ;
        virtual char const* nodeName() const ;
    } ;

    class PositiveClosureNode : public ClosureNode
    {
    public:
                            PositiveClosureNode(
                                CRexRefCntPtr< ParseTreeNode > closedSubtree ) ;

        virtual void        annotate( NFAStateTable& nfa ) ;
        virtual char const* nodeName() const ;
    } ;

    class OptionalNode : public ClosureNode
    {
    public:
                            OptionalNode(
                                CRexRefCntPtr< ParseTreeNode > closedSubtree ) ;

        virtual void        annotate( NFAStateTable& nfa ) ;
        virtual char const* nodeName() const ;
    } ;

    //      Link nodes:
    //      ===========
    //
    //      There are two ways to link two subtrees: concatenation or
    //      choice (or).
    // ----------------------------------------------------------------------
    class LinkNode : public ParseTreeNode
    {
    public:
                            LinkNode(
                                CRexRefCntPtr< ParseTreeNode > leftSubtree ,
                                CRexRefCntPtr< ParseTreeNode > rightSubtree ) ;

        virtual void        visit( Visitor const& fnc ) ;
        virtual void        dump( std::ostream& out , int indent ) const ;
    protected:
        CRexRefCntPtr< ParseTreeNode >
                            myLeft ;
        CRexRefCntPtr< ParseTreeNode >
                            myRight ;
    } ;

    class ConcatNode : public LinkNode
    {
    public:
                            ConcatNode(
                                CRexRefCntPtr< ParseTreeNode > leftSubtree ,
                                CRexRefCntPtr< ParseTreeNode > rightSubtree ) ;

        virtual void        annotate( NFAStateTable& nfa ) ;
        virtual char const* nodeName() const ;
    } ;

    class ChoiceNode : public LinkNode
    {
    public:
                            ChoiceNode(
                                CRexRefCntPtr< ParseTreeNode > leftSubtree ,
                                CRexRefCntPtr< ParseTreeNode > rightSubtree ) ;

        virtual void        annotate( NFAStateTable& nfa ) ;
        virtual char const* nodeName() const ;
    } ;

    // ======================================================================
    //      FallibleNodePtr:
    //
    //      This class physically contains all of our data.  It is
    //      defined separately, however, in order that it may also
    //      serve as a simple return value for the recursive descent
    //      parsing functions.
    //
    //      In practice, this class is a variation on a Fallible of
    //      a CRexRefCntPtr< ParseTreeNode >.  Instead of a simple
    //      boolean, however, the status is a CRegExpr::Status.  The
    //      node is only valid if the status == CRegExpr::ok.
    //
    //      This class is unmodifiable, except by assignment.
    // ----------------------------------------------------------------------
    class FallibleNodePtr
    {
    public:
        //      Constructors, destructor and assignment:
        //      ----------------------------------------
        //
        //      In addition to copy, the following constructors are
        //      supported:
        //
        //      default:    Sets the status to CRegExpr::emptyExpr.
        //
        //      CRegExpr::Status:
        //                  Sets the status to the given status (which
        //                  may not be CRegExpr::ok).
        //
        //      ParseTreeNode*:
        //                  Sets the status to CRegExpr::ok.  This
        //                  constructor is designed expressedly for
        //                  implicit conversions -- a function
        //                  returning a FallibleNodePtr may simply
        //                  return a pointer to a new'ed
        //                  ParseTreeNode.
        //
        //      Copy, assignment and destruction are provided by the
        //      compiler generated defaults.
        // ------------------------------------------------------------------
                            FallibleNodePtr() ;
                            FallibleNodePtr( CRegExpr::Status state ) ;
                            FallibleNodePtr( ParseTreeNode* node ) ;

        bool                isValid() const ;
        CRegExpr::Status  state() const ;
        CRexRefCntPtr< ParseTreeNode >
                            node() const ;
        ParseTreeNode*      operator->() const ;

    private:
        CRegExpr::Status  myState ;
        CRexRefCntPtr< ParseTreeNode >
                            myNode ;
    } ;

    FallibleNodePtr     myRoot ;

    // ======================================================================
    //      parse...Node:
    //      =============
    //
    //      The functions used in the recursive descent.  These are
    //      all static, since they don't use any of the member
    //      variables.
    //
    //      The return value in all cases is a FallibleNodePtr,
    //      basically, a Fallible for a reference counted pointer,
    //      but with an error status instead of just a bool for the
    //      error case.
    // ----------------------------------------------------------------------
    static FallibleNodePtr
                        parseOrNode(
                            std::istream&  expr ,
                            int                 delim ) ;
    static FallibleNodePtr
                        parseCatNode(
                            std::istream&  expr ,
                            int                 delim ) ;
    static FallibleNodePtr
                        parseClosureNode(
                            std::istream&  expr ,
                            int                 delim ) ;
    static FallibleNodePtr
                        parseLeafNode(
                            std::istream&  expr ,
                            int                 delim ) ;
    static FallibleNodePtr
                        constructChoiceNode( FallibleNodePtr const& left ,
                                             FallibleNodePtr const& right ) ;
    static FallibleNodePtr
                        constructConcatNode( FallibleNodePtr const& left ,
                                             FallibleNodePtr const& right ) ;
} ;
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\regxnfa.inl ===
/****************************************************************************/
/*  File:       regxnfa.ihh                                                 */
/*  Author:     J. Kanze                                                    */
/*  Date:       30/03/1994                                                  */
/*      Copyright (c) 1994 James Kanze                                      */
/* ------------------------------------------------------------------------ */
//      Inline functions for CRexRegExpr_Impl::NFAStateTable.
//
//      This file is designed to be included from RegExpr.lhh, after
//      the full class definition.  No guarantee is given concerning
//      its use in any other context.
// --------------------------------------------------------------------------

inline
CRexRegExpr_Impl::NFAStateTable::NFAState::NFAState()
    :   acceptCode( -1 )
{
}

inline
CRexRegExpr_Impl::NFAStateTable::NFAState::NFAState(
                        SetOfChar const& charClass )
    :   acceptCode( -1 )
    ,   legalChars( charClass )
{
}

inline void
CRexRegExpr_Impl::NFAStateTable::NFAState::setAccept( int newAcceptCode )
{
    ASSERT( acceptCode == -1 || acceptCode == newAcceptCode);
    acceptCode = newAcceptCode ;
}

inline bool
CRexRegExpr_Impl::NFAStateTable::defined() const
{
    return myTable.size() > 0 ;
}

inline CRexRegExpr_Impl::NFAStateTable::NFAState&
CRexRegExpr_Impl::NFAStateTable::operator[]( CRexRegExpr_Impl::LeafId state )
{
    return myTable[ state ] ;
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\bitvect.h ===
/****************************************************************************/
/*  File:       bitvect.h                                                  */
/*  Author:     J. Kanze                                                    */
/*  Date:       06/01/1994                                                  */
/*      Copyright (c) 1994 James Kanze                                      */
/* ------------------------------------------------------------------------ */
/*  Modified:   11/11/1994  J. Kanze                                        */
/*      Merged in DynBitVect.  Adapted to new coding standards.          */
/*  Modified:   21/11/1994  J. Kanze                                        */
/*      Made interface conform to ArrayOf.                               */
/*  Modified:   07/08/2000  J. Kanze                                        */
/*      Ported to current library conventions and the standard library.     */
/* ------------------------------------------------------------------------ */
//      CBitVector:
//      =============
//
//      isSet:              returns true if (any of) the specified
//                          bits are set.  Possible specifiers are:
//                          index (an int, selecting a specific bit),
//                          any, none, or all.
//
//      find:               find the first matching bit starting at a
//                          given point in the vector.
//
//      operator[]:         indexing.  An out of bounds index causes
//                          an assertion failure.
//
//      set:                set one or more bits, as selected by the
//                          argument.  The following argument types
//                          are allowed: index (an int, selecting a
//                          single bit), all, or another CBitVector
//                          (selecting all of the bits set in this
//                          set).  When another CBitVector is used,
//                          it must either be dynamic, or have exactly
//                          the same size as this bit vector.
//
//      reset:              as above, but resets the specified bit(s).
//
//      toggle:             as set, but toggles the specified bit(s).
//
//      intersect:          logical and, only supported with another
//                          CBitVector.
//
//      complement:         complement.  The equivalent of `toggle(
//                          all )'.
//
//      The functions and, or, xor and not have been removed from this
//      version, as their names conflicted with new keywords:-).
//
//      isEqual,
//      isNotEqual,
//      isSubsetOf,
//      isStrictSubsetOf,
//      isSupersetOf,
//      isStrictSupersetOf: returns true if the specified relation
//                          is true, false otherwise.  In all
//                          cases, the bit vectors are processed
//                          semantically as a `set of cardinal'.
//
//      operators:          in addition to [] and =, the following
//                          operators are defined: &, |, ^, ~, &=, |=,
//                          ^=, +, +=, *, *=, -, -=, ==, !=, <, <=, >,
//                          >=.  Operators + and += have the same
//                          semantics as | and |=, operators * and *=
//                          the same as & and &=.  The comparison
//                          operators are defined by processing the
//                          bit vectors semantically as `set of
//                          cardinal', with < as isStrictSubsetOf, <=
//                          isSubsetOf, > isStrictSupersetOf and >=
//                          isSupersetOf.
// --------------------------------------------------------------------------

#ifndef REX_BITVECT_HH
#define REX_BITVECT_HH

#include <inc/global.h>
#include <inc/bitvimpl.h>

// ==========================================================================
//      CBitVector:
//      =============
//
//      This is a template class for fixed length bit vectors.
// --------------------------------------------------------------------------

template< int bitCount >
class CBitVector : public CBitVectorImpl
{
    typedef CBitVectorImpl Impl ;
public :
    typedef CBitVIterator< CBitVector< bitCount > > Iterator ;

    //      Constructors, Destructors and Assignment:
    //      =========================================
    //
    //      The following constructors (in addition to the copy
    //      constructor) are provided:
    //
    //      default:            Initializes all of the bits to 0.
    //
    //      unsigned long:      Uses the unsigned long to initialize
    //                          the bits in the vector; the low order
    //                          bit of the unsigned long goes into bit
    //                          0, and so on.  If the bit vector
    //                          contains more bits than an unsigned
    //                          long, the additional bits are
    //                          initialized to 0.  If the bit vector
    //                          contains less bits, the extra bits are
    //                          simply ignored.
    //
    //      std::string:        The string is used to initialize the
    //                          bits in the vector.  '0', 'F' or 'f'
    //                          initialize a bit to 0, '1', 'T' or 't'
    //                          to 1.  White space is ignored.  Any
    //                          other characters will result in an
    //                          assertion failure (to be replaced by
    //                          an exception ulteriorly).
    //
    //                          The first significant character in the
    //                          string initializes bit 0, the next bit
    //                          1, and so on.  WARNING: this is the
    //                          opposite of the proposed ISO 'bits'
    //                          class!
    //
    //                          If the number of significant
    //                          characters in the string is less than
    //                          the number of bits in the vector, the
    //                          additional bits will be initialized to
    //                          0.  It is an error (assertion failure
    //                          for now) for the string to contain
    //                          more significant characters than there
    //                          are bits.
    //
    //      const char*:        Exactly as std::string.
    //
    //      The copy constructor, the destructor, and the assignment
    //      operator are provided by the compiler (at least for now).
    // ----------------------------------------------------------------------
                        CBitVector() ;
    explicit            CBitVector( unsigned long initValue ) ;
    explicit            CBitVector( std::string const& initValue ) ;
    explicit            CBitVector( char const* initValue ) ;

    //      Access functions:
    //      =================
    //
    //      These functions are used to read the bit vector as a unit.
    //
    //      Calling 'asShort' or 'asLong' for a bit vector with more
    //      than 16 or 32 bits respectively results in an assertion
    //      failure, even if all of the excess bits are 0.  (This was
    //      deemed preferrable to using the actual number of bits in a
    //      short or a long, to ensure portability.)
    //
    //      'asString' returns a string consisting of uniquely 0's and
    //      1's, suitable for use in the constructor.  (Ie: bit 0 is
    //      the first character in the string, bit 1 the next, and so
    //      on.)  The number of characters in the string is always
    //      exactly equal to bitCount.
    // ----------------------------------------------------------------------
    unsigned short      asShort() const ;
    unsigned long       asLong() const ;
    std::string      asString() const ;

    //      Predicates:
    //      ===========
    //
    //      These const Functions return true or false.
    //
    //      isSet:      Returns true if the given bit is set.
    //
    //      contains:   An alias for isSet.  Semantically, it refers to
    //                  the set nature of the bit vector,
    //
    //      isEmpty:    Returns true if no bits are set.  (Set is empty.)
    // ----------------------------------------------------------------------
    bool                isSet( BitIndex bitNo ) const ;
    bool                contains( BitIndex bitNo ) const ;
    bool                isEmpty() const ;

    //      Attributes:
    //      ===========
    //
    //      find:       returns the index of the first bit matching
    //                  the targetValue, starting from the 'from'
    //                  parameter (inclusive).  If no bit matches,
    //                  returns CBitVectorImpl::infinity.
    //
    //      count:      returns the number of *set* bits in the
    //                  vector.
    // ----------------------------------------------------------------------
    BitIndex            find( bool targetValue , BitIndex from = 0 ) const ;
    BitIndex            count() const ;

    Iterator            iterator() const ;
    Iterator            begin() const ;
    Iterator            end() const ;

    //      Relationships:
    //      ==============
    //
    //      A partial ordering is defined by the subset relationship.
    // ----------------------------------------------------------------------
    bool                isEqual(
                            CBitVector< bitCount > const& other ) const ;
    bool                isNotEqual(
                            CBitVector< bitCount > const& other ) const ;
    bool                isSubsetOf(
                            CBitVector< bitCount > const& other ) const ;
    bool                isStrictSubsetOf(
                            CBitVector< bitCount > const& other ) const ;
    bool                isSupersetOf(
                            CBitVector< bitCount > const& other ) const ;
    bool                isStrictSupersetOf(
                            CBitVector< bitCount > const& other ) const ;

    //      Basic bit manipulations:
    //      ========================
    //
    //      Set sets the bit(s) to 1 (logical or).
    //
    //      Reset resets the bit(s) to 0.
    //
    //      Complement toggles (complements) the bit(s) (logical xor).
    //
    //      Intersect is a logical and.
    //
    //      With the exception of intersect, all of these functions
    //      have three variants: one for a single bit, one where a
    //      second array specifies the bits concerned, and one with
    //      no arguments, which acts on all of the bits.
    //
    //      These functions provide the basis for the logical
    //      operations defined later.
    // ----------------------------------------------------------------------
    void                set( BitIndex bitNo ) ;
    void                set( CBitVector< bitCount > const& other ) ;
    void                set() ;

    void                reset( BitIndex bitNo ) ;
    void                reset( CBitVector< bitCount > const& other ) ;
    void                reset() ;
    void                clear() ;       // synonyme for reset()...

    void                complement( BitIndex bitNo ) ;
    void                complement( CBitVector< bitCount > const& other ) ;
    void                complement() ;

    void                intersect( CBitVector< bitCount > const& other ) ;

    //      Operator overloads:
    //      ===================
    //
    //      All reasonable operators are overloaded.
    //
    //      Note that even the classic binary operators are overloaded
    //      as member functions.  This is necessary, as most compilers
    //      will not allow a template function with a non-type
    //      argument (ie: bitCnt).
    //
    //      The operators for comparison of inequality (<, <=, >, >=)
    //      use the subset relationship, ie: < means is a strict
    //      subset of, etc.  Since this relation defines only a
    //      partial ordering, '!  (a < b)' does not necessarily imply
    //      'a >= b'.
    // ----------------------------------------------------------------------
    CBitVector< bitCount >&
                        operator&=( CBitVector< bitCount > const& other ) ;
    CBitVector< bitCount >&
                        operator|=( CBitVector< bitCount > const& other ) ;
    CBitVector< bitCount >&
                        operator^=( CBitVector< bitCount > const& other ) ;

    CBitVector< bitCount >&
                        operator+=( CBitVector< bitCount > const& other ) ;
    CBitVector< bitCount >&
                        operator+=( BitIndex bitNo ) ;
    CBitVector< bitCount >&
                        operator-=( CBitVector< bitCount > const& other ) ;
    CBitVector< bitCount >&
                        operator-=( BitIndex bitNo ) ;
    CBitVector< bitCount >&
                        operator*=( CBitVector< bitCount > const& other ) ;

    bool                operator[]( BitIndex index ) const ;
    CBitVAccessProxy< CBitVector< bitCount > >
                        operator[]( BitIndex index ) ;

    //      Support functions:
    //      ==================
    //
    //      The following two functions are for support for container
    //      classes.
    //
    //      The compare functions defines an *arbitrary* ordering
    //      relationship, in no way related to subsets, for example.
    //      (It is not even guaranteed that the ordering will remain
    //      the same between releases.)
    // ----------------------------------------------------------------------
    unsigned            hash() const ;
    int                 compare(
                            CBitVector< bitCount > const& other ) const ;

private :
    CBitVectorImpl::Byte
                        myBuffer[
                            (bitCount / CBitVectorImpl::bitsPerByte) +
                            (bitCount % CBitVectorImpl::bitsPerByte != 0) ] ;
} ;

#include <inc/bitvect.inl>

template< int bitCount >
inline bool
operator==( CBitVector< bitCount > const& op1 ,
            CBitVector< bitCount > const& op2 )
{
    return op1.isEqual( op2 ) ;
}

template< int bitCount >
inline bool
operator!=( CBitVector< bitCount > const& op1 ,
            CBitVector< bitCount > const& op2 )
{
    return op1.isNotEqual( op2 ) ;
}

template< int bitCount >
inline bool
operator<( CBitVector< bitCount > const& op1 ,
           CBitVector< bitCount > const& op2 )
{
    return op1.isStrictSubsetOf( op2 ) ;
}

template< int bitCount >
inline bool
operator<=( CBitVector< bitCount > const& op1 ,
            CBitVector< bitCount > const& op2 )
{
    return op1.isSubsetOf( op2 ) ;
}

template< int bitCount >
inline bool
operator>( CBitVector< bitCount > const& op1 ,
           CBitVector< bitCount > const& op2 )
{
    return op1.isStrictSupersetOf( op2 ) ;
}

template< int bitCount >
inline bool
operator>=( CBitVector< bitCount > const& op1 ,
            CBitVector< bitCount > const& op2 )
{
    return op1.isSupersetOf( op2 ) ;
}

template< int bitCount >
inline CBitVector< bitCount >
operator+( CBitVector< bitCount > const& op1 ,
           CBitVector< bitCount > const& op2 )
{
    CBitVector< bitCount >
                        result( op1 ) ;
    result += op2 ;
    return result ;
}

template< int bitCount >
inline CBitVector< bitCount >
operator+( CBitVector< bitCount > const& op1 ,
           __TYPENAME CBitVector< bitCount >::BitIndex op2 )
{
    CBitVector< bitCount >
                        result( op1 ) ;
    result += op2 ;
    return result ;
}

template< int bitCount >
inline CBitVector< bitCount >
operator-( CBitVector< bitCount > const& op1 ,
           CBitVector< bitCount > const& op2 )
{
    CBitVector< bitCount >
                        result( op1 ) ;
    result -= op2 ;
    return result ;
}

template< int bitCount >
inline CBitVector< bitCount >
operator-( CBitVector< bitCount > const& op1 ,
           __TYPENAME CBitVector< bitCount >::BitIndex op2 )
{
    CBitVector< bitCount >
                        result( op1 ) ;
    result -= op2 ;
    return result ;
}

template< int bitCount >
inline CBitVector< bitCount >
operator*( CBitVector< bitCount > const& op1 ,
           CBitVector< bitCount > const& op2 )
{
    CBitVector< bitCount >
                        result( op1 ) ;
    result *= op2 ;
    return result ;
}

template< int bitCount >
inline CBitVector< bitCount >
operator|( CBitVector< bitCount > const& op1 ,
           CBitVector< bitCount > const& op2 )
{
    CBitVector< bitCount >
                        result( op1 ) ;
    result |= op2 ;
    return result ;
}

template< int bitCount >
inline CBitVector< bitCount >
operator&( CBitVector< bitCount > const& op1 ,
           CBitVector< bitCount > const& op2 )
{
    CBitVector< bitCount >
                        result( op1 ) ;
    result &= op2 ;
    return result ;
}

template< int bitCount >
inline CBitVector< bitCount >
operator^( CBitVector< bitCount > const& op1 ,
           CBitVector< bitCount > const& op2 )
{
    CBitVector< bitCount >
                        result( op1 ) ;
    result ^= op2 ;
    return result ;
}

template< int bitCount >
inline CBitVector< bitCount >
operator~( CBitVector< bitCount > const& op )
{
    CBitVector< bitCount >
                        result( op ) ;
    result.complement() ;
    return result ;
}
#endif
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\counter.h ===
/****************************************************************************/
/*  File:       counter.h                                                  */
/*  Author:     J. Kanze                                                    */
/*  Date:       03/06/1994                                                  */
/*      Copyright (c) 1994 James Kanze                                      */
/* ------------------------------------------------------------------------ */
/*  Modified:   03/11/1994  J. Kanze                                        */
/*      Adapted to current naming conventions and coding guidelines.        */
/* ------------------------------------------------------------------------ */
/*  Modified:   13/01/2000  J. Kanze                                        */
/*      Rendue gnrique (plus ou moins -- sans <limits>, c'est difficile,  */
/*      g++ n'a toujours pas de <limits>).                                  */
/* ------------------------------------------------------------------------ */
//      CRexCounter:
//      ===========
//
//      (This class was actually written long before the date above,
//      but for some reason, it didn't get a header.)
//
//      <lang=french>
//      Cette classe est en fait ni plus ni moins qu'un entier ligot.
//      Elle s'initialise automatiquement  0, et le seul opration
//      permis, c'est l'incrmentation.  (Aussi, elle vrifie qu'il
//      n'y a pas de dbordement.)
//
//      Il y a en fait deux versions de cette classe : la version
//      complte ne fonctionne que si le compilateur supporte
//      <limits>, ce qui n'est pas le cas, par exemple, de g++ (dbut
//      2000, au moins). La version rduite n'a pas besoin de
//      <limits>, mais ne permet l'instantiation que pour les types ou
//      ~static_cast<T>( 0 ) correspond  la valeur positive maximum :
//      unsigned, par exemple, mais non int.
// --------------------------------------------------------------------------
//      <lang=english>
//      This class is just a restricted integer; it is automatically
//      initialized to 0, and can only be incremented.  It also
//      verifies that there is no overflow.
//
//      In fact, there are two versions of this class: the complete
//      version will only work if the compiler supports <limits>,
//      which isn't the case, for example, for g++ (early 2000, at
//      least).  The restricted version doesn't need <limits>, but
//      can only be instantiated for types where ~static_cast<T>( 0 )
//      correspond to the maximum positive value: unsigned, for
//      example, but not int.
// --------------------------------------------------------------------------

#ifndef REX_COUNTER_HH
#define REX_COUNTER_HH

#include <inc/global.h>

template< class T >
class CRexCounter
{
public:
    explicit 	    	CRexCounter( T initialValue = 0 ) ;

    T                   value() const ;
                        operator T() const ;

    void                incr() ;
    void                decr() ;

    CRexCounter&         operator++() ;
    CRexCounter          operator++( int ) ;
    CRexCounter&         operator--() ;
    CRexCounter          operator--( int ) ;

    void                clear( T initialValue = 0 ) ;

    unsigned            hashCode() const ;
    int                 compare( CRexCounter< T > const& other ) const ;

private:
    T                   myCount ;
} ;

#include <inc/counter.inl>
#endif
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\counter.inl ===
/****************************************************************************/
/*  File:       counter.ihh                                                 */
/*  Author:     J. Kanze                                                    */
/*  Date:       20/11/1996                                                  */
/*      Copyright (c) 1996 James Kanze                                      */
/* ------------------------------------------------------------------------ */


//       remplacer par std::numeric_limits< T >::max(), quand les
//      compilateurs seront tous  jour.
#define Rex_upperLimit(T) ~static_cast<T>( 0 )

template< class T >
inline
CRexCounter< T >::CRexCounter( T initialValue )
    :   myCount( initialValue )
{
    if ( 0 ) {
        char                dummyForControl[ Rex_upperLimit(T) > 0 ] ;
    }
}

template< class T >
inline T
CRexCounter< T >::value() const
{
    return myCount ;
}

template< class T >
inline
CRexCounter< T >::operator T() const
{
    return myCount ;
}

template< class T >
inline void
CRexCounter< T >::incr()
{
    ASSERT( myCount < Rex_upperLimit(T) ); //Counter overflow
    myCount ++ ;
}

template< class T >
inline void
CRexCounter< T >::decr()
{
    ASSERT( myCount > 0 ); // Counter underflow
    myCount -- ;
}

template< class T >
inline CRexCounter< T >&
CRexCounter< T >::operator++()
{
    incr() ;
    return *this ;
}

template< class T >
inline CRexCounter< T >
CRexCounter< T >::operator++( int )
{
    CRexCounter          tmp( *this ) ;
    incr() ;
    return tmp ;
}

template< class T >
inline CRexCounter< T >&
CRexCounter< T >::operator--()
{
    decr() ;
    return *this ;
}

template< class T >
inline CRexCounter< T >
CRexCounter< T >::operator--( int )
{
    CRexCounter          tmp( *this ) ;
    decr() ;
    return tmp ;
}

template< class T >
inline void
CRexCounter< T >::clear( T initialValue )
{
    myCount = initialValue ;
}

template< class T >
inline unsigned
CRexCounter< T >::hashCode() const
{
    return static_cast< unsigned>( myCount ) ;
}

template< class T >
inline int
CRexCounter< T >::compare( CRexCounter< T > const& other ) const
{
    return myCount > other.myCount
        ?   1
        :   myCount < other.myCount
        ?   -1
        :   0 ;
}
#undef Rex_upperLimit
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\bitvimpl.inl ===
/****************************************************************************/
/*  File:       bitvimpl.ihh                                                */
/*  Author:     J. Kanze                                                    */
/*  Date:       06/01/1994                                                  */
/*      Copyright (c) 1994 James Kanze                                      */
/* ------------------------------------------------------------------------ */
/*  Modified:   04/08/2000  J. Kanze                                        */
/*      Ported to current library conventions and the standard library.     */
/* ------------------------------------------------------------------------ */

//      CBitVAccessProxy...
// --------------------------------------------------------------------------

template< class BitVect >
inline
CBitVAccessProxy< BitVect >::CBitVAccessProxy(
    BitVect&            owner ,
    BitIndex            bitNo )
    :   myOwner( &owner )
    ,   myBitNo( bitNo )
{
}

template< class BitVect >
inline
CBitVAccessProxy< BitVect >::operator bool() const
{
    return myOwner->isSet( myBitNo ) ;
}

template< class BitVect >
CBitVAccessProxy< BitVect >&
CBitVAccessProxy< BitVect >::operator=( bool other )
{
    if ( other ) {
        myOwner->set( myBitNo ) ;
    } else {
        myOwner->reset( myBitNo ) ;
    }
    return *this ;
}

//      CBitVIterator...
// --------------------------------------------------------------------------

template< class BitVect >
inline
CBitVIterator< BitVect >::CBitVIterator(
    BitVect const&      owner ,
    bool                targetStatus )
    :   myOwner( &owner )
    ,   myCurrentIndex( owner.find( targetStatus , 0 ) )
    ,   myTarget( targetStatus )
{
}

template< class BitVect >
inline
CBitVIterator< BitVect >::CBitVIterator()
    :   myOwner( NULL )
    ,   myCurrentIndex( CBitVectorImpl::infinity )
{
}

template< class BitVect >
inline CBitVectorImpl::BitIndex
CBitVIterator< BitVect >::current() const
{
    return myCurrentIndex ;
}

template< class BitVect >
inline CBitVectorImpl::BitIndex
CBitVIterator< BitVect >::operator*() const
{
    return current() ;
}

template< class BitVect >
inline bool
CBitVIterator< BitVect >::isDone() const
{
    return myCurrentIndex == CBitVectorImpl::infinity ;
}

template< class BitVect >
inline void
CBitVIterator< BitVect >::next()
{
    myCurrentIndex = myOwner->find( myTarget , myCurrentIndex + 1 ) ;
}

template< class BitVect >
inline CBitVIterator< BitVect >&
CBitVIterator< BitVect >::operator++()
{
    next() ;
    return *this ;
}

template< class BitVect >
inline CBitVIterator< BitVect >
CBitVIterator< BitVect >::operator++( int )
{
    CBitVIterator< BitVect >
                        result( *this ) ;
    next() ;
    return result ;
}

template< class BitVect >
inline bool
CBitVIterator< BitVect >::operator==(
    CBitVIterator< BitVect > const& other ) const
{
    return myCurrentIndex == other.myCurrentIndex ;
}

template< class BitVect >
inline bool
CBitVIterator< BitVect >::operator!=(
    CBitVIterator< BitVect > const& other ) const
{
    return myCurrentIndex != other.myCurrentIndex ;
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\setofchr.cpp ===
/****************************************************************************/
/*  File:       setofchr.cc                                                 */
/*  Author:     J. Kanze                                                    */
/*  Date:       04/03/91                                                    */
/* ------------------------------------------------------------------------ */
/*  Modified:   14/04/92    J. Kanze                                        */
/*      Converted to CCITT naming conventions.                              */
/*  Modified:   13/06/2000  J. Kanze                                        */
/*      Ported to current library conventions, iterators.                   */
/* ------------------------------------------------------------------------ */

#include <libpch.h>
#include <inc/setofchr.h>

#include "setofchr.tmh"

//      This funny function does nothing but resolve the ambiguity
//      which would otherwise be present when taking the address of
//      functions like CRexSetOfChar::set.  Because the address is used
//      to initialize a pointer to member function taking a char, the
//      ambiguity is resolved in favor of the version taking a char.
//
//      While we're at it, we wrap the member pointer in a function
//      object.
static inline std::mem_fun1_t< void , CRexSetOfChar , char >
charFnc( void (CRexSetOfChar::*pmf)( char ) )
{
    return std::mem_fun1( pmf ) ;
}

//      initialize...
// ---------------------------------------------------------------------------
inline void
CRexSetOfChar::initialize( std::string const& str )
{
    std::for_each(
        str.begin() , str.end() ,
        std::bind1st( charFnc( &CRexSetOfChar::set ) , this ) ) ;
}

//      Constructors...
// ---------------------------------------------------------------------------
CRexSetOfChar::CRexSetOfChar()
{
}

CRexSetOfChar::CRexSetOfChar( char element )
{
    set( element ) ;
}

CRexSetOfChar::CRexSetOfChar( unsigned char element )
{
    set( element ) ;
}

CRexSetOfChar::CRexSetOfChar( int element )
{
    set( element ) ;
}

CRexSetOfChar::CRexSetOfChar( Except , char element )
{
    set( element ) ;
    complement() ;
}

CRexSetOfChar::CRexSetOfChar( Except , unsigned char element )
{
    set( element ) ;
    complement() ;
}

CRexSetOfChar::CRexSetOfChar( Except , int element )
{
    set( element ) ;
    complement() ;
}

CRexSetOfChar::CRexSetOfChar( std::string const& elements )
{
    initialize( elements ) ;
}

CRexSetOfChar::CRexSetOfChar( Except , std::string const& elements )
{
    initialize( elements ) ;
    complement() ;
}

//      Character manipulations...
// --------------------------------------------------------------------------
void
CRexSetOfChar::set( std::string const& elements )
{
    std::for_each(
        elements.begin() ,
        elements.end() ,
        std::bind1st( charFnc( &CRexSetOfChar::set ) , this ) ) ;
}

void
CRexSetOfChar::reset( std::string const& elements )
{
    std::for_each(
        elements.begin() ,
        elements.end() ,
        std::bind1st( charFnc( &CRexSetOfChar::reset ) , this ) ) ;
}

void
CRexSetOfChar::complement( std::string const& elements )
{
    std::for_each(
        elements.begin() ,
        elements.end() ,
        std::bind1st( charFnc( &CRexSetOfChar::complement ) , this ) ) ;
}

//      Helper functions...
// --------------------------------------------------------------------------
std::string
CRexSetOfChar::asString() const
{
    std::string      result ;
    char                separ = '[' ;
    for ( iterator iter = iterator( *this ) ; ! iter.isDone() ; iter.next() ) {
        result.append( 1 , separ ) ;
        int                 chr = *iter ;
        if ( isprint( chr ) ) {
            result.append( 1 , static_cast< char >( chr ) ) ;
        } else {
            std::ostringstream    tmp ;
            tmp.setf( std::ios::hex , std::ios::basefield ) ;
            tmp.fill( '0' ) ;
            tmp << "\\x" << std::setw( 2 ) << chr ;
            result.append( tmp.str() ) ;
        }
        separ = ',' ;
    }
    if ( separ == '[' ) {
        result = "[]" ;
    } else {
        result.append( 1 , ']' ) ;
    }
    return result ;
}

//      Operators...
// --------------------------------------------------------------------------
CRexSetOfChar
operator~( CRexSetOfChar const& other )
{
    CRexSetOfChar        result( other ) ;
    result.complement() ;
    return result ;
}

CRexSetOfChar
operator&( CRexSetOfChar const& op1 , CRexSetOfChar const& op2 )
{
    CRexSetOfChar        result( op1 ) ;
    result &= op2 ;
    return result ;
}

CRexSetOfChar
operator|( CRexSetOfChar const& op1 , CRexSetOfChar const& op2 )
{
    CRexSetOfChar        result( op1 ) ;
    result |= op2 ;
    return result ;
}

CRexSetOfChar
operator^( CRexSetOfChar const& op1 , CRexSetOfChar const& op2 )
{
    CRexSetOfChar        result( op1 ) ;
    result ^= op2 ;
    return result ;
}

CRexSetOfChar
operator+( CRexSetOfChar const& op1 , CRexSetOfChar const& op2 )
{
    CRexSetOfChar        result( op1 ) ;
    result += op2 ;
    return result ;
}

CRexSetOfChar
operator+( CRexSetOfChar const& op1 , unsigned char op2 )
{
    CRexSetOfChar        result( op1 ) ;
    result += op2 ;
    return result ;
}

CRexSetOfChar
operator-( CRexSetOfChar const& op1 , CRexSetOfChar const& op2 )
{
    CRexSetOfChar        result( op1 ) ;
    result -= op2 ;
    return result ;
}

CRexSetOfChar
operator-( CRexSetOfChar const& op1 , unsigned char op2 )
{
    CRexSetOfChar        result( op1 ) ;
    result -= op2 ;
    return result ;
}

CRexSetOfChar
operator*( CRexSetOfChar const& op1 , CRexSetOfChar const& op2 )
{
    CRexSetOfChar        result( op1 ) ;
    result *= op2 ;
    return result ;
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\regxtree.inl ===
/****************************************************************************/
/*  File:       regxtree.ihh                                                */
/*  Author:     J. Kanze                                                    */
/*  Date:       24/01/1994                                                  */
/*      Copyright (c) 1994 James Kanze                                      */
/* ------------------------------------------------------------------------ */
//      Inline functions for CRexRegExpr_Impl::ParseTree.
//
//      This file is designed to be included from RegExpr.lhh, after
//      the full class definition.  No guarantee is given concerning
//      its use in any other context.
// --------------------------------------------------------------------------

inline
CRexRegExpr_Impl::ParseTree::FallibleNodePtr::FallibleNodePtr()
    :   myState( CRegExpr::emptyExpr ),
        myNode((ParseTreeNode*)0)
{
}

inline
CRexRegExpr_Impl::ParseTree::FallibleNodePtr::FallibleNodePtr(
    CRegExpr::Status state )
    :   myState( state ), myNode((ParseTreeNode*)0)
{
    ASSERT( myState != CRegExpr::ok);
}

inline
CRexRegExpr_Impl::ParseTree::FallibleNodePtr::FallibleNodePtr(
    ParseTreeNode* node )
    :   myState( CRegExpr::ok )
    ,   myNode( node )
{
}

inline bool
CRexRegExpr_Impl::ParseTree::FallibleNodePtr::isValid() const
{
    return myState == CRegExpr::ok ;
}

inline CRegExpr::Status
CRexRegExpr_Impl::ParseTree::FallibleNodePtr::state() const
{
    return myState ;
}

inline CRexRefCntPtr< CRexRegExpr_Impl::ParseTree::ParseTreeNode >
CRexRegExpr_Impl::ParseTree::FallibleNodePtr::node() const
{
    ASSERT( myState == CRegExpr::ok); //No words
    return myNode ;
}

inline CRexRegExpr_Impl::ParseTree::ParseTreeNode*
CRexRegExpr_Impl::ParseTree::FallibleNodePtr::operator->() const
{
    return myNode.operator->() ;
}

inline
CRexRegExpr_Impl::ParseTree::ParseTreeNode::ParseTreeNode()
    :   myMayBeEmpty( true )
{
}

inline bool
CRexRegExpr_Impl::ParseTree::ParseTreeNode::mayBeEmpty() const
{
    return myMayBeEmpty ;
}

inline CRexRegExpr_Impl::SetOfNFAStates const&
CRexRegExpr_Impl::ParseTree::ParseTreeNode::leftLeaves() const
{
    return myLeftLeaves ;
}

inline CRexRegExpr_Impl::SetOfNFAStates const&
CRexRegExpr_Impl::ParseTree::ParseTreeNode::rightLeaves() const
{
    return myRightLeaves ;
}

inline
CRexRegExpr_Impl::ParseTree::ParseTree()
{
}

inline CRegExpr::Status
CRexRegExpr_Impl::ParseTree::errorCode() const
{
    return myRoot.state() ;
}

inline CRexRegExpr_Impl::SetOfNFAStates const&
CRexRegExpr_Impl::ParseTree::leftMost() const
{
    return myRoot->leftLeaves() ;
}

inline void
CRexRegExpr_Impl::ParseTree::merge( ParseTree const& other )
{
    myRoot = constructChoiceNode( myRoot , other.myRoot ) ;
}

inline void
CRexRegExpr_Impl::ParseTree::visit( Visitor const& fnc )
{
    myRoot->visit( fnc );
}

inline void
CRexRegExpr_Impl::ParseTree::dump( std::ostream& output ) const
{
    if ( myRoot.isValid() ) {
        myRoot->dump( output ) ;
    }
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\bitvimpl.h ===
/****************************************************************************/
/*  File:       bitvimpl.h                                                 */
/*  Author:     J. Kanze                                                    */
/*  Date:       06/01/1994                                                  */
/*      Copyright (c) 1994 James Kanze                                      */
/* ------------------------------------------------------------------------ */
/*  Modified:   04/08/2000  J. Kanze                                        */
/*      Ported to current library conventions and the standard library.     */
/* ------------------------------------------------------------------------ */
//      The implementation class for bit vectors.
//
//      This class has been separated out of bitvect.h, since it will
//      also be used for bit strings (at least in part).
//
//      Note that the client class supplies the actual buffer; this
//      class consists entirely of static functions.
// --------------------------------------------------------------------------

#ifndef REX_BITVIMPL_HH
#define REX_BITVIMPL_HH

#include <inc/global.h>
#include <limits.h>

class CBitVectorImpl
{
protected :
    typedef unsigned    Byte ;
    enum { bitsPerByte = CHAR_BIT * sizeof( Byte ) } ;

public:
    typedef unsigned    BitIndex ;          //  Should be size_t, but...
    static BitIndex const
                        infinity ;

protected:
    static void         clear( Byte* buffer , BitIndex bitCount ) ;
    static void         init( Byte* buffer ,
                              BitIndex bitCount ,
                              unsigned long initValue ) ;
    static void         init( Byte* buffer ,
                              BitIndex bitCount ,
                              std::string const& initValue ) ;
    static unsigned long
                        asLong( Byte const* buffer , BitIndex bitCount ) ;
    static std::string
                        asString( Byte const* buffer , BitIndex bitCount ) ;

    static bool         isSet( Byte const* buffer , BitIndex bitNo ) ;
    static bool         isEmpty( Byte const* buffer , BitIndex bitCount ) ;
    static BitIndex     count( Byte const* buffer , BitIndex bitCount ) ;

    static BitIndex     find( Byte const* buffer ,
                              BitIndex bitCount ,
                              BitIndex from ,
                              bool value ) ;

    static void         set( Byte* buffer , BitIndex bitNo ) ;
    static void         set( Byte* buffer ,
                             Byte const* other ,
                             BitIndex bitCount ) ;
    static void         setAll( Byte* buffer , BitIndex bitCount ) ;
    static void         reset( Byte* buffer , BitIndex bitNo ) ;
    static void         reset( Byte* buffer ,
                               Byte const* other ,
                               BitIndex bitCount ) ;
    static void         resetAll( Byte* buffer , BitIndex bitCount ) ;
    static void         complement( Byte* buffer , BitIndex bitNo ) ;
    static void         complement( Byte* buffer ,
                                Byte const* other ,
                                BitIndex bitCount ) ;
    static void         complementAll( Byte* buffer , BitIndex bitCount ) ;
    static void         intersect( Byte* buffer ,
                                   Byte const* other ,
                                   BitIndex bitCount ) ;

    static bool         isSubsetOf( Byte const* lhs ,
                                    Byte const* rhs ,
                                    BitIndex bitCount ) ;

    static unsigned     hash( Byte const* buffer , BitIndex bitCount ) ;
    static int          compare( Byte const* buffer ,
                                 Byte const* other ,
                                 BitIndex bitCount ) ;

    static BitIndex     getByteCount( BitIndex bitCount ) ;

private:
    static BitIndex     byteCount( BitIndex bitCount ) ;
    static BitIndex     byteIndex( BitIndex bitNo ) ;
    static BitIndex     bitInByte( BitIndex bitNo ) ;

    struct Set
    {
        Byte                operator()( Byte x , Byte y )
        {
            return x | y ;
        }
    } ;

    struct Reset
    {
        Byte                operator()( Byte x , Byte y )
        {
            return x & ~ y ;
        }
    } ;

    struct Intersect
    {
        Byte                operator()( Byte x , Byte y )
        {
            return x & y ;
        }
    } ;

    struct Toggle
    {
        Byte                operator()( Byte x , Byte y )
        {
            return x ^ y ;
        }
    } ;
} ;

template< class BitVect >
class CBitVAccessProxy
{
public:
    typedef CBitVectorImpl::BitIndex
                        BitIndex ;

                        CBitVAccessProxy(
                            BitVect& owner ,
                            BitIndex bitNo ) ;
                        operator bool() const ;
    CBitVAccessProxy< BitVect >&
                        operator=( bool other ) ;

private:
    BitVect*            myOwner ;       // pointer so that = works.
    BitIndex            myBitNo ;
} ;

// ==========================================================================
//      CBitVIterator:
//      ================
//
//      An iterator class for vector classes using CBitVectImpl.
//
//      This iterator is a bit unusual, in that it doesn't iterator
//      over the vector as a vector, but as a set of int which
//      contains all of the elements which are equal to the
//      constructor parameter (true by default), and only returns
//      these elements.  This corresponds to the most typical use of
//      the class: a set of (small) positive integers.
//
//      For a more classical iterator, just use int.
//
//      This is not an iterator class in the sense of the STL.  In
//      fact, it is impossible to write an STL iterator for this
//      class, since an STL iterator requires that operator* return a
//      reference, and it is impossible to create a reference to a
//      single bit.
// --------------------------------------------------------------------------

template< class BitVect >
class CBitVIterator
{
public :
    typedef CBitVectorImpl::BitIndex
                        BitIndex ;

    //      Constructors, destructors and assignment:
    //      =========================================
    //
    //      In addition to the copy constructor, the following
    //      constructor are supported:
    //
    //      Byte, BitIndex, bool:   Constructs an iterator for the
    //                              given vector, defined by its
    //                              underlying array and its length.
    //                              The iterator iterates over all
    //                              bits with the state of the second
    //                              variable, and is initialize to
    //                              select the first bit with the
    //                              correct state.
    //
    //      There is no default constructor.  All iterators must be
    //      associated with a specific CBitVector.
    //
    //      For the moment, the default copy constructor, assignment
    //      operator and destructor are adequate, and no explicit
    //      versions are provided.
    //
    //      A special default constructor is provided in order to
    //      furnish a singular value -- an instance created with the
    //      default constructor compares equal to all instances for
    //      which isDone() returns true.  This is used to facilitate
    //      support of STL-like iterator usage: the begin iterator
    //      will initialize using the bit vector, and the end iterator
    //      with the default constructor.
    // ----------------------------------------------------------------------
    explicit            CBitVIterator( BitVect const& owner ,
                                         bool targetStatus = true  ) ;
                        CBitVIterator() ;

    //      current:
    //      --------
    //
    //      This function returns the bit index (an unsigned) of the
    //      current setting.  For convenience, it is also available as
    //      an overloaded conversion operator.
    // ----------------------------------------------------------------------
    BitIndex            current() const ;
    BitIndex            operator*() const ;

    //      isDone:
    //      -------
    //
    //      Returns true if and only if all of the bits of the desired
    //      status have been iterated over.
    // ----------------------------------------------------------------------
    bool                isDone() const ;

    //      next:
    //      -----
    //
    //      Go to the next bit with the desired status.
    //
    //      For notational convenience, this function is also
    //      available as the ++ operator.  Both prefix and postfix
    //      forms are supported.
    // ----------------------------------------------------------------------
    void                next() ;
    CBitVIterator< BitVect>&
                        operator++() ;
    CBitVIterator< BitVect >
                        operator++( int ) ;

    //      operator==, !=:
    //      ---------------
    //
    //      Provided for STL support.  Two iterators can be compared
    //      if and only if they both have the same owner, or one or
    //      both of them have been created with the default
    //      constructor.  They compare equal if the current position
    //      is equal, or isDone() returns true for both of them.
    // ----------------------------------------------------------------------
    bool                operator==(
                            CBitVIterator< BitVect > const& other ) const ;
    bool                operator!=(
                            CBitVIterator< BitVect > const& other ) const ;

private :
    BitVect const*      myOwner ;       // pointer so that = works.
    BitIndex            myCurrentIndex ;
    bool                myTarget ;
} ;

#include <inc/bitvimpl.inl>
#endif
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\bitvect.inl ===
/****************************************************************************/
/*  File:       bitvect.ihh                                                 */
/*  Author:     J. Kanze                                                    */
/*  Date:       06/01/1994                                                  */
/*      Copyright (c) 1994 James Kanze                                      */
/* ------------------------------------------------------------------------ */
/*  Modified:   11/11/1994  J. Kanze                                        */
/*      Merged in DynBitVect.  Adapted to new coding standards.          */
/*  Modified:   21/11/1994  J. Kanze                                        */
/*      Made interface conform to ArrayOf.                               */
/*  Modified:   07/08/2000  J. Kanze                                        */
/*      Ported to current library conventions and the standard library.     */
/* ------------------------------------------------------------------------ */


template< int bitCount >
inline
CBitVector< bitCount >::CBitVector()
{
    Impl::clear( myBuffer , bitCount ) ;
}

template< int bitCount >
inline
CBitVector< bitCount >::CBitVector( unsigned long initValue )
{
    Impl::init( myBuffer , bitCount , initValue ) ;
}

template< int bitCount >
inline
CBitVector< bitCount >::CBitVector( std::string const& initValue )
{
    Impl::init( myBuffer , bitCount , initValue ) ;
}

template< int bitCount >
inline
CBitVector< bitCount >::CBitVector( char const* initValue )
{
    Impl::init( myBuffer , bitCount , initValue ) ;
}

template< int bitCount >
inline unsigned short
CBitVector< bitCount >::asShort() const
{
    ASSERT( bitCount <= CHAR_BIT * sizeof( short ) ) ;
    return Impl::asLong( myBuffer , bitCount ) ;
}

template< int bitCount >
inline unsigned long
CBitVector< bitCount >::asLong() const
{
    ASSERT( bitCount <= CHAR_BIT * sizeof( long ) ) ;
    return Impl::asLong( myBuffer , bitCount ) ;
}

template< int bitCount >
inline std::string
CBitVector< bitCount >::asString() const
{
    return Impl::asString( myBuffer , bitCount ) ;
}

template< int bitCount >
inline bool
CBitVector< bitCount >::isSet( BitIndex bitNo ) const
{
    ASSERT( bitNo < bitCount ); // Illegal index for CBitVector
    return Impl::isSet( myBuffer , bitNo ) ;
}

template< int bitCount >
inline bool
CBitVector< bitCount >::contains( BitIndex index ) const
{
    return isSet( index ) ;
}

template< int bitCount >
inline bool
CBitVector< bitCount >::isEmpty() const
{
    return Impl::isEmpty( myBuffer , bitCount ) ;
}

template< int bitCount >
inline CBitVectorImpl::BitIndex
CBitVector< bitCount >::find( bool targetValue , BitIndex from ) const
{
    return Impl::find( myBuffer , bitCount , from , targetValue ) ;
}

template< int bitCount >
inline CBitVectorImpl::BitIndex
CBitVector< bitCount >::count() const
{
    return Impl::count( myBuffer , bitCount ) ;
}

template< int bitCount >
inline typename CBitVector< bitCount >::Iterator
CBitVector< bitCount >::iterator() const
{
    return Iterator( *this , true ) ;
}

template< int bitCount >
inline typename CBitVector< bitCount >::Iterator
CBitVector< bitCount >::begin() const
{
    return Iterator( *this , true ) ;
}

template< int bitCount >
inline typename CBitVector< bitCount >::Iterator
CBitVector< bitCount >::end() const
{
    return Iterator() ;
}

template< int bitCount >
inline bool
CBitVector< bitCount >::isEqual(
    CBitVector< bitCount > const& other ) const
{
    return Impl::compare( myBuffer , other.myBuffer , bitCount ) == 0 ;
}

template< int bitCount >
inline bool
CBitVector< bitCount >::isNotEqual(
    CBitVector< bitCount > const& other ) const
{
    return Impl::compare( myBuffer , other.myBuffer , bitCount ) != 0 ;
}

template< int bitCount >
inline bool
CBitVector< bitCount >::isSubsetOf(
    CBitVector< bitCount > const& other ) const
{
    return Impl::isSubsetOf( myBuffer , other.myBuffer , bitCount ) ;
}

template< int bitCount >
inline bool
CBitVector< bitCount >::isStrictSubsetOf(
    CBitVector< bitCount > const& other ) const
{
    return Impl::isSubsetOf( myBuffer , other.myBuffer , bitCount )
        && ! Impl::isSubsetOf( other.myBuffer , myBuffer , bitCount ) ;
}

template< int bitCount >
inline bool
CBitVector< bitCount >::isSupersetOf(
    CBitVector< bitCount > const& other ) const
{
    return other.isSubsetOf( *this ) ;
}

template< int bitCount >
inline bool
CBitVector< bitCount >::isStrictSupersetOf(
    CBitVector< bitCount > const& other ) const
{
    return other.isStrictSubsetOf( *this ) ;
}

template< int bitCount >
inline void
CBitVector< bitCount >::set( BitIndex bitNo )
{
    ASSERT( bitNo < bitCount ); // Illegal index for CBitVector
    Impl::set( myBuffer , bitNo ) ;
}

template< int bitCount >
inline void
CBitVector< bitCount >::set( CBitVector< bitCount > const& other )
{
    Impl::set( myBuffer , other.myBuffer , bitCount ) ;
}

template< int bitCount >
inline void
CBitVector< bitCount >::set()
{
    Impl::setAll( myBuffer , bitCount ) ;
}

template< int bitCount >
inline void
CBitVector< bitCount >::reset( BitIndex bitNo )
{
    ASSERT( bitNo < bitCount ); //Illegal index for CBitVector
    Impl::reset( myBuffer , bitNo ) ;
}

template< int bitCount >
inline void
CBitVector< bitCount >::reset( CBitVector< bitCount > const& other )
{
    Impl::reset( myBuffer , other.myBuffer , bitCount ) ;
}

template< int bitCount >
inline void
CBitVector< bitCount >::reset()
{
    Impl::resetAll( myBuffer , bitCount ) ;
}

template< int bitCount >
inline void
CBitVector< bitCount >::complement( BitIndex bitNo )
{
    ASSERT( bitNo < bitCount ); // Illegal index for CBitVector
    Impl::complement( myBuffer , bitNo ) ;
}

template< int bitCount >
inline void
CBitVector< bitCount >::complement( CBitVector< bitCount > const& other )
{
    Impl::complement( myBuffer , other.myBuffer , bitCount ) ;
}

template< int bitCount >
inline void
CBitVector< bitCount >::complement()
{
    Impl::complementAll( myBuffer , bitCount ) ;
}

template< int bitCount >
inline void
CBitVector< bitCount >::intersect( CBitVector< bitCount > const& other )
{
    Impl::intersect( myBuffer , other.myBuffer , bitCount ) ;
}

template< int bitCount >
inline CBitVector< bitCount >&
CBitVector< bitCount >::operator&=( CBitVector< bitCount > const& other )
{
    intersect( other ) ;
    return *this ;
}

template< int bitCount >
inline CBitVector< bitCount >&
CBitVector< bitCount >::operator|=( CBitVector< bitCount > const& other )
{
    set( other ) ;
    return *this ;
}

template< int bitCount >
inline CBitVector< bitCount >&
CBitVector< bitCount >::operator^=( CBitVector< bitCount > const& other )
{
    complement( other ) ;
    return *this ;
}

template< int bitCount >
inline CBitVector< bitCount >&
CBitVector< bitCount >::operator+=( CBitVector< bitCount > const& other )
{
    set( other ) ;
    return *this ;
}

template< int bitCount >
inline CBitVector< bitCount >&
CBitVector< bitCount >::operator+=( BitIndex bitNo )
{
    set( bitNo ) ;
    return *this ;
}

template< int bitCount >
inline CBitVector< bitCount >&
CBitVector< bitCount >::operator-=( CBitVector< bitCount > const& other )
{
    reset( other ) ;
    return *this ;
}

template< int bitCount >
inline CBitVector< bitCount >&
CBitVector< bitCount >::operator-=( BitIndex bitNo )
{
    reset( bitNo ) ;
    return *this ;
}

template< int bitCount >
inline CBitVector< bitCount >&
CBitVector< bitCount >::operator*=( CBitVector< bitCount > const& other )
{
    intersect( other ) ;
    return *this ;
}

template< int bitCount >
inline bool
CBitVector< bitCount >::operator[]( BitIndex index ) const
{
    return isSet( index ) ;
}

template< int bitCount >
inline CBitVAccessProxy< CBitVector< bitCount > >
CBitVector< bitCount >::operator[]( BitIndex index )
{
    ASSERT( index < bitCount ); // Illegal index for CBitVector
    return CBitVAccessProxy< CBitVector< bitCount > >( *this , index ) ;
}

template< int bitCount >
inline unsigned
CBitVector< bitCount >::hash() const
{
    return Impl::hash( myBuffer , bitCount ) ;
}

template< int bitCount >
inline int
CBitVector< bitCount >::compare( CBitVector< bitCount > const& other ) const
{
    return Impl::compare( myBuffer , other.myBuffer , bitCount ) ;
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\dataptr.h ===
/****************************************************************************/
/*  File:       dataptr.h                                                  */
/*  Author:     J. Kanze                                                    */
/*  Date:       28/05/1996                                                  */
/*      Copyright (c) 1996 James Kanze                                      */
/* ------------------------------------------------------------------------ */
/*  Modified:   14/02/2000  J. Kanze                                        */
/*      Ajout operator() pour compatibilit avec STL. (En fait, selon      */
/*      la norme, std::less doit faire l'affaire. Mais jusqu' ce que       */
/*      tous les compilateurs soient  jour...)                             */
/* ------------------------------------------------------------------------ */
//      dataptr :
//      =========
//
//      <lang=french>
//      Un ensemble de fonctions pour faire des choses autrement
//      non-portables avec des pointeurs. (Une partie des ces
//      fonctions ont t perimes par des evolutions dans la norme,
//      mais d'ici  ce que les compilateurs sont tous  jour...)
//
//      Ici, il y a les fonctions pour les pointeurs  des donnes.
//
//      compare :       dfinit une fonction (relationship) d'ordre
//                      sur les pointeurs, ou qu'ils pointent. (On se
//                      souviendrait que les oprateurs de comparison
//                      d'inegalit ne sont dfinis que si les deux
//                      pointeurs point  l'intrieur d'un mme
//                      objet.) La fonction d'ordre ainsi dfinie est
//                      completement arbitraire.
//
//                      La fonction retourne une valeur ngative,
//                      zro, ou positive, selon que le premier
//                      pointeur se trouve avant, est le mme que, ou
//                      se trouve aprs le second.
//
//      isLessThan :    Une forme simplifie du prcedant, implmente
//                      p1 < p2, en se servant de la fonction d'ordre
//                      dfinie par compare.
//
//                      Correspond  less<T*> dans la norme.
//
//                      L'oprateur() est un alias pour cette
//                      fonction, afin que la classe puisse servir
//                      directement comme objet de comparison d'une
//                      collection associative.
//
//      hash :          gnre un code de hachage sur le pointeur. Si
//                      deux pointeurs pointent au mme endroit, il
//                      est garanti qu'ils se hacheraient  la mme
//                      valeur (mme s'ils ont de rprsentations
//                      diffrentes). S'ils pointent aux endroits
//                      diffrents, il y a de fortes chances (mais
//                      pas de garantie) qu'ils auront de valeurs de
//                      hachage diffrentes.
//
//      asString :      convertit un pointeur dans une chane de
//                      caractres alphanumrique. Cette fonction
//                      retourne un pointeur  la chane gnre.
//
//                      ATTENTION : la chane gnre peut se trouver
//                       une adresse fixe, et pourrait tre crasse
//                      par un appel nouveau de la fonction.
// ---------------------------------------------------------------------------
//      <lang=english>
//      A set of functions for things that are otherwise not portable
//      with pointers.  (Most of these functions are actually no
//      longer needed with the new standard, but until all compilers
//      and libraries are up to date...)
//
//      In this file, we define the operations on pointers to data.
//
//      compare:        Defines an ordering relationship over the
//                      pointers, including between pointers which do
//                      not point into the same object.  The ordering
//                      relationship is totally arbitrary, however.
//
//                      This function returns a negative, zero or
//                      positive value, according to whether the first
//                      pointer is before, equal to, or after the
//                      second.
//
//      isLessThan:     A simplified form of the preceding,
//                      implementing p1 < p2, by means of the compare
//                      function.
//
//                      Corresponds to less< T* > in the standard.
//
//                      The operator< is an alias for this function,
//                      so that this class can be used directly as a
//                      comparison object for an associative
//                      container.
//
//      hash:           Generates a hash code for the pointer. If two
//                      pointers designate the same object, this
//                      function is guaranteed to return the same
//                      value for them, even if they have different
//                      representations.  If they designate different
//                      objects, it is highly likely (but not
//                      guaranteed) that the return values will be
//                      different.
//
//      asString:       Converts a pointer to a string of
//                      alphanumerical characters.  This function
//                      returns a pointer to the generated string.
//
//                      ATTENTION: the generated string is in static
//                      memory, and will be overwritten on each
//                      invocation of the function.
// ---------------------------------------------------------------------------

#ifndef REX_DATAPTR_HH
#define REX_DATAPTR_HH

#include <inc/global.h>

struct CRexDataPointers
{
    static int          compare( void const* p1 , void const* p2 ) ;
    static bool         isLessThan( void const* p1 , void const* p2 ) ;
    static unsigned int hashCode( void const* p ) ;
    static char const*  asString( void const* p ) ;

    bool                operator()( void const* p1 , void const* p2 ) ;
} ;

inline bool
CRexDataPointers::operator()( void const* p1 , void const* p2 )
{
    return isLessThan( p1 , p2 ) ;
}
#endif
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\dynbitv.inl ===
/****************************************************************************/
/*  File:       dynbitv.ihh                                                 */
/*  Author:     J. Kanze                                                    */
/*  Date:       06/01/1994                                                  */
/*      Copyright (c) 1994 James Kanze                                      */
/* ------------------------------------------------------------------------ */
/*  Modified:   11/11/1994  J. Kanze                                        */
/*      Merged in DynBitVect.  Adapted to new coding standards.          */
/*  Modified:   21/11/1994  J. Kanze                                        */
/*      Made interface conform to ArrayOf.                               */
/*  Modified:   07/08/2000  J. Kanze                                        */
/*      Ported to current library conventions and the standard library.     */
/* ------------------------------------------------------------------------ */

#include <limits.h>

inline unsigned short
CRexDynBitVector::asShort() const
{
    unsigned long       result = asLong() ;
    ASSERT( result <= USHRT_MAX ); //Bounds check error converting CRexDynBitVector
    return static_cast< unsigned short >( result ) ;
}

inline bool
CRexDynBitVector::contains( BitIndex index ) const
{
    return isSet( index ) ;
}

inline bool
CRexDynBitVector::trailingValue() const
{
    return myTrailingPart ;
}

inline CRexDynBitVector::Iterator
CRexDynBitVector::iterator() const
{
    return Iterator( *this , true ) ;
}

inline CRexDynBitVector::Iterator
CRexDynBitVector::begin() const
{
    return Iterator( *this , true ) ;
}

inline CRexDynBitVector::Iterator
CRexDynBitVector::end() const
{
    return Iterator() ;
}

inline bool
CRexDynBitVector::isEqual( CRexDynBitVector const& other ) const
{
    return compare( other ) == 0 ;
}

inline bool
CRexDynBitVector::isNotEqual(
    CRexDynBitVector const& other ) const
{
    return compare( other ) != 0 ;
}

inline bool
CRexDynBitVector::isStrictSubsetOf(
    CRexDynBitVector const& other ) const
{
    return isSubsetOf( other ) && ! other.isSubsetOf( *this ) ;
}

inline bool
CRexDynBitVector::isSupersetOf(
    CRexDynBitVector const& other ) const
{
    return other.isSubsetOf( *this ) ;
}

inline bool
CRexDynBitVector::isStrictSupersetOf(
    CRexDynBitVector const& other ) const
{
    return other.isStrictSubsetOf( *this ) ;
}

inline CRexDynBitVector&
CRexDynBitVector::operator&=( CRexDynBitVector const& other )
{
    intersect( other ) ;
    return *this ;
}

inline CRexDynBitVector&
CRexDynBitVector::operator|=( CRexDynBitVector const& other )
{
    set( other ) ;
    return *this ;
}

inline CRexDynBitVector&
CRexDynBitVector::operator^=( CRexDynBitVector const& other )
{
    complement( other ) ;
    return *this ;
}

inline CRexDynBitVector&
CRexDynBitVector::operator+=( CRexDynBitVector const& other )
{
    set( other ) ;
    return *this ;
}

inline CRexDynBitVector&
CRexDynBitVector::operator+=( BitIndex bitNo )
{
    set( bitNo ) ;
    return *this ;
}

inline CRexDynBitVector&
CRexDynBitVector::operator-=( CRexDynBitVector const& other )
{
    reset( other ) ;
    return *this ;
}

inline CRexDynBitVector&
CRexDynBitVector::operator-=( BitIndex bitNo )
{
    reset( bitNo ) ;
    return *this ;
}

inline CRexDynBitVector&
CRexDynBitVector::operator*=( CRexDynBitVector const& other )
{
    intersect( other ) ;
    return *this ;
}

inline bool
CRexDynBitVector::operator[]( BitIndex index ) const
{
    return isSet( index ) ;
}

inline CBitVAccessProxy< CRexDynBitVector >
CRexDynBitVector::operator[]( BitIndex index )
{
    return CBitVAccessProxy< CRexDynBitVector >( *this , index ) ;
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\global.h ===
/****************************************************************************/
/*  File:       global.h                                                   */
/*  Author:     J. Kanze                                                    */
/*  Date:       29/06/1993                                                  */
/*      Copyright (c) 1993,1996,1998 James Kanze                            */
/* ------------------------------------------------------------------------ */
/*  Modified:   16/09/1998  J. Kanze                                        */
/*      Port to standard C++.                                               */
/*  Modified:   28/03/1996  J. Kanze                                        */
/*      Ajouter les dfinitions par dfaut pour _MaxAlign, ptrLT       */
/*      et _ptrHash.                                                      */
/*  Modified:   28/06/1996  J. Kanze                                        */
/*      Transfr ptr...   une module  part.                           */
/*  Modified:   18/11/1996  J. Kanze                                        */
/*      Normalis l'orthographe des mots-cl qui manque.                    */
/* ------------------------------------------------------------------------ */
//      <lang=french>
//      Les dfinitions globales. Ce fichier doit toujours tre le
//      premier inclus.
// --------------------------------------------------------------------------
//      <lang=english>
//      Global definitions. This file should always be the first
//      included.
// --------------------------------------------------------------------------

#ifndef REX_GLOBAL_HH
#define REX_GLOBAL_HH

#include <inc/system.h>
#include <stddef.h>                     // To always have NULL

#endif
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\ios.h ===
/****************************************************************************/
/*  File:       ios.h                                                      */
/*  Author:     J. Kanze                                                    */
/*  Date:       27/09/2000                                                  */
/* ------------------------------------------------------------------------ */
//      ios:
//      ====
//
//      Also typedef's FmtFlags (std::ios::fmtflags, or long for
//      the classical iostream) and defines REX_eof (from character
//      traits, or the macro EOF).  Portable code should use these,
//      instead of the standard values.
// ===========================================================================

#ifndef REX_IOS_HH
#define REX_IOS_HH
typedef std::ios::fmtflags  REX_FmtFlags ;
static int const REX_eof = std::ios::traits_type::eof() ;
#endif
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\dynbitv.h ===
/****************************************************************************/
/*  File:       dynbitv.h                                                  */
/*  Author:     J. Kanze                                                    */
/*  Date:       06/01/1994                                                  */
/*      Copyright (c) 1994 James Kanze                                      */
/* ------------------------------------------------------------------------ */
/*  Modified:   11/11/1994  J. Kanze                                        */
/*      Merged in DynBitVect.  Adapted to new coding standards.          */
/*  Modified:   21/11/1994  J. Kanze                                        */
/*      Made interface conform to ArrayOf.                               */
/*  Modified:   07/08/2000  J. Kanze                                        */
/*      Ported to current library conventions and the standard library.     */
/* ------------------------------------------------------------------------ */
//      CRexDynBitVector:
//      ================
//
//      A dynamic bit vector is conceptually an infinitly long bit
//      vector, with indexes starting at 0.  In fact, even
//      conceptually, the length is limited by the range of the index
//      type, a CBitVectorImpl::BitIndex.
//
//      The bit vector can in fact be viewed as consisting of two
//      parts, an active part and a trailing part.  All of the bits in
//      the trailing part have the same value, and in fact are
//      represented by a single flag, which the user can read.  The
//      size of the active part increases dynamically; in the current
//      implementation, it will only decrease on assignment.  There
//      are special functions for the client to read the size of the
//      active part and the value of the trailing part.
//
//      isSet:              returns true if (any of) the specified
//                          bits are set.  Possible specifiers are:
//                          index (an int, selecting a specific bit),
//                          any, none, or all.
//
//      find:               find the first matching bit starting at a
//                          given point in the vector.
//
//      operator[]:         indexing.  An out of bounds index causes
//                          an assertion failure.
//
//      set:                set one or more bits, as selected by the
//                          argument.  The following argument types
//                          are allowed: index (an int, selecting a
//                          single bit), all, or another CBitVector
//                          (selecting all of the bits set in this
//                          set).  When another CBitVector is used,
//                          it must either be dynamic, or have exactly
//                          the same size as this bit vector.
//
//      reset:              as above, but resets the specified bit(s).
//
//      toggle:             as set, but toggles the specified bit(s).
//
//      intersect:          logical and, only supported with another
//                          CRexDynBitVector.
//
//      complement:         complement.  The equivalent of `toggle(
//                          all )'.
//
//      The functions and, or, xor and not have been removed from this
//      version, as their names conflicted with new keywords:-).
//
//      isEqual,
//      isNotEqual,
//      isSubsetOf,
//      isStrictSubsetOf,
//      isSupersetOf,
//      isStrictSupersetOf: returns true if the specified relation
//                          is true, false otherwise.  In all
//                          cases, the bit vectors are processed
//                          semantically as a `set of cardinal'.
//
//      operators:          in addition to [] and =, the following
//                          operators are defined: &, |, ^, ~, &=, |=,
//                          ^=, +, +=, *, *=, -, -=, ==, !=, <, <=, >,
//                          >=.  Operators + and += have the same
//                          semantics as | and |=, operators * and *=
//                          the same as & and &=.  The comparison
//                          operators are defined by processing the
//                          bit vectors semantically as `set of
//                          cardinal', with < as isStrictSubsetOf, <=
//                          isSubsetOf, > isStrictSupersetOf and >=
//                          isSupersetOf.
// --------------------------------------------------------------------------

#ifndef REX_DYNBITV_HH
#define REX_DYNBITV_HH

#include <inc/global.h>
#include <inc/bitvimpl.h>

// ==========================================================================
//      CRexDynBitVector:
//      ================
//
//      This is a (non-template) class for a conceptually infinite
//      length bit vector.
// --------------------------------------------------------------------------

class CRexDynBitVector : public CBitVectorImpl
{
    typedef CBitVectorImpl
                        Impl ;
    enum { granularity = sizeof( long ) * CHAR_BIT } ;
                                        // must be power of 2, >= number of
                                        // bits in Byte.
public :
    typedef CBitVIterator< CRexDynBitVector >
                        Iterator ;

    //      Constructors, Destructors and Assignment:
    //      =========================================
    //
    //      The following constructors (in addition to the copy
    //      constructor) are provided:
    //
    //      default:            Initializes all of the bits to 0.
    //
    //      unsigned long:      Uses the unsigned long to initialize
    //                          the bits in the vector; the low order
    //                          bit of the unsigned long goes into bit
    //                          0, and so on.  If the bit vector
    //                          contains more bits than an unsigned
    //                          long, the additional bits are
    //                          initialized to 0.  If the bit vector
    //                          contains less bits, the extra bits are
    //                          simply ignored.
    //
    //      std::string:        The string is used to initialize the
    //                          bits in the vector.  '0', 'F' or 'f'
    //                          initialize a bit to 0, '1', 'T' or 't'
    //                          to 1.  White space is ignored.  Any
    //                          other characters will result in an
    //                          assertion failure (to be replaced by
    //                          an exception ulteriorly).
    //
    //                          The first significant character in the
    //                          string initializes bit 0, the next bit
    //                          1, and so on.  WARNING: this is the
    //                          opposite of the proposed ISO 'bits'
    //                          class!
    //
    //                          If the number of significant
    //                          characters in the string is less than
    //                          the number of bits in the vector, the
    //                          additional bits will be initialized to
    //                          0.  It is an error (assertion failure
    //                          for now) for the string to contain
    //                          more significant characters than there
    //                          are bits.
    //
    //      const char*:        Exactly as std::string.
    // ----------------------------------------------------------------------
                        CRexDynBitVector() ;
    explicit            CRexDynBitVector( unsigned long initValue ) ;
    explicit            CRexDynBitVector( std::string const& initValue ) ;
    explicit            CRexDynBitVector( char const* initValue ) ;

    //      Access functions:
    //      =================
    //
    //      These functions are used to read the bit vector as a unit.
    //
    //      asShort or asLong will cause an assertion failure if any
    //      bit after the first 16 or 32 respectively is set.  (It was
    //      deemed preferable to use the fixed values of 16 and 32,
    //      rather than the actual number of bits in a short or a
    //      long, for portability reasons.)  The value returned is
    //      suitable for use as a parameter to the constructor.
    //
    //      'asString' returns a string consisting of uniquely 0's and
    //      1's, suitable for use in the constructor.  (Ie: bit 0 is
    //      the first character in the string, bit 1 the next, and so
    //      on.)  The length of the string is such that the last
    //      character will always be a '1'; trailing unset bits are
    //      not output.
    // ----------------------------------------------------------------------
    unsigned short      asShort() const ;
    unsigned long       asLong() const ;
    std::string      asString() const ;

    //      Predicates:
    //      ===========
    //
    //      These const Functions return true or false.
    //
    //      isSet:      Returns true if the given bit is set.
    //
    //      contains:   An alias for isSet.  Semantically, it refers to
    //                  the set nature of the bit vector,
    //
    //      isEmpty:    Returns true if no bits are set.  (Set is empty.)
    // ----------------------------------------------------------------------
    bool                isSet( BitIndex bitNo ) const ;
    bool                contains( BitIndex bitNo ) const ;
    bool                isEmpty() const ;

    //      Attributes:
    //      ===========
    //
    //      find:       returns the index of the first bit matching
    //                  the targetValue, starting from the 'from'
    //                  parameter (inclusive).  If no bit matches,
    //                  returns CBitVectorImpl::infinity.
    //
    //      count:      returns the number of *set* bits in the
    //                  vector.
    //
    //      activeLength:   returns the number of bits in the active
    //                      part.  It is guarenteed that all bits
    //                      beyond this have the same value.
    //
    //      trailingValue:  returns the value of the bits in the
    //                      active part.
    //
    //      Note that with judicious use of activeLength and
    //      trailingValue, it is possible to "iterate" over the entire
    //      vector, despite its "infinite" length.
    // ----------------------------------------------------------------------
    BitIndex            find( bool targetValue , BitIndex from = 0 ) const ;
    BitIndex            count() const ;
    BitIndex            activeLength() const ;
    bool                trailingValue() const ;

    Iterator            iterator() const ;
    Iterator            begin() const ;
    Iterator            end() const ;

    //      Relationships:
    //      ==============
    //
    //      A partial ordering is defined by the subset relationship.
    // ----------------------------------------------------------------------
    bool                isEqual( CRexDynBitVector const& other ) const ;
    bool                isNotEqual( CRexDynBitVector const& other ) const ;
    bool                isSubsetOf( CRexDynBitVector const& other ) const ;
    bool                isStrictSubsetOf(
                            CRexDynBitVector const& other ) const ;
    bool                isSupersetOf( CRexDynBitVector const& other ) const ;
    bool                isStrictSupersetOf(
                            CRexDynBitVector const& other ) const ;

    //      Basic bit manipulations:
    //      ========================
    //
    //      Set sets the bit(s) to 1 (logical or).
    //
    //      Reset resets the bit(s) to 0.
    //
    //      Complement toggles (complements) the bit(s) (logical xor).
    //
    //      Intersect is a logical and.
    //
    //      With the exception of intersect, all of these functions
    //      have three variants: one for a single bit, one where a
    //      second array specifies the bits concerned, and one with
    //      the parameter "all", which acts on all of the bits.
    //
    //      These functions provide the basis for the logical
    //      operations defined later.
    // ----------------------------------------------------------------------
    void                set( BitIndex bitNo ) ;
    void                set( CRexDynBitVector const& other ) ;
    void                set() ;

    void                reset( BitIndex bitNo ) ;
    void                reset( CRexDynBitVector const& other ) ;
    void                reset() ;
    void                clear() ;       // synonyme for reset...

    void                complement( BitIndex bitNo ) ;
    void                complement( CRexDynBitVector const& other ) ;
    void                complement() ;

    void                intersect( CRexDynBitVector const& other ) ;

    //      Operator overloads:
    //      ===================
    //
    //      All reasonable operators are overloaded.
    //
    //      Note that even the classic binary operators are overloaded
    //      as member functions.  This is necessary, as most compilers
    //      will not allow a template function with a non-type
    //      argument (ie: bitCnt).
    //
    //      The operators for comparison of inequality (<, <=, >, >=)
    //      use the subset relationship, ie: < means is a strict
    //      subset of, etc.  Since this relation defines only a
    //      partial ordering, '!  (a < b)' does not necessarily imply
    //      'a >= b'.
    // ----------------------------------------------------------------------
    CRexDynBitVector&    operator&=( CRexDynBitVector const& other ) ;
    CRexDynBitVector&    operator|=( CRexDynBitVector const& other ) ;
    CRexDynBitVector&    operator^=( CRexDynBitVector const& other ) ;

    CRexDynBitVector&    operator+=( CRexDynBitVector const& other ) ;
    CRexDynBitVector&    operator+=( BitIndex bitNo ) ;
    CRexDynBitVector&    operator-=( CRexDynBitVector const& other ) ;
    CRexDynBitVector&    operator-=( BitIndex bitNo ) ;
    CRexDynBitVector&    operator*=( CRexDynBitVector const& other ) ;

    bool                operator[]( BitIndex index ) const ;
    CBitVAccessProxy< CRexDynBitVector >
                        operator[]( BitIndex index ) ;

    //      Support functions:
    //      ==================
    //
    //      The following two functions are for support for container
    //      classes.
    //
    //      The compare functions defines an *arbitrary* ordering
    //      relationship, in no way related to subsets, for example.
    //      (It is not even guaranteed that the ordering will remain
    //      the same between releases.)
    // ----------------------------------------------------------------------
    unsigned            hash() const ;
    int                 compare( CRexDynBitVector const& other ) const ;

private :
    std::vector< Byte > myBuffer ;
    bool                myTrailingPart ;

    static BitIndex     byteCount( BitIndex bitCount ) ;
    BitIndex            bitCount() const ;
    Byte*               buffer() ;
    Byte const*         buffer() const ;
    void                init( std::string const& initValue ) ;
    void                enlargeActivePart( BitIndex minBitCount ) ;
} ;

#include <inc/dynbitv.inl>

inline bool
operator==( CRexDynBitVector const& op1 , CRexDynBitVector const& op2 )
{
    return op1.isEqual( op2 ) ;
}

inline bool
operator!=( CRexDynBitVector const& op1 , CRexDynBitVector const& op2 )
{
    return op1.isNotEqual( op2 ) ;
}

inline bool
operator<( CRexDynBitVector const& op1 , CRexDynBitVector const& op2 )
{
    return op1.isStrictSubsetOf( op2 ) ;
}

inline bool
operator<=( CRexDynBitVector const& op1 , CRexDynBitVector const& op2 )
{
    return op1.isSubsetOf( op2 ) ;
}

inline bool
operator>( CRexDynBitVector const& op1 , CRexDynBitVector const& op2 )
{
    return op1.isStrictSupersetOf( op2 ) ;
}

inline bool
operator>=( CRexDynBitVector const& op1 , CRexDynBitVector const& op2 )
{
    return op1.isSupersetOf( op2 ) ;
}

inline CRexDynBitVector
operator+( CRexDynBitVector const& op1 , CRexDynBitVector const& op2 )
{
    CRexDynBitVector     result( op1 ) ;
    result += op2 ;
    return result ;
}

inline CRexDynBitVector
operator+( CRexDynBitVector const& op1 , CRexDynBitVector::BitIndex op2 )
{
    CRexDynBitVector     result( op1 ) ;
    result += op2 ;
    return result ;
}

inline CRexDynBitVector
operator-( CRexDynBitVector const& op1 , CRexDynBitVector const& op2 )
{
    CRexDynBitVector     result( op1 ) ;
    result -= op2 ;
    return result ;
}

inline CRexDynBitVector
operator-( CRexDynBitVector const& op1 , CRexDynBitVector::BitIndex op2 )
{
    CRexDynBitVector     result( op1 ) ;
    result -= op2 ;
    return result ;
}

inline CRexDynBitVector
operator*( CRexDynBitVector const& op1 , CRexDynBitVector const& op2 )
{
    CRexDynBitVector     result( op1 ) ;
    result *= op2 ;
    return result ;
}

inline CRexDynBitVector
operator|( CRexDynBitVector const& op1 , CRexDynBitVector const& op2 )
{
    CRexDynBitVector     result( op1 ) ;
    result |= op2 ;
    return result ;
}

inline CRexDynBitVector
operator&( CRexDynBitVector const& op1 , CRexDynBitVector const& op2 )
{
    CRexDynBitVector     result( op1 ) ;
    result &= op2 ;
    return result ;
}

inline CRexDynBitVector
operator^( CRexDynBitVector const& op1 , CRexDynBitVector const& op2 )
{
    CRexDynBitVector     result( op1 ) ;
    result ^= op2 ;
    return result ;
}

inline CRexDynBitVector
operator~( CRexDynBitVector const& op )
{
    CRexDynBitVector     result( op ) ;
    result.complement() ;
    return result ;
}
#endif
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\iteristr.h ===
/****************************************************************************/
/*  File:       iteristr.h                                                 */
/*  Author:     J. Kanze                                                    */
/*  Date:       16/06/2000                                                  */
/*      Copyright (c) 2000 James Kanze                                      */
/* ------------------------------------------------------------------------ */
//      iterator input stream:
//      ======================
//
//      This template streambuf uses a pair of iterators to define the
//      input stream.  Any type of STL conform forward iterators can
//      be used, as long as the expression "&*iter" results in a char
//      const*.
// ---------------------------------------------------------------------------

#ifndef REX_ITERISTR_HH
#define REX_ITERISTR_HH

#include <inc/global.h>

// ===========================================================================
//      CRexIteratorInputStreambuf:
//      ==========================
//
// ---------------------------------------------------------------------------

template< typename FwdIter >
class CRexIteratorInputStreambuf : public std::streambuf
{
public:
    // -----------------------------------------------------------------------
    //      Constructors, destructor and assignment:
    //      ----------------------------------------
    //
    // -----------------------------------------------------------------------
                        CRexIteratorInputStreambuf( FwdIter begin ,
                                                   FwdIter end ) ;

    // -----------------------------------------------------------------------
    //      Fonctions virtuelles rdfinies de streambuf :
    //      ----------------------------------------------
    //
    //      Je ne crois pas que  overflow  soit ncessaire ; selon
    //      la norme, le comportement de la classe de base convient.
    //      Seulement historiquement, dans l'implmentation CFront, le
    //      comportement de cette fonction dans streambuf n'tait pas
    //      dfini. Alors, en attendant pouvoir tre sr que tous les
    //      compilateurs sont  jour...
    //
    //      Pour les fonctions sync et setbuf, on ne fait que les
    //      renvoyer  la source.
    // -----------------------------------------------------------------------
    virtual int         overflow( int ch ) ;
    virtual int         underflow() ;
    virtual int         sync() ;
    virtual std::streambuf*
                        setbuf( char* p , int len ) ;

    // -----------------------------------------------------------------------
    //      current:
    //      --------
    //
    //      These two functions provide access to the current
    //      position, so that the user can alternate between using the
    //      iterators, and reading the data as a stream.  The first
    //      returns the current position, and the second sets it.
    //
    //      In order to avoid confusion when there are two users of
    //      the iterator, the read will also position the interal
    //      value of the iterator to the end, effectively causing any
    //      attempt to read characters from the streambuf to return
    //      EOF.
    // -----------------------------------------------------------------------
    FwdIter             current() ;
    void                current( FwdIter newCurrent ) ;

private:
    FwdIter             myCurrent ;
    FwdIter             myEnd ;
    char                myBuffer ;      // Separate buffer needed to guarantee
                                        // that putback will work.
} ;

// ===========================================================================
//      CRexIteratorIstream :
//      ====================
//
//      Convenience template class: a CRexIteratorIstream< FwdIter > is
//      an istream which uses a CRexIteratorInputStreambuf< FwdIter >
//      as its streambuf.
// ---------------------------------------------------------------------------

template< class FwdIter >
class CRexIteratorIstream :   public std::istream
{
public:
    // -----------------------------------------------------------------------
    //      Constructeurs, destructeurs et affectation :
    //      --------------------------------------------
    //
    //      Comme pour les istream de la norme, il n'y a pas de
    //      support ni de copie ni de l'affectation. Sinon, on
    //      rtrouve les constructeurs de FilteringInputStreambuf,
    //      avec en plus la possibilit de spcifier un istream  la
    //      place d'un streambuf -- dans ce cas, c'est le streambuf de
    //      l'istream au moment de la construction qui servira. (C'est
    //      constructeurs sont interessant, par exemple, dans les
    //      fonctions qui reoivent un istream& comme paramtre, ou
    //      pour filtrer sur std::cin.) Dans ces cas, le streambuf
    //      source n'appartient jamais  FilteringIstream.
    // -----------------------------------------------------------------------
    	    	    	CRexIteratorIstream( FwdIter begin , FwdIter end ) ;

    CRexIteratorInputStreambuf< FwdIter >*
    	    	    	rdbuf() ;

private:
     CRexIteratorInputStreambuf< FwdIter > m_buf;
} ;

#include <inc/iteristr.inl>
#endif
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\iosave.h ===
/****************************************************************************/
/*  File:       iosave.h                                                   */
/*  Author:     J. Kanze                                                    */
/*  Date:       11/04/1994                                                  */
/*      Copyright (c) 1994 James Kanze                                      */
/* ------------------------------------------------------------------------ */
//      CRexIOSave :
//      ===========
//
//      <lang=french>
//      Une classe pour sauvegarder l'tat de formattage d'ios,
//      d'aprs une ide de Jerry Schwarz.
//
//      Cette classe sauve l'tat complte du formattage dans son
//      constructeur, et le restitue dans le destructeur (appel parce
//      que on quitte la porte de la variable, ou une exception a t
//      leve).
//
//      Au mieux, on declarerait une instance de cette classe  la
//      tte de toute fonction qui tripotte les informations de
//      formattage, avec le stream (ios ou un de ces derives) comme
//      paramtre. (C'est tout ce qu'il faut ; la classe se charge de
//      la reste.)
//
//      La classe sauve tout l'tat SAUF :
//
//          width :     puisqu'il serait rmis  zro aprs chaque
//                      utilisation de toute faon.
//
//          error :     vraiment, il n'y a personne que veut qu'il
//                      soit remise a zero, j'espere.
//
//          tie :       il n'y faut pas tripotter une fois les sorties
//                      ont commencee.
//
//      En plus, cette classe ne connait pas les informations
//      etendues, allouees au moyen de ios::xalloc.
// --------------------------------------------------------------------------
//      <lang=english>
//      A class to save the formatting state of an std::ios, from an
//      idea by Jerry Schwarz.
//
//      This class saves the complete formatting state in its
//      constructor, and restores it in its destructor (called because
//      the variable is no longer in scope, or an exception has been thrown).
//
//      The best solution is probably to declare an instance of this
//      class at the start of any function which modifies the
//      formatting state, with the affected stream (ios or one of its
//      derived classes) as argument.  (That's all that's needed.  The
//      class takes care of all of the rest.)
//
//      The class saves everything BUT:
//
//          width:      since it will be reset after each use anyway.
//
//          error:      really, I hope no one wants this one restored.
//
//          tie:        since it shouldn't be modified anyway once
//                      output has started.
//
//      In addition, this class is blissfully unaware of the extended
//      information contained in the memory allocated by means of
//      ios::xalloc.
// --------------------------------------------------------------------------

#ifndef REX_IOSAVE_HH
#define REX_IOSAVE_HH

#include <inc/global.h>
#include <inc/ios.h>

class CRexIOSave
{
public :
    explicit            CRexIOSave( std::ios& userStream ) ;
                        ~CRexIOSave() ;
private :
    std::ios&      myStream ;
    REX_FmtFlags         myFlags ;
    int                 myPrecision ;
    char                myFill ;
} ;

#include <inc/iosave.inl>
#endif
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\iteristr.inl ===
/****************************************************************************/
/*  File:       iteristr.hh                                                 */
/*  Author:     J. Kanze                                                    */
/*  Date:       16/06/2000                                                  */
/*      Copyright (c) 2000 James Kanze                                      */
/* ------------------------------------------------------------------------ */

#include <inc/ios.h>

template< typename FwdIter >
CRexIteratorInputStreambuf< FwdIter >::CRexIteratorInputStreambuf(
    FwdIter             begin ,
    FwdIter             end )
    :   myCurrent( begin )
    ,   myEnd( end )
{
}

template< typename FwdIter >
int
CRexIteratorInputStreambuf< FwdIter >::overflow( int ch )
{
    return REX_eof ;
}

template< typename FwdIter >
int
CRexIteratorInputStreambuf< FwdIter >::underflow()
{
    int                 result( REX_eof ) ;
    if ( gptr() < egptr() ) {
        result = static_cast< unsigned char >( *gptr() ) ;
    } else if ( myCurrent != myEnd ) {
        myBuffer = *myCurrent ;
        ++ myCurrent ;
        setg( &myBuffer , &myBuffer , &myBuffer + 1 ) ;
        result = static_cast< unsigned char >( myBuffer ) ;
    }
    return result ;
}

template< typename FwdIter >
int
CRexIteratorInputStreambuf< FwdIter >::sync()
{
    return 0 ;
}

template< typename FwdIter >
std::streambuf*
CRexIteratorInputStreambuf< FwdIter >::setbuf( char* p , int len )
{
    return static_cast< std::streambuf* >( NULL ) ;
}

template< typename FwdIter >
FwdIter
CRexIteratorInputStreambuf< FwdIter >::current()
{
    FwdIter             result( myCurrent ) ;
    myCurrent = myEnd ;
    return result ;
}

template< typename FwdIter >
void
CRexIteratorInputStreambuf< FwdIter >::current( FwdIter newCurrent )
{
    myCurrent = newCurrent ;
}

#pragma warning( disable: 4355 )
template< typename FwdIter >
CRexIteratorIstream< FwdIter >::CRexIteratorIstream( FwdIter begin ,
                                                   FwdIter end )
    :   m_buf( begin , end )
    ,   std::istream( &m_buf )
{
}

template< typename FwdIter >
CRexIteratorInputStreambuf< FwdIter >*
CRexIteratorIstream< FwdIter >::rdbuf()
{
    return &m_buf;
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\iosave.inl ===
/****************************************************************************/
/*  File:       iosave.ihh                                                  */
/*  Author:     J. Kanze                                                    */
/*  Date:       03/11/1994                                                  */
/*      Copyright (c) 1994 James Kanze                                      */
/* ------------------------------------------------------------------------ */

inline
CRexIOSave::CRexIOSave( std::ios& userStream )
    :   myStream( userStream )
    ,   myFlags( userStream.flags() )
    ,   myPrecision( userStream.precision() )
    ,   myFill( userStream.fill() )
{
}

inline
CRexIOSave::~CRexIOSave()
{
    myStream.flags( myFlags ) ;
    myStream.precision( myPrecision ) ;
    myStream.fill( myFill ) ;
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\message.h ===
/****************************************************************************/
/*  File:       message.h                                                  */
/*  Author:     J. Kanze                                                    */
/*  Date:       04/01/1996                                                  */
/*      Copyright (c) 1996 James Kanze                                      */
/* ------------------------------------------------------------------------ */
/*  Modified:   07/11/2000  J. Kanze                                        */
/*      Changed to use std::string, std::vector, instead of char*,          */
/*      report errors with exception.                                       */
/* ------------------------------------------------------------------------ */
//      CRexMessage :
//      ============
//
//      <lang=french>
//      Gestion des messages d'une faon indpendante de la langue.
//
//      La faon dont les messages sont cherch dpend du systme ;
//      elle doit tre documente avec la documentation systme.
//      Typiquement, cependant : Il y aura une variable d'environment
//      qui spcifie le rpertoire o se trouvent tous les messages
//      (GABI_LOCALEDIR, par exemple), et une ou des variables
//      d'environment qui spcify la langue  utilise (LC_ALL,
//      LC_MESSAGES ou LANG par exemple).
//
//      Plus n'est pas spcifi parse qu'on veut conformer tant que
//      peut aux conventions du systme. (Donc, par exemple, si
//      GABI_LOCALEDIR n'est pas spcifi sous Solaris, on utilise
//      /opt/lib/locale. Dans un autre variant d'Unix, on prfrerait
//      /usr/lib/locale, ou peut-tre /usr/local/lib/locale.)
//
//      Normallement, l'initialisation invoquera la fonction systme :
//       setlocale( LC_MESSAGE , "" ) . Ceci doit avoir lieu lors de
//      la construction de la premire variable statique msg ; un
//      appel ultrieur  setlocale par l'application emportera donc.
//
//      L'utilisation normale est simplement :
//
//          msg.get( "messageId" ) ;
//
//      Cette fonction rend un pointeur au message dans la langue
//      spcifie par l'environment. Ce message peut tre dans de la
//      memoire statique, et il peut tre modifi au prochain appel de
//      la fonction.
//
//      A rmarquer :  prsent, CRexMessage utilise un variant du
//      compteur fut, comme iostream. Donc, il y a du code
//      d'initialisation dans chaque module qui inclut cette entte,
//      ce qui peut avoir des consquences dsagrable sur la vitesse
//      de l'initialisation. C'est la vie ; si quelqu'un a une
//      meilleure solution, qu'il me fasse signe.
//
//      Directions futures : il serait interessant de pouvoir
//      enregistrer plusieurs domaines : e.g. : GABI Software
//      (l'actuel), mais aussi pour l'application.
// ---------------------------------------------------------------------------
//      <lang=english>
//      Message handling in a language independant manner.
//
//      How the messages are looked up depends on the system; it
//      should be documented in the system documentation.  Typically,
//      however, there will be an environment variable which specifies
//      the directory where all of the messages are located
//      (GABI_LOCALEDIR, for example), and one or more environment
//      variables which specify the language to be used (LC_ALL,
//      LC_MESSAGES or LANG, for example).
//
//      No more is specified here, because we want to conform to the
//      local conventions of the host system as much as possible.
//      (Thus, for example, if GABI_LOCALEDIR isn't set under Solaris,
//      /opt/lib/locale will be used. Under another variant of Unix,
//      /usr/lib/locale might be preferred, or perhaps
//      /usr/local/lib/locale.)
//
//      Normally, the initialization will invoke the system function
//      "setlocale( LC_MESSAGE , "" )".  This will take place during
//      the construction of the first static variable msg; a later
//      invocation of setlocale by the application will dominate.
//
//      The normal use is simply:
//
//          msg.get( "messageId" ) ;
//
//      This function returns a pointer to the message in the language
//      specified by the environment.  This message may be in static
//      memory, and may be overwritten on subsequent invocations.
//
//      If for any reason the internationalized message cannot be
//      found, the argument itself will be returned.
// ---------------------------------------------------------------------------

#ifndef REX_MESSAGE_HH
#define REX_MESSAGE_HH

#include <inc/global.h>


//      Only defined in the implementation dependant code.  The actual
//      definition must provide a default constructor and a get
//      function compatible with the get of CRexMessage, below.
// ---------------------------------------------------------------------------
class CRexMessageImpl ;

static class CRexMessage
{
public :
                        CRexMessage() ;
    std::string      get( std::string const& messageId ) const throw() ;
private :
    static CRexMessageImpl*
                        ourImpl ;
}                   s_rex_message ;
#endif
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\refcnt.h ===
/****************************************************************************/
/*  File:       refcnt.h                                                   */
/*  Author:     J. Kanze                                                    */
/*  Date:       22/10/93                                                    */
/*      Copyright (c) 1993,1994 James Kanze                                 */
/* ------------------------------------------------------------------------ */
/*  Modified:   18/05/94    J. Kanze                                        */
/*      Converti aux templates.                                             */
/*  Modified:   25/10/94    J. Kanze                                        */
/*      Actualise en ce qui concerne les conventions de nomage.             */
/*  Modified:   28/03/1996  J. Kanze                                        */
/*      Retravailler selon les ides dans `More Effective C++' (merci,      */
/*      Scott).                                                             */
/*  Modified:   07/02/2000  J. Kanze                                        */
/*      Fait marcher les template membres : CRexRefCntObj ne peut pas        */
/*      tre un template. On perd un peu de scurit, mais la               */
/*      flexibilit supplmentaire en vaut la peine.                        */
/* ------------------------------------------------------------------------ */
//      RefCnt :
//      ===========
//
//      <lang=french>
//      Une classe gnrique pour la gestion des objets compts.
//
//      Afin d'tre gr par cette classe, un objet doit
//      obligatoirement drive de CRexRefCntObj ; en plus, cette
//      drivation ne doit pas tre virtuelle.  Aussi (videmment),
//      l'objet en question doit tre allou dynamiquement, avec un
//      new sans placement.  Pour meiux s'assurer de ces contraints,
//      il est fortement conseill d'encapsuler RefCntPtr dans un
//      classe manipulateuse (handle) associe  la classe (ou  la
//      hirarchie des classes) cible.
//
//      Noter bien qu'il n'y a rien qui empche qu'une classe drive
//      de CRexRefCntObj soit instancie sur la pile ou statiquement,
//      mais un tel objet ne doit jamais servir  initialiser un
//      CRexRefCntPtr.
//
//      CRexRefCntObj contient un constructeur noInit pour les cas
//      particulier.  Ce constructeur ne doit servir que pour les
//      objets statique, o l'initialisation  0 au depart garantit
//      une valeur correcte dans le compteur.  C'est en fait de
//      l'histoire ; aujourd'hui je connais de meillieur moyens pour
//      obtenir les mmes fins.
//
//      CRexRefCntObj n'a pas de destructeur virtuel.  Ainsi, on peut
//      driver de CRexRefCntObj sans encourir les frais d'un pointeur
//       la table des fonctions virtuelles.  Mais...  il ne faut pas
//      non plus appeler delete avec un pointeur  un CRexRefCntObj.
//      (Normallement, cela ne doit pas se produire, puisque c'est
//      CRexRefCntPtr qui doit appeler delete, et pas l'utilisateur.)
//      L'intention est que l'utilisateur peut (et doit) ignorer
//      compltement l'existance du CRexRefCntObj, une fois qu'il l'a
//      dclar comme classe de base.  En particulier, il n'est pas
//      prvu que l'utilisateur ait des pointeurs  un CRexRefCntObj 
//      lui.  Il n'y a que CRexRefCntPtr qui doit s'en charger.
// --------------------------------------------------------------------------
//      <lang=english>
//      The following defines a generic class for handling reference
//      counted objects.
//
//      To use reference counting, the reference counted class must
//      derive (not virtually) from CRexRefCntObj.  Also, the object
//      must be on the heap.  To ensure these invariants, it is
//      recommended that the RefCntPtr be encapsulated in a handle
//      class for the target type.  (In other words, this class is not
//      intended to be used at the application level, but rather in
//      the implementation of handle classes for the application.)
//
//      Note that an object deriving from CRexRefCntObj can be
//      constructed on the stack or as a static, but such an object
//      should *not* be used to initialize a CRexRefCntPtr.
//
//      A "no init" constructor for CRexRefCntObj is available for
//      special cases.
//
//      CRexRefCntObj does *not* have a virtual destructor!  This means
//      that classes can derive from CRexRefCntObj without necessarily
//      incuring the cost of a virtual function table pointer.  But...
//      it also means that deleting directly through a pointer to a
//      CRexRefCntObj will *not* work.
//
//      It is the intent that the user ignore completely CRexRefCntObj,
//      except for declaring it as a base class.  Generally, the user
//      should *not* maintain his own pointers to CRexRefCntObj; all
//      pointers to a reference counted class should be
//      CRexRefCntPtr's.
// --------------------------------------------------------------------------

#ifndef REX_REFCNT_HH
#define REX_REFCNT_HH


#include    <inc/global.h>
#include    <inc/counter.h>

template< class T > class CRexRefCntPtr ;

// ==========================================================================
//      CRexRefCntObj :
//      ==============
//
//      <lang=french>
//      Tout objet gr par CRexRefCntPtr doit obligatoirement drive
//      de cette classe.
//
//      Un CRexRefCntObj ne peut tre ni assign, ni copi.  La plupart
//      du temps, un essai de assigner ou de copier un tel objet
//      resulte d'une erreur de programmation.  (Enfin, le but de la
//      manip, c'est de pouvoir utiliser une semantique de rfrence
//      plutt qu'une semantique de copie.)  Donc, on l'interdit.
//      Dans le cas exceptionel o une copie peut tre dsirable
//      (e.g.: une fonction de clone), la classe drive a toujours la
//      libert de dfinir ces propres fonctions de assignement et de
//      copie (un constructeur).  Dans ce cas, ces fonctions doivent
//      s'crire comme si CRexRefCntObj n'y tait pas ; le compteur de
//      rfrences se trouvant ainsi soit initialis  zro (copie),
//      soit inchang (assignement).
//
//
//      <lang=english>
//      All objects which are to be managed by a CRexRefCntPtr must
//      have this class as a base.
//
//      CRexRefCntObj is unassignable (and uncopiable).  In most cases,
//      copying or assigning a reference counted object is an error,
//      so we forbid it.  In the exceptional cases where it might make
//      sense, the derived class can always provide an overriding copy
//      constructor or assignment operator.  In such cases: the copy
//      constructor and assignment operator should be written as
//      though the class did not derive from CRexRefCntObj.
// --------------------------------------------------------------------------

class CRexRefCntObj
{
public:
    unsigned            useCount() const ;

    void                incrUse() ;
    void                decrUse() ;

protected:
    //      Constructeurs, destructeurs et operateurs d'assignement :
    //      =========================================================
    //
    //      <lang=french>
    //      CRexRefCntObj a les constructeurs suivant :
    //
    //      le defaut :         initialise le compteur de rfrences 
    //                          zro.
    //
    //      Il n'y a ni de constructeur de copie, ni d'oprateur
    //      d'assignement (voir ci-dessus).
    //
    //      Le destructeur est protg, afin que l'utilisateur n'a
    //      mme pas la possibilit d'appeler delete sur un pointeur 
    //      un CRexRefCntObj.
    //
    //
    //      <lang=english>
    //      CRexRefCntObj has the following constructors:
    //
    //      default:            Initializes the reference count to
    //                          zero.
    //
    //      Copy construction and assignment are *not* supported, see
    //      above.
    // ----------------------------------------------------------------------
                        CRexRefCntObj() ;
    virtual             ~CRexRefCntObj() ;

private :
                        CRexRefCntObj( CRexRefCntObj const& other ) ;
    CRexRefCntObj&       operator=( CRexRefCntObj const& other ) ;

    CRexCounter< unsigned >
                        myUseCount ;
} ;

// ==========================================================================
//      CRexRefCntPtr :
//      ==============
//
//      <lang=french>
//      Une classe gnrique, qui pointe  un objet compt d'un type
//      driv de CRexRefCntPtr.
//
//      Il y a deux raisons pour qu'il pointe au type driv, plutt
//      qu'au CRexRefCntObj mme :
//
//      1.  Scurit de type.  Un CRexRefCntPtr d'un type donn ne peut
//          rfre qu' un objet de ce type, ou d'un type driv de ce
//          type.
//
//      2.  Simplicit des types drivs de CRexRefCntObj.  Si
//          CRexRefCntPtr n'tait pas gnrique, et ne savait pas le
//          type de l'objet auquel il rfrait, il faudrait que
//          CRexRefCntObj ait un destructeur virtuel.  Dans
//          l'implementation ici, REX_REfCntObj n'a aucune fonction
//          virtuelle, et donc il n'impose pas de fonctions virtuelles
//          aux classes drives.
//
//
//      <lang=english>
//      A generic class which points to an object of a type derived
//      from CRexRefCntObj.
//
//      There are two reasons for doing this, rather than simply
//      having a non-template class pointing to CRexRefCntObj:
//
//      1.  Type safety.  A CRexRefCntPtr of one type cannot point to
//          an object of another type.
//
//      2.  Simplicity of the class derived from CRexRefCntObj.  If
//          CRexRefCntPtr were not generic (and thus didn't know the
//          actual type of what it was pointing to), CRexRefCntObj
//          would have to have a virtual destructor.  In the present
//          implementation, CRexRefCntObj has *no* virtual functions,
//          and so does not impose virtual functions on the derived
//          class.
// --------------------------------------------------------------------------

template< class T >
class CRexRefCntPtr
{
public :
    //      Constructeurs, destructeurs et operateurs d'assignement :
    //      =========================================================
    //
    //      <lang=french>
    //      Construction par copie et assignement sont pourvus.  En
    //      plus, il est possible d'assigner un T* directement.  (Dans
    //      ce cas, attention : le T* doit obligatoirement provenir
    //      d'une expression de new.)
    //
    //
    //      <lang=english>
    //      There is no default constructor; a CRexRefCntPtr must
    //      always be initialized to point to a T.
    //
    //      Copy construction and assignment are supported.  In
    //      addition to being able to assign another CRexRefCntPtr to a
    //      CRexRefCntPtr, it is possible to assign a T* directly.
    // ----------------------------------------------------------------------
    template< class D > CRexRefCntPtr( D* newedPtr )
        :   myPtr( newedPtr )
    {
        if ( isValid() ) {
            //  On utilise l'affectation avec la conversion implicite pour
            //  provoquer une erreur de compilation si T ne drive pas de
            //  CRexRefCntObj. Mme l'optimisation la plus primitive doit
            //  pouvoir l'liminer.
            CRexRefCntObj*       tmp = newedPtr ;
            tmp->incrUse() ;
        }
    }

    template< class D > CRexRefCntPtr( const CRexRefCntPtr< D >& other )
        :   myPtr( other.get() )
    {
        if ( isValid() ) {
    	myPtr->incrUse() ;
        }
    }

    explicit CRexRefCntPtr( T* newedPtr  = 0)
        :   myPtr( newedPtr )
    {
        if ( isValid() ) {
            //  On utilise l'affectation avec la conversion implicite pour
            //  provoquer une erreur de compilation si T ne drive pas de
            //  CRexRefCntObj. Mme l'optimisation la plus primitive doit
            //  pouvoir l'liminer.
            CRexRefCntObj*       tmp = newedPtr ;
            tmp->incrUse() ;
       }
    }

    CRexRefCntPtr( const CRexRefCntPtr& other )
          :   myPtr( other.get() )
    {
        if ( isValid() ) {
 	    myPtr->incrUse() ;
        }
    }


                        ~CRexRefCntPtr() ;

    CRexRefCntPtr< T >&  operator=( T* newedPtr ) ;

    template< class D >
    CRexRefCntPtr< T >&  operator=( CRexRefCntPtr< D > const& other )
    {
        return operator=( other.get() ) ;
    }

    CRexRefCntPtr< T >& operator=( CRexRefCntPtr const& other )
    {
        return operator=( other.get() ) ;
    }


    //      isValid :
    // ----------------------------------------------------------------------
    bool                isValid() const ;

    //      get :
    //      =====
    //
    //      Cette fonction sert  obtenir un T*  l'tat brut.  En
    //      gnral, elle est fortement dconseill, vu les dangers
    //      qu'elle prsente.  En effet, le pointeur qui en resulte
    //      n'tant pas gr par la classe, l'objet auquel il rfre
    //      peut ainsi cesser d'exister d'une faon inopportune, avec
    //      des resultats gnralement dsagrables.
    // ----------------------------------------------------------------------
    T*                  get() const ;

    //      count :
    //      =======
    //
    //      Retourne le nombre de pointeurs qui refere au meme objet.
    //      Typiquement, cette fonction sert a implementer les strategies de
    //      "copy on write" ; elle sera appelee avant la modification, et si
    //      elle retourne une valeur superieur a un, l'appelant fera une
    //      copie profonde avant d'effectuer la modification. Ex. :
    //
    //          if ( ptr.count() > 1 ) {
    //              ptr = ptr->clone() ;
    //          }
    //
    //      (Ce suppose que l'objet en question a une fonction clone qui
    //      retourne une copie de l'objet.)
    // ----------------------------------------------------------------------
    unsigned            count() const ;

    //      Oprateurs d'accs :
    //      ====================
    //
    //      <lang=french>
    //      Ces oprateurs sont identiques aux mmes oprateurs sur
    //      des pointeurs ; ils rprsentent la faon habituelle
    //      d'utiliser des CRexRefCntPtr.
    //
    //      <lang=english>
    //      These operators simulate the same operations on pointers,
    //      and are the normal way of using CRexRefCntPtr's.
    // ----------------------------------------------------------------------
    T*                  operator->() const ;
    T&                  operator*() const ;

    unsigned            hashCode() const ;
    int                 compare( CRexRefCntPtr< T > const& other ) const ;
private :
    T*                  myPtr ;
} ;

#include <inc/refcnt.inl>
#endif
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\refcnt.inl ===
/****************************************************************************/
/*  File:       refcnt.ihh                                                  */
/*  Author:     J. Kanze                                                    */
/*  Date:       28/03/1996                                                  */
/*      Copyright (c) 1996 James Kanze                                      */
/* ------------------------------------------------------------------------ */

#include <inc/dataptr.h>
#include <stdio.h>

//      CRexRefCntObj :
// ==========================================================================

inline unsigned
CRexRefCntObj::useCount() const
{
    return myUseCount.value() ;
}

inline void
CRexRefCntObj::incrUse()
{
    myUseCount.incr() ;
}

inline void
CRexRefCntObj::decrUse()
{
    myUseCount.decr() ;
    if ( myUseCount.value() == 0 ) {
	delete this ;
    }
}

inline
CRexRefCntObj::CRexRefCntObj()
{
}

inline
CRexRefCntObj::~CRexRefCntObj()
{
}

//      CRexRefCntPtr :
//      ==============
//
//      On dfie de l'ordre de la dclaration afin que les fonctions
//      soit dfinie avant l'utilisation.  En particulier, puisque
//      "get" et "isValid" servent  peu prs partout, elles sont
//      dfinie en premire.
// ==========================================================================

template< class T >
inline bool
CRexRefCntPtr< T >::isValid() const
{
    return myPtr != NULL ;
}

template< class T >
inline T*
CRexRefCntPtr< T >::get() const
{
    return myPtr ;
}




template< class T >
inline
CRexRefCntPtr< T >::~CRexRefCntPtr()
{
    if ( isValid() ) {
	myPtr->decrUse() ;
    }
}

template< class T >
inline CRexRefCntPtr< T >&
CRexRefCntPtr< T >::operator=( T* newedPtr )
{
    if ( newedPtr != myPtr ) {
	if ( isValid() ) {
	    myPtr->decrUse() ;
        }
	myPtr = newedPtr ;
	if ( isValid() ) {
            //  On utilise l'affectation avec la conversion implicite pour
            //  provoquer une erreur de compilation si T ne drive pas de
            //  CRexRefCntObj. Mme l'optimisation la plus primitive doit
            //  pouvoir l'liminer.
            CRexRefCntObj*       tmp = newedPtr ;
	    tmp->incrUse() ;
        }
    }
    return *this ;
}



template< class T >
inline unsigned
CRexRefCntPtr< T >::count() const
{
    return (! isValid())
        ? 0
        : myPtr->useCount() ;
}

template< class T >
inline T*
CRexRefCntPtr< T >::operator->() const
{
    ASSERT( isValid() ); //Attempt to dereference null (reference counted) pointer
    return get() ;
}

template< class T >
inline T&
CRexRefCntPtr< T >::operator*() const
{
    ASSERT( isValid() ); //Attempt to dereference null (reference counted) pointer
    return *get() ;
}

template< class T >
inline unsigned
CRexRefCntPtr< T >::hashCode() const
{
    return CRexDataPointers::hashCode( get() ) ;
}

template< class T >
inline int
CRexRefCntPtr< T >::compare( CRexRefCntPtr< T > const& other ) const
{
    return CRexDataPointers::compare( get() , other.get() ) ;
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\system.h ===
/****************************************************************************/
/*  File:       system.h                                                  */
/*  Author:     J. Kanze                                                    */
/*  Date:       28/03/1996                                                  */
/*      Copyright (c) 1996,1998 James Kanze                                 */
/* ------------------------------------------------------------------------ */
//      Definitions for Intel 80x86, 32 bit MS-Windows, g++ 2.95 and up.
// --------------------------------------------------------------------------
//      Compiler definition:
//      ====================
//
//      The following definitions describe the state of the compiler.
//      Most are predicates, and specify whether or not the compiler
//      supports a given new feature.
// --------------------------------------------------------------------------
#pragma warning(push, 3)


// ==========================================================================
//      Definition of the system:
//      =========================
//
//      The following definitions try to encapsulate certain
//      differences between operating systems.  In fact, the problem
//      is more difficult that it would seem ; under MS-DOS, for
//      example, the character to separate directories changes
//      according to a non documented system request, and in fact,
//      most programs accepted both '\' and '/'.  Not to mention the
//      systems which don't have a directory hierarchy, or which
//      maintain a version, etc.
//
//      Hopefully, these definitions will be replaced by a class some
//      time in the future, a sort of global 'traits'.  And we need a
//      special class just to manipulate filenames (with and/or
//      without path, version, etc.)
// --------------------------------------------------------------------------
//      Special characters:
// --------------------------------------------------------------------------

static char const   REX_optId = '-' ;    // - under UNIX
static char const   REX_altOptId = '+' ; // + under UNIX
static char const   REX_asciiEsc = '\\' ;// \ under UNIX
static char const   REX_preferredPathSep = '/' ;  // / under UNIX
static char const   REX_allowedPathSep[] = "/\\" ;
static bool const   REX_ignoreCase = true ;
                                        // in filenames only.
static char const   REX_stdinName[] = "-" ;

//      Return codes:
//      =============
//
//      The standard only defines two, EXIT_SUCCESS and EXIT_FAILURE.
//      We want more, if the system supports it.
//
//      These values work for all Unix and Windows based systems.  In
//      the worst case, define the first *two* as EXIT_SUCCESS, and
//      the others as EXIT_FAILURE.  Some information will be lost,
//      but at least we won't lie.
// --------------------------------------------------------------------------

static int const    REX_exitSuccess = 0 ;
static int const    REX_exitWarning = 1 ;
static int const    REX_exitError = 2 ;
static int const    REX_exitFatal = 3 ;
static int const    REX_exitInternal = 4 ;


//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\encryptor.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    encryptor.cpp

Abstract:
    Implementing class CSSlEncryptor (encryptor.h)


Author:
    Gil Shafriri (gilsh) 27-Feb-2001

--*/

#include <libpch.h>
#include "stp.h"
#include "encryptor.h"

#include "encryptor.tmh"

CSSlEncryptor::CSSlEncryptor(
	const SecPkgContext_StreamSizes& StreamSizes,
	PCredHandle SecContext
	):
	m_EncryptedData(2048),
	m_StreamSizes(StreamSizes),
	m_SecContext(SecContext)
	{
 		m_EncryptedBuffers.reserve(2);
	}



void CSSlEncryptor::FixPointers()
/*++

Routine Description:
    This function is called to fix the pointers to the encrypted data
	because the buffer that holds the encrypted data was realocated and the data was moved.
  
Returned Value:
None

--*/
{
	size_t ofsset = 0;
	std::vector<WSABUF>::iterator it;
	for(it = m_EncryptedBuffers.begin(); it!= m_EncryptedBuffers.end(); ++it)
	{
		it->buf = m_EncryptedData.begin() + ofsset;
		ofsset += it->len;
	}

	ASSERT(m_EncryptedData.begin() + ofsset ==  m_EncryptedData.end() );
}


/*++

Routine Description:
    Encrypte data (copy the data,  no inplce encryption) and append it to the encrypted buffers.
	  
Arguments:
	pdata - data to encrypt
	len - data length in bytes
  
  
Returned Value:
None

--*/
void CSSlEncryptor::Append(const void* pdata, size_t DataLen)
{
	size_t Headerlen = m_StreamSizes.cbHeader;
	size_t TrailLen = m_StreamSizes.cbTrailer;
	size_t EncryptedLen = Headerlen + DataLen + TrailLen;
	size_t TotalNeededLen = EncryptedLen + m_EncryptedData.size();	
  
	if(m_EncryptedData.capacity() < TotalNeededLen)
	{
		//
		// Because we needed more space for the heade + body + trailer 
		// We must resize the vector holding the encrypted data - 
		// doing this will change the data location	so the pointers in 
		// the WSABUF are  not correct any more  - we need to fix them.
		//

		m_EncryptedData.reserve(TotalNeededLen * 2);	
		FixPointers();
	}

	//
	//Copy the body to it's place between the header and the trailer
	//
	char* pBody =  m_EncryptedData.end() +  Headerlen;
	memcpy(
		pBody,
		pdata,
		DataLen
		);


  
	SecBufferDesc   Message;
    SecBuffer       Buffers[4];
	

	//
	// SSL header buffer
	//
	char* pHeader =  m_EncryptedData.end();
    Buffers[0].pvBuffer     = pHeader;
    Buffers[0].cbBuffer     = numeric_cast<DWORD>(Headerlen);
    Buffers[0].BufferType   = SECBUFFER_STREAM_HEADER;


	//
	// SSL body buffer
	//
	Buffers[1].pvBuffer     = pBody;
    Buffers[1].cbBuffer     = numeric_cast<DWORD>(DataLen);
    Buffers[1].BufferType   = SECBUFFER_DATA;


	//
	// SSL trailer buffer
	//
	char* pTrail = pBody + DataLen;
    Buffers[2].pvBuffer     = pTrail;
    Buffers[2].cbBuffer     = numeric_cast<DWORD>(TrailLen);
    Buffers[2].BufferType   = SECBUFFER_STREAM_TRAILER;


	//
	// Empty buffer as termination
	//
    Buffers[3].BufferType   = SECBUFFER_EMPTY;

    Message.ulVersion       = SECBUFFER_VERSION;
    Message.cBuffers        = TABLE_SIZE(Buffers);
    Message.pBuffers        = Buffers;

	ASSERT(Buffers[1].pvBuffer >  Buffers[0].pvBuffer); 

    SECURITY_STATUS scRet = EncryptMessage(m_SecContext,0,&Message, 0);
	if(scRet != SEC_E_OK)
    {
		TrERROR(NETWORKING, "EncryptMessage returned error %x", scRet);
	    throw exception();
    }

	WSABUF buf;
	buf.len = numeric_cast<DWORD>(EncryptedLen);
	buf.buf = pHeader; 
	m_EncryptedBuffers.push_back(buf);


	m_EncryptedData.resize(TotalNeededLen);
}


const std::vector<WSABUF>& CSSlEncryptor::GetEncrypted() const
{
	return m_EncryptedBuffers;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\encryptor.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    encryptor.h

Abstract:
    Header for class CSSlEncryptor responsible to encrypt data (copy the data not inplace encrtption !!)
	and to 	return encrypted buffers ready for delivery.


Author:
    Gil Shafriri (gilsh) 27-Feb-2001

--*/

#ifndef __ST_SSLENCRYPTOR_H
#define __ST_SSLENCRYPTOR_H
#include <buffer.h>

 
class CSSlEncryptor
{
public:
	CSSlEncryptor(const SecPkgContext_StreamSizes& StreamSizes, PCredHandle SecContext);


public:
	void Append(const void* pdata, size_t len);
	void Clear()
	{
		m_EncryptedBuffers.resize(0);
		m_EncryptedData.resize(0);
	}

	const std::vector<WSABUF>& GetEncrypted() const;

private:
	void FixPointers();


private:
	std::vector<WSABUF> m_EncryptedBuffers;
	CResizeBuffer<char> m_EncryptedData;
	const SecPkgContext_StreamSizes& m_StreamSizes;
	PCredHandle m_SecContext;
};

	 	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\setofchr.inl ===
/****************************************************************************/
/*  File:       setofchr.ihh                                                */
/*  Author:     J. Kanze                                                    */
/*  Date:       04/03/91                                                    */
/* ------------------------------------------------------------------------ */
/*  Modified:   14/04/92    J. Kanze                                        */
/*      Converted to CCITT naming conventions.                              */
/*  Modified:   13/06/2000  J. Kanze                                        */
/*      Ported to current library conventions, iterators.                   */
/* ------------------------------------------------------------------------ */

#include <inc/ios.h>                    // for REX_eof

//      Simple tests...
// --------------------------------------------------------------------------
inline bool
CRexSetOfChar::contains( unsigned char element ) const
{
    return super::contains( static_cast< Byte >( element ) ) ;
}

inline bool
CRexSetOfChar::contains( char element ) const
{
    return contains( static_cast< unsigned char >( element ) ) ;
}

inline bool
CRexSetOfChar::contains( int element ) const
{
    return contains( static_cast< unsigned char >( element ) ) ;
}

//      find...
// --------------------------------------------------------------------------
inline int
CRexSetOfChar::find( char from ) const
{
    return find( static_cast< unsigned char >( from ) ) ;
}

inline int
CRexSetOfChar::find( unsigned char from ) const
{
    return find( static_cast< int >( from ) ) ;
}

inline int
CRexSetOfChar::find( int from ) const
{
    BitIndex            result = super::find( true , from ) ;
    return result == infinity
        ?   REX_eof
        :   static_cast< unsigned char >( result ) ;
}

inline CRexSetOfChar::BitIndex
CRexSetOfChar::find( bool target , BitIndex from = 0 ) const
{
    return super::find( target , from ) ;
}

inline void
CRexSetOfChar::clear()
{
    super::reset() ;
}

inline void
CRexSetOfChar::complement()
{
    super::complement() ;
}

//      Character manipulations...
// --------------------------------------------------------------------------
inline void
CRexSetOfChar::set( char element )
{
    set( static_cast< unsigned char >( element ) ) ;
}

inline void
CRexSetOfChar::set( int element )
{
    set( static_cast< unsigned char >( element ) ) ;
}

inline void
CRexSetOfChar::set( unsigned char element )
{
    super::set( element ) ;
}

inline void
CRexSetOfChar::reset( char element )
{
    reset( static_cast< unsigned char >( element ) ) ;
}

inline void
CRexSetOfChar::reset( int element )
{
    reset( static_cast< unsigned char >( element ) ) ;
}

inline void
CRexSetOfChar::reset( unsigned char element )
{
    super::reset( element ) ;
}

inline void
CRexSetOfChar::complement( char element )
{
    complement( static_cast< unsigned char >( element ) ) ;
}

inline void
CRexSetOfChar::complement( int element )
{
    complement( static_cast< unsigned char >( element ) ) ;
}

inline void
CRexSetOfChar::complement( unsigned char element )
{
    super::complement( element ) ;
}

//      Manipulations with another set...
// --------------------------------------------------------------------------
inline void
CRexSetOfChar::set( CRexSetOfChar const& other )
{
    super::set( other ) ;
}

inline void
CRexSetOfChar::reset( CRexSetOfChar const& other )
{
    super::reset( other ) ;
}

inline void
CRexSetOfChar::complement( CRexSetOfChar const& other )
{
    super::complement( other ) ;
}

inline void
CRexSetOfChar::intersect( CRexSetOfChar const& other )
{
    super::intersect( other ) ;
}

//      Operators...
// --------------------------------------------------------------------------
inline CRexSetOfChar&
CRexSetOfChar::operator|=( CRexSetOfChar const& other )
{
    set( other ) ;
    return *this ;
}

inline CRexSetOfChar&
CRexSetOfChar::operator&=( CRexSetOfChar const& other )
{
    intersect( other ) ;
    return *this ;
}

inline CRexSetOfChar&
CRexSetOfChar::operator^=( CRexSetOfChar const& other )
{
    complement( other ) ;
    return *this ;
}

inline CRexSetOfChar&
CRexSetOfChar::operator+=( CRexSetOfChar const& other )
{
    set( other ) ;
    return *this ;
}

inline CRexSetOfChar&
CRexSetOfChar::operator+=( char other )
{
    set( other ) ;
    return *this ;
}

inline CRexSetOfChar&
CRexSetOfChar::operator+=( unsigned char other )
{
    set( other ) ;
    return *this ;
}

inline CRexSetOfChar&
CRexSetOfChar::operator+=( int other )
{
    set( other ) ;
    return *this ;
}

inline CRexSetOfChar&
CRexSetOfChar::operator-=( CRexSetOfChar const& other )
{
    reset( other ) ;
    return *this ;
}

inline CRexSetOfChar&
CRexSetOfChar::operator-=( char other )
{
    reset( other ) ;
    return *this ;
}

inline CRexSetOfChar&
CRexSetOfChar::operator-=( unsigned char other )
{
    reset( other ) ;
    return *this ;
}

inline CRexSetOfChar&
CRexSetOfChar::operator-=( int other )
{
    reset( other ) ;
    return *this ;
}

inline CRexSetOfChar&
CRexSetOfChar::operator*=( CRexSetOfChar const& other )
{
    intersect( other ) ;
    return *this ;
}

//      STL iterator accessors...
// --------------------------------------------------------------------------
inline CRexSetOfChar::iterator
CRexSetOfChar::begin() const
{
    return iterator( *this ) ;
}

inline CRexSetOfChar::iterator
CRexSetOfChar::end() const
{
    return iterator() ;
}

//      Operators...
// --------------------------------------------------------------------------
inline CRexSetOfChar
operator-( CRexSetOfChar const& other )
{
    return operator~( other ) ;
}

inline CRexSetOfChar
operator+( CRexSetOfChar const& lhr , char rhs )
{
    return operator+( lhr , static_cast< unsigned char >( rhs ) ) ;
}

inline CRexSetOfChar
operator-( CRexSetOfChar const& lhr , char rhs )
{
    return operator-( lhr , static_cast< unsigned char >( rhs ) ) ;
}

inline bool
operator==( CRexSetOfChar const& op1 , CRexSetOfChar const& op2 )
{
    return op1.isEqual( op2 ) ;
}

inline bool
operator!=( CRexSetOfChar const& op1 , CRexSetOfChar const& op2 )
{
    return ! op1.isEqual( op2 ) ;
}

inline bool
operator>( CRexSetOfChar const& op1 , CRexSetOfChar const& op2 )
{
    return op2.isSubsetOf( op1 ) && ! op2.isEqual( op1 ) ;
}

inline bool
operator>=( CRexSetOfChar const& op1 , CRexSetOfChar const& op2 )
{
    return op2.isSubsetOf( op1 ) ;
}

inline bool
operator< (CRexSetOfChar const& op1 , CRexSetOfChar const& op2 )
{
    return op1.isSubsetOf( op2 ) && ! op1.isEqual( op2 ) ;
}

inline bool
operator<=( CRexSetOfChar const& op1 , CRexSetOfChar const& op2 )
{
    return op1.isSubsetOf( op2 ) ;
}

//      CharClass...
// --------------------------------------------------------------------------
inline bool
CRexCharClass::good() const
{
    return status == ok ;
}

inline CRexCharClass::Status
CRexCharClass::errorCode() const
{
    return status ;
}

inline std::string
CRexCharClass::errorMsg() const
{
    return errorMsg( status ) ;
}
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\test\rextest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    RexTest.cpp

Abstract:
    Regular Expression based Queues Alias library test

Author:
    Vlad Dovlekaev (vladisld) 27-Dec-01

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <iostream>
#include "rex.h"

#pragma warning(disable:4100)

#include "RexTest.tmh"

static bool TestInit();
static void PrintAll();
static void Usage();
static int RunTest();


static char const*
asString( bool value )
{
    return value ? "true" : "false" ;
}

static char const*
passed( bool value )
{
    return value ? "test passed: " : "test failed: " ;
}


class TestRegExpr
{
public:
    void verify( bool ist , bool soll )
    {
        std::cout << passed( ist == soll )
            << " is "
            << asString( ist )
            << " should be "
            << asString( soll )
            << std::endl ;

    }
    void verify( int ist , int soll )
    {
        std::cout << passed( ist == soll )
            << " is "
            << ist
            << " should be "
            << soll
            << std::endl ;

    }
    void verify( char const* ist , char const* soll )
    {
        static std::string const empty ;
        std::cout << passed( ist == soll )
            << " is "
            << static_cast< void const* >( ist )
            << " ("
            << (ist == NULL ? empty.c_str() : ist)
            << ")"
            << " should be "
            << static_cast< void const* >( soll )
            << " ("
            << (soll == NULL ? empty.c_str() : soll)
            << ")"
            << std::endl ;

    }
} ;




int count = 1;

extern "C"
int
__cdecl
_tmain(
    int argc,
    LPCTSTR* argv
    )
/*++

Routine Description:
    Test Queues Alias library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

    if(argc == 2  && (wcscmp(argv[1],L"/?") ==0 || wcscmp(argv[1],L"\?") ==0)  )
    {
        Usage();
        return 1;
    }

    if(argc == 3  && wcscmp(argv[1],L"/c") == 0 )
    {
        count = _wtol(argv[2]);
    }

    if(!TestInit())
    {
        TrTRACE(GENERAL, "Could not initialize test");
        return 1;
    }

    int ret=RunTest();

    WPP_CLEANUP();
    return ret;
}

static void Usage()
{
    wprintf(L"rextest [/c count] \n");
    wprintf(L"-l : run forever (leak test) \n");
}

static
bool
TestInit()
{
    TrInitialize();
    return true;
}

static
int
RunTest()
{
    try
    {

        printf("Running Test %d times ", count );
        TrTRACE(GENERAL, "Start RexTest");
        printf("start 1");
        DWORD dwTickCount = GetTickCount();
        for(DWORD  i = 0; i < (DWORD)count; ++i )
            PrintAll();
        printf(" - %d\n", GetTickCount() - dwTickCount);
        TrTRACE(GENERAL, "RexTest print took: %d ticks", GetTickCount() - dwTickCount);
    }
    catch(const exception&)
    {
        TrTRACE(GENERAL, "Got c++ exception");
    }
    TrTRACE(GENERAL, "Test ok");
    return 0;
}

void
testMerge(  )            // Merge
{
    TestRegExpr         t;
    {
        CRegExpr          re( "[1-9][0-9]*" , 10 ) ;
        re |= CRegExpr( "0[0-7]*" , 8 ) ;
        re |= CRegExpr( "0[Xx][:xdigit:]+" , 16 ) ;
        char const*         s = "0" ;
        char const*         end = NULL ;
/* 1*/  t.verify( re.match( s , &end ) , 8 ) ;
/* 2*/  t.verify( end , s + 1 ) ;
        s = "1" ;
        end = NULL ;
/* 3*/  t.verify( re.match( s , &end ) , 10 ) ;
/* 4*/  t.verify( end , s + 1 ) ;
        s = "0x1" ;
        end = NULL ;
/* 5*/  t.verify( re.match( s , &end ) , 16 ) ;
/* 6*/  t.verify( end , s + 3 ) ;
        s = "08" ;
        end = NULL ;
/* 7*/  t.verify( re.match( s , &end ) , 8 ) ;
/* 8*/  t.verify( end , s + 1 ) ;
        s = "1a" ;
        end = NULL ;
/* 9*/  t.verify( re.match( s , &end ) , 10 ) ;
/*10*/  t.verify( end , s + 1 ) ;
        s = "0X1fg" ;
        end = NULL ;
/*11*/  t.verify( re.match( s , &end ) , 16 ) ;
/*12*/  t.verify( end , s + 4 ) ;
    }
}


void
testSimple(  )           // Simple
{
    TestRegExpr         t ;
    {
        CRegExpr          re( "abc" ) ;
/* 1*/  t.verify( re.good() , true ) ;
        char const*         s = "abcd" ;
        char const*         end = NULL ;
/* 2*/  t.verify( re.match( s , &end ) , 0 ) ;
/* 3*/  t.verify( end , s + 3 ) ;
        s = "abd" ;
        end = NULL ;
/* 4*/  t.verify( re.match( s , &end ) , -1 ) ;
/* 5*/  t.verify( end , NULL ) ;
    }
    {
        CRegExpr          re( "." ) ;
/* 6*/  t.verify( re.good() , true ) ;
        char const*         s = "abc" ;
        char const*         end = NULL ;
/* 7*/  t.verify( re.match( s , &end ) , 0 ) ;
/* 8*/  t.verify( end , s + 1 ) ;
        s = "\nabc" ;
        end = NULL ;
/* 9*/  t.verify( re.match( s , &end ) , -1 ) ;
/*10*/  t.verify( end , NULL ) ;
    }
    {
        CRegExpr          re( "a[xyz]c" ) ;
/*11*/  t.verify( re.good() , true ) ;
        char const*         s = "axcd" ;
        char const*         end = NULL ;
/*12*/  t.verify( re.match( s , &end ) , 0 ) ;
/*13*/  t.verify( end , s + 3 ) ;
        s = "abcd" ;
        end = NULL ;
/*14*/  t.verify( re.match( s , &end ) , -1 ) ;
/*15*/  t.verify( end , NULL ) ;
    }
    {
        CRegExpr          re( "ab*c" ) ;
/*16*/  t.verify( re.good() , true ) ;
        char const*         s = "abbbcd" ;
        char const*         end = NULL ;
/*17*/  t.verify( re.match( s, &end ) , 0 ) ;
/*18*/  t.verify( end , s + 5 ) ;
        s = "abcd" ;
        end = NULL ;
/*19*/  t.verify( re.match( s, &end ) , 0 ) ;
/*20*/  t.verify( end , s + 3 ) ;
        s = "acd" ;
        end = NULL ;
/*21*/  t.verify( re.match( s, &end ) , 0 ) ;
/*22*/  t.verify( end , s + 2 ) ;
    }
    {
        CRegExpr          re( "ab+c" ) ;
/*23*/  t.verify( re.good() , true ) ;
        char const*         s = "abbbcd" ;
        char const*         end = NULL ;
/*24*/  t.verify( re.match( s, &end ) , 0 ) ;
/*25*/  t.verify( end , s + 5 ) ;
        s = "abcd" ;
        end = NULL ;
/*26*/  t.verify( re.match( s, &end ) , 0 ) ;
/*27*/  t.verify( end , s + 3 ) ;
        s = "acd" ;
        end = NULL ;
/*28*/  t.verify( re.match( s, &end ) , -1 ) ;
/*29*/  t.verify( end , NULL ) ;
    }
    {
        CRegExpr          re( "ab?c" ) ;
/*30*/  t.verify( re.good() , true ) ;
        char const*         s = "abbbcd" ;
        char const*         end = NULL ;
/*31*/  t.verify( re.match( s, &end ) , -1 ) ;
/*32*/  t.verify( end , NULL ) ;
        s = "abcd" ;
        end = NULL ;
/*33*/  t.verify( re.match( s, &end ) , 0 ) ;
/*34*/  t.verify( end , s + 3 ) ;
        s = "acd" ;
        end = NULL ;
/*35*/  t.verify( re.match( s, &end ) , 0 ) ;
/*36*/  t.verify( end , s + 2 ) ;
    }
    {
        CRegExpr          re( "a|b" ) ;
/*37*/  t.verify( re.good() , true ) ;
        char const*         s = "abcd" ;
        char const*         end = NULL ;
/*38*/  t.verify( re.match( s , &end ) , 0 ) ;
/*39*/  t.verify( end , s + 1 ) ;
        s = "bcd" ;
        end = NULL ;
/*40*/  t.verify( re.match( s , &end ) , 0 ) ;
/*41*/  t.verify( end , s + 1 ) ;
        s = "cd" ;
        end = NULL ;
/*42*/  t.verify( re.match( s , &end ) , -1 ) ;
/*43*/  t.verify( end , NULL ) ;
    }
    {
        CRegExpr          re( "(a|b)c" ) ;
/*44*/  t.verify( re.good() , true ) ;
        char const*         s = "acd" ;
        char const*         end = NULL ;
/*45*/  t.verify( re.match( s , &end ) , 0 ) ;
/*46*/  t.verify( end , s + 2 ) ;
        s = "bcd" ;
        end = NULL ;
/*47*/  t.verify( re.match( s , &end ) , 0 ) ;
/*48*/  t.verify( end , s + 2 ) ;
        s = "xcd" ;
        end = NULL ;
/*49*/  t.verify( re.match( s , &end ) , -1 ) ;
/*50*/  t.verify( end , NULL ) ;
    }
    {
        CRegExpr          re( "abc(ab*c)+" ) ;
/*51*/  t.verify( re.good() , true ) ;
        char const*         s = "abcabbbcabbbd" ;
        char const*         end = NULL ;
/*52*/  t.verify( re.match( s , &end ) , 0 ) ;
/*53*/  t.verify( end , s + 8 ) ;
    }
}

void
testSources(  )          // SouRCes
{
    TestRegExpr         t ;
    {
        std::istringstream    src( "a+b/" ) ;
        CRegExpr          re( src , '/' ) ;
        t.verify( re.good() , true ) ;
        char const*         s = "aab/" ;
        char const*         end = NULL ;
        t.verify( re.match( s , &end ) , 0 ) ;
        t.verify( end , s + 3 ) ;
    }
    {
        CRegExpr          re( std::string( "a+b" ) ) ;
        t.verify( re.good() , true ) ;
        char const*         s = "aab/" ;
        char const*         end = NULL ;
        t.verify( re.match( s , &end ) , 0 ) ;
        t.verify( end , s + 3 ) ;
    }
    {
        CRegExpr          re1( "a+b" ) ;
        CRegExpr          re( re1 ) ;
        t.verify( re.good() , true ) ;
        char const*         s = "aab/" ;
        char const*         end = NULL ;
        t.verify( re.match( s , &end ) , 0 ) ;
        t.verify( end , s + 3 ) ;
    }
    {
        CRegExpr          re1( "a+b" ) ;
        CRegExpr          re ;
        t.verify( re.good() , false ) ;
        re = re1 ;
        t.verify( re.good() , true ) ;
        char const*         s = "aab/" ;
        char const*         end = NULL ;
        t.verify( re.match( s , &end ) , 0 ) ;
        t.verify( end , s + 3 ) ;
    }
    {
        CRegExpr          re( "/" ) ;
        std::string const
                            s( "/" ) ;
        std::pair< int , std::string::const_iterator > r
            = re.match( s.begin() , s.end() ) ;
        t.verify( r.first , 0 ) ;
        t.verify( r.second , s.begin() + 1 ) ;
    }
    {
        CRegExpr          re( "a+b" ) ;
        std::string      s( "aabc" ) ;
        std::pair< int , std::string::const_iterator > r
            = re.match( s.begin() , s.end() ) ;
        t.verify( r.first , 0 ) ;
        t.verify( r.second , s.begin() + 3 ) ;
        s = "bc" ;
        r = re.match( s.begin() , s.end() ) ;
        t.verify( r.first , -1 ) ;
    }
    {
        CRegExpr          re( "abc(ab*c)+" ) ;
        t.verify( re.good() , true ) ;
        std::string const
                            s( "abcabbbcabbbd" ) ;
        std::pair< int , std::string::const_iterator > r
            = re.match( s.begin() , s.end() ) ;
        t.verify( r.first , 0 ) ;
        t.verify( r.second , s.begin() + 8 ) ;
    }
    {
        CRegExpr          re( "[1-9][0-9]*" , 10 ) ;
        re |= CRegExpr( "0[0-7]*" , 8 ) ;
        re |= CRegExpr( "0[Xx][:xdigit:]+" , 16 ) ;
        std::string const
                            s1( "15x" ) ;
        std::pair< int , std::string::const_iterator > r
            = re.match( s1.begin() , s1.end() ) ;
        t.verify( r.first , 10 ) ;
        t.verify( r.second , s1.begin() + 2 ) ;
        std::string const
                            s2( "0x15x" ) ;
        r = re.match( s2.begin() , s2.end() ) ;
        t.verify( r.first , 16 ) ;
        t.verify( r.second , s2.begin() + 4 ) ;
    }
}


static void PrintAll()
{
    testSimple();
    testSources();
    testMerge();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\sendchunks.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    sendchunks.cpp

Abstract:
    Implementing class CSendChunks (sendchunks.h)

Author:
    Gil Shafriri (gilsh) 28-Feb-00

--*/

#include <libpch.h>
#include "sendchunks.h"

#include "sendchunks.tmh"

CSendChunks::CSendChunks(
						const WSABUF* Buffers,
						DWORD nBuffers
						):					
						m_Buffers(Buffers),
						m_nBuffers(nBuffers),
						m_CurrentBuffer(0),
						m_offset(0)
{

}



void CSendChunks::GetNextChunk(DWORD len, const void** ppBuffer,DWORD* pLen)
/*++

Routine Description:
    Get next chunk to send from user buffer 
  
Arguments:
	IN -  len - rthe requested chunk size
	OUT - ppBuffer - receive pointer to next chunk.
	OUT - pLen - the size of the chunk in *ppBuffer.

Returned Value:
None

--*/


{
	ASSERT(ppBuffer != NULL);
	ASSERT(pLen != NULL);
	ASSERT(len != 0);

	*ppBuffer = NULL;
	*pLen = NULL;
		
	const WSABUF* pBuffer =  &m_Buffers[m_CurrentBuffer];

	if(m_offset == pBuffer->len)
	{
		bool fSucess = MoveNext();
		if(!fSucess)
		{
			return;
		}
		GetNextChunk(len,ppBuffer,pLen);
		return ;
	}

	*pLen =  min(pBuffer->len - m_offset ,len);
	*ppBuffer =  pBuffer->buf + m_offset;
  	m_offset += *pLen;

	return;
		
}


bool CSendChunks::MoveNext(void)
{
	ASSERT(m_CurrentBuffer < m_nBuffers);
	if(m_CurrentBuffer == m_nBuffers -1 )
	{
		return false;
	}
	m_offset = 0;
	++m_CurrentBuffer;
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\rex\lib\inc\setofchr.h ===
/****************************************************************************/
/*  File:       setofchr.h                                                 */
/*  Author:     J. Kanze                                                    */
/*  Date:       04/03/91                                                    */
/* ------------------------------------------------------------------------ */
/*  Modified:   14/04/92    J. Kanze                                        */
/*      Converted to CCITT naming conventions.                              */
/*  Modified:   13/06/2000  J. Kanze                                        */
/*      Ported to current library conventions, iterators.  (This is         */
/*      actually a complete rewrite.)                                       */
/* ------------------------------------------------------------------------ */
//      CRexSetOfChar:
//      =============
//
//      Strictly speaking, this should be called REX_SetOfUnsignedChar,
//      since it implements a set over 0...UCHAR_MAX.  In fact, it is
//      designed to take either char or unsigned char as an argument;
//      a char is interpreted by converting it to an unsigned char.
//      The possible characters depends on the locale, but typically
//      will be ISO 8859-n or something similar.
//
//      This file also contains a second class, CRexCharClass.  Except
//      for the possible constructors (and the associated potential
//      error conditions), this class behaves like a CRexSetOfChar.
//
//      TODO:
//        - The actual metacharacters should be somehow configurable.
//        - The current implementation uses the locale functionality
//          of C.  This should be changed to the C++ locale's as soon
//          as they become widely available.  Which, of course, means
//          something else to configure -- some thought must be given
//          to configuration issues.  (Maybe the metacharacters should
//          be a special facet of the locale, which would be an
//          optional argument to the constructor.)
//        - We should probably have our own exception, derived from
//          invalid_argument, rather than invalid_argument itself.
//
//      The original implementation used CBitVector.  This has been
//      replaced with a direct implementation: on one hand, we wanted
//      to remove all dependencies on the GB container classes, and on
//      the other, std::bitset seems pretty useless in its current
//      form.
// ---------------------------------------------------------------------------

#ifndef REX_SETOFCHR_HH
#define REX_SETOFCHR_HH

#include <inc/global.h>
#include <inc/bitvect.h>
#include <limits.h>

class CRexSetOfChar_Iterator ;

class CRexSetOfChar : public CBitVector< UCHAR_MAX + 1 >
{
    typedef CBitVector< UCHAR_MAX + 1 >
                        super ;

public :
    //      STL iterator...
    typedef CBitVIterator< CRexSetOfChar >
                        iterator ;

    //      Special value...
    enum Except { except } ;

    //      Constructors, destructor and assignment:
    //      ----------------------------------------
    //
    //      In addition to copy construction and assignment, the
    //      following constructors are supported:
    //
    //      default:    Constructs an empty set.
    //
    //      char or unsigned char:
    //                  Constructs a set with the single char.
    //
    //      std::string:
    //                  Constructs a set with all of the characters
    //                  present in the string.
    //
    //      The second and third constructors may be preceded with an
    //      argument "except".  In this case, the set constructed will
    //      be the complement of that constructed without this
    //      argument.
    //
    //      The compiler generated default copy constructor,
    //      assignment operator and destructor are used.
    // ----------------------------------------------------------------------
                        CRexSetOfChar() ;
    explicit            CRexSetOfChar( char element ) ;
    explicit            CRexSetOfChar( unsigned char element ) ;
    explicit            CRexSetOfChar( int element ) ;
                        CRexSetOfChar( Except , char element ) ;
                        CRexSetOfChar( Except , unsigned char element ) ;
                        CRexSetOfChar( Except , int element ) ;
    explicit            CRexSetOfChar( std::string const& elements ) ;
                        CRexSetOfChar( Except ,
                                      std::string const& elements ) ;

    //      Predicates:
    //      ===========
    //
    //      In addition, we inherit isEmpty from the base class.
    // --------------------------------------------------------------------
    bool                contains( char element ) const ;
    bool                contains( unsigned char element ) const ;
    bool                contains( int element ) const ;

    //      find:
    //      =====
    //
    //      Find the first member of this set, starting from the given
    //      character (inclusive).  The ordering of the characters is
    //      that of the native collating sequence.
    //
    //      The result is an int in the range [0...UCHAR_MAX], or EOF
    //      (from <stdio.h>) if no further characters.  (Exactly like
    //      getc() in <stdio.h>.)
    //
    //      The last version is uniquely for use in the iterators.
    // ----------------------------------------------------------------------
    int                 find( char from ) const ;
    int                 find( unsigned char from = 0 ) const ;
    int                 find( int from ) const ;

    BitIndex            find( bool target , BitIndex from ) const ;

    //      Relationships:
    //      ==============
    //
    //      We inherit the entire set of relationships (isEqual,
    //      isNotEqual, isSubsetOf, isStrictSubsetOf, isSupersetOf,
    //      isStrictSubsetOf) as well as the count function from the
    //      base class.
    // ----------------------------------------------------------------------

    //      Global manipulations:
    //      =====================
    //
    //      Empty the set, or take the complement of the complete set.
    // ----------------------------------------------------------------------
    void                clear() ;
    void                complement() ;

    //      Character manipulations:
    //      ========================
    //
    //      Of a single character, add the character to the set (set),
    //      remove it from the set (reset), or change its status with
    //      regards to membership in the set (complement).
    //
    //      With a string as argument, apply the operation for all
    //      characters in the string.
    // ----------------------------------------------------------------------
    void                set( char element ) ;
    void                set( unsigned char element ) ;
    void                set( int element ) ;
    void                set( std::string const& elements ) ;
    void                reset( char element ) ;
    void                reset( unsigned char element ) ;
    void                reset( int element ) ;
    void                reset( std::string const& elements ) ;
    void                complement( char element ) ;
    void                complement( unsigned char element ) ;
    void                complement( int element ) ;
    void                complement( std::string const& elements ) ;

    //      Manipulations with an other set:
    //      ================================
    //
    //      The first four apply the corresponding character
    //      manipulation on this set for each member of the other
    //      set.  These map to the classical operations (and, or, xor)
    //      as follows:
    //
    //          and     intersect
    //          or      set
    //          xor     complement
    //
    //      Support for the more conventional names (and, or, xor,
    //      union) creates conflicts with keywords.  (The support for
    //      and, or and xor was removed in the 2000 rewrite, because
    //      of the compiler errors which it caused.)
    // ----------------------------------------------------------------------
    void                set( CRexSetOfChar const& other ) ;
    void                reset( CRexSetOfChar const& other ) ;
    void                complement( CRexSetOfChar const& other ) ;
    void                intersect( CRexSetOfChar const& elements ) ;

    //      Operators:
    //      ==========
    //
    //      Only the op= forms are provided as member functions.  The
    //      binary operators are non-members defined outside of the
    //      class definition.
    //
    //      The basic operators between sets: union (or, '|'),
    //      intersection (and, '&') and ?  (xor, '^').
    // ----------------------------------------------------------------------
    CRexSetOfChar&       operator|=( CRexSetOfChar const& other ) ;
    CRexSetOfChar&       operator&=( CRexSetOfChar const& other ) ;
    CRexSetOfChar&       operator^=( CRexSetOfChar const& other ) ;

    //      +, - and *:
    //      ===========
    //
    //      The same as above, '+' is '|' and '*' is '&'.  The
    //      operator is less intuitive, but the precedence is correct.
    //
    //      In addition, there is the '-' operator, which *removes*
    //      members from this set.  (Logically, it is the same as A &~
    //      B.)
    //
    //      '+' and '-' are also available for individual characters,
    //      to add or remove a member from the set.
    // ----------------------------------------------------------------------
    CRexSetOfChar&       operator+=( CRexSetOfChar const& other ) ;
    CRexSetOfChar&       operator+=( char other ) ;
    CRexSetOfChar&       operator+=( unsigned char other ) ;
    CRexSetOfChar&       operator+=( int other ) ;
    CRexSetOfChar&       operator-=( CRexSetOfChar const& other ) ;
    CRexSetOfChar&       operator-=( char other ) ;
    CRexSetOfChar&       operator-=( unsigned char other ) ;
    CRexSetOfChar&       operator-=( int other ) ;
    CRexSetOfChar&       operator*=( CRexSetOfChar const& other ) ;

    //      STL iterators:
    //      --------------
    //
    //      There is only a forward iterator; its operator* returns
    //      an element in the set, in order.
    // -----------------------------------------------------------------------
    iterator            begin() const ;
    iterator            end() const ;

    //      'Helper' functions:
    //      ===================
    //
    //      hashCode and compare are provided by the base class.
    // ----------------------------------------------------------------------
    std::string         asString() const ;

private :
    void                initialize( std::string const& str ) ;
} ;

// ==========================================================================
//      Unary operators:
//
//      Complement is supported in two forms, the "correct" ~ and a -
//      operator which passes to the +, - and * operators.
// --------------------------------------------------------------------------
CRexSetOfChar        operator~( CRexSetOfChar const& other ) ;
CRexSetOfChar        operator-( CRexSetOfChar const& other ) ;

// ==========================================================================
//      Binary operators:
//      =================
//
//      All of the operators supported in the op= format are also
//      supported as binary op's.
// --------------------------------------------------------------------------

CRexSetOfChar        operator&( CRexSetOfChar const& lhs ,
                               CRexSetOfChar const& rhs ) ;
CRexSetOfChar        operator|( CRexSetOfChar const& lhs ,
                               CRexSetOfChar const& rhs ) ;
CRexSetOfChar        operator^( CRexSetOfChar const& lhs ,
                               CRexSetOfChar const& rhs ) ;
CRexSetOfChar        operator+( CRexSetOfChar const& lsh ,
                               CRexSetOfChar const& rhs ) ;
CRexSetOfChar        operator+( CRexSetOfChar const& lsh , unsigned char rhs ) ;
CRexSetOfChar        operator+( CRexSetOfChar const& lsh , char rhs ) ;
CRexSetOfChar        operator-( CRexSetOfChar const& lsh ,
                               CRexSetOfChar const& rhs ) ;
CRexSetOfChar        operator-( CRexSetOfChar const& lsh , unsigned char rhs ) ;
CRexSetOfChar        operator-( CRexSetOfChar const& lsh , char rhs ) ;
CRexSetOfChar        operator*( CRexSetOfChar const& lsh ,
                               CRexSetOfChar const& rhs ) ;

// ==========================================================================
//      Comparison:
//      ===========
//
//      The ordering relationship is based on containment (subsets).
//      A <= B means A is a subset of B.  Likewise, < means proper
//      subset, >= superset, > proper superset.  (Note that this does
//      not define a complete ordering.  It is possible that A<=B and
//      B<=A both be false.)
// --------------------------------------------------------------------------
bool                operator==( CRexSetOfChar const& op1 ,
                                CRexSetOfChar const& op2 ) ;
bool                operator!=( CRexSetOfChar const& op1 ,
                                CRexSetOfChar const& op2 ) ;
bool                operator>( CRexSetOfChar const& op1 ,
                               CRexSetOfChar const& op2 ) ;
bool                operator>=( CRexSetOfChar const& op1 ,
                                CRexSetOfChar const& op2 ) ;
bool                operator<( CRexSetOfChar const& op1 ,
                               CRexSetOfChar const& op2 ) ;
bool                operator<=( CRexSetOfChar const& op1 ,
                                CRexSetOfChar const& op2 ) ;

// ==========================================================================
//      CRexCharClass:
//      =============
//
//      This class implements a CRexSetOfChar which is (or can be)
//      initialized by a character class specifier.
//
//      A character class specifier is parsed as follows:
//
//      If the first character is a '[', then a character class is
//      parsed.  A character class consists of all of the characters
//      between '[' and the next following ']'.  In addition, a range
//      of characters may be specified by a-b; 'a' and 'b' must be
//      either both numeric, both capital letters, or both small
//      letters, as determined by the functions 'isdigit', 'isupper'
//      and 'islower' in ctype.  (Note that this implies that locale
//      is taken into consideration.)  The collating order of ISO
//      8859-1 code is supposed.  Thus, [a-] is the same as
//      [a-z], and includes *all* non-accented small letters.
//      (Note that in the default "C" locale, the above character
//      class is illegal, since  is *not* a small letter in this
//      locale.)  If the first character of the character class is a
//      '^', then the resulting set is the complement of the character
//      class specified by the remaining characters.  Also, the
//      following locale dependant category specifiers may be given:
//          ":alnum:"   isalnum
//          ":alpha:"   isalpha
//          ":blank:"   either ' ' or '\t'
//          ":cntrl:"   iscntrl
//          ":digit:"   isdigit
//          ":graph:"   isgraph
//          ":lower:"   islower
//          ":print:"   isprint
//          ":punct:"   ispunct
//          ":space:"   isspace
//          ":upper:"   isupper
//          ":xdigit:"  isxdigit
//      With the exception of :blank:, the designated function in
//      <ctype.h> is invoked.
//
//      The character ']' must be either the first character in the
//      character class, or escaped with '\'.  The '^' must be either
//      the only character, or may not be the first character, or must
//      be escaped with '\'.  The character '-' must be either the
//      first character, the last, or escaped with '\'.  A ':' must be
//      escaped with '\'.  The usual escape sequences (as defined
//      below) will be recognized within a character class.
//
//      If the first character seen is a '\', then an escape sequence
//      is parsed.  All of the standard sequences defined in ISO C
//      (and in C++), with the exception of '\u', will be recognized.
//      A '\' followed by any non-alphanumeric character is that
//      character.  The set will contain exactly one member.
//
//      If the first character seen is a '.', then that character is
//      parsed, and the generated set contains *all* characters except
//      '\n'.
//
//      If the first character is none of the above, the single
//      character is parsed.  The set will contain just that
//      character.
//
//      Note that using a CRexIteratorIstream with the last constructor
//      allows parsing a character class from any source which
//      supports the STL interface: string, vector, ...
// --------------------------------------------------------------------------

class CRexCharClass : public CRexSetOfChar
{
public :
    //      Status:
    //      =======
    //
    //      This enum defines the possible result states for the
    //      constructor from a character class/escape sequence
    //      definition (see constructors, below).  At present, this
    //      state is a characteristic of the CRexCharClass, which can
    //      be tested at any time after construction, and *should* be
    //      tested immediately after any constructor which uses a
    //      character class.
    // ----------------------------------------------------------------------
    enum Status
    {
        ok ,
        extraCharacters ,           //  Extra characters at end of string.
        illegalEscapeSequence ,     //  \a, a is alpha, and no corresponding
                                    //      escape sequence is defined.
        overflowInEscapeSequence ,  //  conversion of \[0-7]... or \x...
                                    //      overflowed.
        missingHexDigits ,          //  no hex digits after \x.
        illegalRangeSpecifier ,     //  a-b, a and b are not both digits,
                                    //      both capitals, or both small
                                    //      letters.
        unexpectedEndOfFile ,       //  No ']' was found for a char. class,
                                    //      or nothing following a \.
        unknownCharClassSpec ,      //  Unknown char. class specifier.
        emptySequence               //  No characters (empty string, EOF)
    } ;

    //      Constructors, destructor and assignment:
    //      ========================================
    //
    //      There is no default constructor.  The following
    //      constructors are provided:
    //
    //      istream:            Parses the given string to initialize
    //                          the set of characters.  After parsing,
    //                          all of the characters which are part
    //                          of the specification will have been
    //                          extracted.  If an error has occured,
    //                          ios::failbit will be set.
    //
    //      char const*:        Parses the given string to initialize
    //                          the set of characters.  It is an error
    //                          condition for the string to contain
    //                          any characters beyond the end of the
    //                          character class specifier.
    //
    //      If there is no error in parsing the character class/escape
    //      sequence, the status of the CRexSetOfChar is set to ok, the
    //      pointer is advanced to the first character not used to
    //      determine the class/escape sequence, and the set contains
    //      the characters determined by the character class/escape
    //      sequence.  If an error occurs when attempting to parse the
    //      character class/escape sequence, the status of the
    //      CRexSetOfChar is set to the corresponding error code, the
    //      set is empty; if the constructor took an istream, the last
    //      character extracted corresponds to the character where the
    //      error was detected.
    //
    //      Copy and assignment are supported.  (In this case, by the
    //      default versions generated by the compiler.)
    // ----------------------------------------------------------------------
    explicit            CRexCharClass( std::istream& source ) ;
    explicit            CRexCharClass( char const* ptr ) ;
    explicit            CRexCharClass( std::string const& src ) ;

    //      status:
    //      =======
    //
    //      The following routines return information concerning the
    //      status of the CRexCharClass.
    //
    //      There are two routines to read the status.  The first
    //      (good) simply returns true if the status is ok, false
    //      otherwise.  The second, (errorCode) returns the status
    //      itself.
    // ----------------------------------------------------------------------
    bool                good() const ;
    Status              errorCode() const ;

    //      errorMsg:
    //      =========
    //
    //      Return error code (Status) as readable string.
    // ----------------------------------------------------------------------
    std::string        errorMsg() const ;
    static std::string errorMsg( Status errorCode ) ;

private :
    Status              status ;

    void                parse( std::istream& src ) ;
    void                setNumericEscape( std::string const& chrs ,
                                          int base ) ;
    void                escapedChar( std::istream& source ) ;
    void                setExplicitRange( std::string const& rangeName ) ;
    void                setRange( unsigned char first , unsigned char last ) ;
    void                parseCharClass( std::istream& source ) ;
} ;

#include <inc/setofchr.inl>
#endif
//  Local Variables:    --- for emacs
//  mode: c++           --- for emacs
//  tab-width: 8        --- for emacs
//  End:                --- for emacs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\stinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stInit.cpp

Abstract:
    Socket Transport initialization

Author:
    Gil Shafriri (gilsh) 05-Jun-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <autosec.h>
#include "stssl.h"
#include "stsimple.h"
#include "st.h"
#include "stp.h"
#include "stpgm.h"

#include "stinit.tmh"


VOID
StInitialize(DWORD LocalInterfaceIP)
/*++

Routine Description:
    Initializes Socket Transport library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    ASSERT(!StpIsInitialized());
	StpRegisterComponent();
	StpCreateCredentials();

	CWinsockSSl::InitClass();
	CSimpleWinsock::InitClass();
	CPgmWinsockConnection::InitClass(LocalInterfaceIP);

    StpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\socketconfactory.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    socketconfactory.h

Abstract:
    Header for class CSocketConnectionFactory responsible to connect(asynchronously) a socket handle
	to a  tcp destination address. The class gets socket handle and multiple destinations
	and tries  to connect to the destinations untill the first success or faliure connecting to all
	of them.


Author:
    Gil Shafriri (gilsh) 3-Jul-2001

--*/


#ifndef _MSMQ_SOCKETFACTORY_H
#define _MSMQ_SOCKETFACTORY_H

#include <ex.h>

class CSocketConnectionFactory : private EXOVERLAPPED
{
public:
	CSocketConnectionFactory();

	
	void 
	Create(
		const std::vector<SOCKADDR_IN>& AddrList, 
		EXOVERLAPPED* pOverlapped, 
		SOCKADDR_IN* pConnectedAddr,
		SOCKET socket
		);


private:
	static void WINAPI OnConnectionsSucceeded(EXOVERLAPPED* pOvl);
	static void WINAPI OnConnectionFailed(EXOVERLAPPED* pOvl);
	void Connect();
	void BackToCaller(LONG status);
	

private:
	SOCKET m_socket;
	std::vector<SOCKADDR_IN> m_AddrList;
	SOCKADDR_IN* m_pConnectedAddr;
	EXOVERLAPPED* m_pCallerOvl;
	size_t m_AdressIndex;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\sendchunks.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    sendchunks.h

Abstract:
    Header file for class CSendChunks responsibile to cut given buffers to chunks
	limited to a given size. The class it used to encrypte user data chunk by 
	chunk.

Author:
    Gil Shafriri (gilsh) 28-Feb-00

--*/

class CSendChunks 
{
public:
	  CSendChunks(const WSABUF* Buffers, DWORD nBuffers);


public:
		void GetNextChunk(DWORD len, const void** ppBuffer,DWORD* pLen);

private:
		bool MoveNext(void);

private:
		const   WSABUF* m_Buffers;
		DWORD	m_nBuffers;
		DWORD	m_CurrentBuffer;
		DWORD	m_offset;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\socketconfactory.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    socketconfactory.cpp

Abstract:
    Implementing  CSocketConnectionFactory (socketconfactory.h)


Author:
    Gil Shafriri (gilsh) 3-Jul-2001

--*/

#include <libpch.h>
#include <no.h>
#include "socketconfactory.h"

CSocketConnectionFactory::CSocketConnectionFactory(
												void
												):
												EXOVERLAPPED(OnConnectionsSucceeded, OnConnectionFailed),
												m_pCallerOvl(NULL),
												m_AdressIndex(0),
												m_pConnectedAddr(NULL),
												m_socket(INVALID_SOCKET)
			
{

}



void CSocketConnectionFactory::Create(
		const std::vector<SOCKADDR_IN>& AddrList, 
		EXOVERLAPPED* pOverlapped, 
		SOCKADDR_IN* pConnectedAddr,
		SOCKET socket
		)
/*++

Routine Description:
    The function tries to connect asynchronously  to tcp addresses from given list one by one. 
	After first success the operation is completed and the address the connection was established on
	is returned in the pConnectedAddr parameter.
	   
Arguments:
	AddrList - List of adderess to try to connect to.
	pOverlapped - Caller overlapp.
	pConnectedAddr - On success Receives the address the connection was established on.
   

Returned Value:
None

Note:
	The function tries to connect asynchronously  to tcp addresses from list one by one. 
	After first success the operation is completed and the address the connection was established on
	is returned.
	
--*/
{
	ASSERT(m_AddrList.size() == 0);
	ASSERT(m_pCallerOvl == NULL);
	ASSERT(m_socket == INVALID_SOCKET);
	ASSERT(m_pConnectedAddr == NULL);

	m_pConnectedAddr = pConnectedAddr;
	m_AddrList = AddrList;
	m_pCallerOvl = pOverlapped;
	m_socket = socket;

	Connect();
}


void CSocketConnectionFactory::BackToCaller(LONG status)
{
	m_pCallerOvl->SetStatus(status);
	EXOVERLAPPED* pOvl = m_pCallerOvl;
	m_pCallerOvl = NULL;
	m_pConnectedAddr = NULL;
	m_socket = INVALID_SOCKET;
	m_AddrList.resize(0);
	ExPostRequest(pOvl);
}


void WINAPI CSocketConnectionFactory::OnConnectionsSucceeded(EXOVERLAPPED* pOvl)
{
	CSocketConnectionFactory* Me = static_cast<CSocketConnectionFactory*>(pOvl);

	if(Me->m_pConnectedAddr != NULL)
	{
		*(Me->m_pConnectedAddr) = Me->m_AddrList[Me->m_AdressIndex - 1];
	}

	Me->BackToCaller(STATUS_SUCCESS);
}



void WINAPI CSocketConnectionFactory::OnConnectionFailed(EXOVERLAPPED* pOvl)
{
	CSocketConnectionFactory* Me = static_cast<CSocketConnectionFactory*>(pOvl);
	Me->Connect();
}


void CSocketConnectionFactory::Connect()
{
	m_AdressIndex++;
	if(m_AddrList.size() < m_AdressIndex)
	{
		BackToCaller(STATUS_UNSUCCESSFUL);
		return;
	}

	try
	{
		NoConnect(m_socket, m_AddrList[m_AdressIndex - 1] , this);
	}
	catch(exception&)
	{
		SetStatus(STATUS_UNSUCCESSFUL);
		ExPostRequest(this);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\st.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    st.cpp

Abstract:
    Socket Transport public interface

Author:
    Gil Shafriri (gilsh) 05-Jun-00

--*/

#include <libpch.h>
#include "stp.h"
#include "st.h"
#include "stsimple.h"
#include "stssl.h"
#include "StPgm.h"

#include "st.tmh"

ISocketTransport* StCreatePgmWinsockTransport()
{
    return new CPgmWinsock();

} // StCreatePgmWinsockTransport


ISocketTransport* StCreateSimpleWinsockTransport()
/*++

Routine Description:
    Create new simple winsock transport
  
Arguments:

  
Returned Value:
	Socket transport interface.
	caller has to delete the returned pointer.

--*/
{
	return new 	CSimpleWinsock();
}


R<IConnection> StCreateSimpleWisockConnection(SOCKET s)
{
	return new CWinsockConnection(s);
}


ISocketTransport* StCreateSslWinsockTransport(const xwcs_t& ServerName,USHORT ServerPort,bool fProxy)
/*++

Routine Description:
    Create new ssl winsock transport
  
Arguments:
	ServerName - Server name to authenticate (destination server name).
	ServerPort - Port of the destination (used only if 	fProxy==true)
	fProxy - Indicating if we are connecting via proxy or not
  
Returned Value:
	Socket transport interface.
	Caller has to delete the returned pointer.

--*/

{
	return new 	CWinsockSSl(StpGetCredentials(), ServerName, ServerPort, fProxy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\stdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stDebug.cpp

Abstract:
    Socket Transport debugging

Author:
    Gil Shafriri (gilsh) 05-Jun-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "st.h"
#include "stp.h"

#include "stdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Socket Transport state
//
void StpAssertValid(void)
{
    //
    // stInitalize() has *not* been called. You should initialize the
    // Socket Transport library before using any of its funcionality.
    //
    ASSERT(StpIsInitialized());

    //
    // TODO:Add more Socket Transport validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void StpSetInitialized(void)
{
    LONG fstAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Socket Transport library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fstAlreadyInitialized);
}


BOOL StpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
void StpRegisterComponent(void)
{
}




#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\stp.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stp.cpp

Abstract:
    Socket Transport private functions implementation

Author:
    Gil Shafriri (gilsh) 05-Jun-00

--*/

#include <libpch.h>
#include <no.h>
#include "stp.h"
#include "stsimple.h"
#include "stssl.h"

#include "stp.tmh"

static CSSPISecurityContext s_SSPISecurityContext;


void  StpSendData(const R<IConnection>& con ,const void* pData, size_t cbData,EXOVERLAPPED* pov)
/*++

Routine Description:
    Send data to destination.
  
Arguments:
	Socket - Connected socket.
	pData - Pointer to data
	cbData - data size
	pov - overlapp to call when finish.

  
Returned Value:
	None

--*/
{
	WSABUF buffer;
		
	buffer.buf = (char*)(pData);
	buffer.len = numeric_cast<DWORD>(cbData);
 
	con->Send(&buffer, 1, pov);
}


CredHandle* StpGetCredentials()
{
	ASSERT(s_SSPISecurityContext.IsValid());
	return s_SSPISecurityContext.getptr();
}


void  StpPostComplete(EXOVERLAPPED** ppOvl,HRESULT hr)
/*++

Routine Description:
    Complete ayncrounos call and zeroing in the given overlapp
  
Arguments:
	IN/OUT ppOvl - poinetr to overlapp to signal.
	IN - status return code
    
Returned Value:
	None 
--*/
{
	EXOVERLAPPED* pTmpOvl = *ppOvl;
	*ppOvl = NULL;
	pTmpOvl->SetStatus(hr);
	ExPostRequest(pTmpOvl);
}


void StpCreateCredentials()
/*++

Routine Description:
    Create credential handle.
  
Arguments:
    None.
    
Returned Value:
    Create handle (exception is thrown if on error)

--*/
{
	CCertOpenStore hMyCertStore = CertOpenStore(
											CERT_STORE_PROV_SYSTEM,
											X509_ASN_ENCODING,
											0,
											CERT_STORE_OPEN_EXISTING_FLAG | CERT_SYSTEM_STORE_SERVICES,
											L"MSMQ\\MY"
											);

	if(hMyCertStore == NULL)
    {
		TrERROR(NETWORKING,"Could not open MSMQ Certificate Stote,Error=%x",GetLastError());
		throw exception();		   
    }

	SCHANNEL_CRED   SchannelCred;
	ZeroMemory(&SchannelCred, sizeof(SchannelCred));
	SchannelCred.dwVersion  = SCHANNEL_CRED_VERSION;
	SchannelCred.cCreds     = 1;
    SchannelCred.grbitEnabledProtocols = SP_PROT_SSL3;
    SchannelCred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;
    SchannelCred.dwFlags |= SCH_CRED_MANUAL_CRED_VALIDATION;


	CCertificateContext pCertContext = CertFindCertificateInStore(
															hMyCertStore, 
															0, 
															0,
															CERT_FIND_ANY,
															NULL,
															NULL
													        );

	//
	// If MSMQ service has certificate in it's service store - use it to get client credential
	//
	if(pCertContext == NULL)
	{
		TrWARNING(NETWORKING,"Could not find certificate in MSMQ store, Error=%x" ,GetLastError());
        SchannelCred.paCred = NULL;
 	}
	else
	{
		SchannelCred.paCred  =  &pCertContext;
	}
 
    //
    // Create an SSPI credential.
    //
	CredHandle      phCreds;
	TimeStamp       tsExpiry;

    SECURITY_STATUS Status = AcquireCredentialsHandle(
										NULL,                   // Name of principal    
										UNISP_NAME_W,           // Name of package
										SECPKG_CRED_OUTBOUND,   // Flags indicating use
										NULL,                   // Pointer to logon ID
										&SchannelCred,          // Package specific data
										NULL,                   // Pointer to GetKey() func
										NULL,                   // Value to pass to GetKey()
										&phCreds,                // (out) Cred Handle
										&tsExpiry	            // (out) Lifetime (optional)
										);             

	
    if(Status != SEC_E_OK)
    {
		//
		// Somthing is wrong with the client certificate - use empty client credential
		//
		SchannelCred.paCred = NULL;
		Status = AcquireCredentialsHandle(
										NULL,                   // Name of principal    
										UNISP_NAME_W,           // Name of package
										SECPKG_CRED_OUTBOUND,   // Flags indicating use
										NULL,                   // Pointer to logon ID
										&SchannelCred,          // Package specific data
										NULL,                   // Pointer to GetKey() func
										NULL,                   // Value to pass to GetKey()
										&phCreds,                // (out) Cred Handle
										&tsExpiry	            // (out) Lifetime (optional)
										);             

		if(Status != SEC_E_OK)
		{
			TrERROR(NETWORKING,"Failed to acquire credential  handle, Error=%x ",Status);
			throw exception();		 
		}
    }
 	s_SSPISecurityContext = phCreds;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\stp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stp.h

Abstract:
    Socket Transport private functions.

Author:
    Gil Shafriri (gilsh) 05-Jun-00

--*/

#pragma once

#ifndef _MSMQ_stp_H_
#define _MSMQ_stp_H_

#define SECURITY_WIN32
#include <security.h>
#include <sspi.h>
#include <schannel.h>
#include <ex.h>

class  CSSPISecurityContext;
extern CSSPISecurityContext g_SSPISecurityContext;

inline DWORD DataTransferLength(EXOVERLAPPED& ov)
{
    //
    // In win64, InternalHigh is 64 bits. Since the max chunk of data
    // we transfer in one operation is always less than MAX_UNIT we can cast
    // it to DWORD safetly
    //
    ASSERT(0xFFFFFFFF >= ov.InternalHigh);
	return numeric_cast<DWORD>(ov.InternalHigh);
}

void  StpSendData(const R<class IConnection>& con ,const void* pData, size_t cbData,EXOVERLAPPED* pov);
CredHandle* StpGetCredentials(void);
void  StpCreateCredentials(void);
void  StpPostComplete(EXOVERLAPPED** pov,HRESULT hr); 


//---------------------------------------------------------
//
//  class CAutoZeroPtr	- zero given pointer at destruction
//
//---------------------------------------------------------
template<class T>
class CAutoZeroPtr{
public:
    CAutoZeroPtr(T** pptr) : m_pptr(pptr) {}
   ~CAutoZeroPtr()
   { 
		if  (m_pptr) 
		{
			*m_pptr	= 0;
		}
   }
   T** detach()
   {
	   T** tmp = m_pptr; 
	   m_pptr = 0;
	   return tmp;
   }

private:
    CAutoZeroPtr(const CAutoZeroPtr&);
    CAutoZeroPtr& operator=(const CAutoZeroPtr&);

private:
    T** m_pptr;
};


#ifdef _DEBUG

void StpAssertValid(void);
void StpSetInitialized(void);
BOOL StpIsInitialized(void);
void StpRegisterComponent(void);

#else // _DEBUG

#define StpAssertValid() ((void)0)
#define StpSetInitialized() ((void)0)
#define StpIsInitialized() TRUE
#define StpRegisterComponent() ((void)0)

#endif // _DEBUG







#endif // _MSMQ_stp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\stpgm.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    StPgm.h

Abstract:

    Header for class CPgmWinsock that implements ISocketTransport interface
	for PGM protocol (multicast).

Author:

    Shai Kariv  (shaik)  27-Aug-00

--*/

#ifndef __ST_PGM_H
#define __ST_PGM_H

#include <ex.h>
#include "socketconfactory.h"
#include "st.h"
#include "rwlock.h"

class CPgmWinsockConnection : public IConnection
{
public:
	virtual 
	void 
	ReceivePartialBuffer(
        VOID* pBuffer,                                     
        DWORD Size, 
        EXOVERLAPPED* pov
        );


 	virtual 
	void 
	Send(
		const WSABUF* Buffers,                                     
		DWORD nBuffers, 
		EXOVERLAPPED* pov
		);

	virtual void Close();

	static void InitClass(DWORD LocalInterfaceIP);

private:
	CPgmWinsockConnection();

	void 
	Init(
	const std::vector<SOCKADDR_IN>& AddrList, 
	EXOVERLAPPED* pOverlapped,
	SOCKADDR_IN* pAddr = NULL
	);


	void Connect();

	bool IsClosed() const
	{
		return 	m_socket == INVALID_SOCKET;
	}

	void CheckLocalInterfaceIP();

	friend class CPgmWinsock;

private:
	mutable CReadWriteLock m_CloseConnection;
	CSocketConnectionFactory m_SocketConnectionFactory;
	CSocketHandle m_socket;
	static DWORD m_LocalInterfaceIP;
	static bool m_IsFirstSession;
};



class CPgmWinsock :public ISocketTransport
{
public:
	CPgmWinsock() {}
	

	virtual
	bool
	GetHostByName(
    LPCWSTR host,
	std::vector<SOCKADDR_IN>* pConnectedAddr,
	bool fUseCache	= true
    );
 
    virtual 
	void 
	CreateConnection(
			const std::vector<SOCKADDR_IN>& AddrList,	
			EXOVERLAPPED* pOverlapped,
			SOCKADDR_IN* pConnectedAddr = NULL
			);

	virtual R<IConnection> GetConnection(void);
 
	virtual bool IsPipelineSupported();

private:
	R<CPgmWinsockConnection> m_pPgmWinsockConnection;


private:
	CPgmWinsock(const CPgmWinsock&);
	CPgmWinsock& operator=(const CPgmWinsock&);
};


#endif // __ST_PGM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\stsimple.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stsimple.h

Abstract:
    Header for class CSimpleWinsock that implements ISocketTransport interface
	for non secure network protocol (simple winsock)

Author:
    Gil Shafriri (gilsh) 23-May-2000

--*/

#ifndef __ST_SIMPLE_H
#define __ST_SIMPLE_H
#include <ex.h>
#include <rwlock.h>
#include "st.h"
#include "socketconfactory.h"


class CWinsockConnection : public IConnection
{	
public:
	CWinsockConnection(SOCKET s) :
		m_socket(s)
	{
	}
	

	~CWinsockConnection(){};


	virtual 
	void 
	ReceivePartialBuffer(
					VOID* pBuffer,                                     
					DWORD Size, 
					EXOVERLAPPED* pov
					);


 	virtual 
	void 
	Send(
		const WSABUF* Buffers,                                     
		DWORD nBuffers, 
		EXOVERLAPPED* pov
		);


	virtual	void Close();


private:
	CWinsockConnection();

	void Init(
		const std::vector<SOCKADDR_IN>& AddrList,	
		EXOVERLAPPED* pOverlapped,
		SOCKADDR_IN* pConnectedAddr
		);

	bool IsClosed() const
	{
		return m_socket == INVALID_SOCKET;		
	}

	
	friend class CSimpleWinsock;


private:
	mutable CReadWriteLock m_CloseConnection;
	CSocketHandle m_socket;
	CSocketConnectionFactory m_SocketConnectionFactory;
};




class CSimpleWinsock :public ISocketTransport
{
public:
	CSimpleWinsock();
	~CSimpleWinsock();
 
	
public:

	virtual
	bool
	GetHostByName(
    LPCWSTR host,
	std::vector<SOCKADDR_IN>* pConnectedAddr,
	bool fUseCache	= true
    );


    virtual 
	void 
	CreateConnection(
	const std::vector<SOCKADDR_IN>& AddrList, 
	EXOVERLAPPED* pOverlapped, 
	SOCKADDR_IN* pConnectedAddr
	);

	virtual R<IConnection> GetConnection(void);

	virtual bool IsPipelineSupported();
	static void InitClass();

private:
	static bool m_fIsPipelineSupported;


private:
	R<CWinsockConnection> m_pWinsockConnection;

private:
	CSimpleWinsock(const CSimpleWinsock&);
	CSimpleWinsock& operator=(const CSimpleWinsock&);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\stssl.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stssl.h

Abstract:
    Header for class CWinsockSSl that implements ISocketTransport interface
	for secure  (using ssl).

Author:
    Gil Shafriri (gilsh) 23-May-2000

--*/

#ifndef __ST_SSL_H
#define __ST_SSL_H

#include "st.h"
#include "stsslng.h"
#include "stp.h"

class CWinsockSSl :public ISocketTransport
{
public:
	CWinsockSSl(
		CredHandle* pCred,
		const xwcs_t& ServerName,
		USHORT ServerPort,
		bool fProxy
		);

	~CWinsockSSl();
	
public:
	virtual
	bool
	GetHostByName(
    LPCWSTR host,
	std::vector<SOCKADDR_IN>* pConnectedAddr,
	bool fUseCache	= true
    );
     
    virtual	
	void 
	CreateConnection(
			const std::vector<SOCKADDR_IN>& AddrList,	
			EXOVERLAPPED* pov,
			SOCKADDR_IN* pConnectedAddr = NULL
			);


	virtual R<IConnection> GetConnection();
  
	virtual bool IsPipelineSupported();
	static void InitClass();

private:
	CSSlNegotioation      m_CSSlNegotioation;

private:
	static bool m_fIsPipelineSupported;
	

private:
	CWinsockSSl(const CWinsockSSl&);
	CWinsockSSl& operator=(const CWinsockSSl&);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\stsimple.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stsimple.h.cpp

Abstract:
    implementation of class CSimpleWinsock declared in (stsimple.h)
	It simply forward the functions calls to no library

Author:
    Gil Shafriri (gilsh) 23-May-2000

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <no.h>
#include <cm.h>
#include "stsimple.h"
#include "stp.h"
#include "stsimple.tmh"


CWinsockConnection::CWinsockConnection(
				void
				)
				:
				m_socket(NoCreateStreamConnection())
	
{
}



void 
CWinsockConnection::Init(
			const std::vector<SOCKADDR_IN>& AddrList,
			EXOVERLAPPED* pOverlapped,
			SOCKADDR_IN* pConnectedAddr
			)
{
	m_SocketConnectionFactory.Create(AddrList, pOverlapped,	pConnectedAddr, m_socket );
}



void CWinsockConnection::Close()
{
	CSW writelock(m_CloseConnection);
	m_socket.free();
}



void 
CWinsockConnection::Send(
				const WSABUF* Buffers,                                     
				DWORD nBuffers, 
				EXOVERLAPPED* pov
				)
{
    //
	// Addref to prevent deleting the object before releaseing the lock
	//
	R<CWinsockConnection> ar = SafeAddRef(this);

	CSR readlock(m_CloseConnection);
	if(IsClosed())
	{
		throw exception();
	}
	NoSend(m_socket, Buffers, nBuffers, pov);	
}



void 
CWinsockConnection::ReceivePartialBuffer(				                 
					VOID* pBuffer,                                     
					DWORD Size, 
					EXOVERLAPPED* pov
					)
{
    //
	// Addref to prevent deleting the object before releaseing the lock
	//
	R<CWinsockConnection> ar = SafeAddRef(this);

	CSR readlock(m_CloseConnection);
	if(IsClosed())
	{
		throw exception();
	}
 	NoReceivePartialBuffer(m_socket, pBuffer, Size, pov);
}



bool CSimpleWinsock::m_fIsPipelineSupported = true;


static bool IsSimpleSocketPipeLineSupported()
/*++

Routine Description:
   Return the pipe line mode of the http delivery according registry setting
   - default is  pipeline mode
  
Arguments:
	Socket - Connected socket.

  
Returned Value:
	None

--*/

{
	DWORD fHttpPipeLineSupport;

	CmQueryValue(
			RegEntry(NULL, L"HttpPipeLine", TRUE),  
			&fHttpPipeLineSupport
			);

	bool fRet = (fHttpPipeLineSupport == TRUE); 
	TrTRACE(NETWORKING,"http pipeline mode = %d", fRet);
	return fRet;
}

CSimpleWinsock::CSimpleWinsock()
{
}


CSimpleWinsock::~CSimpleWinsock()
{
}


void CSimpleWinsock::InitClass()
{
	m_fIsPipelineSupported	=  IsSimpleSocketPipeLineSupported();
}


void
CSimpleWinsock::CreateConnection(
					const std::vector<SOCKADDR_IN>& AddrList,
					EXOVERLAPPED* pOverlapped,
					SOCKADDR_IN* pConnectedAddr
					)
{	
	//
	// Note - we must do two phase constrcution of the connection object
	// becaue the connection can be completed before we assign the pointer
	// to m_pWinsockConnection and a call to GetConnection upon connection completion
	// will find null pointer in m_pWinsockConnection.
	//
	m_pWinsockConnection = new CWinsockConnection();
	m_pWinsockConnection->Init(AddrList, pOverlapped, pConnectedAddr );
}




R<IConnection> CSimpleWinsock::GetConnection()
{
	return m_pWinsockConnection;	
}

	
bool
CSimpleWinsock::GetHostByName(
    LPCWSTR host,
	std::vector<SOCKADDR_IN>* pConnectedAddr,
	bool fUseCache
    )
{
	return NoGetHostByName(host, pConnectedAddr, fUseCache);
}



bool CSimpleWinsock::IsPipelineSupported()
/*++

Routine Description:
     return if this transport support pipelining. 
	 Piplining means sending more requests to the server
	 before complete reading all response from previous request.
  
Arguments:
   
Returned Value:
true support piplining false not support piplining

--*/
{
	return m_fIsPipelineSupported;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\stssl.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stssl.cpp

Abstract:
    implementation of class CWinsockSSl declared in (stssl.h)

Author:
    Gil Shafriri (gilsh) 23-May-2000

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <schannel.h>
#include <no.h>
#include <ex.h>
#include <tr.h>
#include <xstr.h>
#include <cm.h>
#include "stssl.h"
#include "stsslco.h"
#include "stp.h"

#include "stssl.tmh"

bool CWinsockSSl::m_fIsPipelineSupported = false;

static bool IsSslPipeLineSupported()
/*++

Routine Description:
   Return the pipe line mode of the https delivery according registry setting
   - default is non pipeline mode
  
Arguments:
	Socket - Connected socket.

  
Returned Value:
	None

--*/

{
	DWORD fHttpsPipeLineSupport;

	CmQueryValue(
			RegEntry(NULL, L"HttpsPipeLine", TRUE),  
			&fHttpsPipeLineSupport
			);

	bool fRet = (fHttpsPipeLineSupport == TRUE); 
	TrTRACE(NETWORKING,"https pipeline mode = %d", fRet);
	return fRet;
}



void CWinsockSSl::InitClass()
{
	m_fIsPipelineSupported	=  IsSslPipeLineSupported();
}



//---------------------------------------------------------
//
//  CWinsockSSl Implementation
//
//---------------------------------------------------------

CWinsockSSl::CWinsockSSl(
					CredHandle* pCredentialsHandle,
					const xwcs_t& ServerName,
					USHORT ServerPort,
					bool fProxy
					):
					m_CSSlNegotioation(pCredentialsHandle,ServerName, ServerPort, fProxy )
				
				
{

}


CWinsockSSl::~CWinsockSSl()
{
}




bool
CWinsockSSl::GetHostByName(
	LPCWSTR host,
	std::vector<SOCKADDR_IN>* pConnectedAddr,
	bool fUseCache
	)
{
	return 	NoGetHostByName(host, pConnectedAddr, fUseCache);
}



void 
CWinsockSSl::CreateConnection(
				const std::vector<SOCKADDR_IN>& AddrList,
				EXOVERLAPPED* pOverlapped,
				SOCKADDR_IN* pConnectedAddr
				)
{
	TrTRACE(NETWORKING,"Try to connect");
	m_CSSlNegotioation.CreateConnection(AddrList, pOverlapped, pConnectedAddr);
}


R<IConnection> CWinsockSSl::GetConnection()
{
	return m_CSSlNegotioation.GetConnection();
}



/*++

Routine Description:
     return if this transport support pipelining. 
	 Piplining means sending more requests to the server
	 before complete reading all response from previous request.
  
Arguments:
   
Returned Value:
true support piplining false not support piplining

--*/
bool CWinsockSSl::IsPipelineSupported()
{
	//
	// HTTS does not support pileling - because we can get request to renegotiate
	// at any time form the server.	When this happened - the server expects spesific handshake
	// data to be send, this will fail if we have pending send at the same time. 
	//
	return m_fIsPipelineSupported;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\stsslco.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stsslco.h

Abstract:
    Header for class CSSlConnection sending\reading data above ssl connection


Author:
    Gil Shafriri (gilsh) 23-May-2000

--*/

#ifndef __ST_SSLCO_H
#define __ST_SSLCO_H

#include <rwlockexe.h>
#include "stsslsn.h"
#include "stsslrd.h"
#include "st.h"



class CSSlConnection: public IConnection
{
public:
	CSSlConnection(
		CredHandle* SecContext,
		const SecPkgContext_StreamSizes& sizes,
		const R<IConnection>& SimpleConnection,
		CSSlNegotioation& SSlNegotioation
		);

public:
	void virtual ReceivePartialBuffer(
						VOID* pBuffer,                                     
						DWORD Size, 
						EXOVERLAPPED* pov
						);


 	void virtual Send(
			const WSABUF* Buffers,                                     
			DWORD nBuffers, 
			EXOVERLAPPED* pov
			);



	//
	//	At the moment closing the connection is just closing the socket
	//	We sould consider doing it in the SSL way.
	//
	void virtual Close();
	
	
private:
	R<IConnection> m_SimpleConnection;
    CSSlSender m_SSLSender;
	CSSlReceiver m_SSlReceiver;
	CReadWriteLockAsyncExcutor m_ReadWriteLockAsyncExcutor;
	  
private:
	CSSlConnection(const CSSlConnection&);
	CSSlConnection& operator=(const CSSlConnection&);
 
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\stsslco.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    mtsslcon.cpp

Abstract:
    implementation class CSSlSender declared in stsslco.h


Author:
    Gil Shafriri (gilsh) 23-May-2000

--*/

#include <libpch.h>
#include <no.h>
#include "stsslco.h"
#include "stp.h"

#include "stsslco.tmh"


CSSlConnection::CSSlConnection(
		CredHandle* SecContext,
		const SecPkgContext_StreamSizes& sizes,
		const R<IConnection>&  SimpleConnection,
		CSSlNegotioation& SSlNegotioation
		):
		m_SimpleConnection(SimpleConnection),
		m_SSLSender(SecContext, sizes, SSlNegotioation, m_ReadWriteLockAsyncExcutor),
		m_SSlReceiver(SecContext, sizes, SSlNegotioation, m_ReadWriteLockAsyncExcutor)
{
		ASSERT(m_SimpleConnection.get() != NULL);
}



void CSSlConnection::ReceivePartialBuffer(
						VOID* pBuffer,                                     
						DWORD Size, 
						EXOVERLAPPED* pov
						)
{
	m_SSlReceiver.ReceivePartialBuffer(m_SimpleConnection, pBuffer, Size, pov);
}
	


void CSSlConnection::Send(
			const WSABUF* Buffers,                                     
			DWORD nBuffers, 
			EXOVERLAPPED* pov
			)
{
	m_SSLSender.Send(m_SimpleConnection, Buffers , nBuffers, pov); 
}


//
//	At the moment closing the connection is just closing the socket
//	We sould consider doing it in the SSL way.
//
void CSSlConnection::Close()
{
	m_ReadWriteLockAsyncExcutor.Close();
	m_SimpleConnection->Close();	    	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\stpgm.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    StPgm.cpp

Abstract:

    Implementation of class CPgmWinsock.

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include <mqsymbls.h>
#include <WsRm.h>
#include <no.h>
#include <Cm.h>
#include "StPgm.h"
#include "stp.h"
#include "uniansi.h"
#include "ev.h"

#include "stpgm.tmh"

static void STpDumpPGMSenderStats(const SOCKET socket );

DWORD CPgmWinsockConnection::m_LocalInterfaceIP = INADDR_NONE;
bool CPgmWinsockConnection::m_IsFirstSession = true;
CCriticalSection s_MulticastLock;


//
// This registry is to choose the binging ip of the sender
// in multicast
//
#define MSMQ_MULTICAST_SENDER_BIND_IP_STR			TEXT("MulticastBindIP")


void CPgmWinsockConnection::CheckLocalInterfaceIP()
{
	CS Lock(s_MulticastLock);
	if (m_IsFirstSession == false)
	{
		return;
	}
	m_IsFirstSession = false;

	//
	// first multicast message, we will check if event is needed
	//
    PHOSTENT phe = gethostbyname(NULL);
	if(phe == NULL)
	{
		DWORD gle = WSAGetLastError();
		TrERROR(NETWORKING, "failed to retrieve local IP address. %!winerr!", gle);
        throw exception();
	}

	std::string IPString;
	bool isValid = false;
    for (DWORD i = 0; phe->h_addr_list[i] != NULL; i++)
    {
    	in_addr TempAddr;
    	TempAddr.s_addr = *(ULONG*)phe->h_addr_list[i];
    	if (TempAddr.s_addr == m_LocalInterfaceIP)
    	{
    		isValid = true;
    	}
	
    	IPString += inet_ntoa(TempAddr);
    	IPString += ", ";
    }
    if ((i>1) && (!isValid))
    {
    	//
    	// we have more than one ip, or the IP in the registry is not one of
    	// the machine IPs, lets report to the event log
    	//
	    ASSERT(IPString.length()>0);
		IPString.erase(IPString.length()-2);
	    int len = ConvertToWideCharString(IPString.c_str(), NULL, 0);
	    AP<WCHAR> wzIPString = new WCHAR[len+1];
	    i = ConvertToWideCharString(IPString.c_str(), wzIPString.get(), len+1);
	    ASSERT (i);
	    wzIPString[len] = '\0';
		
		EvReport(EVENT_INFO_MULTICAST_SENDING_IP_NOT_DEFINED, 2, MSMQ_MULTICAST_SENDER_BIND_IP_STR, wzIPString.get());

		//
		// clean what we got from the registry so connect will not fail
		//
    	m_LocalInterfaceIP = INADDR_ANY;
    }
}


CPgmWinsockConnection::CPgmWinsockConnection(void)
{
    CSocketHandle socket = NoCreatePgmConnection();

    SOCKADDR_IN SrcSockAddr;
    SrcSockAddr.sin_family = AF_INET;
    SrcSockAddr.sin_port   = htons(0);
    SrcSockAddr.sin_addr.s_addr = 0;

    int rc;
    rc = bind(socket, (SOCKADDR *)&SrcSockAddr, sizeof(SrcSockAddr));
    if (rc == SOCKET_ERROR)
    {
        TrERROR(NETWORKING, "Failed to bind to PGM socket, error %d", WSAGetLastError());
        throw exception();
    }

    RM_SEND_WINDOW win;
    
    CmQueryValue(
        RegEntry(NULL, L"MulticastRateKbitsPerSec",560),
        &win.RateKbitsPerSec
        );
                  
    CmQueryValue(
        RegEntry(NULL, L"MulticastWindowSizeInMSecs"),
        &win.WindowSizeInMSecs 
        );
             
    win.WindowSizeInBytes = 0;

    TrTRACE(NETWORKING, "PGM window: Kbits/Sec=%d, Size(Msecs)=%d, Size(Bytes)=%d", win.RateKbitsPerSec, win.WindowSizeInMSecs, win.WindowSizeInBytes);

    rc = setsockopt(socket, IPPROTO_RM, RM_RATE_WINDOW_SIZE, (char *)&win, sizeof(win));
    if (rc == SOCKET_ERROR)
    {
        TrERROR(NETWORKING, "Failed to set PGM send window parameters, error %d", WSAGetLastError());
        throw exception();
    }
    
    ULONG Info = 0;
    TrTRACE(NETWORKING, "Set late join, join=%d", Info);
    rc = setsockopt(socket, IPPROTO_RM, RM_LATEJOIN, (char *)&Info, sizeof(ULONG));
    if (rc == SOCKET_ERROR)
    {
        TrERROR(NETWORKING, "Failed to set PGM socket options(RM_LATEJOIN), error %d", WSAGetLastError());
        throw exception();
    }

    ULONG PgmTimeToLive = 0;
    CmQueryValue(
        RegEntry(NULL, L"MulticastTimeToLive"),
        &PgmTimeToLive
        );
    
    if (PgmTimeToLive != 0)
    {
        rc = setsockopt(socket, IPPROTO_RM, RM_SET_MCAST_TTL, (char *)&PgmTimeToLive, sizeof(PgmTimeToLive));
        if (rc == SOCKET_ERROR)
        {
            TrERROR(NETWORKING, "Failed to set PGM socket options(RM_SET_MCAST_TTL), error %d", WSAGetLastError());
            throw exception();
        }
    }

	ASSERT(m_LocalInterfaceIP != INADDR_NONE);
	CheckLocalInterfaceIP();
	if (m_LocalInterfaceIP != INADDR_ANY)
	{
	    rc = setsockopt(socket, IPPROTO_RM, RM_SET_SEND_IF, (char *) &m_LocalInterfaceIP, sizeof(m_LocalInterfaceIP));
	    if (rc == SOCKET_ERROR)
	    {
	        TrERROR(NETWORKING, "Failed to set PGM socket options(RM_SET_SEND_IF), error %d", WSAGetLastError());
	        throw exception();
	    }
	}
	
	*&m_socket = socket.detach();
}


void
CPgmWinsockConnection::InitClass(DWORD LocalInterfaceIP)
{
	ASSERT(LocalInterfaceIP != INADDR_NONE);

    RegEntry registry(0, MSMQ_MULTICAST_SENDER_BIND_IP_STR);
    AP<WCHAR> pRetStr;
    CmQueryValue(registry, &pRetStr);

    if(pRetStr.get() != NULL)
    {
    	m_LocalInterfaceIP = StIPWStringToULONG(pRetStr.get());
    	if (m_LocalInterfaceIP == INADDR_NONE)
    	{
    		m_LocalInterfaceIP = INADDR_ANY;
    	}
    }
    else
    {
    	m_LocalInterfaceIP = LocalInterfaceIP;
    }
}


void
CPgmWinsockConnection::Init(
				const std::vector<SOCKADDR_IN>& AddrList, 
				EXOVERLAPPED* pOverlapped,
				SOCKADDR_IN* pConnectedAddr
				)
{
	m_SocketConnectionFactory.Create(AddrList, pOverlapped, pConnectedAddr, m_socket);
}



void 
CPgmWinsockConnection::ReceivePartialBuffer(
    VOID*,                                     
    DWORD, 
    EXOVERLAPPED*
    )
{
	ASSERT(("CPgmWinsock::ReceivePartialBuffer should not be called!", 0));
    TrERROR(NETWORKING, "CPgmWinsock::ReceivePartialBuffer should not be called!");
    throw exception();
}



void 
CPgmWinsockConnection::Send(
    const WSABUF* Buffers,
    DWORD nBuffers,
    EXOVERLAPPED* pov
    )
{
	CSR readlock(m_CloseConnection);
	if(IsClosed())
	{
		throw exception();
	}
	NoSend(m_socket, Buffers, nBuffers, pov);
}


void CPgmWinsockConnection::Close()
{
	ASSERT(!IsClosed());
	CSW writelock(m_CloseConnection);
    STpDumpPGMSenderStats(m_socket);
    m_socket.free();
}



void 
CPgmWinsock::CreateConnection(
					const std::vector<SOCKADDR_IN>& AddrList, 
					EXOVERLAPPED* pOverlapped,
					SOCKADDR_IN* pConnectedAddr
					)
{
	//
	// Note - we must do two phase constrcution of the connection object
	// becaue the connection can be completed before we assign the pointer
	// to m_pWinsockConnection and a call to GetConnection upon connection completion
	// will find null pointer in m_pWinsockConnection.
	//
	m_pPgmWinsockConnection = new  CPgmWinsockConnection();
	m_pPgmWinsockConnection->Init(AddrList, pOverlapped, pConnectedAddr);
} 


 
R<IConnection> CPgmWinsock::GetConnection()
{
	return m_pPgmWinsockConnection;
} 



bool
CPgmWinsock::GetHostByName(
	LPCWSTR,
	std::vector<SOCKADDR_IN>*,
	bool 
	)
{
	ASSERT(("CPgmWinsock::GetHostByName should not be called!", 0));
    TrERROR(NETWORKING, "CPgmWinsock::GetHostByName should not be called!");
    throw exception();
}




bool 
CPgmWinsock::IsPipelineSupported(
    VOID
    )
{
	return true;
}



void STpDumpPGMSenderStats(const SOCKET socket )
/*++
  
	Function Description:
		Get statistic information from the PGM sockets.
	Arguments:
		socket - PGM socket.
	Return code:
		None

	
--*/
{
	if(!WPP_LEVEL_COMPID_ENABLED(rsTrace, NETWORKING))
	{
		return;
	}
    RM_SENDER_STATS RmSenderStats;
    INT BufferLength = sizeof(RM_SENDER_STATS);
    memset (&RmSenderStats, 0, BufferLength);
    ULONG ret = getsockopt (socket, IPPROTO_RM, RM_SENDER_STATISTICS, (char *)&RmSenderStats, &BufferLength);
    if (ret != ERROR_SUCCESS)
    {
        TrERROR(NETWORKING, "GetSenderStats:  Failed to retrieve sender stats! error = %d\n",WSAGetLastError());
        return ;
    }
    TrTRACE(NETWORKING, "NaksReceived=<%I64d>", RmSenderStats.NaksReceived);
    TrTRACE(NETWORKING, "NaksReceivedTooLate=<%I64d>", RmSenderStats.NaksReceivedTooLate);
    TrTRACE(NETWORKING, "NumOutstandingNaks=<%I64d>", RmSenderStats.NumOutstandingNaks);
    TrTRACE(NETWORKING, "NumNaksAfterRData=<%I64d>", RmSenderStats.NumNaksAfterRData);
    TrTRACE(NETWORKING, "RepairPacketsSent=<%I64d>", RmSenderStats.RepairPacketsSent);
    TrTRACE(NETWORKING, "BufferSpaceAvailable=<%I64d> bytes", RmSenderStats.BufferSpaceAvailable);
    TrTRACE(NETWORKING, "LeadingEdgeSeqId=<%I64d>", RmSenderStats.LeadingEdgeSeqId);
    TrTRACE(NETWORKING, "TrailingEdgeSeqId=<%I64d>", RmSenderStats.TrailingEdgeSeqId);
    TrTRACE(NETWORKING, "Sequences in Window=<%I64d>", (RmSenderStats.LeadingEdgeSeqId-RmSenderStats.TrailingEdgeSeqId+1));
    TrTRACE(NETWORKING, "RateKBitsPerSecLast=<%I64d>", RmSenderStats.RateKBitsPerSecLast);
    TrTRACE(NETWORKING, "RateKBitsPerSecOverall=<%I64d>", RmSenderStats.RateKBitsPerSecOverall);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\stsslrd.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stsslsn.h

Abstract:
    Header for class CSSlReceiver that receive data above ssl connection.
	The class is responsible to receive data from ssl connection, decrypte it and to
	copy it to caller buffer. The caller overlapp function will be called when
	some data (> 0) was decrypted OK ,or in case of error. It is the caller responsiblity
	to call	ReceivePartialBuffer() again to get more decrypted data.


Author:
    Gil Shafriri (gilsh) 23-May-2000

--*/

#ifndef __ST_SSLRD_H
#define __ST_SSLRD_H
#include <buffer.h>
#include <rwlockexe.h>
#include "stp.h"




//---------------------------------------------------------
//
//  CUserReceiveBuffer helper class 
//
//---------------------------------------------------------
class CUserReceiveBuffer
{
public:
	CUserReceiveBuffer():m_pBuffer(NULL),m_len(0),m_written(0)
	{
	}
	
	void CreateNew(void* pBuffer,size_t len)
	{
		m_pBuffer = pBuffer;
		m_len = len;
		m_written = 0;
	}

	size_t Write(const void* pData ,size_t len)
	{
		ASSERT(pData != NULL);
		ASSERT(m_pBuffer != NULL);
		size_t leftout =  m_len - m_written;
		size_t towrite =  min(len,leftout);
		memcpy((BYTE*)m_pBuffer + m_written,pData,towrite);	//lint !e668
		m_written += towrite;
		
		return towrite;
	}

private:
	void* m_pBuffer;                                     
	size_t m_len; 
	size_t m_written;
};

//---------------------------------------------------------
//
//  CDecryptionBuffer helper class 
//
//---------------------------------------------------------
class  CDecryptionBuffer :private  CResizeBuffer<BYTE>
{
public:
	using CResizeBuffer<BYTE>::capacity;
	using CResizeBuffer<BYTE>::size;
	using CResizeBuffer<BYTE>::reserve;
	using CResizeBuffer<BYTE>::begin;
	using CResizeBuffer<BYTE>::resize;


public:
	CDecryptionBuffer(
		size_t len
		):
	    CResizeBuffer<BYTE>(len),
		m_decryptedlen(0)
		{
		}
	

	//
	// reset buffer
	//
	void reset()
	{
		resize(0);
		m_decryptedlen = 0;
	}
 	
	//
	// Get decrypted length of the buffer
	//
	size_t DecryptedSize()const
	{
		return 	m_decryptedlen;
	}

	//
	// Set decrypted length of the buffer
	//
	void DecryptedSize(size_t newsize)
	{
		ASSERT(newsize <=  size());
		m_decryptedlen =  newsize;
	}
	

private:
	size_t  m_decryptedlen;


private:
	CDecryptionBuffer(const CDecryptionBuffer&);
	CDecryptionBuffer& operator=(const CDecryptionBuffer&);
};


//---------------------------------------------------------
//
//  CReNegotioationRequest  class -  Represent ssl renegotiation request
//
//---------------------------------------------------------
class CSSlNegotioation;
class CSSlReceiver;
class CReNegotioationRequest : public IAsyncExecutionRequest , public CReference, public EXOVERLAPPED
{
public:
	CReNegotioationRequest(
		CSSlReceiver& SSlReceiver
		):
		EXOVERLAPPED(Complete_Renegotiate, Complete_RenegotiateFailed),
		m_SSlReceiver(SSlReceiver),
		m_fRun(false)
		{
		}

private:
	virtual void Run();

private:
	virtual void Close() throw();

private:
	static void WINAPI  Complete_RenegotiateFailed(EXOVERLAPPED* pOvl);
	static void WINAPI  Complete_Renegotiate(EXOVERLAPPED* pOvl);


private:
	CSSlReceiver& m_SSlReceiver;
	bool m_fRun;
};


//---------------------------------------------------------
//
//  CSSlReceiver  class - receive data from a connection (async)
//
//---------------------------------------------------------
class CSSlReceiver :public EXOVERLAPPED
{


public:
	CSSlReceiver(
		PCredHandle SecContext,
		const SecPkgContext_StreamSizes& sizes,
		CSSlNegotioation& SSlNegotioation,
		CReadWriteLockAsyncExcutor& ReadWriteLockAsyncExcutor
		);

	~CSSlReceiver();

public:
	void 
	ReceivePartialBuffer(	 
		const R<IConnection>& SimpleConnection,   
		VOID* pBuffer,                                     
		DWORD Size, 
		EXOVERLAPPED* pov
		);

	
private:
	void 
	ReceivePartialBufferInternal(	                          
		VOID* pBuffer,                                     
		DWORD Size 
		);

	void CopyExtraData();
	void ReceivePartialData();
	void ReceivePartialDataContinute();
	void Renegotiate();
	void RenegotiateFailed();
	void RenegotiateCompleted();
	void SetState(const EXOVERLAPPED& ovl);
	void BackToCallerWithError();
	void BackToCallerWithSuccess(size_t readcount);
	void IOReadMoreData();
	size_t WriteDataToCaller();
	SECURITY_STATUS TryDecrypteMessage();

private:
	static void WINAPI Complete_ReceivePartialData(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_ReceiveFailed(EXOVERLAPPED* pOvl);
	
	friend CReNegotioationRequest;

private:
	CSSlReceiver(const CSSlReceiver&);
	CSSlReceiver& operator=(const CSSlReceiver&);
	
private:
	CDecryptionBuffer m_DecryptionBuffer;
	CUserReceiveBuffer  m_UserReceiveBuffer;
	CredHandle* m_SecContext;
	SecPkgContext_StreamSizes m_Sizes;
	R<IConnection> m_SimpleConnection;
	EXOVERLAPPED* m_callerOvl;
	CSSlNegotioation& m_CSSlNegotioation;
	CReadWriteLockAsyncExcutor& m_ReadWriteLockAsyncExcutor;
};
	   


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\stsslsn.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    mtsslsn.h

Abstract:
    implementation class CSSlSender declared in mtsslsn.h


Author:
    Gil Shafriri (gilsh) 23-May-2000

--*/

#include <libpch.h>
#include <no.h>
#include <rwlockexe.h>
#include "stsslng.h"
#include "stsslsn.h"
#include "stp.h"
#include "encryptor.h"
#include "sendchunks.h"


#include "stsslsn.tmh"

//---------------------------------------------------------
//
//  class CSSLAsyncSend resposibile to encrypte the data 
//  using encryptor class (CSSlEncryptor) and to send it over the SSL connection.
//  On send completion,  it callback to a CSSlSender object it holds
//  
//---------------------------------------------------------
class CSSLAsyncSend : public EXOVERLAPPED, public IAsyncExecutionRequest, public CReference
{
public:
	CSSLAsyncSend(
		PCredHandle SecContext,	
		const SecPkgContext_StreamSizes& Sizes,
		const R<IConnection>& SimpleConnection,
		const WSABUF* Buffers,                                     
		DWORD nBuffers, 
		EXOVERLAPPED* pov,
		CSSlSender* pSSlSender
		):
		EXOVERLAPPED(OnSendOk, OnSendFailed),
		m_SendChunks(Buffers, nBuffers),
		m_SSlEncryptor(Sizes, SecContext),
		m_MaximumMessageLen(Sizes.cbMaximumMessage),
		m_SimpleConnection(SimpleConnection),
		m_pov(pov),
		m_pSSlSender(pSSlSender),
		m_fRun(false)
		
	{
	}

private:
	virtual void Run()	
	{
		ASSERT(!m_fRun);

		EncryptAllChunks();	
		Send();

		m_fRun = true;
	}


	void Send()	
	{
		DWORD size = numeric_cast<DWORD>(m_SSlEncryptor.GetEncrypted().size());
		ASSERT(size != 0);
	
		m_SimpleConnection->Send(	
						m_SSlEncryptor.GetEncrypted().begin(),
						size,
						this
						);
	}


	//
	// Force callback - by doing explicit call back with error.
	//
	virtual void Close()throw()
	{
		ASSERT(!m_fRun);
		SetStatus(STATUS_UNSUCCESSFUL);
		ExPostRequest(this);		
	}


private:
	void EncryptAllChunks()
	{
		for(;;)
        {
			const void* pChunk;
			DWORD len;

			m_SendChunks.GetNextChunk(m_MaximumMessageLen, &pChunk, &len);
			if(pChunk == NULL)
				return;   
			
			m_SSlEncryptor.Append(pChunk , len);
        }
	}

		
private:
	static void WINAPI OnSendOk(EXOVERLAPPED* pov)
	{
		CSSLAsyncSend* myself = static_cast<CSSLAsyncSend*>(pov);		
		myself->m_pSSlSender->OnSendOk(myself,  myself->m_pov);	
	}



	static void WINAPI OnSendFailed(EXOVERLAPPED* pov)
	{
		CSSLAsyncSend* myself = static_cast<CSSLAsyncSend*>(pov);
		myself->m_pSSlSender->OnSendFailed(myself, myself->m_pov);
	}


private:	
	CSendChunks m_SendChunks;
	CSSlEncryptor m_SSlEncryptor;
	PCredHandle m_SecContext;	
	R<IConnection> m_SimpleConnection;
	const WSABUF* m_Buffers;                                     
	DWORD m_nBuffers; 
	EXOVERLAPPED* m_pov;
	CSSlSender* m_pSSlSender;
	DWORD  m_MaximumMessageLen;
	bool m_fRun;
};




CSSlSender::CSSlSender(
						PCredHandle SecContext,
						const SecPkgContext_StreamSizes& sizes,
						const CSSlNegotioation& SSlNegotioation,
						CReadWriteLockAsyncExcutor& ReadWriteLockAsyncExcutor
						):
						m_SecContext(SecContext),
						m_Sizes(sizes),
						m_SSlNegotioation(SSlNegotioation),
						m_ReadWriteLockAsyncExcutor(ReadWriteLockAsyncExcutor)

{
}


void 
CSSlSender::Send(
	const R<IConnection>& SimpleConnection,                                              
	const WSABUF* Buffers,                                     
	DWORD nBuffers, 
	EXOVERLAPPED* pov
	)

/*++

Routine Description:
    Encrypte and send data buffers over ssl connection. 
  
Arguments:
	IN - Socket - connected ssl socket	.
	IN - Buffers - DATA buffers to send
	IN - nBuffers - number of buffers
	IN - pov - overlapp to finish the asyncrounous operation.
  
Returned Value:
None

--*/
{
	ASSERT(SimpleConnection.get() != NULL);

	R<CSSLAsyncSend> pSSLAsyncSend =  new CSSLAsyncSend(
												m_SecContext,	
												m_Sizes,
												SimpleConnection,
												Buffers,                                     
												nBuffers, 
												pov,
												this
												);
	//
	// Needs additional ref count for the async operation.
	//
	R<CSSLAsyncSend> AsyncOperationRef = pSSLAsyncSend;
	
	m_ReadWriteLockAsyncExcutor.AsyncExecuteUnderReadLock(pSSLAsyncSend.get());

	AsyncOperationRef.detach();
}
  

void CSSlSender::OnSendFailed(CSSLAsyncSend* pSSLAsyncSend, EXOVERLAPPED* pov)
{
	pSSLAsyncSend->Release();
	m_ReadWriteLockAsyncExcutor.UnlockRead();
		
	pov->SetStatus(STATUS_UNSUCCESSFUL);
	ExPostRequest(pov);
}


void CSSlSender::OnSendOk(CSSLAsyncSend* pSSLAsyncSend,  EXOVERLAPPED* pov)
{
	pSSLAsyncSend->Release();
	m_ReadWriteLockAsyncExcutor.UnlockRead();


	pov->SetStatus(STATUS_SUCCESS);
	ExPostRequest(pov);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\stsslng.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stsslnc.cpp

Abstract:
    implementation for class CSSlNegotioation declared in stsslng.h


Author:
    Gil Shafriri (gilsh) 23-May-2000

--*/
#include <libpch.h>
#include <schannel.h>
#include <no.h>
#include <xstr.h>
#include "stsslng.h"
#include "stsslco.h"
#include "stp.h"
#include "cm.h"
#include "_mqini.h"

#include "stsslng.tmh"

static
void
ReceivePartialBuffer(
    const R<IConnection>& SimpleConnection,
    VOID* pBuffer,
    size_t Size,
    EXOVERLAPPED* pov
    )
{
	DWORD dwLen = numeric_cast<DWORD>(Size);
	SimpleConnection->ReceivePartialBuffer(pBuffer, dwLen ,	pov);
}



//---------------------------------------------------------
//
//  class CCertificateChain
//
//---------------------------------------------------------
class CCertificateChain{
public:
    CCertificateChain(PCCERT_CHAIN_CONTEXT  h = NULL) : m_h(h) {}
   ~CCertificateChain()
   {
		if (m_h != NULL)				
		{
			CertFreeCertificateChain(m_h);
		}
   }

    PCCERT_CHAIN_CONTEXT* getptr()            { return &m_h; }
    PCCERT_CHAIN_CONTEXT  get() const         { return m_h; }
    PCCERT_CHAIN_CONTEXT  operator->() const  { return m_h; }

    PCCERT_CHAIN_CONTEXT  detach()
	{
		PCCERT_CHAIN_CONTEXT h = m_h;
		m_h = NULL;
		return h;
	}

private:
    CCertificateChain(const CCertificateChain&);
    CCertificateChain& operator=(const CCertificateChain&);

private:
    PCCERT_CHAIN_CONTEXT  m_h;
};


static
void
VerifyServerCertificate(
				PCCERT_CONTEXT  pServerCert,
				LPWSTR         pServerName
				)

/*++
Routine Description:
    Verify that the server certificate is valid

Arguments:
    pServerCert - server cetificate.
	pServerName - server name.

Returned Value:
   None

--*/

				

{
    HTTPSPolicyCallbackData  polHttps;
    CERT_CHAIN_POLICY_PARA   PolicyPara;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_PARA          ChainPara;

    //
    // handle fo disallowed certificate store used in searching for bad certificates
    // we use a fresh handle since an old one will not reflect the latest changes
    //
    CCertOpenStore hDisallowedCertStore = CertOpenSystemStore( NULL, TEXT("Disallowed") );
    if( NULL == (HCERTSTORE)hDisallowedCertStore )
    {
        TrERROR(NETWORKING,"Error opening the Disallowed certificates store!");
        throw exception();
    }

    //
    // search certificate in the disallowed certificate store
    //
    CCertificateContext pCertContext = CertFindCertificateInStore(
                hDisallowedCertStore,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                0,                      // no special find attributes
                CERT_FIND_EXISTING,
                (PCCERT_CONTEXT)pServerCert,
                NULL );                 // no previous certificate found

    //
    // the certificate was found in the disallowed list, this means that it is untrusted
    //
    if( (PCCERT_CONTEXT)pCertContext != NULL )
    {
        TrERROR(NETWORKING,"CertFindCertificateInStore Disallowed succeeded, the certificate cannot be trusted!");
        throw exception();
    }

	//
    // Build certificate chain.
    //

    ZeroMemory(&ChainPara, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);

    //
    // we have the CERT_CHAIN_REVOCATION_CHECK_CHAIN to check if the
    // specified certificate is revoked.
    //
    CCertificateChain  pChainContext;
    DWORD dwFlag = CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    DWORD fIgnoreRevocation = FALSE;
	CmQueryValue(
			RegEntry(MSMQ_SECURITY_REGKEY, MSMQ_SKIP_REVOCATION_CHECK_REGNAME, FALSE),  
			&fIgnoreRevocation
			);

	if(fIgnoreRevocation)
		dwFlag = 0;
	
    if(!CertGetCertificateChain(
                            HCCE_LOCAL_MACHINE,
                            pServerCert,
                            NULL,
                            pServerCert->hCertStore,
                            &ChainPara,
                            dwFlag,
                            NULL,
                            pChainContext.getptr()))
    {
		TrERROR(NETWORKING,"CertGetCertificateChain failed with error %x",GetLastError());
		throw exception();
    }
	

    //
    // if there is an error in the chain trust status there is no need to go on
    // and check if there are other policy issues with this certificate
    //
    if( pChainContext->TrustStatus.dwErrorStatus != CERT_TRUST_NO_ERROR )
    {
        TrERROR(NETWORKING,"CertGetCertificateChain returned chain with TrustStatus %x", pChainContext->TrustStatus.dwErrorStatus);
        throw exception();
    }

    //
    // Validate certificate chain.
    //

    memset(&polHttps,0, sizeof(HTTPSPolicyCallbackData));
    polHttps.cbStruct           = sizeof(HTTPSPolicyCallbackData);
    polHttps.dwAuthType         = AUTHTYPE_SERVER;
    polHttps.fdwChecks          = 0;
    polHttps.pwszServerName     = pServerName;


	
	
    memset(&PolicyPara, 0, sizeof(PolicyPara));
    PolicyPara.cbSize  = sizeof(PolicyPara);

    PolicyPara.pvExtraPolicyPara = &polHttps;

    memset(&PolicyStatus, 0, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);

   
			
    if(!CertVerifyCertificateChainPolicy(
                            CERT_CHAIN_POLICY_SSL,
                            pChainContext.get(),
                            &PolicyPara,
                            &PolicyStatus))
    {
		TrERROR(NETWORKING,"Verify Certificate Chain Policy failed, Error=%x ",GetLastError());
		throw exception();
    }
	
    if(PolicyStatus.dwError)
    {
		TrERROR(NETWORKING,"Verify Certificate Chain Policy failed,  PolicyStatus.dwError=%x ",PolicyStatus.dwError);
		throw exception();
    }
}



//---------------------------------------------------------
//
//  static callback member functions
//
//---------------------------------------------------------

void WINAPI CSSlNegotioation::Complete_NetworkConnect(EXOVERLAPPED* pOvl)
/*++

Routine Description:
    Called when network connection completed succsefully.

Arguments:
    pov - pointer to overlapped structure.

Returned Value:
    None.

--*/
{
	ASSERT(pOvl != NULL);
	CSSlNegotioation* MySelf = (static_cast<CSSlNegotioation*>(pOvl));
	MySelf->m_SimpleConnection = MySelf->m_SimpleWinsock.GetConnection();
	ASSERT(MySelf->m_SimpleConnection.get() != NULL);

	try
	{
		if(MySelf->m_fUseProxy)
		{
			MySelf->SendSslProxyConnectRequest();
		}
		else
		{
			MySelf->SendStartConnectHandShake();
		}
	}
	catch(const exception&)
	{
		MySelf->BackToCallerWithError();		
	}
}

void WINAPI CSSlNegotioation::Complete_ConnectFailed(EXOVERLAPPED* pOvl)
/*++

Routine Description:
    Called in any case of connection failure.

Arguments:
    pov - pointer to overlapped structure.

Returned Value:
    None.

--*/
{
	ASSERT(pOvl != NULL);
	CSSlNegotioation* MySelf = (static_cast<CSSlNegotioation*>(pOvl));

	MySelf->BackToCallerWithError();
}

void WINAPI  CSSlNegotioation::Complete_SendHandShakeData(EXOVERLAPPED* pOvl)
/*++

Routine Description:
    Called after sednding the first handshake data to the server completed

Arguments:
    pov - pointer to overlapped structure.

Returned Value:
    None.

--*/
{
	ASSERT(pOvl  !=  NULL);
	CSSlNegotioation* MySelf = (static_cast<CSSlNegotioation*>(pOvl));

	try
	{
		MySelf->ReadHandShakeData();
	}
	catch(const exception&)
	{
		MySelf->BackToCallerWithError();		
	}

}

void WINAPI CSSlNegotioation::Complete_SendFinishConnect(EXOVERLAPPED* pOvl)
/*++

Routine Description:
    Called after sednding the end handshake data to the server completed

Arguments:
    pov - pointer to overlapped structure.

Returned Value:
    None.

--*/
{
	ASSERT(pOvl  !=  NULL);
	CSSlNegotioation* MySelf = (static_cast<CSSlNegotioation*>(pOvl));
 	try
	{
		MySelf->AuthenticateServer();
	}
	catch(const exception&)
	{
		MySelf->BackToCallerWithError();		
	}
}

void WINAPI CSSlNegotioation::Complete_ReadHandShakeResponse(EXOVERLAPPED* pOvl)
/*++

Routine Description:
    Called after reading data from the server completed

Arguments:
    pov - pointer to overlapped structure.

Returned Value:
    None.

--*/
{
	ASSERT(pOvl  !=  NULL);
	CSSlNegotioation* MySelf = (static_cast<CSSlNegotioation*>(pOvl));

	try
	{
		MySelf->HandleHandShakeResponse();
	}
	catch(const exception&)
	{
		MySelf->BackToCallerWithError();		
	}

}


void WINAPI CSSlNegotioation::Complete_SendSslProxyConnectRequest(EXOVERLAPPED* pOvl)
/*++

Routine Description:
    Called after sending "connect" request to the proxy completed.

Arguments:
    pov - pointer to overlapped structure.

Returned Value:
    None.

--*/
{
	ASSERT(pOvl  !=  NULL);
	CSSlNegotioation* MySelf = (static_cast<CSSlNegotioation*>(pOvl));
	try
	{
		MySelf->m_pHandShakeBuffer.reset();
        MySelf->ReadProxyConnectResponse();
	}
	catch(const exception&)
	{
		MySelf->BackToCallerWithError();		
	}

}


void WINAPI CSSlNegotioation::Complete_ReadProxyConnectResponse(EXOVERLAPPED* pOvl)
/*++

Routine Description:
    Called reading proxy partial response completed.

Arguments:
    pov - pointer to overlapped structure.

Returned Value:
    None.

--*/
{
	ASSERT(pOvl  !=  NULL);
	CSSlNegotioation* MySelf = (static_cast<CSSlNegotioation*>(pOvl));
	try
	{
		MySelf->ReadProxyConnectResponseContinute();
	}
	catch(const exception&)
	{
		MySelf->BackToCallerWithError();		
	}
}


//---------------------------------------------------------
//
//  none static callback member functions
//
//---------------------------------------------------------

CSSlNegotioation::CSSlNegotioation(
							CredHandle* pCredentialsHandle ,
						    const xwcs_t& ServerName,
						    USHORT ServerPort,
							bool fUseProxy
							):
						    EXOVERLAPPED(Complete_NetworkConnect,Complete_ConnectFailed),
							m_pCredentialsHandle(pCredentialsHandle),
							m_pServerName(ServerName.ToStr()),
						   	m_pSSlConnection(NULL),
						    m_callerOvl(NULL),
						  	m_fServerAuthenticate(true),
							m_ServerPort(ServerPort),
							m_fUseProxy(fUseProxy)

				
{

}





void CSSlNegotioation::SendStartConnectHandShake()
/*++

Routine Description:
    Start SSL connection handshake.

Arguments:
    None.

Returned Value:
    None

--*/

{
	if(m_pHandShakeBuffer.capacity() < CHandShakeBuffer::xReadBufferStartSize)
	{
		TrTRACE(NETWORKING,"Creating new handshake buffer ");
		ASSERT(m_pHandShakeBuffer.size() == 0);
		m_pHandShakeBuffer.CreateNew();
	}

	//
    //  Initiate a ClientHello message and generate a token.
    //
	SecBuffer   OutBuffers;
    OutBuffers.pvBuffer   = NULL;
    OutBuffers.BufferType = SECBUFFER_TOKEN;
    OutBuffers.cbBuffer   = 0;

	SecBufferDesc   OutBuffer;
    OutBuffer.cBuffers = 1;
    OutBuffer.pBuffers = &OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

	DWORD dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT   |
						ISC_REQ_REPLAY_DETECT     |
						ISC_REQ_CONFIDENTIALITY   |
						ISC_RET_EXTENDED_ERROR    |
						ISC_REQ_ALLOCATE_MEMORY   |
                        ISC_REQ_USE_SUPPLIED_CREDS|
						ISC_REQ_STREAM;


	DWORD           dwSSPIOutFlags;
	TimeStamp       tsExpiry;

    SECURITY_STATUS scRet = InitializeSecurityContext(
													m_pCredentialsHandle,
													NULL,
													m_pServerName.get(),
													dwSSPIFlags,
													0,
													SECURITY_NATIVE_DREP,
													NULL,
													0,
													m_hContext.getptr(),
													&OutBuffer,
													&dwSSPIOutFlags,
													&tsExpiry
													);



	if(scRet != SEC_I_CONTINUE_NEEDED || OutBuffers.cbBuffer == 0 )
    {
		TrERROR(NETWORKING,"Initialize Security Context failed, Error=%x",scRet);
		throw exception();
    }
   	


	//
    //save send buffer because we sent it ayncrounosly
	//
	m_SendConetext = OutBuffers.pvBuffer;

	SetState(EXOVERLAPPED(Complete_SendHandShakeData,Complete_ConnectFailed));

	
	StpSendData(
		m_SimpleConnection,
		OutBuffers.pvBuffer,
		OutBuffers.cbBuffer,
		this
		);

}


void CSSlNegotioation::BackToCallerWithSuccess()
/*++

Routine Description:
    Called if connection was established. It signal the user overlapp
	with success code.

Arguments:
    None.

Returned Value:
    None

--*/
{
	TrTRACE(NETWORKING,"connection established with %ls",m_pServerName.get());
	m_SendConetext.free();
	StpPostComplete(&m_callerOvl, STATUS_SUCCESS);
}


void  CSSlNegotioation::BackToCallerWithError()
/*++

Routine Description:
    Called if connection negotiation failed. It signal the user overlapp
	with error code.

Arguments:
    None.

Returned Value:
    None

--*/
{
	TrERROR(NETWORKING,"connection negotiation failed with %ls",m_pServerName.get());
 	m_pHandShakeBuffer.free();
	m_SimpleConnection.free();
	m_SendConetext.free();
	StpPostComplete(&m_callerOvl,STATUS_UNSUCCESSFUL);
}


void CSSlNegotioation::CreateConnection(
		const std::vector<SOCKADDR_IN>& AddrList,
		EXOVERLAPPED* pOverlapped,
		SOCKADDR_IN* pConnectedAddr
		)

/*++

Routine Description:
    Start SSL connection handshake.

Arguments:
 	 AddrList - List of Addresses  to try connect to.
	 pOverlapped - function to call when finished or failed.
	 SOCKADDR_IN* pConnectedAddr - On success - Receive the address connection was established on.


Returned Value:
    None

--*/
{
	ASSERT(pOverlapped != NULL);
	ASSERT(m_callerOvl == NULL);
	ASSERT(m_SimpleConnection.get() == NULL);

	TrTRACE(NETWORKING,"Start connection negotiation with %ls",m_pServerName.get());

	SetState(EXOVERLAPPED(Complete_NetworkConnect,Complete_ConnectFailed));
	m_callerOvl =  pOverlapped;
	m_fServerAuthenticate = true;

	m_SimpleWinsock.CreateConnection(AddrList, this, pConnectedAddr);
}



void
CSSlNegotioation::ReConnect(
    const R<IConnection>& SimpleConnection,
    EXOVERLAPPED* pOverlapped
    )
{
	TrTRACE(NETWORKING,"Start connection renegotiation with %ls",m_pServerName.get());

	m_callerOvl =  pOverlapped;
	m_SimpleConnection = SimpleConnection;
	m_fServerAuthenticate = false;
	m_pHandShakeBuffer.CreateNew();
	HankShakeLoop(false);
}


void CSSlNegotioation::HandleHandShakeResponse()
/*++

Routine Description:
     Called after client read data from the serve.
	 The data read will start handshake loop.

Arguments:
    None.

Returned Value:
    None

--*/
{
	//
	// if we did not read even single byte - this in an error
	// probably server closed the connection
	//
	DWORD ReadLen = DataTransferLength(*this);
	if(ReadLen == 0)
	{
		TrERROR(NETWORKING,"Server closed the connection");
		throw exception();
	}
 	m_pHandShakeBuffer.resize(m_pHandShakeBuffer.size() + ReadLen);
	HankShakeLoop(false);
}


void CSSlNegotioation::SendFinishConnect(const void* pContext,DWORD len)
/*++

Routine Description:
	Send data to the server that finish successfuly the handshake,

Arguments:
	IN - pContext pointer to data to send.
	IN - len data length to send.

Returned Value:
	None

--*/
{
	SetState(EXOVERLAPPED(Complete_SendFinishConnect,Complete_ConnectFailed));


	StpSendData(
		m_SimpleConnection,
		pContext,
		len,
		this
		);

}



void CSSlNegotioation::SendContinuteConnect(const void* pContext,DWORD len)
/*++

Routine Description:
	Send token to the server and remaind in hankshake mode.

Arguments:
	IN - pContext pointer to data to send.
	IN - len data length to send.

Returned Value:
	None

--*/



{
	SetState(EXOVERLAPPED(Complete_SendHandShakeData,Complete_ConnectFailed));


	StpSendData(
		m_SimpleConnection,
		pContext,
		len,
		this
		);

}



SecPkgContext_StreamSizes CSSlNegotioation::GetSizes()
/*++

Routine Description:
	Get SSL sizes information of the header, trailer and max message.

Arguments:


Returned Value:
	SSL sizes information structure.

--*/

{
	SecPkgContext_StreamSizes Sizes;

	//
    // Read stream encryption properties.
    //

    SECURITY_STATUS scRet = QueryContextAttributes(
								   m_hContext.getptr(),
                                   SECPKG_ATTR_STREAM_SIZES,
                                   &Sizes
								   );
    if(scRet != SEC_E_OK)
    {
		TrERROR(NETWORKING,"QueryContextAttributes failed,Error=%x",scRet);
		throw exception();
    }

	return Sizes;
}



void CSSlNegotioation::AuthenticateServer()
/*++

Routine Description:
   Authenticate the server.
   Create new connection object if the server is
   authenticated.

Arguments:
	None

Returned Value:
	None

--*/
{

	if(!m_fServerAuthenticate)
	{
		BackToCallerWithSuccess();
		return;
	}

	//
	//Get server's certificate.
	//
	CCertificateContext pRemoteCertContext;
	

    SECURITY_STATUS Status = QueryContextAttributes(
										m_hContext.getptr(),
										SECPKG_ATTR_REMOTE_CERT_CONTEXT,
										&pRemoteCertContext
										);
    if(Status != SEC_E_OK)
    {
		throw exception();
    }


	//
    // Attempt to validate server certificate.
	//
    VerifyServerCertificate(pRemoteCertContext,m_pServerName);


	//
	// create connection object
	//
	m_pSSlConnection = new CSSlConnection(
							m_hContext.getptr(),
							GetSizes(),
							m_SimpleConnection,
							*this
							);	


	//
	// at last we are connected !
	//
	BackToCallerWithSuccess();
}

void CSSlNegotioation::SetState(const EXOVERLAPPED& ovl)
{
	EXOVERLAPPED::operator=(ovl); //LINT !e530	 !e1013	  !e1015 !e534
}


void CSSlNegotioation::ReadHandShakeData()
/*++

Routine Description:
   Read hankshake data from the server.

Arguments:
	None

Returned Value:
	None

--*/
{
	ASSERT (m_pHandShakeBuffer.size() <=  m_pHandShakeBuffer.capacity());

	//
	//  if we need to resize the buffer
	//
	if(m_pHandShakeBuffer.capacity() == m_pHandShakeBuffer.size())
	{
		m_pHandShakeBuffer.reserve(m_pHandShakeBuffer.size() * 2);		
	}
   	
   	SetState(EXOVERLAPPED(Complete_ReadHandShakeResponse, Complete_ConnectFailed));

	ReceivePartialBuffer(
					m_SimpleConnection,
					m_pHandShakeBuffer.begin() + m_pHandShakeBuffer.size(),
					m_pHandShakeBuffer.capacity() - m_pHandShakeBuffer.size(),
					this
					);

}


void CSSlNegotioation::ReadProxyConnectResponseContinute()
/*++

Routine Description:
	Continute reading the proxy connect response untill "\r\n\r\n"


Returned Value:
	None

--*/
{
 	DWORD ReadLen = DataTransferLength(*this);
	if(ReadLen == 0)
	{
		TrERROR(NETWORKING,"Proxy closed the connection");
		throw exception();
	}

	const BYTE xProxyResponseEndStr[]= "\r\n\r\n";

    BYTE* pBufferStart = m_pHandShakeBuffer.begin() + m_pHandShakeBuffer.size();
    BYTE* pBufferEnd   = pBufferStart + ReadLen;

    //
    // We need to start from 4th byte before the current chunk in case that
    // xProxyResponseEndStr will be cut between two chunks
    //
    if( m_pHandShakeBuffer.size() >= STRLEN(xProxyResponseEndStr) )
    {
        pBufferStart -= STRLEN(xProxyResponseEndStr);
    }
	
    const BYTE* pFound = std::search(
					pBufferStart,
					pBufferEnd,
					xProxyResponseEndStr,
					xProxyResponseEndStr + STRLEN(xProxyResponseEndStr)
					);

	//
	// if we did not find the "\r\n\r\n" in the response - continure reading
	//
	if(pFound == pBufferEnd)
	{
		//
        // Do not read unresonable response sizes.
        //
        if( m_pHandShakeBuffer.size() + ReadLen > xMaxResponseSize )
        {
            TrERROR(NETWORKING,"Proxy response is too long");
            throw exception();
        }

        // we don't care about the proxy response data - just need to read it all
        // in order to start the ssl handshake.
        m_pHandShakeBuffer.resize( m_pHandShakeBuffer.size() + ReadLen );
        m_pHandShakeBuffer.reserve(m_pHandShakeBuffer.size() + xResponseChunkSize);

        ReadProxyConnectResponse();
		return;
	}

	//
	// make buffer ready for next step
	//
	m_pHandShakeBuffer.reset();
	
    //
	// next step which is SSL handshake.
	//
	SendStartConnectHandShake();
}




void CSSlNegotioation::ReadProxyConnectResponse()
/*++

Routine Description:
  reading the proxy response fro the ssl connect request.


Returned Value:
	None

--*/
{
	SetState(EXOVERLAPPED(Complete_ReadProxyConnectResponse,Complete_ConnectFailed));
	
	
	ReceivePartialBuffer(
				m_SimpleConnection,
				m_pHandShakeBuffer.begin() + m_pHandShakeBuffer.size(),
				m_pHandShakeBuffer.capacity() - m_pHandShakeBuffer.size(),
				this
				);

}

void CSSlNegotioation::SendSslProxyConnectRequest()
/*++

Routine Description:
  Send to the proxy SSL connect request to remote host


Returned Value:
	None

Note:
	When working with proxy we must send special SSL connect request to the proxy
	before the handshake with the destination machine. This is needed because  proxy
	can't undestand the SSl handshake and don't know where to redirect the requst.
--*/
{
    SP<char> ServerNameA;
    StackAllocSP(ServerNameA, wcslen(m_pServerName.get()) + 1);
    sprintf(ServerNameA,"%ls",m_pServerName.get());


	//
	// preaper proxy connect(ssl tunneling) requset string
	//
	std::ostringstream ProxySSlConnectRequest;
	ProxySSlConnectRequest<<"CONNECT "
						  <<ServerNameA.get()
					  	  <<':'
						  <<m_ServerPort
						  <<" HTTP/1.1\r\n\r\n";
							

	m_ProxySSlConnectRequestStr =  ProxySSlConnectRequest.str();

	SetState(EXOVERLAPPED(Complete_SendSslProxyConnectRequest,Complete_ConnectFailed));
	StpSendData(
		m_SimpleConnection,
		m_ProxySSlConnectRequestStr.c_str(),
		m_ProxySSlConnectRequestStr.size(),
		this
		);

}

void
CSSlNegotioation::HandShakeLoopIncompleteCredentials()
/*++

Routine Description:
   Continute the handshake loop.	
   Called by HankShakeLoop() when handshake ask for credentials renegotiation

Arguments:

Returned Value:
	None

Note:

--*/
{
    HankShakeLoop(true);
}


void
CSSlNegotioation::HankShakeLoopContinuteNeeded(
	void* pContext,
	DWORD len,
	SecBuffer* pSecBuffer
	)
/*++

Routine Description:
   Continute the handshake loop.	
   Called by HankShakeLoop() when handshake loop is still going on.

Arguments:
	void* pContex - data to send to the server (if not NULL).
	len - context length.
	pSecBuffer - security buffer.

Returned Value:
	None

Note:
	If pSecBuffer has extra data - we use it as new input for HankShakeLoop(),
	otherwise - we send context data to the server , continute reading from server
	and staying	the  handshake loop.

--*/
{
	if(pSecBuffer->BufferType == SECBUFFER_EXTRA)
	{
			ASSERT(pContext == NULL);

			memmove(
				m_pHandShakeBuffer.begin(),
				m_pHandShakeBuffer.begin()+(m_pHandShakeBuffer.size() - pSecBuffer->cbBuffer),
				pSecBuffer->cbBuffer
				);

			m_pHandShakeBuffer.resize(pSecBuffer->cbBuffer);
			HankShakeLoop(false);
			return;
	}
	ASSERT(pContext != NULL);
	m_pHandShakeBuffer.reset();
	m_SendConetext	=  pContext;
	SendContinuteConnect(pContext, len);
}


void CSSlNegotioation::HankShakeLoopOk(const SecBuffer InBuffers[2], void* pContext, DWORD len)
/*++

Routine Description:
   Finish the Hand Shake loop.	
   Called by HankShakeLoop() when handshake loop finished successfully.


Arguments:
	void* pContex - data to send to the server (if not NULL).
					If pContex is NULL we go to do server authentication,
					otherwise - we send it to server and only then go to do server
					authentication.
					
	len - context len.

Returned Value:
	None

--*/
{

	//
	// check if server response has some application data for us - we should pointer to it
	//
	if(InBuffers[1].BufferType == SECBUFFER_EXTRA)
	{
        const BYTE* pInputBufferStart = static_cast<BYTE*>(InBuffers[0].pvBuffer);
        DWORD InputBufferLen = InBuffers[0].cbBuffer;
        DWORD ExtraDataLen = InBuffers[1].cbBuffer;
        const BYTE* pExtraDataPtr = pInputBufferStart + InputBufferLen - ExtraDataLen;
		xustr_t Exdata(pExtraDataPtr, ExtraDataLen);
        ASSERT(Exdata.Buffer() + Exdata.Length() == pInputBufferStart + InputBufferLen);
		m_pHandShakeBuffer.ExtraData(Exdata);
	}


	//
	// We need to send token to server
	//
	if(pContext != NULL)
	{
		//
		// send data token to server and we are done
		//
		m_SendConetext	=  pContext;
		SendFinishConnect(pContext,len);
		return;
	}

	//
	// now we should authenticate the server
	//
	AuthenticateServer();
}


void CSSlNegotioation::HankShakeLoop(bool fIgnoreInputBuffers)
/*++

Routine Description:
   Perform the connection state machine loop.

Arguments:
	None

Returned Value:
	None

Note:
	The function is called after we have some data read from the server
	and it ask SSPI what to do next.

--*/
{
    //
    // Set up the input buffers. Buffer 0 is used to pass in data
    // received from the server. Schannel will consume some or all
    // of this. Leftover data (if any) will be placed in buffer 1 and
    // given a buffer type of SECBUFFER_EXTRA.
    //
	SecBuffer       InBuffers[2];


    InBuffers[0].pvBuffer   = m_pHandShakeBuffer.begin();
    InBuffers[0].cbBuffer   = numeric_cast<DWORD>(m_pHandShakeBuffer.size());
    InBuffers[0].BufferType = SECBUFFER_TOKEN;

    InBuffers[1].pvBuffer   = NULL;
    InBuffers[1].cbBuffer   = 0;
    InBuffers[1].BufferType = SECBUFFER_EMPTY;

	SecBufferDesc   InBuffer;
    InBuffer.cBuffers       = fIgnoreInputBuffers ? 0 : TABLE_SIZE(InBuffers);
    InBuffer.pBuffers       = InBuffers;
    InBuffer.ulVersion      = SECBUFFER_VERSION;

	
	SecBuffer       OutBuffers;
    OutBuffers.pvBuffer  = NULL;
    OutBuffers.BufferType= SECBUFFER_TOKEN;
    OutBuffers.cbBuffer  = 0;

	
	SecBufferDesc   OutBuffer;
    OutBuffer.cBuffers      = 1;
    OutBuffer.pBuffers      = &OutBuffers;
    OutBuffer.ulVersion     = SECBUFFER_VERSION;

	DWORD dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT   |
					    ISC_REQ_REPLAY_DETECT     |
					    ISC_REQ_CONFIDENTIALITY   |
					    ISC_RET_EXTENDED_ERROR    |
					    ISC_REQ_ALLOCATE_MEMORY   |
                        ISC_REQ_USE_SUPPLIED_CREDS|
					    ISC_REQ_STREAM;

	TimeStamp       tsExpiry;
	DWORD           dwSSPIOutFlags;

    //
    // Call InitializeSecurityContext to see what to do next
    //
    SECURITY_STATUS scRet  = InitializeSecurityContext(
											  m_pCredentialsHandle,
											  m_hContext.getptr(),
											  NULL,
											  dwSSPIFlags,
											  0,
											  SECURITY_NATIVE_DREP,
											  &InBuffer,
											  0,
											  NULL,
											  &OutBuffer,
											  &dwSSPIOutFlags,
											  &tsExpiry
											  );


    if(scRet == SEC_I_INCOMPLETE_CREDENTIALS )
    {
        TrTRACE(NETWORKING, "CSSlNegotioation::HandShakeLoop - SEC_I_INCOMPLETE_CREDENTIALS - Continuing");
        HandShakeLoopIncompleteCredentials();
        return;
    }

	//
	// we should read more from the server
	//
	if(scRet == SEC_E_INCOMPLETE_MESSAGE)
	{
        TrTRACE(NETWORKING, "CSSlNegotioation::HandShakeLoop - SEC_E_INCOMPLETE_MESSAGE - Continuing");
		ReadHandShakeData();
		return;
	}

	//
	// if the connection negotiation is not completed
	//
	if(scRet == SEC_I_CONTINUE_NEEDED)
	{
		HankShakeLoopContinuteNeeded(OutBuffers.pvBuffer, OutBuffers.cbBuffer, &InBuffers[1] );	
		return;
	}

	//
	// it is completed
	//
	if(scRet == SEC_E_OK )
	{
		HankShakeLoopOk(InBuffers, OutBuffers.pvBuffer, OutBuffers.cbBuffer);	
		return;
	}

	//
	// Otherwise - it is something unexpected
	//
	TrERROR(NETWORKING,"Could not Initialize Security Context, Error=%x",scRet);
	throw exception();
}


R<IConnection> CSSlNegotioation::GetConnection()
{
	ASSERT(m_pSSlConnection.get() != NULL);
	return m_pSSlConnection;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\test\clparser.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    clparser.h

Abstract:
    Class for parsing command line arguments
	The command line argument are in the format of "/token":"literal"

	Usage :
	main(int argc, WCHAR* argv[])
	{
	   CClParser<WCHAR> ClParser(argc, argv);
	   std::wstring name = ClParser[L"name"]; //get the literal for L"name" token
	   std::wstring Length = ClParser[L"l"];  //get the literal for L"l" token
	   bool b = ClParser.IsExists(L"p");      // does L"/p" exsists in the commandline ?
	} 	

Author:
    Gil Shafriri (gilsh) 05-Jun-00

Environment:
    Platform-independent

--*/


#ifndef CLPARSER_H
#define CLPARSER_H


template <class T>
class CClParser
{
	typedef std::basic_string<T> String;
public:
	CClParser(int argc, T* const* argv);
    bool IsExists(const T*  pToken)const;
    String operator[](const T* pToken)const;
	size_t GetNumber(const T*  pToken)const;

private:
	void ParseToken(const String& str);


private:
    std::map<String,String> m_map;
};



template <class T> inline CClParser<T>::CClParser(int argc, T*const * argv)
{
    for (int i=1; i<argc; i++)
    {
        ParseToken(argv[i]);
    }
}

template <class T> inline size_t CClParser<T>::GetNumber(const T*  pToken)const
{
	std::map<String,String>::const_iterator it = m_map.find(String(pToken));
	if(it == m_map.end())
	{
		return 0;
	}
	std::basic_istringstream<T> istr(it->second);
	size_t value = 0;
	istr>>value;
	return value;
}


template <class T> inline void CClParser<T>::ParseToken(const String& str)
/*++

Routine Description:
 Get staring from the format /"token":"literal" and insert in into map
 when token is the key and literal is the value.

Arguments:
    str - string to parse.

Returned Value:
    None.

--*/
{
	String::const_iterator StartToken = std::find(
										str.begin(),
										str.end(),
										std::ctype<T>().widen('/')
										);

	String::const_iterator StartLiteral = std::find(
											str.begin(),
											str.end(),
											std::ctype<T>().widen(':')
											);
										
	if(StartToken == str.end() ||	StartToken !=  str.begin()  )
	{
		return;
	}
	ASSERT(StartToken <  StartLiteral);

	String token (++StartToken , StartLiteral);

	//
	// if no ':" found - the literal considered as empty string ("")
	//
	if(StartLiteral == str.end())	
	{
		m_map[token] = String();
		return;
	}
	
	m_map[token] = String(++StartLiteral, str.end());
}


template <class T> inline bool CClParser<T>::IsExists(const T* pToken)const
/*++

Routine Description:
 Check if given token is exists in the command line

Arguments:
    pToken - token to check.

Returned Value:
   true if exists - false otherwise.

--*/
{
    std::map<String,String>::const_iterator p = m_map.find(String(pToken));
    return p != m_map.end();
}


template <class T>
inline
typename CClParser<T>::String
CClParser<T>::operator[](
	const T*  pToken
	)const

/*++

Routine Description:
 Get literal for given token

Arguments:
    pToken - token.

Returned Value:
   The literal that match the token or empty string if not exists.

--*/
{
	typename std::map<String,String>::const_iterator it = m_map.find(String(pToken));
	if(it != m_map.end())
	{
		return it->second;
	}
	return String();
}




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\stsslng.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    mtsslfc.h

Abstract:
    Header for class CSSlNegotioation that implement creation of ssl connection.


Author:
    Gil Shafriri (gilsh) 23-May-2000

--*/


#ifndef __ST_SSLNG_H
#define __ST_SSLNG_H


#include <ex.h>
#include <xstr.h>
#include <autosec.h>
#include <buffer.h>

#include "stp.h"
#include "st.h"
#include "stsimple.h"

class CContextBuffer;
class CSSlConnection;
typedef  basic_xstr_t<BYTE>  xustr_t;



//---------------------------------------------------------
//
//  CHandShakeBuffer helper class Implementation
//
//---------------------------------------------------------
class  CHandShakeBuffer : private CResizeBuffer<BYTE>
{
public:
	using CResizeBuffer<BYTE>::capacity;
	using CResizeBuffer<BYTE>::resize;
	using CResizeBuffer<BYTE>::reserve;
	using CResizeBuffer<BYTE>::begin;
	using CResizeBuffer<BYTE>::free;
	using CResizeBuffer<BYTE>::size;

	enum {xReadBufferStartSize = 4096};


public:
	CHandShakeBuffer(
		) :
		CResizeBuffer<BYTE>(xReadBufferStartSize)
		{
		}

	void CreateNew()
	{
		reserve(xReadBufferStartSize);
		reset();
	}//lint !e429



	void reset()
	{
		m_pExtraData = xustr_t();
		resize(0);
	}

	const xustr_t ExtraData() const
	{
		return m_pExtraData;
	}

	void ExtraData(const xustr_t& ExData)
	{
		m_pExtraData = ExData;				
	}

private:
	xustr_t m_pExtraData;

private:
	CHandShakeBuffer(const CHandShakeBuffer&);
	CHandShakeBuffer& operator=(const CHandShakeBuffer&);
};


//---------------------------------------------------------
//
//  helper class CContextBuffer
//
//---------------------------------------------------------
class CContextBuffer
{
public:
    CContextBuffer(void* h = NULL) : m_h(h) {}

   ~CContextBuffer()
   {
		free();
   }//lint !e1740


public:
   	void*  get()const
	{
		return m_h;
	}

	void free()
	{
		if (m_h != NULL)
		{
			FreeContextBuffer(m_h);//lint !e534
		}
		m_h = NULL;
	}

    void operator=(void* h)
	{
		free();
		m_h = h;
	}
	
	
private:
    CContextBuffer(const CContextBuffer&);
    CContextBuffer& operator=(const CContextBuffer&);

private:
    void*  m_h;
};


//---------------------------------------------------------
//
//  class CSSlNegotioation
//
//---------------------------------------------------------

class  CSSlNegotioation : public EXOVERLAPPED
{
public:
	CSSlNegotioation(
		CredHandle* pCredentialsHandle,
		const xwcs_t& ServerName,
		USHORT ServerPort,
		bool fUseProxy
		);


public:
  	void
	CreateConnection(
		const std::vector<SOCKADDR_IN>& AddrList,
		EXOVERLAPPED* pOverlapped,
		SOCKADDR_IN* pConnectedAddr
		);

	void
	ReConnect(
		const R<IConnection>& SimpleConnection,
		EXOVERLAPPED* pOverlapped
		);
	

	
	xustr_t ExtraData()const
	{
		return m_pHandShakeBuffer.ExtraData();
	}

	void FreeHandShakeBuffer()
	{
		m_pHandShakeBuffer.free();
	}

	R<IConnection> virtual GetConnection();
	

private:
	SecPkgContext_StreamSizes GetSizes();
	void SetState(const EXOVERLAPPED& ovl);
	void ReadHandShakeData();
	void ReadProxyConnectResponse();
	void HandleHandShakeResponse();
	void SendStartConnectHandShake();
	void SendSslProxyConnectRequest();
	void ReadProxyConnectResponseContinute();
	void SendContinuteConnect(const void* pContext,DWORD len);
 	void SendFinishConnect(const void* pContext, DWORD len);
	void AuthenticateServer();
	void BackToCallerWithError();
	void BackToCallerWithSuccess();
    void HandShakeLoopIncompleteCredentials();
	void HankShakeLoopContinuteNeeded(void* pContext, DWORD len, SecBuffer* pSecBuffer);
	void HankShakeLoopOk(const SecBuffer Buffer[2], void* pContext, DWORD len);
	void HankShakeLoop(bool fIgnoreInputBuffers);


private:
	static void WINAPI Complete_SendSslProxyConnectRequest(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_ReadProxyConnectResponse(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_ReadHandShakeResponse(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_NetworkConnect(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_ConnectFailed(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_SendFinishConnect(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_SendHandShakeData(EXOVERLAPPED* pOvl);
	


private:
	CSSlNegotioation(const CSSlNegotioation&);
	CSSlNegotioation& operator=(const CSSlNegotioation&);


private:
    enum {
        xResponseChunkSize = 256,
        xMaxResponseSize = 0x8000 // 32 Kb
    };

    CredHandle* m_pCredentialsHandle;
	AP<WCHAR> m_pServerName;
	CContextBuffer m_SendConetext;
	CSSPISecurityContext  m_hContext;
	CHandShakeBuffer m_pHandShakeBuffer;
	R<CSSlConnection> m_pSSlConnection; 		
	EXOVERLAPPED* m_callerOvl;
	CSimpleWinsock m_SimpleWinsock;
	R<IConnection> m_SimpleConnection;
    bool   m_fServerAuthenticate;
	USHORT m_ServerPort;
	bool m_fUseProxy;
	std::string m_ProxySSlConnectRequestStr;
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\stsslrd.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    stsslrd.cpp	    

Abstract:
    implementation class CSSlReceiver declared in stsslrd.h


Author:
    Gil Shafriri (gilsh) 23-May-2000

--*/

#include <libpch.h>
#include <no.h>
#include "stsslrd.h"
#include "stp.h"
#include "stsslng.h"
#include "stsslco.h"


#include "stsslrd.tmh"

//---------------------------------------------------------
//
//  static helper  functions
//
//---------------------------------------------------------


static void SetReadCount(EXOVERLAPPED* pOvl,DWORD rcount)
{
	pOvl->InternalHigh = rcount;
}




//---------------------------------------------------------
//
//  static members callback functions
//
//---------------------------------------------------------


void WINAPI CSSlReceiver::Complete_ReceivePartialData(EXOVERLAPPED* pOvl)
/*++

Routine Description:
    Called reading server partial response completed.
  
Arguments:
    pov - pointer to overlapped structure.
  
Returned Value:
    None.

--*/
{
	ASSERT(pOvl != NULL);
	CSSlReceiver* MySelf = static_cast<CSSlReceiver*>(pOvl);
	try
	{
		MySelf->ReceivePartialData();
	}
	catch(const exception&)
	{
		MySelf->BackToCallerWithError();		
	}

}


void WINAPI CSSlReceiver::Complete_ReceiveFailed(EXOVERLAPPED* pOvl)
/*++

Routine Description:
    Called in all cases of receive error.
  
Arguments:
    pov - pointer to overlapped structure.
  
Returned Value:
    None.

--*/
{
	ASSERT(pOvl != NULL);
	CSSlReceiver* MySelf = static_cast<CSSlReceiver*>(pOvl);
	MySelf->BackToCallerWithError();	
}




//---------------------------------------------------------
//
//  non static members  functions
//
//---------------------------------------------------------



CSSlReceiver::CSSlReceiver(
						PCredHandle SecContext,
						const SecPkgContext_StreamSizes& sizes,
						CSSlNegotioation& SSlNegotioation,
						CReadWriteLockAsyncExcutor& ReadWriteLockAsyncExcutor
						):
						EXOVERLAPPED(Complete_ReceivePartialData,Complete_ReceiveFailed),
						m_DecryptionBuffer(sizes.cbMaximumMessage),
						m_SecContext(SecContext),
						m_Sizes(sizes),
						m_callerOvl(NULL),
						m_CSSlNegotioation(SSlNegotioation),
						m_ReadWriteLockAsyncExcutor(ReadWriteLockAsyncExcutor)
					
					
{
	CopyExtraData();
}


CSSlReceiver::~CSSlReceiver()
{
	//
	// ASSERT that there is no pending receive
	//
	ASSERT(m_callerOvl == 0);
}


void CSSlReceiver::IOReadMoreData()
{

	if(m_DecryptionBuffer.capacity()  == 	m_DecryptionBuffer.size())
	{
		TrTRACE(NETWORKING,"Decryption buffer needs reallocation");
		m_DecryptionBuffer.reserve(m_DecryptionBuffer.size() * 2);
		ASSERT(m_DecryptionBuffer.capacity() > 0);
	}

	SetState(EXOVERLAPPED(Complete_ReceivePartialData,Complete_ReceiveFailed));

	DWORD size = numeric_cast<DWORD>(m_DecryptionBuffer.capacity() - m_DecryptionBuffer.size());
	m_SimpleConnection->ReceivePartialBuffer(
								m_DecryptionBuffer.begin() + m_DecryptionBuffer.size(),
								size,
								this
								);

}

size_t CSSlReceiver::WriteDataToCaller()
/*++

Routine Description:
    Write decrypted data to caller buffer.
  
Arguments:
  
  
Returned Value:
Number of bytes written.

--*/
{
	        
	       
			size_t written = m_UserReceiveBuffer.Write(
							m_DecryptionBuffer.begin(),
							m_DecryptionBuffer.DecryptedSize()
							);

			if(written == 0)
			{
				return 0;
			}

			//
			// shift remaining data to the buffer start
			//

			memmove(
				m_DecryptionBuffer.begin(),
				m_DecryptionBuffer.begin() + written,
				m_DecryptionBuffer.size() - written
				);

			m_DecryptionBuffer.DecryptedSize(m_DecryptionBuffer.DecryptedSize() - written);
			m_DecryptionBuffer.resize(m_DecryptionBuffer.size() - written);

			return written;	
}

void CSSlReceiver::ReceivePartialBufferInternal(			                          
						VOID* pBuffer,                                     
						DWORD Size 
						)

{
	m_UserReceiveBuffer.CreateNew(pBuffer,Size);


	//
	// write decrypted data left out to caller
	//
	size_t written = WriteDataToCaller();
	if(written != 0)
	{
		BackToCallerWithSuccess(written);
		return;
	}

	//
	// if we still have data to decrypte - decrypte it -
	// otherwise - go read more data
	//
	if(m_DecryptionBuffer.size()> 0)
	{
		ReceivePartialDataContinute();
	}
	else
	{
		IOReadMoreData();
	}
}

void CSSlReceiver::ReceivePartialBuffer(
						const R<IConnection>& SimpleConnection,                                              
						VOID* pBuffer,                                     
						DWORD Size, 
						EXOVERLAPPED* pov
						)

/*++

Routine Description:
    Receive data from the socket. 
  
Arguments:
	SimpleConnection - Connection to read from.
	pBuffer - Caller buffer                                     
	Size - Size of the buffer 
	pov	 - Caller overlap to signal when end
  
  
Returned Value:
None

--*/
{	
	ASSERT(SimpleConnection.get() != NULL);
	ASSERT(pov != NULL);
	ASSERT(m_callerOvl == NULL);
	ASSERT(Size != 0);
	ASSERT(pBuffer != NULL);
 	m_callerOvl = pov;
	m_SimpleConnection = SimpleConnection;

	TrTRACE(NETWORKING,"Receive Partial Buffer called");


	//
	// make sure we zero caller overlapp in case of exception (to ease debugging)
	//
 	CAutoZeroPtr<EXOVERLAPPED>	AutoZeroPtr(&m_callerOvl);

 	ReceivePartialBufferInternal(pBuffer, Size);

	//
	//caller overlapp will be zero when we finish asynchronously 
	//
	AutoZeroPtr.detach();
}



SECURITY_STATUS CSSlReceiver::TryDecrypteMessage()
/*++

Routine Description:
    try to decrypte message we got. If we can decrytpte it
	(SEC_E_OK from 	DecryptMessage call) we move block in the read buffer
	so the all decrypted data is at the start and then extra ,
	non decrypted data. We throw away SSL header and trailer data.
  
Arguments:
    None.
  
Returned Value:
   return value of DecryptMessage.  

--*/


		  
{
	ASSERT(m_DecryptionBuffer.DecryptedSize() == 0);

	SecBuffer  Buffers[4];
	Buffers[0].pvBuffer     = m_DecryptionBuffer.begin();
	Buffers[0].cbBuffer     = numeric_cast<DWORD>(m_DecryptionBuffer.size());
	Buffers[0].BufferType   = SECBUFFER_DATA;

	Buffers[1].BufferType   = SECBUFFER_EMPTY;
	Buffers[2].BufferType   = SECBUFFER_EMPTY;
	Buffers[3].BufferType   = SECBUFFER_EMPTY;

	SecBufferDesc   Message;
	Message.ulVersion       = SECBUFFER_VERSION;
	Message.cBuffers        = TABLE_SIZE(Buffers);
	Message.pBuffers        = Buffers;

	SECURITY_STATUS scRet = DecryptMessage(m_SecContext, &Message, 0, NULL);
	if(scRet != SEC_E_OK)
	{
		return scRet;	
	}
 
	//
	// find data and extra (non decrypted) buffers
	//
	SecBuffer* pExtraBuffer = NULL;
	SecBuffer* pDataBuffer = NULL;
	for(DWORD i = 1; i <Message.cBuffers ; i++)
	{
		if(pExtraBuffer == NULL && Buffers[i].BufferType == SECBUFFER_EXTRA )
		{
			pExtraBuffer = &Buffers[i];
		}

		if(pDataBuffer == NULL && Buffers[i].BufferType == SECBUFFER_DATA )
		{
			pDataBuffer = &Buffers[i];
		}
	}
			
	//
	// shift decryption buffer so we have only data (no ssl header)
	//
	ASSERT(pDataBuffer != NULL);
	memmove(
		m_DecryptionBuffer.begin(),
		pDataBuffer->pvBuffer,
		pDataBuffer->cbBuffer
		);
  	m_DecryptionBuffer.DecryptedSize(pDataBuffer->cbBuffer);
	m_DecryptionBuffer.resize(m_DecryptionBuffer.DecryptedSize());


	//
	// shift extra buffer (not decrypted) just after the data
	//
	if(pExtraBuffer != NULL)
	{
		ASSERT(pExtraBuffer->pvBuffer >	pDataBuffer->pvBuffer);
		memmove(
			m_DecryptionBuffer.begin() + m_DecryptionBuffer.DecryptedSize(),
			pExtraBuffer->pvBuffer,
			pExtraBuffer->cbBuffer
			);
		m_DecryptionBuffer.resize(m_DecryptionBuffer.size() + pExtraBuffer->cbBuffer);
	}

 	return 	scRet;
}


void CSSlReceiver::ReceivePartialData()
{
/*++

Routine Description:
Called after read operation - check what we read and try to decrypt. 
  
Arguments:
    None.
  
Returned Value:
	None		

--*/
 	DWORD ReadLen = DataTransferLength(*this);
	if(ReadLen == 0)
	{
		TrERROR(NETWORKING,"Server closed the connection");
		BackToCallerWithSuccess(0);
		return;
	}
	m_DecryptionBuffer.resize(m_DecryptionBuffer.size() + ReadLen);
	ReceivePartialDataContinute();
}


void CSSlReceiver::ReceivePartialDataContinute()
/*++

Routine Description:
Called after read operation - check what we read and try to decrypt. 
  
Arguments:
    None.
  
Returned Value:
	None		

--*/
{
  	SECURITY_STATUS scRet = TryDecrypteMessage();
	size_t written; 
	switch(scRet)
	{
		//
		// read more
		//
		case SEC_E_INCOMPLETE_MESSAGE:
		IOReadMoreData();
		return;

		//
		// renegotiation
		//
		case SEC_I_RENEGOTIATE:
		Renegotiate();
		return;

		//
		// the data was decrypted ok
		//
		case SEC_E_OK:
		written = WriteDataToCaller();
		ASSERT(written != 0);
		BackToCallerWithSuccess(written);
		return;
	

		default:
		TrERROR(NETWORKING,"Could not Decrypt Message Error=%x",scRet);
		throw exception();
	}

}


void CSSlReceiver::Renegotiate()
/*++

Routine Description:
Start new ssl connection handshake. 
  
Arguments:
    None.
  
Returned Value:
	None		

--*/
{
	TrTRACE(NETWORKING,"Start Renegotiation");

	R<CReNegotioationRequest> ReNegotioationRequest = new CReNegotioationRequest(*this);

	//
	// Needs additional ref count for the async operation.
	//
	R<CReNegotioationRequest>  AsyncOperationRef = ReNegotioationRequest; 	

	m_ReadWriteLockAsyncExcutor.AsyncExecuteUnderWriteLock(ReNegotioationRequest.get());

	AsyncOperationRef.detach();
}

void CSSlReceiver::RenegotiateFailed()
{
	TrERROR(NETWORKING,"Renegotiation failed");
	BackToCallerWithError();
}


void CSSlReceiver::BackToCallerWithError()
{
	TrERROR(NETWORKING,"Receive Failed");
	StpPostComplete(&m_callerOvl,STATUS_UNSUCCESSFUL);
}


void CSSlReceiver::BackToCallerWithSuccess(size_t read)
{
	DWORD dwread = numeric_cast<DWORD>(read);
	TrTRACE(NETWORKING,"Receive Completed Ok reading %d bytes",dwread);
	SetReadCount(m_callerOvl,dwread);
	StpPostComplete(&m_callerOvl,STATUS_SUCCESS);
}


void CSSlReceiver::SetState(const EXOVERLAPPED& ovl)
{
	EXOVERLAPPED::operator=(ovl); //LINT !e530 !e534 !e1013 !e1015  	!e10
}

void CSSlReceiver::RenegotiateCompleted()
/*++

Routine Description:
ssl connection handshake. finished ok - continute reading
  
Arguments:
    None.
  
Returned Value:
	None		

--*/
{
	TrTRACE(NETWORKING,"Renegotiation Finished");
	
	m_DecryptionBuffer.reset();

	//
	//copy application data (if any) send with the negotiation
	//
	CopyExtraData();

	
	
	ReceivePartialDataContinute();
}

void CSSlReceiver::CopyExtraData()
/*++

Routine Description:
Copy application data (needs decryption !) sent from the server as part of finishing the handshake.
In theory - server can do it - in practice I have not seen it yet.
  
Arguments:
    None.
  
Returned Value:
	None		

--*/
{
	xustr_t ExtraData =  m_CSSlNegotioation.ExtraData();
	DWORD ExtraDataLen = ExtraData.Length();
	if(ExtraDataLen != 0)
	{
		TrTRACE(NETWORKING,"Copy application data sent as part of the connection negotiation");
		m_DecryptionBuffer.reserve(ExtraDataLen);
		
		//
		//copy application data from negotiation buffer (this data is application encrypted data)
		//
		memmove(
			m_DecryptionBuffer.begin(),
			ExtraData.Buffer(),
			ExtraDataLen
			);

		m_DecryptionBuffer.resize(ExtraDataLen);
	}
	m_CSSlNegotioation.FreeHandShakeBuffer();
}



void CReNegotioationRequest::Run()
/*++

Routine Description:
Start renegotiation execution.
  
Arguments:
    None.
  
Returned Value:
	None
	
Note - Run() and Close() cannot be called at the same time.
They are sync  by CReadWriteLockAsyncExcutor.

--*/
{
	m_SSlReceiver.m_CSSlNegotioation.ReConnect(m_SSlReceiver.m_SimpleConnection, this);
	m_fRun = true;
}


void CReNegotioationRequest::Close()throw()
/*++

Routine Description:
Force renegotiation callback  by explicit call back with error.

  
Arguments:
    None.
  
Returned Value:
	None		

Note - Run() and Close() cannot be called at the same time.
	They are sync  by CReadWriteLockAsyncExcutor.

  
--*/
{
	ASSERT(!m_fRun);
	SetStatus(STATUS_UNSUCCESSFUL);
	ExPostRequest(this);
}



void WINAPI  CReNegotioationRequest::Complete_RenegotiateFailed(EXOVERLAPPED* pOvl)
{
	CReNegotioationRequest* me = static_cast<CReNegotioationRequest*>(pOvl);
	R<CReNegotioationRequest> AutoDelete(me); 
	me->m_SSlReceiver.m_ReadWriteLockAsyncExcutor.UnlockWrite();

	me->m_SSlReceiver.RenegotiateFailed();
}


void WINAPI  CReNegotioationRequest::Complete_Renegotiate(EXOVERLAPPED* pOvl)
{
	CReNegotioationRequest* me = static_cast<CReNegotioationRequest*>(pOvl);
	R<CReNegotioationRequest> AutoDelete(me); 
	me->m_SSlReceiver.m_ReadWriteLockAsyncExcutor.UnlockWrite();

	try
	{
		me->m_SSlReceiver.RenegotiateCompleted();
	}
	catch(exception&)
	{
		me->m_SSlReceiver.RenegotiateFailed();		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\lib\stsslsn.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    mtsslsn.h

Abstract:
    Header for class CSSlSender sending data above ssl connection.
	The class is responsible to take caller buffers - and to send them
	encrypted chunk by chunk, over the ssl connection. The caller overlapp functions
	will be called only when all data is sent, or in case of error.



Author:
    Gil Shafriri (gilsh) 23-May-2000

--*/

#ifndef __ST_SSLSN_H
#define __ST_SSLSN_H

#include "stp.h"


class CSSlNegotioation;
class ReadWriteLockAsyncExcutor;

class CSSlSender 
{
public:
	CSSlSender(
		PCredHandle SecContext,
		const SecPkgContext_StreamSizes& sizes,
		const CSSlNegotioation& SSlNegotioation,
		CReadWriteLockAsyncExcutor& ReadWriteLockAsyncExcutor
		);


public:
	void Send(
			const R<IConnection>& SimpleConnection,                                              
			const WSABUF* Buffers,                                     
			DWORD nBuffers, 
			EXOVERLAPPED* pov
			);


private:
	friend class CSSLAsyncSend;
	void OnSendOk(CSSLAsyncSend* pSSLAsyncSend,  EXOVERLAPPED* pov);
	void OnSendFailed(CSSLAsyncSend* pSSLAsyncSend, EXOVERLAPPED* pov);


private:
	CSSlSender(const CSSlSender&);
	CSSlSender& operator=(const CSSlSender&);

private:
	PCredHandle m_SecContext;
	SecPkgContext_StreamSizes m_Sizes;
	const CSSlNegotioation& m_SSlNegotioation;
	CReadWriteLockAsyncExcutor& m_ReadWriteLockAsyncExcutor;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\test\envcreate.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envcreate.h

Abstract:
    Header for creating test envelop

Author:
    Gil Shafriri (gilsh) 07-Jan-2001

--*/


#ifndef _MSMQ_Envcreate_H_
#define _MSMQ_Envcreate_H_
std::string CreateEnvelop(const std::string& FileName,const std::string& Host,const std::string& Resource);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\test\sendbuffers.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    SendBuffers.h

Abstract:
    Header for class CSendBuffers that create delivery buffers.

Author:
    Gil Shafriri (gilsh) 07-Jan-2001

--*/


#ifndef _MSMQ_CreateBufers_H_
#define _MSMQ_CreateBufers_H_

#include <buffer.h>
#include <xstr.h>

class CSendBuffers : public CReference
{
public:
	CSendBuffers(
		const std::string& Env, 
		const std::string& Host, 
		const std::string& Resource,
		const std::string& MessageBody
		);


public:
	size_t GetNumberOfBuffers() const;
	const WSABUF* GetSendBuffers() const;
	size_t GetSendDataLength() const;
	char*  SerializeSendData() const;


private:
	void CreateMultipartHeaders(
						const std::string& Host,
						const std::string& Resource
						);


	DWORD GenerateEnvelopeAttachmentHeader(
							DWORD dataSize,
							DWORD boundaryId
							);


	DWORD GenerateMultipartAttachmentHeader(
							DWORD dataSize,
							const xstr_t& contentId,
							DWORD boundaryId
							);


	void SetBufferPointers();

private:
	std::string m_envelope;
	std::string m_MessageBody;
	std::vector<WSABUF> m_buffers;
	CResizeBuffer<char>  m_HttpRequestData;
};






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\test\sttest.cpp ===
#include <libpch.h>
#include <no.h>
#include <tr.h>
#include <ex.h>
#include <st.h>
#include <cm.h>
#include "envcreate.h"
#include "clparser.h"
#include "sendbuffers.h"
#include "senderthread.h"

#include "StTest.tmh"

using namespace std;


DWORD
AppGetBindInterfaceIp(
	void
	)
{
	return INADDR_ANY;
}


//
// test initialization
//
static void Init()
{
	TrInitialize();
	CmInitialize(HKEY_LOCAL_MACHINE, L"Software\\Microsoft", KEY_ALL_ACCESS);
	NoInitialize();
	ExInitialize(10);
    StInitialize(INADDR_ANY);
}



static void Usage()
{
	printf("Sttest [/f:envelop file] [/l] [/h:destination host] [/r:resource] [/s] [/rc:request counts] [/p:proxy name] [/pp:proxy port] [/bl:body length]\n");
	printf("Options: \n");
	printf("/f:Envelop file  - Template file for srmp envelop  - Default built in envelop \n");
	printf("/h:Target Host - Destination machine to send requests to - required \n");
	printf("/r:Resource - Resource name on the target destination machine - required \n");
	printf("/s:Use secure channel (https) - Default http \n");
	printf("/rc:Number of requests to send on each connection - Default 1 \n");
	printf("/p:Proxy name - use proxy to connect to destination host - Default, no proxy \n");
	printf("/pp:Proxy Port - port number to connect to the proxy - Default, 80 \n");
	printf("/bl:Body length in bytes - Default 1000 \n");
	printf("/l:Run in loop - default, run once \n");
	printf("Example: sttest /f:http.txt /h:gilsh015  /r:/msmq\\myqueue\n");
}



static void DoTest(const CClParser<WCHAR>& ClParser)
{
	DWORD Loops;
	if(ClParser.IsExists(L"l"))
	{
		Loops = 10000000;
	}
	else
	{
		Loops = 1;
	}
	for(DWORD i=0; i<Loops; ++i)
	{
		//
		// Run sender thread
		//
		CSenderThread SenderThread(ClParser);
		SenderThread.Run();
		SenderThread.WaitForEnd();
	}
}



extern "C" int __cdecl wmain(int argc ,WCHAR** argv)
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

 	CClParser<WCHAR> ClParser(argc, argv);
	if(!ClParser.IsExists(L"r") || !ClParser.IsExists(L"h"))
	{
		Usage();
		return -1;
	}
	try
	{
		Init();
		DoTest(ClParser);
	}
	catch(const exception& )
	{
		return -1;
	}

    WPP_CLEANUP();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\test\senderthread.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    SenderThread.h

Abstract:
    Implements class CSenderThread that sends http\https request to a server

Author:
    Gil Shafriri (gilsh) 07-Jan-2001
--*/

#include <libpch.h>
#include <st.h>
#include <tr.h>
#include "senderthread.h"
#include "SendBuffers.h"
#include "envcreate.h"
#include "stp.h"

#include "senderthread.tmh"

using namespace std;


static string WstringTostring(const wstring& wstr)
{
	string str( wstr.size(),' ');
	for(wstring::size_type i=0; i<wstr.size(); ++i)
	{
		str[i] = ctype<WCHAR>().narrow(wstr[i]);
	}
	return str;
}


//
// print server response data
//
static void DumpData(const char* data,size_t size)
{
	stringstream str;
	str.write(data,size);
	printf("ServerResponse : %s", str.str().c_str());
}



//
// return pointer in a response buffer where header ends (after \r\n\r\n") .
// 0 is returned if no header end found 
//
static size_t FindEndOfResponseHeader(const char* buf, size_t len)
{
	const char Termination[] = "\r\n\r\n";
	const char* found = search(buf, buf + len, Termination, Termination + STRLEN(Termination));
	return found == buf + len ? 0 : found + STRLEN(Termination) - buf ;
}




//
// get status code from response headers
//
static size_t GetStatus(LPCSTR p, size_t length)
{
	if(length <  STRLEN("HTTP/1.1"))
	{
		throw exception();	
	}
	istringstream statusstr(string(p + STRLEN("HTTP/1.1"),length - STRLEN("HTTP/1.1")) );
	USHORT status;
	statusstr>>status;
	if(!statusstr)
	{
		throw exception();		
	}
	return status;
}


bool IsContinuteResponse(LPCSTR p, size_t len)
{
	return GetStatus(p, len) == 100;
}



static size_t GetContentLength(LPCSTR p, size_t length)
{
	const char xContentlength[] = "Content-Length:";
	const char* found = search(
						p, 
						p + length,xContentlength, 
						xContentlength + STRLEN(xContentlength)
						);

	if(found == p + length || (found += STRLEN(xContentlength)) == p + length)
	{
		return 0;
	}

	istringstream contextLengthStr(string(found,p + length - found));
	size_t  Contentlength;
	contextLengthStr>>Contentlength;
	if(!contextLengthStr)
	{
		throw exception();		
	}
	return 	Contentlength;
}



//
// create event that test user will wait on untill test loop ends
//
static HANDLE CreateEndEvent()
{
	HANDLE event = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(event == NULL)
	{
		printf("Create event failed, Error=%d\n",GetLastError());
		throw exception();
	}
	return 	event;
}




CSenderThread::CSenderThread(
	const CClParser<WCHAR>& ClParser
	):
	EXOVERLAPPED(Complete_Connect, Complete_ConnectFailed),
	m_ClParser(ClParser),
	m_event(CreateEndEvent()),
	m_pTransport(CreateTransport()),
	m_ReadBuffer(1024),
	m_TotalRequestCount(GetTotalRequestCount()),
	m_CurrentRequestCount(0)
{

}


string CSenderThread::GenerateBody()  const
{
	size_t BodyLen =  m_ClParser.IsExists(L"bl") ? m_ClParser.GetNumber(L"bl") : xDeafultBodyLen;

	return string(BodyLen, 'a');
}


string CSenderThread::GetResource()  const
{
	wstring Resource;
	if(!m_ClParser.IsExists(L"p"))
	{
		Resource = m_ClParser[L"r"];				
	}
	else
	{
		Resource = wstring(L"HTTP://") + m_ClParser[L"h"] + m_ClParser[L"r"];
	}
	return 	WstringTostring(Resource);
}


R<CSendBuffers> CSenderThread::GetSendBuffers()	 const
{
	
	string Host =   WstringTostring(m_ClParser[L"h"]);
	string Resource = GetResource();
   	string Envelope = CreateEnvelop(WstringTostring(m_ClParser[L"f"]), Host, Resource);
	string MessageBody  = GenerateBody();

	return new CSendBuffers(Envelope,  Host, Resource, MessageBody);
}


CSenderThread::~CSenderThread()
{

}


//
// called by CStTest user after  CStTest::Run called to wait for end
//
void CSenderThread::WaitForEnd()
{
	WaitForSingleObject(m_event,INFINITE);
}


//
// Test failed - for what ever reason
//
void CSenderThread::Failed()
{
	SetEvent(m_event);
}


//
// create transport interafce - simple winsock transport or ssl transport
//
ISocketTransport* CSenderThread::CreateTransport()const
{
	if(!m_ClParser.IsExists(L"s") )
	{
		return StCreateSimpleWinsockTransport();
	}

	wstring  pServerName =  m_ClParser[L"h"];

	return StCreateSslWinsockTransport(
						xwcs_t(pServerName.c_str(), pServerName.size()),
						GetNextHopPort(),
						m_ClParser.IsExists(L"p")
						);


}



wstring CSenderThread::GetNextHop() const
{
	return m_ClParser.IsExists(L"p") ? m_ClParser[L"p"] : m_ClParser[L"h"];
}



USHORT CSenderThread::GetProtocolPort() const
{
	return m_ClParser.IsExists(L"s") ? x_DefaultHttpsPort : x_DefaultHttpPort; 
}



size_t CSenderThread::GetTotalRequestCount() const
{
	return m_ClParser.IsExists(L"rc") ? m_ClParser.GetNumber(L"rc") : xDefaultRequestCount;
}


USHORT CSenderThread::GetProxyPort() const
{
	return (USHORT)(m_ClParser.IsExists(L"pp") ? m_ClParser.GetNumber(L"pp") : xDefaultProxyPort);
}


USHORT CSenderThread::GetNextHopPort() const
{
	return m_ClParser.IsExists(L"p") ? GetProxyPort() : GetProtocolPort();
}



//
// Start running test state machine  by connecting to the server
//
void CSenderThread::Run()
{
	
	std::vector<SOCKADDR_IN> Address;
	wstring NextHop = GetNextHop();
	bool fRet = m_pTransport->GetHostByName(NextHop.c_str(), &Address); 
    if (!fRet)
    {
        printf("Failed to resolve address for '%ls'\n", NextHop.c_str());
        throw exception();
    }

	for(std::vector<SOCKADDR_IN>::iterator it = Address.begin(); it != Address.end(); ++it)
	{
		it->sin_port = htons(GetNextHopPort());		
	}

	
 	m_pTransport->CreateConnection(Address, this);
}



//
// called when connecting to the server completed - call to send request
// to the server.
//
void WINAPI CSenderThread::Complete_Connect(EXOVERLAPPED* pOvl)
{
	CSenderThread* MySelf = static_cast<CSenderThread*>(pOvl);
	MySelf->m_Connection  =  MySelf->m_pTransport->GetConnection();
	try
	{
		MySelf->SendRequest();
	}
	catch(const exception&)
	{
		MySelf->Failed();
	}
}


void CSenderThread::SetState(const EXOVERLAPPED& ovl)
{
	EXOVERLAPPED::operator=(ovl);	
}


void CSenderThread::LogRequest()const
{
	ofstream LogFile("sttest.log", ios_base::binary);
	AP<char>  AllRawData = 	m_SendBuffers->SerializeSendData();
	LogFile.write(AllRawData.get(), m_SendBuffers->GetSendDataLength());
	LogFile<<flush;
}


//
// Send request to the server
//
void CSenderThread::SendRequest()
{
	m_SendBuffers = GetSendBuffers();


	LogRequest();

	SetState(EXOVERLAPPED(Complete_SendRequest,Complete_SendFailed));
	m_ReadBuffer.resize(0);

	m_Connection->Send(
		m_SendBuffers->GetSendBuffers(), 
		numeric_cast<DWORD>(m_SendBuffers->GetNumberOfBuffers()), 
		this
		);

}

//
// sending request to the server completed - call to read response header
// 
void  WINAPI CSenderThread::Complete_SendRequest(EXOVERLAPPED* pOvl)
{
	CSenderThread* MySelf = static_cast<CSenderThread*>(pOvl);
	try
	{
		MySelf->ReadPartialHeader();
	}
	catch(const exception&)
	{
		MySelf->Failed();
	}
}

//
// called if connected to destination or proxy failed.
//
void WINAPI CSenderThread::Complete_ConnectFailed(EXOVERLAPPED* pOvl)
{
	CSenderThread* MySelf = static_cast<CSenderThread*>(pOvl);
	printf("Connect failed error %d\n",pOvl->GetStatus());
	MySelf->Failed();
}


//
// called if sending request failed.
//
void WINAPI CSenderThread::Complete_SendFailed(EXOVERLAPPED* pOvl)
{
	CSenderThread* MySelf = static_cast<CSenderThread*>(pOvl);
	printf("Send failed error %d\n", pOvl->GetStatus());
	MySelf->Failed();
}

void CSenderThread::ReadPartialHeader()
{
	SetState(EXOVERLAPPED(Complete_ReadPartialHeader , Complete_ReceiveFailed));
	ASSERT(m_ReadBuffer.capacity() >= m_ReadBuffer.size());
	if(m_ReadBuffer.capacity() == m_ReadBuffer.size())
	{
		m_ReadBuffer.reserve(m_ReadBuffer.capacity() * 2);		
	}
   
	m_Connection->ReceivePartialBuffer(
					m_ReadBuffer.begin() + m_ReadBuffer.size(),
					numeric_cast<DWORD>(m_ReadBuffer.capacity() - m_ReadBuffer.size()),
					this
					);
}


//
// called when partial response header was read - call to continure reading the
// server response header
//
void WINAPI CSenderThread::Complete_ReadPartialHeader(EXOVERLAPPED* pOvl)
{
	CSenderThread* MySelf = static_cast<CSenderThread*>(pOvl);
	try
	{
		MySelf->ReadPartialHeaderContinute();
	}
	catch(const exception&)
	{
		MySelf->Failed();
	}
}


//
// called if receiving the request failed.
//
void WINAPI CSenderThread::Complete_ReceiveFailed(EXOVERLAPPED* pOvl)
{
	CSenderThread* MySelf = static_cast<CSenderThread*>(pOvl);
	printf("Receive failed error %d\n",pOvl->GetStatus());
	MySelf->Failed();
}


//
// start reading response data
//
void CSenderThread::ReadPartialContentData()
{
	SetState(EXOVERLAPPED(Complete_ReadPartialContentData, Complete_ReceiveFailed));
	ASSERT(m_ReadBuffer.capacity() > m_ReadBuffer.size());

	m_Connection->ReceivePartialBuffer(
					m_ReadBuffer.begin() + m_ReadBuffer.size(),
					numeric_cast<DWORD>(m_ReadBuffer.capacity() - m_ReadBuffer.size()),
					this
					);
}


void CSenderThread::TestRestart()
{
	if(++m_CurrentRequestCount == m_TotalRequestCount)
	{
		Done();
	}
	else
	{
		SendRequest();
	}
}



//
// Continute to read response data
//
void CSenderThread::ReadPartialContentDataContinute()
{
	size_t read = DataTransferLength(*this);
	if(read == 0)
    {
        printf("Failed to receive response, connection was closed.\n");
        throw exception();
    }

	DumpData(m_ReadBuffer.begin() + m_ReadBuffer.size(), read);

	m_ReadBuffer.resize(m_ReadBuffer.size() + read);


	//
	// if we are done reading the data
	//
	if(m_ReadBuffer.capacity() == m_ReadBuffer.size())
	{
		TestRestart();	
		return;
	}

	//
	// read more
	//
	ReadPartialContentData();
}


//
// this cycle is done - signal test caller
//
void CSenderThread::Done()
{
	SetEvent(m_event);
}



//
// called when partial response data read completed - call to continure reading the
// server response data
//
void WINAPI CSenderThread::Complete_ReadPartialContentData(EXOVERLAPPED* pOvl)
{
	CSenderThread* MySelf = static_cast<CSenderThread*>(pOvl);
	try
	{
		MySelf->ReadPartialContentDataContinute();
	}
	catch(const exception&)
	{
		MySelf->Failed();
	}
}


void CSenderThread::HandleHeader()
{
	//
	// find out if we read all the header
	//
	size_t EndResponseHeader = FindEndOfResponseHeader(m_ReadBuffer.begin(), m_ReadBuffer.size());

	//
	// the header was not read yet - continute reading
	//
	if(EndResponseHeader == 0)
	{
		ReadPartialHeader();
		return;
	}

	if(IsContinuteResponse(m_ReadBuffer.begin(), EndResponseHeader))
	{
		size_t shiftSize = m_ReadBuffer.size() -  EndResponseHeader;
		memmove(
			m_ReadBuffer.begin(), 
			m_ReadBuffer.begin() + EndResponseHeader, 
			shiftSize
			);
		
		m_ReadBuffer.resize(shiftSize);
		HandleHeader();
		return;
	}



	//
	// start read content (if any)
	//
	size_t DataLen = GetContentLength(
		m_ReadBuffer.begin(), 
		EndResponseHeader
		);

	
	if(DataLen == 0)
	{
		TestRestart();
		return;
	}

	//
	// Get ready to read the buffer
	//
	m_ReadBuffer.reserve(DataLen);
	m_ReadBuffer.resize(0);

	ReadPartialContentData();
}



//
// Continute to readresponse header
//
void CSenderThread::ReadPartialHeaderContinute()
{
	size_t read = DataTransferLength(*this);
	if(read == 0)
    {
        printf("Failed to receive response, connection was closed.\n");
        throw exception();
    }
	DumpData(m_ReadBuffer.begin() + m_ReadBuffer.size(), read);
	m_ReadBuffer.resize(m_ReadBuffer.size() + read);

	ASSERT(m_ReadBuffer.capacity() >= m_ReadBuffer.size());
	HandleHeader();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\test\senderthread.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    SenderThread.h

Abstract:
    Header for class CSenderThread that sends http\https request to a server

Author:
    Gil Shafriri (gilsh) 07-Jan-2001
--*/


#ifndef _MSMQ_SenderThread_H_
#define _MSMQ_SenderThread_H_

#include <ex.h>
#include <buffer.h>
#include "clparser.h"

class ISocketTransport;
class CSendBuffers;

class CSenderThread : public EXOVERLAPPED
{
public:
	CSenderThread(const CClParser<WCHAR>& ClParser);
	~CSenderThread();

public:
	void Run();
	void WaitForEnd();


private:
	std::wstring GetNextHop() const;
	size_t GetTotalRequestCount() const;
	USHORT GetNextHopPort()const;
	USHORT GetProtocolPort() const;
	R<CSendBuffers> GetSendBuffers() const;
	void Failed();
	ISocketTransport*  CreateTransport()const;
	void SetState(const EXOVERLAPPED& ovl);
	USHORT GetProxyPort()const;
	void SendRequest();
	void ReadPartialHeader();
	void ReadPartialHeaderContinute();
	void ReadPartialContentDataContinute();
	void ReadPartialContentData();
	void Done();
	void TestRestart();
	void HandleHeader();
	std::string GenerateBody()const;
	std::string GetResource()  const;
 	void LogRequest()const;

private:
	static void WINAPI Complete_Connect(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_ConnectFailed(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_SendFailed(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_ReceiveFailed(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_ReadPartialHeader(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_SendRequest(EXOVERLAPPED* pOvl);
	static void WINAPI Complete_ReadPartialContentData(EXOVERLAPPED* pOvl);

private:
	CClParser<WCHAR> m_ClParser;
	CHandle m_event;
	P<ISocketTransport> m_pTransport; 
	R<IConnection> m_Connection;
	R<CSendBuffers> m_SendBuffers;
	CResizeBuffer<char> m_ReadBuffer;
	size_t m_TotalRequestCount;
	size_t m_CurrentRequestCount;


private:
	static const USHORT x_DefaultHttpsPort = 443;
	static const USHORT x_DefaultHttpPort = 80;
	static const int xDefaultProxyPort = 80;
	static const int xDefaultRequestCount = 1;
	static const int xDeafultBodyLen = 1000;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\test\sendbuffers.cpp ===
#include <libpch.h>
#include <bufutl.h>
#include <fntoken.h>
#include "sendbuffers.h"

#include "sendbuffers.tmh"

using namespace std;

#define BOUNDARY_LEADING_HYPHEN "--"
#define BOUNDARY_VALUE "MSMQ - SOAP boundary, %d "
#define GUID_STR_FORMAT "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"
const char xEnvelopeContentType[] = "text/xml";
const char xApplicationContentType[] = "application/octet-stream";
const char xMultipartContentType[] = "multipart/related";
const char xHttpHeaderTerminater[] = "\r\n\r\n";
const char xMimeBodyId[] = "body@";

static GUID s_machineId = {1234, 12, 12, 1, 1, 1, 1, 1, 1, 1, 1};
const GUID&
McGetMachineID(
    void
    )
{
    return s_machineId;
}



void CSendBuffers::CreateMultipartHeaders(
					  const string& Host,
					  const string& Resource
						)
{
	DWORD boundaryId = rand();
	ASSERT(m_buffers.size() == 0);

    DWORD totalSize = 0;
    DWORD envLen = numeric_cast<DWORD>(m_envelope.size());


	//
	// http header - is the first buffer to send. set with null values - we don't know yet it's size
	//
	WSABUF buffer;
	buffer.buf = NULL;
	buffer.len =  0;
	m_buffers.push_back(buffer);

      

	//
	// envelop header
	//
	buffer.buf = NULL;
	buffer.len =  GenerateEnvelopeAttachmentHeader(envLen, boundaryId);
	totalSize += buffer.len;
	m_buffers.push_back(buffer);

   
	//
	// Envelop body
	//
    buffer.buf = (LPSTR)m_envelope.c_str();
    buffer.len = envLen;
    totalSize += buffer.len;
	m_buffers.push_back(buffer);


	//
	// Attachment(message body) headers
	//
    buffer.buf = NULL;
    buffer.len = numeric_cast<DWORD>(GenerateMultipartAttachmentHeader(
							    numeric_cast<DWORD>(m_MessageBody.size()),
                                xstr_t(xMimeBodyId, STRLEN(xMimeBodyId)),
                                boundaryId
                                ));

    totalSize +=  buffer.len;
	m_buffers.push_back(buffer);
  

	//
	// Attachement(messages body)  body
	//
    buffer.buf = const_cast<char*>(m_MessageBody.c_str());
    buffer.len = numeric_cast<DWORD>(m_MessageBody.size());
    totalSize +=  buffer.len;
	m_buffers.push_back(buffer);



    //
    // Add boundry seperator in the end of the request
    //
    size_t n = UtlSprintfAppend(
							&m_HttpRequestData,
							BOUNDARY_LEADING_HYPHEN BOUNDARY_VALUE "\r\n", 
							boundaryId
							);


    buffer.buf = NULL;
    buffer.len = numeric_cast<DWORD>(n);
    totalSize += buffer.len;
    m_buffers.push_back(buffer);



    //
	// Set http header
	//
    m_buffers[0].len = numeric_cast<DWORD>(
						UtlSprintfAppend(
						&m_HttpRequestData,
                        "POST http://%s%s HTTP/1.1\r\n"
                        "Host: %s\r\n"
                        "Content-Type: %s; boundary=\"" BOUNDARY_VALUE "\"\r\n"
                        "Content-Length: %d\r\n"
                        "\r\n",
						Host.c_str(),
                        Resource.c_str(),
                        Host.c_str(),
                        xMultipartContentType,
                        boundaryId,
                        totalSize
                        ));


   	//
	//Now we need to fix set the send buffers to the formatted data.
	//Only at the end of the formatting we can do so - because the formatted buffers
	//can be realocated so pointer  are invalid untill the formating ends. 
	//
	SetBufferPointers();
}


DWORD
CSendBuffers::GenerateMultipartAttachmentHeader(
	DWORD dataSize,
    const xstr_t& contentId,
    DWORD boundaryId
    )
{
    const GUID* pGuid = &McGetMachineID();
    size_t n = UtlSprintfAppend(
				&m_HttpRequestData,
                BOUNDARY_LEADING_HYPHEN BOUNDARY_VALUE "\r\n"
                "Content-Type: %s\r\n"
                "Content-Length: %d\r\n"
                "Content-Id: %.*s" GUID_STR_FORMAT "\r\n"
                "\r\n",
                boundaryId,
                xApplicationContentType,
                dataSize,
                contentId.Length(), contentId.Buffer(),
                GUID_ELEMENTS(pGuid)
                );

    return numeric_cast<DWORD>(n);
}



void CSendBuffers::SetBufferPointers()
{
	ASSERT(m_buffers.size() != 0);
	size_t pos = 0;
	for(DWORD i = 1; i<m_buffers.size(); ++i)
	{
		ASSERT(pos <= m_HttpRequestData.size());
		if(m_buffers[i].buf  == NULL)
		{
			m_buffers[i].buf =	const_cast<char*>(m_HttpRequestData.begin() + pos);
			pos += m_buffers[i].len;
		}
	}
	ASSERT(m_buffers[0].buf == NULL);
	m_buffers[0].buf = const_cast<char*>(m_HttpRequestData.begin() + pos);
	pos += 	m_buffers[0].len;
	ASSERT(pos == m_HttpRequestData.size());
}	



DWORD
CSendBuffers::GenerateEnvelopeAttachmentHeader(
    DWORD dataSize,
    DWORD boundaryId
    )
{
	size_t n = UtlSprintfAppend(
				&m_HttpRequestData,
                BOUNDARY_LEADING_HYPHEN BOUNDARY_VALUE "\r\n"
                "Content-Type: %s; charset=UTF-8\r\n"
                "Content-Length: %d\r\n"
                "\r\n",
                boundaryId,
                xEnvelopeContentType,
                dataSize
                );

    return numeric_cast<DWORD>(n);
}





CSendBuffers::CSendBuffers(
				const std::string& envelope, 
				const std::string& Host, 
				const std::string& Resource,
				const string& MessageBody
				):
				m_envelope(envelope),
				m_MessageBody(MessageBody),
				m_HttpRequestData(512)
{
	CreateMultipartHeaders(Host, Resource);			
}



size_t CSendBuffers::GetNumberOfBuffers() const
{
	return m_buffers.size();
}


const WSABUF* CSendBuffers::GetSendBuffers() const
{
	return m_buffers.begin();		
}


size_t CSendBuffers::GetSendDataLength() const
{
	size_t sum = 0;
	for(std::vector<WSABUF>::const_iterator it = m_buffers.begin(); it != m_buffers.end();++it)
	{
		sum += it->len;		
	}
	return sum;	
}


char*  CSendBuffers::SerializeSendData() const
{
	size_t SendDataLength =  GetSendDataLength();
	AP<char>  SendData = new char[SendDataLength];
	char* ptr = SendData.get(); 
	for(std::vector<WSABUF>::const_iterator it = m_buffers.begin(); it != m_buffers.end();++it)
	{
		memcpy(ptr, it->buf, it->len);
		ptr += it->len;
	}
	ASSERT(numeric_cast<size_t>((ptr -  SendData.get())) == SendDataLength);
	return 	SendData.detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\st\test\envcreate.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envcreate.h

Abstract:
    Implements creating test envelop

Author:
    Gil Shafriri (gilsh) 07-Jan-2001

--*/

#include <libpch.h>
#include "envcreate.h"

#include "envcreate.tmh"

using namespace std;

static string ReadEnvelop(const string& FileName)
{
	ifstream File(FileName.c_str() ,ios_base::binary );
	if(!File.is_open())
	{
		throw exception("could not open the input file");
	}
	string Envelop;
	char c;
	while( File.get(c))
	{
		Envelop.append(1,c);		
	}
	return Envelop;
}


static string GetNewAddresElement(const string& Host,const string& Resource)
{
	return string("<to>") +
		   "http://" +
		   Host +
		   Resource +
		   "</to>";
}

static void AdjustEnvelop(const string& Host, const string& Resource, string& Envelop)
{
	const char xToOpen[] = "<to";

	string::size_type  DestinastionTagOpen =  Envelop.find(xToOpen);
	if(DestinastionTagOpen == string::npos)
	{
		throw exception("could not find destination address in the envelop");
	}
	

	const char xToClose[] = "</to>";
	string::size_type  DestinastionTagClose =  Envelop.find(xToClose);
	if(DestinastionTagClose == string::npos)
	{
		throw exception("could not find destination address in the envelop");
	}
	
	const string Address = GetNewAddresElement(Host, Resource);

	string::iterator StartReplace = Envelop.begin() + DestinastionTagOpen;
	string::iterator EndReplace = Envelop.begin() + DestinastionTagClose + sizeof(xToClose) -1;
	Envelop.replace(
				StartReplace,
				EndReplace,
				Address.begin(),  
				Address.end()
				);

}


string CreateEnvelop(const string& FileName,const string& Host, const string& Resource)
/*++

Routine Description:
  Create srmp envelop out of template envelop.

    
Arguments:
  FileName - Envelope template file name
  Host  - Destination host machine
  Resource - http resource on the destination machine (e.g : "/msmq\myqueue")
     
Returned Value:
  Deliver srmp envelop
      
--*/
{
	const char x_DeafaultEnvelop[] = "<se:Envelope xmlns:se=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns=\"http://schemas.xmlsoap.org/srmp/\"><se:Header><path xmlns=\"http://schemas.xmlsoap.org/rp/\" se:mustUnderstand=\"1\"><action>MSMQ:mqsender label</action><to>http://gilsh019/msmq/private$/s</to><id>uuid:211969@b2762491-b9bd-46af-b007-663fe062c901</id></path><properties se:mustUnderstand=\"1\"><expiresAt>20380119T031407</expiresAt><sentAt>20010620T003131</sentAt></properties><Msmq xmlns=\"msmq.namespace.xml\"><Class>0</Class><Priority>3</Priority><Correlation>AAAAAAAAAAAAAAAAAAAAAAAAAAA=</Correlation><App>0</App><BodyType>8</BodyType><HashAlgorithm>32772</HashAlgorithm><SourceQmGuid>b2762491-b9bd-46af-b007-663fe062c901</SourceQmGuid><TTrq>20010918T003131</TTrq></Msmq></se:Header><se:Body></se:Body></se:Envelope>";


	string Envelop = FileName == "" ? x_DeafaultEnvelop : ReadEnvelop(FileName.c_str());
	AdjustEnvelop(Host, Resource, Envelop);
	return Envelop;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\svc\lib\status.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Status.cpp

Abstract:
    Service status functions

Author:
    Erez Haba (erezh) 01-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Svc.h"
#include "Svcp.h"

#include "status.tmh"

//
// The service status handle
//
static SERVICE_STATUS_HANDLE s_StatusHandle = 0;

//
// The service status
//
static SERVICE_STATUS s_Status = {

	SERVICE_WIN32_OWN_PROCESS,
	SERVICE_START_PENDING,
	0,
	0,
	0,
	0,
	0,
};


VOID
SvcpSetStatusHandle(
	SERVICE_STATUS_HANDLE hStatus
	)
/*++

Routine Description:
    Captures the service Status Handle to be used latter

Arguments:
    hStatus - The service status handle

Returned Value:
    None.

--*/
{
	ASSERT(s_StatusHandle == 0);
	ASSERT(hStatus != 0);

	s_StatusHandle = hStatus;
}


inline void SetStatus(void)
{
	SvcpSetServiceStatus(s_StatusHandle, &s_Status);
}


VOID
SvcEnableControls(
	DWORD Controls
	)
/*++

Routine Description:
    Enable controls accepted by this service

Arguments:
    Controls - Controls to enable

Returned Value:
    None.

--*/
{
	SvcpAssertValid();
	s_Status.dwControlsAccepted |= Controls;
	s_Status.dwCheckPoint = 0;
	s_Status.dwWaitHint = 0;
	SetStatus();
}


VOID
SvcDisableControls(
	DWORD Controls
	)
/*++

Routine Description:
    Disable controls to prevent SCM from dispatching them to this service

Arguments:
    Controls - Controls to disable

Returned Value:
    None.

--*/
{
	SvcpAssertValid();
	s_Status.dwControlsAccepted &= ~Controls;
	s_Status.dwCheckPoint = 0;
	s_Status.dwWaitHint = 0;
	SetStatus();
}


DWORD
SvcQueryControls(
	VOID
	)
/*++

Routine Description:
    Query the current controls enabled

Arguments:
    None.

Returned Value:
    The current set of enabled controls

--*/
{
	SvcpAssertValid();
	return s_Status.dwControlsAccepted;
}


VOID
SvcReportState(
	DWORD State
	)
/*++

Routine Description:
    Report current service state to SCM

Arguments:
    State - Current service state

Returned Value:
    None.

--*/
{
	SvcpAssertValid();
	s_Status.dwCurrentState = State;
	s_Status.dwCheckPoint = 0;
	s_Status.dwWaitHint = 0;
	SetStatus();
}


DWORD
SvcQueryState(
	VOID
	)
/*++

Routine Description:
    Query last reported service state

Arguments:
    None.

Returned Value:
    Last reported service state

--*/
{
	SvcpAssertValid();
	return s_Status.dwCurrentState;
}


VOID
SvcReportProgress(
	DWORD MilliSecondsToNextTick
	)
/*++

Routine Description:
    Report a 'Pending' progress to SCM. The ProgressTick is incremented with
	every report to indicate progress. The MilliSecondsToNextTick, give the max
	time to the next progress report.

Arguments:
	ProgressTick - Tick on every report
	MilliSecondsToNextTick - Max time to next report

Returned Value:
    None.

--*/
{
	SvcpAssertValid();
    ASSERT(("Must be in pending state to report progress",
        (s_Status.dwCurrentState == SERVICE_START_PENDING) ||
        (s_Status.dwCurrentState == SERVICE_STOP_PENDING)
        ));

	++s_Status.dwCheckPoint;
	s_Status.dwWaitHint = MilliSecondsToNextTick;
	SetStatus();
}

VOID
SvcpInterrogate(
	VOID
	)
/*++

Routine Description:
    Report back when SCM interrogate the service for status.

Arguments:
	None.

Returned Value:
    None.

--*/
{
	SetStatus();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\svc\lib\sc_nt.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    sc_nt.cpp

Abstract:
    Service control API's

Author:
    Erez Haba (erezh) 03-Aug-99

Environment:
    Windows NT

--*/

#include <libpch.h>
#include <mqexception.h>
#include "Svc.h"
#include "Svcp.h"

#include "sc_nt.tmh"

static BOOL g_fUseDummyServiceCtrl = FALSE;


static void UseDummyServiceCtrl()
{
	g_fUseDummyServiceCtrl = TRUE;
}


static BOOL UsingDummyServiceCtrl()
{
	return g_fUseDummyServiceCtrl;
}


VOID
SvcpStartServiceCtrlDispatcher(
	CONST SERVICE_TABLE_ENTRY* pServiceStartTable
	)
/*++

Routine Description:
    Forwarding the call to SCM StartServiceCtrlDispatcher. If the function
	fails a bad_alloc exception is raise.

	If failed to connect this function forward the call to the dummy SCM.
    This is to enable running the service as an executable.

Arguments:
    pServiceStartTable - The service Start table, that holds the service name
		and the Service main function.

Returned Value:
    None.

--*/
{
	if(::StartServiceCtrlDispatcher(pServiceStartTable))
        return;

    DWORD gle = GetLastError();
	if(gle != ERROR_FAILED_SERVICE_CONTROLLER_CONNECT)
	{
	    TrERROR(GENERAL, "Failed to start control dispatcher. Error=%d", gle);
	    throw bad_win32_error(gle);
    }

	UseDummyServiceCtrl();
	SvcpStartDummyCtrlDispatcher(pServiceStartTable);
}


VOID
SvcpRegisterServiceCtrlHandler(
	LPHANDLER_FUNCTION pHandler
	)
/*++

Routine Description:
    Forwarding the call to SCM RegisterServiceCtrlHandler.

	In debug builds this function forward the call to the dummy SCM, in case
	the connection to the NT SCM fails. This is to enable running the service
	as an executable.

Arguments:
    pHandler - The service handler function

Returned Value:
    None.

--*/
{
	if(UsingDummyServiceCtrl())
	{
		SvcpSetStatusHandle(SvcpRegisterDummyCtrlHandler(pHandler));
		return;
	}

	SERVICE_STATUS_HANDLE hStatus = ::RegisterServiceCtrlHandler(L"", pHandler);
	if(hStatus == 0)
	{
        DWORD gle = GetLastError();
		TrERROR(GENERAL, "Failed to register service control handler. Error=%d", gle);
		throw bad_win32_error(gle);
	}

	SvcpSetStatusHandle(hStatus);
}


VOID
SvcpSetServiceStatus(
	SERVICE_STATUS_HANDLE hStatus,
	LPSERVICE_STATUS pServiceStatus
	)
/*++

Routine Description:
    Forwarding the call to SCM SetServiceStatus.

	In debug builds this function forward the call to the dummy SCM, in case
	the connection to the NT SCM fails. This is to enable running the service
	as an executable.

Arguments:
    hStatus - The status handle
	pServiceStatus - The service reported status

Returned Value:
    None.

--*/
{
	if(UsingDummyServiceCtrl())
	{
		SvcpSetDummyStatus(hStatus, pServiceStatus);
		return;
	}

	if(::SetServiceStatus(hStatus, pServiceStatus))
        return;

    DWORD gle = GetLastError();
    TrERROR(GENERAL, "Failed to set service status. Error=%d", gle);
	throw bad_win32_error(gle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\svc\lib\svcdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    SvcDebug.cpp

Abstract:
    Service debugging

Author:
    Erez Haba (erezh) 18-Jun-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Svc.h"
#include "Svcp.h"

#include "svcdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Service state
//
void SvcpAssertValid(void)
{
    //
    // SvcInitalize() has *not* been called. You should initialize the
    // Service library before using any of its funcionality.
    //
    ASSERT(SvcpIsInitialized());

    //
    // TODO:Add more Service validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void SvcpSetInitialized(void)
{
    LONG fSvcAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Service library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fSvcAlreadyInitialized);
}


BOOL SvcpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
/*
const DebugEntry xDebugTable[] = {

    {
        "SvcDumpState(queue path name)",
        "Dump Service State to debugger",
        DumpState
    ),

    //
    // TODO: Add Service debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void SvcpRegisterComponent(void)
{
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\svc\lib\sc_dummy.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    sc_dummy.cpp

Abstract:
    Dummy Service Controller

Author:
    Erez Haba (erezh) 03-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <conio.h>
#include <mqexception.h>
#include "Svc.h"
#include "Svcp.h"

#include "sc_dummy.tmh"

//
// Dummy Status handle value to pass and accept fromt he service
//
const SERVICE_STATUS_HANDLE xDummyStatusHandle = reinterpret_cast<SERVICE_STATUS_HANDLE>(0x12345678);

//
// Dummy Service Name to be passed to ServiceMain
//
static LPWSTR s_ServiceName = L"Dummy";

//
// Service Controls handler (set by sevice call to RegisterServiceCtrlHandler)
//
static LPHANDLER_FUNCTION s_pServiceHandler = 0;

//
// Last service reported status as captured by our Dummy SCM
//
static SERVICE_STATUS s_LastStatus = { 0 };



static void Usage()
{
	printf(	"\n"
			"+-- Service Controls --+\n"
			"|                      |\n"
			"| S: Stop              |\n"
			"| P: Pause             |\n"
			"| D: shutDown          |\n"
			"| C: Continue          |\n"
			"| I: Interrogate       |\n"
			"|                      |\n"
			"+-- Manager Controls --+\n"
			"|                      |\n"
			"| Q: Quit              |\n"
			"| L: Print Last status |\n"
			"|                      |\n"
			"+----------------------+");
}


//
// Convert a State value to state text
//
static const char* StateText(DWORD State)
{
	char const* const xStateText[] = {
		"*invalid*",
		"Stopped",
		"Starting",
		"Stopping",
		"Running",
		"Continuing",
		"Pausing",
		"Paused",
	};

	if(State > SERVICE_PAUSED)
	{
		State = 0;
	}

	return xStateText[State];
}


//
// Convert Controls value to controls text
//
static const char* ControlsText(DWORD Controls)
{
	char const* const xControlsText[] = {
		"none",
		"Stop",
		"Pause,Continue",
		"Stop,Pause,Continue",
		"Shutdown",
		"Shutdown,Stop",
		"Shutdown,Pause,Continue",
		"Shutdown,Stop,Pause,Continue",
		"*unknown*",
		"*unknown*,Stop",
		"*unknown*,Pause,Continue",
		"*unknown*,Stop,Pause,Continue",
		"*unknown*,Shutdown",
		"*unknown*,Shutdown,Stop",
		"*unknown*,Shutdown,Pause,Continue",
		"*unknown*,Shutdown,Stop,Pause,Continue",
	};

	const DWORD xControlAllowed =
		SERVICE_ACCEPT_STOP |
		SERVICE_ACCEPT_PAUSE_CONTINUE |
		SERVICE_ACCEPT_SHUTDOWN;

	if((Controls & ~xControlAllowed) != 0)
	{
		Controls = 0x8 | (Controls & xControlAllowed);
	}

	return xControlsText[Controls];
}


//
// Print the service state and accepted controls
//
static void PrintStatus(LPSERVICE_STATUS p)
{
	printf(
		"\nStatus: state=(%d) %s, accepts=(0x%x) %s",
		p->dwCurrentState,
		StateText(p->dwCurrentState),
		p->dwControlsAccepted,
		ControlsText(p->dwControlsAccepted)
		);
}


//
// Print the 'Pending' progress information
//
static void PrintProgress(LPSERVICE_STATUS p)
{
	printf(
		", tick=%d, wait=%dms",
		p->dwCheckPoint,
		p->dwWaitHint
		);
}


//
// Pring last service reported status
//
static void PrintLastStatus()
{
	PrintStatus(&s_LastStatus);
	PrintProgress(&s_LastStatus);
}


//
// Print an input indicated, showing the this Dummy SCM accepts input
//
static void PrintInputSign()
{
	printf(" >");
}


static void ContinueService()
{
	if((s_LastStatus.dwControlsAccepted & SERVICE_ACCEPT_PAUSE_CONTINUE) == 0)
	{
		printf("\nService does not accepts Continue control");
		return;
	}

	if(s_LastStatus.dwCurrentState != SERVICE_PAUSED)
	{
		printf("\nService is not paused, can not continue");
		return;
	}

	s_pServiceHandler(SERVICE_CONTROL_CONTINUE);
}


static void StopService()
{
	if((s_LastStatus.dwControlsAccepted & SERVICE_ACCEPT_STOP) == 0)
	{
		printf("\nService does not accepts Stop control");
		return;
	}

	if((s_LastStatus.dwCurrentState != SERVICE_PAUSED) &
	   (s_LastStatus.dwCurrentState != SERVICE_RUNNING))
	{
		printf("\nService is not running or paused, can not stop");
		return;
	}

	s_pServiceHandler(SERVICE_CONTROL_STOP);
}


static void ShutdownService()
{
	if((s_LastStatus.dwControlsAccepted & SERVICE_ACCEPT_SHUTDOWN) == 0)
	{
		printf("\nService does not accepts Shutdown control");
		return;
	}

	if(s_LastStatus.dwCurrentState == SERVICE_STOPPED)
	{
		printf("\nService already stopped, meaningless shutdown");
		return;
	}

	s_pServiceHandler(SERVICE_CONTROL_SHUTDOWN);
}


static void PauseService()
{
	if((s_LastStatus.dwControlsAccepted & SERVICE_ACCEPT_PAUSE_CONTINUE) == 0)
	{
		printf("\nService does not accepts Pause control");
		return;
	}

	if(s_LastStatus.dwCurrentState != SERVICE_RUNNING)
	{
		printf("\nService is not running, can not pause");
		return;
	}

	s_pServiceHandler(SERVICE_CONTROL_PAUSE);
}


static void InterrogateService()
{
	s_pServiceHandler(SERVICE_CONTROL_INTERROGATE);
}


static
DWORD
WINAPI
ServiceControlThread(
	LPVOID /*pParameter*/
	)
/*++

Routine Description:
    This thread controls the service. It accepts console commands and dispatchs
	the control to the service handler.

Arguments:
    None.

Returned Value:
    None.

--*/
{
	Usage();

	for(;;)
	{
		PrintInputSign();

		switch(_getche())
		{
			case 'c':
			case 'C':
				ContinueService();
				break;

			case 's':
			case 'S':
				StopService();
				break;

			case 'd':
			case 'D':
				ShutdownService();
				break;

			case 'p':
			case 'P':
				PauseService();
				break;

			case 'i':
			case 'I':
				InterrogateService();
				break;

			case 'l':
			case 'L':
				PrintLastStatus();
				break;

			case 'q':
			case 'Q':
				ExitProcess(0);

			default:
				Usage();
		}
	}
	return 0;
}


VOID
SvcpStartDummyCtrlDispatcher(
	CONST SERVICE_TABLE_ENTRY* pServiceStartTable
	)
/*++

Routine Description:
    Dummy service control dispatcher, emulates SCM StartServiceCtrlDispatcher.
	This function spawns a thread to run the service controller, and then goes
	and call ServiceMain

Arguments:
    pServiceStartTable - A Size 2 Table, that contains the service name
		and the Service main function.

Returned Value:
    None.

--*/
{
	ASSERT(pServiceStartTable[0].lpServiceName !=0);
	ASSERT(pServiceStartTable[0].lpServiceProc !=0);
	ASSERT(pServiceStartTable[1].lpServiceName ==0);
	ASSERT(pServiceStartTable[1].lpServiceProc ==0);

	DWORD ThreadID;
	HANDLE hThread = ::CreateThread(0, 0, ServiceControlThread, 0, 0, &ThreadID);

	if(hThread == NULL)
	{
        DWORD gle = GetLastError();
		TrERROR(GENERAL, "Failed to create dummy control dispatcher thread. Error=%d", gle);
		throw bad_win32_error(gle);
	}

	CloseHandle(hThread);

	//
	// Call service main funciton
	//
	pServiceStartTable[0].lpServiceProc(1, &s_ServiceName);
}


SERVICE_STATUS_HANDLE
SvcpRegisterDummyCtrlHandler(
	LPHANDLER_FUNCTION pHandler
	)
/*++

Routine Description:
    Dummy service control registration, emulates SCM RegisterServiceCtrlHandler.
	The service handler function is stored for further use by the dispatcher.

Arguments:
    pHandler - The service handler function

Returned Value:
    A Dummy service status handle (fixed value)

--*/
{
	ASSERT(s_pServiceHandler == 0);
	ASSERT(pHandler != 0);

	s_pServiceHandler = pHandler;

	return xDummyStatusHandle;
}


VOID
SvcpSetDummyStatus(
	SERVICE_STATUS_HANDLE hStatus,
	LPSERVICE_STATUS pServiceStatus
	)
/*++

Routine Description:
    Dummy service status report, emulates SCM SetServiceStatus.
	The service status is captured for further use by the dispatcher.
	The reported status or progress is displayed on the console.

Arguments:
    hStatus - A Dummy service status handle (fixed value)
	pServiceStatus - The service reported status

Returned Value:
    None.

--*/
{
	ASSERT(hStatus == xDummyStatusHandle);
	DBG_USED(hStatus);

	s_LastStatus = *pServiceStatus;
	if(s_LastStatus.dwCheckPoint == 0)
	{
		PrintStatus(&s_LastStatus);
		PrintInputSign();
	}
	else
	{
		printf(".");
	}
}


VOID
SvcpSetDummyServiceName(
    LPCWSTR DummyServiceName
    )
/*++

Routine Description:
    Sets Dummy service name. The dummy SCM does not have an external way
	to retrive the service name. Thus, during initialization the applicaion
    passes the preferd name.

Arguments:
    DummySericeName - The default name for the service.

Returned Value:
    None.

--*/
{
    //
    // We have to cast away constness as the service interface is detemined by
    // SCM. Neverhteless this parameter is only passed to AppRun which its
    // interface pases a const string
    //
    s_ServiceName = const_cast<LPWSTR>(DummyServiceName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\svc\lib\svcmain.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    SvcMain.cpp

Abstract:
    Service Main function

Author:
    Erez Haba (erezh) 01-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Svc.h"
#include "Svcp.h"

#include "svcmain.tmh"

static
VOID
WINAPI
SvcpHandler(
	DWORD Control
	)
/*++

Routine Description:
    The Service handle routine. Handles any commands comming in from SCM by
	dispatching the appropriate AppXXX function. Only Interrogate is
	implemented by this service library. all AppXXX functions should be
	overriden by the service implementation.

Arguments:
    Control - The service control

Returned Value:
    None.

--*/
{
	try
	{
		SvcpAssertValid();

		switch(Control)
		{
			case SERVICE_CONTROL_STOP:
				AppStop();
				break;

			case SERVICE_CONTROL_PAUSE:
				AppPause();
				break;

			case SERVICE_CONTROL_CONTINUE:
				AppContinue();
				break;

			case SERVICE_CONTROL_INTERROGATE:
				SvcpInterrogate();
				break;

			case SERVICE_CONTROL_SHUTDOWN:
				AppShutdown();
				break;

			default:
				ASSERT(("Unexpected Service Control 0x%x", 0));
		}
	}
	catch (const exception&)
	{
		TrERROR(GENERAL, "Unhandled exception was caught in SvcpHandler");
	}
}


VOID
WINAPI
SvcpServiceMain(
	DWORD /*argc*/,
	LPTSTR* argv
	)
/*++

Routine Description:
    The Service main routine. As soon as the service start running this function
	is called by the SCM. This funciton register the Controls handler and calls
	the AppRun function, which returns only after the service stops.

Arguments:
	argc - number of parameters
	argv - parameter list. (the first one is the service name)

Returned Value:
    None.

--*/
{
	try
	{
		SvcpAssertValid();
		SvcpRegisterServiceCtrlHandler(SvcpHandler);
		AppRun(argv[0]);
	}
	catch (const exception&)
	{
		TrERROR(GENERAL, "Unhandled exception was caught in SvcpServiceMain");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\svc\lib\svcinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    SvcInit.cpp

Abstract:
    Service initialization

Author:
    Erez Haba (erezh) 01-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Svc.h"
#include "Svcp.h"

#include "svcinit.tmh"

const SERVICE_TABLE_ENTRY xDispatchTable[2] =
{
	{L"", SvcpServiceMain},
	{0, 0}
};



VOID
SvcInitialize(
    LPCWSTR DummyServiceName
    )
/*++

Routine Description:
    Initializes Service library, This function does not actually returns until the service terminates.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the Service library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!SvcpIsInitialized());
    SvcpRegisterComponent();

    SvcpSetDummyServiceName(DummyServiceName);

	//
	// Since the Control Dispatcher does not return until the service
	// actually terminates. Svc library state is set to initialized here
	// to prevent any other calls before termination.
	//
    SvcpSetInitialized();

	//
	// Start the control dispatcher. This function does not return until
	// the service terminates.
	//
	SvcpStartServiceCtrlDispatcher(xDispatchTable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\svc\lib\svcp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Svcp.h

Abstract:
    Service private functions.

Author:
    Erez Haba (erezh) 01-Aug-99

--*/

#pragma once

#ifndef _MSMQ_Svcp_H_
#define _MSMQ_Svcp_H_

#ifdef _DEBUG

void SvcpAssertValid(void);
void SvcpSetInitialized(void);
BOOL SvcpIsInitialized(void);
void SvcpRegisterComponent(void);

#else // _DEBUG

#define SvcpAssertValid() ((void)0)
#define SvcpSetInitialized() ((void)0)
#define SvcpIsInitialized() TRUE
#define SvcpRegisterComponent() ((void)0)

#endif // _DEBUG


//
// Service Controller Manager interfaces
//
VOID
SvcpStartServiceCtrlDispatcher(
	CONST SERVICE_TABLE_ENTRY* pServiceStartTable
	);

VOID
SvcpRegisterServiceCtrlHandler(
	LPHANDLER_FUNCTION pHandler
	);

VOID
SvcpSetStatusHandle(
	SERVICE_STATUS_HANDLE hStatus
	);


//
// Dummy Service Controller Manager
//
VOID
SvcpSetDummyServiceName(
    LPCWSTR DummyServiceName
    );

VOID
SvcpStartDummyCtrlDispatcher(
	CONST SERVICE_TABLE_ENTRY* pServiceStartTable
	);

SERVICE_STATUS_HANDLE
SvcpRegisterDummyCtrlHandler(
	LPHANDLER_FUNCTION pHandler
	);

VOID
SvcpSetDummyStatus(
	SERVICE_STATUS_HANDLE hStatus,
	LPSERVICE_STATUS pServiceStatus
	);


//
// Status interfaces
//
VOID
SvcpSetServiceStatus(
	SERVICE_STATUS_HANDLE hStatus,
	LPSERVICE_STATUS pServiceStatus
	);

VOID
SvcpInterrogate(
	VOID
	);


//
// Service Main fucntion
//
VOID
WINAPI
SvcpServiceMain(
	DWORD dwArgc,
	LPTSTR* lpszArgv
	);

#endif // _MSMQ_Svcp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\svc\test\app.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    App.cpp

Abstract:
    Service Application stub functions

Author:
    Erez Haba (erezh) 01-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Svc.h"

#include "app.tmh"

VOID
AppRun(
	LPCWSTR /*ServiceName*/
	)
/*++

Routine Description:
    Stub implementation for application Run function. It should immidiatly
	report it state and enable the controls it accepts.

Arguments:
    Service name

Returned Value:
    None.

--*/
{
	SvcReportState(SERVICE_RUNNING);

	SvcEnableControls(
		SERVICE_ACCEPT_STOP |
		SERVICE_ACCEPT_PAUSE_CONTINUE |
		SERVICE_ACCEPT_SHUTDOWN
		);
}


VOID
AppStop(
	VOID
	)
/*++

Routine Description:
    Stub implementation for application Stop function. It should immidiatly
	report it state back, and take the procedure to stop the service

Arguments:
    None.

Returned Value:
    None.

--*/
{
	SvcReportState(SERVICE_STOPPED);
}


VOID
AppPause(
	VOID
	)
/*++

Routine Description:
    Stub implementation for application Pause function. It should immidiatly
	report it state back, and take the procedure to pause the service

Arguments:
    None.

Returned Value:
    None.

--*/
{
	SvcReportState(SERVICE_PAUSE_PENDING);

	for(int i = 1; i < 100; i++)
	{
		SvcReportProgress(3000);
		Sleep(2000);
	}

	SvcReportState(SERVICE_PAUSED);
}


VOID
AppContinue(
	VOID
	)
/*++

Routine Description:
    Stub implementation for application Continue function. It should immidiatly
	report it state back, and take the procedure to contineu the service from
	a paused state.

Arguments:
    None.

Returned Value:
    None.

--*/
{
	SvcReportState(SERVICE_RUNNING);
}


VOID
AppShutdown(
	VOID
	)
{
	SvcReportState(SERVICE_STOPPED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\tm\lib\tmconfig.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Tmap.cpp

Abstract:
    Transport Manager - Configuration routine

Author:
    Uri Habusha (urih) 29-Feb-2000

Environment:
    Platform-independent

--*/
#include <libpch.h>
#include <timetypes.h>
#include <Cm.h>
#include "Tmp.h"
#include "tmconset.h"

#include "tmconfig.tmh"

static CTimeDuration s_remoteResponseTimeout;
static CTimeDuration s_remoteCleanupTimeout;


static DWORD s_SendWindowinBytes;

void 
TmpGetTransportTimes(
    CTimeDuration& ResponseTimeout,
    CTimeDuration& CleanupTimeout
    )
{
    ResponseTimeout = s_remoteResponseTimeout;
    CleanupTimeout = s_remoteCleanupTimeout;
}

void 
TmpGetTransportWindow(
    DWORD& SendWindowinBytes
    )
{
   SendWindowinBytes = s_SendWindowinBytes;
}
    
static void InitTransportTimeouts(void)
{
    CmQueryValue(
        RegEntry(NULL, L"HttpResponseTimeout", 2 * 60 * 1000),   // 2 minutes
        &s_remoteResponseTimeout
        );
                      
    
    CmQueryValue(
        RegEntry(NULL, L"HttpCleanupInterval", 2 * 60 * 1000),  // 2 minutes
        &s_remoteCleanupTimeout
        );

    //
    // Cleanup timeout should be greater than the response timeout, otherwise
    // the transport can be removed before receive the response
    //
    s_remoteCleanupTimeout = max(s_remoteCleanupTimeout, s_remoteResponseTimeout);
}

static void InitTransportWindows(void)
{
    CmQueryValue(
        RegEntry(NULL, L"SendWindowinBytes", 200000),
        &s_SendWindowinBytes
        );
}



void TmpInitConfiguration(void)
{
    InitTransportTimeouts();
    InitTransportWindows();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\tm\lib\tmconset.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    tmconset.h

Abstract:
    Header file for internet connection setting

Author:
    Gil Shafriri (gilsh) 03-May-00

--*/

#pragma once

#ifndef _MSMQ_CONSET_H_
#define _MSMQ_CONSET_H_

#include <xstr.h>



//
// class resposible for proxy setting
//
class CProxySetting
{
public:
	typedef std::list<std::wstring> BypassList;
	CProxySetting(LPCWSTR proxyServerUrl, LPCWSTR pBypassListStr);


public:
	const xwcs_t ProxyServerName() const
	{
		return m_ProxyServerName;
	}

	USHORT ProxyServerPort() const
	{
		return m_ProxyServerPort;
	}
	bool IsProxyRequired(const xwcs_t& pMachineName) const;

private:
	CProxySetting(const CProxySetting&);
	CProxySetting& operator=(const CProxySetting&);

private:
	AP<WCHAR> m_proxyServer;
	xwcs_t m_ProxyServerName;
	USHORT m_ProxyServerPort;
	std::list<std::wstring> m_BypassList;
};


CProxySetting* TmGetProxySetting();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\svc\test\svctest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    SvcTest.cpp

Abstract:
    Service library test

Author:
    Erez Haba (erezh) 01-Aug-99

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Svc.h"

#include "SvcTest.tmh"

static void Usage()
{
    printf("Usage: SvcTest\n");
    printf("\n");
    printf("Example, SvcTest\n");
    exit(-1);

} // Usage


extern "C" int __cdecl _tmain(int argc, LPCTSTR /*argv*/[])
/*++

Routine Description:
    Test Service library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	TrInitialize();

    if(argc != 1)
    {
        Usage();
    }

    try
    {
        SvcInitialize(L"SvcTest");
    }
    catch(const exception&)
    {
        //
        // Failed to start the service. If failed to connect, we shouldn't get
        // here as the service starts up using the dummy SCM. Therfore if we
        // get an exception the test completes with failure status
        //
        return -1;
    }

    WPP_CLEANUP();
    return 0;

} // _tmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\tm\lib\tmconset.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    tmconset.cpp

Abstract:
    connection setting classes inpmementation (tmconset.h)

Author:
    Gil Shafriri (gilsh) 8-Aug-2000

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <strutl.h>
#include <tr.h>
#include "TmWinHttpProxy.h"
#include "tmconset.h"
#include "Tm.h"
#include "tmp.h"

#include "tmconset.tmh"

static P<CProxySetting> s_ProxySetting;  

static
bool 
IsInternalMachine(const xwcs_t& pMachineName)
/*++

Routine Description:
    Check if a given machine is internal machine in the intranet (proxy not needed) 

Arguments:
	const xwcs_t& pMachineName - machine name.    
    
Return Value:
    true if the machine is internal false if not.
	
Note :
When this function returns false it actually means "I dont know". Only machine name
that is not dns name(has '.') is 100% internal.
--*/
{
	const WCHAR*  start = pMachineName.Buffer();
	const WCHAR*  end = pMachineName.Buffer() + pMachineName.Length();
   	
	//
	// Could not find '.' in the name - so it is internal machine
	//
	return  std::find(start , end, L'.') == end;
}



static
void 
CreateBypassList(
			LPCWSTR pBypassListStr, 
			std::list<std::wstring>* pBypassList
			)
/*++

Routine Description:
    Creates bypass list of names (patterns) that connection to them should not be via proxy.
	It creates it from a given string of names seperated by ';'

Arguments:
	IN - pBypassListStr - list of names(patterns) seperated by ';'   
    
Return Value:
	List of strings parsed from pBypassListStr.  

--*/
{
	if(pBypassListStr == NULL)
		return;

	LPCWSTR end = pBypassListStr + wcslen(pBypassListStr);
	LPCWSTR ptr = pBypassListStr;

	while(ptr !=  end)
	{
		LPCWSTR found = std::find(ptr, end, L';');
		if(found == end)
		{
			pBypassList->push_back(std::wstring(ptr, end));
			return;
		}
		pBypassList->push_back(std::wstring(ptr, found));
		ptr = ++found;
	}
}


static
void
CrackProxyName(
	LPCWSTR proxyServer,
	xwcs_t* pHostName,
	USHORT* pPort
	)
/*++

Routine Description:
   Crack proxy name  of the format machine:port to machine name and port.

Arguments:
    proxyServer - pointer to proxy server string from the format machine:port

    hostName - pointer to x_str structure, that will contains the proxy machine name

    
    port - pointer to USHORT that will contain the port  number.
	       if proxyServer does not contains port number - default port 80 is returned.  
    
Return Value:
    None.

--*/
{
	const WCHAR* start =  proxyServer;
	const WCHAR* end =  proxyServer + wcslen(proxyServer);

	const WCHAR* found = std::find(start , end, L':');
	if(found != end)
	{
		*pHostName = xwcs_t(start, found - start);
		*pPort = numeric_cast<USHORT>(_wtoi(found + 1));
		if(*pPort == 0)
		{
			TrERROR(
				NETWORKING,
				"the proxy port in %ls is invalid, use default port %d ",
				proxyServer,
				xHttpDefaultPort
				);

			*pPort = xHttpDefaultPort;
		}
		return;
	}

	*pHostName  = xwcs_t(start, end - start);
	*pPort = xHttpDefaultPort;
}


CProxySetting::CProxySetting(
						LPCWSTR proxyServer,
						LPCWSTR pBypassListStr
						):
						m_proxyServer(newwcs(proxyServer))
													
{
	CreateBypassList(pBypassListStr, &m_BypassList); 
	CrackProxyName(m_proxyServer, &m_ProxyServerName , &m_ProxyServerPort); 
}



bool CProxySetting::IsProxyRequired(const xwcs_t& pMachineName) const
/*++

Routine Description:
    Check if proxy is needed for connecting the given machine.
   
Arguments:
    pMachineName - machine name


Return Value:
    true if proxy is needed false if not.

Note : 
The function check one by one the bypass list and try to find match.
If match found - proxy is not needed (false is returned).

There is one exception - if in the bypass list we have the string "<local>"
It means that we should not use proxy if the given address is local (not dns).
--*/
{
	BypassList::const_iterator it;
	for(it = m_BypassList.begin(); it!= m_BypassList.end(); ++it)
	{
		//
		// if found the special string <local>  check if the machine is in the intranet
		// if so - we don't need proxy.
		//
		if(_wcsicmp(L"<local>", it->c_str() ) == 0)
		{
			bool fInternal = IsInternalMachine(pMachineName);
			if(fInternal)
				return false;


			continue;
		}

		//
		// Simple regural expression match - if match don't use proxy
		//
		bool fMatch = UtlSecIsMatch(
								pMachineName.Buffer(),
								pMachineName.Buffer() + pMachineName.Length(),
								it->c_str(),
								it->c_str() + it->size(),
								UtlCharNocaseCmp<WCHAR>()
								);

	   if(fMatch)
		   return false;

	}
	return true;
}



CProxySetting* TmGetProxySetting()
{
	return GetWinhttpProxySetting();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\tm\lib\tm.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Tm.cpp

Abstract:
    Transport Manager general functions

Author:
    Uri Habusha (urih) 16-Feb-2000

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <wininet.h>
#include <mqwin64a.h>
#include <mqexception.h>
#include <Mc.h>
#include <xstr.h>
#include <mt.h>
#include <qal.h>
#include "Tm.h"
#include "Tmp.h"
#include "tmconset.h"

#include "tm.tmh"

const WCHAR xHttpScheme[] = L"http";
const WCHAR xHttpsScheme[] = L"https";

//
// BUGBUG: is \\ legal sepeartor in url?
//						Uri habusha, 16-May-2000
//
const WCHAR xHostNameBreakChars[] = L";:@?/\\";
const USHORT xHttpsDefaultPort = 443;




static const xwcs_t CreateEmptyUri()
{
	static const WCHAR xSlash = L'/';
	return xwcs_t(&xSlash , 1);
}

void
CrackUrl(
    LPCWSTR url,
    xwcs_t& hostName,
    xwcs_t& uri,
    USHORT* port,
	bool* pfSecure
    )
/*++

Routine Description:
    Cracks an URL into its constituent parts.

Arguments:
    url - pointer to URL to crack. The url is null terminated string. Url must be fully decoded

    hostName - refrence to x_str structure, that will contains the begining of the
               host name in the URL and its length

    uri - refrence to x_str structure, that will contains the begining of the
          uri in the URL and its length

    port - pointer to USHORT that will contain the port number

Return Value:
    None.

--*/
{
    ASSERT(url != NULL);

	URL_COMPONENTSW urlComponents;
	memset( &urlComponents, 0, sizeof(urlComponents));

	urlComponents.dwStructSize = sizeof(urlComponents);
	urlComponents.dwSchemeLength    = -1;
    urlComponents.dwHostNameLength  = -1;
    urlComponents.dwUrlPathLength   = -1;
	
	if( !InternetCrackUrl( url, 0, 0, &urlComponents) )
	{
        DWORD gle = GetLastError();
        TrTRACE(NETWORKING, "InternetCrackUrl failed with error %!winerr!", gle);
        throw bad_win32_error(gle);		
	}
	
    if( urlComponents.dwSchemeLength <= 0 || NULL == urlComponents.lpszScheme)
    {
        TrTRACE(NETWORKING, "Unknown URI scheme during URI cracking");
        throw bad_win32_error( ERROR_INTERNET_INVALID_URL );
    }

	*pfSecure = !_wcsnicmp(urlComponents.lpszScheme, xHttpsScheme, STRLEN(xHttpsScheme));

	//
	// copy the host name from URL to user buffer and add terminted
	// string in the end
	//
    hostName = xwcs_t(urlComponents.lpszHostName, urlComponents.dwHostNameLength);

	//
	// get the port number
	//
    *port = numeric_cast<USHORT>(urlComponents.nPort);


    if ( !urlComponents.dwUrlPathLength )
    {
        uri = CreateEmptyUri();
    }
    else
    {
        uri = xwcs_t(urlComponents.lpszUrlPath, urlComponents.dwUrlPathLength);
    }
}



static
CProxySetting*
GetNextHopInfo(
    LPCWSTR queueUrl,
    xwcs_t& targetHost,
    xwcs_t& nextHop,
    xwcs_t& nextUri,
    USHORT* pPort,
	USHORT* pNextHopPort,
	bool* pfSecure
    )
{
    CrackUrl(queueUrl, targetHost, nextUri, pPort,pfSecure);

    if( targetHost.Length() <= 0 )
    {
        throw bad_win32_error( ERROR_INTERNET_INVALID_URL );
    }

	P<CProxySetting>  ProxySetting =  TmGetProxySetting();
    if (ProxySetting.get() == 0 || !ProxySetting->IsProxyRequired(targetHost))
    {
        //
        // The message should be delivered directly to the target machine
        //
        nextHop = targetHost;
		*pNextHopPort =  *pPort;
        return ProxySetting.detach();
    }

    //
    // The message should deliver to proxy. Update the nextHop to be the proxy server
    // name, the port is the proxy port and the URI is the destination url
    //
    nextHop = ProxySetting->ProxyServerName();
    if( nextHop.Length() <= 0 )
    {
        throw bad_win32_error( ERROR_INTERNET_INVALID_URL );
    }

	*pNextHopPort  =  ProxySetting->ProxyServerPort();

	//
	// if we are working with http(secure) we put full url in the request
	// because the proxy will  not change it (It is encrypted).
	// It will be accepted on the target as if not proxy exists.
	//
	if(!(*pfSecure))
	{
		nextUri = xwcs_t(queueUrl, wcslen(queueUrl));
	}
	return ProxySetting.detach();
}


VOID
TmCreateTransport(
    IMessagePool* pMessageSource,
	ISessionPerfmon* pPerfmon,
	LPCWSTR url
    )
/*++

Routine Description:
    Handle new queue notifications. Let the message transport

Arguments:
    pQueue - The newly created queue
    Url - The Url the queue is assigned to

Returned Value:
    None.

--*/
{
    TmpAssertValid();

    ASSERT(url != NULL);
    ASSERT(pMessageSource != NULL);

    xwcs_t targetHost;
    xwcs_t nextHop;
    xwcs_t nextUri;
    USHORT port;
	USHORT NextHopPort;
	bool fSecure;

    //
    // Check if we have an outbound mapping for target url
    //
    AP<WCHAR> sTargetUrl;
    if( QalGetMapping().GetOutboundQueue(url, &sTargetUrl) )
    {
        url = sTargetUrl.get();
    }

    //
    // Get the host, uri and port information
    //
    P<CProxySetting> ProxySetting =  GetNextHopInfo(url, targetHost, nextHop, nextUri, &port, &NextHopPort, &fSecure);

	TmpCreateNewTransport(
			targetHost,
			nextHop,
			nextUri,
			port,
			NextHopPort,
			pMessageSource,
			pPerfmon,
			url,
			fSecure
			);
	
}


VOID
TmTransportClosed(
    LPCWSTR url
    )
/*++

Routine Description:
    Notification for closing connection. Removes the transport from the
    internal database and checkes if a new transport should be created (the associated
    queue is in idle state or not)

Arguments:
    Url - The endpoint URL, must be a uniqe key in the database.

Returned Value:
    None.

--*/
{
    TmpAssertValid();

    TrTRACE(NETWORKING, "AppNotifyTransportClosed. transport to: %ls", url);

    TmpRemoveTransport(url);
}



VOID
TmPauseTransport(
	LPCWSTR queueUrl
    )	
/*++

Routine Description:
    Pause spesifc transport by call the Pause method of the transport.

Arguments:
    queueUrl - Transport url

Returned Value:
    None.

--*/
{
	TmpAssertValid();

    TrTRACE(NETWORKING, "TmPauseTransport called to pause transport %ls", queueUrl);

	R<CTransport> Transport = TmGetTransport(queueUrl);	
	if(Transport.get() == NULL)
		return;
	
	Transport->Pause();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\tm\lib\tminit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    TmInit.cpp

Abstract:
    HTTP transport manager initialization

Author:
    Uri Habusha (urih) 03-May-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Tm.h"
#include "Tmp.h"

#include "tminit.tmh"

VOID
TmInitialize(
    VOID
    )
/*++

Routine Description:
    Initializes HTTP transport manager library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the HTTP transport manager library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!TmpIsInitialized());
    TmpRegisterComponent();

    TmpInitConfiguration();

    TmpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\tm\lib\tmdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    TmDebug.cpp

Abstract:
    HTTP transport manager debugging

Author:
    Uri Habusha (urih) 03-May-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Tm.h"
#include "Tmp.h"

#include "tmdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate HTTP transport manager state
//
void TmpAssertValid(void)
{
    //
    // TmInitalize() has *not* been called. You should initialize the
    // HTTP transport manager library before using any of its funcionality.
    //
    ASSERT(TmpIsInitialized());

    //
    // TODO:Add more HTTP transport manager validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void TmpSetInitialized(void)
{
    LONG fTmAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The HTTP transport manager library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fTmAlreadyInitialized);
}


BOOL TmpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
/*
const DebugEntry xDebugTable[] = {

    {
        "TmDumpState(queue path name)",
        "Dump HTTP transport manager State to debugger",
        DumpState
    ),

    //
    // TODO: Add HTTP transport manager debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void TmpRegisterComponent(void)
{
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\tm\lib\tmwinhttpproxy.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    TmWinHttpProxy.H

Abstract:
    Header that  exposes API  for getting proxy setting information using winhttp
	proxy setting for a machine in the registry.

Author:
    Gil Shafriri (gilsh) 15-April-2001

--*/
#ifndef _MSMQ_WINHTTPPROXY_H_
#define _MSMQ_WINHTTPPROXY_H_

class CProxySetting;
CProxySetting* GetWinhttpProxySetting();



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\tm\lib\tmp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Tmp.h

Abstract:
    HTTP transport manager private functions.

Author:
    Uri Habusha (urih) 03-May-00

--*/

#pragma once

#ifndef _MSMQ_Tmp_H_
#define _MSMQ_Tmp_H_

#include <xstr.h>

const USHORT xHttpDefaultPort = 80;


#ifdef _DEBUG

void TmpAssertValid(void);
void TmpSetInitialized(void);
BOOL TmpIsInitialized(void);
void TmpRegisterComponent(void);

#else // _DEBUG

#define TmpAssertValid() ((void)0)
#define TmpSetInitialized() ((void)0)
#define TmpIsInitialized() TRUE
#define TmpRegisterComponent() ((void)0)

#endif // _DEBUG

void 
TmpInitConfiguration(
    void
    );


void 
TmpSetWebProxy(
    LPCWSTR proxyUrl,
	LPCWSTR pByPassList
    );


void 
TmpGetTransportTimes(
    CTimeDuration& ResponseTimeout,
    CTimeDuration& CleanupTimeout
    );

void 
TmpGetTransportWindow(
    DWORD& SendWindowinBytes
    );

void 
TmpRemoveTransport(
    LPCWSTR url
    );


class IMessagePool;
class ISessionPerfmon;

void
TmpCreateNewTransport(
    const xwcs_t& targetHost,
    const xwcs_t& nextHop,
    const xwcs_t& uri,
    USHORT port,
	USHORT nextHopPort,
    IMessagePool* pMessageSource,
	ISessionPerfmon* pPerfmon,
    LPCWSTR queueUrl,
	bool fSecure
    );

#endif // _MSMQ_Tmp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\tr\lib\trdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    TrDebug.cpp

Abstract:
    Tracing debugging

Author:
    Erez Haba (erezh) 06-Jan-99

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>

#ifdef _DEBUG

//
// Support ASSERT_BENIGN
// The default true for this value, so ASSERT_BENIGN will not create the false impression of asserting
// while it is not. The applicaiton may set this value directly;
//
bool g_fAssertBenign = true;

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\tm\lib\tmmap.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    TmMap.cpp

Abstract:
    URL to Transport mapping

Author:
    Uri Habusha (urih) 19-Jan-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Tm.h"
#include "Mt.h"
#include "rwlock.h"
#include "stlcmp.h"
#include "timetypes.h"
#include "Tmp.h"

#include "tmmap.tmh"

using namespace std;

typedef map<WCHAR*, R<CTransport>, CFunc_wcscmp> TMAP;

static TMAP s_transports;
static CReadWriteLock s_rwlock;


inline
TMAP::iterator
TmpFind(
    LPCWSTR url
    )
{
    return s_transports.find(const_cast<WCHAR*>(url));
}


void 
TmpRemoveTransport(
    LPCWSTR url
    )
/*++

Routine Description:
    Remove a transport from the transport database

Arguments:
    url - The endpoint URL, must be a uniqe key in the database.

Returned Value:
    None.

--*/
{
    CSW writeLock(s_rwlock);

    TMAP::iterator it = TmpFind(url);

    //
    // The transport can be removed with the same name more than once
    // see comment below at TmpCreateNewTransport.
    //
    if(it == s_transports.end())
        return;

    TrTRACE(NETWORKING, "RemoveTransport. transport to : 0x%p", &it->second);

    delete [] it->first;
    s_transports.erase(it);
}


R<CTransport>
TmGetTransport(
    LPCWSTR url
    )
/*++

Routine Description:
    Find a transport by a url in the database

Arguments:
    url - The endpoint URL.

Returned Value:
    None.

--*/
{
    TmpAssertValid();
    
    CSR readLock(s_rwlock);

    TrTRACE(NETWORKING, "TmGetTransport. url: %ls", url);

    TMAP::iterator it = TmpFind(url);

    if(it == s_transports.end())
        return NULL;

    return it->second;
}


void
TmpCreateNewTransport(
    const xwcs_t& targetHost,
    const xwcs_t& nextHop,
    const xwcs_t& nextUri,
    USHORT targetPort,
	USHORT nextHopPort,
    IMessagePool* pMessageSource,
	ISessionPerfmon* pPerfmon,
    LPCWSTR queueUrl,
	bool fSecure
    )
{
    //
    // The state of the map isn't consistence until the function
    // is completed (add a null transport for place holder). Get the CS to 
    // insure that other process doesn't enumerate the data structure during this time
    //
    CSW writeLock(s_rwlock);

    TrTRACE(NETWORKING, "TmNotifyNewQueue. url: %ls, queue: 0x%p", queueUrl, pMessageSource);

    //
    // Add the url to the map. We do it before creating the transport to inssure 
    // that after creation we always success to add the new transport to the data 
    // structure (place holder)
    //
    AP<WCHAR> mapurl = newwcs(queueUrl);
    pair<TMAP::iterator, bool> pr = s_transports.insert(TMAP::value_type(mapurl, NULL));

    TMAP::iterator it = pr.first;

    if (! pr.second)
    {
        //
        // BUGBUG: The queue can close while it has an active message transport. As
        //         a result the CQueueMgr moved the queue from the group and remove it. 
        //         Now the Tm is asked to create mt for this queue but it already has a one.  
        //         So the Tm release the previous transport before creating a new one.
        //         When we will have a Connection Cordinetor we need to handle it better
        //                          Uri Habusha, 16-May-2000
        //
        delete [] it->first;            
        s_transports.erase(it);

        pr = s_transports.insert(TMAP::value_type(mapurl, NULL));

        it = pr.first;
        ASSERT(pr.second);
    }

    mapurl.detach();

    try
    {
        //
        // Get transport timeouts
        //
        CTimeDuration responseTimeout;
        CTimeDuration cleanupTimeout;
 
        DWORD SendWindowinBytes;

        TmpGetTransportTimes(responseTimeout, cleanupTimeout);

        TmpGetTransportWindow(SendWindowinBytes);

        //
        // Replace the NULL transport in place holder, with the created transport
        //
        it->second = MtCreateTransport(
                                targetHost,
                                nextHop, 
                                nextUri, 
                                targetPort, 
								nextHopPort,
                                queueUrl,
                                pMessageSource, 
								pPerfmon,
                                responseTimeout, 
                                cleanupTimeout,
								fSecure,
                                SendWindowinBytes
                                );
    }
    catch(const exception&)
    {
        //
        // Remove the place holder from the map
        //
        delete [] it->first;            
        ASSERT(it->second.get() == NULL);

        s_transports.erase(it);

        throw;
    }

    TrTRACE(
        NETWORKING, 
        "Created message transnport (pmt = 0x%p), target host = %.*ls, next hop = %.*ls, port = %d, uri = %.*ls",
        (it->second).get(),
        LOG_XWCS(targetHost),
        LOG_XWCS(nextHop), 
        nextHopPort,
        LOG_XWCS(nextUri)
        );
}


R<CTransport>
TmFindFirst(
    void
    )
/*++

Routine Description:
    Find first transport in s_transports. The function returns a pointer to the
    CTransport, from which the caller can get the transport state and URL.
    
    The caller must release the transport reference count

Arguments:
    None..

Returned Value:
    Pointer to CTransport. NULL is returned If the map is empty.

--*/
{
    TmpAssertValid();
        
    CSR readLock(s_rwlock);

    if(s_transports.empty())
        return NULL;

    return s_transports.begin()->second;
}


R<CTransport>
TmFindLast(
    void
    )
/*++

Routine Description:
    Find last transport in s_transports. The function returns a pointer to the
    CTransport, from which the caller can get the transport state and URL.
    
    The caller must release the transport reference count

Arguments:
    None..

Returned Value:
    Pointer to CTransport. NULL is returned If the map is empty.

--*/
{
    TmpAssertValid();
        
    CSR readLock(s_rwlock);

    if(s_transports.empty())
        return NULL;

    return s_transports.rbegin()->second;
}


R<CTransport>
TmFindNext(
    const CTransport& transport
    )
/*++

Routine Description:
    Find next transport in s_transport.

Arguments:
    transport - reference to transport.

Returned Value:
    The next CTransport in the database. NULL is returned if there is no more data

--*/
{
    TmpAssertValid();

    
    CSR readLock(s_rwlock);

    TMAP::iterator it = s_transports.upper_bound(const_cast<WCHAR*>(transport.QueueUrl()));

    //
    // No element found
    //
    if(it == s_transports.end())
        return NULL;

    return it->second;
}


R<CTransport>
TmFindPrev(
    const CTransport& transport
    )
/*++

Routine Description:
    Find prev transport in s_transport.

Arguments:
    transport - reference to transport.

Returned Value:
    The prev CTransport in the database. NULL is returned if there is no more data

--*/
{
    TmpAssertValid();

    
    CSR readLock(s_rwlock);

    TMAP::iterator it = s_transports.lower_bound(const_cast<WCHAR*>(transport.QueueUrl()));

    //
    // No element found
    //
    if(it == s_transports.begin())
        return NULL;

    --it;

    return it->second;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\tm\test\tmtest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    TmTest.cpp

Abstract:
    Transport manager library test

Author:
    Uri Habusha (urih) 19-Jan-00

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <Tm.h>
#include <Cm.h>
#include <Mt.h>
#include <msi.h>
#include <spi.h>
#include "timetypes.h"

#include "Tmp.h"

#include "TmTest.tmh"

const IID GUID_NULL = {0};

class CQueueAlias
{
public:
    CQueueAlias(){}

	bool
	GetInboundQueue(LPCWSTR ,LPWSTR* ) const;

    bool
    GetOutboundQueue(LPCWSTR, LPWSTR* ) const;

	bool
	GetStreamReceiptURL(LPCWSTR, LPWSTR* ) const;

    bool
    GetDefaultStreamReceiptURL(LPWSTR* ) const;

private:	
	CQueueAlias& operator=(const CQueueAlias&);
	CQueueAlias(const CQueueAlias&);
};

bool CQueueAlias::GetOutboundQueue(LPCWSTR, LPWSTR* ) const { return false;}
bool CQueueAlias::GetInboundQueue(LPCWSTR ,LPWSTR* ) const { return false;}
bool CQueueAlias::GetStreamReceiptURL(LPCWSTR, LPWSTR* ) const{ return false;}
bool CQueueAlias::GetDefaultStreamReceiptURL(LPWSTR* ) const{ return false;}

CQueueAlias temp;
CQueueAlias& QalGetMapping(void){return temp;}

class CGroup : public IMessagePool
{
public:
    CGroup() :
        IMessagePool()
    {
        AddRef();
    }

    ~CGroup()
    {
    }


    void Requeue(CQmPacket* )
    {
        throw exception();
    }


    void EndProcessing(CQmPacket*, USHORT)
    {
        throw exception();
    }

    void LockMemoryAndDeleteStorage(CQmPacket* )
    {
        throw exception();
    }

    void GetFirstEntry(EXOVERLAPPED* , CACPacketPtrs& )
    {
        throw exception();
    }

    void CancelRequest(void)
    {
        throw exception();
    }
};


class CTestTransport : public CTransport
{
public:
    CTestTransport(
        LPCWSTR queueUrl
        ) :
        CTransport(queueUrl)
    {
    }

    LPCWSTR ConnectedHost(void) const
    {
        return 0;
    }


    LPCWSTR ConnectedUri(void) const
    {
        return 0;
    }


    USHORT ConnectedPort(void) const
    {
        return 0;
    }

	void Pause(void)
	{
	}

};


R<CTransport>
MtCreateTransport(
    const xwcs_t&,
    const xwcs_t&,
    const xwcs_t&,
    USHORT,
	USHORT,
    LPCWSTR queueUrl,
	IMessagePool*,
	ISessionPerfmon*,
	const CTimeDuration&,
    const CTimeDuration&,
	bool,
    DWORD
    )
{
    return new CTestTransport(queueUrl);
}



static BOOL s_fCanCloseQueue = TRUE;

void CmQueryValue(const RegEntry&, CTimeDuration* pValue)
{
   *pValue = CTimeDuration(rand());
}

void CmQueryValue(const RegEntry&, DWORD* pValue)
{
   *pValue = 0;
}


void CmQueryValue(const RegEntry&, BYTE** ppData, DWORD* plen)
{
	const DWORD xSize = 100;
	AP<BYTE> pData = new BYTE[xSize];
	memset(pData,'a', xSize);
	*ppData = pData.detach();
	*plen =  xSize;
}



void TmpInitConfiguration(void)
{
    NULL;
}


void
TmpGetTransportTimes(
    CTimeDuration& ResponseTimeout,
    CTimeDuration& CleanupTimeout
    )
{
    ResponseTimeout = CTimeDuration(rand());
    CleanupTimeout = CTimeDuration(rand());
}


void
TmpGetTransportWindow(
    DWORD& SendWindowinBytes
    )
{
   SendWindowinBytes = rand();
}

const WCHAR* xQueueUrl[] = {
    L"http://m1:8889/ep1",
    L"http://m2/ep1",
    L"http://m3:9870/ep1/tt/ll lll ll",
    L"http://m4.ntdev.microsoft.com/ep1",
    L"http://m2/ep1$",
    L"http://m1/ep1$"
    };


void CheckError(bool f, DWORD line)
{
    if (f)
        return;

    TrERROR(NETWORKING, "Failed. Error in line %d", line);
    exit(1);
}


extern "C" int  __cdecl _tmain(int /*argc*/, LPCTSTR /*argv*/[])
/*++

Routine Description:
    Test Transport manager library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	TrInitialize();

    TmInitialize();

    //
    // Add transport to TM
    //
    TmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xQueueUrl[0]);

    //
    // Get first transport in TM.
    //
    R<CTransport> tr = TmFindFirst();
    CheckError((tr.get() != NULL), __LINE__);
    CheckError((wcscmp(tr->QueueUrl(), xQueueUrl[0]) == 0), __LINE__);

    //
    // Get previous transport. Should failed since there is only one transport
    //
    R<CTransport> tr2 = TmFindPrev(*tr.get());
    CheckError((tr2.get() == NULL), __LINE__);

    //
    // remove the transport from Tm map
    //
    TmTransportClosed(tr->QueueUrl());
    tr.free();

    //
    // Add new transport
    //
    TmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xQueueUrl[1]);

    //
    // Get pointer to the transport. So afterwards teh test can ask the next and prev
    //
    tr = TmFindFirst();
    CheckError((tr.get() != NULL), __LINE__);
    CheckError((wcscmp(tr->QueueUrl(), xQueueUrl[1]) == 0), __LINE__);


    //
    // add new transports to Tm map
    //
    TmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xQueueUrl[0]);
    TmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xQueueUrl[2]);

    //
    // Get previous transport
    //
    tr2 = TmFindPrev(*tr.get());
    CheckError((tr2.get() != NULL), __LINE__);
    CheckError((wcscmp(tr2->QueueUrl(), xQueueUrl[0]) == 0), __LINE__);
    tr2.free();


    //
    // remove the added transports
    TmTransportClosed(tr->QueueUrl());

    R<CTransport> tr1 = TmGetTransport(xQueueUrl[2]);
    TmTransportClosed(tr1->QueueUrl());

    //
    // Find the previous transport of non-existing transport
    //
    tr2 = TmFindPrev(*tr.get());
    CheckError((tr2.get() != NULL), __LINE__);
    CheckError((wcscmp(tr2->QueueUrl(), xQueueUrl[0]) == 0), __LINE__);
    tr2.free();

    //
    // Find the next transport of non-existing transport
    //
    tr2 = TmFindNext(*tr.get());
    CheckError((tr2.get() == NULL), __LINE__);

    tr.free();


    //
    // Add new transports to Tm
    //
    TmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xQueueUrl[1]);
    TmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xQueueUrl[2]);
    TmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xQueueUrl[3]);

    //
    // Enumerate the transport in order
    //
    DWORD i = 0;
    for(tr = TmFindFirst(); tr.get() != NULL; tr = TmFindNext(*tr.get()), ++i)
    {
        CheckError((wcscmp(tr->QueueUrl(), xQueueUrl[i]) == 0), __LINE__);
    }


    //
    // Close transports
    //
    R<CTransport> tr3 = TmGetTransport(xQueueUrl[3]);
    TmTransportClosed(tr3->QueueUrl());

    R<CTransport> tr4 = TmGetTransport(xQueueUrl[0]);
    TmTransportClosed(tr4->QueueUrl());

    R<CTransport> tr5 = TmGetTransport(xQueueUrl[2]);
    TmTransportClosed(tr5->QueueUrl());


    //
    // Find the first transport in Tm map, that is the only one
    //
    tr = TmFindFirst();
    CheckError((tr.get() != NULL), __LINE__);
    CheckError((wcscmp(tr->QueueUrl(), xQueueUrl[1]) == 0), __LINE__);
    tr.free();

    //
    // Close the queue, but act like there is message in the queue
    //
    s_fCanCloseQueue = FALSE;
    R<CTransport> tr6 = TmGetTransport(xQueueUrl[1]);
    TmTransportClosed(tr6->QueueUrl());

    tr = TmFindFirst();
    CheckError((tr.get() == NULL), __LINE__);

    TmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xQueueUrl[4]);
    TmCreateTransport(R<CGroup>(new CGroup).get(), NULL, xQueueUrl[5]);

    tr = TmGetTransport(xQueueUrl[4]);
    CheckError((tr.get() != NULL), __LINE__);
    tr.free();

    TrTRACE(NETWORKING, "Test passed successfully...");

    WPP_CLEANUP();
    return 0;
}

BOOL
McIsLocalComputerName(
	LPCSTR /*host*/
	)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\tm\lib\tmwinhttpproxy.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    TmWinHttpProxy.cpp

Abstract:
    Implementing CreateWinhhtpProxySetting function (TmWinHttpProxy.h)

Author:
    Gil Shafriri (gilsh) 15-April-2001

--*/
#include <libpch.h>
#include <wininet.h>
#include <cm.h>
#include <utf8.h>
#include "TmWinHttpProxy.h"
#include "tmconset.h"
#include "tmp.h"
#include "TmWinHttpProxy.tmh"

//
// Class for reading winhhtp proxy blob information
//
class CProxyBlobReader
{
public:
	CProxyBlobReader(
		const BYTE* blob, 
		DWORD len
		):
		m_blob(blob),
		m_len(len),
		m_offset(0)
		{
		}


	//
	// Read data from the proxy blob and increament read location
	//
	void  Read(void* pData,  DWORD len)	throw(std::out_of_range)
	{
		if(m_len - m_offset < len)
		{
			TrERROR(NETWORKING,"Invalid proxy setting block in registry");
			throw std::out_of_range("");
		}
		memcpy(pData, m_blob + 	m_offset, len);
		m_offset += len;
	}

	//
	// Read string from the proxy blob and increament the read location
	// String is formatted as length (4 bytes) and after that the string data.
	//
	void ReadStr(char** ppData)throw(std::out_of_range, std::bad_alloc)
	{
		DWORD StrLen;
		Read(&StrLen, sizeof(DWORD));
		AP<char> Str = new char[StrLen +1];
		Read(Str.get(), StrLen);
	   	Str[StrLen] ='\0';
		*ppData = Str.detach();
	}

	
private:
	const BYTE* m_blob;
	DWORD m_len;
	DWORD m_offset;
};



CProxySetting* GetWinhttpProxySetting()
/*++

Routine Description:
    Get proxy setting by reading winhttp proxy information from the registry.
	This information is set by proxycfg.exe tool

Arguments:
      None
	  
Return Value:
    Pointer to CProxySetting object.

--*/
{
	const WCHAR* xPath = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections";
	const WCHAR* xValueName = L"WinHttpSettings";

	RegEntry ProySettingRegName(
				xPath,
				xValueName,
				0,
                RegEntry::Optional,
                HKEY_LOCAL_MACHINE
                );


	AP<BYTE> ProxySettingBlob;
	DWORD len = 0;
    CmQueryValue(ProySettingRegName, &ProxySettingBlob, &len);
	if(len == 0)
	{
		return NULL;
	}		  

	//
	// Parse the proxy blob - throw non relevent data abd keep
	// proxy name and bypaslist
	//
 	CProxyBlobReader BlobReader(ProxySettingBlob, len);
	AP<char>  BypassList;
	AP<char> Proxy;
	try
	{		    
		DWORD StructSize;
		BlobReader.Read(&StructSize, sizeof(DWORD));

		DWORD CurrentSettingsVersion;
		BlobReader.Read(&CurrentSettingsVersion, sizeof(DWORD));

		DWORD Flags;
		BlobReader.Read(&Flags, sizeof(DWORD));
		if(!(Flags & PROXY_TYPE_PROXY))
			return NULL;


		BlobReader.ReadStr(&Proxy);
		BlobReader.ReadStr(&BypassList);
	}
	catch(const std::exception&)
	{
		return NULL;
	}

	AP<WCHAR> wcsProxy = UtlUtf8ToWcs((utf8_char*)Proxy.get());
	AP<WCHAR> wcsProxyBypass = UtlUtf8ToWcs((utf8_char*)BypassList.get());
	return new CProxySetting(wcsProxy, wcsProxyBypass);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\tr\lib\dbgrpt.cpp ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:
    dbgrpt.cpp

Abstract:
    Assertion functions (the best functions ever :))

Author:
    Erez Haba (erezh) 30-Apr-2001

--*/


#include <libpch.h>
#include <signal.h>

#include <strsafe.h>

//
// Assertion length constants
//
const int xMaxBoxLineLength = 64;
const int xMaxMessageLength = 1024;

#define MAILTO_MSG \
    "<mailto:msmqbugs@microsoft.com>"

//
// Assert box text
//
#define ASSERT_BOX_CAPTION \
    "Message Queuing"

#define ASSERT_BOX_HEADER_MSG \
    "Debug Assertion Failed!\n\n"

#define TOO_LONG_BOX_MSG \
    "Cannot display debug information. String is too long or an I/O error.\n"

#define ASSERT_BOX_FOOTER_MSG \
    "\n" \
    "\n" \
    "Please send this information to Message Queuing support  \n" \
     MAILTO_MSG "\n" \
    "\n" \
    "(Press Retry to debug the application)"

#define STRING_TOO_LONG_BOX_MSG  ASSERT_BOX_HEADER_MSG TOO_LONG_BOX_MSG ASSERT_BOX_FOOTER_MSG


//
// Debugger output text
//
#define STRING_TOO_LONG_DBG_MSG \
    "\n*** Assertion failed! " MAILTO_MSG "***\n\n"


static
int
TrpMessageBoxA(
    const char* Text,
    const char* Caption,
    unsigned int Type
    )
/*++

Routine Description:
    Load and display the assert messagae box.
    Use a dynamic load not to force static linking with user32.dll.
    This will leak the user32 dll in case of assertion, but who cares

Arguments:
    Text - The text to display in the box
    Caption - The messagae box title
    Type - The message box type attributes

Returned Value:
    The message box result, or 0 in case the box can not be loaded. 

--*/
{
    typedef int (APIENTRY * PFNMESSAGEBOXA)(HWND, LPCSTR, LPCSTR, UINT);
    static PFNMESSAGEBOXA pfnMessageBoxA = NULL;

    if (NULL == pfnMessageBoxA)
    {
        HINSTANCE hlib = LoadLibraryA("user32.dll");

        if (NULL == hlib)
            return 0;
        
        pfnMessageBoxA = (PFNMESSAGEBOXA) GetProcAddress(hlib, "MessageBoxA");
        if(NULL == pfnMessageBoxA)
            return 0;
    }

    return (*pfnMessageBoxA)(NULL, Text, Caption, Type);
}


static
bool
TrpAssertWindow(
    const char* FileName,
    unsigned int Line,
    const char* Text
    )
/*++

Routine Description:
    Format and display the assert box. This function aborts the applicaiton if
    required so.
    This function is called if no debugger is attached and kernel debugger
    not specified

Arguments:
    FileName - The assert file location
    Line - The assert line location
    Text - The assert text to display

Returned Value:
    true, if the user asked to break into the debugger;
    false if to ignore the assertion

--*/
{
    //
    // Shorten program name
    //
    HRESULT hr;
    char szExeName[MAX_PATH];
    szExeName[MAX_PATH -1] = '\0';
    if (!GetModuleFileNameA(NULL, szExeName, MAX_PATH - 1))
    {
        hr = StringCchCopyA(szExeName, TABLE_SIZE(szExeName), "<program name unknown>");
        ASSERT(SUCCEEDED(hr));

    }
    
    char *szShortProgName = szExeName;
    if (strlen(szShortProgName) > xMaxBoxLineLength)
    {
    	size_t size = strlen(szShortProgName);
        szShortProgName +=  size - xMaxBoxLineLength;
        hr = StringCchCopyA(szShortProgName, (TABLE_SIZE(szExeName) - size + xMaxBoxLineLength), "...");
        ASSERT(SUCCEEDED(hr));        
    }

    char szOutMessage[xMaxMessageLength];
    hr = StringCchPrintfA(
                szOutMessage,
                TABLE_SIZE(szOutMessage),
                ASSERT_BOX_HEADER_MSG
                "Program: %s\n"
                "File: %s\n"
                "Line: %u\n"
                "\n"
                "Expression: %s\n"
                ASSERT_BOX_FOOTER_MSG,
                szShortProgName,
                FileName,
                Line,
                Text
                );

    if(FAILED(hr))
    {
        C_ASSERT(TABLE_SIZE(STRING_TOO_LONG_BOX_MSG) < TABLE_SIZE(szOutMessage));

        hr = StringCchCopyA(szOutMessage, TABLE_SIZE(szOutMessage), STRING_TOO_LONG_BOX_MSG);
        ASSERT(SUCCEEDED(hr));
    }

    //
    // Display the assertion
    //
    // Use,
    //      MB_SYSTEMMODAL
    //      Put the box always on top of all windows
    //
    //      MB_DEFBUTTON2
    //      Retry is the default button, to prevent accidental termination of the process
    //      by keystroke
    //
    //      MB_SERVICE_NOTIFICATION
    //      Make the box appear even if the service is not interactive with the desktop
    //
    int nCode = TrpMessageBoxA(
                    szOutMessage,
                    ASSERT_BOX_CAPTION,
                    MB_SYSTEMMODAL |
                        MB_ICONHAND |
                        MB_ABORTRETRYIGNORE | 
                        MB_SERVICE_NOTIFICATION |
                        MB_DEFBUTTON2
                    );

    //
    // Abort: abort the plrogram by rasing an abort signal
    //
    if (IDABORT == nCode)
    {
        raise(SIGABRT);
    }

    //
    // Ignore: continue execution
    //
    if(IDIGNORE == nCode)
        return false;

    //
    // Retry or message box failed: return true to break into the debugger
    //
    return true;
}


static
bool
TrpDebuggerBreak(
    const char* FileName,
    unsigned int Line,
    const char* Text
    )
/*++

Routine Description:
    Format and display the assert text.
    This funciton is called trying to break into user or kernel mode debugger.
    If it cannot break debug breakpoint exception is raised.

Arguments:
    FileName - The assert file location
    Line - The assert line location
    Text - The assert text to display

Returned Value:
    true, break into the debugger at the assert line
    false, a break into debuger was successful don't break again
    debug breakpoint exception, when no debugger was around to handle this break

--*/
{
    char szOutMessage[xMaxMessageLength];
    HRESULT hr = StringCchPrintfA(
                szOutMessage,
                TABLE_SIZE(szOutMessage),
                "\n"
                "*** Assertion failed: %s\n"
                "    Source File: %s, line %u\n"
                "    " MAILTO_MSG "\n\n",
                Text,
                FileName,
                Line
                );
    if(FAILED(hr))
    {
        C_ASSERT(TABLE_SIZE(STRING_TOO_LONG_DBG_MSG) < TABLE_SIZE(szOutMessage));

        hr = StringCchCopyA(szOutMessage, TABLE_SIZE(szOutMessage), STRING_TOO_LONG_DBG_MSG);
        ASSERT(SUCCEEDED(hr));
    }

    OutputDebugStringA(szOutMessage);

    //
    // The debugger is present, let it break on the assert line rather than here
    //
    if(IsDebuggerPresent())
        return true;

    //
    // No debugger is attached to this process, try kernel debugger.
    // Use VC7 cool breakpoint insert.
    //
    __debugbreak();
    return false;
}


bool
TrAssert(
    const char* FileName,
    unsigned int Line,
    const char* Text
    )
/*++

Routine Description:
    The assertion failed try to break into the debugger.
    First try directly and if no debugger respond pop-up a message box.

Arguments:
    FileName - The assert file location
    Line - The assert line location
    Text - The assert text to display

Returned Value:
    true, break into the debugger at the assert line
    false, ignore the assertion;

--*/
{
    __try
    {
        return TrpDebuggerBreak(FileName, Line, Text);
    }
    __except(GetExceptionCode() == STATUS_BREAKPOINT)
    {
        return TrpAssertWindow(FileName, Line, Text);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\tr\lib\trutil.cpp ===
/*++

Copyright (c) 1995-2002 Microsoft Corporation

Module Name:
    TrUtil.cpp

Abstract:
    WPP Trace Utility Functions - Use TrControl class to enable MSMQ 3.0 error tracing.

    To enable tracing
    1) CmInitialize to initialize the registry class object
    2) TrControl->Start()


    To save the settings
    1) TrControl->WriteRegistry()


    Please see lib\tr\test\test.cpp for more info

    
Author:
    Conrad Chang (conradc) 07-May-2002

Environment:
    Platform-independent

--*/
#include <libpch.h>
#include <wmistr.h>
#include <evntrace.h>
#include <strsafe.h>
#include <cm.h>
#include "_mqini.h"
#include "tr.h"
#include "TrUtil.tmh"


//
//  ISSUE-2002/05/09-conradc
//  Need to have Ian Service to review the default
//  Particularly we need to know if the parameters are good also 
//  for use with trace KD extension. 
//

//
// Define the tracing session parameters
//
const static ULONG x_DefaultBufferSize=64;     // Default 64KB buffer size
const static ULONG x_DefaultMinBuffer=32;      // Minimum Buffer
const static ULONG x_DefaultMaxBuffer=32;      // Maximum Buffer
const static ULONG x_DefaultFlushTime=5;       //  5 second flush time
const static ULONG x_DefaultLogFileMode=EVENT_TRACE_USE_GLOBAL_SEQUENCE | EVENT_TRACE_FILE_MODE_PREALLOCATE; 


TrControl::TrControl(
    ULONG   ulTraceFlags,
    LPCWSTR pwszTraceSessionName,
    LPCWSTR pwszTraceDirectory,
    LPCWSTR pwszTraceFileName,
    LPCWSTR pwszTraceFileExt,
    LPCWSTR pwszTraceFileBackupExt,
    ULONG   ulTraceSessionFileSize,
    TraceMode Mode,
    LPCWSTR pwszTraceRegistryKeyName,
    LPCWSTR pwszMaxTraceSizeRegValueName,
    LPCWSTR pwszUseCircularTraceFileModeRegValueName,
    LPCWSTR pwszTraceFlagsRegValueName,
    LPCWSTR pwszUnlimitedTraceFileNameRegValueName
    ):
    m_ulTraceFlags(ulTraceFlags),
    m_ulDefaultTraceSessionFileSize(ulTraceSessionFileSize),
    m_ulActualTraceSessionFileSize(ulTraceSessionFileSize),
    m_Mode(Mode)
{
    
    CopyStringInternal(
        pwszTraceSessionName, 
        m_szTraceSessionName, 
        TABLE_SIZE(m_szTraceSessionName)
        );
    
    CopyStringInternal(
        pwszTraceDirectory, 
        m_szTraceDirectory, 
        TABLE_SIZE(m_szTraceDirectory));
    
    CopyStringInternal(
        pwszTraceFileName, 
        m_szTraceFileName, 
        TABLE_SIZE(m_szTraceFileName)
        );
    
    CopyStringInternal(
        pwszTraceFileExt, 
        m_szTraceFileExt, 
        TABLE_SIZE(m_szTraceFileExt)
        );
    
    CopyStringInternal(
        pwszTraceFileBackupExt, 
        m_szTraceFileBackupExt, 
        TABLE_SIZE(m_szTraceFileBackupExt)
        );
    
    CopyStringInternal(
        pwszTraceRegistryKeyName, 
        m_szTraceRegistryKeyName, 
        TABLE_SIZE(m_szTraceRegistryKeyName)
        );
    
    CopyStringInternal(
        pwszMaxTraceSizeRegValueName, 
        m_szMaxTraceSizeRegValueName, 
        TABLE_SIZE(m_szMaxTraceSizeRegValueName)
        );
    
    CopyStringInternal(
        pwszUseCircularTraceFileModeRegValueName, 
        m_szUseCircularTraceFileModeRegValueName, 
        TABLE_SIZE(m_szUseCircularTraceFileModeRegValueName)
        );
    
    CopyStringInternal(
        pwszTraceFlagsRegValueName, 
        m_szTraceFlagsRegValueName, 
        TABLE_SIZE(m_szTraceFlagsRegValueName)
        );
    
    CopyStringInternal(
        pwszUnlimitedTraceFileNameRegValueName, 
        m_szUnlimitedTraceFileNameRegValueName, 
        TABLE_SIZE(m_szUnlimitedTraceFileNameRegValueName)
        );
    
       
    m_nFullTraceFileNameLength = 0;
    m_nTraceSessionNameLength = lstrlen(m_szTraceSessionName);
    m_hTraceSessionHandle = NULL;

}



HRESULT 
TrControl::CopyStringInternal(
    LPCWSTR pSource,
    LPWSTR  pDestination,
    const DWORD dwSize
    )
{
    if( (pSource == NULL) ||
        (pDestination == NULL) ||
        (dwSize == 0) )
       return ERROR_INVALID_PARAMETER;

    return StringCchCopy(
                pDestination,
                dwSize,
                pSource
                );
    
}


HRESULT TrControl::WriteRegistry()
{
    DWORD dwFileSize=0;
    BOOL  fCircular;
    HRESULT hr = GetCurrentTraceSessionProperties(
                     &dwFileSize,
                     &fCircular
                     );
        
    //
    // Ignore the error return
    //

    if(dwFileSize < m_ulDefaultTraceSessionFileSize)
        dwFileSize = m_ulDefaultTraceSessionFileSize;

    hr = SetTraceSessionSettingsInRegistry(
             dwFileSize,
             fCircular
             );

    UpdateTraceFlagInRegistryEx(GENERAL);
    UpdateTraceFlagInRegistryEx(AC);
    UpdateTraceFlagInRegistryEx(NETWORKING);
    UpdateTraceFlagInRegistryEx(SRMP);
    UpdateTraceFlagInRegistryEx(RPC);
    UpdateTraceFlagInRegistryEx(DS);
    UpdateTraceFlagInRegistryEx(SECURITY);
    UpdateTraceFlagInRegistryEx(ROUTING);
    UpdateTraceFlagInRegistryEx(XACT_GENERAL);
    UpdateTraceFlagInRegistryEx(XACT_SEND);
    UpdateTraceFlagInRegistryEx(XACT_RCV);
    UpdateTraceFlagInRegistryEx(XACT_LOG);
    UpdateTraceFlagInRegistryEx(LOG);
    UpdateTraceFlagInRegistryEx(PROFILING);

    return ERROR_SUCCESS;
}

PEVENT_TRACE_PROPERTIES 
AllocSessionProperties(
    void
    )
{
    PEVENT_TRACE_PROPERTIES Properties;
    ULONG SizeNeeded;
  
    //
    // Calculate the size needed to store the properties,
    // a LogFileName string, and LoggerName string.
    //
    SizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + 
                 (2 * MAX_PATH * sizeof(WCHAR));
    Properties = reinterpret_cast<PEVENT_TRACE_PROPERTIES>(new BYTE[SizeNeeded]);

    ZeroMemory(reinterpret_cast<BYTE *>(Properties), SizeNeeded);

    //
    // Set the location for the event tracing session name.
    // LoggerNameOffset is a relative address.
    //
    Properties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);

    //
    // Set the log file name location.  
    // LogFileNameOffset is a relative address.
    //
    Properties->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES) + 
                                    (MAX_PATH * sizeof(WCHAR));

    //
    // Store the total number of bytes pointed to by Properties.
    //
    Properties->Wnode.BufferSize = SizeNeeded;

    //
    // The WNODE_HEADER is being used.
    //
    Properties->Wnode.Flags = WNODE_FLAG_TRACED_GUID;

    return Properties;
}


HRESULT 
TrControl::GetCurrentTraceSessionProperties(
    DWORD *pdwFileSize,
    BOOL  *pbUseCircular
    )
{

    if( (lstrlen(m_szTraceSessionName) == 0) ||
        (pdwFileSize == NULL) ||
        (pbUseCircular == NULL)
       )
       return E_FAIL;
    
    
    PEVENT_TRACE_PROPERTIES pTraceProp=AllocSessionProperties();
      
    ULONG ulResult = QueryTrace(
                         NULL,
                         m_szTraceSessionName,
                         pTraceProp
                         );


    if(ulResult != ERROR_SUCCESS)
    {
        *pdwFileSize = m_ulDefaultTraceSessionFileSize;
        *pbUseCircular = TRUE; 
        delete pTraceProp;
        return HRESULT_FROM_WIN32(ulResult);
    }

    //
    // We are only care about trace size and circular or sequential
    //
    *pdwFileSize = pTraceProp->MaximumFileSize;
    *pbUseCircular = ((pTraceProp->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) == EVENT_TRACE_FILE_MODE_CIRCULAR);

    delete pTraceProp;

     return HRESULT_FROM_WIN32(ulResult);
}


BOOL   
TrControl::IsLoggerRunning(
    void
    )
/*++

Routine Description:
    This function enable the default error tracing


Arguments:
    None.

Returned Value:
    None.

--*/
{

    if(lstrlen(m_szTraceSessionName) == 0)
    {
        return FALSE;
    }


     
    ULONG                   ulResult;
    EVENT_TRACE_PROPERTIES  LoggerInfo;

    ZeroMemory(&LoggerInfo, sizeof(LoggerInfo));
    LoggerInfo.Wnode.BufferSize = sizeof(LoggerInfo);
    LoggerInfo.Wnode.Flags = WNODE_FLAG_TRACED_GUID;

    ulResult= QueryTrace(
                 NULL,
                 m_szTraceSessionName,
                 &LoggerInfo
                 );

    if (ulResult == ERROR_SUCCESS || ulResult == ERROR_MORE_DATA)
    {
        return TRUE;
    }

    return FALSE;
    
}

HRESULT 
TrControl::ComposeTraceRegKeyName(
    const GUID guid,
    LPWSTR lpszString,
    const DWORD  dwSize
    )
{
    if( (lpszString == NULL)|| 
        (dwSize == 0)|| 
        (lstrlen(m_szTraceFlagsRegValueName) == 0)
       )
         return ERROR_INVALID_PARAMETER;

    LPTSTR pstrGUID=NULL;
    RPC_STATUS rpcStatus = UuidToString(
                                (UUID *)&guid,
                                &pstrGUID
                                );


    if(rpcStatus != RPC_S_OK)
    {
        return GetLastError();
    }

    HRESULT hr = StringCchPrintf(
                    lpszString, 
                    dwSize, 
                    L"%s\\{%s}", 
                    m_szTraceRegistryKeyName, 
                    pstrGUID
                    );

    RpcStringFree(&pstrGUID);
    
    return hr;

}

//
// The following function can be eliminated 
// if we can find a way to enumerate all the
// trace provider GUIDs
//
HRESULT 
TrControl::UpdateTraceFlagInRegistry(
    const GUID guid,
    const DWORD  dwFlags
    )
{

    if(lstrlen(m_szTraceFlagsRegValueName) == 0)
        return ERROR_INVALID_PARAMETER;

    WCHAR   szString[REG_MAX_KEY_NAME_LENGTH]=L"";
    HRESULT hr = ComposeTraceRegKeyName(
                    guid,
                    szString,
                    TABLE_SIZE(szString));
    
    //
	// Create registery key
	//
	if (FAILED(hr))
	{
		return hr;
	}

    DWORD dwValue = dwFlags;
    if(dwValue == 0)
    {
        dwValue = m_ulTraceFlags;
    }

    
	RegEntry appReg(szString,  NULL, 0, RegEntry::MustExist, NULL);
	CRegHandle hAppKey = CmCreateKey(appReg, KEY_ALL_ACCESS);

	RegEntry TraceProviderReg(NULL, m_szTraceFlagsRegValueName, 0, RegEntry::MustExist, hAppKey);
	CmSetValue(TraceProviderReg, dwValue);

    return hr;
}

HRESULT
TrControl::GetTraceFlag(
    const GUID guid,
    DWORD *pdwValue
    )
{
   
    //
    // Check valid parameter
    //
    if(pdwValue == NULL)
        return ERROR_INVALID_PARAMETER;

    WCHAR   szString[REG_MAX_KEY_NAME_LENGTH]=L"";
    HRESULT hr = ComposeTraceRegKeyName(
                    guid,
                    szString,
                    TABLE_SIZE(szString)
                    );
    
    //
	// If get registery key failed, exit
	//
	if (FAILED(hr))
	{
		return hr;
	}

    DWORD dwValue = 0;
    
	RegEntry registry(szString, MSMQ_TRACE_FLAG_VALUENAME, *pdwValue);
    CmQueryValue(registry, &dwValue);
    
    if(dwValue == 0)
    {
        return hr;
    }
    
    *pdwValue = dwValue;

    return hr;

}

//
// The following function can be eliminated 
// if we can find a way to enumerate all the
// trace provider GUIDs
//

HRESULT 
TrControl::AddTraceProvider(
     const LPCGUID lpGuid
     )
{
    //
    // Bail out if we don't start the trace session
    //
    if(m_hTraceSessionHandle == NULL)return E_FAIL;

    //
    // Set dwFlags to ulFlags as default
    //
    DWORD dwFlags = m_ulTraceFlags;
    GetTraceFlag(*lpGuid, &dwFlags);

    HRESULT hr = EnableTrace(
                    TRUE,  
                    dwFlags,  
                    TR_DEFAULT_TRACELEVELS, 
                    lpGuid, 
                    m_hTraceSessionHandle
                    );

    return hr;
} 

HRESULT 
TrControl::GetTraceSessionSettingsFromRegistry(
    void
    )
{
    if( (lstrlen(m_szTraceRegistryKeyName) == 0) ||
        (lstrlen(m_szMaxTraceSizeRegValueName) == 0) ||
        (lstrlen(m_szUseCircularTraceFileModeRegValueName) == 0)
        )
        return ERROR_INVALID_PARAMETER;

    DWORD dwTempFileSize;
    RegEntry RegTraceFileSize(
                 m_szTraceRegistryKeyName, 
                 m_szMaxTraceSizeRegValueName, 
                 m_ulDefaultTraceSessionFileSize, 
                 RegEntry::Optional
                 );
    CmQueryValue(RegTraceFileSize, &dwTempFileSize);
    

    RegEntry RegTraceFileMode(
                 m_szTraceRegistryKeyName, 
                 m_szUseCircularTraceFileModeRegValueName, 
                 m_Mode, 
                 RegEntry::Optional
                 );
    
    DWORD dwTempFileMode;
    CmQueryValue(RegTraceFileMode, &dwTempFileMode);
    m_Mode = (dwTempFileMode != 0) ? CIRCULAR : SEQUENTIAL;

    if(dwTempFileSize > m_ulDefaultTraceSessionFileSize)
    {
        m_ulActualTraceSessionFileSize = dwTempFileSize;
    }
    
    return ERROR_SUCCESS;

}


HRESULT 
TrControl::SetTraceSessionSettingsInRegistry(
    DWORD dwFileSize,
    BOOL  bUseCircular
    )
{

    if( (lstrlen(m_szTraceRegistryKeyName) == 0) ||
        (lstrlen(m_szMaxTraceSizeRegValueName) == 0) ||
        (lstrlen(m_szMaxTraceSizeRegValueName) == 0)
       )
        return ERROR_INVALID_PARAMETER;
    
    RegEntry RegTraceFileSize(
                m_szTraceRegistryKeyName, 
                m_szMaxTraceSizeRegValueName, 
                m_ulDefaultTraceSessionFileSize, 
                RegEntry::Optional
                );
    CmSetValue(RegTraceFileSize, dwFileSize);
    

    RegEntry RegTraceFileMode(
                m_szTraceRegistryKeyName,  
                m_szUseCircularTraceFileModeRegValueName, 
                m_Mode, 
                RegEntry::Optional
                );
    CmSetValue(RegTraceFileMode, (DWORD)bUseCircular);
    
    return ERROR_SUCCESS;
}


HRESULT 
TrControl::GetTraceFileName(
    void
    )
{
    //
    // Check required parameters
    // 1) Trace Directory
    // 2) Trace Filename
    // 3) Trace File extension
    //
    if( (lstrlen(m_szTraceDirectory) == 0) ||
        (lstrlen(m_szTraceFileName) == 0) ||
        (lstrlen(m_szTraceFileExt) == 0)
       )
       return E_FAIL;


    // 
    // Setup the full trace file name
    // i.e. %windir%\debug\msmqlog.bin
    //
    HRESULT hr = StringCchPrintf(
                    m_szFullTraceFileName,
                    TABLE_SIZE(m_szFullTraceFileName),
                    L"%s\\%s%s",
                    m_szTraceDirectory,
                    m_szTraceFileName,
                    m_szTraceFileExt
                    );

    if(FAILED(hr))return hr;

    m_nFullTraceFileNameLength = lstrlen(m_szFullTraceFileName);

    // 
    // Check to see if the trace file exists
    // If it exists, we need to copy it to a backup file.
    // 
    if(INVALID_FILE_ATTRIBUTES == GetFileAttributes(m_szFullTraceFileName))
    {
        if(ERROR_FILE_NOT_FOUND == GetLastError())
        {
            m_nFullTraceFileNameLength = lstrlen(m_szFullTraceFileName);
            return ERROR_SUCCESS;
        }
    }

    //
    //  If we are set to have no Trace File Limit, then we create each trace file with
    //  date and time as its extension.  Otherwise, backup the trace file.
    //
    //  1 - the backup file is created with date extension
    //  0 - the backup file is created with bak
    //
    RegEntry registry(
                m_szTraceRegistryKeyName,                 // Registry key path
                m_szUnlimitedTraceFileNameRegValueName,   // Registry value name
                FALSE                                       // Default value 0
                );
    DWORD dwNoTraceFileLimit=0;
    CmQueryValue(registry, &dwNoTraceFileLimit);

    WCHAR   szBackupFileName[MAX_PATH+1];

    // 
    // Determine the backup file name
    // if NoTraceFileLimit, the backup trace file name is the trace file name with date/time extension
    // otherwise, it will be trace file name with .bak extension
    //
    if(dwNoTraceFileLimit == 0)
    {
        //
        // Check to see if we have the backup 
        // file extension name
        //
        if(lstrlen(m_szTraceFileBackupExt) == 0)
            return ERROR_INVALID_PARAMETER;

        //
        // setup the backup full trace file name
        // i.e. %windir%\debug\msmqlog.bak
        //
        hr = StringCchPrintf(
                szBackupFileName,
                TABLE_SIZE(szBackupFileName),
                L"%s\\%s%s",
                m_szTraceDirectory,
                m_szTraceFileName,
                m_szTraceFileBackupExt
                );

        if(FAILED(hr))
            return hr;

    
    }
    else
    {
        SYSTEMTIME LocalTime;
        
        GetLocalTime(&LocalTime);
        hr = StringCchPrintf(
                 szBackupFileName,
                 TABLE_SIZE(szBackupFileName),
                 L"%s\\%s%04d-%02d-%02d-%02d-%02d-%02d-%04d", 
                 m_szTraceDirectory,
                 m_szTraceFileName,
                 LocalTime.wYear, 
                 LocalTime.wMonth, 
                 LocalTime.wDay, 
                 LocalTime.wHour, 
                 LocalTime.wMinute, 
                 LocalTime.wSecond, 
                 LocalTime.wMilliseconds
                 );
        
        if(FAILED(hr))
            return hr;
    
    }

    //
    // Move the log file to msmqlog.bak and replace existing
    // ignore error here
    //
    MoveFileEx(m_szFullTraceFileName, szBackupFileName, MOVEFILE_REPLACE_EXISTING);

    return hr;
}


HRESULT
TrControl::Start(
    void
    )
/*++

Routine Description:
    This function start the trace session with name 
    1) logger session name = m_szTraceSessionName
    2) trace file name = m_szTraceFileName m_szTraceFileExt
    3) 


Arguments:
    None.

Returned Value:
    None.

--*/
{
        //
        // Check required parameters
        //
        if( (lstrlen(m_szTraceSessionName) == 0) ||
            (lstrlen(m_szTraceFileName) == 0) ||
            (lstrlen(m_szTraceFileExt) == 0)
           )
            return ERROR_INVALID_PARAMETER;


        //
        // Bail out if trace session is already running
        //
        if(IsLoggerRunning())return E_FAIL;


        //
        // Generate FileNames
        //
        HRESULT hr = GetTraceFileName();

        if(FAILED(hr))return hr;

        //
        // Check to make sure we have trace file name with non-zero length
        //
        if( (m_nFullTraceFileNameLength == 0) ||
            (m_nTraceSessionNameLength == 0) ||
            (m_ulActualTraceSessionFileSize == 0)
            )
             return E_FAIL;
                        
        //
        // Allocate buffer to have the following structure
        //  1) EVENT_TRACE_PROPERTIES
        //  2) NULL terminated TraceFileName,  i.e. %windir%\debug\msmqbin.log
        //  3) NULL terminated TraceSessionName, i.e. MSMQ
        //
        int nBufferSize = sizeof(EVENT_TRACE_PROPERTIES) + 
                          (m_nFullTraceFileNameLength + m_nTraceSessionNameLength+2)*sizeof(WCHAR);

        PEVENT_TRACE_PROPERTIES pTraceProp=NULL;

        pTraceProp = (PEVENT_TRACE_PROPERTIES)new BYTE[nBufferSize];

        GetTraceSessionSettingsFromRegistry();

        memset(pTraceProp, 0, nBufferSize);

        pTraceProp->Wnode.BufferSize = nBufferSize;
        pTraceProp->Wnode.Flags = WNODE_FLAG_TRACED_GUID; 

        pTraceProp->BufferSize      = x_DefaultBufferSize;
        pTraceProp->MinimumBuffers  = x_DefaultMinBuffer;
        pTraceProp->MaximumBuffers  = x_DefaultMaxBuffer;

        pTraceProp->MaximumFileSize = m_ulActualTraceSessionFileSize;
        pTraceProp->LogFileMode     = x_DefaultLogFileMode | ((m_Mode==CIRCULAR)?EVENT_TRACE_FILE_MODE_CIRCULAR:EVENT_TRACE_FILE_MODE_SEQUENTIAL); 
        pTraceProp->FlushTimer      = x_DefaultFlushTime;
        pTraceProp->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES);

        pTraceProp->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES) + 
                                       (m_nFullTraceFileNameLength + 1) * sizeof(WCHAR);
        hr = StringCchCopy(
                (LPWSTR)((LPBYTE)pTraceProp + pTraceProp->LoggerNameOffset), 
                m_nTraceSessionNameLength+1,
                m_szTraceSessionName
                );

        if(FAILED(hr))return hr;

        hr = StringCchCopy(
                (LPWSTR)((LPBYTE)pTraceProp + pTraceProp->LogFileNameOffset), 
                m_nFullTraceFileNameLength+1,
                m_szFullTraceFileName
                );



        if(FAILED(hr))return hr;

        ULONG ulResult  = StartTrace(
                            &m_hTraceSessionHandle, 
                            m_szTraceSessionName, 
                            pTraceProp
                            );

        delete []pTraceProp;

        if(ulResult == ERROR_SUCCESS)
        {
            //
            // We are ignoring the return value from EnableTrace now.
            //   If the Trace has been enabled from an GUID, it will return ERROR_INVALID_PARAMETER.
            //
            AddTraceProvider(&WPP_ThisDir_CTLGUID_GENERAL);
            AddTraceProvider(&WPP_ThisDir_CTLGUID_AC);
            AddTraceProvider(&WPP_ThisDir_CTLGUID_NETWORKING);
            AddTraceProvider(&WPP_ThisDir_CTLGUID_SRMP);
            AddTraceProvider(&WPP_ThisDir_CTLGUID_RPC);
            AddTraceProvider(&WPP_ThisDir_CTLGUID_DS);
            AddTraceProvider(&WPP_ThisDir_CTLGUID_SECURITY);
            AddTraceProvider(&WPP_ThisDir_CTLGUID_ROUTING);
            AddTraceProvider(&WPP_ThisDir_CTLGUID_XACT_GENERAL);
            AddTraceProvider(&WPP_ThisDir_CTLGUID_XACT_SEND);
            AddTraceProvider(&WPP_ThisDir_CTLGUID_XACT_RCV);
            AddTraceProvider(&WPP_ThisDir_CTLGUID_XACT_LOG);
            AddTraceProvider(&WPP_ThisDir_CTLGUID_LOG);
            AddTraceProvider(&WPP_ThisDir_CTLGUID_PROFILING);
            
        }

        return HRESULT_FROM_WIN32(ulResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\ts\lib\event.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    event.cpp

Abstract:
    Simulate Event Reporting

Author:
    Uri Habusha (urih) 04-May-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Ev.h"

#include "event.tmh"

static LONG s_fInitialized = FALSE;

void EvpSetInitialized(void)
{
    LONG fEvAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    ASSERT(!fEvAlreadyInitialized);
	DBG_USED(fEvAlreadyInitialized);
}


BOOL EvpIsInitialized(void)
{
    return s_fInitialized;
}



static HMODULE s_hInst = NULL;

static 
void
TraceReportEvent(
    DWORD EventId,
    va_list va
    )
/*++

Routine Description:
   The Routine printd the event-log message into tracing window

Arguments:
    EventId  - Message id
    pArglist - pointer to argument list for values for 
               formatted message

Returned Value:
    None.

--*/
{
    ASSERT(s_hInst != NULL);

    WCHAR msg[1024];
    DWORD ret = FormatMessage( 
                    FORMAT_MESSAGE_FROM_HMODULE,
                    s_hInst,
                    EventId,
                    0,
                    msg,
                    TABLE_SIZE(msg),
                    &va
                    );
    if (ret == 0)
    {
        TrERROR(GENERAL, "Failed to Format Message. Error %d", GetLastError());
        return;
    }

    printf("(%x) %ls\n", EventId, msg);
}


void 
__cdecl
EvReport(
    DWORD EventId,
    DWORD,
    PVOID,
    WORD NoOfStrings
    ... 
    ) 
{
    ASSERT(EvpIsInitialized());

    //     
    // Look at the strings, if they were provided     
    //     
    va_list va;
    va_start(va, NoOfStrings);
   
    TraceReportEvent(EventId, va);

    va_end(va);

}

void
__cdecl
EvReport(
    DWORD EventId,
    WORD NoOfStrings
    ... 
    ) 
{
    ASSERT(EvpIsInitialized());

    va_list va;
    va_start(va, NoOfStrings);
   
    TraceReportEvent(EventId, va);

    va_end(va);
}


void 
EvReport(
    DWORD EventId
    ) 
{
    ASSERT(EvpIsInitialized());

    TraceReportEvent(EventId, NULL);
}


const WCHAR xEventFileValue[] = L"EventMessageFile";
const WCHAR xEventSourcePath[] = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\";

static void LoadEventReportLibrary(LPCWSTR ApplicationName)
{
    WCHAR RegApplicationEventPath[256];

    ASSERT(TABLE_SIZE(RegApplicationEventPath) > (wcslen(ApplicationName) + wcslen(xEventSourcePath)));
    swprintf(RegApplicationEventPath, L"%s%s", xEventSourcePath, ApplicationName);

    //
    // Featch the name of Event Report string library from registery
    //
    WCHAR LibraryName[256];

    HKEY hKey;
    int rc = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    RegApplicationEventPath,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );

    if (rc != ERROR_SUCCESS)
    {
        TrERROR(GENERAL, "Can't open Registery Key %ls: Error %d", xEventSourcePath, GetLastError());
        return;
    }

    DWORD Type = REG_SZ;
    DWORD Size = 256 * sizeof(WCHAR);
    rc = RegQueryValueEx (
                hKey,
                xEventFileValue, 
                0,
                &Type, 
                reinterpret_cast<BYTE*>(LibraryName),
                &Size
                );

    if (rc != ERROR_SUCCESS)
    {
        TrERROR(GENERAL, "can't Read Registery Value %ls\\%ls. Error %d", xEventSourcePath, xEventFileValue, GetLastError());
        return;
    }

    //
    // get an handle to Event Report string library 
    //
    s_hInst = LoadLibrary(LibraryName);
    if (s_hInst == NULL) 
    {
        TrERROR(GENERAL, "Can't Load Event report library %ls. Error=%d", LibraryName, GetLastError());
    }
}    


VOID
EvInitialize(
    LPCWSTR ApplicationName
    )
/*++

Routine Description:
    Initializes Event Report library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    ASSERT(!EvpIsInitialized());

    LoadEventReportLibrary(ApplicationName);
    
    EvpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\tr\test\trtest.cpp ===
/*++

Copyright (c) 1995-2002  Microsoft Corporation

Module Name:
    TrTest.cpp

Abstract:
    Trace library test

Author:
    Conrad Chang (conradc) 09-May-2002

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Tr.h"
#include "cm.h"
#include "TrTest.tmh"

const WCHAR REGSTR_PATH_TRTEST_ROOT[] = L"SOFTWARE\\Microsoft\\TRTEST";

static void Usage()
{
    printf("Usage: TrTest\n");
    printf("\n");
    printf("Example, TrTest\n");
    exit(-1);

} // Usage

int _cdecl 
main( 
    int argc,
    char *
    )
/*++

Routine Description:
    Test Trace Utility library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{


    if(argc != 1)
    {
        Usage();
    }

    HKEY hKey=NULL;
    long lResult = RegCreateKeyEx(
                        HKEY_LOCAL_MACHINE,
                        REGSTR_PATH_TRTEST_ROOT,
                        NULL,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        NULL);

    RegCloseKey(hKey);

    if(lResult != ERROR_SUCCESS)
    {
        return -1;
    }


    try
    {
        	
        CmInitialize(HKEY_LOCAL_MACHINE, REGSTR_PATH_TRTEST_ROOT, KEY_ALL_ACCESS);

        TCHAR szTraceDirectory[MAX_PATH + 1] = L"";
        int nTraceFileNameLength=0;
        nTraceFileNameLength = GetSystemWindowsDirectory(
                                   szTraceDirectory, 
                                   TABLE_SIZE(szTraceDirectory)
                                   ); 

        if( nTraceFileNameLength < TABLE_SIZE(szTraceDirectory) || nTraceFileNameLength != 0 )
        {


            TrControl *pMSMQTraceControl = new TrControl(
                                                   1,
                                                   L"MSMQ",
                                                   szTraceDirectory,
                                                   L"Debug\\trtestlog.",
                                                   L"bin",
                                                   L"bak"
                                                   );

            if(pMSMQTraceControl)
            {
                HRESULT hr = pMSMQTraceControl->Start();

                // 
                // Save the setting in registry
                //
                pMSMQTraceControl->WriteRegistry();

                delete pMSMQTraceControl;
  
    	        if(FAILED(hr))return hr;
            }
        }
    }
    catch(const exception&)
    {
        //
        // Failed to Enable Tracing
        //
        return -1;
    }

    return 0;

} // main
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\utl\lib\adsiutl.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:
    adsiutl.cpp

Abstract:
   Implementation of UtlEscapeAdsPathName()

Author:
    Oren Weimann (t-orenw) 08-7-2002

--*/

#include <adsiutl.h>
#include <libpch.h>
#include <buffer.h>

#include "adsiutl.tmh"


LPCWSTR
UtlEscapeAdsPathName(
    IN LPCWSTR pAdsPathName,
    OUT AP<WCHAR>& pEscapeAdsPathNameToFree
    )
/*++

Routine Description:
    The routine returns an ADSI path, like the one given, but where the '/' chars are escaped
	i.e:
	1) if pAdsPathName = "LDAP://CN=QueueName,CN=msmq,CN=computername/with/slashes" then
	   return value will be "LDAP://CN=QueueName,CN=msmq,CN=computername\/with\/slashes"

	2) if pAdsPathName = "LDAP://servername.domain.com/CN=QueueName,CN=computername/with/slashes" then
	   return value will be "LDAP://servername.domain.com/CN=QueueName,CN=computername\/with\/slashes"

Arguments:
	IN LPWSTR pAdsPathName - input (non escaped path)
	OUT LPWSTR* pEscapeAdsPathNameToFree - output (escaped path) 

Return Value 
    Pointer to the escaped string (if the original pAdsPathName does not contain '/' the function
	returns the original pointer to pAdsPathName)
	
--*/
{
	const WCHAR x_AdsiSpecialChar = L'/';
	const WCHAR x_CommonNameDelimiter = L'=';

	//
	// ignore '/' before the first '='
	//
	PWCHAR ptr = wcschr(pAdsPathName, x_CommonNameDelimiter);
	if(ptr == NULL)
	{
		return pAdsPathName;
	}

	//
	// count the number of '/' in pAdsPathName
	//
	ULONG ulSlashNum=0;
	for(; *ptr != L'\0' ; ptr++)
	{
		if(*ptr == x_AdsiSpecialChar)
		{
			ulSlashNum++;
		}
	}

	if(ulSlashNum == 0)
	{
		//
		// No need to change the original string, no '/' found.
		//
		return pAdsPathName;
	}

	pEscapeAdsPathNameToFree = new WCHAR[wcslen(pAdsPathName) + ulSlashNum + 1];

	//
	// copy until first '=', only the '/' after the '=' should be escaped.
	// the '/' before the first '=' should NOT be escaped, they belong to the server's name,
	// as shown in example 2 in this Routine Description.
	//
	ULONG i;
	for(i=0 ; pAdsPathName[i] != x_CommonNameDelimiter ; i++)
	{
		pEscapeAdsPathNameToFree[i] = pAdsPathName[i];
	}

	ptr = &(pEscapeAdsPathNameToFree[i]);

	for(; pAdsPathName[i] != L'\0' ; i++)
	{
		if( (pAdsPathName[i] == x_AdsiSpecialChar) && (pAdsPathName[i-1] == L'\\') )
		{
			//
			// already escaped 
			//
			ulSlashNum--;
		}
		else if(pAdsPathName[i] == x_AdsiSpecialChar)
		{
			*ptr++ = L'\\';  
		}
		
		*ptr++ = pAdsPathName[i];
	}

	*ptr = L'\0';

	ASSERT( numeric_cast<ULONG>(ptr - pEscapeAdsPathNameToFree.get()) == (wcslen(pAdsPathName) + ulSlashNum) );
	
	TrTRACE(GENERAL, "In UtlEscapeAdsPathName escaped the %ls path to %ls", pAdsPathName, pEscapeAdsPathNameToFree);
	
	return pEscapeAdsPathNameToFree;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\utl\lib\bufutl.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    bufutl.cpp

Abstract:
   Implementation to some buffer utilities declared in buftl.h

Author:
    Gil Shafriri (gilsh) 30-7-2000

--*/
#include <libpch.h>
#include <buffer.h>
#include <strutl.h>

#include "bufutl.tmh"

template <class C>
class Utlvsnprintf;
template<> class Utlvsnprintf<char>
{
public:
	static int vsnprintf(char* buffer, size_t count, const char *format, va_list argptr )
	{
		return _vsnprintf(buffer, count, format, argptr);
	}
};


template<> class Utlvsnprintf<wchar_t>
{
public:
	static int vsnprintf(wchar_t* buffer, size_t count, const wchar_t *format, va_list argptr )
	{
			return _vsnwprintf(buffer, count, format, argptr);
	}
};


			   

template <class BUFFER, class T>
static 
size_t
UtlSprintfAppendInternal(
		BUFFER* pResizeBuffer, 
		const T* format,
		va_list va
		)
{
	int len = Utlvsnprintf<T>::vsnprintf(
					pResizeBuffer->begin() + pResizeBuffer->size(),
					pResizeBuffer->capacity() - pResizeBuffer->size(),
					format,
					va
					);
	//
	// If no space in the buffer - realloc
	//
	if(len == -1)
	{
		const size_t xAdditionalSpace = 128;
		pResizeBuffer->reserve(pResizeBuffer->capacity()*2 + xAdditionalSpace );
		return UtlSprintfAppendInternal(pResizeBuffer , format, va);
	}
	pResizeBuffer->resize(pResizeBuffer->size() + len);
	return numeric_cast<size_t>(len);

}


template <class BUFFER, class T>
size_t 
__cdecl 
UtlSprintfAppend(
	BUFFER* pResizeBuffer, 
	const T* format ,...
	)
/*++

Routine Description:
	Append formated string to given resizable buffer


Arguments:
    IN - pResizeBuffer - pointer resizable buffer of caracters

	IN - format - sprintf format string  followed by arguments 

Returned value:
	Number of bytes written to the buffer not including null terminate character.

Note :
The buffer might be reallocated if no space left.

--*/
{
	va_list va;
    va_start(va, format);

   	size_t written = UtlSprintfAppendInternal(pResizeBuffer, format,va);

	return written;
}





template <class BUFFER, class T>
size_t 
UtlStrAppend(
	BUFFER* pResizeBuffer, 
	const T* str
	)
/*++

Routine Description:
	Append  string to given resizable buffer


Arguments:
    IN - pResizeBuffer - pointer resizable buffer of caracters

	IN - str - string to append 

Returned value:
	Number of bytes written to the buffer not including null termination character.

Note :
The buffer might be reallocated if no space left.Null termination is appended but
the new size() will not include it.

--*/
{
	size_t len = UtlCharLen<T>::len(str) + 1;
	pResizeBuffer->append(str , len);


	//
	// Set the new size not including the null termination
	//
	pResizeBuffer->resize(pResizeBuffer->size() - 1);
	return len - 1;
}






//
// explicit instantiation
//
template size_t __cdecl UtlSprintfAppend(CResizeBuffer<char>* pResizeBuffer, const char* format, ...);
template size_t __cdecl UtlSprintfAppend(CResizeBuffer<wchar_t>* pResizeBuffer, const wchar_t* format, ...);
template size_t __cdecl UtlSprintfAppend(CPreAllocatedResizeBuffer<char>* pResizeBuffer, const char* format, ...);
template size_t __cdecl UtlSprintfAppend(CPreAllocatedResizeBuffer<wchar_t>* pResizeBuffer, const wchar_t* format, ...);



template size_t UtlStrAppend(CResizeBuffer<char>* pResizeBuffer, const char* str);
template size_t UtlStrAppend(CResizeBuffer<wchar_t>* pResizeBuffer, const wchar_t*  wstr);
template size_t UtlStrAppend(CPreAllocatedResizeBuffer<char>* pResizeBuffer, const char* str);
template size_t UtlStrAppend(CPreAllocatedResizeBuffer<wchar_t>* pResizeBuffer, const wchar_t* wstr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\utl\lib\strutl.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    strutl.cpp
 
Abstract: 
    implementation file for string utilities

Author:
    Gil Shafriri (gilsh) 15-10-2000

--*/
#include <libpch.h>
#include <strutl.h>
#include <xstr.h>

#include "strutl.tmh"

/////////////////////////////////////
// CRefcountStr_t implementation	
////////////////////////////////////

//
// Take ownership with duplicate the string
//
template <class T>
CRefcountStr_t<T>::CRefcountStr_t(
	const T* str
	):
	m_autostr(UtlStrDup(str))
	{
	}

	//
	// Take ownership without duplicate	the string
	//
	template <class T>
	CRefcountStr_t<T>::CRefcountStr_t(
	T* str ,
	int
	):
	m_autostr(str)
	{
	}

//
// Take ownership without duplicate	the given string
//
template <class T>
CRefcountStr_t<T>::CRefcountStr_t(
	const basic_xstr_t<T>& xstr
	):
	m_autostr(xstr.ToStr())	
	{
	}


template <class T> const T* CRefcountStr_t<T>::getstr()
{
	return m_autostr.get();			
}


//
// Explicit instantiation
//
template class 	 CRefcountStr_t<wchar_t>;
template class 	 CRefcountStr_t<char>;


/////////////////////////////////////
// CStringToken implementation	
////////////////////////////////////


template <class T, class Pred >
CStringToken<T, Pred>::CStringToken<T, Pred>(
			const T* str,
			const T* delim,
			Pred pred
			):
			m_startstr(str),
			m_delim(delim),
			m_pred(pred),
			m_endstr(str + UtlCharLen<T>::len(str)),
			m_enddelim(delim + UtlCharLen<T>::len(delim))
{
							
}

template <class T, class Pred >
CStringToken<T, Pred>::CStringToken<T, Pred>(
			const basic_xstr_t<T>&  str,
			const basic_xstr_t<T>&  delim,
			Pred pred = Pred()
			):
			m_startstr(str.Buffer()),
			m_delim(delim.Buffer()),
			m_pred(pred),
			m_endstr(str.Buffer() + str.Length()),
			m_enddelim(delim.Buffer() + delim.Length())
{
}


template <class T, class Pred >
CStringToken<T, Pred>::CStringToken<T, Pred>(
			const basic_xstr_t<T>&  str,
			const T* delim,
			Pred pred = Pred()
			):
			m_startstr(str.Buffer()),
			m_delim(delim),
			m_pred(pred),
			m_endstr(str.Buffer() + str.Length()),
			m_enddelim(delim + UtlCharLen<T>::len(delim))

{
}


template <class T, class Pred>
__TYPENAME CStringToken<T,Pred>::iterator 
CStringToken<T,Pred>::begin() const
{
	return FindFirst();
}


template <class T,class Pred>
__TYPENAME CStringToken<T,Pred>::iterator 
CStringToken<T,Pred>::end()	const
{
	return 	iterator(m_endstr, m_endstr, this);
}


template <class T, class Pred> 
const __TYPENAME CStringToken<T,Pred>::iterator 
CStringToken<T,Pred>::FindNext(
						const T* begin
						)const
{
	begin += m_enddelim - m_delim;
	ASSERT(m_endstr >= begin);
	const T* p = std::search(begin, m_endstr, m_delim, m_enddelim, m_pred);
	return p == m_endstr ? end() : iterator(begin, p, this);	
}
	    

template <class T, class Pred> 
const __TYPENAME CStringToken<T,Pred>::iterator 
CStringToken<T, Pred>::FindFirst() const
						
{
	const T* p = std::search(m_startstr, m_endstr, m_delim, m_enddelim, m_pred);
	return p == m_endstr ? end() : iterator(m_startstr, p, this);
}


//
// Explicit instantiation
//
template class 	 CStringToken<wchar_t>;
template class 	 CStringToken<char>;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\utl\test\adsitest.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:
    adsitest.cpp

Abstract:
   tests UtlEscapeAdsPathName()

Author:
    Oren Weimann (t-orenw) 9-7-2002

--*/
#include <libpch.h>
#include <adsiutl.h>
#include "utltest.h"

#include "adsitest.tmh"


const LPCWSTR pUnescapedPath[]= 
	{
		L"LDAP://CN=test_without_slashes",
		L"LDAP://CN=test/with/slashes",
		L"LDAP://servertest.domain.com/CN=includinserver,CN=test_without_slashes",
		L"LDAP://servertest.domain.com/CN=includinserver,CN=test/with/slashes",
		L"LDAP://servertest.domain.com/CN=includinserver,CN=test\\/with/some\\/slashes/but/not/all",
		L"LDAP://test_without_assignment"
	};

const LPCWSTR pEscapedPath[]= 
	{
		L"LDAP://CN=test_without_slashes",
		L"LDAP://CN=test\\/with\\/slashes",
		L"LDAP://servertest.domain.com/CN=includinserver,CN=test_without_slashes",
		L"LDAP://servertest.domain.com/CN=includinserver,CN=test\\/with\\/slashes",
		L"LDAP://servertest.domain.com/CN=includinserver,CN=test\\/with\\/some\\/slashes\\/but\\/not\\/all",
		L"LDAP://test_without_assignment"
	};

C_ASSERT(TABLE_SIZE(pUnescapedPath) == TABLE_SIZE(pEscapedPath));

void DoEscapedAdsPathTest()
{
	for(ULONG i=0 ; i < TABLE_SIZE(pUnescapedPath) ; i++)
	{
		AP<WCHAR> pTmpEscaped;
		if(wcscmp(UtlEscapeAdsPathName(pUnescapedPath[i],pTmpEscaped), pEscapedPath[i]) != 0)
		{
			TrERROR(GENERAL,"UtlEscapeAdsPathName() was incorrect:\n%ls was changed to:\n%ls and not to \n%ls",pUnescapedPath[i],pTmpEscaped,pEscapedPath[i]);
			throw  exception();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\utl\lib\utf8.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    utf8.cpp
 
Abstract: 
    Implementation of conversion functions from\to utf8 caracters set

Author:
    Gil Shafriri (gilsh) 15-10-2000

--*/
#include <libpch.h>
#include <utf8.h>
#include <strutl.h>

#include "utf8.tmh"

static size_t UtlUtf8LenOfWc(wchar_t wc)throw()
/*++

Routine Description:
	return the number of utf8 caracters representing the given unicode caracter.


Arguments:
     wc - unicode carcter.

Returned value:
	number of utf8 caracters representing the given unicode caracter.	
--*/
{
  if (wc < 0x80)
    return 1;

  if (wc < 0x800)
    return 2;

  return 3;
}


size_t UtlUtf8LenOfWcs(const wchar_t* pwc,	size_t cbWcs)throw()
/*++

Routine Description:
	Return the number of utf8 caracters representing the given unicode buffer.


Arguments:
     pwc - unicode buffer.
	 cbWcs - unicode buffer length in unicode caracters.

Returned value:
	The number of utf8 caracters representing the given unicode buffer.

--*/
{
	size_t len = 0;
	for(size_t i=0; i<cbWcs; ++i)
	{
		len += 	UtlUtf8LenOfWc(pwc[i]);	
	}
	return len;
}



size_t UtlUtf8LenOfWcs(const wchar_t* pwc)throw()
/*++

Routine Description:
	Return the number of utf8 caracters representing the given unicode null terminating string.


Arguments:
     pwc - unicode string.

Returned value:
	The number of utf8 caracters representing the given unicode null terminating string.

Note:
The null termination unicode caracter (L'\0') is not processed.
--*/
{
	size_t len = 0;
	while(*pwc != L'\0')
	{
		len += 	UtlUtf8LenOfWc(*pwc);	
		pwc++;
	}
	return len;
}

size_t
UtlWcToUtf8(
	wchar_t wc ,
	utf8_char *pUtf8, 
	size_t cbUtf8
	)
/*++

Routine Description:
	Convert single unicode caracter into one or more (up to 3) utf8 caracters.

Arguments:
     wc - Unicode caracter to convert.
	 pUtf8 - Output buffer that receive the utf8 carcters that are the conversion result.
	 cbUtf8 - the size in bytes of the space pUtf8 point to.

Returned value:
	The number of utf8 caracters that copied to the output buffer. If the function
	fails because of invalid input - bad_utf8 exception is thrown.

Note:
The null termination unicode caracter (L'\0') is not processed.
--*/
{
  size_t count = UtlUtf8LenOfWc(wc);
  ASSERT(count <= 3 && count > 0);
  

  if (cbUtf8 < count)
	  throw std::range_error("");


  switch (count) /* note: code falls through cases! */
  { 
	case 3: pUtf8[2] = (utf8_char)(0x80 | (wc & 0x3f)); wc = wc >> 6; wc |= 0x800;
        // Fall through

	case 2: pUtf8[1] = (utf8_char)(0x80 | (wc & 0x3f)); wc = wc >> 6; wc |= 0xc0;
        // Fall through

	case 1: pUtf8[0] = (utf8_char)(wc);
  }
  return count;
}

static
size_t
UtlUtf8ToWc(
	const utf8_char *pUtf8, 
	size_t cbUtf8,
	wchar_t *pwc
	)
/*++

Routine Description:
	Convert utf8 caracters into single unicode caracter.

Arguments:
     pUtf8 - Pointer to utf8 caracters that should be converted into single unicode caracter.
	 cbUtf8 - The length in bytes of the buffer pUtf8 points to.
	 pwc - Output buffer for the unicode caracter created.

Returned value:
	The number of utf8 caracters that converted. If the function failed because of invalid
	input - bad_utf8 exception is thrown.

--*/
{
	ASSERT(pwc != 0);
	ASSERT(pUtf8 != 0);
	ASSERT(cbUtf8 != 0);

	utf8_char c = pUtf8[0];

	if (c < 0x80)
	{
		*pwc = c;
		return 1;
	} 


	if (c < 0xc2) 
	{
		throw bad_utf8();
	}
 
	if (c < 0xe0) 
	{
		if (cbUtf8 < 2)
			throw std::range_error("");


		if (!((pUtf8[1] ^ 0x80) < 0x40))
		  throw bad_utf8();


		*pwc = ((wchar_t) (c & 0x1f) << 6) | (wchar_t) (pUtf8[1] ^ 0x80);
		return 2;
	}

	if (c < 0xf0) 
	{
		if (cbUtf8 < 3)
			throw std::range_error("");


		if (!((pUtf8[1] ^ 0x80) < 0x40 && (pUtf8[2] ^ 0x80) < 0x40
			  && (c >= 0xe1 || pUtf8[1] >= 0xa0)))
		  throw bad_utf8();


		*pwc = ((wchar_t) (c & 0x0f) << 12)
			   | ((wchar_t) (pUtf8[1] ^ 0x80) << 6)
			   | (wchar_t) (pUtf8[2] ^ 0x80);

		return 3;
	} 
	throw bad_utf8();
}

void 
UtlUtf8ToWcs(
		const utf8_char* pUtf8,
		size_t cbUtf8,
		wchar_t* pWcs,
		size_t cbWcs,
		size_t* pActualLen
		)
/*++

Routine Description:
	Convert utf8 array (not null terminating) into unicode string.

Arguments:
    pUtf8 - utf8 string to convert.
	size_t  cbUtf8 size in bytes of array pUtf8 points to.
	pWcs -  Output buffer for the converted unicode caracters
	cbWcs - The size in unicode caracters of the space that pWcs points to.
	pActualLen -  Receives the number of unicode caracters created.


Returned value:
	None

Note:
	It is the responsibility of the caller to allocate buffer large enough
	to hold the converted data + null termination. To be on the safe side - allocate buffer
	that the number of unicode caracters in it >= strlen(pUtf8) +1

--*/
{
	size_t index = 0;
	const utf8_char* Utf8End = pUtf8 + cbUtf8;
	for(; pUtf8 != Utf8End; ++index)
	{
		size_t size = UtlUtf8ToWc(
							pUtf8, 
							cbWcs - index, 
							&pWcs[index]
							);

		pUtf8 += size; 
		ASSERT(pUtf8 <= Utf8End);
		ASSERT(index < cbWcs - 1);
	}
	ASSERT(index < cbWcs);
	pWcs[index] = L'\0';
	if(pActualLen != NULL)
	{
		*pActualLen = index;
	}
}


void 
UtlUtf8ToWcs(
		const utf8_char *pUtf8,
		wchar_t* pWcs,
		size_t cbWcs,
		size_t* pActualLen
		)
/*++

Routine Description:
	Convert utf8 string into unicode string.

Arguments:
    pUtf8 - utf8 string to convert.
	pWcs -  Output buffer for the converted unicode caracters
	cbWcs - The size in unicode caracters of the space that pWcs points to.
	pActualLen -  Receives the number of unicode caracters created.


Returned value:
	None

Note:
	It is the responsibility of the caller to allocate buffer large enough
	to hold the converted data + null termination. To be on the safe side - allocate buffer
	that the number of unicode caracters in it >= strlen(pUtf8) +1

--*/
{
	size_t index = 0;
	for(; *pUtf8 != '\0' ; ++index)
	{
		size_t size = UtlUtf8ToWc(
							pUtf8, 
							cbWcs - index, 
							&pWcs[index]
							);

		pUtf8 += size; 
		ASSERT(index < cbWcs - 1);
	}
	ASSERT(index < cbWcs);
	pWcs[index] = L'\0';
	if(pActualLen != NULL)
	{
		*pActualLen = index;
	}
}


utf8_char* UtlWcsToUtf8(const wchar_t* pwcs, size_t* pActualLen)

/*++

Routine Description:
	Convert unicode string into utf8 string.

Arguments:
    pwcs - Unicode string to convert.
	pActualLen -  Receives the number of bytes created in utf8 format.


Returned value:
	Utf8 reperesentation of the given unicode string.
    If the function failes because of invalid input - bad_utf8 exception
	is thrown.

Note:
	It is the responsibility of the caller to call delete[] on returned pointer.
--*/
{
	ASSERT(pwcs != NULL);
	size_t len = UtlUtf8LenOfWcs(pwcs) +1;

	AP<utf8_char> pUtf8 = new utf8_char[len];
	UtlWcsToUtf8(pwcs, pUtf8.get(), len, pActualLen); 
	return pUtf8.detach();
}


wchar_t* UtlUtf8ToWcs(const utf8_char* pUtf8, size_t cbUtf8, size_t* pActualLen)
/*++

Routine Description:
	Convert utf8 array of bytes into unicode string.

Arguments:
    pUtf8 - utf8 array of bytes to convert.
	cbUtf8 - The length in bytes of the buffer pUtf8 points to.
	pActualLen -  Receives the number of unicode caracters created.


Returned value:
	Unicode reperesentation of the given utf8 string.
    If the function failes because of invalid input - bad_utf8 exception
	is thrown

Note:
	It is the responsibility of the caller to call delete[] on returned pointer.

--*/
{
	ASSERT(pUtf8 != NULL);
	
	size_t Wcslen = cbUtf8 + 1;
	AP<wchar_t> pWcs = new wchar_t[Wcslen];
	UtlUtf8ToWcs(pUtf8, cbUtf8, pWcs.get(), Wcslen, pActualLen);
	return 	pWcs.detach();
}


wchar_t* UtlUtf8ToWcs(const utf8_char* pUtf8, size_t* pActualLen)
/*++

Routine Description:
	Convert utf8 string into unicode string.

Arguments:
    pUtf8 - utf8 string to convert.
	pActualLen -  Receives the number of unicode caracters created.


Returned value:
	Unicode reperesentation of the given utf8 string.
    If the function failes because of invalid input - bad_utf8 exception
	is thrown

Note:
	It is the responsibility of the caller to call delete[] on returned pointer.

--*/
{
	ASSERT(pUtf8 != NULL);
	
	size_t len = UtlCharLen<utf8_char>::len(pUtf8) + 1;
	AP<wchar_t> pWcs = new wchar_t[len];
	UtlUtf8ToWcs(pUtf8, pWcs.get(), len, pActualLen);
	return 	pWcs.detach();
}


void
UtlWcsToUtf8(
		const wchar_t* pwcs, 
		size_t cbwcs,
		utf8_char* pUtf8,
		size_t cbUtf8,
		size_t* pActualLen
		)
/*++

Routine Description:
	Convert unicode array (non null terminating) into utf8 string.

Arguments:
    pwcs - Unicode string to convert.
	cbwcs - Size in unicode characters of the array pwcs points to.
	pUtf8 - Pointer to buffer that receives the utf8 converted caracters.
	cbUtf8 - The size in bytes of the space that pUtf8 points to.
	pActualLen -  Receives the number of bytes created in utf8 format.


Returned value:
	None

Note:
	It is the responsibility of the caller to allocate buffer large enough
	to hold the converted data + null termination. To be on the safe side - allocate buffer
	that the number of bytes in it >= UtlWcsUtf8Len(pwcs) +1
--*/
{
	const  wchar_t* pwcsEnd = pwcs + cbwcs;
	size_t index = 0;
	for( ; pwcs != pwcsEnd; ++pwcs)
	{
		ASSERT(index < cbUtf8 - 1);
		index += UtlWcToUtf8(*pwcs, &pUtf8[index], cbUtf8 - index );
	}
	ASSERT(index < cbUtf8);
	pUtf8[index] = '\0';
	if(pActualLen != NULL)
	{
		*pActualLen = index;
	}
}



void
UtlWcsToUtf8(
		const wchar_t* pwcs,
		utf8_char* pUtf8,
		size_t cbUtf8,
		size_t* pActualLen
		)
/*++

Routine Description:
	Convert unicode string into utf8 string.

Arguments:
    pwcs - Unicode string to convert.
	pUtf8 - Pointer to buffer that receives the utf8 converted caracters.
	cbUtf8 - The size in bytes of the space that pUtf8 points to.
	pActualLen -  Receives the number of bytes created in utf8 format.


Returned value:
	None

Note:
	It is the responsibility of the caller to allocate buffer large enough
	to hold the converted data + null termination. To be on the safe side - allocate buffer
	that the number of bytes in it >= UtlWcsUtf8Len(pwcs) +1
--*/
{
	size_t index = 0;
	for( ; *pwcs != L'\0'; ++pwcs)
	{
		ASSERT(index < cbUtf8 -1);
		index += UtlWcToUtf8(*pwcs, &pUtf8[index], cbUtf8 - index );
	}

	ASSERT(index < cbUtf8);
	pUtf8[index] = '\0';
	if(pActualLen != NULL)
	{
		*pActualLen = index;
	}
}


utf8_str 
UtlWcsToUtf8(
		const std::wstring& wcs
		)
/*++

Routine Description:
	Convert unicode stl string into utf8 stl string.

Arguments:
    wcs - Unicode stl string to convert.

Returned value:
	Stl utf8 string reperesentation of the given unicode string.
    If the function failes because of invalid input - bad_utf8 exception
	is thrown.

--*/
{
	size_t len = UtlUtf8LenOfWcs(wcs.c_str()) +1 ;
	utf8_str utf8(len ,' ');

	size_t ActualLen;
	UtlWcsToUtf8(wcs.c_str(), utf8.begin(), len, &ActualLen);

	ASSERT(ActualLen == len -1);
	utf8.resize(ActualLen);
	return utf8;
}

utf8_str 
UtlWcsToUtf8(
		const wchar_t* pwcs,
		size_t cbWcs
		)
/*++

Routine Description:
	Convert unicode buffer into utf8 stl string.

Arguments:
    pwcs - pointer to buffer to convert
	cbWcs - buffer length in unicode bytes

Returned value:
	Stl utf8 string reperesentation of the given unicode string.
    If the function failes because of invalid input - bad_utf8 exception
	is thrown.

--*/
{
	size_t len = UtlUtf8LenOfWcs(pwcs, cbWcs) +1;
	utf8_str utf8(len ,' ');

	size_t ActualLen;
	UtlWcsToUtf8(pwcs, cbWcs, utf8.begin(), len, &ActualLen);

	ASSERT(ActualLen == len -1);
	utf8.resize(ActualLen);
	return utf8;
}



std::wstring 
UtlUtf8ToWcs(
			const utf8_str& utf8
			)
/*++

Routine Description:
	Convert utf8 stl string into unicode stl string.

Arguments:
    pUtf8 - utf8 string to convert.

Returned value:
	Stl Unicode string reperesentation of the given utf8 string.
    If the function failes because of invalid input - bad_utf8 exception
	is thrown

--*/
{
	return UtlUtf8ToWcs	(utf8.c_str(), utf8.size());
}


std::wstring 
UtlUtf8ToWcs(
		const utf8_char* pUtf8,
		size_t cbUtf8
		)
/*++

Routine Description:
	Convert utf8 array of bytes (non null terminating) into unicode stl string.

Arguments:
    pUtf8 - utf8 string to convert.
	cbUtf8 - The size in bytes  of the array pUtf8 points to.

Returned value:
	Stl Unicode string reperesentation of the given utf8 string.
    If the function failes because of invalid input - bad_utf8 exception
	is thrown

--*/
{
	size_t len = cbUtf8 +1;

	std::wstring wcs(len ,L' ');
	ASSERT(wcs.size() == len);

	size_t ActualLen;
	UtlUtf8ToWcs(pUtf8, cbUtf8, wcs.begin(), len , &ActualLen);

	ASSERT(ActualLen <= cbUtf8);
	wcs.resize(ActualLen);

	return wcs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\utl\lib\timeutl.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    timeutl.cpp
 
Abstract: 
    implementation of time utilities

Author:
    Gil Shafriri (gilsh) 15-10-2000

--*/
#include <libpch.h>
#include <timeutl.h>
#include <xstr.h>
#include <mqexception.h>
#include <strutl.h>

#include "timeutl.tmh"

using namespace std;

template <class T>
std::basic_ostream<T>& 
operator<<(
	std::basic_ostream<T>& o, 
	const CIso8601Time& Iso8601Time
	)
/*++

Routine Description:
	Serialize time integer returned for time() function into stream
	according to  Iso860 format.


Arguments:
    o - stream to format the string into.

	Iso8601Time - holds the number of seconds elapsed since midnight (00:00:00), January 1, 1970. 

Returned value:
	None

--*/
{
    struct tm* ts = gmtime(&Iso8601Time.m_time);
	ASSERT(ts != NULL);
	if(ts == NULL)
	{
		throw bad_time_value();
	}

	T oldfill = o.fill();
	o.fill(o.widen('0'));
	
	o<<setw(4)<<(ts->tm_year + 1900)
	 <<setw(2)<<ts->tm_mon + 1  
	 <<setw(2)<<ts->tm_mday;

	o.put(o.widen('T'))
	<<setw(2)<<ts->tm_hour
	<<setw(2)<<ts->tm_min
	<<setw(2)<<ts->tm_sec;

	o.fill(oldfill);

	return o;
}

//
// Explicit instantiation
//

template std::basic_ostream<char>& 
operator<<(
	std::basic_ostream<char>& o, 
	const CIso8601Time& Iso8601Time
	);


template std::basic_ostream<wchar_t>& 
operator<<(
	std::basic_ostream<wchar_t>& o, 
	const CIso8601Time& Iso8601Time
	);



void
UtlIso8601TimeToSystemTime(
    const xwcs_t& Iso860Time, 
    SYSTEMTIME* pSysTime
    )
/*++

Routine Description:
	convert  Iso860 absolute time format to system time format

Arguments:
    Iso8601Time -  Iso8601 absolute time format to convert
	pSysTime - will holds the system time after the function returns.

Returned value:
	None

Note:
  the function throw bad_Iso8601Time exception in case of bad format

--*/
{
    DWORD year = 0;
    DWORD month = 0;
    DWORD day = 0;
    DWORD hour = 0;
    DWORD minute = 0;
    DWORD second = 0;

	int n = _snwscanf(
				Iso860Time.Buffer(),
				Iso860Time.Length(),
				L"%04d%02d%02dT%02d%02d%02d",
				&year, &month, &day, &hour, &minute, &second
				);

    if (
    	(n < 4) ||
    	(month == 0) || (month > 12) ||
    	(day == 0) || (day > 31) ||
    	(hour > 23) ||
    	(minute > 59) ||
    	(second > 59)
    	)
    {
    	TrERROR(GENERAL, "Bad SRMP time format %.*ls", Iso860Time);
        throw bad_time_format();
    }

    pSysTime->wYear = (WORD)year;
    pSysTime->wMonth = (WORD)month;
    pSysTime->wDayOfWeek = 0;
    pSysTime->wDay = (WORD)day;
	pSysTime->wHour = (WORD)hour;
	pSysTime->wMinute = (WORD)minute;
	pSysTime->wSecond= (WORD)second;
	pSysTime->wMilliseconds = 0;
}



time_t UtlSystemTimeToCrtTime(const SYSTEMTIME& SysTime)
/*++

Routine Description:
	convert  system time to c runtime time integer 
	(that is the number of seconds elapsed since midnight (00:00:00), January 1, 1970. )


Arguments:
    SysTime -  system time.

Returned value:
	c runtime time value

  Note:
  the function throw bad_Iso8601Time exception in case of bad format

--*/
{
	FILETIME FileTime;
	bool fSuccess = SystemTimeToFileTime(&SysTime, &FileTime) == TRUE;
	if(!fSuccess)
	{
		throw bad_win32_error(GetLastError());
	}
    
	// SystemTimeToFileTime() returns the system time in number 
    // of 100-nanosecond intervals since January 1, 1601. We
    // should return the number of seconds since January 1, 1970.
    // So we should subtract the number of 100-nanosecond intervals
    // since January 1, 1601 up until January 1, 1970, then divide
    // the result by 10**7.
	LARGE_INTEGER* pliFileTime = (LARGE_INTEGER*)&FileTime;
    pliFileTime->QuadPart -= 0x019db1ded53e8000;
    pliFileTime->QuadPart /= 10000000;

	if(FileTime.dwHighDateTime != 0)
	{
		throw bad_time_value();
	}

	return min(FileTime.dwLowDateTime, LONG_MAX);
}



time_t
UtlIso8601TimeDuration(
    const xwcs_t& TimeDurationStr
    )
/*++

Routine Description:
	convert relative time duration string (Iso8601 5.5.3.2) to integer


Arguments:
    SysTime -  system time.

Returned value:
	Integer representing the number of seconds the string represent.

  Note:
  the function throw bad_time_format exception in case of bad format

--*/
{
	const  WCHAR xTimeDurationPrefix[] = L"P";
	LPCWSTR p = TimeDurationStr.Buffer() + STRLEN(xTimeDurationPrefix);
    LPCWSTR pEnd = TimeDurationStr.Buffer()+ TimeDurationStr.Length();

    if(!UtlIsStartSec(
			p,
			pEnd,
			xTimeDurationPrefix,
			xTimeDurationPrefix + STRLEN(xTimeDurationPrefix)
			))
	{
		throw bad_time_format();
	}

    DWORD years = 0;
    DWORD months = 0;
    DWORD hours = 0;
    DWORD days = 0;
    DWORD minutes = 0;
    DWORD seconds = 0;
    bool fTime = false;
    DWORD temp = 0;

	while(p++ != pEnd)
    {
        if (iswdigit(*p))
        {
            temp = temp*10 + (*p -L'0');
            continue;
        }

        switch(*p)
        {
			case L'Y':
			case L'y':
				years = temp;
				break;

			case L'M':
			case L'm':
				if (fTime)
				{
					minutes = temp;
				}
				else
				{
					months = temp;
				}
				break;

			case L'D':
			case L'd':
				days = temp;
				break;

			case L'H':
			case L'h':
				hours = temp;
				break;

			case L'S':
			case L's':
				seconds = temp;
				break;

			case L'T':
			case L't':
				fTime = true;
				break;

			default:
				throw bad_time_format();
				break;
			}

			temp = 0;
	}

    months += (years * 12);
    days += (months * 30);
    hours += (days * 24);
    minutes += (hours * 60);
    seconds += (minutes * 60);

    return min(seconds ,LONG_MAX);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\utl\test\buftest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    buftest.cpp

Abstract:
   Buffer + buffer utilities test module

Author:
    Gil Shafriri (gilsh) 1-8-2000

--*/
#include <libpch.h>
#include <buffer.h>
#include <bufutl.h>
#include "utltest.h"

#include "buftest.tmh"

void DoBufferUtlTest()
{
	const char* format = "this integer=%d and this string=%s and this second integer=%x\n";
	char buffer[1024];
	CResizeBuffer<char> ResizeBuffer(10);
	TrTRACE(GENERAL,"test formating string to resizable buffer");
	int int1 = 3;
	int int2 = 12233;
	const char* str= "string";
	size_t len1 = sprintf(buffer, format, int1, str,int2);
	size_t len2 = UtlSprintfAppend(&ResizeBuffer,format, int1, str, int2);
	if(len1 !=  len2 || len2 != ResizeBuffer.size() )
	{
		TrERROR(GENERAL,"length of the data written into the resizable buffer is incorrect");
		throw  exception();
	}
	
	if(strcmp(buffer, ResizeBuffer.begin()) != 0 )
	{
		TrERROR(GENERAL,"the formated data  written to the resizable buffer is incorrect");
		throw  exception();
	}

	CStaticResizeBuffer<char ,10> StaticResizeBuffer;
	len2 = UtlSprintfAppend(StaticResizeBuffer.get(), format, int1, str, int2);
	if(len1 !=  len2 || len2 != StaticResizeBuffer.size() )
	{
		TrERROR(GENERAL,"length of the data written into the resizable buffer is incorrect");
		throw  exception();
	}
	if(strcmp(buffer, StaticResizeBuffer.begin()) != 0 )
	{
		TrERROR(GENERAL,"the formated data  written to the resizable buffer is incorrect");
		throw  exception();
	}


	const WCHAR* wstr = L"WSTRING";
	CStaticResizeBuffer<WCHAR ,2> StaticResizeBuffer2;
	size_t l = UtlStrAppend(StaticResizeBuffer2.get(), wstr);
	if( l !=  wcslen(wstr))
	{
		TrERROR(GENERAL,"length of the string written into the resizable buffer is incorrect");
		throw  exception();
	}


	if(wcscmp(wstr, StaticResizeBuffer2.begin())	!= 0)
	{
		TrERROR(GENERAL,"string written into the resizable buffer is incorrect");
		throw  exception();
	}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\utl\test\timetest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    timetest.cpp

Abstract:
   time related functions utilities test module

Author:
    Erez Haba (erezh) 15-Jan-2002

--*/
#include <libpch.h>
#include <xstr.h>
#include "timeutl.h"

#include "timetest.tmh"

void DoTimeTest()
{
	//
	// Test full time with milliseconds
	//
	LPCWSTR pTimeText1 = L"20020813T124433";
	xwcs_t t1(pTimeText1, wcslen(pTimeText1));
	SYSTEMTIME SysTime1;
	UtlIso8601TimeToSystemTime(t1, &SysTime1);

	time_t CrtTime1 = UtlSystemTimeToCrtTime(SysTime1);
	printf("Original string is %ls, crt time result %Id", pTimeText1, CrtTime1);

	//
	// Test time with hours only
	//
	LPCWSTR pTimeText2 = L"20020813T12";
	xwcs_t t2(pTimeText2, wcslen(pTimeText2));
	SYSTEMTIME SysTime2;
	UtlIso8601TimeToSystemTime(t2, &SysTime2);

	//
	// Test bad time format; too long date
	//
	try
	{
		LPCWSTR pTimeText3 = L"200205813T12";
		xwcs_t t3(pTimeText3, wcslen(pTimeText3));
		SYSTEMTIME SysTime3;
		UtlIso8601TimeToSystemTime(t3, &SysTime3);

		printf("ERROR: UtlIso8601TimeToSystemTime parsed unexpeted format %ls", pTimeText3);
		throw exception();
	}
	catch(const exception&)
	{
	}
		

	//
	// Test bad time format; too long date
	//
	try
	{
		LPCWSTR pTimeText4 = L"20020813T1";
		xwcs_t t4(pTimeText4, wcslen(pTimeText4));
		SYSTEMTIME SysTime4;
		UtlIso8601TimeToSystemTime(t4, &SysTime4);

		LPCWSTR pTimeText5 = L"20021313T12";
		xwcs_t t5(pTimeText5, wcslen(pTimeText5));
		SYSTEMTIME SysTime5;
		UtlIso8601TimeToSystemTime(t5, &SysTime5);
		
		printf("ERROR: UtlIso8601TimeToSystemTime parsed unexpeted format %ls", pTimeText4);
		throw exception();
	}
	catch(const exception&)
	{
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\utl\test\utf8test.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    utf8test.cpp

Abstract:
    Test the utf8 conversion functions

Author:
    Gil Shafriri (gilsh) 12-Nov-2000

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <utf8.h>
#include "utltest.h"

#include "utf8test.tmh"

static void DoUtf8TestInternal(size_t rseed)
{	
	//
	// Fill unicode array with random strings
	//
	WCHAR wstr[1000];
	for(size_t i=0; i< TABLE_SIZE(wstr); i++)
	{
		WCHAR wc =  (WCHAR)(rand() % USHRT_MAX);
		wstr[i] = wc != 0 ? wc : (WCHAR)123;
	}
	wstr[TABLE_SIZE(wstr) -1] = L'\0';
	size_t len = wcslen(wstr);

	//
	//  convert it to utf8
	// 
	AP<unsigned char> str = UtlWcsToUtf8(wstr);	 


	//
	// check it length
	//
	if(str[UtlUtf8LenOfWcs(wstr)] != '\0')
	{
		TrERROR(GENERAL,"utf8 conversion error random seed = %Id",rseed);
		throw exception();
	}
	if(UtlUtf8LenOfWcs(wstr) != strlen((char*)str.get()))
	{
		TrERROR(GENERAL,"utf8 conversion error random seed = %Id",rseed);
		throw exception();
	}
  
	//
	// convert it back to unicode
	//
	AP<WCHAR> wstr2 = UtlUtf8ToWcs(str.get());
	if(wstr2[len] != L'\0')
	{
		TrERROR(GENERAL,"utf8 conversion error random seed = %Id",rseed);
		throw exception();
	}
	
	//
	// check against original string
	//
	if(memcmp(wstr, wstr2, len*sizeof(WCHAR)) != 0)
	{
		TrERROR(GENERAL,"utf8 conversion error random seed = %Id",rseed);
		throw exception();
	}

	//
	// convert it again to utf8
	//
	AP<unsigned char> str2 = UtlWcsToUtf8(wstr2.get());
	if(str2[UtlUtf8LenOfWcs(wstr)] != '\0')
	{
		TrERROR(GENERAL,"utf8 conversion error random seed = %Id",rseed);
		throw exception();
	}

	//
	// check length
	//
	if(UtlUtf8LenOfWcs(wstr) != strlen((char*)str2.get()))
	{
		TrERROR(GENERAL,"utf8 conversion error random seed = %Id",rseed);
		throw exception();
	}

	//
	// check the utf8 string accepted
	//
	if(memcmp(str2.get(), str.get(), UtlUtf8LenOfWcs(wstr)) != 0)
	{
		TrERROR(GENERAL,"utf8 conversion error random seed = %Id",rseed);
		throw exception();
	}
	
	//
	// empty unicode conversion	test
	//
	const WCHAR* wnill=L"";
	AP<unsigned char> strnill = UtlWcsToUtf8(wnill);	 
	if(strnill[0] != '\0')
	{
		TrERROR(GENERAL,"utf8 conversion error random seed = %Id",rseed);
		throw exception();
	}
		
	AP<WCHAR> wnill2 =  UtlUtf8ToWcs(strnill.get());
	if(wnill2[0] != L'\0')
	{
		TrERROR(GENERAL,"utf8 conversion error random seed = %Id",rseed);
		throw exception();
	}


	//
	// stl conversion
	//
	std::wstring stlwcs(wstr);
	utf8_str stlstr = UtlWcsToUtf8(stlwcs);
	if(memcmp(stlstr.c_str(), str.get(), UtlUtf8LenOfWcs(wstr)) != 0)
	{
		TrERROR(GENERAL,"utf8 conversion error random seed = %Id",rseed);
		throw exception();
	}

	size_t cbWcs = stlwcs.size();
	stlstr = UtlWcsToUtf8(stlwcs.c_str(), cbWcs);
	if(memcmp(stlstr.c_str(), str.get(), UtlUtf8LenOfWcs(wstr)) != 0)
	{
		TrERROR(GENERAL,"utf8 conversion error random seed = %Id",rseed);
		throw exception();
	}


	
	if(stlstr.size() != UtlUtf8LenOfWcs(wstr))
	{
		TrERROR(GENERAL,"utf8 conversion error random seed = %Id",rseed);
		throw exception();
	}


	stlstr = str.get();
	stlwcs = UtlUtf8ToWcs(stlstr);
	if(memcmp(stlwcs.c_str(), wstr, len*sizeof(WCHAR)) != 0)
	{
		TrERROR(GENERAL,"utf8 conversion error random seed = %Id",rseed);
		throw exception();
	}
}


void DoUtf8Test()
{
	time_t rseed;
	time(&rseed);
	srand(numeric_cast<DWORD>(rseed));
   
	for(int i =0;i<1000;i++)
	{
		DoUtf8TestInternal(rseed);		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\utl\test\utltest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    UtlTest.cpp

Abstract:
    Utilities library test

Author:
    Gil Shafriri (gilsh) 31-Jul-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "utltest.h"

#include "UtlTest.tmh"

extern "C" int __cdecl _tmain(int /*argc*/, LPCTSTR /*argv*/[])
/*++

Routine Description:
    Test Utilities library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	try
	{
		
	   	TrInitialize();

		//
		// Buffer utilities test.
		//
		DoBufferUtlTest();

		//
		// String utilities test
		//
	    DoStringtest();

		//
		// Utf8 test
		//
		DoUtf8Test();

		//
		// Time functionality test
		//
		DoTimeTest();
		
		//
		// Escape '/' test
		//
		DoEscapedAdsPathTest();
	}
	catch(const exception&)
	{
		TrERROR(GENERAL,"Get unexcepted exception - test failed");
		return 1;
	}
 	TrTRACE(GENERAL, "Test passed");

    WPP_CLEANUP();
    return 0;

} // _tmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\utl\test\strtest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    strtest.cpp

Abstract:
  string test utilities

Author:
    Gil Shafriri (gilsh) 1-8-2000

--*/
#include <libpch.h>
#include <strutl.h>
#include <xstr.h>
#include "utltest.h"

#include "strtest.tmh"

static void DoCwstringexTest()
{
	const WCHAR xWstr[] = L"TEST STRING";
	std::wstring wstr(xWstr); 
	Cwstringex wstrex (wstr);
	Cwstringex wstr2ex(wstrex);
	if(wcscmp(wstr.c_str(), wstr2ex.getstr()) !=0)
	{
		TrERROR(GENERAL,"error in Cwstringex class");
		throw exception();
	}

	if(wstr.length() != wstr2ex.getlen() )
	{
		TrERROR(GENERAL,"error in Cwstringex class");
		throw exception();
	}

	Cwstringex wstr3ex(xWstr, STRLEN(xWstr));
	if(STRLEN(xWstr) != wstr3ex.getlen() )
	{
		TrERROR(GENERAL,"error in Cwstringex class");
		throw exception();
	}

	if(xWstr != wstr3ex.getstr() )
	{
		TrERROR(GENERAL,"error in Cwstringex class");
		throw exception();
	}
}




static void DoCRefcountStrTest()
{
	const WCHAR* xTestStr = L"TEST STR";
	R< CWcsRef > RefcountStr( new CWcsRef(xTestStr));
	R<CWcsRef> RefcountStr2;
	RefcountStr2 = 	RefcountStr;
	if(wcscmp(RefcountStr2->getstr(),xTestStr) != 0)
	{
		TrERROR(GENERAL,"error in CRefcountStr class");
		throw exception();
	}

	xwcs_t xstr(xTestStr,wcslen(xTestStr));
	R< CWcsRef > RefcountStr3(new CWcsRef(xstr)); 
	if(wcscmp(RefcountStr2->getstr(),xTestStr) != 0)
	{
		TrERROR(GENERAL,"error in CRefcountStr class");
		throw exception();
	}

	P<WCHAR> Str (newwcs(xTestStr));
	const WCHAR* pStr =   Str.get();
	R< CWcsRef > RefcountStr4( new CWcsRef(Str.detach(), 0 ));
	if(wcscmp(RefcountStr4->getstr(),xTestStr) != 0 || RefcountStr4->getstr() != pStr)
	{
		TrERROR(GENERAL,"error in CRefcountStr class");
		throw exception();
	}
}


static void DoStrMatchTest()
{
	static const char* xStr1 =  "microsoft.com";
	static const char* xPattern1 = "mic*.co*m";
	bool b = UtlStrIsMatch(xStr1, xPattern1);
    if(!b)
	{
		TrERROR(GENERAL,"%s should match %s" ,xPattern1, xStr1 );
		throw exception();
	}

	static const char* xStr2 =  "microsoft.com";
	static const char* xPattern2 = "*";
	b = UtlStrIsMatch(xStr2, xPattern2);
    if(!b)
	{
		TrERROR(GENERAL,"%s should match %s" ,xPattern2, xStr2 );
		throw exception();
	}

	static const char* xStr3 =  "microsoft.com";
	static const char* xPattern3 = "*r**f*";
	b = UtlStrIsMatch(xStr3, xPattern3);
    if(!b)
	{
		TrERROR(GENERAL,"%s should match %s" ,xPattern3, xStr3 );
		throw exception();
	}

	static const char* xStr4 =  "microsoft.com";
	static const char* xPattern4 = "microsoft.com****";
	b = UtlStrIsMatch(xStr4, xPattern4);
    if(!b)
	{
		TrERROR(GENERAL,"%s should match %s" ,xPattern4, xStr4 );
		throw exception();
	}
	
	static const char* xStr5 =  "microsoft.com";
	static const char* xPattern5 = "microsoft.com****a";
	b = UtlStrIsMatch(xStr5, xPattern5);
    if(b)
	{
		TrERROR(GENERAL,"%s should not match %s" ,xPattern5, xStr5 );
		throw exception();
	}

	static const WCHAR* xStr6 =  L"www.microsoft.com";
	static const WCHAR* xPattern6 = L"ww*w.micr*";
	b = UtlStrIsMatch(xStr6, xPattern6);
    if(!b)
	{
		TrERROR(GENERAL,"%ls should match %ls" ,xPattern6, xStr6 );
		throw exception();
	}

	static const WCHAR* xStr7 =  L"ww*w.microsoft.com";
	static const WCHAR* xPattern7 = L"ww^*w.micr*";
	b = UtlStrIsMatch(xStr7, xPattern7);
    if(!b)
	{
		TrERROR(GENERAL,"%ls should match %ls" ,xPattern7, xStr7);
		throw exception();
	}

	static const WCHAR* xStr8 =  L"ww*w.microsoft.com";
	static const WCHAR* xPattern8 = L"ww^^*w.micr*";
	b = UtlStrIsMatch(xStr8, xPattern8);
    if(b)
	{
		TrERROR(GENERAL,"%ls should not match %ls" ,xPattern8, xStr8);
		throw exception();
	}


	static const WCHAR* xStr9 =  L"*****^^^^^";
	static const WCHAR* xPattern9 = L"^*^*^*^*^*^^^^^^^^^^";
	b = UtlStrIsMatch(xStr9, xPattern9);
    if(!b)
	{
		TrERROR(GENERAL,"%ls should match %ls" ,xPattern9, xStr9);
		throw exception();
	}
}


static void	CheckStringParsing(const CStrToken& tokenizer, const char* tokens[], int tokensize)
{	

	std::vector<xstr_t>  v;
	std::copy(tokenizer.begin() ,  tokenizer.end(), std::back_inserter<std::vector<xstr_t> >(v));


	std::vector<xstr_t>  v2;
	for(int i =0;i<tokensize;i++)
	{
		v2.push_back(xstr_t(tokens[i],strlen(tokens[i])));		
	}


	if(!(v2 == v))
	{
		TrERROR(GENERAL,"incorrect string parsing");
		throw exception();
	}


	i=0;
	for(CStrToken::iterator it = tokenizer.begin();it !=  tokenizer.end();it++, i++)
	{
		xstr_t tok = *it;
		if(tok != xstr_t(tokens[i], strlen(tokens[i]) ))
		{
			TrERROR(GENERAL,"incorrect string parsing");
			throw exception();
		}
	}
	if(i != tokensize)
	{
			TrERROR(GENERAL,"incorrect string parsing");
			throw exception();
	}
}

static void DoStrTokenTest()
{
	const char* Tokens[] = {"aaa","bbb","ccc","ddd","yyyyyyyyyy"};
	const char* Delim =	 "\r\n";
	std::ostringstream str;
	for(int i = 0; i< TABLE_SIZE(Tokens); ++i)
	{
		str<<Tokens[i]<<Delim;	
	}

	const std::string tokenizedstr = str.str();
	CStrToken tokenizer(tokenizedstr.c_str(), Delim);
	CheckStringParsing(tokenizer, Tokens, TABLE_SIZE(Tokens));
	CStrToken tokenizer2(
				xstr_t(tokenizedstr.c_str(), tokenizedstr.size() ), 
				xstr_t(Delim,strlen(Delim)) 
				);

	CheckStringParsing(tokenizer2, Tokens, TABLE_SIZE(Tokens));
}

static void DoStrAlgoTest()
{
	const char* s1 ="Host: hhh";
	const char* s2 ="Host:";
	bool b = UtlIsStartSec(
		  s1,
		  s1 + strlen(s1),
		  s2,
		  s2 + strlen(s2)
		  );

	if(!b)
	{
		TrERROR(GENERAL,"bad result from UtlIsStart");
		throw exception();
	}

	const char* s3 ="Host: hhh";
	const char* s4 ="Host::";

	b = UtlIsStartSec(
		  s3,
		  s3 + strlen(s3),
		  s4,
		  s4 + strlen(s4)
		  );

	if(b)
	{
		TrERROR(GENERAL,"bad result from UtlIsStart");
		throw exception();
	}
     
	b = UtlIsStartSec(
		  s4,
		  s4 + strlen(s4),
		  s3,
		  s3 + strlen(s3)
		  );

	if(b)
	{
		TrERROR(GENERAL,"bad result from UtlIsStart");
		throw exception();
	}
}

static void DoStaticStrLenTest()
{
	char str[] = "123456789";
	std::wstring wstr= L"123456789";  


	if(wstr.size() != STRLEN(str))
	{
		TrERROR(GENERAL,"bad STRLEN");
		throw exception();
	}
	
	if(wstr.size()  != STRLEN("123456789"))
	{
		TrERROR(GENERAL,"bad STRLEN");
		throw exception();
	}

	if(wstr.size()  != strlen(str))
	{
		TrERROR(GENERAL,"bad STRLEN");
		throw exception();
	}

	xwcs_t x[100];
	if(TABLE_SIZE(x) != 100)
	{
		TrERROR(GENERAL,"bad TABLE_SIZE");
		throw exception();
	}
}

void DoStringtest()
{
	DoCwstringexTest();
	DoStrMatchTest();
	DoCRefcountStrTest();
	DoStrTokenTest();
	DoStrAlgoTest();
	DoStaticStrLenTest();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\utl\test\utltest.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    utltest.h

Abstract:
	Headr file for utlities test   

Author:
    Gil Shafriri (gilsh) 25-7-2000

--*/


#ifndef UTLTEST_H
#define UTLTEST_H

void DoBufferUtlTest();
void DoStringtest();
void DoUtf8Test();
void DoTimeTest();
void DoEscapedAdsPathTest();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\xds\lib\base64.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    base64.cpp

Abstract:
    functions to convert from octet/bytes to base64 and vice versa

Author:
    Ilan Herbst (ilanh) 5-Mar-00

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <xds.h>
#include <xdsp.h>

#include "base64.tmh"

//
// Conversion table from base64 to wchar_t
// every base64 value (0-63) is map to the corresponding unicode character
//
const WCHAR xBase642AsciiW[] = {
	L'A', L'B', L'C', L'D', L'E', L'F', L'G', L'H', L'I', L'J',
	L'K', L'L', L'M', L'N', L'O', L'P', L'Q', L'R', L'S', L'T',
	L'U', L'V', L'W', L'X', L'Y', L'Z', L'a', L'b', L'c', L'd', 
	L'e', L'f', L'g', L'h', L'i', L'j', L'k', L'l', L'm', L'n', 
	L'o', L'p', L'q', L'r', L's', L't', L'u', L'v', L'w', L'x', 
	L'y', L'z', L'0', L'1', L'2', L'3', L'4', L'5', L'6', L'7', 
	L'8', L'9', L'+', L'/'
	};

C_ASSERT(TABLE_SIZE(xBase642AsciiW) == 64);

//
// Conversion table from base64 to char
// every base64 value (0-63) is map to the corresponding Ascii character
//
const char xBase642Ascii[] = {
	'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
	'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
	'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 
	'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 
	'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 
	'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', 
	'8', '9', '+', '/'
	};

C_ASSERT(TABLE_SIZE(xBase642Ascii) == 64);

//
// Conversion table from wchar_t to base64 value
// unused values are mark with 255 - we map only the base64 character
// to values from 0-63
//
const BYTE xAscii2Base64[128] = {
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255,  62, 255, 255, 255,  63,  52,  53,
	54,  55,  56,  57,  58,  59,  60,  61, 255, 255,
	255,   0, 255, 255, 255,   0,   1,   2,   3,   4,
	5,   6,   7,   8,   9,  10,  11,  12,  13,  14,
	15,  16,  17,  18,  19,  20,  21,  22,  23,  24,
	25, 255, 255, 255, 255, 255, 255,  26,  27,  28,
	29,  30,  31,  32,  33,  34,  35,  36,  37,  38,
	39,  40,  41,  42,  43,  44,  45,  46,  47,  48,
	49,  50,  51, 255, 255, 255, 255, 255
	};

// C_ASSERT(xAscii2Base64[L'='] == 0);

//
// Mask bits in 24 bit value for the four 6 bit units
// for base64 values
// note the first char is the most significant 6 bit !!
//
const int xFirst6bChar = 0x00fc0000;
const int xSecond6bChar = 0x0003f000;
const int xThird6bChar = 0x00000fc0;
const int xFourth6bChar = 0x0000003f;

const int xFirst6bShift = 18;
const int xSecond6bShift = 12;
const int xThird6bShift = 6;
const int xFourth6bShift = 0;

//
// Mask bits in 24 bit value for the three 8 bit units
// note the first char is the most significant byte !!
//
const int xFirst8bChar = 0x00ff0000;
const int xSecond8bChar = 0x0000ff00;
const int xThird8bChar = 0x000000ff;

const int xFirst8bShift = 16;
const int xSecond8bShift = 8;
const int xThird8bShift = 0;


LPWSTR
Convert3OctetTo4Base64(
	DWORD ThreeOctet,
	LPWSTR pBase64Buffer
	)
/*++

Routine Description:
    Transform 3 Octet bytes to 4 base64 wchar_t
	3 characters (24 bit) are transform into 4 wchar_t in base64
	the function update the pBase64Buffer to point to the next location	and return
	the updated pointer.

Arguments:
	ThreeOctet - input 3Octet value (24 bit) 
	pBase64Buffer - base64 buffer that will be filled with 4 base64 wchar_t

Returned Value:
	updated pointer of pBase64Buffer which points to the next location

--*/
{
	//
	// Calc first 6 bits
	//
	DWORD Res = ((ThreeOctet & xFirst6bChar) >> xFirst6bShift);
	ASSERT(Res < 64);
	*pBase64Buffer = xBase642AsciiW[Res];
	++pBase64Buffer;

	//
	// Calc second 6 bits
	//
	Res = ((ThreeOctet & xSecond6bChar) >> xSecond6bShift); 
	ASSERT(Res < 64);
	*pBase64Buffer = xBase642AsciiW[Res];
	++pBase64Buffer;

	//
	// Calc third 6 bits
	//
	Res = ((ThreeOctet & xThird6bChar) >> xThird6bShift);
	ASSERT(Res < 64);
	*pBase64Buffer = xBase642AsciiW[Res];
	++pBase64Buffer;

	//
	// Calc fourth 6 bits
	//
	Res = ((ThreeOctet & xFourth6bChar) >> xFourth6bShift); 
	ASSERT(Res < 64);
	*pBase64Buffer = xBase642AsciiW[Res];
	++pBase64Buffer;

	return(pBase64Buffer);
}


LPSTR
Convert3OctetTo4Base64(
	DWORD ThreeOctet,
	LPSTR pBase64Buffer
	)
/*++

Routine Description:
    Transform 3 Octet bytes to 4 base64 chars
	3 characters (24 bit) are transform into 4 chars in base64
	the function update the pBase64Buffer to point to the next location	and return
	the updated pointer.

Arguments:
	ThreeOctet - input 3Octet value (24 bit) 
	pBase64Buffer - base64 buffer that will be filled with 4 base64 char

Returned Value:
	updated pointer of pBase64Buffer which points to the next location

--*/
{
	//
	// Calc first 6 bits
	//
	DWORD Res = ((ThreeOctet & xFirst6bChar) >> xFirst6bShift);
	ASSERT(Res < 64);
	*pBase64Buffer = xBase642Ascii[Res];
	++pBase64Buffer;

	//
	// Calc second 6 bits
	//
	Res = ((ThreeOctet & xSecond6bChar) >> xSecond6bShift); 
	ASSERT(Res < 64);
	*pBase64Buffer = xBase642Ascii[Res];
	++pBase64Buffer;

	//
	// Calc third 6 bits
	//
	Res = ((ThreeOctet & xThird6bChar) >> xThird6bShift);
	ASSERT(Res < 64);
	*pBase64Buffer = xBase642Ascii[Res];
	++pBase64Buffer;

	//
	// Calc fourth 6 bits
	//
	Res = ((ThreeOctet & xFourth6bChar) >> xFourth6bShift); 
	ASSERT(Res < 64);
	*pBase64Buffer = xBase642Ascii[Res];
	++pBase64Buffer;

	return(pBase64Buffer);
}


LPWSTR
Octet2Base64W(
	const BYTE* OctetBuffer, 
	DWORD OctetLen, 
	DWORD *Base64Len
	)
/*++

Routine Description:
    Transform Octet/char string to base64 wchar_t string
	every 3 characters (24 bit) are transform into 4 wchar_t in base64
	end condition: padd with zero to complete 24 bits (3 octet/char blocks)
	'=' is an extra char in base64 that indicates zero padding.
	1 char at the end (8 bit out of 24) --> '==' padding
	2 char at the end (16 bit out of 24) --> '=' padding
	(more details in the function)

	this function allocate and return the Base64 Buffer
	the caller is responsible to free this buffer

Arguments:
	OctetBuffer - input Octet buffer 
	OctetLen - Length of the Octet buffer (number of byte elements in buffer)
	Base64Len - (out) base64 buffer len (number of WCHAR elements in buffer)

Returned Value:
    wchar_t Base64 buffer

--*/
{
	//
	// Base64 Length - round up OctetLen to multiplies of complete 3 chars
	// each 3 chars will generate 4 base64 chars
	//
	*Base64Len =  ((OctetLen + 2) / 3) * 4;

	//
	// Extra byte for end of string
	//
	LPWSTR Base64Buffer = new WCHAR[*Base64Len+1];
	LPWSTR pBase64Buffer = Base64Buffer;

	//
	// going over complete 3 bytes/chars and transform them to 4 Base64 characters
	//
	int Complete3Chars = OctetLen / 3;

	//
	// Convert each 3 bytes of 8 bits to 4 bytes of 6 bits in base64
	//
	for(int i=0; i< Complete3Chars; ++i, OctetBuffer += 3)
	{
		//
		// Calc 24 bits value - from 3 bytes of 8 bits
		//
		DWORD Temp = ((OctetBuffer[0]) << xFirst8bShift) 
					 + ((OctetBuffer[1]) << xSecond8bShift) 
					 + ((OctetBuffer[2]) << xThird8bShift);

		pBase64Buffer = Convert3OctetTo4Base64(Temp, pBase64Buffer); 
	}

	//
	// Handling the remainder - 1/2 chars (not a complete 3 chars)
	//
	int Remainder = OctetLen - Complete3Chars * 3;

	switch(Remainder)
	{
		DWORD Temp;

		//
		// No reminder - all bytes in complete 3 bytes blocks
		//
		case 0:
			break;

		//
		// Only 1 byte left - we will have two 6 bits result and two = padding
		//
		case 1:

			//
			// Calc 24 bits value - from only 1 byte
			//
			Temp = ((OctetBuffer[0]) << xFirst8bShift); 

			pBase64Buffer = Convert3OctetTo4Base64(Temp, pBase64Buffer); 

			//
			// Third, fourth 6 bits are zero --> = padding
			//
			pBase64Buffer -= 2;
			*pBase64Buffer = L'='; 
			++pBase64Buffer;
			*pBase64Buffer = L'='; 
			++pBase64Buffer;
			break;

		//
		// Only 2 bytes left - we will have three 6 bits result and one = padding
		//
		case 2:

			//
			// Calc 24 bits value - from 2 bytes
			//
			Temp = ((OctetBuffer[0]) << xFirst8bShift) 
				   + ((OctetBuffer[1]) << xSecond8bShift);

			pBase64Buffer = Convert3OctetTo4Base64(Temp, pBase64Buffer); 

			//
			// Fourth 6 bits are zero --> = padding
			//
			--pBase64Buffer;
			*pBase64Buffer = L'='; 
			++pBase64Buffer;
			break;

		default:
			ASSERT(("remainder value should never get here", 0));
			break;
	}

	//
	// Adding end of string
	//
	Base64Buffer[*Base64Len] = L'\0';
	return(Base64Buffer);
}


LPSTR
Octet2Base64(
	const BYTE* OctetBuffer, 
	DWORD OctetLen, 
	DWORD *Base64Len
	)
/*++

Routine Description:
    Transform Octet/char string to base64 char string
	every 3 characters (24 bit) are transform into 4 chars in base64
	end condition: padd with zero to complete 24 bits (3 octet/char blocks)
	'=' is an extra char in base64 that indicates zero padding.
	1 char at the end (8 bit out of 24) --> '==' padding
	2 char at the end (16 bit out of 24) --> '=' padding
	(more details in the function)

	this function allocate and return the Base64 Buffer
	the caller is responsible to free this buffer

Arguments:
	OctetBuffer - input Octet buffer 
	OctetLen - Length of the Octet buffer (number of byte elements in buffer)
	Base64Len - (out) base64 buffer len (number of WCHAR elements in buffer)

Returned Value:
    char Base64 buffer

--*/
{
	//
	// Base64 Length - round up OctetLen to multiplies of complete 3 chars
	// each 3 chars will generate 4 base64 chars
	//
	*Base64Len =  ((OctetLen + 2) / 3) * 4;

	//
	// Extra byte for end of string
	//
	LPSTR Base64Buffer = new char[*Base64Len+1];
	LPSTR pBase64Buffer = Base64Buffer;

	//
	// going over complete 3 bytes/chars and transform them to 4 Base64 characters
	//
	int Complete3Chars = OctetLen / 3;

	//
	// Convert each 3 bytes of 8 bits to 4 bytes of 6 bits in base64
	//
	for(int i=0; i< Complete3Chars; ++i, OctetBuffer += 3)
	{
		//
		// Calc 24 bits value - from 3 bytes of 8 bits
		//
		DWORD Temp = ((OctetBuffer[0]) << xFirst8bShift) 
					 + ((OctetBuffer[1]) << xSecond8bShift) 
					 + ((OctetBuffer[2]) << xThird8bShift);

		pBase64Buffer = Convert3OctetTo4Base64(Temp, pBase64Buffer); 
	}

	//
	// Handling the remainder - 1/2 chars (not a complete 3 chars)
	//
	int Remainder = OctetLen - Complete3Chars * 3;

	switch(Remainder)
	{
		DWORD Temp;

		//
		// No reminder - all bytes in complete 3 bytes blocks
		//
		case 0:
			break;

		//
		// Only 1 byte left - we will have two 6 bits result and two = padding
		//
		case 1:

			//
			// Calc 24 bits value - from only 1 byte
			//
			Temp = ((OctetBuffer[0]) << xFirst8bShift); 

			pBase64Buffer = Convert3OctetTo4Base64(Temp, pBase64Buffer); 

			//
			// Third, fourth 6 bits are zero --> = padding
			//
			pBase64Buffer -= 2;
			*pBase64Buffer = '='; 
			++pBase64Buffer;
			*pBase64Buffer = '='; 
			++pBase64Buffer;
			break;

		//
		// Only 2 bytes left - we will have three 6 bits result and one = padding
		//
		case 2:

			//
			// Calc 24 bits value - from 2 bytes
			//
			Temp = ((OctetBuffer[0]) << xFirst8bShift) 
				   + ((OctetBuffer[1]) << xSecond8bShift);

			pBase64Buffer = Convert3OctetTo4Base64(Temp, pBase64Buffer); 

			//
			// Fourth 6 bits are zero --> = padding
			//
			--pBase64Buffer;
			*pBase64Buffer = '='; 
			++pBase64Buffer;
			break;

		default:
			ASSERT(("remainder value should never get here", 0));
			break;
	}

	//
	// Adding end of string
	//
	Base64Buffer[*Base64Len] = '\0';
	return(Base64Buffer);
}


BYTE GetBase64Value(wchar_t Base64CharW)
/*++

Routine Description:
	map Base64 wchar_t to base64 value.
	throw bad_base64 if Base64 char value is not acceptable.

Arguments:
    Base64CharW - (In) base64 wchar_t

Returned Value:
	Base64 value (0-63)
	throw bad_base64 if Base64 char value is not acceptable.

--*/
{
	if((Base64CharW >= TABLE_SIZE(xAscii2Base64)) || (xAscii2Base64[Base64CharW] == 255))
	{
		TrERROR(GENERAL, "bad base64 - base64 char is illegal %d", Base64CharW);
		throw bad_base64();
	}

	return(xAscii2Base64[Base64CharW]);
}


BYTE* 
Base642OctetW(
	LPCWSTR Base64Buffer, 
	DWORD Base64Len,
	DWORD *OctetLen 
	)
/*++

Routine Description:
    Transform wchar_t base64 string to Octet string
	every 4 wchar_t characters base64 (24 bit) are transform into 3 character
	'=' is an extra char in base64 that indicates zero padding.
	end condition: determinate according to the = padding in base64
	how many chars are at the final 4 base64 chars block
	'=' is an extra char that indicates padding
	no = --> last blocks of 4 base64 chars is full and transform to 3 Octet chars
	'=' --> last blocks of 4 base64 chars contain 3 base64 chars and will generate
			2 Octet chars
	'==' --> last blocks of 4 base64 chars contain 2 base64 chars and will generate
			 1 Octet chars

	this function allocate and return the Octet Buffer
	the caller is responsible to free this buffer

Arguments:
    Base64Buffer - (In) base64 buffer of wchar_t 
	Base64Len - (In) base64 buffer length (number of WCHAR elements in buffer)
	OctetLen - (Out) Length of the Octet buffer (number of byte elements in buffer)

Returned Value:
	Octet Buffer 

--*/
{
	DWORD Complete4Chars = Base64Len / 4;

	//
	// base64 length must be divided by 4 - complete 4 chars blocks
	//
	if((Complete4Chars * 4) != Base64Len)
	{
		TrERROR(GENERAL, "bad base64 - base64 buffer length %d dont divide by 4", Base64Len);
		throw bad_base64();
	}

	//
	// Calc Octec length
	//
	*OctetLen = Complete4Chars * 3;
	BYTE* OctetBuffer = new BYTE[*OctetLen];

	if(Base64Buffer[Base64Len - 2] == L'=')
	{
		//
		// '==' padding --> only 1 of the last 3 in the char is used
		//
		ASSERT(Base64Buffer[Base64Len - 1] == L'=');
		*OctetLen -= 2;
	}
	else if(Base64Buffer[Base64Len - 1] == L'=')
	{
		//
		// '=' padding --> only 2 of the last 3 char are used
		//
		*OctetLen -= 1;
	}

	BYTE* pOctetBuffer = OctetBuffer;

	//
	// Convert each 4 wchar_t of base64 (6 bits) to 3 Octet bytes of 8 bits
	// note '=' is mapped to 0 so no need to worry about last 4 base64 block
	// they might be extra Octet byte created in the last block
	// but we will ignore them because the correct value of OctetLen
	//
	for(DWORD i=0; i< Complete4Chars; ++i, Base64Buffer += 4)
	{
		//
		// Calc 24 bits value - from 4 bytes of 6 bits
		//
		DWORD Temp = (GetBase64Value(Base64Buffer[0]) << xFirst6bShift) 
				     + (GetBase64Value(Base64Buffer[1]) << xSecond6bShift) 
				     + (GetBase64Value(Base64Buffer[2]) << xThird6bShift) 
				     + (GetBase64Value(Base64Buffer[3]) << xFourth6bShift);

		//
		// Calc first 8 bits
		//
		DWORD Res = ((Temp & xFirst8bChar) >> xFirst8bShift); 
		ASSERT(Res < 256);
		*pOctetBuffer = static_cast<unsigned char>(Res);
		++pOctetBuffer;

		//
		// Calc second 8 bits
		//
		Res = ((Temp & xSecond8bChar) >> xSecond8bShift); 
		ASSERT(Res < 256);
		*pOctetBuffer = static_cast<unsigned char>(Res);
		++pOctetBuffer;

		//
		// Calc third 8 bits
		//
		Res = ((Temp & xThird8bChar) >> xThird8bShift); 
		ASSERT(Res < 256);
		*pOctetBuffer = static_cast<unsigned char>(Res); 
		++pOctetBuffer;
	}

	return(OctetBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\xds\lib\xdsdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    XdsDebug.cpp

Abstract:
    Xml Digital Signature debugging

Author:
    Ilan Herbst (ilanh) 06-Mar-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Xds.h"
#include "Xdsp.h"

#include "xdsdebug.tmh"

#ifdef _DEBUG

//---------------------------------------------------------
//
// Validate Xml Digital Signature state
//
void XdspAssertValid(void)
{
    //
    // XdsInitalize() has *not* been called. You should initialize the
    // Xml Digital Signature library before using any of its funcionality.
    //
    ASSERT(XdspIsInitialized());

    //
    // TODO:Add more Xml Digital Signature validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void XdspSetInitialized(void)
{
    LONG fXdsAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Xml Digital Signature library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fXdsAlreadyInitialized);
}


BOOL XdspIsInitialized(void)
{
    return s_fInitialized;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\xds\lib\xds.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    xds.cpp

Abstract:
    Xml digital signature functions

Author:
    Ilan Herbst (ilanh) 28-Feb-00

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <Xds.h>
#include "Xdsp.h"
#include <utf8.h>

#include "xds.tmh"


LPSTR
XdsCalcDataDigest(
	const void *Data,
	DWORD DataLen,
	ALG_ID AlgId,
	HCRYPTPROV hCsp
	)
/*++

Routine Description:
	Calc data digest base64 on a buffer
	this function return the DataDigest Buffer (this buffer is allocated by GetHashData function)
	the caller is responsible to free this buffer

Arguments:
    Data - input data to digest (WCHAR)
    DataLen - number of data elements
	AlgId - hash algorithm
	hCsp - crypto provider handle

Returned Value:
	String of the Hash buffer in base64 format

--*/
{
	//
	// Data digest
	//
	ASSERT(Data != 0);
	DWORD HashLen;
	AP<BYTE> HashBuffer = CryCalcHash(
							  hCsp,
							  reinterpret_cast<const BYTE *>(Data), 
							  DataLen,
							  AlgId,
							  &HashLen
							  );

	//
	// Convert digest string to base64 format
	//
	DWORD DataHashLen;
	LPSTR HashBase64 = Octet2Base64(HashBuffer, HashLen, &DataHashLen);

	return(HashBase64);
}


LPWSTR
XdsCalcDataDigestW(
	const void *Data,
	DWORD DataLen,
	ALG_ID AlgId,
	HCRYPTPROV hCsp
	)
/*++

Routine Description:
	Calc data digest base64 on a buffer
	this function return the DataDigest Buffer (this buffer is allocated by GetHashData function)
	the caller is responsible to free this buffer

Arguments:
    Data - input data to digest (WCHAR)
    DataLen - number of data elements
	AlgId - hash algorithm
	hCsp - crypto provider handle

Returned Value:
	WString of the Hash buffer in base64 format

--*/
{
	//
	// Data digest
	//
	ASSERT(Data != 0);
	DWORD HashLen;
	AP<BYTE> HashBuffer = CryCalcHash(
							  hCsp,
							  reinterpret_cast<const BYTE *>(Data), 
							  DataLen,
							  AlgId,
							  &HashLen
							  );

	//
	// Convert digest string to base64 format
	//
	DWORD DataHashLen;
	LPWSTR HashBase64 = Octet2Base64W(HashBuffer, HashLen, &DataHashLen);

	return(HashBase64);
}


LPSTR
XdsGetDataDigest(
	HCRYPTHASH hHash
	)
/*++

Routine Description:
	Get data digest base64 on a hash
	this function return the DataDigest Buffer (this buffer is allocated by GetHashData function)
	the caller is responsible to free this buffer

Arguments:
    hHash - input hash (hash object on data)

Returned Value:
	String of the Hash buffer in base64 format

--*/
{
	//
	// Data digest
	//
	ASSERT(hHash != 0);
	DWORD HashLen;
	AP<BYTE> HashBuffer = CryGetHashData(
							  hHash, 
							  &HashLen
							  );

	//
	// Convert digest string to base64 format
	//
	DWORD DataHashLen;
	LPSTR HashBase64 = Octet2Base64(HashBuffer, HashLen, &DataHashLen);

	return(HashBase64);
}


LPSTR
XdsCalcSignature(
	LPCSTR Data,
	DWORD DataLen,
	ALG_ID AlgId,
	DWORD PrivateKeySpec,
	HCRYPTPROV hCsp
	)
/*++

Routine Description:
	Calc signature on given data
	this function return the Signature Buffer that was allocated by CreateSignature function
	the caller is responsible to free this buffer

Arguments:
    Data - data to be signed (WCHAR)
    DataLen - number of data elements
	AlgId - hash algorithm
	PrivateKeySpec - Identifies the private key to use from the provider. 
					 It can be AT_KEYEXCHANGE or AT_SIGNATURE.
	hCsp - crypto provider handle

Returned Value:
	String buffer of the signature in base64 format

--*/
{

	//
	// Sign Data
	//
	DWORD SignatureLen;
	AP<BYTE> SignBuffer = CryCreateSignature(
							  hCsp,
							  reinterpret_cast<const BYTE*>(Data), 
							  DataLen,
							  AlgId,
							  PrivateKeySpec,
							  &SignatureLen
							  );

	//
	// Convert signature string to base64 format
	//
	DWORD SignLen;
	LPSTR SignatureBase64 = Octet2Base64(SignBuffer, SignatureLen, &SignLen);

	return(SignatureBase64);
}


void
XdsValidateSignature(
	const XmlNode* pSignatureTree,
	HCRYPTKEY hKey,
	HCRYPTPROV hCsp
    )
/*++

Routine Description:
	Validate signature in parsed SignatureTree.
	If validation failed throw bad_signature() exception.
	If bad signature Element throw bad_XmldsigElement().

Arguments:
	pSignatureTree - pointer to the <Signature> (root)
	hKey - the public key corresponding to the private key that was used to signed the signature
	hCsp - crypto provider handle

Returned Value:
	Throw bad_signature() if validation failed, if validation was successfull normal termination
	Throw bad_XmldsigElement() if the Xmldsig Element is not ok
--*/
{
	//
	// Find SignedInfo Element in the signature tree
	//
	const XmlNode* pSignedInfoNode = XmlFindNode(
										 pSignatureTree, 
										 L"Signature!SignedInfo"
										 );

	if(pSignedInfoNode == NULL)
	{
		TrERROR(SECURITY, "bad Xmldsig element - SignedInfo element in signatre was not found");
		throw bad_XmldsigElement();
	}

	ALG_ID AlgId = 0;

	//
	// Elements in SignedInfo
	//
	const List<XmlNode>& SignedInfoNodeList = pSignedInfoNode->m_nodes;

	for(List<XmlNode>::iterator SignedInfoSubNode = SignedInfoNodeList.begin(); 
		SignedInfoSubNode != SignedInfoNodeList.end();
		++SignedInfoSubNode
		)
	{
		//
		// CanonicalizationMethod Element
		// m_tag is xcws_t and == is operator that compare xwcs_t to string.
		//
		if(SignedInfoSubNode->m_tag == L"CanonicalizationMethod")
		{
			//
			// BUGBUG: Dont handle CanonicalizationMethod yet
			//
			ASSERT(0);
		}

		//
		// SignatureMethod Element
		// m_tag is xcws_t and == is operator that compare xwcs_t to string.
		//
		if(SignedInfoSubNode->m_tag == L"SignatureMethod")
		{
			const xwcs_t* value = XmlGetAttributeValue(
									  &*SignedInfoSubNode, 
									  L"Algorithm"
									  );

			if(!value)
			{
				TrERROR(SECURITY, "bad Xmldsig Element - no Algorithm attribute was found in SignatureMethod element");
				throw bad_XmldsigElement();
			}

			//
			// Searching all possible names 
			//
			for(DWORD i = 0; i < TABLE_SIZE(xSignatureAlgorithm2SignatureMethodNameW); ++i)
			{
				if(*value == xSignatureAlgorithm2SignatureMethodNameW[i])
				{
					AlgId = xSignatureAlgorithm2AlgId[i]; // CALG_SHA1
				}
			}

			if(AlgId == 0)
			{
				TrERROR(SECURITY, "Bad Xmldsig Signature Algorithm %.*ls", LOG_XWCS(*value));
				throw bad_XmldsigElement();
			}
		}
	}

	//
	// Must have AlgId
	//
	if(AlgId == 0)
	{
		TrERROR(SECURITY, "bad XmldsigElement - did not find SignatureMethod");
		throw bad_XmldsigElement();
	}

	const XmlNode* pSignatureValueNode = XmlFindNode(
											 pSignatureTree, 
											 L"Signature!SignatureValue"
											 );

	if(pSignatureValueNode == NULL)
	{
		TrERROR(SECURITY, "bad XmldsigElement - did not found SignatureValue element in the signature");
		throw bad_XmldsigElement();
	}

	//
	// Convert the WCHAR base64 buffer to Octet buffer this is done because the signature result
	// is an Octet buffer that was latter transform to WCHAR base64 and was put in the SignatureValue element
	//
	DWORD SignValLen;
	AP<BYTE> SignValBuffer = Base642OctetW(
							     pSignatureValueNode->m_values.front().m_value.Buffer(), 
							     pSignatureValueNode->m_values.front().m_value.Length(), 
							     &SignValLen
							     );

	//
	// Convert the SignedInfo element to utf8 for validation
	// We must to this conversion because the signature was calculated on the utf8 format of SignedInfo element.
	//
	utf8_str pSignedInfoUtf8 = UtlWcsToUtf8(pSignedInfoNode->m_element.Buffer(), pSignedInfoNode->m_element.Length()); 

	//
	// Validate signature
	//
	bool fValidSignature = CryValidateSignature(
							   hCsp,
							   SignValBuffer, // Signature Value
							   SignValLen, 
							   pSignedInfoUtf8.data(), 
							   numeric_cast<DWORD>(pSignedInfoUtf8.size()),  // length of the data that was signed
							   AlgId,
							   hKey
							   );

	if(fValidSignature)
		return;

	TrERROR(SECURITY, "bad Signature Validation");
	throw bad_signature();
}


void
XdsValidateReference(
	const CXdsReferenceValidateInfo& ReferenceValidateInfo,
	HCRYPTPROV hCsp
    )
/*++

Routine Description:
	Validate reference in Xmldsig.
	If validation failed throw bad_reference() exception.

Arguments:
	ReferenceValidateInfo - Information for reference validation
	hCsp - crypto provider handle

Returned Value:
	Throw bad_reference() if validation failed, if validation was successfull normal termination

--*/
{
	//
	// Calc Digest Value on Reference data
	//
	ASSERT(ReferenceValidateInfo.ReferenceData().Buffer() != NULL);

	AP<WCHAR> VerifyDigestValue = XdsCalcDataDigestW(
								      ReferenceValidateInfo.ReferenceData().Buffer(),
								      ReferenceValidateInfo.ReferenceData().Length(),
								      ReferenceValidateInfo.HashAlgId(),
								      hCsp 
								      );

	//
	// Check for identical Hash values, xstr operator ==
	//
	bool fVerifyDigest = (ReferenceValidateInfo.DigestValue() == VerifyDigestValue);

	if(fVerifyDigest)
		return;

	TrERROR(SECURITY, "bad Refernce Validation");
	throw bad_reference();
}


ReferenceValidateVectorType
XdsGetReferenceValidateInfoVector(
	const XmlNode* pSignatureTree
    )
/*++

Routine Description:
	Get vector of pointers to CXdsReferenceValidateInfo from SignatureTree
	If bad signature Element throw bad_XmldsigElement().

Arguments:
    pSignatureTree - pointer to Signature root node

Returned Value:
	Vector of pointers to CXdsReferenceValidateInfo
	If bad signature Element throw bad_XmldsigElement().

--*/
{
	//
	// Find SignedInfo Element in the signature tree
	//
	const XmlNode* pSignedInfoNode = XmlFindNode(
										 pSignatureTree, 
										 L"Signature!SignedInfo"
										 );
	if(pSignedInfoNode == NULL)
	{
		TrERROR(SECURITY, "bad Xmldsig element - SignedInfo element in signatre was not found");
		throw bad_XmldsigElement();
	}

	ReferenceValidateVectorType ReferenceValidateVector;

	//
	// to free ReferenceValidateVector in case of exception we use the try block
	// 
	try
	{
		//
		// Creating Reference Validate Information
		//
		const List<XmlNode>& SignedInfoNodeList = pSignedInfoNode->m_nodes;

		for(List<XmlNode>::iterator SignedInfoSubNode = SignedInfoNodeList.begin(); 
			SignedInfoSubNode != SignedInfoNodeList.end();
			++SignedInfoSubNode
			)
		{
			if(SignedInfoSubNode->m_tag != L"Reference")
				continue;

			//
			// Handle Reference Elements only
			//

			const XmlNode* pRefNode = &*SignedInfoSubNode;

			//
			// Find Uri Attribute in Reference Element
			//
			const xwcs_t* pUri = XmlGetAttributeValue(
									 pRefNode, 
									 L"URI"
									 );
			
			if(pUri == NULL)
			{
				TrERROR(SECURITY, "bad Xmldsig element - URI element in Reference Element was not found");
				throw bad_XmldsigElement();
			}

			//
			// Find HashValue, DigestMethod Elements in Reference Element
			//
			const xwcs_t* pDigestValue = 0;
			const xwcs_t* pDigestMethod = 0;

			const List<XmlNode>& RefNodeList = pRefNode->m_nodes;

			for(List<XmlNode>::iterator RefSubNode = RefNodeList.begin(); 
				RefSubNode != RefNodeList.end();
				++RefSubNode
				)
			{
				if(RefSubNode->m_tag == L"Transforms")
				{
					//
					// Dont handle transforms
					//
					ASSERT(("", 0));
				}
				else if(RefSubNode->m_tag == L"DigestValue")
				{
					pDigestValue = &RefSubNode->m_values.front().m_value;
				}
				else if(RefSubNode->m_tag == L"DigestMethod")
				{
					pDigestMethod = XmlGetAttributeValue(
										&*RefSubNode, 
										L"Algorithm"
										);
				}
			}

			if(pDigestValue == NULL)
			{
				TrERROR(SECURITY, "bad Xmldsig element - DigestValue element in Reference Element was not found");
				throw bad_XmldsigElement();
			}
			if(pDigestMethod == NULL)
			{
				TrERROR(SECURITY, "bad Xmldsig element - DigestMethod element in Reference Element was not found");
				throw bad_XmldsigElement();
			}

			CXdsReferenceValidateInfo* pRefInfo = new CXdsReferenceValidateInfo(
														  *pUri,
														  *pDigestMethod,
														  *pDigestValue
					 									  );

			//
			// Insert to Vector
			//
			ReferenceValidateVector.push_back(pRefInfo);
		}

	}
	catch(const exception&)
	{
		//
		// Some exception occur, Free ReferenceValidateVector
		//
		for(ReferenceValidateVectorType::iterator ir = ReferenceValidateVector.begin(); 
			ir != ReferenceValidateVector.end();)
		{
			CXdsReferenceValidateInfo* pReferenceValidateInfo = *ir;
			ir = ReferenceValidateVector.erase(ir);
			delete pReferenceValidateInfo;
		}

		throw;
	}

	return(ReferenceValidateVector);
}


std::vector<bool>
XdsValidateAllReference(
	const ReferenceValidateVectorType& ReferenceValidateInfoVector,
	HCRYPTPROV hCsp
    )
/*++

Routine Description:
	Validate all reference in the ReferenceValidateInfoVector

Arguments:
    ReferenceValidateInfoVector - Vector of pointer to validate info for each reference 
	hCsp - crypto provider handle

Returned Value:
	Vector of bool containing the reference validation result
	the vector size is the number of references
	for each reference a bool value: 1 = validation is correct
									 0 = validation failed

--*/
{
	std::vector<bool> RefValidateResult;

	//
	// Validating each reference in the vector
	//
	for(ReferenceValidateVectorType::const_iterator ir = ReferenceValidateInfoVector.begin();
		ir != ReferenceValidateInfoVector.end();
		++ir
		)
	{
		//
		// Reference Validation, Reference inside the doc
		//
		try
		{
			XdsValidateReference(
				**ir,
				hCsp
				);

			//
			// Reference Validation ok
			//
			RefValidateResult.push_back(true);
		}
		catch (const bad_reference&)
		{
			//
			// Reference Validation failed
			//
			RefValidateResult.push_back(false);
		}
	}

	return(RefValidateResult);
}


void
XdsCoreValidation(
	const XmlNode* pSignatureNode,
	HCRYPTKEY hKey,
	const ReferenceValidateVectorType& ReferenceValidateInfoVector,
	HCRYPTPROV hCsp
    ) 
/*++

Routine Description:
	Perform CoreValidation on xml digital signature
	core validation is true if signature validation it true
	and each of the reference validation is true

	If validation failed throw bad_signature() or bad_reference() exception.
	depend on which part of the core validation failed.

Arguments:
	pSignatureNode - pointer to the SignatureNode (signature root)
	hKey - the public key from the corresponding to the private key that was used to signed the signature
	ReferenceValidateInfoVector -  Vector of pointer to validate info for each reference  
	hCsp - crypto provider handle

Returned Value:
	Throw bad_signature() or bad_reference() if validation failed, 
	if validation was successfull normal termination

--*/
{

	//
	// Signature Validation
	//
	XdsValidateSignature(
		pSignatureNode,
		hKey,
		hCsp
		);

	//
	// Reference Vector Validation
	//
	for(ReferenceValidateVectorType::const_iterator ir = ReferenceValidateInfoVector.begin();
		ir != ReferenceValidateInfoVector.end(); 
		++ir
		)
	{
		XdsValidateReference(
			**ir,
			hCsp
			);

	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\xds\lib\xdsclass.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    XdsClass.cpp

Abstract:
    Xml digital signature Class constructors and other functions

Author:
    Ilan Herbst (ilanh) 12-Mar-2000

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <Xds.h>
#include "Xdsp.h"

#include "xdsclass.tmh"

//
// CXdsReferenceInput
//

//
//  HashAlgorithm tables
//	We need both unicode (validation code is on unicode)
//  and ansi (creating the signature element is done in ansi)
//
const LPCWSTR xHashAlgorithm2DigestMethodNameW[] = {
	L"http://www.w3.org/2000/02/xmldsig#sha1",
	L"http://www.w3.org/2000/02/xmldsig#md5"
};

const LPCSTR xHashAlgorithm2DigestMethodName[] = {
	"http://www.w3.org/2000/02/xmldsig#sha1",
	"http://www.w3.org/2000/02/xmldsig#md5"
};

const ALG_ID xHashAlgorithm2AlgId[] = {
	CALG_SHA1,
	CALG_MD5
};

C_ASSERT(TABLE_SIZE(xHashAlgorithm2DigestMethodNameW) == TABLE_SIZE(xHashAlgorithm2AlgId));
C_ASSERT(TABLE_SIZE(xHashAlgorithm2DigestMethodName) == TABLE_SIZE(xHashAlgorithm2AlgId));


inline LPCSTR DigestMethodName(CXdsReference::HashAlgorithm HashAlg)
{
	ASSERT((HashAlg >= 0) && (HashAlg < TABLE_SIZE(xHashAlgorithm2DigestMethodName)));
    return(xHashAlgorithm2DigestMethodName[HashAlg]);
}


inline ALG_ID HashAlgId(CXdsReference::HashAlgorithm HashAlg)
{
	ASSERT((HashAlg >= 0) && (HashAlg < TABLE_SIZE(xHashAlgorithm2AlgId)));
    return(xHashAlgorithm2AlgId[HashAlg]);
}


inline LPCSTR DigestMethodName(ALG_ID HashAlgId)
{
	for(DWORD i = 0; i < TABLE_SIZE(xHashAlgorithm2AlgId); ++i)
	{
		if(HashAlgId == xHashAlgorithm2AlgId[i])
		{
			return(xHashAlgorithm2DigestMethodName[i]);
		}
	}

	//
	// dont suppose to get here
	//
	ASSERT(0);
	return(0);
}


CXdsReferenceInput::CXdsReferenceInput(
	HashAlgorithm HashAlg,
	LPCSTR DigestValue,
	LPCSTR Uri,
	LPCSTR Type
	) :
	m_ReferenceData(),
	m_HashAlgId(HashAlgId(HashAlg)),
	m_DigestMethodName(DigestMethodName(HashAlg)),
	m_DigestValue(newstr(DigestValue)),
	m_Uri(newstr(Uri)),
	m_Type(newstr(Type))
/*++

Routine Description:
	m_ReferenceData empty
	DigestValue must be given

--*/
{
	ASSERT(m_Uri != 0);
	ASSERT(m_DigestValue != 0);
}


CXdsReferenceInput::CXdsReferenceInput(
	const xdsvoid_t& ReferenceData,
	HashAlgorithm HashAlg,
	LPCSTR Uri,
	LPCSTR Type,
	HCRYPTPROV hCsp
	) :
	m_ReferenceData(ReferenceData),
	m_HashAlgId(HashAlgId(HashAlg)),
	m_DigestMethodName(DigestMethodName(HashAlg)),
	m_DigestValue(XdsCalcDataDigest(
					  ReferenceData.Buffer(),
					  ReferenceData.Length(),
					  m_HashAlgId,
					  hCsp
					  )),
	m_Uri(newstr(Uri)),
	m_Type(newstr(Type))

/*++

Routine Description:
	ReferenceData given for calc DigestValue

--*/
{
	ASSERT(m_Uri != 0);
	ASSERT(m_ReferenceData.Buffer() != 0);
}


CXdsReferenceInput::CXdsReferenceInput(
	ALG_ID AlgId,
	LPCSTR DigestValue,
	LPCSTR Uri,
	LPCSTR Type
	) :
	m_ReferenceData(),
	m_HashAlgId(AlgId),
	m_DigestMethodName(DigestMethodName(AlgId)),
	m_DigestValue(newstr(DigestValue)),
	m_Uri(newstr(Uri)),
	m_Type(newstr(Type))
/*++

Routine Description:
	m_ReferenceData empty
	DigestValue must be given

--*/
{
	ASSERT(m_Uri != 0);
	ASSERT(m_DigestValue != 0);
}


CXdsReferenceInput::CXdsReferenceInput(
	const xdsvoid_t& ReferenceData,
	ALG_ID AlgId,
	LPCSTR Uri,
	LPCSTR Type,
	HCRYPTPROV hCsp
	) :
	m_ReferenceData(ReferenceData),
	m_HashAlgId(AlgId),
	m_DigestMethodName(DigestMethodName(AlgId)),
	m_DigestValue(XdsCalcDataDigest(
					  ReferenceData.Buffer(),
					  ReferenceData.Length(),
					  m_HashAlgId,
					  hCsp
					  )),
	m_Uri(newstr(Uri)),
	m_Type(newstr(Type))

/*++

Routine Description:
	ReferenceData given for calc DigestValue

--*/
{
	ASSERT(m_Uri != 0);
	ASSERT(m_ReferenceData.Buffer() != 0);
}


//
// CXdsReferenceValidateInfo
//

ALG_ID HashAlgId(xwcs_t DigestMethodName)
{
	for(DWORD i = 0; i < TABLE_SIZE(xHashAlgorithm2DigestMethodNameW); ++i)
	{
		if(DigestMethodName == xHashAlgorithm2DigestMethodNameW[i])
		{
			return(xHashAlgorithm2AlgId[i]);
		}
	}

	//
	// should not get here
	//
	TrERROR(SECURITY, "Bad Xmldsig element - did not support mapping DigestMethodName %.*ls to AlgId", LOG_XWCS(DigestMethodName));
	throw bad_XmldsigElement();

}

	
CXdsReferenceValidateInfo::CXdsReferenceValidateInfo(
	xwcs_t Uri,
	xwcs_t DigestMethodName,
	xwcs_t DigestValue
	) :
	m_Uri(Uri),
	m_DigestValue(DigestValue),
	m_ReferenceData(),
	m_HashAlgId(::HashAlgId(DigestMethodName))
{
}


CXdsReferenceValidateInfo::CXdsReferenceValidateInfo(
	xwcs_t Uri,
	xwcs_t DigestMethodName,
	xwcs_t DigestValue,
	const xdsvoid_t& ReferenceData
	) :
	m_Uri(Uri),
	m_DigestValue(DigestValue),
	m_ReferenceData(ReferenceData),
	m_HashAlgId(::HashAlgId(DigestMethodName))
{
}


inline LPCSTR SignatureMethodName(CXdsSignedInfo::SignatureAlgorithm SignatureAlg)
{
	ASSERT((SignatureAlg >= 0) && (SignatureAlg < TABLE_SIZE(xSignatureAlgorithm2SignatureMethodName)));
    return(xSignatureAlgorithm2SignatureMethodName[SignatureAlg]);
}


inline ALG_ID SignatureAlgId(CXdsSignedInfo::SignatureAlgorithm SignatureAlg)
{
	ASSERT((SignatureAlg >= 0) && (SignatureAlg < TABLE_SIZE(xSignatureAlgorithm2AlgId)));
	return(xSignatureAlgorithm2AlgId[SignatureAlg]);
}


CXdsSignedInfo::CXdsSignedInfo(
	SignatureAlgorithm SignatureAlg,
	LPCSTR Id,
	std::vector<CXdsReferenceInput*>& ReferenceInputs
	):
	m_SignatureMethodName(SignatureMethodName(SignatureAlg)),
	m_SignatureAlgId(::SignatureAlgId(SignatureAlg)),
	m_Id(newstr(Id)),
	m_ReferenceInputs(ReferenceInputs)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\xds\lib\xdsinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    XdsInit.cpp

Abstract:
    Xml Digital Signature initialization

Author:
    Ilan Herbst (ilanh) 06-Mar-00

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Xds.h"
#include "Xdsp.h"

#include "xdsinit.tmh"

VOID
XdsInitialize(
    VOID
    )
/*++

Routine Description:
    Initializes Xml Digital Signature library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the Xml Digital Signature library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!XdspIsInitialized());

    //
    // TODO: Write Xml Digital Signature initalization code here
    //

    XdspSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\xds\lib\xdsp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Xdsp.h

Abstract:
    Xml Digital Signature private functions.

Author:
    Ilan Herbst (ilanh) 06-Mar-00

--*/

#pragma once

#ifdef _DEBUG

void XdspAssertValid(void);
void XdspSetInitialized(void);
BOOL XdspIsInitialized(void);

#else // _DEBUG

#define XdspAssertValid() ((void)0)
#define XdspSetInitialized() ((void)0)
#define XdspIsInitialized() TRUE

#endif // _DEBUG

//
//  SignatureAlgorithm tables
//	We need both unicode (validation code is on unicode)
//  and ansi (creating the signature element is done in ansi)
//
const LPCWSTR xSignatureAlgorithm2SignatureMethodNameW[] = {
	L"http://www.w3.org/2000/02/xmldsig#dsa"
};

const LPCSTR xSignatureAlgorithm2SignatureMethodName[] = {
	"http://www.w3.org/2000/02/xmldsig#dsa"
};

const ALG_ID xSignatureAlgorithm2AlgId[] = {
	CALG_SHA1
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\xds\lib\xdselements.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    xdsElements.cpp

Abstract:
    Xml digital signature functions for operators << of the signature elements 

Author:
    Ilan Herbst (ilanh) 28-Feb-00

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <Xds.h>
#include "Xdsp.h"

#include "xdselements.tmh"

using std::ostringstream;
using std::ostream;
using std::string;

//
// xEndLine: >
//
LPCSTR xEndLine = ">";

//
// xQEndLine: ">
//
LPCSTR xQEndLine = "\">";


ostream& operator<<(std::ostream& os, const CXdsReferenceInput& ReferenceInput)

/*++

Routine Description:
	Add Reference Element in XmlDsig to ostringstream
	according to RefElementInfo

Arguments:
    os - wstring stream that will be updated
	ReferenceInput - Reference element information

Returned Value:
	ostringstream with the Reference element

--*/
{
	//
	// Reference element
	//
	os << "<Reference URI=\"";
	os << static_cast<LPCSTR>(ReferenceInput.m_Uri);

	//
	// Type (optional)
	//
	if(ReferenceInput.m_Type)
	{
		os << "\" Type=\"";
		os << static_cast<LPCSTR>(ReferenceInput.m_Type);
	}

	os << xQEndLine;

	//
	// DigestMethod Element
	//
	os << "<DigestMethod Algorithm=\"";
	os << ReferenceInput.m_DigestMethodName;
	os << xQEndLine;
	os << "</DigestMethod>";

	//
	// DigestValue Element
	//
	ASSERT(ReferenceInput.m_DigestValue != 0);

	os << "<DigestValue>";
	os << static_cast<LPCSTR>(ReferenceInput.m_DigestValue);
	os << "</DigestValue>";

	//
	// Close Reference element
	//
	os << "</Reference>";

	return(os);
}


ostream& operator<<(std::ostream& os, const CXdsSignedInfo& SignedInfo)

/*++

Routine Description:
	Add SignedInfo Element in XmlDsig to ostringstream
	according to SignedInfo

Arguments:
    os - string stream that will be updated
	SignedInfo - SignedInfo element information

Returned Value:
	ostringstream with the SignedInfo element

--*/
{
	//
	// SignedInfo element
	//
	os << "<SignedInfo";

	//
	// m_Id (optional)
	//
	if(SignedInfo.m_Id)
	{
		os << " Id=\"";
		os << static_cast<LPCSTR>(SignedInfo.m_Id);
		os << "\"";
	}

	os << xEndLine;

	//
	// SignatureMethod
	//
	os << "<SignatureMethod Algorithm=\"";
	os << SignedInfo.m_SignatureMethodName << xQEndLine;
	os << "</SignatureMethod>";

	//
	// References
	//
	for(ReferenceInputVectorType::const_iterator it = SignedInfo.m_ReferenceInputs.begin(); 
			it != SignedInfo.m_ReferenceInputs.end(); 
			++it
			)
	{
		os << **it;
	}

	//
	// Close SignedInfo element
	//
	os << "</SignedInfo>";
	return(os);
}


ostringstream& operator<<(ostringstream& oss, const CXdsSignature& Signature)
/*++

Routine Description:
	Add Signature Element (XmlDsig) to ostringstream

	Note: If you need to detach string from ostringstream (this operation freeze the ostringstream)
		  and latter unfreeze the ostringstream 
	      this function is an example how to do this

	This Function calc the SignatureValue on the SignedInfo Element

Arguments:
    oss - string stream that will be updated
	Signature - Signature element information

Returned Value:
	ostringstream with the Signature element

--*/
{
	//
	// Signature element
	//
	oss << "<Signature xmlns=\"http://www.w3.org/2000/02/xmldsig#";
	oss << "\"";

	//
	// m_Id (optional)
	//
	if(Signature.m_Id)
	{
		//
		// Closing " xmlns "
		//
		oss << " Id=\"";
		oss << static_cast<LPCSTR>(Signature.m_Id);
		oss << "\"";

	}

	oss << xEndLine;

	size_t SignedInfoStart = oss.str().size();

	//
	// SignedInfo element
	//
	oss << Signature.m_SignedInfo;

	size_t SignedInfoEnd = oss.str().size();

	//
	// SignatureValue
	//
	oss << "<SignatureValue>";

	if(Signature.m_SignatureValue)
	{
		oss << static_cast<LPCSTR>(Signature.m_SignatureValue);
	}
	else
	{
		//
		// BUGBUG: did not handle the canonalization transforms on SignedInfo
		//

		//
		// Signature Value on SignedInfoElement including start and end tag
		//
		string TempStr = oss.str();

		ASSERT((SignedInfoEnd - SignedInfoStart) < ULONG_MAX);

		AP<char> SignatureValue = XdsCalcSignature(
										 TempStr.data() + SignedInfoStart, // SignedInfo start
										 static_cast<DWORD>(SignedInfoEnd - SignedInfoStart),   // SignedInfo len
										 Signature.SignatureAlgId(),
										 Signature.m_PrivateKeySpec,
										 Signature.m_hCsp
										 );	

		oss << static_cast<LPCSTR>(SignatureValue);
	}

	oss << "</SignatureValue>";

	//
	// Optional KeyInfo 
	//
	if(Signature.m_KeyValue)
	{
		oss << "<KeyInfo>";
		oss << "<KeyValue>";
		oss << static_cast<LPCSTR>(Signature.m_KeyValue);
		oss << "</KeyValue>";
		oss << "</KeyInfo>";
	}

	//
	// Close Signature element
	//
	oss << "</Signature>";
	return(oss);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\xds\test\crysimulate.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    CrySimulate.cpp

Abstract:
    Simulation of Cry library functions for XdsTest

Author:
    Ilan Herbst (ilanh) 9-May-2000

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Cry.h"

#include "CrySimulate.tmh"

//
// Compilation flag for choosing to use this simulation or the Cry library implementation
//
#define CRY_SIMULATE

#ifdef CRY_SIMULATE

const int xFailCycle = 30;
static int s_fail=0;

HCRYPTPROV 
CryAcquireCsp(
	LPCTSTR /*CspProvider*/
	)
/*++

Routine Description:
	Aquire Crypto Service Provider (csp) 

Arguments:
    hCsp - (out) handle to csp

Returned Value:
	None.

--*/
{
	s_fail++;
	if( (s_fail % xFailCycle) == 0)
	{
		TrERROR(SECURITY, "dummy provider execption");
		throw bad_CryptoProvider(2);
	}
	
	HCRYPTPROV hCsp = 5;
	return(hCsp);
}


HCRYPTKEY 
CryGetPublicKey(
	DWORD /*PrivateKeySpec*/,
	HCRYPTPROV /*hCsp*/
	)
/*++

Routine Description:
	get public key from the crypto service provider (csp) 

Arguments:
	PrivateKeySpec - Identifies the private key to use from the provider. 
					 It can be AT_KEYEXCHANGE or AT_SIGNATURE.
    hCsp - handle to the crypto provider.

Returned Value:
    handle to the public key 

--*/
{
    s_fail++;
	if( (s_fail % xFailCycle) == 0)
	{
		TrERROR(SECURITY, "dummy crypto api execption in GetPublicKey");
		throw bad_CryptoApi(3);
	}
	//
	// Get user public key from the csp 
	//
	HCRYPTKEY hKey = 18;

	return(hKey);
}


HCRYPTHASH 
CryCreateHash(
	HCRYPTPROV /*hCsp*/, 
	ALG_ID /*AlgId*/
	)
/*++

Routine Description:
	Create initialized hash object 

Arguments:
    hCsp - handle to the crypto provider.
	AlgId - (in) hash algorithm

Returned Value:
	the initialized hash object

--*/
{
    s_fail++;
	if( (s_fail % xFailCycle) == 0)
	{
		TrERROR(SECURITY, "dummy crypto api execption in CreateHash");
		throw bad_CryptoApi(5);
	}

	HCRYPTHASH hHash = 8;

	return(hHash);
}


void 
CryHashData(
	const BYTE * /*Buffer*/, 
	DWORD /*BufferLen*/, 
	HCRYPTHASH /*hHash*/
	)
/*++

Routine Description:
	Perform data digest on a buffer and put the result in hash object.

Arguments:
    Buffer - Input data to be hashed/digest.
	BufferLen - Length of the input data.
	hHash - Hash object to put the result of the digested data.

Returned Value:
	None.

--*/
{
	s_fail++;
	if( (s_fail % xFailCycle) == 0)
	{
		TrERROR(SECURITY, "dummy crypto api execption in HashData");
		throw bad_CryptoApi(8);
	}

	return;
}

const LPCSTR xDummyHash = "dummyhash";

BYTE* 
CryGetHashData(
	const HCRYPTHASH /*hHash*/,
	DWORD *HashValLen
	)
/*++

Routine Description:
	Get the Hash value from a Hash object.
	after getting this value we can not use this Hash object again

Arguments:
	hHash - Hash object to put the result of the digested data.
	HashValLen - Length of the hash value.

Returned Value:
	Hash value of the Hash object.

--*/
{
	s_fail++;
	if( (s_fail % xFailCycle) == 0)
	{
		TrERROR(SECURITY, "dummy crypto api execption in GetHashData");
		throw bad_CryptoApi(11);
	}

	AP<BYTE> HashVal = reinterpret_cast<BYTE *>(newstr(xDummyHash));
	*HashValLen = strlen(xDummyHash);
	return(HashVal.detach());
}


BYTE* 
CryCalcHash(
	HCRYPTPROV /*hCsp*/,
	const BYTE* /*Buffer*/, 
	DWORD /*BufferLen*/, 
	ALG_ID /*AlgId*/,
	DWORD *HashLen
	)
/*++

Routine Description:
	Calc Hash buffer 
	this function return the HashData Buffer that was allocated in GetHashData function
	the caller is responsible to free this buffer


Arguments:
    hCsp - handle to the crypto provider.
    Buffer - data buffer to be signed
	BufferLen - Length of data buffer
	AlgId - (in) hash algorithm
	HashLen - (out) Hash Value length

Returned Value:
    Hash Value

--*/
{
	s_fail++;
	if( (s_fail % xFailCycle) == 0)
	{
		TrERROR(SECURITY, "dummy crypto api execption in CalcHash");
		throw bad_CryptoApi(20);
	}

	AP<BYTE> HashVal = reinterpret_cast<BYTE *>(newstr(xDummyHash));
	*HashLen = strlen(xDummyHash);
	return(HashVal.detach());
}


BYTE* 
CryCreateSignature(
	HCRYPTPROV /*hCsp*/,
	const BYTE* /*Buffer*/, 
	DWORD /*BufferLen*/, 
	ALG_ID /*AlgId*/,
	DWORD /*PrivateKeySpec*/,
	DWORD *SignLen
	)
/*++

Routine Description:
	Create the signature on a given buffer - digest, sign. 
	This function allocate and return the Signature Buffer
	the caller is responsible to free this buffer

Arguments:
    hCsp - handle to the crypto provider.
    Buffer - data buffer to be signed
	BufferLen - Length of data buffer
	AlgId - (in) hash algorithm
	PrivateKeySpec - (in) Identifies the private key to use from the provider. 
					 It can be AT_KEYEXCHANGE or AT_SIGNATURE.
	SignLen - (out) SignBuffer length

Returned Value:
    Signature buffer

--*/
{
    s_fail++;
	if( (s_fail % xFailCycle) == 0)
	{
		TrERROR(SECURITY, "dummy crypto api execption in CreateSignature");
		throw bad_CryptoApi(9);
	}

	const LPCSTR xDummySignature = "dummysignature";
    AP<BYTE> SignBuffer = reinterpret_cast<BYTE *>(newstr(xDummySignature));
	*SignLen = strlen(xDummySignature);
	return(SignBuffer.detach());
}


bool 
CryValidateSignature(
	HCRYPTPROV /*hCsp*/,
	const BYTE* /*SignBuffer*/, 
	DWORD /*SignBufferLen*/, 
	const BYTE* /*Buffer*/,
	DWORD /*BufferLen*/,
	ALG_ID /*AlgId*/,
	HCRYPTKEY /*hKey*/
	)
/*++

Routine Description:
	Validate signature according to the signature buffer and the original
	data buffer that was signed.

Arguments:
    hCsp - handle to the crypto provider.
	SignBuffer - Signature Buffer.
	SignBufferLen - Length of SignBuffer.
	Buffer - Original Buffer that was signed.
	BufferLen - Length of Buffer.
	AlgId - (in) hash algorithm
	hKey - Key for unlocking the signature (signer public key)

Returned Value:
	True if Signature validation was succesful
	False if failure in validate the signature.

--*/
{
	s_fail++;
	if( (s_fail % xFailCycle) == 0)
	{
		TrERROR(SECURITY, "dummy crypto api execption in ValidateSignature");
		throw bad_CryptoApi(6);
	}

	return(true);
}


#endif // CRY_SIMULATE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\xds\test\xdstest.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    XdsTest.cpp

Abstract:
    Xml Digital Signature library test

	"usage: \n\n"
	"    /h     dumps this usage text.\n"
	"    /s     AT_SIGNATURE Private Key \n"
	"    /x     AT_KEYEXCHANGE Private Key \n"


Author:
    Ilan Herbst (ilanh) 06-Mar-00

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Xds.h"
#include "Cry.h"
#include "xml.h"
#include "xstr.h"
#include <utf8.h>

#include "XdsTest.tmh"

//
// Ref1 data object
//
const LPCWSTR xRef1Data = 
	L"        <ReferenceObject1 ID=\"Ref1Id\">\r\n"
	L"            <Ref1Data>\r\n"
	L"                This Is Reference Number 1\r\n" 
	L"                msmq3 Reference test\r\n" 
	L"            </Ref1Data>\r\n"
	L"        </ReferenceObject1>\r\n";

//
// Ref2 data object
//
const LPCWSTR xRef2Data = 
	L"        <ReferenceObject2 ID=\"Ref2Id\">\r\n"
	L"            <Ref2Data>\r\n"
	L"                This Is Reference Number 2\r\n" 
	L"                the date is 9.3.2000\r\n" 
	L"            </Ref2Data>\r\n"
	L"        </ReferenceObject2>\r\n";

//
// Ref3 data object
//
const LPCWSTR xRef3Data = 
	L"        <ReferenceObject3 ID=\"Ref3Id\">\r\n"
	L"            <Ref3Data>\r\n"
	L"                This Is Reference Number 3\r\n" 
	L"                the day is thursday\r\n" 
	L"            </Ref3Data>\r\n"
	L"        </ReferenceObject3>\r\n";

//
// Ref4 data object
//
const LPCWSTR xRef4Data = 
	L"        <ReferenceObject4 ID=\"Ref4Id\">\r\n"
	L"            <Ref4Data>\r\n"
	L"                This Is Reference Number 4\r\n" 
	L"                Hello World\r\n" 
	L"            </Ref4Data>\r\n"
	L"        </ReferenceObject4>\r\n";


//
// Usage
//
const char xOptionSymbol1 = '-';
const char xOptionSymbol2 = '/';

const char xUsageText[] =
	"usage: \n\n"
	"    /h     dumps this usage text.\n"
	"    /s     AT_SIGNATURE Private Key \n"
	"    /x     AT_KEYEXCHANGE Private Key \n";

inline
void 
DumpUsageText( 
	void 
	)
{
	printf( "%s\n" , xUsageText);
}


DWORD g_PrivateKeySpec = AT_SIGNATURE;
BOOL g_fErrorneous = false;


void SetActivation( int argc, LPCTSTR argv[] )
/*++
Routine Description:
    translates command line arguments.

Arguments:
    main's command line arguments.

Returned Value:

proper command line syntax:
	"usage: \n\n"
	"    /h     dumps this usage text.\n"
	"    /s     AT_SIGNATURE Private Key \n"
	"    /x     AT_KEYEXCHANGE Private Key \n"
--*/
{
	
	if(argc == 1)
	{
		printf("Test AT_SIGNATURE Private Key\n");
		return;
	}

	for(int index = 1; index < argc; index++)
	{
		if((argv[index][0] != xOptionSymbol1) && (argv[index][0] != xOptionSymbol2))	
		{
			TrERROR(SECURITY, "invalid option switch %lc, option switch should be - or /", argv[index][0]);
			g_fErrorneous = true;
			continue;
		}

		//
		// consider argument as option and switch upon its second (sometimes also third) character.
		//
		switch(argv[index][1])
		{
			case 's':
			case 'S':
				g_PrivateKeySpec = AT_SIGNATURE;
				printf("Test AT_SIGNATURE Private Key\n");
				break;

			case 'x':
			case 'X':	
				g_PrivateKeySpec = AT_KEYEXCHANGE;
				printf("Test AT_KEYEXCHANGE Private Key\n");
				break;

			case 'H':	
			case 'h':
			case '?':
				g_fErrorneous = true;
				break;

			default:
				TrERROR(SECURITY, "invalid command line argument %ls", argv[index]);
				g_fErrorneous = true;
				return;
		};
	}

	return;
}



LPSTR TestCreateSignature(DWORD PrivateKeySpec, HCRYPTPROV hCsp)
/*++

Routine Description:
	Test create signature element functions
	This is an example what is need to be done in order to create signature
	This simulate the sender side

Arguments:
	PrivateKeySpec - Identifies the private key to use from the provider. 
					 It can be AT_KEYEXCHANGE or AT_SIGNATURE.
	hCsp - crypto provider handle

Returned Value:
	Signature Element string

--*/
{
	//
	// First Signature Example
	//

	//
	// Test Building Signature Element from a given references
	// some of the references are internal - so data digest on them
	// is done.
	// some of the references are external and their data is not available
	// in this case must supply digest value

	//
	// Initialize References Information
	//


	CXdsReferenceInput::HashAlgorithm DigestMethod = CXdsReferenceInput::haSha1;
	//
	// Ref1 - Internal reference
	//			RefData is given
	//			DigestValue not given will be calculate in the reference constructor
	//
	xdsvoid_t Reference1Data(xRef1Data, wcslen(xRef1Data) * sizeof(WCHAR));
	P<CXdsReferenceInput> pRef1 = new CXdsReferenceInput(
										  Reference1Data,				
										  DigestMethod,
										  "#Ref1Id",
										  NULL /* Type */,
										  hCsp
										  );
	//
	// Ref2 - Internal reference
	//			RefData is given
	//			DigestValue not given will be calculate in the reference constructor
	//
	xdsvoid_t Reference2Data(xRef2Data, wcslen(xRef2Data) * sizeof(WCHAR));
	P<CXdsReferenceInput> pRef2 = new CXdsReferenceInput(
										  Reference2Data,				
										  DigestMethod,
										  "#Ref2Id",
										  NULL /* Type */,
										  hCsp
										  );
	//
	// Ref3 - Internal reference
	//			RefData is given
	//			DigestValue not given will be calculate in the reference constructor
	//
	xdsvoid_t Reference3Data(xRef3Data, wcslen(xRef3Data) * sizeof(WCHAR));
	P<CXdsReferenceInput> pRef3 = new CXdsReferenceInput(
										  Reference3Data,				
										  DigestMethod,
										  "#Ref3Id",
										  NULL /* Type */,
										  hCsp
										  );

	//
	// Ref4 - Internal reference
	//			RefData is given
	//			DigestValue not given will be calculate in the reference constructor
	//
	xdsvoid_t Reference4Data(xRef4Data, wcslen(xRef4Data) * sizeof(WCHAR));
	P<CXdsReferenceInput> pRef4 = new CXdsReferenceInput(
										  Reference4Data,				
										  DigestMethod,
										  "#Ref4Id",
										  NULL /* Type */,
										  hCsp
										  );
	//
	// Ref5 - External reference
	//			RefData is not given
	//			DigestValue is given
	//
	P<CXdsReferenceInput> pRef5 = new CXdsReferenceInput(
										  DigestMethod,
										  "j6lwx3rvEPO0vKtMup4NbeVu8nk=",
										  "#Ref5Id",
										  NULL /* Type */
										  );


	//
	// Create pReferenceInputs vector
	//
	ReferenceInputVectorType pReferenceInputs;

	pReferenceInputs.push_back(pRef1);
	pReferenceInputs.push_back(pRef4);
//	pReferenceInputs.push_back(pRef5);
	pReferenceInputs.push_back(pRef2);
	pReferenceInputs.push_back(pRef3);

	pRef1.detach();
	pRef2.detach();
	pRef3.detach();
	pRef4.detach();
//	pRef5.detach();
	
	CXdsSignedInfo::SignatureAlgorithm SignatureAlg = CXdsSignedInfo::saDsa;

	CXdsSignature SignatureInfoEx(
					  SignatureAlg,
					  "SignatureExample", /* SignedInfo Id */
					  pReferenceInputs,
					  NULL, // L"RunTime Signature", /* Signature Id */
					  hCsp,
					  PrivateKeySpec,
					  NULL /* KeyValue */
					  );

	LPSTR SignatureElementEx = SignatureInfoEx.SignatureElement();

	printf("\n%s\n", SignatureElementEx);

	return(SignatureElementEx);
}


void 
TestValidation(
	LPCSTR SignatureElementEx, 
	HCRYPTKEY hKey, 
	HCRYPTPROV hCsp
	)
/*++

Routine Description:
	Test the validation of Xml signature element
	This simulate the reciever side

Arguments:
	SignatureElementEx - Signature Element string 
	hKey - Signer public key 
	hCsp - crypto provider handle

Returned Value:
	None.

--*/
{

	//
	// Convert to signature element from utf8 - Unicode.
	// The xml parser support only unicode buffers
	//
	size_t SignatureWSize;
	AP<WCHAR> pSignatureW = UtlUtf8ToWcs(reinterpret_cast<const BYTE*>(SignatureElementEx), strlen(SignatureElementEx),  &SignatureWSize);

	printf("SignatureW \n%.*ls\n", numeric_cast<DWORD>(SignatureWSize), pSignatureW.get());

	//
	// Parsing signature element
	//
	CAutoXmlNode SignatureTree;
	XmlParseDocument(xwcs_t(pSignatureW, numeric_cast<DWORD>(SignatureWSize)), &SignatureTree );
	XmlDumpTree(SignatureTree);

	//
	// Test Signature Validation on SignatureTree that was just created
	// note that the second parameter is the signer public key of the user that signed the signature
	//
	try
	{
		XdsValidateSignature(
			SignatureTree, 
			hKey, 
			hCsp
			);
		
		//
		// Normal termination --> Validation ok
		//
		printf("Signature Validation OK\n");
	}
	catch (const bad_signature&)
	{
		//
		// XdsValidateSignature throw excption --> Validation fail
		//
		printf("Signature Validation Failed - bad_signature excption\n");
	}

	//
	// Get reference vector from the SignatureTree
	//
	CReferenceValidateVectorTypeHelper ReferenceValidateVector = XdsGetReferenceValidateInfoVector(
																	 SignatureTree
																	 );
	//
	// Fill ReferenceData in the ReferenceValidateVector found in the signature
	//
	for(ReferenceValidateVectorType::iterator ir = ReferenceValidateVector->begin(); 
		ir != ReferenceValidateVector->end(); ++ir)
	{
		printf("Uri '%.*ls'\n", (*ir)->Uri().Length(), (*ir)->Uri().Buffer());

		//
		// Get ReferenceData according to Uri or some other mechanism
		// this need to be decided
		//
		xdsvoid_t ReferenceData;
		if((*ir)->Uri() == L"#Ref1Id")
		{
			ReferenceData = xdsvoid_t(xRef1Data, wcslen(xRef1Data) * sizeof(WCHAR));
		}
		else if((*ir)->Uri() == L"#Ref2Id")
		{
			ReferenceData = xdsvoid_t(xRef2Data, wcslen(xRef2Data) * sizeof(WCHAR));
		}
		else if((*ir)->Uri() == L"#Ref3Id")
		{
			ReferenceData = xdsvoid_t(xRef3Data, wcslen(xRef3Data) * sizeof(WCHAR));
		}
		else if((*ir)->Uri() == L"#Ref4Id")
		{
			ReferenceData = xdsvoid_t(xRef4Data, wcslen(xRef4Data) * sizeof(WCHAR));
		}
		else
		{
			//
			// If we dont know we fill an empty ReferenceData
			//
			ASSERT(0);
		}

		//
		// Set the pReferenceData in the ReferenceValidateVector
		//
		(*ir)->SetReferenceData(ReferenceData);

		printf("AlgId %d\n", (*ir)->HashAlgId());
		printf("DigestValue '%.*ls'\n", (*ir)->DigestValue().Length(), (*ir)->DigestValue().Buffer());
	}

	printf("CALG_SHA1 = %d\n", CALG_SHA1);

	//
	// Test reference validation - vector of validation values
	//
	std::vector<bool> RefValidateResult = XdsValidateAllReference(
											  *ReferenceValidateVector,	    
											  hCsp
											  );
	//
	// Reference Validation results
	//
	for(DWORD j=0; j < RefValidateResult.size(); j++)
	{
	    printf("Ref %d, ValidateRef = %d\n", j, RefValidateResult[j]);
	}

	//
	// Test CoreValidation
	// Important note: this should have the ReferenceValidateVector already filled
	//
	try
	{
		XdsCoreValidation(
			SignatureTree, 
			hKey, 
			*ReferenceValidateVector,	    
			hCsp
			);

	    printf("CoreValidation OK\n");
	}
	catch (const bad_signature&)
	{
		//
		// XdsCoreValidation throw Signature excption --> CoreValidation fail
		//
		printf("Core Validation Failed, Signature Validation Failed\n");
	}
	catch (const bad_reference&)
	{
		//
		// XdsCoreValidation throw Reference excption --> CoreValidation fail
		//
		printf("Core Validation Failed, Reference Validation Failed\n");
	}
	
}


void TestBase64()
/*++

Routine Description:
	Test base64 operations

Arguments:
    None

Returned Value:
	None.

--*/
{
	//
    // Testing Encrypt, Decrypt using Session key
    //
	AP<char> Buffer = newstr("Hello World");
	DWORD BufferLen = strlen(Buffer);

	printf("Original Octet data: '%.*s'\n", BufferLen, Buffer.get());

	//
	// Base64 functions test
	//
	FILE *fp = fopen("Hello.dat","w");
	fprintf(fp,"%.*s", BufferLen, Buffer.get());
	fclose(fp);

	//
	// Transfer SignBuffer to base64 wchar format
	//
	DWORD BufferWBase64Len;
	AP<WCHAR> BufferWBase64 = Octet2Base64W(reinterpret_cast<const BYTE*>(Buffer.get()), BufferLen, &BufferWBase64Len);

	printf("Base64 wchar Buffer: '%.*ls'\n", BufferWBase64Len, BufferWBase64.get());

	//
	// Transfer SignBuffer to base64 ansi format
	//
	DWORD BufferBase64Len;
	AP<char> BufferBase64 = Octet2Base64(reinterpret_cast<const BYTE*>(Buffer.get()), BufferLen, &BufferBase64Len);

	printf("Base64 ansi Buffer: '%.*s'\n", BufferBase64Len, BufferBase64.get());

	//
	// Test Utf8ToWcs
	//
	size_t WcsBufferBase64Len;
	AP<WCHAR> WcsBufferBase64 = UtlUtf8ToWcs(reinterpret_cast<const BYTE*>(BufferBase64.get()), BufferBase64Len, &WcsBufferBase64Len);

	if((BufferWBase64Len != WcsBufferBase64Len) ||
	   (wcsncmp(WcsBufferBase64, BufferWBase64, BufferWBase64Len) != 0))
	{
		printf("Base64 ansi Buffer after utf8Wcs does not match\n");
		throw bad_base64();
	}

	printf("UtlUtf8ToWcs test pass ok\n");

	//
	// Test WcsToUtf8
	//
	utf8_str Utf8BufferWBase64 = UtlWcsToUtf8(BufferWBase64, BufferWBase64Len);

	if((Utf8BufferWBase64.size() != BufferBase64Len) ||
	   (strncmp(reinterpret_cast<const char*>(Utf8BufferWBase64.data()), BufferBase64, BufferBase64Len) != 0))
	{
		printf("Base64 wchar Buffer after Wcsutf8 does not match\n");
		throw bad_base64();
	}

	printf("UtlWcsToUtf8 test pass ok\n");

	//
	// Transfer SignBase64 back to Octet format
	//
	DWORD OctetLen;
	AP<BYTE> OctetBuffer = Base642OctetW(BufferWBase64, BufferWBase64Len, &OctetLen);

	printf("Octet data after conversions (base64 and back): '%.*s'\n", OctetLen, reinterpret_cast<char*>(OctetBuffer.get()));
}


extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
/*++

Routine Description:
    Test Xml Digital Signature library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	TrInitialize();

	SetActivation(argc, argv);

	if(g_fErrorneous)
	{
		DumpUsageText();
		return 3;
	}

    XmlInitialize();
    XdsInitialize();

	try
	{
		//
		// Class that upon constructing initialize the Csp, retrieves user public/private key
		// This object will be used to perform an operations that call crypto api
		//
		CCspHandle hCsp(CryAcquireCsp(MS_DEF_PROV));
//		CCspHandle hCsp(CryAcquireCsp(MS_ENHANCED_PROV));


		AP<char> SignatureElement = TestCreateSignature(g_PrivateKeySpec, hCsp);

		//
		// for validation we need the signer key - in this case it is our key
		// in real use we need to get this key via certificate or other mechanishm
		// possible that this key will be in the xml dsig
		// then might get it from there
		//
		TestValidation(SignatureElement, CryGetPublicKey(g_PrivateKeySpec, hCsp), hCsp);
		
		TestBase64();
	}
	catch (const bad_CryptoProvider& badCspEx)
	{
		TrERROR(SECURITY, "bad Crypto Service Provider Excption ErrorCode = %x", badCspEx.error());
		return(-1);
	}
	catch (const bad_CryptoApi& badCryEx)
	{
		TrERROR(SECURITY, "bad Crypto Class Api Excption ErrorCode = %x", badCryEx.error());
		return(-1);
	}
	catch (const bad_XmldsigElement&)
	{
		TrERROR(SECURITY, "bad Xmldsig Element excption");
		return(-1);
	}
	catch (const bad_base64&)
	{
		TrERROR(SECURITY, "bad base64");
		return(-1);
	}

    WPP_CLEANUP();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\xml\lib\parse.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    parse.cpp

Abstract:
    Super fast Xml document parser

Author:
    Erez Haba (erezh) 15-Sep-99

Environment:
    Platform-independent,

--*/			  
		
#include <libpch.h>
#include <Xml.h>
#include "Xmlp.h"
#include "xmlns.h"

#include "parse.tmh"

static const WCHAR* parse_element(const WCHAR* p,const WCHAR* end, XmlNode** ppNode,CNameSpaceInfo*  pNsInfo);


inline void operator+=(XmlNode& n,XmlAttribute& a)
{
    n.m_attributes.push_back(a);
}


inline void operator+=(XmlNode& n,XmlValue& v)
{
    n.m_values.push_back(v);
}


inline void operator+=(XmlNode& n, XmlNode& c)
{
    n.m_nodes.push_back(c);
}



static const WCHAR* skip_ws(const WCHAR* p, const WCHAR* end)
{
    while(p!= end && iswspace(*p))
    {
        ++p;
    }

    return p;
}


static bool is_start_sub_str(
			const WCHAR* f1,
			const WCHAR* l1,
			const WCHAR* f2,
			const WCHAR* l2)

/*++

Routine Description:
	check if [l1,f1) is at the start of [l2,f2)

 
Arguments:
--*/
{
	if ((l2 - f2) < (l1 - f1))
		return false;

	return (wcsncmp(f1, f2, l1 - f1) == 0);

}

void check_end(const WCHAR* p,const WCHAR* end)
{
	if(p >= end)
	{
		TrERROR(GENERAL, "Unexpected end of document ");
        throw bad_document(p);
	}
}


static const WCHAR* find_char(const WCHAR* p, const WCHAR* end, WCHAR c)
{
	for(;p != end; p++)
	{
		if(*p == c)
			return p;
	}
	TrERROR(GENERAL, "Unexpected EOS while searching for '%lc'", c);
	throw bad_document(--p);
}


static const WCHAR* skip_comment(const WCHAR* p, const WCHAR* end)
{
	static const WCHAR xComment[] =	L"<!--";
	

    //
    // [15]  Comment ::=  '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->' 
    //
	if(!is_start_sub_str(
				xComment,
				xComment + STRLEN(xComment),
				p,
				end))
	{
		return p;
	}


	p += STRLEN(xComment);
    for(;;)
    {
		p = find_char(p, end, L'-');
		if(p+2 >=  end)
			return end;

        if(*++p != L'-')
            continue;
		
        if(*++p != L'>')
		{
			TrERROR(GENERAL, "Comment terminator '--' followed by %lc and not by '>'", *p);
            throw bad_document(p);
		}

        return ++p;
    }
}


static const WCHAR* skip_pi(const WCHAR* p,const WCHAR* end)
{
	static const WCHAR xPi[] = L"<?";

    //
    // [16]  PI ::=  '<?' Name (S (Char* - (Char* '?>' Char*)))? '?>' 
    //

	if(!is_start_sub_str(
				xPi,
				xPi + STRLEN(xPi),
				p,
				end))
	{
		return p;
	}


	p += STRLEN(xPi);
    for(;;)
    {
        p = find_char(p, end, L'?');
		if(p+1 >= end)
			return end;

        if(*++p != L'>')
			continue;

        return ++p;
    }
}


static const WCHAR* skip_misc(const WCHAR* p,const WCHAR* end)
{
    //
    // [27]  Misc ::=  Comment | PI |  S 
    //
    for(;;)
    {
        const WCHAR* q;
		q = skip_ws(p, end);
        q = skip_comment(q, end);
        q = skip_pi(q, end );

        if(p == q)
            return p;

        p = q;
    }
}


static const WCHAR* skip_doctype(const WCHAR* p, const WCHAR* end)
{
	static const WCHAR xDocType[] =  L"<!DOCTYPE";


    //
    // [28]  doctypedecl ::=  '<!DOCTYPE' S Name (S {bad system parse})? S? ('[' (problem maybe netsing)* ']' S?)? '>'
    //
    
	//
	// BUGBUG: Don't know how to parse DOCTYPE yet. gilsh 24-Apr-2000 
	//
	if(!is_start_sub_str(
				xDocType,
				xDocType + STRLEN(xDocType),
				p,
				end))
	{
		return p;
	}

	TrERROR(GENERAL, "Don't know how to skip DOCTYPE section");
    throw bad_document(p);
}


static const WCHAR* skip_name_char(const WCHAR* p, const WCHAR* end, const WCHAR** ppPrefix)
{
	const WCHAR* pStart = p;
	*ppPrefix = pStart;


   	DWORD PrefixCharCount = 0;
    while(p!= end && (iswalpha(*p) || iswdigit(*p) || *p == L'.' || *p == L'-' || *p == L'_' || *p == L':'))
    {
		//
		// the first time we see L':' we try to match qualified  name.
		// if we see another L':' - we consider it an non qualified  name
		//
		if(*p == L':')
		{
			if(PrefixCharCount++ == 0)
			{
				*ppPrefix = p;	
			}
			else
			{
			   *ppPrefix = pStart;	
			}
		}
        ++p;
    }
    return p;
}



static const WCHAR* parse_name(const WCHAR* p,const WCHAR* end, const WCHAR** ppPrefix)
{

	/* if qualified  name then try to match this : 

	// QName ::=  (Prefix ':')? LocalPart 
	// Prefix ::=  NCName 
	// LocalPart ::=  NCName 
	// NCName ::=  (Letter | '_') (NCNameChar)* 
    // NCNameChar ::=  Letter | Digit | '.' | '-' | '_' | CombiningChar | Extender  

	*/

	
	/* if not, try to match this :

	//
	//NameChar ::=  Letter | Digit | '.' | '-' | '_' | ':' |  
	//

    */

	
	
	//
	// check if first char is (Letter | '_' | ':')
	// this check is valid even if the name is qualified.
	//
	check_end(p , end);

    if(!(iswalpha(*p) || *p == L'_' || *p == L':'))
	{
		TrERROR(GENERAL, "Bad first char in Name '%lc'", *p);
        throw bad_document(p);
	}
    return skip_name_char(p, end, ppPrefix);
}


static 
xwcs_t 
get_local_name(
	const WCHAR* pStartName,
	const WCHAR* pEndName,
	const WCHAR* pEndPrefix
	)
{
	if(pEndPrefix == pStartName)
	{
		return xwcs_t(pStartName , pEndName - pStartName);
	}
	ASSERT(*pEndPrefix == L':'); 
	return  xwcs_t(pEndPrefix+1,pEndName - (pEndPrefix+1));
}


static 
xwcs_t 
get_name_prefix(
	const WCHAR* pStartName,
	const WCHAR* pEndPrefix
	)
{
	return  xwcs_t(pStartName,pEndPrefix - pStartName);
}



static 
const 
WCHAR*  
parse_full_name(
	const WCHAR* pStartName,
	const WCHAR* end,
	xwcs_t* pPrefix,
	xwcs_t* pTag
	)

{
	const WCHAR* pEndPrefix;
	const WCHAR* pEndName = parse_name(pStartName, end, &pEndPrefix);
	*pTag  = get_local_name(pStartName,pEndName,pEndPrefix);
	*pPrefix = get_name_prefix(pStartName,pEndPrefix); 
	
	return 	pEndName;
}



static const WCHAR* parse_attribute(const WCHAR* p,const WCHAR* end, XmlAttribute** ppAttribute)
{
	
    //
    // [41]  Attribute ::=  Name  S? '=' S? AttValue
    // [10]  AttValue ::=  '"' [^"]* '"'  | "'" [^']* "'" 
    //
	xwcs_t tag;
	xwcs_t prefix;
	const WCHAR* q = parse_full_name(p, end, &prefix,&tag);



	p = skip_ws(q, end);
	check_end(p , end);

	if(*p != L'=')
	{
		TrERROR(GENERAL, "Missing '=' in attribute parsing");
		throw bad_document(p);
	}

	p = skip_ws(++p, end);
	check_end(p , end);


	WCHAR c = *p;
	if(c != L'\'' && c != L'"')
	{
        //
        // NTRAID#WINDOWS-353696-2001/03/28-shaik WPP: Compiler error on \" format
        //
		//TrERROR(GENERAL, "Attribute value does not start with a \' or a \" but with a '%lc'", c);
        TrERROR(GENERAL, "Attribute value does not start with a \' but with a '%lc'", c);
		throw bad_document(p);
	}

	q = find_char(++p, end, c);
	
	xwcs_t value(p, q - p);
	XmlAttribute* attrib = new XmlAttribute(prefix,tag,value);
	*ppAttribute = attrib;

    return ++q;
}
  

static const WCHAR* parse_char_data(const WCHAR* p,const WCHAR* end, XmlValue** ppValue)
{
	//
    // [14]  CharData ::=  [^<]*
    //
    const WCHAR* q = find_char(p, end, L'<');


//#pragma BUGBUG("Should traling white spaces be removed from char data while parsing?")

	//
	// We should have some data here
	//
	ASSERT(q != p);

	XmlValue* value = new XmlValue(xwcs_t(p, q - p));
	*ppValue = value;
    return q;
}


static const WCHAR* parse_cdsect(const WCHAR* p,const WCHAR* end, XmlValue** ppValue)
{
	static const WCHAR xCDATA[] =  L"<![CDATA[";

	//
    // [18]  CDSect ::=  '<![CDATA['  (Char* - (Char* ']]>' Char*))  ']]>' 
    //

    if(!is_start_sub_str(
				xCDATA,
				xCDATA + STRLEN(xCDATA),
				p,
				end))
	{
		TrERROR(GENERAL, "CDATA section does not start with '<![CDATA[' but rather with %.9ls", p);
        throw bad_document(p);
	}

	p += STRLEN(xCDATA);
    for(const WCHAR* q = p; ; q++)
    {
        q = find_char(q, end,  L']');
		check_end(p + 2, end);
		
        if(q[1] != ']')
            continue;

	
        if(q[2] != L'>')
            continue;

		XmlValue* value = new XmlValue(xwcs_t(p, q - p));
		*ppValue = value;
		return (q + 3);
    }
}


static xwcs_t get_namespace_prefix_declared(const XmlAttribute& Attribute)
/*++

Routine Description:
	get the prefix of namespace declaration.

 
Arguments:
IN - Attribute - attribute that declared namespace

  

Returned Value:
    prefix declared
--*/
{
	//
	// if default namespace declared  : xmlns="uri"
	//
	if(Attribute.m_namespace.m_prefix.Length() == 0)
	{
		return xwcs_t();	
	}

	//
	// spesific namespace prefix declared :	 xmlns:prefix="uri"
	//
	return 	Attribute.m_tag;
	
}

static bool is_namespace_declaration(const XmlAttribute* Attribute)
/*++

Routine Description:
    check if attributed parsed is not real attribute but namespace declaration
.

Arguments:
  

Returned Value:
    true if the attribute is namespace declaration - otherwise false.

--*/


{
	const LPCWSTR xNsDecKeyWord = L"xmlns";

	//
	// default namespace declaration "xmlns=uri"
	// no prefix declared.
	//
	if(Attribute->m_tag ==  xNsDecKeyWord)
	{
		return Attribute->m_namespace.m_prefix.Length() == 0;
	}


	//
	// spesific prefix declared "xmlns:prefix=uri".
	// little bit confusing - "xmlns" was parsed as
	// prefix and "prefix" was parsed as tag - because
	// parser thought it just regular attribute of the form
	// "prefix:tag=uri". 
	//
	if(Attribute->m_namespace.m_prefix == xNsDecKeyWord)
	{
		return  Attribute->m_tag.Length()  != 0;
	}

	return false;
	
}



static const CNsUri get_namespace_uri(const CNameSpaceInfo& NsInfo, const xwcs_t& prefix)
/*++

Routine Description:
	return namespace uri for given namespace prefix

 
Arguments:
IN - NsInfo - namespace information class
IN - prefix - namespace prefix.
  

Returned Value:
    Namespace uri that match the prefix, or empty uri if no match found.
--*/

{
	CNsUri NsUri = NsInfo.GetNs(prefix);
	if(NsUri.m_uri.Length() == 0  && prefix.Length() != 0)
	{
        TrERROR(GENERAL, "Prefix '%.*ls' has no namespace Uri declared", LOG_XWCS(prefix));

        //
        // At the moment we decided to return empty namespace  and not to throw
        // exception on prefix without namespace declaration.
        //
  	}
	
	return NsUri;
}


static void set_namespaces(const CNameSpaceInfo& NsInfo, XmlNode* pNode)
/*++

Routine Description:
	set namespaces uri to all node tag and attributea of the current node   

 
Arguments:
IN - NsInfo - namespace information class
IN - XmlNode* pNode - xml node

  

Returned Value:
    None

Note:
Parsing namespaces done into steps
1) Collecting namespaces declaration and the prefixes used
2) Setting the namespaces uri's collected to node tag and attributes of the current node.

This function perform step 2

--*/
{
	//
	// set uri for current node 
	//
	CNsUri NsUri  = get_namespace_uri(NsInfo, pNode->m_namespace.m_prefix);
	pNode->m_namespace.m_uri = NsUri.m_uri;
	pNode->m_namespace.m_nsid = NsUri.m_nsid;


	//
	// set uri for all attrubutes
	//
	for(List<XmlAttribute>::iterator it = pNode->m_attributes.begin();
		it != pNode->m_attributes.end();
		++it
		)
	{
		//
		//  default name space affects empty prefix of nodes only (not attributes) - 
		//  so we skip empty prefixes.  Here is the what the space recomendation
		//  spec say about it : 
		//

		/*
		5.2 Namespace Defaulting
		A default namespace is considered to apply to the element 
		where it is declared (if that element has no namespace prefix), 
		and to all elements with no prefix within the content of that element. 
		If the URI reference in a default namespace declaration is empty, 
		then unprefixed elements in the scope of the declaration are
		not considered to be in any namespace. Note that default namespaces 
		do not apply directly to attributes. 
		*/


		if(it->m_namespace.m_prefix.Length() > 0)
		{
				CNsUri NsUri  = get_namespace_uri(NsInfo, it->m_namespace.m_prefix);
				it->m_namespace.m_uri  = NsUri.m_uri;
				it->m_namespace.m_nsid = NsUri.m_nsid;
		}
	}
}

//
// check if close tag match the open tag
// <prefix:tag> ... </prefix:tag>
//
static
bool 
is_tags_match(
			const xwcs_t& StartPrefix,
			const xwcs_t& StartTag,
			const xwcs_t& EndPrefix,
			const xwcs_t& EndTag
			)

/*++

Routine Description:
   	Check if close tag match the open tag.
    <prefix:tag> ... </prefix:tag>

 
Arguments:
IN - StartPrefix start prefix tag
IN - StartTag - start tag.
IN - EndPrefix - end prefix tag
IN - EndTag - end tag
  

Returned Value:
    true if tags match otherwise false.

--*/

{

	return (StartPrefix == EndPrefix) && (StartTag == EndTag);
}


static 
const 
WCHAR* 
parse_content(
		const WCHAR* p,
		const WCHAR* end, 
		XmlNode* pNode,
		CNameSpaceInfo*  pNsInfo
		)
{
	LPCWSTR pContent = p;

    //
    // [43]  content ::=  (element | CharData | CDSect | Misc)* 
    //
    for(;;)
    {
        p = skip_misc(p, end);
		check_end(p , end);

        if(*p != L'<')
        {
            //
            // Only char data (and Reference) do not begin with '<'
            //
            XmlValue* value;
             p = parse_char_data(p, end, &value);
            *pNode += *value;
            continue;
        }
        
        //
        // End of node detected '</'
        //
		check_end(p + 1 , end);
        if(p[1] == L'/')
            break;

        //
        // CDATA section detected '<!'
        //
        if(p[1] == L'!')
        {
            XmlValue* value;
            p = parse_cdsect(p, end, &value);
            *pNode += *value;
            continue;
        }

        //
        // Child element detected
        //
        {
            XmlNode* child;
            p = parse_element(p, end,&child,pNsInfo);
            *pNode += *child;
            continue;
        }
    }

	pNode->m_content = xwcs_t(pContent, p - pContent);
	return p;

}


static 
const 
WCHAR*  
parse_attributes(
	const WCHAR* p,
	const WCHAR* end,
	XmlNode* pNode,
	CNameSpaceInfo* pNsInfo,
	bool* bContinute
	)
{
	
	for(;;)
    {
		const WCHAR* q = p;
        p = skip_ws(p, end);
		check_end(p+1 ,end);

        if((p[0] == L'/') && (p[1] == L'>'))
        {
			LPCWSTR pElement = pNode->m_tag.Buffer() - 1;
			pNode->m_element = xwcs_t(pElement, p + 2 - pElement);
		

			//
			// m_content is initialize to NULL
			//
		             
			*bContinute = false;
            return (p + 2);
        }

        if(*p == L'>')
        {
            ++p;
            break;
        }

		//
		// There must be a white space before attribute name
		//
		if(q == p)
		{
			TrERROR(GENERAL, "There must be a white space before attribute name");
			throw bad_document(p);
		}

        P<XmlAttribute> attribute;
        p = parse_attribute(p, end, &attribute);

		//
		// if the attribute id actually namespace declaration xmlns:prefix="uri"
		// the the attribute value is the namespace uri. This attribute is not inserted
		// to the attributes list.
		if(is_namespace_declaration(attribute))
		{
			pNsInfo->SaveNs(
						get_namespace_prefix_declared(*attribute),
						attribute->m_value
						);
							
		}
		else
		{
			*pNode += *(attribute.detach());
		}
    }
	*bContinute = true;
	return p;
}

static const WCHAR* create_new_node(const WCHAR* p,const WCHAR* end, XmlNode** ppNode)
{
	xwcs_t tag;
	xwcs_t prefix;
	p = parse_full_name(p, end, &prefix,&tag);
	*ppNode = new XmlNode(prefix,tag);
	return p;
}


#ifdef _DEBUG

static bool is_end_tag(const WCHAR* p)
{
	return (p[0] == L'<') && (p[1] == L'/');
}

#endif


static const WCHAR* parse_end_node(const WCHAR* p,const WCHAR* end, const  XmlNode& node)
{
	
	ASSERT(is_end_tag(p));

	//
    // [42]  ETag ::=  '</' Name S? '>' 
    //
    p += 2;


  	xwcs_t Prefix;
	xwcs_t Tag; 
	p = parse_full_name(p, end, &Prefix,&Tag);
	if(!is_tags_match(
				node.m_namespace.m_prefix,
				node.m_tag,
				Prefix,
				Tag))
       
	{
		TrERROR(
			GENERAL,
			"End tag '%.*ls:%.*ls' does not match Start tag '%.*ls:%.*ls'",
			LOG_XWCS(Prefix),
			LOG_XWCS(Tag), 
			LOG_XWCS(node.m_namespace.m_prefix),
			LOG_XWCS(node.m_tag)
			);

        throw bad_document(p);
	}

	p = skip_ws(p, end);
	check_end(p, end);
    if(*p != L'>')
	{
		TrERROR(GENERAL, "End tag does not close with a '>' but rather with a '%lc'", *p);
        throw bad_document(p);
	}
   	++p;


	return p;
}

static void parse_start_node(const WCHAR* p ,const WCHAR* end)
{
	//
    // [40]  STag ::=  '<' Name (S Attribute)* S? '>'
    // [44]  EmptyElemTag ::=  '<' Name (S Attribute)* S? '/>' 
    //
	check_end(p , end);
    if(*p != L'<')
	{
		TrERROR(GENERAL, "Element does not start with a '<' but rather with a '%lc'", *p);
        throw bad_document(p);
	}
}

static
const 
WCHAR* 
parse_element(
		const WCHAR* p, 
		const WCHAR* end,
		XmlNode** ppNode,
		CNameSpaceInfo*  pNsInfo
		)
{
	//
	// create local namespace info from previous level
	//
	CNameSpaceInfo LocalNameSpaceInfo(pNsInfo); 


	parse_start_node(p , end);

	//
	//  create node object
	//
	CAutoXmlNode node;
	p = create_new_node(++p, end, &node);


	//
	// add attributes found in the node (or namespaces declarations)
	//
 	bool bContinute;
	p = parse_attributes(p, end, node,&LocalNameSpaceInfo,&bContinute);
	if(!bContinute)
	{
		set_namespaces(LocalNameSpaceInfo,node);
		*ppNode = node.detach();
		return p;
	}

	//
	// add node content
	//
	p = parse_content(p, end , node, &LocalNameSpaceInfo);
	p = parse_end_node(p, end, *node);
	

	//
	// ilanh - m_element is the all element including opening < and closing >
	// node->m_tag.Buffer() is pointer to the tag name that is after the opening <
	// therefore need to substract one from node->m_tag.Buffer() (both for the pointer and for the length)
	//
	LPCWSTR pElement = node->m_tag.Buffer() - 1;
	node->m_element = xwcs_t(pElement, p - pElement);


	//
	// At the end - we should update namespace uri of attributes and nodes
	// only now we know the correct mapping from prefix to uri.
	//
	set_namespaces(LocalNameSpaceInfo,node);

	*ppNode = node.detach();
    return p;
}



const WCHAR*
XmlParseDocument(
	const xwcs_t& doc,
	XmlNode** ppTree,
	const INamespaceToId* pNamespaceToId
	)

/*++

Routine Description:
    Parse an XML document and return the reprisenting tree.

Arguments:
    doc - Buffer to parse. 

	ppTree - Output, received the parsed  XML tree.

	pNamespaceToId - Poniter to interface that will be used by the parser to map
	namespace strings to id's. This will enable the caller to be optimized working with ids's
	instead of long namespaces strings.



Returned Value:
    The end of the XML document

--*/


{
	XmlpAssertValid();

	const WCHAR* p = doc.Buffer();
	const WCHAR* end = doc.Buffer() + doc.Length();

	//
	// [1]  document ::=  prolog element Misc* 
	//

	//
	// [22]  prolog ::=  Misc* (doctypedecl Misc*)? 
	// [27]  Misc ::=  Comment | PI |  S 
	//


    p = skip_misc(p,end);
	p = skip_doctype(p, end);
    p = skip_misc(p , end);

	CNameSpaceInfo  NsInfo(pNamespaceToId);
    p = parse_element(p, end,  ppTree, &NsInfo);

    return p;
}



VOID
XmlFreeTree(
	XmlNode* Tree
	)
/*++

Routine Description:
    Free a complete Xml tree structure.

Arguments:
    Tree - the tree to free

Returned Value:
    None.

--*/
{
	XmlpAssertValid();
	ASSERT(Tree != 0);

	while(!Tree->m_attributes.empty())
	{
		XmlAttribute& attrib = Tree->m_attributes.front();
		Tree->m_attributes.pop_front();
		delete &attrib;
	}

	while(!Tree->m_values.empty())
	{
		XmlValue& value = Tree->m_values.front();
		Tree->m_values.pop_front();
		delete &value;
	}

	while(!Tree->m_nodes.empty())
	{
		XmlNode& node = Tree->m_nodes.front();
		Tree->m_nodes.pop_front();
		XmlFreeTree(&node);
	}

	delete Tree;
}


static xwcs_t get_first_node_name(const WCHAR* Path)
{
	const WCHAR* p = Path;
	while((*p != L'!') && (*p != L'\0'))
	{
		++p;
	}

	return xwcs_t(Path, p - Path);
}

static
const
XmlNode*
XmlpFindSubNode(
	const XmlNode* Tree,
	const WCHAR* SubNodePath
	)
/*++

Routine Description:
    Get the element for a specific *relative* path. That is, don't match the
	root element tag.

Arguments:
    Tree - The tree to search
	SubNodePath - The element *relative* path in the format "!level1!level1.1!level1.1.1"

Returned Value:
    The deepest sub-element node if found NULL otherwise.

--*/
{
	XmlpAssertValid();
	ASSERT(Tree != 0);

	if(*SubNodePath == L'\0')
		return Tree;

	ASSERT(*SubNodePath == L'!');
	xwcs_t tag = get_first_node_name(++SubNodePath);

	const List<XmlNode>& n = Tree->m_nodes;
	for(List<XmlNode>::iterator in = n.begin(); in != n.end(); ++in)
	{
		if(in->m_tag == tag)
			return XmlpFindSubNode(&*in, SubNodePath + tag.Length());
	}

	return 0;
}


const
XmlNode*
XmlFindNode(
	const XmlNode* Tree,
	const WCHAR* NodePath
	)
/*++

Routine Description:
    Get the element for a specific relative or absolute node path. Absolute
	path includes matching the root element tag while Relative path doesn't.

Arguments:
    Tree - The tree to search
	NodePath - The element path in the *absolute* format "root!level1!level1.1!level1.1.1"
		or the *relative* format "!level1!level1.1!level1.1.1"

Returned Value:
    The element node if found NULL otherwise.

--*/
{
	XmlpAssertValid();
	ASSERT(Tree != 0);

	xwcs_t tag = get_first_node_name(NodePath);

	if((tag.Length() == 0) || (Tree->m_tag == tag))
		return XmlpFindSubNode(Tree, NodePath + tag.Length());

	return 0;
}

static
const
XmlAttribute*
XmlpFindAttribute(
	const XmlNode* Node,
	const WCHAR* AttributeTag
	)
/*++

Routine Description:
    Get an atribute node for a specific element.

Arguments:
    Node - The node to search
	AttributeTag- The attribute tag for that node

Returned Value:
    The attribute node if found NULL otherwise.

--*/
{
	XmlpAssertValid();
	ASSERT(Node != 0);

	const List<XmlAttribute>& a = Node->m_attributes;
	for(List<XmlAttribute>::iterator ia = a.begin(); ia != a.end(); ++ia)
	{
		if(ia->m_tag == AttributeTag)
			return &*ia;
	}

	return 0;
}


const
xwcs_t*
XmlGetNodeFirstValue(
	const XmlNode* Tree,
	const WCHAR* NodePath
	)
/*++

Routine Description:
    Get the first text value of a node.

Arguments:
    Tree - The tree to search
	NodePath - The element path in the *absolute* format "root!level1!level1.1!level1.1.1"
		or the *relative* format "!level1!level1.1!level1.1.1"

Returned Value:
    The element text value if found NULL otherwise.

--*/
{
	XmlpAssertValid();

	Tree = XmlFindNode(Tree, NodePath);
	if(Tree == 0)
		return 0;

	if(Tree->m_values.empty())
		return 0;

	return &Tree->m_values.front().m_value;
}


const
xwcs_t*
XmlGetAttributeValue(
	const XmlNode* Tree,
	const WCHAR* AttributeTag,
	const WCHAR* NodePath /* = NULL */
	)
/*++

Routine Description:
    Get attribute value for a specific node.

Arguments:
    Tree - The tree to search
	NodePath - The element path in the *absolute* format "root!level1!level1.1!level1.1.1"
		or the *relative* format "!level1!level1.1!level1.1.1"
	AttributeTag- the attribute tag for that node

Returned Value:
    Attribute value if found NULL otherwise.

--*/
{
	XmlpAssertValid();

	//
	// If no NodePath supplied assume that Tree is the requested node no update
	//
	if(NodePath != NULL)
	{
		//
		// Find NodePath in Tree
		//
		Tree = XmlFindNode(Tree, NodePath);
	}

	if(Tree == 0)
		return 0;

	const XmlAttribute* attrib = XmlpFindAttribute(Tree, AttributeTag);
	if(attrib == 0)
		return 0;

	return &attrib->m_value;
}


/*++
Description:
	This is the grammer description used with this parser

	[1]  document ::=  prolog element Misc* 

	Prolog 
	[22]  prolog ::=  Misc* (doctypedecl Misc*)? 
	[27]  Misc ::=  Comment | PI |  S 
 
	[28]  doctypedecl ::=  '<!DOCTYPE' S Name (S {problem with system})? S? ('[' (problem maybe netsing)* ']' S?)? '>'
	[15]  Comment ::=  '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->' 

	Processing Instructions
	[16]  PI ::=  '<?' Name (S (Char* - (Char* '?>' Char*)))? '?>' 


	Element 
	[39]  element ::=  EmptyElemTag | STag content ETag
	[44]  EmptyElemTag ::=  '<' Name (S Attribute)* S? '/>' 
 
	[40]  STag ::=  '<' Name (S Attribute)* S? '>'
	[41]  Attribute ::=  Name  S? '=' S? AttValue
	[42]  ETag ::=  '</' Name S? '>' 

 
	[10]  AttValue ::=  '"' [^"]* '"'  | "'" [^']* "'" 



	[43]  content ::=  (element | CharData | CDSect | PI | Comment)* 
 
	[14]  CharData ::=  [^<]*
	[18]  CDSect ::=  '<![CDATA['  (Char* - (Char* ']]>' Char*))  ']]>' 
 


	Names and Tokens 
	[3]  S ::=  (#x20 | #x9 | #xD | #xA)+ 
	[4]  NameChar ::=  Letter | Digit | '.' | '-' | '_' | ':' 
	[5]  Name ::=  (Letter | '_' | ':') (NameChar)* 

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\xml\lib\xmldebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    XmlDebug.cpp

Abstract:
    Xml debugging

Author:
    Erez Haba (erezh) 15-Sep-99

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Xml.h"
#include "Xmlp.h"

#include "xmldebug.tmh"

#ifdef _DEBUG

//---------------------------------------------------------
//
// Validate Xml state
//
void XmlpAssertValid(void)
{
    //
    // XmlInitalize() has *not* been called. You should initialize the
    // Xml library before using any of its funcionality.
    //
    ASSERT(XmlpIsInitialized());

    //
    // TODO:Add more Xml validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void XmlpSetInitialized(void)
{
    LONG fXmlAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Xml library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fXmlAlreadyInitialized);
}


BOOL XmlpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
void XmlpRegisterComponent(void)
{
}


//---------------------------------------------------------
//
//  helper stream functions 
//
//---------------------------------------------------





static std::wostream& operator<<(std::wostream& ostr,const xwcs_t& xwstr)
{
	ostr.write(xwstr.Buffer(), xwstr.Length());	 //lint !e534
	return ostr;
}


static std::wostream& operator<<(std::wostream& ostr,const XmlNameSpace& NameSpace)
{
	if(NameSpace.m_uri.Length() != 0)
	{
		ostr<<L"{"<<NameSpace.m_uri<<L"}";
	}

	if(NameSpace.m_prefix.Length() != 0)
	{
		ostr<<NameSpace.m_prefix<<L":";
	}
	return ostr;
}


static std::wostream& operator<<(std::wostream& ostr,const XmlAttribute& Attribute)
{
	ostr<<Attribute.m_namespace<<Attribute.m_tag<<L"="<<L"'"<<Attribute.m_value<<L"'";
	return ostr;
}


static std::wostream& operator<<(std::wostream& ostr,const XmlValue& Value)
{
	ostr<<Value.m_value;
	return ostr;
}





static void PrintXmlTree(const XmlNode* node, unsigned int level,std::wostringstream& ostr)
{
	ostr<<level<<std::setw(level*4)<<L" "<<L"<"<<node->m_namespace<<node->m_tag;
	typedef List<XmlAttribute>::iterator iterator;
	for(iterator ia = node->m_attributes.begin(); ia != node->m_attributes.end(); ++ia)
	{
		ostr<<L" "<<*ia;			
	}
	ostr<<L">\r\n";


	level++;
	for(List<XmlValue>::iterator iv = node->m_values.begin(); iv != node->m_values.end(); ++iv)
	{
		ostr<<level<<std::setw(level*4)<<L" "<<*iv<<L"\r\n";
	}


	for(List<XmlNode>::iterator in = node->m_nodes.begin(); in != node->m_nodes.end(); ++in)
	{
		PrintXmlTree(&*in,level,ostr);
	}
	

}


VOID
XmlDumpTree(
	const XmlNode* Tree
	)
{
	XmlpAssertValid();
	std::wostringstream wstr;
	PrintXmlTree(Tree,1,wstr);
	TrTRACE(GENERAL, "Xml Tree dump:\r\n%ls",wstr.str().c_str());
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\xml\lib\xmlinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    XmlInit.cpp

Abstract:
    Xml initialization

Author:
    Erez Haba (erezh) 15-Sep-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Xml.h"
#include "Xmlp.h"

#include "xmlinit.tmh"

VOID
XmlInitialize(
    VOID
    )
/*++

Routine Description:
    Initializes Xml library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the Xml library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!XmlpIsInitialized());
    XmlpRegisterComponent();

    //
    // TODO: Write Xml initalization code here
    //

    XmlpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\xml\lib\xmlp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Xmlp.h

Abstract:
    Xml private functions.

Author:
    Erez Haba (erezh) 15-Sep-99

--*/

#pragma once

#ifndef _MSMQ_XMLP_H_
#define _MSMQ_XMLP_H_


void check_end(const WCHAR* p,const WCHAR* end);


#ifdef _DEBUG

void XmlpAssertValid(void);
void XmlpSetInitialized(void);
BOOL XmlpIsInitialized(void);
void XmlpRegisterComponent(void);

#else // _DEBUG

#define XmlpAssertValid() ((void)0)
#define XmlpSetInitialized() ((void)0)
#define XmlpIsInitialized() TRUE
#define XmlpRegisterComponent() ((void)0)

#endif // _DEBUG
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\xml\lib\encode.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    encode.cpp

Abstract:
	implemeting  CXmlEncode and  CXmlDecode(xml.h)  



Author:
    Gil Shafriri(gilsh) 15-Feb-2001

--*/

#include <libpch.h>
#include <xmlencode.h>
#include <xml.h>
#include "xmlp.h"

#include "encode.tmh"

//---------------------------------------------------------
//
// CXmlSpecialCharsSet - holds a set of special xml caracters 
//
//---------------------------------------------------------
class CXmlSpecialCharsSet
{
public:
	static bool IsIncluded(WCHAR c) 
	{
		return c == L'<'  || 
			   c == '>'   || 
			   c == L'&'  || 
			   c == L'\"'; 
	}
};




CXmlEncode::CXmlEncode(
		const xwcs_t& wcs
		):
		m_wcs(wcs)
{

}


std::wostream& operator<<(std::wostream& o, const CXmlEncode& XmlEncode)
/*++

Routine Description:
    encode given data and write it encoded to stream 


Arguments:
	o - stream
	XmlEncode - holds the data to encode.

  
Returned Value:
	The input stream

Note:
	The function loop over the input and write it to the stream as is
	if it is not special xml caracter. If it is special caracter it encode
	it with '&' + '#' + char decimal value + ';' For example '<' is encoded as
	&#60;
  
--*/

{
	for(int i = 0; i<XmlEncode.m_wcs.Length(); ++i)
	{
		WCHAR wc = XmlEncode.m_wcs.Buffer()[i];
		if(!CXmlSpecialCharsSet::IsIncluded(wc))
		{
			o.put(wc);
		}
		else
		{
			const WCHAR* dec = L"0123456789";
			WCHAR DecimalHighByte = wc / 10;
			WCHAR DecimalLowByte = wc - (DecimalHighByte * 10);
			ASSERT(DecimalHighByte < 10 && 	DecimalLowByte < 10);
			o.put(L'&');
			o.put(L'#');
			o.put(dec[DecimalHighByte]);
			o.put(dec[DecimalLowByte]);
			o.put(L';');
		}
	}
	return o;
}




CXmlDecode::CXmlDecode(
	void
	):
	m_fConverted(false)
{

}


void CXmlDecode::Decode(const xwcs_t& encoded)
{
	m_DecodedBuffer.free();
	m_encoded =  encoded;

	const WCHAR* ptr =  encoded.Buffer();
	const WCHAR* end = encoded.Buffer() + encoded.Length();

	while(ptr != end)
	{
		if(*ptr ==  L'&')
		{	
			ptr = HandleSpeciallChar(ptr, end);
		}
		else
		{
			ptr = HandleReguralChar(ptr);
		}
	}					
}



const WCHAR* CXmlDecode::HandleReguralChar(const WCHAR* ptr)
{
	if(m_fConverted)
	{
		m_DecodedBuffer.append(*ptr);				
	}
	return ++ptr;
}


const WCHAR* CXmlDecode::HandleSpeciallChar(const WCHAR* ptr, const WCHAR* end)
/*++

Routine Description:
    Decode encoded char and write it into the output decoded buffer.


Arguments:
	ptr - pointer to array of caracters encoding the special char.
	The encoding format is : "&#xx;" where xx is the decimal value
	of the ascii of the encoded char.

  
Returned Value:
	Pointer after the encoded sequence.

--*/
{
	//
	// If this is the first special char - copy all caracters  before it to the converted stream.
	//
	if(!m_fConverted)
	{
 		const WCHAR* begin = m_encoded.Buffer();
 		ASSERT(begin <= ptr);
		while(begin != ptr)
		{
			m_DecodedBuffer.append(*begin);								
			begin++;
		}
		m_fConverted = true;
	}
	ptr++;
	check_end(ptr , end);

	//
	//Encoded chars should start with L'#' just after the L'&'
	//
	if(*(ptr++) != L'#')
		throw bad_xml_encoding();

	//
	// Now loop over the caracters untill L';' and calculate
	// their decimal numeric value.
	//
	WCHAR decoded = 0;
	short i = 0;
	for(;;)
	{
		check_end(ptr , end);

		if(*ptr == L';')
			break;

		if(!iswdigit(*ptr))
			throw bad_xml_encoding();

		decoded = decoded * 10 + (*ptr - L'0');
		++ptr;
		++i;
	}

	if(decoded == 0 || i > 2)
		throw bad_xml_encoding();

	//
	// Add the caracter  to the decoded buffer
	//
	m_DecodedBuffer.append(decoded);

	//
	// Return the position for the next caracter
	//
	return ++ptr;
}



const xwcs_t CXmlDecode::get() const
/*++

Routine Description:
    Return the decoded characters


Arguments:
	None.

  
Returned Value:
	array of decoded characters.

Note:
If no caracters in the input caracters was decoded - the input caracters return as is.
If one of the  input caracters was decoded  - the decoded buffer is returned.

--*/
{
	return m_fConverted ? xwcs_t(m_DecodedBuffer.begin(), m_DecodedBuffer.size()) : m_encoded;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\xml\lib\xmlns.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    xmlns.cpp

Abstract:
  implementation of xml namespace support classes declared in (xmlns.h)

Author:
    Gil Shafriri(gilsh) 9-May-2000

--*/

#include <libpch.h>
#include <xml.h>
#include "xmlns.h"

#include "xmlns.tmh"

//---------------------------------------------------------
//
//  CNameSpaceInfo - implementation 
//
//---------------------------------------------------------



CNameSpaceInfo::CNameSpaceInfo(
				const INamespaceToId* NamespaceToId
				):
				m_nsstacks(new CNameSpaceStacks),
				m_NamespaceToId(NamespaceToId)
/*++

Routine Description:
    Constructor - initialize clean namespace information object.
	The object is created with this constructor at the parsing start. 


Arguments:
	None

  
Returned Value:
	None
  
--*/
{

}



CNameSpaceInfo::CNameSpaceInfo(
	CNameSpaceInfo* pNameSpaceInfo
	) : 
	m_nsstacks(pNameSpaceInfo->m_nsstacks),
	m_NamespaceToId(pNameSpaceInfo->m_NamespaceToId)
/*++

Routine Description:
    Constructor - initialize namespace information based on namespace information 
	object of the previous level.	

	
Arguments:
	CNameSpaceInfo -  namespace information of 	previous level.

  
Returned Value:
	None
  
--*/
{

}



CNameSpaceInfo::~CNameSpaceInfo()
/*++

Routine Description:
    dtor - Does cleanup of the namespaces info declared in the lifetime of the object.	
	It pop from the cleanup stack UriNodes objects - get from the information on this objects
	the Uri stack it's  belongs to, pop it from this stack and delete the object.

  
Arguments:
	None	

  
Returned Value:
	None
  
--*/

{
	while(!m_NsCleanStack.empty())
	{
		CNsUriNode* pNsUriNode =  &m_NsCleanStack.front();
		ASSERT(pNsUriNode != NULL);

		//
		// remove from cleanup stack
		// here we can use the method remove because we know
		// the stack the item belongs.
		// this the prefered method to remove item from the list
		// because it does some validation befor removing
		//
		m_NsCleanStack.remove(*pNsUriNode);


		//
		// remove from namespace stack using link information.
		// saved on the node itself. Here we can't use
		// the method remove because we don't know to which 
		// namespace stack it belongs. Fourtunly - the node can unlik 
		// itself without knowing the list it is in. 
		//
		CNsStack::RemoveEntry(&pNsUriNode->m_NsStack);

		delete pNsUriNode;
	}
}


void  
CNameSpaceInfo::SaveNs(
	const xwcs_t& prefix,
	const xwcs_t& uri
	)
/*++

Routine Description:
    Save  prefix\uri namespace declaration. It save this mapping in a stack dedicated to
	the prefix. It also save this mapping in special cleanup stack - so when the object goes out of
	scope -  this namespace declaration will be removed.

  
Arguments:
	None	

  
Returned Value:
	None
  
--*/

{
	//
	//Map namespace string to id
	//
	int nsid = (m_NamespaceToId != NULL) ? (*m_NamespaceToId)[uri] : 0;

	P<CNsUriNode> pNsUriNode  = new CNsUriNode(uri, nsid);
	m_nsstacks->SaveNs(prefix, pNsUriNode);
	m_NsCleanStack.push_front( *(pNsUriNode.detach()) );
}



const 
CNsUri
CNameSpaceInfo::GetNs(
	const xwcs_t& prefix
	)const

/*++

Routine Description:
    Get the current namespace uri for given namespace prefix.

  
Arguments:
	Namespace prefix.

  
Returned Value:
	Namespace uri or empty 	xwcs_t if not exists.
  
--*/

{
	const CNsUriNode* pNsUriNode = m_nsstacks->GetNs(prefix);
	if(pNsUriNode == NULL)
	{
		return CNsUri();
	}

	return pNsUriNode->NsUri();
}


//---------------------------------------------------------
//
//  CNameSpaceInfo::CNameSpaceStacks - implementation 
//
//---------------------------------------------------------


CNameSpaceInfo::CNameSpaceStacks::~CNameSpaceStacks()
/*++

Routine Description:
    remove and delete namespace prefixes stacks.
  
Arguments:
	None.

  
Returned Value:
	None
  
--*/


{
	for(;;)
	{
		CStacksMap::iterator it = m_map.begin();
		if(it == m_map.end() )
		{
			return;				
		}
		CNsStack* pCNsStack = it->second;
		ASSERT(pCNsStack->empty());
	
		delete 	pCNsStack;
		m_map.erase(it);//lint !e534
	}
}



const CNsUriNode* CNameSpaceInfo::CNameSpaceStacks::GetNs(const xwcs_t& prefix)const
/*++

Routine Description:
    Return namespace uri node for given namespace prefix.
	It find the stack for the prefix and pop from it the top item.
	

Arguments:
    IN - prefix	- namespace prefix.

  
Returned Value:
	The uri node in the top of the prefix stack. If not prefix exists - NULL is retuned .
  
--*/
{
	CStacksMap::const_iterator it = m_map.find(prefix);
	if(it == m_map.end())
	{
		return NULL;
	}
	CNsStack*  NsUriStack =  it->second;
	ASSERT(NsUriStack != NULL);

	if(NsUriStack->empty())
	{
		return NULL;
	}
	
	const CNsUriNode* NsUriNode = &NsUriStack->front();
	ASSERT(NsUriNode != NULL);
	return 	NsUriNode;
}



void
CNameSpaceInfo::CNameSpaceStacks::SaveNs(
	const xwcs_t& prefix,
	CNsUriNode* pNsUriNode 
	)

/*++

Routine Description:
    Save namespace uri of given prefix in the stack of that prefix.

Arguments:
    IN - prefix	- namespace prefix
	IN - pNsUriNode namespace uri node to save.

  
Returned Value:
	pointer to CNsUriNode object saved
  
--*/

{
	//
	// get or create stack for the given namespace uri according to it's prefix
	//
	CNsStack& NsStack = OpenStack(prefix);
	
	NsStack.push_front(*pNsUriNode);

}

CNsStack& CNameSpaceInfo::CNameSpaceStacks::OpenStack(const xwcs_t& prefix)
/*++

Routine Description:
	Open namespace uri stack for given prefix - If not exists create it


Arguments:
	prefix - namespace prefix.   

  
Returned Value:
	reference to namespace uri stack of the given prefix.
  
--*/

{
	CStacksMap::const_iterator it = m_map.find(prefix);
	if(it != m_map.end())
	{
		return *it->second;
	}

	P<CNsStack> pNsNewStack = new CNsStack;
	bool fSuccess = InsertStack(prefix,pNsNewStack);
	ASSERT(fSuccess);
	DBG_USED(fSuccess);
	return *(pNsNewStack.detach());
}


bool CNameSpaceInfo::CNameSpaceStacks::InsertStack(const xwcs_t& prefix,CNsStack* pCNsStack)
/*++

Routine Description:
	Insert new stack into the map that contains namespace prefix stacks. 


Arguments:
    prefix	- namespace prefix
	pCNsStack - pointer to stack to insert to map

  
Returned Value:
	True is stack inserted - false if elready exists.
*/

{
	return m_map.insert(CStacksMap::value_type(prefix,pCNsStack)).second;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\xml\lib\xmlns.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    xmlns.h

Abstract:
	Classes that help xml parser to  deal with  namespaces.  

	The basic functionality the parser needs it to save namespace declaration
	it find in the xml text - and to find the current uri for a given prefix.
	In general - each node inherites all namespaces was declared by parents nodes
	unless it override them. We need to maintain stack  per namespace prefix -
	to know what is the uri matching given prefix in an arbitrary scope.


Author:
    Gil Shafriri(gilsh) 9-May-2000

--*/

#pragma once

#ifndef _MSMQ_XMLNS_H_
#define _MSMQ_XMLNS_H_

#include <xstr.h>
#include <list.h>



class CNsUriNode;
typedef List<CNsUriNode,0> 	CNsStack;


//---------------------------------------------------------
//
//  CNsUriNode - class that represent namespace uri node.
//  it push itself it a stack in the ctor and pop itself
//  in dtor. 
//
//---------------------------------------------------

struct CNsUri
{
	CNsUri(
		const xwcs_t& uri = xwcs_t(),
		int nsid = 0
		):
		m_uri(uri),
		m_nsid(nsid)		
		{
		}

	xwcs_t	m_uri;
	int m_nsid;
};



class CNsUriNode 
{
public:
	CNsUriNode(
	const xwcs_t& uri,
	int nsid
	):
	m_CNsInfo(uri, nsid)
	{
	}

	CNsUri NsUri()const 
	{
		return m_CNsInfo;
	}


public:
	LIST_ENTRY  m_NsStack;    // must be first
	LIST_ENTRY  m_CleanStack;

private:
	CNsUri m_CNsInfo;

private:
	CNsUriNode(const CNsUriNode&);
	CNsUriNode& operator=(const CNsUriNode&);
};

C_ASSERT(offsetof(CNsUriNode,m_NsStack)== 0);


//---------------------------------------------------------
//
//  CNameSpaceInfo - Class that expose the functionality needs by the parser :
//	1) Save namespace declaration (prefix\uri pair )
//  2) Match uri to prefix.
// 	The parser create object of this class in the node scope - 
//  and save the declarations it find in this scope. 
//  The object itself responsible to clean the namespace declarations
//  saved in it's lifetime. (remember namespace declarations valid only in the scope they declared)
//---------------------------------------------------
class INamespaceToId;
class CNameSpaceInfo
{
public:
	CNameSpaceInfo(CNameSpaceInfo* NameSpaceInfo);
	CNameSpaceInfo(const INamespaceToId* NamespaceToId);
	~CNameSpaceInfo();

public:
	void  SaveNs(const xwcs_t& prefix,const xwcs_t& uri);
	const CNsUri GetNs(const xwcs_t& prefix) const;

private:
	typedef List<CNsUriNode,offsetof(CNsUriNode,m_CleanStack)> CNsCleanStack;

	//
	// class CNameSpaceStacks - manage map of stacks. Stack per namespace prefix.
	// Namespace Uris are pushed\poped to\prom the correct stack according to their prefix.
	//
	class CNameSpaceStacks :public CReference
	{
	public:
		CNameSpaceStacks(){};
		~CNameSpaceStacks();

	public:
		const CNsUriNode* GetNs(const xwcs_t& prefix)const;
		void SaveNs(const xwcs_t& prefix, CNsUriNode* pNsUriNode);

	private:
		bool InsertStack(const xwcs_t& prefix,CNsStack* pCNsStack);
		CNsStack& OpenStack(const xwcs_t& prefix);

	   		
	private:
		CNameSpaceStacks(const CNameSpaceStacks&);
		CNameSpaceStacks& operator=(const CNameSpaceStacks&);


	private:
		typedef std::map<xwcs_t,CNsStack*> CStacksMap;
		CStacksMap m_map;
	};




private:
	R<CNameSpaceStacks> m_nsstacks;
	CNsCleanStack m_NsCleanStack;
	const INamespaceToId* m_NamespaceToId;

private:
	CNameSpaceInfo(const CNameSpaceInfo&);
	CNameSpaceInfo& operator=(const CNameSpaceInfo&);
};







#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\xml\test\fmapper.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    FMapper.cpp

Abstract:
    memory-mapped-files api abstraction.
   
	

Author:
    Nir Aides (niraides) 27-dec-99

--*/

#include <libpch.h>
#include "FMapper.h"

#include "fmapper.tmh"

CFileMapper::CFileMapper( LPCTSTR FileName )
{
    CFileHandle hFile = CreateFile(
							FileName, 
							GENERIC_READ, 
							FILE_SHARE_READ, 
							NULL,        // IpSecurityAttributes
							OPEN_EXISTING,
							NULL,      // dwFlagsAndAttributes
							NULL      // hTemplateFile
							);
    if(hFile == INVALID_HANDLE_VALUE)
        throw FileMappingError();

	m_size = ::GetFileSize( 
					hFile, 
					NULL    // lpFileSizeHigh 
					);

	if(m_size <= 0)
		throw FileMappingError();

    *&m_hFileMap = ::CreateFileMapping( 
						hFile,
						NULL,       // IpFileMappingAttributes
						PAGE_WRITECOPY,
						0,        // dwMaximumSizeHigh
						0,		 // dwMaximumSizeLow
						NULL    // lpName
						);
    if(m_hFileMap == NULL)
        throw FileMappingError();
}



LPVOID CFileMapper::MapViewOfFile( DWORD dwDesiredAccess )
{
	ASSERT( dwDesiredAccess == FILE_MAP_COPY || dwDesiredAccess == FILE_MAP_READ );

    LPVOID address = ::MapViewOfFile( 
							m_hFileMap,
							dwDesiredAccess,
							0,                // dwFileOffsetHigh
							0,				 // dwFileOffsetLow
							0				// dwNumberOfBytesToMap
							);

    return address;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\xml\test\fmapper.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    FMapper.h

Abstract:
    memory-mapped-files api abstraction.

	1. each view can be defined to be either FILE_MAP_COPY, or FILE_MAP_READ. 
	2. throws FileMappingError() exceptions on api functions failure.
	3. it is the responsiblity of users to unmap views!
	4. CViewPtr is an auto pointer class to a file mapping view

Author:
    Nir Aides (niraides) 27-dec-99

--*/



#pragma once

              

//
// class objects thrown on exceptions
//
class FileMappingError {};



class CFileMapper
{
public:
    CFileMapper( LPCTSTR FileName );

    DWORD  GetFileSize( void ) const
	{
		return m_size;
	}

	//
	// dwDesiredAccess can be either FILE_MAP_COPY, or FILE_MAP_READ.
	//
    LPVOID MapViewOfFile( DWORD dwDesiredAccess );

private:

	//
	// unimplemented to prevent copy construction or assignment operator
	//
	CFileMapper( const CFileMapper &obj );
	operator=( const CFileMapper &obj );

private:
    CFileHandle m_hFileMap;

	DWORD m_size;
};



//---------------------------------------------------------
//
//  auto file map view class
//
//---------------------------------------------------------
class CViewPtr {
private:
    LPVOID m_p;

public:
    CViewPtr( LPVOID p = NULL ): m_p( p ) {}
   ~CViewPtr() 
   { 
	   if(m_p) UnmapViewOfFile( m_p ); 
   }

	operator LPVOID() const { return m_p; }
    LPVOID* operator&()     { return &m_p; }
    LPVOID  detach()        { LPVOID p = m_p; m_p = NULL; return p; }

private:
    CViewPtr( const CViewPtr& );
    CViewPtr& operator=( const CViewPtr& );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\lib\xml\test\xmltest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    XmlTest.cpp

Abstract:
    Xml library test.

	"usage: XmlTest [-h] [[-g|-b] <file name>] [-n <number>]\n\n"
	"    -h     dumps this usage text.\n"
	"    -g     signals <file name> contains a valid xml document (default).\n"
	"    -b     signals <file name> contains a bad   xml document.\n"
	"    -n     executes <number> parsing iterations of documents (default is 1).\n"
	"    if no file name specified, activates test with hardcoded xml files.";
  
Author:
	Nir Aides (niraides)	29-dec-99
    Erez Haba (erezh)		15-Sep-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <Xml.h>
#include <xmlencode.h>
#include "FMapper.h"

#include "XmlTest.tmh"


//-------------------- global structures and constants ----------------------

const char xOptionSymbol = '-';

const char xUsageText[] =
	"usage: XmlTest [-h] [[-g|-b] <file name>] [-n <number>]\n\n"
	"    -h     dumps this usage text.\n"
	"    -g     signals <file name> contains a valid xml document (default).\n"
	"    -b     signals <file name> contains a bad   xml document.\n"
	"    -n     executes <number> parsing iterations of documents (default is 1).\n\n"
	"    if no file name specified, activates test with hardcoded xml files.";



struct CActivationForm
{
	CActivationForm( void ):
		m_fEmptyForm( true ),
		m_fErrorneousForm( false ),
		m_fExpectingGoodDocument( true ), 
		m_fDumpUsage( false ), 
		m_iterations( 1 ),
		m_FileName( NULL )
	{}

	bool    m_fEmptyForm;
	bool	m_fErrorneousForm;

	bool    m_fExpectingGoodDocument;
	bool    m_fDumpUsage;
	int     m_iterations;
	LPCTSTR m_FileName;
};



CActivationForm g_ActivationForm;



//
// exception class thrown by TestBuffer on test failure
//
class TestFailed {};


	
//
// xGoodDocument & xBadDocument are the hardcoded xml files.
//

const WCHAR xGoodDocument[] =
	L"<?xml aldskjfaj ad;jf adsfj asdf asdf ?>"
	L"<!-- this is a comment - this is a comment -->\r\n"
	L"      \r\n"
	L"<root xmlns=\"gil\"  xmlns:nsprefix2=\"http://ms2.com\"   xmlns:nsprefix=\"http://ms3.com\" >"

		L"<!-- 1st comment in the root node -->\r\n"
		L"<nsprefix:node1  xmlns=\"gil2\" id=\"33\" type = 'xml'>"
			L"the node text 1st line"
			L"<!-- a comment in node 1 -->\r\n"
			L"more text"
			L"<node1.1 nsprefix2:type = 'an empty node'/>"
		L"</nsprefix:node1>"

		L"some root text 1-2"

		L"<![CDATA[ab123 adf a< ]<>]] ]>>!!&&]]]]>"

		L"<!-- 2nd comment in the root node -->\r\n"
		L"<node2 id=\"33\" type = 'xml' length = '\?\?'  >"
			L"<!-- a comment in node 2 -->\r\n"
			L"node 2 text"
			L"<node2.1 />"
			L"<node2.2 xmlns=\"gil2\" xmlns:nsprefix=\"http://ms3.com\" channel = \"1234\" id='111' nsprefix:timeout= \"33\">"
				L"text in node 2.2"
				L"<nsprefix:node2.2.1 tag = 'QoS' xmlns:nsprefix=\"http://ms4.com\">"
					L"<Durable/>"
					L"<Retry/>"
				L"</nsprefix:node2.2.1>\r\n"
				L"more text in node 2.2"
			L"</node2.2>"
		L"</node2>"

		L"<!-- 3rd comment in the root node -->\r\n"
		L"<node3 id=\"33\" type = 'xml'>"
			L"the node text 1st line"
			L"more text"
			L"<node3.2 type = 'empty node'/>"
		L"</node3>"

		L"some root text 3-4"

		L"<!-- 4th comment in the root node -->\r\n"
		L"<node4 id=\"33\" type = 'xml' length = '\?\?'  >"
			L"node 4 text"
			L"<node4.1 />"
			L"<node4.2 id='4.2'>"
				L"text in node 4.2"
				L"<node4.2.1 tag = 'QoS node 4'>"
					L"<Durable/>"
					L"<Retry/>"
				L"</node4.2.1>\r\n"
				L"more text in node 4.2"
			L"</node4.2>"
		L"</node4>"

	L"</root>"
	;








const WCHAR xBadDocument[] =
	L"<?xml aldskjfaj ad;jf adsfj asdf asdf ?>"
	L"<!-- this is a comment - this is a comment -->\r\n"
	L"      \r\n"
	L"<root>"

		L"<!-- 1st comment in the root node -->\r\n"
		L"<node1 id=\"33\" type = 'xml'>"
			L"the node text 1st line"
			L"<!-- a comment in node 1 -->\r\n"
			L"more text"
			L"<node1.1 type = 'an empty node'/>"
		L"</node2>"

		L"some root text 1-2"

		L"<![CDATA[ab123 adf a< ]<>]] ]>>!!&&]]]]>"
	;




//-------------------------- old section ------------------------------------

const WCHAR *ParseDocument( const xwcs_t& doc, bool fExpectingGoodDocument, bool fDump = true )
{
	try
	{
		CAutoXmlNode XmlRootNode;
		const WCHAR   *end = XmlParseDocument(doc, &XmlRootNode);

  		ASSERT((XmlRootNode->m_element.Buffer() + XmlRootNode->m_element.Length()) == end);

		ASSERT(XmlRootNode->m_content.Length() < XmlRootNode->m_element.Length());

		if(XmlRootNode->m_content.Length() != 0)
		{
			//
			// Check end element content for non empty elements
			//
			const WCHAR *pContentEnd = XmlRootNode->m_content.Buffer() +  XmlRootNode->m_content.Length();
			DBG_USED(pContentEnd);
			ASSERT( wcsncmp(pContentEnd, L"</", 2) == 0);
			DWORD prefixLen =  XmlRootNode->m_namespace.m_prefix.Length();
			if(prefixLen)
			{
				ASSERT( wcsncmp(pContentEnd + 3 + prefixLen , XmlRootNode->m_tag.Buffer(), XmlRootNode->m_tag.Length()) == 0);
			}
			else
			{
				ASSERT( wcsncmp(pContentEnd + 2 , XmlRootNode->m_tag.Buffer(), XmlRootNode->m_tag.Length()) == 0);
			}
		}

		TrTRACE(GENERAL, "%d characters parsed successfully.", doc.Length() );

		if(fDump)
		{
			XmlDumpTree(XmlRootNode);
		}

		if(!fExpectingGoodDocument)
		{
			TrERROR(GENERAL, "parsing succeeded while excpeting parsing failure." );
			throw TestFailed();
		}

		return end;
	}
	catch( const bad_document &BadDoc  )
	{
		
		TrTRACE(GENERAL, "parsing raised bad_document exception. offset=%Id text='%.16ls'", BadDoc.Location() - doc.Buffer(), BadDoc.Location());

		if(fExpectingGoodDocument)
		{
			TrERROR(GENERAL, "parsing failed while excpeting succesful parsing." );
			throw TestFailed();
		}
		return BadDoc.Location();
	}
}



static void TestXmlFind(const WCHAR* Doc)
{
	CAutoXmlNode XmlRootNode;	  
	const WCHAR* End = XmlParseDocument(xwcs_t(Doc, wcslen(Doc)), &XmlRootNode);
	TrTRACE(GENERAL, "Searching %Id characters document", End - Doc);

	const WCHAR NodePath[] = L"root!node4!node4.2";
	const WCHAR SubNodePath[] = L"!node4!node4.2";

	const XmlNode* node = XmlFindNode(XmlRootNode, NodePath);
	if(node == 0)
	{
		TrTRACE(GENERAL, "Failed to find node '%ls'", NodePath);
	}
	else
	{
		TrTRACE(GENERAL, "Found node '%ls' = 0x%p", NodePath, node);
	}

	ASSERT(node != 0);

	const XmlNode* SubNode = XmlFindNode(XmlRootNode, SubNodePath);
	if(SubNode == 0)
	{
		TrTRACE(GENERAL, "Failed to find sub node '%ls'", SubNodePath);
	}
	else
	{
		TrTRACE(GENERAL, "Found sub node '%ls' = 0x%p", SubNodePath, SubNode);
	}

	ASSERT(SubNode != 0);
	ASSERT(SubNode == node);

	const xwcs_t* value = XmlGetNodeFirstValue(XmlRootNode, NodePath);
	if(value == 0)
	{
		TrTRACE(GENERAL, "Failed to find node '%ls' value", NodePath);
	}
	else
	{
		TrTRACE(GENERAL, "Found node '%ls' value '%.*ls'", NodePath, LOG_XWCS(*value));
	}

	ASSERT(value != 0);

	const xwcs_t* SubValue = XmlGetNodeFirstValue(XmlRootNode, SubNodePath);
	if(SubValue == 0)
	{
		TrTRACE(GENERAL, "Failed to find sub node '%ls' value", SubNodePath);
	}
	else
	{
		TrTRACE(GENERAL, "Found sub node '%ls' value '%.*ls'", SubNodePath, LOG_XWCS(*SubValue));
	}

	ASSERT(SubValue != 0);
	ASSERT(SubValue == value);

	const WCHAR AttributeTag[] = L"id";

	value = XmlGetAttributeValue(XmlRootNode, AttributeTag, NodePath);
	if(value == 0)
	{
		TrTRACE(GENERAL, "Failed to find node '%ls' attribute '%ls' value", NodePath, AttributeTag);
	}
	else
	{
		TrTRACE(GENERAL, "Found node '%ls' attribute '%ls' = '%.*ls'", NodePath, AttributeTag, LOG_XWCS(*value));
	}

	ASSERT(value != 0);

	SubValue = XmlGetAttributeValue(XmlRootNode, AttributeTag, SubNodePath);
	if(SubValue == 0)
	{
		TrTRACE(GENERAL, "Failed to find sub node '%ls' attribute '%ls' value", SubNodePath, AttributeTag);
	}
	else
	{
		TrTRACE(GENERAL, "Found sub node '%ls' attribute '%ls' = '%.*ls'", SubNodePath, AttributeTag, LOG_XWCS(*SubValue));
	}

	ASSERT(SubValue != 0);
	ASSERT(SubValue == value);
}



void ExecBuiltInTest( void )
{
	//
	// forward declaration
	//
	void TestBuffer(const xwcs_t& doc , bool fExpectingGoodDocument, int iterations = 1 );

	printf("Parsing %d characters in good document\n", STRLEN(xGoodDocument) );
	TestBuffer( 
		xwcs_t(xGoodDocument,STRLEN(xGoodDocument)), 
		true, // expecting good document
		g_ActivationForm.m_iterations 
		);

	try
	{
		TrTRACE(GENERAL, "Searching good document." );
		TestXmlFind(xGoodDocument);
	}
	catch(const bad_document& bd)
	{
		TrTRACE(GENERAL, "Bad document exception while searching document. offset=%d text='%.16ls'", (int)(bd.Location() - xGoodDocument), bd.Location());
		throw TestFailed();
	}

	 
	printf("Parsing %d characters in bad document\n", STRLEN(xBadDocument));
	TestBuffer( 
		xwcs_t(xBadDocument,wcslen(xBadDocument)), 
		false, // expecting bad document
		g_ActivationForm.m_iterations 
		);

	//
	// copy the good ducument and make it none null terminated
	//
    AP<WCHAR> NoneNullTerminatingGoodDocument( newwcs(xGoodDocument));
	size_t len = wcslen(NoneNullTerminatingGoodDocument);
	NoneNullTerminatingGoodDocument[len] = L't';


   printf("Parsing %Id characters in not null terminating good document\n", len);
   TestBuffer( 
		xwcs_t(NoneNullTerminatingGoodDocument, len), 
		true, // expecting good document
		g_ActivationForm.m_iterations 
		);

   
}



//----------------------------------- new section ------------------------------

inline
void DumpUsageText( void )
{
	TrTRACE(GENERAL, "%s\n" , xUsageText );
}



void SetActivationForm( int argc, LPCTSTR argv[] )
/*++
Routine Description:
    translates command line arguments to CActivationForm structure.

Arguments:
    main's command line arguments.

Returned Value:
	affects g_ActivationForm.
	on errorneous command line arguments, it sets the g_ActivationForm.m_fErrorneous field

proper command line syntax:
	"usage: XmlTest [-h] [[-g|-b] <file name>] [-n <number>]\n\n"
	"    -h     dumps this usage text.\n"
	"    -g     signals <file name> contains a valid xml document (default).\n"
	"    -b     signals <file name> contains a bad   xml document.\n"
	"    -n     executes <number> parsing iterations of documents (default is 1).\n"
	"    -q     eliminates parser output (good for tests with many iterations).\n\n"
	"    if no file name specified, activates test with hardcoded xml files.";
--*/
{
	g_ActivationForm.m_fErrorneousForm = false;
	g_ActivationForm.m_fEmptyForm      = false;

	if(argc == 1)
	{
		g_ActivationForm.m_fEmptyForm = true;
		return;
	}
	
	for(int index = 1; index < argc; index++)
	{
		if(argv[index][0] != xOptionSymbol)	
		{
			//
			// consider argument as file name
			//
			g_ActivationForm.m_FileName = argv[index];
			continue;
		}

		//
		// option symbols should consist of 2 chars only! '-' and 'xx'
		//
		if(argv[index][2] != 0)
		{
			g_ActivationForm.m_fErrorneousForm = true;
			return;
		}

		//
		// else consider argument as option and switch upon its second character.
		//
		switch(argv[index][1])
		{
		case 'G':
		case 'g':	// expect valid xml input files
			g_ActivationForm.m_fExpectingGoodDocument = true;
			break;

		case 'B':
		case 'b':	// expect bad xml input filed
			g_ActivationForm.m_fExpectingGoodDocument = false;
			break;

		case 'N':
		case 'n':	// set iterations number
			{
				index++;
			
				int result = swscanf( argv[index], L"%d", &g_ActivationForm.m_iterations );

				if(result == 0 || g_ActivationForm.m_iterations <= 0)
				{
					g_ActivationForm.m_fErrorneousForm = true;
					return;
				}
			}
			break;

		case 'h':	// output help
			g_ActivationForm.m_fDumpUsage = true;
			break;

		default:
			g_ActivationForm.m_fErrorneousForm = true;
			return;
		};
	}

	return;
}


static void EncodeTest()
{
	std::wstring  wstr = L"this is string without special caractes";
	std::wostringstream owstr;
	owstr<<CXmlEncode(xwcs_t(wstr.c_str(), wstr.size()));
	if(!(owstr.str() == wstr))
	{
		TrTRACE(GENERAL, "wrong xml encoding");
		throw TestFailed();
	}


	owstr.str(L"");
	wstr = L"this is string with  special caractes like < and > and spaces ";
	owstr<<CXmlEncode(xwcs_t(wstr.c_str(), wstr.size()));
	std::wstring encoded = 	owstr.str();
	if(encoded == wstr)
	{
		TrTRACE(GENERAL, "wrong xml encoding");
		throw TestFailed();
	}

	CXmlDecode XmlDecode;
	XmlDecode.Decode(xwcs_t(encoded.c_str(), encoded.size()));
	xwcs_t  wcsDecoded =  XmlDecode.get();
	std::wstring wstrDecoded (wcsDecoded.Buffer(), wcsDecoded.Length());
	if(!(wstrDecoded ==  wstr) )
	{
		TrTRACE(GENERAL, "wrong xml encoding");
		throw TestFailed();
	}

}




void TestBuffer(const  xwcs_t& doc, bool fExpectingGoodDocument, int iterations = 1 )
/*++

Routine Description:
    parses the buffer n times, where n = 'iterations'.
	checks the results for consistency, and published performance results.
	consistency check is based on the value returned from the parser, which happens 
	to be the offset to the last character parsed by the parser.

Arguments:
    Parameters.

Returned Value:
	if reults are inconsistent or if ParseDocument() throws 'UnexpectedResults' 
	exception, then a 'TestFailed' exception is raised.

--*/
{
	const WCHAR *LastResultOffset = NULL;

	LARGE_INTEGER CounterFrequency;
	QueryPerformanceFrequency( &CounterFrequency );

	LARGE_INTEGER CounterStart;
	QueryPerformanceCounter( &CounterStart );

	for( int i = 0; i < iterations; i++)
	{
		const WCHAR *ResultOffset = ParseDocument( 
										doc,
										fExpectingGoodDocument,
										i == 0		// fDump (if true dumps parse tree)
										); 
		if(i == 0)
		{
			LastResultOffset = ResultOffset;
		}
		else if(ResultOffset != LastResultOffset)
		{
			TrTRACE(GENERAL, "INCONSISTENCY! on iteration %d.", i );
			throw TestFailed();
		}
	}

	LARGE_INTEGER CounterStop;
	QueryPerformanceCounter( &CounterStop );

	LONGLONG CounterMicroSec = ((CounterStop.QuadPart - CounterStart.QuadPart) * (1000000000 / CounterFrequency.QuadPart)) / 1000;
	printf("parsed %Id characters in document.\n", LastResultOffset - doc.Buffer() );
	printf("parsed %d iterations in %I64d usec.\n", iterations, CounterMicroSec );
	printf("document parsed %I64d times per second.\n", (LONGLONG(1000000) * iterations) / CounterMicroSec );
}

static bool IsValidUnicodeFile(const WCHAR* pBuffer,DWORD size)
{
	const DWORD xUnicodeStartDword=0X3CFEFF;
	if(size < sizeof(DWORD) || pBuffer == NULL)
	{
		return false;
	}
	DWORD UnicodeStartDword=*(DWORD*)pBuffer; 
	return  UnicodeStartDword  == xUnicodeStartDword;
}


void ExecFileTest( void )
/*++

Routine Description:
	intiates test with specified file name.

Arguments:
    Parameters.

Returned Value:
	rethrows the FileMapper's exception, if any.

--*/
{
	TrTRACE(GENERAL, "parsing xml file \'%ls\'.", g_ActivationForm.m_FileName );
	
	CFileMapper  FileMap( g_ActivationForm.m_FileName );
	CViewPtr     view( FileMap.MapViewOfFile( FILE_MAP_READ ) );
	const WCHAR  *buffer = static_cast<WCHAR*>( static_cast<LPVOID>( view ) );


	if(!IsValidUnicodeFile(buffer,FileMap.GetFileSize()))
	{
		TrWARNING(GENERAL, "the xml file is not valid unicode file" );
		throw TestFailed();
	}
	
	DWORD len = (FileMap.GetFileSize() +1) / sizeof(WCHAR);
	TestBuffer(xwcs_t(buffer+1,len-1), g_ActivationForm.m_fExpectingGoodDocument, g_ActivationForm.m_iterations );
}



void ExecActivationForm( void )
{
	EncodeTest();


	//
	// if -h signaled in command line arguments dump usage text, and return.
	//
	if(g_ActivationForm.m_fDumpUsage)	
	{
		DumpUsageText();
		return;
	}

	//
	// if no file name specified. proceed with internal test
	//
	try
	{
		printf("TEST START\n");

		if(g_ActivationForm.m_FileName == NULL)	 
		{
			ExecBuiltInTest();
		}
		else
		{
			ExecFileTest();
		}

		printf("TEST PASSED\n");
	}
	catch( const TestFailed& )
	{
		printf("TEST FAILED\n");
		exit( 1 );
	}
	catch( const FileMappingError& )
	{
		printf("ERROR: file mapping error.\n");
		printf("TEST ABORTED\n");
		exit( 2 );
	}
		
}




extern "C" int _cdecl  _tmain( int argc, LPCTSTR argv[] )
/*++

Routine Description:
    Test Xml library

Arguments:
    Parameters.

Returned Value:
    0 - parser ok.
	1 - parser failed.
	2 - file mapping error.
	3 - bad argument list in command line

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	TrInitialize();

	XmlInitialize();

	SetActivationForm( argc, argv );
	if(g_ActivationForm.m_fErrorneousForm)
	{
		DumpUsageText();
		return 3;
	}

	//
	// try catches file mapping errors
	//
	ExecActivationForm();
	
	WPP_CLEANUP();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\migrepl.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: migrepl.h

Abstract: definitions which are common to the migration tool and the
          replication service.

Author:

    Doron Juster  (DoronJ)   18-Mar-98

--*/

//+-----------------------------------------------
//
// Definitions used in seq numbers ini file.
//
//+-----------------------------------------------

//
// In this file we keep the seq-numbers of other MSMQ1.0 PSCs.
// It is created by the migration tool and used by the replication service.
//
#define SEQ_NUMBERS_FILE_NAME  TEXT("mqseqnum.ini")

//
// In this section we register the seq-numbers most recently received
// from other MSMQ1.0 PSCs. (recieved by replication from other PSCs to us).
// The objects with these numbers are already in NT5 DS, i.e., the
// replication service first update the DS and then update the seq number
// in the ini file.
//
#define RECENT_SEQ_NUM_SECTION_IN  TEXT("MostRecentSeqNumbersIn")

//
// In this section we register the seq-numbers most recently sent by PEC server
// to its BSCs about itself, all other NT5 masterss and MSMQ1.0 PSCs. 
// The objects with these numbers are already in NT5 DS, i.e., the
// replication service first update the DS and then update the seq number
// in the ini file.
//
#define RECENT_SEQ_NUM_SECTION_OUT  TEXT("MostRecentSeqNumbersOut")

//
// In this section we register the highest seq-number of each MSMQ1.0 PSC
// while running the migration tool. This is necessary for replication TO
// MSMQ1.0 PSCs and BSCs.
// Once set by the migration tool, the entries under this section are not
// changed anymore.
//
#define MIGRATION_SEQ_NUM_SECTION  TEXT("HighestMigSeqNumbers")

//
// In this section we register the delta between MQIS seqnumbers and DS
// USN numbers for each MSMQ master. This is necessary for replication to
// NT4 BSCs (where NT5 server replicate objects of other NT4 masters to its
// own NT4 BSCs). The delta values are used to convert from seq-numbers to
// usn and vice-versa.
// The delta is added to the USN to get the seq-num. The delta is subtracted
// from seq-number to get USNs.
//
#define MIGRATION_DELTA_SECTION  TEXT("MigDelta")

//
// In this section we register all CNs of MSMQ1.0
// Once set by the migration tool, the entries under this section are not
// changed anymore.
//
#define MIGRATION_IP_SECTION        TEXT("IP CNs")
#define MIGRATION_IPX_SECTION       TEXT("IPX CNs")
#define MIGRATION_FOREIGN_SECTION   TEXT("Foreign CNs")

#define MIGRATION_CN_KEY            TEXT("CN")

#define MIGRATION_IP_CNNUM_SECTION          TEXT("IP CN Number")
#define MIGRATION_IPX_CNNUM_SECTION         TEXT("IPX CN Number")
#define MIGRATION_FOREIGN_CNNUM_SECTION     TEXT("Foreign CN Number")

#define MIGRATION_CNNUM_KEY     TEXT("CNNumber")

//
// In this section we save all Windows Site Links
// Entries set by migration tool and after restoring of these site links in DS
// they will be removed from file
//
#define MIGRATION_SITELINKNUM_SECTON	TEXT("SiteLink Number")
#define MIGRATION_SITELINKNUM_KEY		TEXT("SiteLinkNumber")

#define MIGRATION_NONRESTORED_SITELINKNUM_SECTON	TEXT("Non Restored SiteLink Number")

#define MIGRATION_SITELINK_SECTION		TEXT("SiteLink")

#define MIGRATION_SITELINK_PATH_KEY				TEXT("Path")
#define MIGRATION_SITELINK_PATHLENGTH_KEY		TEXT("PathLength")
#define MIGRATION_SITELINK_NEIGHBOR1_KEY		TEXT("Neighbor1")
#define MIGRATION_SITELINK_NEIGHBOR2_KEY		TEXT("Neighbor2")
#define MIGRATION_SITELINK_SITEGATE_KEY			TEXT("SiteGate")
#define MIGRATION_SITELINK_SITEGATENUM_KEY		TEXT("SiteGateNum")
#define MIGRATION_SITELINK_SITEGATELENGTH_KEY	TEXT("SiteGateLength")
#define MIGRATION_SITELINK_COST_KEY				TEXT("Cost")
#define MIGRATION_SITELINK_DESCRIPTION_KEY		TEXT("Description")
#define MIGRATION_SITELINK_DESCRIPTIONLENGTH_KEY	TEXT("DescriptionLength")

//
// For cluser mode: in this section we'll save all PSCs and all PEC's BSCs
//
#define MIGRATION_ALLSERVERS_SECTION			TEXT("All Servers To Update")
#define MIGRATION_ALLSERVERS_NAME_KEY			TEXT("ServerName")

#define MIGRATION_ALLSERVERSNUM_SECTION			TEXT("Server Number")
#define MIGRATION_ALLSERVERSNUM_KEY				TEXT("AllServerNumber")

#define MIGRATION_NONUPDATED_SERVERNUM_SECTION	TEXT("Non Updated Server Number")

//
// To replicate all site with names those were changed by migtool
//
#define MIGRATION_CHANGED_NT4SITE_NUM_SECTION  TEXT("Site Number")
#define MIGRATION_CHANGED_NT4SITE_NUM_KEY      TEXT("SiteNumber")

#define MIGRATION_CHANGED_NT4SITE_SECTION      TEXT("All Sites With Changed Properties")
#define MIGRATION_CHANGED_NT4SITE_KEY          TEXT("Site")

//
// Save new created site link id to add connector machine as site gate later
//
#define MIGRATION_CONNECTOR_FOREIGNCN_NUM_SECTION  TEXT("Foreign CN Number for Connector")
#define MIGRATION_CONNECTOR_FOREIGNCN_NUM_KEY    TEXT("ForeignCNNumber")
#define MIGRATION_CONNECTOR_FOREIGNCN_KEY        TEXT("ForeignCN")

//
// Save all machines with invalid name which were not migrated
//
#define MIGRATION_MACHINE_WITH_INVALID_NAME     TEXT("Non Migrated Machines With Invalid Name")

//
// These registry values keep track of highest USN numbers on local DS.
// FirstHighestUsnMig is the value before migration.
// LastHighestUsnMig is the value just after completing migration.
// This value is necessary when a MSMQ1.0 server ask sync0. Local DS will
// be queried for object with USN above this value.
// HighestUsnRepl is the highest value handled by last replication cycle
// from local replication service to MSMQ1.0 PSCs and BSCs.
//
#define FIRST_HIGHESTUSN_MIG_REG        TEXT("Migration\\FirstHighestUsnMig")
#define LAST_HIGHESTUSN_MIG_REG         TEXT("Migration\\LastHighestUsnMig")
#define HIGHESTUSN_REPL_REG             TEXT("Migration\\HighestUsnRepl")

//
// This flag is set to 1 by the migration tool if it ran in recovery mode.
// The replication service checks it on first time it run and if it was set
// it replicate all PEC's object to NT4 MQIS. 
// Then the replication service delete it.
//
#define AFTER_RECOVERY_MIG_REG          TEXT("Migration\\AfterRecovery")

//
// This flag is set to 1 by the migration tool.
// The replication service uses it on first time it run to replicate all
// existing NT5 sites to NT4 MQIS. then the replication service reset it
// to 0.
//
#define FIRST_TIME_REG    TEXT("Migration\\FirstTime")

//
// This flag is set to 1 by Migration tool after removing
// migration tool from Welcome screen. 
// Migration tool needs this flag to prevent unnecessary warning message box 
// when tool is executed more than once.
//
#define REMOVED_FROM_WELCOME	TEXT("Migration\\RemovedFromWelcome")

//
// In special mode (recovery or cluster) we don't have MasterId key after
// the setup, we create this key in our Migration section
//
#define MIGRATION_MQIS_MASTERID_REGNAME  TEXT("Migration\\MasterId")

//
// In cluster mode we have to save guid of former PEC (PEC on cluster)
//
#define MIGRATION_FORMER_PEC_GUID_REGNAME   TEXT("Migration\\FormerPECGuid")

//
// Indicates that although migration itself succeeded, we did not update all machines registry.
//
#define MIGRATION_UPDATE_REGISTRY_ONLY   TEXT("Migration\\RegistryUpdateOnly")

//
// This is the size of buffers to hold the printable representation of
// a seq-number. in both MQIS and NT5 DS, a seq-number is a 8 bytes bunary
// value.
//
#define  SEQ_NUM_BUF_LEN  32

//---------------------------------
//
// Definitions for LDAP queries
//
//---------------------------------

#define  LDAP_COMMA            (TEXT(","))

#define  LDAP_ROOT             (TEXT("LDAP://"))

#define  CN_CONFIGURATION_W    L"CN=Configuration,"
#define  CN_SERVICES_W         L"CN=Services,"
#define  CN_SITES_W            L"CN=Sites,"
#define  CN_USERS_W            L"CN=Users,"

#ifdef UNICODE
#define  CN_SITES           CN_SITES_W
#define  CN_SERVICES        CN_SERVICES_W
#define  CN_CONFIGURATION   CN_CONFIGURATION_W
#define  CN_USERS           CN_USERS_W
#else
#endif

#define CN_USERS_LEN           (sizeof(CN_USERS) / sizeof(TCHAR))

#define MQUSER_ROOT            L"OU=MSMQ Users,"
#define MQUSER_ROOT_LEN        (sizeof(MQUSER_ROOT) / sizeof(TCHAR))

#define  SITES_ROOT            (CN_SITES CN_CONFIGURATION)
#define  SITE_LINK_ROOT        (CN_SERVICES CN_CONFIGURATION)

#define  SITE_LINK_ROOT_LEN    (sizeof(SITE_LINK_ROOT) / sizeof(TCHAR))

#define  SERVER_DN_PREFIX      (TEXT("CN=MSMQ Settings,CN="))
#define  SERVER_DN_PREFIX_LEN  (sizeof(SERVER_DN_PREFIX) / sizeof(TCHAR))

#define  MACHINE_PATH_PREFIX        (TEXT("CN=msmq,CN="))
#define  MACHINE_PATH_PREFIX_LEN    (sizeof(MACHINE_PATH_PREFIX) / sizeof(TCHAR))


#define  SERVERS_PREFIX        (TEXT("CN=Servers,CN="))
#define  SERVERS_PREFIX_LEN    (sizeof(SERVERS_PREFIX) / sizeof(TCHAR))

#define  CN_PREFIX             (TEXT("CN="))
#define  CN_PREFIX_LEN         (sizeof(CN_PREFIX) / sizeof(TCHAR))

#define  OU_PREFIX             (TEXT("OU="))
#define  OU_PREFIX_LEN         (sizeof(OU_PREFIX) / sizeof(TCHAR))

#define  ISDELETED_FILTER      (TEXT("(IsDeleted=TRUE)"))
#define  ISDELETED_FILTER_LEN  (sizeof(ISDELETED_FILTER))

#define  OBJECTCLASS_FILTER      (TEXT("(objectClass="))
#define  OBJECTCLASS_FILTER_LEN  (sizeof(OBJECTCLASS_FILTER))

#define  DSATTR_SD             (TEXT("nTSecurityDescriptor"))

#define  CONTAINER_OBJECT_CLASS (TEXT("organizationalUnit"))

const WCHAR MQ_U_SIGN_CERT_MIG_ATTRIBUTE[] =    L"mSMQSignCertificatesMig";
const WCHAR MQ_U_DIGEST_MIG_ATTRIBUTE[] =       L"mSMQDigestsMig";
const WCHAR MQ_U_FULL_PATH_ATTRIBUTE[] =        L"distinguishedName"; 
const WCHAR MQ_U_DESCRIPTION_ATTRIBUTE[] =      L"description"; 

const WCHAR MQ_L_SITEGATES_MIG_ATTRIBUTE[] =    L"mSMQSiteGatesMig";

const WCHAR MQ_SET_MIGRATED_ATTRIBUTE[] =       L"mSMQMigrated";

const WCHAR USNCHANGED_ATTRIBUTE[] =            L"uSNChanged";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqdbodbc\apiodbc.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
		apiodbc.cpp

Abstract:
   Implement the api exported by mqdbmgr.dll.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      09-Jan-96   Created

--*/

#include "dbsys.h"
#include "mqdbodbc.h"
#include "dbodbc.h"
#include "tblodbc.h"

#include "apiodbc.tmh"

MQDBSTATUS APIENTRY  MQDBGetVersion( IN MQDBHANDLE         hDatabase,
                                     IN OUT LPMQDBVERSION  pVersion )
{
	TrTRACE(GENERAL, "In MQDBGetVersion");

   MQDBSTATUS dbstatus = MQDB_OK ;
   try
   {
      pVersion->dwMinor = 0 ;
      pVersion->dwMajor = 1 ;
      pVersion->dwProvider = MQDB_ODBC ;

      if (hDatabase)
      {
         // RetrieveDBMS name and version
         CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) hDatabase ;
         dbstatus = pDatabase->GetVersion( pVersion ) ;
      }
      else
      {
         pVersion->szDBMSName[0] = '\0' ;
         pVersion->szDBMSVer[0] = '\0' ;
      }
   }
   catch(...)
   {
      dbstatus = MQDB_E_INVALID_DATA ;
   }
   return dbstatus ;
}

static int g_cInits = 0 ;

MQDBSTATUS APIENTRY  MQDBInitialize()
{
	TrTRACE(GENERAL, "In MQDBInitialize");

   if (g_cInits == 0) {
      // Allocate the ODBC environment ;
      RETCODE sqlstatus = ::SQLAllocEnv(&g_hEnv);
		if (!ODBC_SUCCESS(sqlstatus)) {
         return MQDB_E_DATABASE ;
	   }
   }
   g_cInits++ ;
   return MQDB_OK ;
}


MQDBSTATUS APIENTRY  MQDBTerminate()
{
	TrTRACE(GENERAL, "In MQDBTerminate");

   if (g_cInits == 0) {
      return  MQDB_E_INVALID_CALL ;
   }

   g_cInits-- ;
   if (g_cInits == 0) {
      // Free the ODBC environment ;
      ASSERT(g_hEnv != SQL_NULL_HENV) ;
      RETCODE sqlstatus = ::SQLFreeEnv(g_hEnv);
		if (!ODBC_SUCCESS(sqlstatus)) {
			return MQDB_E_DATABASE ;
      }
      g_hEnv = SQL_NULL_HENV;
	}
   return MQDB_OK ;
}


MQDBSTATUS APIENTRY  MQDBOpenDatabase(
                           IN OUT  LPMQDBOPENDATABASE pOpenDatabase)
{
	TrTRACE(GENERAL, "In MQDBOpenDatabase");

   if (g_hEnv == SQL_NULL_HENV) {
      return  MQDB_E_DLL_NOT_INIT ;
   }

   MQDBSTATUS status ;
   try
   {
      CMQODBCDataBase *pDatabase = new CMQODBCDataBase() ;
      ASSERT(pDatabase) ;
      status = pDatabase->Connect(pOpenDatabase) ;
      if (status == MQDB_OK) {
         pOpenDatabase->hDatabase = (MQDBHANDLE) pDatabase ;
      }
      else {
         // Cannot connect. Cleanup and delete the database object.
         MQDBSTATUS tmpstatus = pDatabase->Disconnect() ;
         UNREFERENCED_PARAMETER(tmpstatus);
         delete pDatabase ;
      }
   }
   catch(...)
   {
      status = MQDB_E_OUTOFMEMORY ;
   }
   return status ;

}


MQDBSTATUS APIENTRY  MQDBCloseDatabase(
                           IN MQDBHANDLE  hDatabase)
{
	TrTRACE(GENERAL, "In MQDBCloseDatabase");

   CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) hDatabase ;
   MQDBSTATUS dbstatus ;

	// Guard against illegal handles.
	try
	{
      dbstatus = pDatabase->Disconnect() ;
      delete pDatabase ;
   }
	catch(...)
	{
      dbstatus = MQDB_E_BAD_HDATABASE ;
	}

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBOpenTable(
                     IN MQDBHANDLE     hDatabase,
                     IN LPSTR          lpszTableName,
                     OUT LPMQDBHANDLE  phTable)
{
	TrTRACE(GENERAL, "In MQDBOpenTable");

   MQDBSTATUS dbstatus ;
   CMQODBCTable *pTable = NULL ;

   try
   {

      pTable = new CMQODBCTable() ;
      ASSERT(pTable) ;

      dbstatus = pTable->Init( hDatabase, lpszTableName ) ;
      if (dbstatus == MQDB_OK) {
         *phTable = (MQDBHANDLE) pTable ;
      }
   }
	catch(...)
	{
      if (!phTable) {
         dbstatus = MQDB_E_INVALID_DATA ;
      }
      else if (!pTable) {
   	  dbstatus = MQDB_E_OUTOFMEMORY ;
      }
      else {
         dbstatus = MQDB_E_UNKNOWN ;
      }
	}

   if (dbstatus != MQDB_OK) {
      if (pTable) {
         delete pTable ;
      }
   }

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBCloseTable(
                     IN MQDBHANDLE     hTable)
{
	TrTRACE(GENERAL,"In MQDBCloseTable");

   if (!hTable) {
      return MQDB_E_BAD_HTABLE ;
   }

   MQDBSTATUS dbstatus ;
   CMQODBCTable *pTable = (CMQODBCTable *) hTable ;

   try
   {
      dbstatus = pTable->Close() ;
   }
   catch(...)
   {
      dbstatus = MQDB_E_BAD_HTABLE ;
   }

   if (dbstatus == MQDB_OK) {
      delete pTable ;
   }
   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBGetTableCount(IN MQDBHANDLE  hTable,
                                       OUT UINT       *puCount,
                                 IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                                       IN LONG        cWhere,
                                       IN MQDBOP      opWhere)
{
   if (!hTable)
   {
      return MQDB_E_BAD_HTABLE ;
   }

   MQDBSTATUS dbstatus ;
   CMQODBCTable *pTable = (CMQODBCTable *) hTable ;

   try
   {
      dbstatus = pTable->GetCount(puCount,
                                  pWhereColumnSearch,
                                  cWhere,
                                  opWhere) ;
   }
   catch(...)
   {
      dbstatus = MQDB_E_BAD_HTABLE ;
   }

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBInsertRecord(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN OUT LPMQDBHANDLE  lphInsert)
{
	TrTRACE(GENERAL, "In MQDBInsertRecord");

   if (cColumns <= 0) {
      return MQDB_E_BAD_CCOLUMNS ;
   }

   CMQODBCTable *pTable = (CMQODBCTable *) hTable ;
   MQDBSTATUS dbstatus ;

	// Guard against illegal handles and bad pointers.
   try
   {
      if (!lphInsert) {
         // Direct execution. Preparation not needed.
         dbstatus = pTable->DirectInsertExec(  aColumnVal,
                                               cColumns) ;
      }
      else if (!(*lphInsert)) {
         // Prepare for future use and execute.
         dbstatus = pTable->PrepareInsert(  aColumnVal,
                                            cColumns) ;
         if (dbstatus == MQDB_OK) {
	         CMQDBOdbcSTMT *pStatement = pTable->GetInsertStmt() ;
	         ASSERT(pStatement) ;
            dbstatus = pTable->ExecuteInsert(  pStatement,
                                               aColumnVal,
                                               cColumns) ;
            if (dbstatus == MQDB_OK) {
               *lphInsert = (MQDBHANDLE) pStatement ;
            }
            else {
               // Could not execute the prepare insert.
               // Delete the prepared statement.
               pTable->DeletePreparedInsert() ;
            }
         }
      }
      else {
         // Use prepared statement. Bind and execute.
         dbstatus = pTable->ExecuteInsert( (CMQDBOdbcSTMT *)(*lphInsert),
                                            aColumnVal,
                                            cColumns) ;
      }
   }
	catch(...)
   {
      dbstatus = MQDB_E_BAD_HTABLE ;
   }

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBUpdateRecord(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition,
                     IN OUT LPMQDBHANDLE  lphUpdate)
{
	TrTRACE(GENERAL, "In MQDBUpdateRecord");

   MQDBSTATUS dbstatus ;

	// Guard against illegal handles and bad pointers.
   try
   {
      CMQODBCTable *pTable = (CMQODBCTable *) hTable ;
      dbstatus = pTable->UpdateRecord(  aColumnVal,
                                        cColumns,
                                        pWhereColumnSearch,
                                        lpszSearchCondition,
                                        1,
                                        AND,
                                        lphUpdate) ;
   }
	catch(...)
   {
      dbstatus = MQDB_E_BAD_HTABLE ;
   }

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBUpdateRecordEx(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere,
                     IN OUT LPMQDBHANDLE  lphUpdate)
{
	TrTRACE(GENERAL, "In MQDBUpdateRecordEx");

   MQDBSTATUS dbstatus ;

	// Guard against illegal handles and bad pointers.
   try
   {
      CMQODBCTable *pTable = (CMQODBCTable *) hTable ;
      dbstatus = pTable->UpdateRecord(  aColumnVal,
                                        cColumns,
                                        pWhereColumnSearch,
                                        NULL,
                                        cWhere,
                                        opWhere,
                                        lphUpdate) ;
   }
	catch(...)
   {
      dbstatus = MQDB_E_BAD_HTABLE ;
   }

   return dbstatus ;
}

MQDBSTATUS APIENTRY  MQDBDeleteRecordEx(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere)
{
	TrTRACE(GENERAL, "In MQDBDeleteRecordEx");

   MQDBSTATUS dbstatus ;

	// Guard against illegal handles and bad pointers.
   try
   {
      CMQODBCTable *pTable = (CMQODBCTable *) hTable ;
      dbstatus = pTable->DeleteRecord( pWhereColumnSearch,
                                       NULL,
                                       cWhere,
                                       opWhere) ;
   }
	catch(...)
   {
      dbstatus = MQDB_E_BAD_HTABLE ;
   }

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBDeleteRecord(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition)
{
	TrTRACE(GENERAL, "In MQDBDeleteRecord");

   MQDBSTATUS dbstatus ;

	// Guard against illegal handles and bad pointers.
   try
   {
      CMQODBCTable *pTable = (CMQODBCTable *) hTable ;
      dbstatus = pTable->DeleteRecord( pWhereColumnSearch,
                                       lpszSearchCondition,
                                       1,
                                       AND) ;
   }
	catch(...)
   {
      dbstatus = MQDB_E_BAD_HTABLE ;
   }

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBOpenQuery(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition,
                     IN LPMQDBSEARCHORDER lpOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout)
{
	TrTRACE(GENERAL, "In MQDBOpenQuery");

   MQDBSTATUS dbstatus ;
	// Guard against illegal handles and bad pointers.
   try
   {
      dbstatus = ((CMQODBCTable *) hTable)->OpenQuery(
                                    aColumnVal,
                                    cColumns,
                                    pWhereColumnSearch,
                                    lpszSearchCondition,
                                    1,
                                    AND,
                                    lpOrder,
                                    cOrders,
                                    phQuery,
                                    fGetFirst,
                                    dwTimeout ) ;
   }
	catch(...)
   {
      dbstatus = MQDB_E_BAD_HTABLE ;
   }

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBOpenQueryEx(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere,
                     IN LPMQDBSEARCHORDER lpOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout)
{
	TrTRACE(GENERAL, "In MQDBOpenQueryEx");

   MQDBSTATUS dbstatus ;
	// Guard against illegal handles and bad pointers.
   try
   {
      dbstatus = ((CMQODBCTable *) hTable)->OpenQuery(
                                    aColumnVal,
                                    cColumns,
                                    pWhereColumnSearch,
                                    NULL,
                                    cWhere,
                                    opWhere,
                                    lpOrder,
                                    cOrders,
                                    phQuery,
                                    fGetFirst,
                                    dwTimeout ) ;
   }
	catch(...)
   {
      dbstatus = MQDB_E_BAD_HTABLE ;
   }

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBGetData(
                     IN MQDBHANDLE     hQuery,
                     IN MQDBCOLUMNVAL  aColumnVal[])
{
	TrTRACE(GENERAL, "In MQDBGetData");

   MQDBSTATUS dbstatus ;
   try
   {
	   CMQDBOdbcSTMT *pStatement = (CMQDBOdbcSTMT *) hQuery ;
      dbstatus = pStatement->RetrieveRecordData( aColumnVal ) ;
   }
	catch(...)
   {
      dbstatus = MQDB_E_BAD_HQUERY ;
   }
   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBCloseQuery(
                     IN MQDBHANDLE     hQuery)
{
	TrTRACE(GENERAL, "In MQDBCloseQuery");

   try
   {
	   CMQDBOdbcSTMT *pStatement = (CMQDBOdbcSTMT *) hQuery ;
      delete pStatement ;
      return MQDB_OK ;
   }
	catch(...)
   {
      return MQDB_E_BAD_HQUERY ;
   }
}


MQDBSTATUS APIENTRY  MQDBOpenJoinQuery(
                     IN MQDBHANDLE        hDatabase,
                     IN LPSTR             lpszLeftTableName,
                     IN LPSTR             lpszRightTableName,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cLefts,
                     IN LONG              cRights,
                     IN LPMQDBJOINOP      opJoin,
                     IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                     IN LONG              cWhereLeft,
                     IN LONG              cWhereRight,
                     IN MQDBOP            opWhere,
                     IN LPMQDBSEARCHORDER pOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout)
{
	TrTRACE(GENERAL,"In MQDBOpenJoinQuery");

   MQDBSTATUS dbstatus ;
   CMQODBCTable * pTable ;

   try
   {
      pTable = new CMQODBCTable( hDatabase ) ;
      ASSERT(pTable) ;
      P<CMQODBCTable> p(pTable) ; // AutoDelete pointer.

      dbstatus = pTable->OpenJoin(  hDatabase,
                                    lpszLeftTableName,
                                    lpszRightTableName,
                                    aColumnVal,
                                    cLefts,
                                    cRights,
                                    opJoin,
                                    pWhereColumnSearch,
                                    cWhereLeft,
                                    cWhereRight,
                                    opWhere,
                                    pOrder,
                                    cOrders,
                                    phQuery,
                                    fGetFirst,
                                    dwTimeout ) ;
   }
   catch(...)
   {
      dbstatus = MQDB_E_INVALID_DATA ;
   }
   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBOpenAggrQuery(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN MQDBAGGR          mqdbAggr,
                     IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere,
                     IN DWORD             dwTimeout)
{
    TrTRACE(GENERAL, "In MQDBOpenAggrQuery");

    MQDBSTATUS dbstatus ;
     // Guard against illegal handles and bad pointers.
    try
    {
       dbstatus = ((CMQODBCTable *) hTable)->OpenAggrQuery(
                                        aColumnVal,
                                        mqdbAggr,
                                        pWhereColumnSearch,
                                        NULL,
                                        cWhere,
                                        opWhere,
                                        dwTimeout ) ;
    }
	catch(...)
    {
       dbstatus = MQDB_E_BAD_HTABLE ;
    }

    return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBTransaction(
                     IN  MQDBHANDLE     hDatabase,
                     IN  MQDBTRANSACOP  mqdbTransac)
{
	TrTRACE(GENERAL, "In MQDBTransaction");

   CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) hDatabase ;
   MQDBSTATUS dbstatus ;

	// Guard against illegal handles and bad pointers.
	try
	{
      dbstatus = pDatabase->Transaction( mqdbTransac) ;
   }
	catch(...)
	{
      dbstatus = MQDB_E_BAD_HDATABASE ;
	}

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBFreeBuf( IN LPVOID lpMem )
{
	TrTRACE(GENERAL, "In MQDBFreeBuf");

   MQDBSTATUS dbstatus = MQDB_OK ;
	// Guard against bad pointers.
	try
	{
      delete lpMem ;
   }
	catch(...)
	{
      dbstatus = MQDB_E_INVALID_DATA ;
	}

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBEscape(
                     IN MQDBHANDLE     hDatabase,
                     IN LPSTR          lpszCommand )
{
	TrTRACE(GENERAL, "In MQDBEscape");

   CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) hDatabase ;
   MQDBSTATUS dbstatus ;

	// Guard against illegal handles and bad pointers.
	try
	{
      dbstatus = pDatabase->Escape( lpszCommand ) ;
   }
	catch(...)
	{
      dbstatus = MQDB_E_BAD_HDATABASE ;
	}

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBSetOption(
                     IN MQDBHANDLE     hDatabase,
                     IN MQDBOPTION     mqdbOption,
                     IN DWORD          dwValue,
                     IN LPSTR          lpszValue,
                     IN MQDBHANDLE     hQuery )
{
	TrTRACE(GENERAL, "In MQDBSetOption");

   CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) hDatabase ;
   MQDBSTATUS dbstatus ;

	// Guard against illegal handles and bad pointers.
	try
	{
      switch(mqdbOption)
      {
         case MQDBOPT_MULTIPLE_QUERIES:
            ASSERT(lpszValue == NULL) ;
            dbstatus = pDatabase->SetMultipleQueries( (BOOL) dwValue ) ;
            break ;

         case MQDBOPT_NOLOCK_QUERIES:
            ASSERT(lpszValue == NULL) ;
            dbstatus = pDatabase->SetNoLockQueries( (BOOL) dwValue ) ;
            break ;

         case MQDBOPT_INSERT_IDENTITY:
            ASSERT(lpszValue) ;
            char buff[512] ;
            lstrcpyA(buff, "set identity_insert ") ;
            lstrcatA(buff, lpszValue) ;
            if (dwValue)
            {
               lstrcatA(buff, " on") ;
            }
            else
            {
               lstrcatA(buff, " off") ;
            }
            dbstatus = MQDBEscape( hDatabase,
                                   buff ) ;
            break ;

         case MQDBOPT_QUERY_TIMEOUT:
         {
            ASSERT( hQuery ) ;
      	   CMQDBOdbcSTMT *pStatement = (CMQDBOdbcSTMT *) hQuery ;
            dbstatus = pStatement->SetQueryTimeout( dwValue ) ;
         }
            break ;

         default:
            dbstatus = MQDB_E_INVALID_DATA ;
            break ;
      }
   }
	catch(...)
	{
      dbstatus = MQDB_E_BAD_HDATABASE ;
	}

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBExecute(
                     IN MQDBHANDLE     hDatabase,
                     IN MQDBHANDLE     hTable,
                     IN MQDBEXEC       ExecOp,
                     IN OUT DWORD      *pdwValue,
                     IN LPSTR          lpszValue )
{
    UNREFERENCED_PARAMETER(lpszValue);
	TrTRACE(GENERAL, "In MQDBExecute");

   MQDBSTATUS dbstatus ;

	// Guard against illegal handles and bad pointers.
   //
	try
	{
      switch(ExecOp)
      {
         case MQDBEXEC_UPDATE_STATISTICS:
         {
            CMQODBCTable *pTable = (CMQODBCTable *) hTable ;
            dbstatus = pTable->UpdateStatistics() ;
            break ;
         }

         case MQDBEXEC_SPACE_USED:
         {
            //
            // On input, *pdwSize should be null if DBCC update is not
            // required. Else dbcc will be performed.
            //
            CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) hDatabase ;
            dbstatus = pDatabase->GetSize( pdwValue ) ;
            break ;
         }

         default:
            dbstatus = MQDB_E_INVALID_DATA ;
            break ;
      }
   }
	catch(...)
	{
      dbstatus = MQDB_E_BAD_HDATABASE ;
	}

   return dbstatus ;
}


MQDBSTATUS APIENTRY  MQDBTruncateTable(
                     IN MQDBHANDLE        hTable)
{
	TrTRACE(GENERAL, "In MQDBTruncateTable");

   MQDBSTATUS dbstatus ;

	// Guard against illegal handles and bad pointers.
   try
   {
      CMQODBCTable *pTable = (CMQODBCTable *) hTable ;
      dbstatus = pTable->Truncate() ;
   }
	catch(...)
   {
      dbstatus = MQDB_E_BAD_HTABLE ;
   }

   return dbstatus ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqdbodbc\dbodbc.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		dbodbc.cpp

Abstract:
   Implement the database class for use with ODBC drivers.

Author:
	Doron Juster (DoronJ)

Revisions:
   NirB          1995      Create first version, under different name.
   DoronJ      09-Jan-96   Adapted and updated for the mqdbmgr dll.

--*/

#include "dbsys.h"
#include "dbodbc.h"
#include "odbcstmt.h"
#include "odbcss.h"  // SQL server specific

#include "dbodbc.tmh"

// Constructor
CMQODBCDataBase::CMQODBCDataBase()
							: m_hConnection(SQL_NULL_HDBC),
							  m_fConnected(FALSE),
                       m_dwDMBSType(MQDBMSTYPE_UNKNOWN),
                       m_fEnableMultipleQueries(FALSE),
                       m_fNoLockQueries(FALSE),
                       m_SQLConformance(0)
{
#ifdef _DEBUG
   m_OutstandingTransactions = 0 ;
#endif
}

// Destructor
CMQODBCDataBase::~CMQODBCDataBase()
{
   ASSERT(m_OutstandingTransactions == 0) ;
}

// Connect to the data source. If necessary, create a new database.
MQDBSTATUS CMQODBCDataBase::Connect(LPMQDBOPENDATABASE pOpen)
{
   RETCODE sqlstatus	= SQL_SUCCESS;
   MQDBSTATUS dbstatus = MQDB_OK ;

   //
   // See if ODBC driver manager recognize the DSN name.
   //
   UWORD uDirection = SQL_FETCH_FIRST ;
   do
   {
      UCHAR szDSNDescription[ 256 ] ;
      UCHAR szDSNName[ SQL_MAX_DSN_LENGTH ] ;
      SWORD cDSNName ;
      SWORD cDSNDesc ;

      sqlstatus = SQLDataSources( g_hEnv,
                                  uDirection,
                                  szDSNName,
                                  SQL_MAX_DSN_LENGTH,
                                  &cDSNName,
                                  szDSNDescription,
                                  256,
                                  &cDSNDesc ) ;

      if ((sqlstatus == SQL_SUCCESS) &&
          (lstrcmpiA(pOpen->lpszDatabaseName, (char *) szDSNName) == 0))
      {
         if (lstrcmpiA("SQL Server", (char *) szDSNDescription) == 0)
         {
            m_dwDMBSType = MQDBMSTYPE_SQLSERVER ;
         }
         else
         {
            //
            // At present we support only SQL server.
            //
#ifdef _DEBUG
            WCHAR wDesc[128] ;
            MultiByteToWideChar( CP_ACP,
                                 0,
                                 (char *)szDSNDescription,
                                 -1,
                                 wDesc,
                                 128 ) ;
            TrWARNING(GENERAL, "MQDBMGR: Found MQIS on  %ls", wDesc);
            ASSERT(0) ;
#endif
         }
         break ;
      }
      uDirection = SQL_FETCH_NEXT ;
   } while (sqlstatus == SQL_SUCCESS) ;

   //
	// Allocate an ODBC connection handle
   //
	sqlstatus = ::SQLAllocConnect(
							g_hEnv,
							&m_hConnection);
	if (!ODBC_SUCCESS(sqlstatus))
		goto checkerror ;

	// Enable read and write
	sqlstatus = ::SQLSetConnectOption(
							m_hConnection,
							SQL_ACCESS_MODE,
							SQL_MODE_READ_WRITE);
	if (!ODBC_SUCCESS(sqlstatus))
		goto checkerror ;

	// Enable Auto commit.
	sqlstatus = ::SQLSetConnectOption(
							m_hConnection,
							SQL_AUTOCOMMIT,
							SQL_AUTOCOMMIT_ON);
	if (!ODBC_SUCCESS(sqlstatus))
		goto checkerror ;

   //
   //  Set security option. This option is relevant only for SQL server.
   //  Must be set before doing the connection.
   //
   if (m_dwDMBSType == MQDBMSTYPE_SQLSERVER)
   {
      sqlstatus = ::SQLSetConnectOption(
			            				m_hConnection,
                                 SQL_INTEGRATED_SECURITY,
                                 SQL_IS_ON ) ;
      if (!ODBC_SUCCESS(sqlstatus))
         goto checkerror ;
   }

	//
	// Connect to the data source
	//
	sqlstatus = ::SQLConnect(
						m_hConnection,
						(UCHAR *) pOpen->lpszDatabaseName,
						SQL_NTS,
						(UCHAR *) pOpen->lpszUserName,
						SQL_NTS,
						(UCHAR *) pOpen->lpszPassword,
						SQL_NTS);

   if (ODBC_SUCCESS_WINFO(sqlstatus))
   {
		if (OdbcStateIs(m_hConnection,
                      SQL_NULL_HSTMT,
                      OERR_GENERAL_WARNING))
      {
         //
         // This happen with SQL server. It tells that context was
         // changed to falcon. It's a success.
         //
         sqlstatus = SQL_SUCCESS ;
      }
   }

	if (!ODBC_SUCCESS(sqlstatus))
	{
      //
		// If the error is not "data source not found", terminate
      //
		if (!OdbcStateIs(m_hConnection,
                       SQL_NULL_HSTMT,
                       OERR_DSN_NOT_FOUND))
   		goto checkerror ;

      if (!pOpen->fCreate)
      {
         //
         // If database not found and caller don't want to create it
         // then leave.
         //
         return  MQDB_E_DB_NOT_FOUND ;
      }

      //
      // We can't create an SQL server database.
      //
      ASSERT(!pOpen->fCreate) ;
      return  MQDB_E_DB_NOT_FOUND ;
	}
	m_fConnected = TRUE ;

   //
   // Determine SQL conformance
   //
   SWORD swDummy ;
   sqlstatus = ::SQLGetInfo( m_hConnection,
                             SQL_ODBC_SQL_CONFORMANCE,
                             (PTR) &m_SQLConformance,
                             sizeof(m_SQLConformance),
                             &swDummy) ;
	if (!ODBC_SUCCESS(sqlstatus))
      goto checkerror ;

   ASSERT(!(m_SQLConformance & 0x0ffff0000)) ; // it's a 16bit value.

   // Find the data-source specific names for data types.
   int index ;
   for ( index = 0 ; index < MQDB_ODBC_NUMOF_TYPES ; index++ )
   {
      sqlstatus = GetDataTypeName(
   						m_hConnection,
                     dbODBCSQLTypes[ index ],
	                  m_szNameOfTypes[ index ],
	                  (SDWORD) MQDB_TYPE_NAME_LEN) ;
	   if (!ODBC_SUCCESS(sqlstatus))
         goto checkerror ;
   }

   if (m_dwDMBSType == MQDBMSTYPE_SQLSERVER)
   {
      //
      // Set prepared statement option. Relevant for SQL server only.
      //
      sqlstatus = ::SQLSetConnectOption(
		            				m_hConnection,
                              SQL_USE_PROCEDURE_FOR_PREPARE,
                              SQL_UP_ON_DROP ) ;
      if (!ODBC_SUCCESS(sqlstatus))
         goto checkerror ;
   }

   //
   // Check SQL version. Falcon can't run on SQL6.5 SP2 (build 240).
   //
   MQDBVERSION  dbVersion ;
   dbstatus = GetVersion( &dbVersion) ;
   if (dbstatus == MQDB_OK)
   {
      LPSTR lpVer = strchr(dbVersion.szDBMSVer, '6') ;
      if (lpVer)
      {
         if (!lstrcmpA(lpVer, "6.50.0240"))
         {
            dbstatus =  MQDB_E_UNSUPPORTED_DBMS ;
         }
      }
   }
   else
   {
      ASSERT(dbstatus == MQDB_OK) ;
      dbstatus = MQDB_OK ;   // this is not a major problem.
   }

#ifdef _DEBUG
   //
   // Print version of database.
   // For beta1, assert it's SQL server.
   //
   if ((dbstatus == MQDB_OK)  ||
       (dbstatus == MQDB_E_UNSUPPORTED_DBMS))
   {
      int icmp = lstrcmpA(dbVersion.szDBMSName, "Microsoft SQL Server") ;
      ASSERT(icmp == 0) ; // at present we support only SQL server.
      ASSERT(m_dwDMBSType == MQDBMSTYPE_SQLSERVER) ;

      WCHAR wName[128] ;
      WCHAR wVer[128] ;
      MultiByteToWideChar( CP_ACP,
                           0,
                           dbVersion.szDBMSName,
                           -1,
                           wName,
                           128 ) ;
      MultiByteToWideChar( CP_ACP,
                           0,
                           dbVersion.szDBMSVer,
                           -1,
                           wVer,
                           128 ) ;

	   TrTRACE(GENERAL, "Connect to database: %ls, Version %ls", wName, wVer);
   }
#endif

   return dbstatus ;

checkerror:
   if (m_hConnection != SQL_NULL_HDBC)
   {
      if (OdbcStateIs( m_hConnection, SQL_NULL_HSTMT, OERR_DBMS_NOT_AVAILABLE))
      {
         dbstatus = MQDB_E_DBMS_NOT_AVAILABLE ;
      }
   }
   if (dbstatus == MQDB_OK)
   {
      dbstatus = MQDB_E_DATABASE ;
   }

   return dbstatus ;
}


// Disconnect from the data source.
MQDBSTATUS CMQODBCDataBase::Disconnect()
{
   RETCODE sqlstatus	= SQL_SUCCESS;
   MQDBSTATUS  dbstatus = MQDB_OK ;

	// Free connection
	if (m_hConnection != SQL_NULL_HDBC) {
		// Disconect
		if (m_fConnected) {
			sqlstatus = ::SQLDisconnect(m_hConnection);
			if (!ODBC_SUCCESS(sqlstatus)) {
				dbstatus = MQDB_E_DATABASE ;
         }
         else {
			   m_fConnected = FALSE;
         }
		}

		// Free the connection handle
		sqlstatus = ::SQLFreeConnect(m_hConnection);
		if (!ODBC_SUCCESS(sqlstatus)) {
			dbstatus = MQDB_E_DATABASE ;
      }
      else {
		   m_hConnection = SQL_NULL_HDBC;
      }
	}

   return dbstatus ;
}

MQDBSTATUS CMQODBCDataBase::GetVersion( IN LPMQDBVERSION  pVersion)
{
   RETCODE sqlstatus ;
   SWORD dwSize ;
   MQDBSTATUS dbstatus = MQDB_OK ;

   // Get the DBMS name
   sqlstatus = ::SQLGetInfo( m_hConnection,
                             SQL_DBMS_NAME,
                             pVersion->szDBMSName,
                             MQDB_VERSION_STRING_LEN,
                             &dwSize ) ;
   if (!ODBC_SUCCESS(sqlstatus))
   {
      OdbcStateIs( m_hConnection, SQL_NULL_HSTMT, OERR_GENERAL_WARNING) ;
      dbstatus = MQDB_E_DATABASE ;
   }
   else
   {
      ASSERT(dwSize < (SWORD) MQDB_VERSION_STRING_LEN) ;
   }

   // Get the DBMS version
   sqlstatus = ::SQLGetInfo( m_hConnection,
                             SQL_DBMS_VER,
                             pVersion->szDBMSVer,
                             MQDB_VERSION_STRING_LEN,
                             &dwSize ) ;
   if (!ODBC_SUCCESS(sqlstatus))
   {
      OdbcStateIs( m_hConnection, SQL_NULL_HSTMT, OERR_GENERAL_WARNING) ;
      dbstatus = MQDB_E_DATABASE ;
   }
   else
   {
      ASSERT(dwSize < (SWORD) MQDB_VERSION_STRING_LEN) ;
   }

   return dbstatus ;
}

// Handle transaction
MQDBSTATUS CMQODBCDataBase::Transaction(IN MQDBTRANSACOP mqdbTransac)
{
   RETCODE     sqlstatus = SQL_SUCCESS ;
   MQDBSTATUS  dbstatus = MQDB_OK ;

   switch (mqdbTransac) {
      case AUTO:
      {
     	   // Enable Auto commit.
	   	sqlstatus = ::SQLSetConnectOption(
			   					m_hConnection,
				   				SQL_AUTOCOMMIT,
					   			SQL_AUTOCOMMIT_ON);
         break ;
      }

      case BEGIN:
      {
     	   // Enable manual transaction mode.
	   	sqlstatus = ::SQLSetConnectOption(
			   					m_hConnection,
				   				SQL_AUTOCOMMIT,
					   			SQL_AUTOCOMMIT_OFF);
#ifdef _DEBUG
         m_OutstandingTransactions++ ;
         ASSERT(m_OutstandingTransactions <= 2) ;
#endif
         break ;
      }

      case COMMIT:
      {
         sqlstatus = ::SQLTransact(g_hEnv, m_hConnection, SQL_COMMIT) ;
#ifdef _DEBUG
         m_OutstandingTransactions-- ;
#endif
         break ;
      }

      case ROLLBACK:
      {
         sqlstatus = ::SQLTransact(g_hEnv, m_hConnection, SQL_ROLLBACK) ;
#ifdef _DEBUG
         m_OutstandingTransactions-- ;
#endif
         break ;
      }

      default:
      {
         dbstatus = MQDB_E_INVALID_DATA ;
         break ;
      }
   }

   if (!ODBC_SUCCESS(sqlstatus))
   {
      dbstatus = CheckSqlStatus( sqlstatus,
	                              NULL ) ;
   }
   return dbstatus ;
}

//
// Create a meaningfull error code.
//
MQDBSTATUS CMQODBCDataBase::GetDBStatus( IN SDWORD  sdwNativeError,
                                         IN UCHAR   *pSqlError )
{
   MQDBSTATUS dbstatus = MQDB_E_DATABASE ;

   if ( lstrcmpiA(OERR_DBMS_NOT_AVAILABLE, (char*)pSqlError) == 0 )
   {
      dbstatus = MQDB_E_DBMS_NOT_AVAILABLE ;
   }
   else if ( m_dwDMBSType == MQDBMSTYPE_SQLSERVER )
   {
      //
      // DBMS type: Microsoft SQL Server.
      //
      if ( lstrcmpiA( (char *) pSqlError, OERR_SQL_SYNTAX_ERROR ) == 0 )
      {
         //
         //  Syntax errors
         //
         switch ( sdwNativeError )
         {
            case SERR_MSSQL_NONUNIQUESORT:
               dbstatus = MQDB_E_NON_UNIQUE_SORT ;
               break ;

            case SERR_MSSQL_TABLE_IS_FULL:
               dbstatus = MQDB_E_TABLE_FULL ;
               break ;

            default:
               break ;
         }
      }
      else if ( lstrcmpiA( (char *) pSqlError, OERR_GENERAL_WARNING ) == 0 )
      {
         //
         //  General warnings
         //
         switch ( sdwNativeError )
         {
            case SERR_MSSQL_NOT_AVAILABLE:
               dbstatus = MQDB_E_DBMS_NOT_AVAILABLE ;
               break ;

            default:
               break ;
         }
      }
      else if ( lstrcmpiA( (char *) pSqlError, OERR_INVALID_STATE ) == 0 )
      {
         //
         // State errors. Operations done when database in wrong state.
         //
         switch ( sdwNativeError )
         {
            case SERR_MSSQL_READ_ONLY:
               dbstatus = MQDB_E_DB_READ_ONLY ;
               break ;

            default:
               break ;
         }
      }
      else if ( lstrcmpiA( (char *) pSqlError, OERR_SERIALIZATION ) == 0 )
      {
         //
         // Serialization / deadlock errors.
         //
         switch ( sdwNativeError )
         {
            case SERR_MSSQL_DEADLOCK:
               dbstatus = MQDB_E_DEADLOCK ;
               break ;

            default:
               break ;
         }
      }
   }

   return dbstatus ;
}

MQDBSTATUS CMQODBCDataBase::CheckSqlStatus(
                             IN RETCODE        sqlError,
	                          IN CMQDBOdbcSTMT  *pStatement,
                             IN HSTMT          hStmtIn /* SQL_NULL_HSTMT */ )
{
   MQDBSTATUS dbstatus = MQDB_OK ;

   if (!ODBC_SUCCESS(sqlError))
   {
      SDWORD  sdwNativeError ;
      UCHAR   szSqlState[ SQLSTATELEN ] ;

      HSTMT hStmt = hStmtIn ;
      if (hStmt == SQL_NULL_HSTMT)
      {
         if (pStatement)
         {
            hStmt = pStatement->GetHandle() ;
         }
      }
      else
      {
         ASSERT(!pStatement) ;
      }

      OdbcStateIsEx( m_hConnection,
                     hStmt,
                     OERR_GENERAL_WARNING,
                     &sdwNativeError,
                     szSqlState ) ;

      dbstatus = GetDBStatus( sdwNativeError, szSqlState ) ;
      ASSERT(dbstatus != MQDB_OK) ;
   }

   return dbstatus ;
}


MQDBSTATUS CMQODBCDataBase::GetSize( DWORD *pSize )
{
   MQDBSTATUS  dbstatus = MQDB_OK ;
   //
   // Create a new statement.
   //
	CMQDBOdbcSTMT *pStatement = new CMQDBOdbcSTMT( m_hConnection ) ;
   ASSERT(pStatement) ;
   P<CMQDBOdbcSTMT> p(pStatement) ; // AutoDelete pointer.

   //
   // Execute the command
   //
   if (*pSize)
   {
	   pStatement->Allocate("sp_spaceused @updateusage = 'TRUE'") ;
   }
   else
   {
	   pStatement->Allocate("sp_spaceused") ;
   }
	RETCODE sqlstatus = pStatement->Execute();

   *pSize = (DWORD) -1 ;
   if (ODBC_SUCCESS(sqlstatus) || ODBC_SUCCESS_WINFO(sqlstatus))
   {
      MQDBCOLUMNVAL  pColumns[3] ;

      for ( int cColumns = 0 ; cColumns < 3 ; cColumns++ )
      {
         INIT_COLUMNVAL(pColumns[ cColumns ]) ;
         pColumns[ cColumns ].lpszColumnName = NULL ;
         pColumns[ cColumns ].nColumnValue   = NULL ;
         pColumns[ cColumns ].nColumnLength  = 0 ;
         pColumns[ cColumns ].mqdbColumnType = MQDB_STRING ;
      }

      dbstatus = pStatement->RetrieveRecordData( pColumns, 3 ) ;

      if (dbstatus == MQDB_OK)
      {
         DWORD  dwTotalSize = 0 ;
         DWORD  dwUnusedSize = 0 ;
         _snscanf(((char *) pColumns[1].nColumnValue), pColumns[1].nColumnLength, "%lu", &dwTotalSize) ;
         _snscanf(((char *) pColumns[2].nColumnValue), pColumns[2].nColumnLength, "%lu", &dwUnusedSize) ;
         ASSERT(dwTotalSize >= dwUnusedSize) ;

         TrWARNING(GENERAL,"MQDBMGR, GetSize: total- %lu MB, unused- %lu MB", dwTotalSize, dwUnusedSize);

         if (dwTotalSize != 0)
         {
            *pSize = 100 - ((dwUnusedSize * 100) / dwTotalSize) ;
         }
         else
         {
            dbstatus = MQDB_E_BAD_SIZE_VALUE ;
         }
      }

      //
      // Free the strings.
      //
      for ( cColumns = 0 ; cColumns < 3 ; cColumns++ )
      {
         ASSERT(pColumns[ cColumns ].nColumnValue) ;
         delete ((char *) pColumns[ cColumns ].nColumnValue) ;
      }
   }
   else
   {
      dbstatus = CheckSqlStatus( sqlstatus,
	                              pStatement ) ;
   }

   return dbstatus ;
}


MQDBSTATUS CMQODBCDataBase::Escape( IN LPSTR lpszCommand )
{
   MQDBSTATUS  dbstatus = MQDB_OK ;
   //
   // Create a new statement.
   //
	CMQDBOdbcSTMT *pStatement = new CMQDBOdbcSTMT( m_hConnection ) ;
   ASSERT(pStatement) ;
   P<CMQDBOdbcSTMT> p(pStatement) ; // AutoDelete pointer.

   //
   // Execute the command
   //
	pStatement->Allocate(lpszCommand);
	RETCODE sqlstatus = pStatement->Execute();
   if (!ODBC_SUCCESS(sqlstatus))
   {
      dbstatus = CheckSqlStatus( sqlstatus,
	                              pStatement ) ;
   }
   return dbstatus ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\rptempl.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    rptempl.h

Abstract:
    Useful templates for Auto pointer and auto Release

Author:
    Erez Haba    (erezh)   11-Mar-96
    Doron Juster (DoronJ)  30-June-98

Revision History:
--*/

#ifndef _RPTEMPL_H
#define _RPTEMPL_H

//
//  return type for 'identifier::operator >' is not a UDT or reference to a UDT.
//  Will produce errors if applied using infix notation
//
#pragma warning(disable: 4284)

#include <winldap.h>
//-----------------------------
//
//  Auto relese LDAP message.
//
//-----------------------------

template<class T>
class LM {
private:
    T* m_p;

public:
    LM()     : m_p(NULL)     {}
    LM(T* p) : m_p(p)        {}
   ~LM()                     { if(m_p) ldap_msgfree(m_p) ; }

    operator T*() const     { return m_p; }
    T** operator&()         { return &m_p;}
    T* operator->() const   { return m_p; }
    LM<T>& operator=(T* p)  { m_p = p; return *this; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }
};

//-----------------------------
//
//  Auto relese LDAP Page handle.
//
//-----------------------------
class CLdapPageHandle {
private:
    PLDAPSearch	m_p;
	PLDAP		m_pLdap;

public:
    CLdapPageHandle(PLDAP pLdap) : m_p(NULL), m_pLdap(pLdap)     {}
    CLdapPageHandle(PLDAPSearch p, PLDAP pLdap)	: m_p(p), m_pLdap(pLdap) {}
    ~CLdapPageHandle()                     
    {
	   if(m_p) ldap_search_abandon_page(m_pLdap, m_p);
    }

    operator PLDAPSearch() const     { return m_p; }
	CLdapPageHandle & operator=(PLDAPSearch p)  { m_p = p; return *this; }  
};

//-----------------------------
//
//  Auto relese Handle.
//
//-----------------------------
class CServiceHandle
{
public:
    explicit CServiceHandle(SC_HANDLE h = NULL) { m_h = h; };
    ~CServiceHandle() { if (m_h) CloseServiceHandle(m_h); };

    operator SC_HANDLE() const { return m_h; };
    //CServiceHandle& operator=(SC_HANDLE h)   { m_h = h; return *this; }

private:
    //
    // Prevent copy
    //
    CServiceHandle(const CServiceHandle & );
    CServiceHandle& operator=(const CServiceHandle &);

private:
    SC_HANDLE m_h;

}; //CServiceHandle

#endif // _RPTEMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqdbodbc\dbsys.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
		dbsys.h

Abstract:
	"General purpose" definitions for the Database interface dll.

Author:
	Doron Juster (DoronJ)

Revisions:
   9-jan-96   DoronJ    Created
--*/

#ifndef __DBSYS_H__
#define __DBSYS_H__

// Include the system specific definition files

#include <_stdh.h>

#ifndef PURE
#define PURE  =0
#endif

//
//  don't use SQL A and W exports
//
#define SQL_NOUNICODEMAP

#include "mqdbmgr.h"

#endif // __DBSYS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqdbodbc\dbodbc.h ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		dbodbc.h

Abstract:
   Define a database class, for use with ODBC drivers.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      09-Jan-96   Created

--*/

#ifndef __DBODBC_H__
#define __DBODBC_H__

#include "mqdbodbc.h"
#include "tblodbc.h"

class CMQODBCDataBase
{
public:
   CMQODBCDataBase() ;   // Constructor.
   ~CMQODBCDataBase() ;  // Destructor.

   MQDBSTATUS Connect(LPMQDBOPENDATABASE pOpen) ;
   MQDBSTATUS Disconnect() ;

   MQDBSTATUS GetVersion( IN LPMQDBVERSION  pVersion) ;

   MQDBSTATUS Transaction( IN MQDBTRANSACOP mqdbTransac) ;

   MQDBSTATUS GetSize( DWORD *pSize ) ;

   inline MQDBSTATUS SetMultipleQueries( IN BOOL fEnable )
      {
         m_fEnableMultipleQueries = fEnable ;
         return MQDB_OK ;
      }

   inline MQDBSTATUS SetNoLockQueries( IN BOOL fEnable )
      {
         m_fNoLockQueries = fEnable ;
         return MQDB_OK ;
      }

   inline BOOL  GetMultipleQueriesState( ) const
      {
         return m_fEnableMultipleQueries ;
      }

   inline BOOL  GetNoLockQueriesState( ) const
      {
         return m_fNoLockQueries ;
      }

   inline DWORD GetDMBSType( ) const
      {
         return m_dwDMBSType ;
      }

   MQDBSTATUS  GetDBStatus( IN SDWORD  sdwNativeError,
                            IN UCHAR   *pSqlError ) ;

   MQDBSTATUS  CheckSqlStatus( IN RETCODE        sqlError,
	                            IN CMQDBOdbcSTMT  *pStatement,
                               IN HSTMT          hStmt = SQL_NULL_HSTMT ) ;

   MQDBSTATUS  Escape( IN LPSTR lpszCommand ) ;

protected:
   HDBC  GethDbc() { return m_hConnection ; }

   friend MQDBSTATUS CMQODBCTable::Init(IN MQDBHANDLE hDatabase,
                                        IN LPSTR      lpszTableName) ;

   friend MQDBSTATUS CMQODBCTable::OpenJoin(
                     IN MQDBHANDLE        hDatabase,
                     IN LPSTR             lpszLeftTableName,
                     IN LPSTR             lpszRightTableName,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cLefts,
                     IN LONG              cRights,
                     IN LPMQDBJOINOP      opJoin,
                     IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                     IN LONG              cWhereLeft,
                     IN LONG              cWhereRight,
                     IN MQDBOP            opWhere,
                     IN LPMQDBSEARCHORDER pOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout) ;

private:
   DWORD    m_SQLConformance ;
	HDBC		m_hConnection;	 // Connection handle
	BOOL		m_fConnected;   // TRUE if connection to Data source succeeded

	char     m_szNameOfTypes[ MQDB_ODBC_NUMOF_TYPES][ MQDB_TYPE_NAME_LEN ] ;
                                       // Holds the name of data types.
   DWORD    m_dwDMBSType ;

   BOOL     m_fEnableMultipleQueries ;
    //
    // If TRUE, then multiple parallel queries are enabled. Important when
    // working with SQL server. If enabled, then statement options must be
    // properly set. FALSE by default.

   BOOL     m_fNoLockQueries ;
    //
    //  If TRUE, then query are done in "nolock" mode and this enable
    //  more concurency.

#ifdef _DEBUG
   int      m_OutstandingTransactions ;
      // Count number of outstanding transactions (transctions which
      // started but didn't yet commited or rollbacked).
#endif
} ;

#endif // __DBODBC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqdbodbc\mqdbodbc.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
		mqdbodbc.h

Abstract:
   ODBC related stuff.
   Define whatever is necessary for using ODBC.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      10-Jan-96   Created

--*/

#include "sqlext.h"

///////////////////////////////////////////////
//
//  Types of database managers
//
///////////////////////////////////////////////

#define  MQDBMSTYPE_UNKNOWN     1
#define  MQDBMSTYPE_SQLSERVER   2

///////////////////////////////////////////////
//
// Information returned in SQLError
//
///////////////////////////////////////////////

#define OERR_DSN_NOT_FOUND				"IM002"
#define OERR_TABLE_ALREADY_EXISTS	"S0001"
#define OERR_INDEX_ALREADY_EXISTS	"S0011"
#define OERR_CONSTRAINT_PROBLEM		"23000"
#define OERR_GENERAL_WARNING        "01000"
#define OERR_SQL_OPTION_CHANGED     "01S02"
#define OERR_SQL_SYNTAX_ERROR       "37000"
#define OERR_DBMS_NOT_AVAILABLE     "08S01"
#define OERR_INVALID_STATE          "25000"
#define OERR_SERIALIZATION          "40001"

#define ODBC_SUCCESS(s)       (s == SQL_SUCCESS)
#define ODBC_SUCCESS_WINFO(s) (s == SQL_SUCCESS_WITH_INFO)

#define  SQLSTATELEN   6   // Length of SQLSTATE string (including NULL).

///////////////////////////////////////////////
//
//  Specific DBMS errors
//
///////////////////////////////////////////////

#define  SERR_MSSQL_NONUNIQUESORT   169
#define  SERR_MSSQL_TABLE_IS_FULL   0x451
#define  SERR_MSSQL_READ_ONLY       3906
#define  SERR_MSSQL_NOT_AVAILABLE   230
#define  SERR_MSSQL_DEADLOCK        1205

///////////////////////////////////////////////
//
//  Data structures to handle SQL datatypes.
//  Defined and initialized in odbcdata.cpp.
//
///////////////////////////////////////////////

#define MQDB_ODBC_NUMOF_TYPES  8
#define MQDB_TYPE_NAME_LEN    32

#if (MQDB_ODBC_NUMOF_TYPES != MQDB_NUMOF_TYPES)
#error "mismatch in number of types"
#endif

// Best fit of our database column types to ODBC SQL types.
//
extern SWORD  dbODBCSQLTypes[] ;

// Precision of each type.
//
extern UDWORD dbODBCPrecision[] ;

// strings for operation names.
//
#define MQDB_ODBC_NUMOF_OPS  8
extern LPSTR dbODBCOpNameStr[] ;

// strings for ordering operation names.
//
#define MQDB_ODBC_NUMOF_ORDER_OP  2
extern LPSTR dbODBCOrderNameStr[] ;

// strings for aggregate operation names.
//
#define MQDB_ODBC_NUMOF_AGGR_OP  3
extern LPSTR dbODBCAggrNameStr[] ;

/////////////////////////////////////////
//
// Prototype of internal functions.
//
/////////////////////////////////////////

BOOL OdbcStateIs(
               IN    HDBC        hDbc,
               IN    HSTMT       hStmt,
					IN		char *		szStateToBeChecked) ;

BOOL OdbcStateIsEx(
               IN    HDBC        hDbc,
               IN    HSTMT       hStmt,
					IN		char *		szStateToBeChecked,
 				   IN    SDWORD *    pdwNativeError,
               IN    UCHAR *     pszSqlState) ;

RETCODE GetDataTypeName(
               IN    HDBC     hDbc,
					IN		SWORD  	swType,
					OUT	char *	szBuffer,
					IN		SDWORD   dwBuffSize) ;

MQDBSTATUS  FormatColumnData( IN LPSTR          szTmpBuff,
                              IN MQDBCOLUMNVAL  *pColumnVal) ;

BOOL  PrepareColumnNames( IN MQDBCOLUMNVAL     aColumnVal[],
                          IN LONG              cColumns,
                          IN OUT LPSTR         lpBuffer) ;

BOOL TypeMustBind( IN MQDBCOLUMNTYPE type ) ;

BOOL  FormatWhereString( IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                         IN OUT LPSTR         lpszBuf) ;

BOOL  FormatOpWhereString( IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                           IN DWORD             cWhere,
                           IN MQDBOP            opWhere,
                           IN OUT LPSTR         lpszBuf) ;
////////////////////////
//
// Some useful macros.
//
////////////////////////

#define  DECLARE_BUFFER(bufname,bufsize)           \
   char bufname[ bufsize ] ;                       \
   bufname[ 0 ] = '\0' ;                           \
   bufname[ bufsize - 1 ] = '\0' ;                 \
   bufname[ bufsize - 2 ] = '\0' ;

#define  VERIFY_BUFFER(bufname,bufsize)            \
   if ((bufname[ bufsize - 1 ] != '\0') ||         \
       (bufname[ bufsize - 2 ] != '\0')) {         \
      return MQDB_E_INVALID_DATA ;                 \
   }

#define  RETURN_ON_ERROR      \
   if (dbstatus != MQDB_OK)   \
   {                          \
      return dbstatus ;       \
   }

//////////////////////////
//
// Global Variables.
//
//////////////////////////

extern HENV  g_hEnv ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqdbodbc\odbcdata.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		odbcdata.cpp

Abstract:
   Define (and initialize if necessary) the global data of the dll.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      11-Jan-96   Created

--*/

#include "dbsys.h"
#include "mqdbodbc.h"

#include "odbcdata.tmh"

SWORD  dbODBCSQLTypes[ MQDB_ODBC_NUMOF_TYPES ] = {
            SQL_SMALLINT,
            SQL_INTEGER,
            SQL_VARCHAR,
            SQL_LONGVARBINARY,
            SQL_LONGVARBINARY,
            SQL_BINARY,
            SQL_LONGVARBINARY,
            SQL_INTEGER} ;

UDWORD dbODBCPrecision[ MQDB_ODBC_NUMOF_TYPES ] = {
            5,
            10,
            0,
            0,
            0,
            0,
            0,
            10} ;

//
// note: the operation names must contain a leading space and trailing
//       space to ease formatting of sql commands.
//
LPSTR dbODBCOpNameStr[ MQDB_ODBC_NUMOF_OPS ] = {
      " = ",
      " <> ",
      " >= ",
      " > ",
      " <= ",
      " < ",
      " OR ",
      " AND " } ;

//
// note: the operation names must contain a leading space and trailing
//       comma to ease formatting of sql commands.
//
LPSTR dbODBCOrderNameStr[ MQDB_ODBC_NUMOF_ORDER_OP ] = {
   " ASC, ",
   " DESC, " } ;

//
//
//
LPSTR dbODBCAggrNameStr[ MQDB_ODBC_NUMOF_AGGR_OP ] = {
      " MAX(",
      " MIN(",
      " AVRG(" } ;

//
// Global ODBC envoronment handle.
//
HENV  g_hEnv = SQL_NULL_HENV ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqdbodbc\odbcss.h ===
/*
** ODBCSS.H - This is the application include file for the
** SQL Server driver specific defines.
**
** (C) Copyright 1993-1996 By Microsoft Corp.
**
*/

//	SQLSetConnectOption/SQLSetStmtOption driver specific defines.
//	Microsoft has 1200 thru 1249 reserved for Microsoft SQL Server driver usage.

//	Connection Options
#define SQL_COPT_SS_BASE				1200
#define SQL_REMOTE_PWD					(SQL_COPT_SS_BASE+1) // dbrpwset SQLSetConnectOption only
#define SQL_USE_PROCEDURE_FOR_PREPARE	(SQL_COPT_SS_BASE+2) // Use create proc for SQLPrepare
#define SQL_INTEGRATED_SECURITY 		(SQL_COPT_SS_BASE+3) // Force integrated security on login
#define SQL_PRESERVE_CURSORS			(SQL_COPT_SS_BASE+4) // Preserve server cursors after SQLTransact
#define SQL_COPT_SS_USER_DATA			(SQL_COPT_SS_BASE+5) // dbgetuserdata/dbsetuserdata
#define SQL_COPT_SS_ANSI_OEM			(SQL_COPT_SS_BASE+6) // dbsetopt/DBANSItoOEM/DBOEMtoANSI
#define SQL_COPT_SS_ENLIST_IN_DTC		(SQL_COPT_SS_BASE+7) // Enlist in a Viper transaction
#define SQL_COPT_SS_ENLIST_IN_XA		(SQL_COPT_SS_BASE+8) // Enlist in a XA transaction
#define SQL_COPT_SS_CONNECTION_DEAD		(SQL_COPT_SS_BASE+9) // dbdead SQLGetConnectOption only
#define SQL_COPT_SS_FALLBACK_CONNECT	(SQL_COPT_SS_BASE+10) // Enables FallBack connections
#define SQL_COPT_SS_PERF_DATA			(SQL_COPT_SS_BASE+11) // Used to access SQL Server ODBC driver performance data
#define SQL_COPT_SS_PERF_DATA_LOG		(SQL_COPT_SS_BASE+12) // Used to set the logfile name for the Performance data
#define SQL_COPT_SS_PERF_QUERY_INTERVAL (SQL_COPT_SS_BASE+13) // Used to set the query logging threshold in milliseconds.
#define SQL_COPT_SS_PERF_QUERY_LOG		(SQL_COPT_SS_BASE+14) // Used to set the logfile name for saving queryies.
#define SQL_COPT_SS_PERF_QUERY			(SQL_COPT_SS_BASE+15) // Used to start and stop query logging.
#define SQL_COPT_SS_PERF_DATA_LOG_NOW	(SQL_COPT_SS_BASE+16) // Used to make a statistics log entry to disk.

#define SQL_COPT_SS_MAX_USED			SQL_COPT_SS_PERF_DATA_LOG_NOW

//	Statement Options
#define SQL_SOPT_SS_BASE				1225
#define SQL_TEXTPTR_LOGGING 			(SQL_SOPT_SS_BASE+0) // Text pointer logging
#define SQL_SOPT_SS_CURRENT_COMMAND		(SQL_SOPT_SS_BASE+1) // dbcurcmd SQLGetStmtOption only
#define SQL_SOPT_SS_MAX_USED			SQL_SOPT_SS_CURRENT_COMMAND


//	Defines for use with SQL_USE_PROCEDURE_FOR_PREPARE
#define SQL_UP_OFF		0L			//	Procedures won't be used for prepare
#define SQL_UP_ON		1L			//	Procedures will be used for prepare
#define SQL_UP_ON_DROP	2L			//	Temp procedures will be explicitly dropped
#define SQL_UP_DEFAULT	SQL_UP_ON

//	Defines for use with SQL_INTEGRATED_SECURITY - only useable before connecting
#define SQL_IS_OFF		0L			//	Integrated security isn't used
#define SQL_IS_ON		1L			//	Integrated security is used
#define SQL_IS_DEFAULT	SQL_IS_OFF

//	Defines for use with SQL_PRESERVE_CURSORS
#define SQL_PC_OFF		0L			//	Cursors are closed on SQLTransact
#define SQL_PC_ON		1L			//	Cursors remain open on SQLTransact
#define SQL_PC_DEFAULT	SQL_PC_OFF

//	Defines for use with SQL_COPT_SS_USER_DATA
#define SQL_UD_NOTSET	0L			//	No user data pointer set

//	Defines for use with SSQL_COPT_SS_ANSI_OEMQL_ANSI_OEM
#define SQL_AO_OFF		0L			//	ANSI/OEM translation is not performed
#define SQL_AO_ON		1L			//	ANSI/OEM translation is performed
#define SQL_AO_DEFAULT	SQL_AO_OFF	//	Default unless DSN OEM/ANSI checkbox is checked

//	Defines for use with SQL_COPT_SS_CONNECTION_DEAD
#define SQL_CD_FALSE	0L			//	Connection is open/available
#define SQL_CD_TRUE		1L			//	Connection is closed/dead

//	Defines for use with SQL_COPT_SS_FALLBACK_CONNECT
#define SQL_FB_OFF		0L			//	FallBack connections are disabled
#define SQL_FB_ON		1L			//	FallBack connections are enabled
#define SQL_FB_DEFAULT	SQL_FB_OFF

//	Defines for use with SQL_ENLIST_IN_DTC
#define SQL_DTC_DONE	0L			//	Delimits end of Viper transaction

//	Defines for use with SQL_TEXTPTR_LOGGING
#define SQL_TL_OFF		0L			//	No logging on text pointer ops
#define SQL_TL_ON		1L			//	Logging occurs on text pointer ops
#define SQL_TL_DEFAULT	SQL_TL_ON


//	SQLColAttributes driver specific defines.
//	SQLSet/GetDescField driver specific defines.
//	Microsoft has 1200 thru 1249 reserved for Microsoft SQL Server driver usage.

#define SQL_CA_SS_BASE				1200
#define SQL_CA_SS_COLUMN_SSTYPE		(SQL_CA_SS_BASE+0)	//	dbcoltype/dbaltcoltype
#define SQL_CA_SS_COLUMN_UTYPE		(SQL_CA_SS_BASE+1)	//	dbcolutype/dbaltcolutype
#define SQL_CA_SS_NUM_ORDERS		(SQL_CA_SS_BASE+2)	//	dbnumorders
#define SQL_CA_SS_COLUMN_ORDER		(SQL_CA_SS_BASE+3)	//	dbcolorder
#define SQL_CA_SS_COLUMN_VARYLEN	(SQL_CA_SS_BASE+4)	//	dbvarylen
#define SQL_CA_SS_NUM_COMPUTES		(SQL_CA_SS_BASE+5)	//	dbnumcompute
#define SQL_CA_SS_COMPUTE_ID		(SQL_CA_SS_BASE+6)	//	dbnextrow status return
#define SQL_CA_SS_COMPUTE_BYLIST	(SQL_CA_SS_BASE+7)	//	dbbylist
#define SQL_CA_SS_COLUMN_ID			(SQL_CA_SS_BASE+8)	//	dbaltcolid
#define SQL_CA_SS_COLUMN_OP			(SQL_CA_SS_BASE+9)	//	dbaltcolop
#define SQL_CA_SS_MAX_USED			SQL_CA_SS_COLUMN_OP

// SQL Server Data Type Tokens. Returned by SQLColAttributes/SQL_CA_SS_COLUMN_SSTYPE.
#define SQLTEXT 			0x23
#define SQLVARBINARY		0x25
#define SQLINTN 			0x26
#define SQLVARCHAR			0x27
#define SQLBINARY			0x2d
#define SQLIMAGE			0x22
#define SQLCHARACTER		0x2f
#define SQLINT1 			0x30
#define SQLBIT				0x32
#define SQLINT2 			0x34
#define SQLINT4 			0x38
#define SQLMONEY			0x3c
#define SQLDATETIME 		0x3d
#define SQLFLT8 			0x3e
#define SQLFLTN 			0x6d
#define SQLMONEYN			0x6e
#define SQLDATETIMN 		0x6f
#define SQLFLT4 			0x3b
#define SQLMONEY4			0x7a
#define SQLDATETIM4 		0x3a
#define SQLDECIMAL			0x37
#define SQLDECIMALN			0x6a
#define SQLNUMERIC			0x3f
#define SQLNUMERICN 		0x6c

//	User Data Type definitions. Returned by SQLColAttributes/SQL_CA_SS_COLUMN_UTYPE.
#define SQLudtTEXT			19
#define SQLudtVARBINARY 	4
#define SQLudtINTN			13
#define SQLudtVARCHAR		2
#define SQLudtBINARY		3
#define SQLudtIMAGE 		20
#define SQLudtCHAR			1
#define SQLudtINT1			5
#define SQLudtBIT			16
#define SQLudtINT2			6
#define SQLudtINT4			7
#define SQLudtMONEY 		11
#define SQLudtDATETIME		12
#define SQLudtFLT8			8
#define SQLudtFLTN			14
#define SQLudtMONEYN		17
#define SQLudtDATETIMN		15
#define SQLudtSYSNAME		18
#define SQLudtTIMESTAMP 	80
#define SQLudtFLT4			23
#define SQLudtMONEY4		21
#define SQLudtDATETIM4		22
#define SQLudtDECML			24
#define SQLudtDECMLN		26
#define SQLudtNUM			10
#define SQLudtNUMN			25
#define MIN_USER_DATATYPE	100

// aggregate operator types (returned by SQLColAttributes/SQL_CA_SS_COLUMN_OP)
#define SQLAOPCNT	0x4b
#define SQLAOPSUM	0x4d
#define SQLAOPAVG	0x4f
#define SQLAOPMIN	0x51
#define SQLAOPMAX	0x52
#define SQLAOPANY	0x53
#define SQLAOPNOOP	0x56


//	SQLGetInfo driver specific defines.
//	Microsoft has 1200 thru 1249 reserved for Microsoft SQL Server driver usage.

#define SQL_INFO_SS_FIRST		1200
#define SQL_INFO_SS_NETLIB_NAME (SQL_INFO_SS_FIRST+0) //  dbprocinfo
#define SQL_INFO_SS_MAX_USED	SQL_INFO_SS_NETLIB_NAME


//	Internal server datatypes - used when binding to SQL_C_BINARY
#ifndef MAXNUMERICLEN	// Resolve ODS/DBLib conflicts
typedef struct dbmoney
{						// Internal representation of MONEY data type
	LONG  mnyhigh;		// Money value *10,000 (High 32 bits/signed)
	ULONG mnylow;		// Money value *10,000 (Low 32 bits/unsigned)
} DBMONEY;

typedef struct dbdatetime
{						// Internal representation of DATETIME data type
	LONG  dtdays;		// No of days since Jan-1-1900 (maybe negative)
	ULONG dttime;		// No. of 300 hundredths of a second since midnight
} DBDATETIME;

typedef struct dbdatetime4
{						// Internal representation of SMALLDATETIME data type
	USHORT numdays; 	// No of days since Jan-1-1900
	USHORT nummins; 	// No. of minutes since midnight
} DBDATETIM4;

typedef LONG DBMONEY4;	// Internal representation of SMALLMONEY data type
						// Money value *10,000

#define MAXNUMERICLEN 16

#define DBNUM_PREC_TYPE BYTE
#define DBNUM_SCALE_TYPE BYTE
#define DBNUM_VAL_TYPE BYTE

typedef struct dbnumeric
{							// Internal representation of NUMERIC data type
	DBNUM_PREC_TYPE   precision;			// Precision
	DBNUM_SCALE_TYPE  scale;				// Scale
	BYTE			  sign; 				// Sign (1 if positive, 0 if negative)
	DBNUM_VAL_TYPE	  val[MAXNUMERICLEN];	// Value
} DBNUMERIC;

typedef DBNUMERIC DBDECIMAL;// Internal representation of DECIMAL data type
#endif //	MAXNUMERICLEN

/*****************************************************************
 This struct is a global used for 
 gathering statistal data on the driver.
 Access to this struct is controled via the 
 pStatCrit;
******************************************************************/

typedef struct sqlperf
{
	// Application Profile Statistics
	DWORD TimerResolution;
	DWORD SQLidu;
	DWORD SQLiduRows;
	DWORD SQLSelects;
	DWORD SQLSelectRows;
	DWORD Transactions;
	DWORD SQLPrepares;
	DWORD ExecDirects;
	DWORD SQLExecutes;
	DWORD CursorOpens;
	DWORD CursorSize;
	DWORD CursorUsed;
	LDOUBLE PercentCursorUsed;
	LDOUBLE AvgFetchTime;
	LDOUBLE AvgCursorSize; 
	LDOUBLE AvgCursorUsed;
	DWORD SQLFetchTime;
	DWORD SQLFetchCount;
	DWORD CurrentStmtCount;
	DWORD MaxOpenStmt;
	DWORD SumOpenStmt;
	
	// Connection Statistics
	DWORD CurrentConnectionCount;
	DWORD MaxConnectionsOpened;
	DWORD SumConnectionsOpened;
	DWORD SumConnectiontime;
	LDOUBLE AvgTimeOpened;

	// Network Statistics
	DWORD ServerRndTrips;
	DWORD BuffersSent;
	DWORD BuffersRec;
	DWORD BytesSent;
	DWORD BytesRec;

	// Time Statistics;
	DWORD msExecutionTime;
	DWORD msNetWorkServerTime;

} 	SQLPERF;

// The following are option for SQL_COPT_SS_PERF_DATA and SQL_COPT_SS_PERF_QUERY
#define SQL_PERF_START	1			// Starts the driver sampling performance data.
#define SQL_PERF_STOP	2			// Stops the counters from sampling performance data.

//	The following options have been deprecated

#define SQL_FAST_CONNECT				(SQL_COPT_SS_BASE+0)
//	Defines for use with SQL_FAST_CONNECT - only useable before connecting
#define SQL_FC_OFF		0L			//	Fast connect is off
#define SQL_FC_ON		1L			//	Fast connect is on
#define SQL_FC_DEFAULT	SQL_FC_OFF

/* 

The following data struct is used as the vParam with 
SQL_COPT_SS_ENLIST_IN_XA to enlist in a XA stansaction
when calling SQLSetStmtAttribute();

*/
typedef struct SQLXaTranTAG
{
    void FAR *transManager;
    void FAR *xaTransID;
    ULONG	xaTransIDLength;
    DWORD   dwErrorInfo;
} SQLXaTran;
                           
//	End of odbcss.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqdbodbc\odbcstmt.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		odbcstmt.cpp

Abstract:
	Implements the odbc statement class CMQDBOdbcSTMT

Authors:
	Nir Ben-Zvi  (nirb)
   Doron Juster (DoronJ)

Revisoins:
   NirB       1995      Create first version
   DoronJ   11-jan-96   Adopt for the mqdbmgr dll.
--*/						

#include "dbsys.h"
#include "odbcstmt.h"

#include "odbcstmt.tmh"

/***********************************************************
*
* CMQDBOdbcSTMT::CMQDBOdbcSTMT
*
* Constructor. Initialize the variables
*
* Input:
* ======
* hConnection	- The connection handle
*
* Output:
* =======
* none
*
************************************************************/

CMQDBOdbcSTMT::CMQDBOdbcSTMT( IN  HDBC  hConnection )
							: m_hConnection(hConnection),
							  m_hStatement(SQL_NULL_HSTMT),
							  m_fAllocated(FALSE),
							  m_fPrepared(FALSE),
							  m_fShouldFree(FALSE),
							  m_szSqlString(NULL),
                       m_cColumns(0)
{
}

/***********************************************************
*
* CMQDBOdbcSTMT::~CMQDBOdbcSTMT
*
* Destructor.
* If the statement is allocated, deallocate it
*
* Input:
* ======
* none
*
* Output:
* =======
* none
*
************************************************************/

CMQDBOdbcSTMT::~CMQDBOdbcSTMT()
{
	if (m_fAllocated)
		Deallocate();
}

/***********************************************************
*
* CMQDBOdbcSTMT::Allocate
*
* This function allocates an ODBC statement
*
* Input:
* ======
* szSqlString - the sql command
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::Allocate(
					IN		char *	 	szSqlString)
{
	RETCODE status;


	// Sanity check
	ASSERT(m_fAllocated == FALSE);

	// Allocate a statement
	status = ::SQLAllocStmt(
						m_hConnection,
						&m_hStatement);
	if (!ODBC_SUCCESS(status))
		return status;
	
	m_fAllocated = TRUE;


	// Set the sql string
	status = ChangeSqlString(szSqlString);


	// Thats it folks
	return status;
}

/***********************************************************
*
* CMQDBOdbcSTMT::Deallocate
*
* This function deallocates the statement
*
* Input:
* ======
* none
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::Deallocate()
{
	RETCODE status;

	// Sanity
	ASSERT(m_fAllocated == TRUE);

	// Get rid of the buffer
	if (m_szSqlString != NULL)
	{
		delete m_szSqlString;
		m_szSqlString = NULL;
	}

	// Free the statement
	status = ::SQLFreeStmt(
						m_hStatement,
						SQL_DROP);
	if (!ODBC_SUCCESS(status))
		return status;

	// Thats it folks
	return SQL_SUCCESS;
}

/***********************************************************
*
* CMQDBOdbcSTMT::ChangeSqlString
*
* This function changes the sql command of the statement
*
* It also resets the stamtement state
*
* Input:
* ======
* szSqlString - the sql command
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::ChangeSqlString(
   					IN	char * 	szSqlString)
{
	// Sanity check
	ASSERT(m_fAllocated == TRUE);

	// Stop current statement processing but do not drop it
	if (m_fShouldFree)
	{
		::SQLFreeStmt(
					m_hStatement,
					SQL_CLOSE);
		::SQLFreeStmt(
					m_hStatement,
					SQL_UNBIND);
		::SQLFreeStmt(
					m_hStatement,
					SQL_RESET_PARAMS);
	}
	m_fPrepared = FALSE;
	m_fShouldFree = FALSE;

	// Drop the current sql string
	if (m_szSqlString != NULL)
	{
		delete m_szSqlString;
		m_szSqlString = NULL;
	}

	// Copy the sql string
	if (szSqlString != NULL)
	{
		m_szSqlString = new char[strlen(szSqlString)+1];
		ASSERT(m_szSqlString) ;
		strcpy(m_szSqlString,szSqlString);
	}
	else
   {
		m_szSqlString = NULL;
   }

	// Thats it folks
	return SQL_SUCCESS;
}

/***********************************************************
*
* CMQDBOdbcSTMT::Prepare
*
* This function prepares the statement to be executed afterwords.
* This is done for two reasons:
* 1. Performance
* 2. The parameters are not known while preparing the statement.
*
* Input:
* ======
* none
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::Prepare()
{
	RETCODE status;

	// Prepare the statement
	status = ::SQLPrepare(
							m_hStatement,
							(UCHAR *)m_szSqlString,
							SQL_NTS);
	if (!ODBC_SUCCESS(status))
		return status;

	// Indicate that the statement was prepared
	m_fPrepared = TRUE;

	return status;
}

/***********************************************************
*
* CMQDBOdbcSTMT::Execute
*
* This function executes the statement.
* If the statement was prepared, we use Execute otherwise we use ExecDirect.
*
* Input:
* ======
* IN LPSTR lpszCommand - if not null, this is the direct command to execute.
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::Execute( IN LPSTR lpszCommand )
{
	RETCODE status;

   if (lpszCommand)
   {
      // Direct execution.
      //
   	ASSERT(!m_fPrepared) ;
      ASSERT(!m_szSqlString) ;

		status = ::SQLExecDirect( m_hStatement,
                                (UCHAR *) lpszCommand,
                                SQL_NTS);
   }
	else if (!m_fPrepared)
	{
		// No preperation done, use ExecDirect
      //
      ASSERT(m_szSqlString) ;
		status = ::SQLExecDirect( m_hStatement,
                                (UCHAR *) m_szSqlString,
                                SQL_NTS);
	}
	else
	{
      //
		// Execute a prepared statement
		status = ::SQLExecute(m_hStatement);
	}

	return status;
}

/***********************************************************
*
* CMQDBOdbcSTMT::Fetch
*
* This function calls the SQL to fetch the next row in a result set
*
* Input:
* ======
* none
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::Fetch()		
{
	RETCODE status	=	SQL_SUCCESS;

	// If used again for other purposes, free the cursor
	m_fShouldFree = TRUE;

	// Get number of rows
	status = ::SQLFetch(m_hStatement);

	// Thats it folks
	return status;
}

/***********************************************************
*
* CMQDBOdbcSTMT::GetStringColumn
*
* This function gets the data of a string column
*
* Input:
* ======
* dwCol	- Column number in result set
* pszOut	- Buffer to hold result
* dwSize	- Buffer size
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::GetStringColumn(
					IN		DWORD	 	dwCol,
					OUT	char **	ppszOut,
					IN		DWORD	*	pdwSize)
{
   return GetLargeColumn( SQL_C_CHAR,
					           dwCol,
					           ppszOut,
                          pdwSize,
		                    0) ;
}

/***********************************************************
*
* CMQDBOdbcSTMT::GetBinaryColumn
*
* This function gets the data of a binary column
*
* Input:
* ======
* dwCol		- Column number in result set
* ppOut		- Pointer to buffer that holds result (buffer can be NULL)
* dwSize 	- Buffer size (If pszOut is NULL the size is returned)
* dwOffset	- starting offset within the parameter
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::GetBinaryColumn(
					IN		DWORD	 	dwCol,
					OUT	char **	ppOut,
					IN		DWORD *	pdwSize,
					IN		DWORD		dwOffset)
{
   return GetLargeColumn( SQL_C_BINARY,
					           dwCol,
					           ppOut,
                          pdwSize,
		                    dwOffset) ;
}

/***********************************************************
*
* CMQDBOdbcSTMT::GetLargeColumn
*
* This function gets the data of a binary column
*
* If the buffer provided is NULL the routine allocates it.
*
* Input:
* ======
* swType    - Type of data: either string or binary.
* dwCol		- Column number in result set
* ppOut		- Pointer to buffer that holds result (buffer can be NULL)
* dwSize 	- Buffer size (If pszOut is NULL the size is returned)
* dwOffset	- starting offset within the parameter
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::GetLargeColumn(
               IN    SWORD    swType,
					IN		DWORD	 	dwCol,
					OUT	char **	ppOut,
					IN		DWORD *	pdwSize,
					IN		DWORD		dwOffset)
{
	RETCODE status			=	SQL_SUCCESS;
	SDWORD	dwOutSize;

    DBG_USED(dwOffset);

	// Sanity check
	ASSERT(ppOut != NULL && pdwSize != NULL);

	// BUGBUG Offset>0 currently unsupported
	ASSERT(dwOffset == 0);

	// If no buffer supplied
	if (*ppOut == NULL)
	{
		// Get the parameter length
        char	OneByte;
		status = ::SQLGetData(  m_hStatement,
            						(UWORD)dwCol,
				            		swType,
            						(PTR)&OneByte,
				            		0,
            						&dwOutSize);
		if (!ODBC_SUCCESS(status) && (status != SQL_SUCCESS_WITH_INFO))
        {
            OdbcStateIs( m_hConnection, m_hStatement, OERR_GENERAL_WARNING) ;
			return status;
        }

		//
        // If this is a NULL column
        //
		if (dwOutSize == SQL_NULL_DATA)
		{
			*pdwSize = 0 ;
		    *ppOut = NULL ;
			return SQL_SUCCESS;
		}

		// Allocate the output buffer
        if (swType == SQL_C_CHAR)
        {
           // include the null termination in the count.
		   dwOutSize++ ;
        }
		*pdwSize = dwOutSize;
		*ppOut = new char[ dwOutSize ] ;
		ASSERT(*ppOut) ;
	}

	// Get the data
	status = ::SQLGetData(
						m_hStatement,
						(UWORD)dwCol,
						swType,
						(PTR)*ppOut,
						*pdwSize,
						&dwOutSize);


	// If not all the data was read, it is still o.k.
	if (status == SQL_SUCCESS_WITH_INFO && *pdwSize != (DWORD)dwOutSize)
	{
		status = SQL_SUCCESS;

		// Update size read
		if (dwOutSize == SQL_NULL_DATA)
			*pdwSize = 0;
		else if (*pdwSize > (DWORD)dwOutSize)
			*pdwSize = dwOutSize;
	}

	// Thats it folks
	return status;
}

/***********************************************************
* CMQDBOdbcSTMT::GetDwordColumn
*
* This function gets the data of an INTEGER column
*
*
*
* Input:
* ======
* dwCol		- Column number in result set
* pdwOut	- Buffer to hold result
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::GetDwordColumn(
					IN		DWORD	 	dwCol,
					OUT	DWORD *	pdwOut)
{
	RETCODE status	=	SQL_SUCCESS;
	SDWORD	dwOutSize;

	// Get data
	status = ::SQLGetData(
						m_hStatement,
						(UWORD)dwCol,
						SQL_C_SLONG,
						(PTR)pdwOut,
						sizeof(DWORD),
						&dwOutSize);

	// Thats it folks
	return status;
}

/***********************************************************
*
* CMQDBOdbcSTMT::GetWordColumn
*
* This function gets the data of an SHORT column
*
* Input:
* ======
* dwCol		- Column number in result set
* pdwOut	- Buffer to hold result
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::GetWordColumn(
					IN		DWORD	 	dwCol,
					OUT	WORD *	pwOut)
{
	RETCODE status	=	SQL_SUCCESS;
	SDWORD	dwOutSize;

	// Get data
	status = ::SQLGetData(
						m_hStatement,
						(UWORD)dwCol,
						SQL_C_SSHORT,
						(PTR)pwOut,
						sizeof(WORD),
						&dwOutSize);

	// Thats it folks
	return status;
}

/***********************************************************
* CMQDBOdbcSTMT::BindParameter
*
* This function binds a parameter to the statement
*
* Input:
* ======
* dwParameter	- Parameter number
* wCType		- The C data type
* wSqlType		- The SQL data type
* dwPrecision	- The precision of the data type
* dwSize		- Total number of bytes in parameter
* pParameter	- A pointer to the parameter location
*
* Output:
* =======
* status
*
************************************************************/

RETCODE CMQDBOdbcSTMT::BindParameter(
					IN		UDWORD	 	dwParameter,
					IN		SWORD	   	wCType,
					IN		SWORD	      wSqlType,
					IN		UDWORD		dwPrecision,
					IN		UDWORD		dwSize,
					IN		PTR			pParameter,
					IN		SDWORD *    pcbValue)
{
	return ::SQLBindParameter(
						m_hStatement,
						(UWORD)dwParameter,
						SQL_PARAM_INPUT,
						wCType,
						wSqlType,
						dwPrecision,
						0,
						pParameter,
						(SDWORD)dwSize,
						pcbValue);
}

/***********************************************************
*
* CMQDBOdbcSTMT::GetDataTypeName
*
* This function gets the specified data type name
*
* Input:
* ======
* swType	- The requested type
* szBuffer	- The buffer that will hold the name returned
* dwBufSize	- Buffer size
*
* Output:
* =======
* status
* Data type name is inserted into the buffer
*
************************************************************/

RETCODE CMQDBOdbcSTMT::GetDataTypeName(
					IN		SWORD	   swType,
					OUT	char *	szBuffer,
					IN		DWORD	   dwBuffSize)
{
	RETCODE status	=	SQL_SUCCESS;
	SDWORD	dwLen;

	// If used again for other purposes, free the cursor
	m_fShouldFree = TRUE;

	// Get type info
	status = ::SQLGetTypeInfo(
							m_hStatement,
							swType);
	if (!ODBC_SUCCESS(status))
		return status;

	// Fetch row
	status = ::SQLFetch(
						m_hStatement);
	if (!ODBC_SUCCESS(status))
		return status;

	// Get data type name
	status = ::SQLGetData(
						m_hStatement,
						1,				// Column number 1
						SQL_C_CHAR,
						szBuffer,
						dwBuffSize,
						&dwLen);

	// Thats it folks
	return status;
}

/***********************************************************************
*
*  RETCODE CMQDBOdbcSTMT::EnableMultipleQueries()
*
*  Enable multiple (parallel) queries.
*
*  Input:
*  ======
*
*  Output:
*  =======
*
**********************************************************************/

RETCODE CMQDBOdbcSTMT::EnableMultipleQueries( IN DWORD dwDBMSType )
{
	RETCODE status	= SQL_SUCCESS ;

   if ( dwDBMSType == MQDBMSTYPE_SQLSERVER )
   {
      // For multiple queries on SQL server, set this option to get
      // type B cursor.
   	status = ::SQLSetStmtOption(
	      						m_hStatement,
			      				SQL_CURSOR_TYPE,
					      		SQL_CURSOR_KEYSET_DRIVEN );
   }

	// Thats it folks
	return status;
}

/***********************************************************************
*
*  RETCODE CMQDBOdbcSTMT::EnableNoLockQueries()
*
*  Enable queries without locks.
*
*  Input:
*  ======
*
*  Output:
*  =======
*
**********************************************************************/

RETCODE CMQDBOdbcSTMT::EnableNoLockQueries( IN DWORD dwDBMSType )
{
	RETCODE status	= SQL_SUCCESS ;

   if ( dwDBMSType == MQDBMSTYPE_SQLSERVER )
   {
   	status = ::SQLSetStmtOption(
	      						m_hStatement,
			      				SQL_CONCURRENCY,
					      		SQL_CONCUR_ROWVER ) ;
   }

	// Thats it folks
	return status;
}

/***********************************************************************
*
*  RETCODE  CMQDBOdbcSTMT::GetRowsCount(LONG *pCount)
*
*  Get number of rows which were affected by last command.
*
*  Input:
*  ======
*
*  Output:
*  =======
*
**********************************************************************/

RETCODE  CMQDBOdbcSTMT::GetRowsCount(LONG *pCount)
{
   SDWORD sdCount ;

   RETCODE sqlstatus = SQLRowCount( m_hStatement,
                                    &sdCount ) ;
   *pCount = (LONG) sdCount ;

	if (!ODBC_SUCCESS(sqlstatus))
   {
       OdbcStateIs( m_hConnection, m_hStatement, OERR_GENERAL_WARNING) ;
   }

   return sqlstatus ;
}

/***********************************************************
*
*  MQDBSTATUS  RetrieveRecordData()
*
*  Retrieve record columns into caller buffers.
*
* Input:
* ======
* hQuery       - handle of the query which selected the record.
* aColumnVal[] - Array of MQDBCOLUMNVAL
* cColumns     - number of columns in the array
*
* Output:
* =======
* MQDB_OK if succeeded.
*
************************************************************/

MQDBSTATUS  CMQDBOdbcSTMT::RetrieveRecordData(
                                  IN MQDBCOLUMNVAL  aColumnVal[],
                                  IN LONG           lColumns /*= 0*/ )
{
   RETCODE sqlstatus = Fetch() ;
   if (sqlstatus == SQL_NO_DATA_FOUND)
   {
      return MQDB_E_NO_MORE_DATA ;
   }

   HDBC  hDbc  = m_hConnection ;
   HSTMT hStmt = m_hStatement ;

   if (!ODBC_SUCCESS(sqlstatus))
   {
     MQDBSTATUS dbstatus = MQDB_E_DATABASE;
     if (OdbcStateIs( hDbc, hStmt, OERR_DBMS_NOT_AVAILABLE))
     {
        dbstatus = MQDB_E_DBMS_NOT_AVAILABLE ;
     }
      return dbstatus ;
   }

   if (lColumns > 0)
   {
      ASSERT(m_cColumns == 0) ;
      m_cColumns = lColumns ;
   }

   LONG index = 0 ;
   for ( ; index < m_cColumns ; index++ )
   {
      switch( aColumnVal[ index ].mqdbColumnType )
      {
         case MQDB_STRING:
         {
            sqlstatus = GetStringColumn( (index+1),
                          (char **) &aColumnVal[ index ].nColumnValue,
                          (DWORD *) &aColumnVal[ index ].nColumnLength) ;
            break ;
         }

         case MQDB_SHORT:
         {
            sqlstatus = GetWordColumn( (index+1),
                          (WORD *) &(aColumnVal[ index ].nColumnValue)) ;
            break ;
         }

         case MQDB_LONG:
         case MQDB_IDENTITY:
         {
            sqlstatus = GetDwordColumn( (index+1),
                           (DWORD *) &(aColumnVal[ index ].nColumnValue)) ;
            break ;
         }

         default:
         {
            sqlstatus = GetBinaryColumn( (index + 1),
                          (char **) &(aColumnVal[ index ].nColumnValue),
                          (DWORD *) &(aColumnVal[ index ].nColumnLength),
                          0 /* offset */) ;
            break ;
         }
      }
      if (!ODBC_SUCCESS(sqlstatus))
      {
         OdbcStateIs( hDbc, hStmt, OERR_GENERAL_WARNING) ;
         return MQDB_E_DATABASE ;
      }
   }
   return MQDB_OK ;
}

/***********************************************************************
*
*  MQDBSTATUS  CMQDBOdbcSTMT::SetQueryTimeout( IN DWORD dwTimeout )
*
*  Set timeout for a query.
*
*  Input:
*  ======
*
*  Output:
*  =======
*
**********************************************************************/

MQDBSTATUS  CMQDBOdbcSTMT::SetQueryTimeout( IN DWORD dwTimeout )
{
	RETCODE status	=  ::SQLSetStmtOption( m_hStatement,
                                         SQL_QUERY_TIMEOUT,
                                         dwTimeout ) ;

   if (!ODBC_SUCCESS(status))
   {
      OdbcStateIs( m_hConnection, m_hStatement, OERR_GENERAL_WARNING) ;
      return  MQDB_E_INVALID_DATA ;
   }

	// Thats it folks
	return MQDB_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqdbodbc\stdh.cpp ===
//
// file:  stdh.cpp
//

#include "dbsys.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqdbodbc\odbcutil.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
		odbcutil.cpp

Abstract:
   Utility functions.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      10-Jan-96   Created. Based on NirB ODBC code.

--*/

#include "dbsys.h"
#include "mqdbodbc.h"
#include "odbcstmt.h"

#include "odbcutil.tmh"

/***********************************************************
*
* DllMain
*
*
* Input:
* ======
*
* Output:
* =======
* TRUE
*
************************************************************/

BOOL WINAPI DllMain (HMODULE hMod, DWORD fdwReason, LPVOID lpvReserved)
{
    UNREFERENCED_PARAMETER(hMod);
    UNREFERENCED_PARAMETER(lpvReserved);

   if (fdwReason == DLL_PROCESS_ATTACH)
   {
      WPP_INIT_TRACING(L"Microsoft\\MSMQ");

      ASSERT(MQDB_ODBC_NUMOF_OPS      == MQDB_NUMOF_OPS) ;
      ASSERT(MQDB_ODBC_NUMOF_ORDER_OP == MQDB_NUMOF_ORDER_OP) ;
   }
   else if (fdwReason == DLL_PROCESS_DETACH)
   {
      WPP_CLEANUP();
      //ASSERT(g_hEnv == SQL_NULL_HENV) ;
   }
   else if (fdwReason == DLL_THREAD_ATTACH)
   {
   }
   else if (fdwReason == DLL_THREAD_DETACH)
   {
   }

	return TRUE;
}


/***********************************************************
*
* OdbcStateIs
* OdbcStateIsEx
*
* Check if the ODBC state (error returned from ODBC call) is as
* specified.
*
* Input:
* ======
* szStateToBeChecked	- The state to checked against what ODBC tell us.
*
* Output:
* =======
* TRUE if ODBC state matches the state to be checked.
*
************************************************************/

BOOL OdbcStateIsEx(
               IN    HDBC        hDbc,
               IN    HSTMT       hStmt,
					IN		char *		szStateToBeChecked,
 				   IN    SDWORD *    pdwNativeError,
               UCHAR             *pszSqlState)
{
	RETCODE sqlstatus;
	SWORD   dwCount;  // Not used.
	UCHAR   szBuffer[SQL_MAX_MESSAGE_LENGTH-1];


	// Get the current error state
 	sqlstatus = ::SQLError(
 						g_hEnv,
 						hDbc,
 						hStmt,
 						pszSqlState,
 						pdwNativeError,
 						szBuffer,
 						sizeof(szBuffer),
 						&dwCount);

	if (!ODBC_SUCCESS(sqlstatus))
		return FALSE;

#ifdef _DEBUG
	TCHAR   wzBuffer[SQL_MAX_MESSAGE_LENGTH-1];
   TCHAR   wzSqlState[SQLSTATELEN];

   MultiByteToWideChar( CP_ACP,
                        0,
                        (LPSTR) &szBuffer[0],
                        -1,
                        wzBuffer,
	                     SQL_MAX_MESSAGE_LENGTH-1 ) ;

   MultiByteToWideChar( CP_ACP,
                        0,
                        (LPSTR) pszSqlState,
                        -1,
                        wzSqlState,
	                     SQLSTATELEN ) ;

	TrTRACE(GENERAL, "SQLError (%ls, %lut): %ls", wzSqlState, (ULONG) *pdwNativeError, wzBuffer);
#endif

	return ( lstrcmpiA(szStateToBeChecked, (char *)pszSqlState) == 0 ) ;
}


BOOL OdbcStateIs(
               IN    HDBC        hDbc,
               IN    HSTMT       hStmt,
					IN		char *		szStateToBeChecked)
{
   SDWORD  dwError ;
   UCHAR   szSqlState[SQLSTATELEN];

   return  OdbcStateIsEx(  hDbc,
                           hStmt,
					            szStateToBeChecked,
                           &dwError,
                           szSqlState ) ;
}

/***********************************************************
*
*  GetDataTypeName
*
*  This function return the data-source name for a data type
*
* Input:
* ======
* hDbc      - Handle of connection.
* swType 	- The requested data type.
* szBuffer	- The buffer that will get the returned name.
* dwBufSize	- Buffer size
*
* Output:
* =======
* ODBC driver return code.
*
************************************************************/

RETCODE GetDataTypeName(
               IN    HDBC     hDbc,
					IN		SWORD  	swType,
					OUT	char *	szBuffer,
					IN		SDWORD   dwBuffSize)
{
	RETCODE  sqlstatus ;
	SDWORD   dwLen ;
   HSTMT    hStmt ;

   // Allocate a statement. This function should be called only when
   // connecting to a new database so performance is not an issue and
   // we won't bother caching statement handles.

   sqlstatus = ::SQLAllocStmt(hDbc, &hStmt) ;
	if (!ODBC_SUCCESS(sqlstatus))
      return sqlstatus ;

   __try
   {
	   // Get type info
	   sqlstatus = ::SQLGetTypeInfo(hStmt, swType);
	   if (!ODBC_SUCCESS(sqlstatus))
		   __leave ;

   	// Fetch row
	   sqlstatus = ::SQLFetch(hStmt) ;
   	if (!ODBC_SUCCESS(sqlstatus))
	   	__leave ;

	   // Get data type name
	   sqlstatus = ::SQLGetData(
						hStmt,
						1,				// Column number 1
						SQL_C_CHAR,
						szBuffer,
						dwBuffSize,
						&dwLen);
   }
   __finally
   {
      RETCODE freestatus = ::SQLFreeStmt(hStmt, SQL_DROP) ;
   	if (ODBC_SUCCESS(sqlstatus))
         sqlstatus = freestatus ;
   }

	// Thats it folks
	return sqlstatus ;
}


/***********************************************************
*
*  PrepareColumnNames
*
*  Get an array of MQDBCOLUMNVAL and prepare a string with column names,
*  suitable for use in SQL syntax.
*
* Input:
* ======
* aColumnVal[] - Array of MQDBCOLUMNVAL
* cColumns     - number of columns in the array
* szBufer      - buffer for the string
*
* Output:
* =======
* TRUE if successful, FALSE otherwise
*
************************************************************/

BOOL  PrepareColumnNames( IN MQDBCOLUMNVAL     aColumnVal[],
                          IN LONG              cColumns,
                          IN OUT LPSTR         lpBuffer)
{
   __try
   {
      char szBuffer[256] ;
      LONG index = 1 ;

      wsprintfA(lpBuffer, "(%s", aColumnVal[0].lpszColumnName) ;
      for ( ; index < cColumns ; index++ ) {
         wsprintfA(szBuffer, ", %s", aColumnVal[ index ].lpszColumnName) ;
         lstrcatA( lpBuffer, szBuffer) ;
      }
      lstrcatA( lpBuffer, ")") ;
      return TRUE ;
   }
   __except(EXCEPTION_EXECUTE_HANDLER)
   {
      return FALSE ;
   }
}

/***********************************************************
*
*  FormatColumnData
*
*  Format a data item in a column into a string
*
* Input:
* ======
*
* Output:
* =======
* MQDB_OK if format succeeded.
*
************************************************************/


MQDBSTATUS  FormatColumnData( IN LPSTR          szTmpBuff,
                              IN MQDBCOLUMNVAL  *pColumnVal)
{
   switch (pColumnVal->mqdbColumnType)
   {
      case MQDB_SHORT:
      case MQDB_LONG:
      {
          wsprintfA(szTmpBuff, "%ld", pColumnVal->nColumnValue) ;
          break ;
      }

      case MQDB_STRING:
      {
          wsprintfA(szTmpBuff, "'%s'", (LPSTR) pColumnVal->nColumnValue) ;
          break ;
      }

      default:
      {
          ASSERT(0) ;
          return MQDB_E_UNKNOWN ;
      }
   }
   return MQDB_OK ;
}


/***********************************************************
*
*  TypeMustBind
*
*  Check if a data type must be bound instead of directly used
*  in direct execution.
*
* Input:
* ======
* cType- data type to be checked.
*
* Output:
* =======
* TRUE if must bind.
*
************************************************************/

BOOL TypeMustBind( IN MQDBCOLUMNTYPE cType )
{
   if ((cType != MQDB_SHORT) &&
       (cType != MQDB_LONG)  &&
       (cType != MQDB_STRING)) {
      return TRUE ;
   }
   else {
      return FALSE ;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqdbodbc\tblinsrt.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		tblinsrt.cpp

Abstract:
   Implement the insert method for the database table class,
   for use with ODBC drivers.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      08-Aug-96   Create, from tblodbc.cpp

--*/

#include "dbsys.h"
#include "tblodbc.h"
#include "dbodbc.h"

#include "tblinsrt.tmh"

#define INSERT_BUFFER_LEN  1024

//***********************************************************
//
//  MQDBSTATUS  CMQODBCTable::FormatInsertCmd
//
//  Format a SQL Insert command.
//
//  Input:
//  ======
//  aColumnVal[] - Array of MQDBCOLUMNVAL
//  cColumns     - number of columns in the array
//  szBufer      - buffer for the string
//
//  Output:
//  =======
//  MQDB_OK if format succeeded.
//
//************************************************************

MQDBSTATUS  CMQODBCTable::FormatInsertCmd(
                             IN MQDBCOLUMNVAL   aColumnVal[],
                             IN LONG            cColumns,
                             IN OUT LPSTR       lpBuffer )
{
   wsprintfA(lpBuffer, "INSERT INTO %s ", m_lpszTableName) ;

   if (aColumnVal[0].lpszColumnName)
   {
      // Only part of the columns are used.
      // Prepare string with column names.
      //
      DECLARE_BUFFER(szColBuffer, INSERT_BUFFER_LEN) ;

      if (!PrepareColumnNames( aColumnVal,
                               cColumns,
                               szColBuffer))
      {
         return MQDB_E_INVALID_DATA ;
      }
      VERIFY_BUFFER(szColBuffer, INSERT_BUFFER_LEN) ;
      lstrcatA(lpBuffer, szColBuffer) ;
   }
   lstrcatA(lpBuffer, "VALUES (") ;

   return MQDB_OK ;
}

//***********************************************************************
//
//  MQDBSTATUS CMQODBCTable::ExecuteInsert
//
// Execute a prepared command
// It's the caller responsibility to supply the right number of columns
// with the right order.
//
//***********************************************************************

MQDBSTATUS CMQODBCTable::ExecuteInsert(
	                       IN CMQDBOdbcSTMT    *pStatement,
                          IN MQDBCOLUMNVAL     aColumnVal[],
                          IN LONG              cColumns)
{
   //
   // First bind the parameters.
   //
   MQDBSTATUS dbstatus = MQDB_OK ;
   RETCODE sqlstatus ;
   LONG index = 1 ;

   for ( ; index <= cColumns ; index++ )
   {
       dbstatus = BindParameter( index,
                                 &aColumnVal[ index - 1 ],
                                 pStatement) ;
       if (dbstatus != MQDB_OK)
       {
          return dbstatus ;
       }
   }

   //
   // Next, execute.
   //
   sqlstatus = pStatement->Execute() ;
   return CheckSqlStatus( sqlstatus, pStatement) ;
}

//***********************************************************************
//
//  MQDBSTATUS CMQODBCTable::PrepareInsert
//
// Prepare an Insert statement
//
//***********************************************************************

MQDBSTATUS CMQODBCTable::PrepareInsert(
                          IN MQDBCOLUMNVAL     aColumnVal[],
                          IN LONG              cColumns )
{
   MQDBSTATUS dbstatus = MQDB_OK ;
   DECLARE_BUFFER(szBuffer, INSERT_BUFFER_LEN) ;

   dbstatus =  FormatInsertCmd( aColumnVal,
                                cColumns,
                                szBuffer ) ;
   if (dbstatus != MQDB_OK)
   {
      return dbstatus ;
   }

   LONG index = 0 ;
   for ( ; index < cColumns - 1 ; index++ )
   {
       // Add the bind marking and delimiting comma between columns.
       //
       lstrcatA(szBuffer, " ? ,") ;
   }
   lstrcatA(szBuffer, "? )") ;

   VERIFY_BUFFER(szBuffer, INSERT_BUFFER_LEN) ;

   RETCODE  sqlstatus ;

   // Create a new statement.
   //
	ASSERT(!m_pInsertStatement) ;
	m_pInsertStatement = new CMQDBOdbcSTMT(m_hConnection) ;
   ASSERT(m_pInsertStatement) ;

   // Prepare the "INSERT" statement.
   //
	m_pInsertStatement->Allocate(szBuffer);
	sqlstatus = m_pInsertStatement->Prepare();

   dbstatus = CheckSqlStatus( sqlstatus, m_pInsertStatement ) ;
   if (dbstatus != MQDB_OK)
   {
      DeletePreparedInsert() ;
   }

   return dbstatus ;
}

//***********************************************************************
//
//  MQDBSTATUS CMQODBCTable::FormatInsertData
//
//  Format the data into the command string for direct insert.
//  If data need binding then replace it with the '?' mark and bind.
//
//  Input
//  =====
//
//***********************************************************************

MQDBSTATUS CMQODBCTable::FormatInsertData(
                                 IN MQDBCOLUMNVAL  *pColumnVal,
                                 IN LONG           cColumns,
                                 IN LPSTR          lpszBuffer,
	                              IN CMQDBOdbcSTMT  *pStatement)
{
   MQDBSTATUS dbstatus = MQDB_OK ;

   LONG index = 0 ;
   int nBind = 1 ;

   for ( ; index < cColumns ; index++ )
   {
      dbstatus = FormatDirectData( pColumnVal,
                                   &nBind,
                                   lpszBuffer,
	                               pStatement);
      if (dbstatus != MQDB_OK)
      {
         break ;
      }
      pColumnVal++ ;
   }

   int nLen = lstrlenA(lpszBuffer) ;
   lpszBuffer[ nLen-1 ] = ')' ;

   return dbstatus ;
}

//***********************************************************************
//
//  MQDBSTATUS CMQODBCTable::DirectInsertExec
//
// Insert a new record in the table. Direct execution without prepare.
//
//***********************************************************************

MQDBSTATUS CMQODBCTable::DirectInsertExec(
                          IN MQDBCOLUMNVAL     aColumnVal[],
                          IN LONG              cColumns)
{
   MQDBSTATUS dbstatus = MQDB_OK ;

   // format the command line.
   DECLARE_BUFFER(szBuffer, INSERT_BUFFER_LEN) ;

   dbstatus =  FormatInsertCmd( aColumnVal,
                                cColumns,
                                szBuffer ) ;
   if (dbstatus != MQDB_OK)
   {
      return dbstatus ;
   }

   //
   // Create a new statement.
   //
    CMQDBOdbcSTMT *pStatement = new CMQDBOdbcSTMT(m_hConnection) ;
    ASSERT(pStatement) ;
    P<CMQDBOdbcSTMT> p(pStatement) ; // AutoDelete pointer.
    pStatement->Allocate(NULL);

    dbstatus = FormatInsertData( aColumnVal,
                                cColumns,
                                szBuffer,
                                pStatement);
    if (dbstatus != MQDB_OK)
    {
      return dbstatus ;
    }

    VERIFY_BUFFER(szBuffer, INSERT_BUFFER_LEN) ;

    //
    // Execute the "INSERT" statement.
    //
    RETCODE  sqlstatus = pStatement->Execute( szBuffer );
    return CheckSqlStatus( sqlstatus, pStatement ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqdbodbc\tblodbc.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		tblodbc.cpp

Abstract:
   Implement the database table class for use with ODBC drivers.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      11-Jan-96   Adapted and updated for the mqdbmgr dll.

--*/

#include "dbsys.h"
#include "tblodbc.h"
#include "dbodbc.h"

#include "tblodbc.tmh"

// Constructor
CMQODBCTable::CMQODBCTable()
							: m_hConnection(SQL_NULL_HDBC),
                       m_hDatabase(NULL),
                       m_lpszTableName(NULL)
{
	m_pInsertStatement = NULL ;
	m_pDeleteStatement = NULL ;
	m_pUpdateStatement = NULL ;
}

// Constructor
CMQODBCTable::CMQODBCTable( MQDBHANDLE hDatabase )
							: m_hConnection(SQL_NULL_HDBC),
                       m_hDatabase(hDatabase),
                       m_lpszTableName(NULL)
{
	m_pInsertStatement = NULL ;
	m_pDeleteStatement = NULL ;
	m_pUpdateStatement = NULL ;
}

// Destructor
CMQODBCTable::~CMQODBCTable()
{
   ASSERT(!m_lpszTableName) ;
   ASSERT(!m_pInsertStatement) ;
   ASSERT(!m_pDeleteStatement) ;
   ASSERT(!m_pUpdateStatement) ;
}

// Init the table object.
MQDBSTATUS CMQODBCTable::Init(IN MQDBHANDLE hDatabase,
                              IN LPSTR      lpszTableName)
{
   CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) hDatabase ;
   if (!pDatabase) {
      return MQDB_E_BAD_HDATABASE ;
   }
   m_hDatabase = hDatabase ;

   MQDBSTATUS dbstatus = MQDB_E_UNKNOWN ;
   HSTMT  hStmt = SQL_NULL_HSTMT ;
   RETCODE sqlstatus ;

   try
   {
      m_hConnection = pDatabase->GethDbc() ;

      // Check if table exist.
      // First allocate a statement.
      sqlstatus = ::SQLAllocStmt(m_hConnection, &hStmt) ;
		if (!ODBC_SUCCESS(sqlstatus)) {
         dbstatus = MQDB_E_OUTOFMEMORY ;
         goto endtry ;
      }

      // Next, look for the columns names
      sqlstatus = ::SQLColumns(hStmt,
                            NULL, 0,              /* All qualifiers */
                            NULL, 0,              /* All owners     */
                (UCHAR *)lpszTableName, SQL_NTS,  /* table name     */
                            NULL, 0);             /* All columns    */
      dbstatus = CheckSqlStatus( sqlstatus, NULL, hStmt) ;
		if (dbstatus != MQDB_OK)
      {
         goto endtry ;
      }

      //
      // Next, try to fetch the columns names
      //
      sqlstatus = ::SQLFetch(hStmt) ;
      if (sqlstatus == SQL_NO_DATA_FOUND)
      {
         //
         // Table doesn't exist.
         //
         dbstatus = MQDB_E_TABLE_NOT_FOUND ;
         goto endtry ;
      }
      else if (sqlstatus != SQL_SUCCESS)
      {
         dbstatus = CheckSqlStatus( sqlstatus, NULL, hStmt) ;
	   	ASSERT(dbstatus != MQDB_OK) ;
         goto endtry ;
      }

      m_lpszTableName = new char[ 1 + lstrlenA(lpszTableName) ];
      lstrcpyA(m_lpszTableName, lpszTableName) ;
      dbstatus = MQDB_OK ;
   }
   catch(...)
   {
   }
endtry:

   if (hStmt != SQL_NULL_HSTMT) {
      sqlstatus = ::SQLFreeStmt(hStmt, SQL_DROP) ;
	   if (!ODBC_SUCCESS(sqlstatus)) {
         if (dbstatus == MQDB_OK) {
            dbstatus = MQDB_E_DATABASE ;
         }
      }
   }

   return dbstatus ;
}

// Close the table object.
MQDBSTATUS CMQODBCTable::Close()
{
   delete m_lpszTableName ;
   m_lpszTableName = NULL ;
   if (m_pInsertStatement)
   {
      delete m_pInsertStatement ;
      m_pInsertStatement = NULL ;
   }
   if (m_pUpdateStatement)
   {
      delete m_pUpdateStatement ;
      m_pUpdateStatement = NULL ;
   }
   if (m_pDeleteStatement)
   {
      delete m_pDeleteStatement ;
      m_pDeleteStatement = NULL ;
   }
   return MQDB_OK ;
}

//********************************************************************
//
//  MQDBSTATUS CMQODBCTable::DeleteRecord
//
// Delete records from the table.
//
//********************************************************************

#define  DELETE_BUFFER_LEN  1024

MQDBSTATUS CMQODBCTable::DeleteRecord(
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition,
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere)
{
   MQDBSTATUS dbstatus = MQDB_OK ;
   DECLARE_BUFFER(szBuffer, DELETE_BUFFER_LEN) ;

   wsprintfA(szBuffer, "DELETE FROM %s", m_lpszTableName) ;

   //
   // Create a new statement.
   //
	CMQDBOdbcSTMT *pStatement = new CMQDBOdbcSTMT( m_hConnection ) ;
   ASSERT(pStatement) ;
   P<CMQDBOdbcSTMT> p(pStatement) ; // AutoDelete pointer.
	pStatement->Allocate(NULL) ;

   if (lpszSearchCondition)
   {
      lstrcatA( szBuffer, " WHERE ") ;
      lstrcatA( szBuffer, lpszSearchCondition) ;
   }
   else if (!pWhereColumnSearch)
   {
      return  MQDB_E_INVALID_DATA ;
   }
   else
   {
      int nBind = 1 ;
      dbstatus = FormatOpWhereString( pWhereColumnSearch,
                                      cWhere,
                                      opWhere,
                                      &nBind,
                                      pStatement,
                                      szBuffer ) ;
      RETURN_ON_ERROR ;
   }

   VERIFY_BUFFER(szBuffer, DELETE_BUFFER_LEN) ;

   return ExecWhereStatement( szBuffer,
                              pWhereColumnSearch,
                              cWhere,
	                           pStatement) ;
}

#undef  DELETE_BUFFER_LEN

//********************************************************************
//
//  MQDBSTATUS CMQODBCTable::Truncate
//
// Truncate the table (delete all rows)
//
//********************************************************************

#define  TRUNCATE_BUFFER_LEN  128

MQDBSTATUS CMQODBCTable::Truncate()
{
   DECLARE_BUFFER(szBuffer, TRUNCATE_BUFFER_LEN) ;
   wsprintfA(szBuffer, "TRUNCATE TABLE %s", m_lpszTableName) ;

   //
   // Create a new statement.
   //
	CMQDBOdbcSTMT *pStatement = new CMQDBOdbcSTMT( m_hConnection ) ;
   ASSERT(pStatement) ;
   P<CMQDBOdbcSTMT> p(pStatement) ; // AutoDelete pointer.
	pStatement->Allocate(szBuffer) ;

	RETCODE sqlstatus = pStatement->Execute();
   MQDBSTATUS dbstatus =  CheckSqlStatus( sqlstatus, pStatement) ;
   return dbstatus ;
}

//-----------------------------------------------------
//
//  MQDBSTATUS CMQODBCTable::GetCount()
//
//-----------------------------------------------------

#define  COUNT_BUFFER_LEN  512

MQDBSTATUS CMQODBCTable::GetCount( IN UINT *puCount,
                                   IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                                   IN LONG               cWhere,
                                   IN MQDBOP             opWhere)
{
   *puCount = 0 ;
   MQDBSTATUS  dbstatus = MQDB_OK ;
   //
   // Create a new statement.
   //
   CMQDBOdbcSTMT *pStatement = new CMQDBOdbcSTMT( m_hConnection ) ;
   ASSERT(pStatement) ;
   P<CMQDBOdbcSTMT> p(pStatement) ; // AutoDelete pointer.

   //
   // Execute the command
   //
   DECLARE_BUFFER(szBuffer, COUNT_BUFFER_LEN) ;

   lstrcatA(szBuffer, "SELECT count(*) from ") ;
   lstrcatA(szBuffer, m_lpszTableName) ;

   pStatement->Allocate(NULL) ;

   if (pWhereColumnSearch)
   {
      int nBind = 1 ;
      dbstatus = FormatOpWhereString( pWhereColumnSearch,
                                      cWhere,
                                      opWhere,
                                      &nBind,
                                      pStatement,
                                      szBuffer) ;
   }

   RETCODE sqlstatus = pStatement->Execute(szBuffer);

   if (ODBC_SUCCESS(sqlstatus) || ODBC_SUCCESS_WINFO(sqlstatus))
   {
      MQDBCOLUMNVAL  pColumns[2] ;

      int cColumns = 0 ;
      INIT_COLUMNVAL(pColumns[ cColumns ]) ;
      pColumns[ cColumns ].lpszColumnName = NULL ;
      pColumns[ cColumns ].nColumnValue   = NULL ;
      pColumns[ cColumns ].nColumnLength  = 0 ;
      pColumns[ cColumns ].mqdbColumnType = MQDB_LONG ;

      dbstatus = pStatement->RetrieveRecordData( pColumns, 1 ) ;

      if (dbstatus == MQDB_OK)
      {
         *puCount = pColumns[ 0 ].nColumnValue ;
      }
   }
   else
   {
      dbstatus = CheckSqlStatus( sqlstatus,
                                 pStatement ) ;
   }

   return dbstatus ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqdbodbc\odbcstmt.h ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		odbcstmt.h

Abstract:
	Define a statement class for implementing an ODBC statement.

	Class CMQDBOdbcSTMT


Author:
	Nir Ben-Zvi (nirb)
   Doron Juster (DoronJ)

Revisoins:
   NirB     1995        Create first version
   DoronJ   11-jan-96   Adopt for the mqdbmgr dll.
--*/

#ifndef __ODBCSTMT_H__
#define __ODBCSTMT_H__

#include "mqdbodbc.h"

/*
 * CMQDBOdbcSTMT - A class implemeting an ODBC statement
 *
 */
class CMQDBOdbcSTMT
{
public:
	CMQDBOdbcSTMT() { ASSERT(0); }
	CMQDBOdbcSTMT(
					IN		HDBC			hConnection);
	~CMQDBOdbcSTMT();

	RETCODE Allocate(			// Initialize statement
					IN		char * 	szSqlString);

	RETCODE Deallocate(); 		// Terminate statement

	RETCODE ChangeSqlString(  // Changes the sql command string
					IN		char * 	szSqlString);

	RETCODE Prepare();        // Prepare the statement

	RETCODE Execute( IN LPSTR lpszCommand = NULL ) ; // Execute the statement

	RETCODE Fetch();			// fetch the next row

	RETCODE GetStringColumn( 	// Return a string column
					IN		DWORD	 	dwCol,
					OUT	char **	ppszOut,
					IN		DWORD	*	pdwSize);

	RETCODE GetBinaryColumn( 	// Return a binary column
					IN		DWORD	 	dwCol,
					OUT	char **	ppOut,
					IN		DWORD *	dwSize,
					IN		DWORD		dwOffset);

	RETCODE GetDwordColumn(		// Return a DWORD column
					IN		DWORD	 	dwCol,
					IN		DWORD *	pdwOut);

	RETCODE GetWordColumn(		// Return a DWORD column
					IN		DWORD	 	dwCol,
					IN		WORD *	pdwOut);

	RETCODE BindParameter(		// Bind a parameter to a prepared request
					IN		UDWORD	 	dwParameter,
					IN		SWORD		wCType,
					IN		SWORD		wSqlType,
					IN		UDWORD		dwPrecision,
					IN		UDWORD		dwSize,
					IN		PTR			pParameter,
					IN		SDWORD *	pcbValue);

	RETCODE GetDataTypeName(	// Return a data type name
					IN		SWORD	swType,
					OUT		char *	szBuffer,
					IN		DWORD	dwBufSize);

	RETCODE         EnableMultipleQueries( IN DWORD  dwDBMSType ) ;

	RETCODE         EnableNoLockQueries( IN DWORD  dwDBMSType ) ;

   inline HSTMT    GetHandle() { return m_hStatement ; }

	inline void     SetColumnsCount(LONG cColumns) { m_cColumns = cColumns ; }

   RETCODE         GetRowsCount(LONG *pCount) ;

   MQDBSTATUS      RetrieveRecordData( IN MQDBCOLUMNVAL   aColumnVal[],
                                       IN LONG            lColumns = 0 ) ;

   MQDBSTATUS      SetQueryTimeout( IN DWORD dwTimeout ) ;

private:
	RETCODE GetLargeColumn( 	// Return a binary or string column
               IN    SWORD    swType,
					IN		DWORD	 	dwCol,
					OUT	char **	ppOut,
					IN		DWORD *	dwSize,
					IN		DWORD		dwOffset);

	HDBC				m_hConnection;		// Connection handle
	HSTMT				m_hStatement;		// A statement to be used
	BOOL				m_fAllocated;		// TRUE if statement allocated
	BOOL				m_fPrepared;		// TRUE if prepare was done
	BOOL				m_fShouldFree;		// TRUE if statement should be freed when changing string

	char *			m_szSqlString;		// The sql command buffer
   LONG           m_cColumns ;      // number of columns, for query.
};

#endif   // __ODBCSTMT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqdbodbc\tbloupdt.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		tbloupdt.cpp

Abstract:
   Implement the update method for the database table class,
   for use with ODBC drivers.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      14-Feb-96   Adapted and updated for the mqdbmgr dll.

--*/

#include "dbsys.h"
#include "tblodbc.h"

#include "tbloupdt.tmh"

#define  UPDATE_BUFFER_LEN 1024

//****************************************************************
//
//  MQDBSTATUS CMQODBCTable::UpdateRecord
//
// Update a record.
//
//****************************************************************

MQDBSTATUS CMQODBCTable::UpdateRecord(
                        IN MQDBCOLUMNVAL     aColumnVal[],
                        IN LONG              cColumns,
                        IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                        IN LPSTR             lpszSearchCondition,
                        IN LONG              cWhere,
                        IN MQDBOP            opWhere,
                        IN OUT LPMQDBHANDLE  lphUpdate)
{
   MQDBSTATUS dbstatus ;

   if (!lphUpdate)
   {
      // Direct execution. Preparation not needed.
      //
      dbstatus = DirectUpdateExec(  aColumnVal,
                                    cColumns,
                                    pWhereColumnSearch,
                                    lpszSearchCondition,
                                    cWhere,
                                    opWhere ) ;
   }
   else if (!(*lphUpdate))
   {
      // Prepare for future use and execute.
      //
      dbstatus = PrepareUpdate(  aColumnVal,
                                 cColumns,
                                 pWhereColumnSearch,
                                 lpszSearchCondition,
                                 cWhere,
                                 opWhere ) ;
      if (dbstatus == MQDB_OK)
      {
         CMQDBOdbcSTMT *pStatement = m_pUpdateStatement ;
         ASSERT(pStatement) ;
         dbstatus = BindAndExecuteUpdate( pStatement,
                                          aColumnVal,
                                          cColumns,
                                          pWhereColumnSearch,
                                          lpszSearchCondition,
                                          cWhere,
                                          opWhere ) ;
         if (dbstatus == MQDB_OK)
         {
            *lphUpdate = (MQDBHANDLE) pStatement ;
         }
         else
         {
            // The execution failed. Delete the prepared statement.
            delete m_pUpdateStatement ;
            m_pUpdateStatement = NULL ;
         }
      }
   }
   else
   {
      // Use prepared statement. Bind and execute.
      //
      dbstatus = BindAndExecuteUpdate( (CMQDBOdbcSTMT *)(*lphUpdate),
                                       aColumnVal,
                                       cColumns,
                                       pWhereColumnSearch,
                                       lpszSearchCondition,
                                       cWhere,
                                       opWhere ) ;
   }

   return  dbstatus ;
}

//***********************************************************
//
//  MQDBSTATUS  CMQODBCTable::FormatUpdateCmd
//
//  Format a SQL Update command.
//
//  Input:
//  ======
//  fPrepared    - TRUE if prepared statement.
//  aColumnVal[] - Array of MQDBCOLUMNVAL
//  cColumns     - number of columns in the array
//  szBufer      - buffer for the string
//
//  Output:
//  =======
//  MQDB_OK if format succeeded.
//
//************************************************************

MQDBSTATUS  CMQODBCTable::FormatUpdateCmd(
                             IN MQDBCOLUMNVAL   aColumnVal[],
                             IN LONG            cColumns,
                             IN OUT int*        pBind,
	                          IN CMQDBOdbcSTMT   *pStatement,
                             IN OUT LPSTR       lpBuffer )
{
   MQDBSTATUS dbstatus = MQDB_OK ;
   wsprintfA(lpBuffer, "UPDATE %s SET ", m_lpszTableName) ;

   LONG index = 0 ;

   for ( ; index < cColumns ; index++ )
   {
      lstrcatA( lpBuffer, aColumnVal[ index].lpszColumnName ) ;
      if (!pStatement)
      {
         lstrcatA( lpBuffer, " = ?," ) ;
      }
      else
      {
         lstrcatA( lpBuffer, " = " ) ;
         dbstatus = FormatDirectData( &aColumnVal[ index ],
                                      pBind,
                                      lpBuffer,
                                      pStatement ) ;
         if (dbstatus != MQDB_OK)
         {
            return dbstatus ;
         }
      }
   }

   int nLen = lstrlenA(lpBuffer) ;
   lpBuffer[ nLen-1 ] = '\0' ;

   return dbstatus ;
}

//************************************************************
//
//  MQDBSTATUS CMQODBCTable::DirectUpdateExec
//
//  Update a record in the table. Direct execution.
//
//************************************************************

MQDBSTATUS CMQODBCTable::DirectUpdateExec(
                                 IN MQDBCOLUMNVAL     aColumnVal[],
                                 IN LONG              cColumns,
                                 IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                                 IN LPSTR             lpszSearchCondition,
                                 IN LONG              cWhere,
                                 IN MQDBOP            opWhere )
{
   MQDBSTATUS dbstatus = MQDB_OK ;

   // format the command line.
   DECLARE_BUFFER(szBuffer, UPDATE_BUFFER_LEN) ;

   //
   // Create a new statement.
   //
	CMQDBOdbcSTMT *pStatement = new CMQDBOdbcSTMT( m_hConnection) ;
   ASSERT(pStatement) ;
   P<CMQDBOdbcSTMT> p(pStatement) ; // AutoDelete pointer.
	pStatement->Allocate(NULL) ;

   int  nBind = 1 ;
   dbstatus =  FormatUpdateCmd( aColumnVal,
                                cColumns,
                                &nBind,
                                pStatement,
                                szBuffer ) ;
   RETURN_ON_ERROR ;

   if (lpszSearchCondition)
   {
      lstrcatA(szBuffer, " WHERE ") ;
      lstrcatA(szBuffer, lpszSearchCondition) ;
   }
   else if (pWhereColumnSearch)
   {
      dbstatus = FormatOpWhereString( pWhereColumnSearch,
                                      cWhere,
                                      opWhere,
                                      &nBind,
                                      pStatement,
                                      szBuffer ) ;
      RETURN_ON_ERROR ;
   }

   VERIFY_BUFFER(szBuffer, UPDATE_BUFFER_LEN) ;

   //
   // Execute the "UPDATE" statement.
   //
   dbstatus = ExecuteUpdate( pStatement, szBuffer ) ;
   return dbstatus ;
}

//*********************************************************************
//
// Execute a prepared UPDATE statement.
//
//*********************************************************************

MQDBSTATUS CMQODBCTable::BindAndExecuteUpdate(
	                     IN CMQDBOdbcSTMT    *pStatement,
                        IN MQDBCOLUMNVAL     aColumnVal[],
                        IN LONG              cColumns,
                        IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                        IN LPSTR             lpszSearchCondition,
                        IN LONG              cWhere,
                        IN MQDBOP            opWhere )
{
    UNREFERENCED_PARAMETER(lpszSearchCondition);
    UNREFERENCED_PARAMETER(opWhere);

    // First bind the parameters.
   MQDBSTATUS dbstatus = MQDB_OK ;
   LONG index = 1 ;

   for ( ; index <= cColumns ; index++ )
   {
       dbstatus = BindParameter( index,
                                 &aColumnVal[ index - 1 ],
                                 pStatement) ;
       RETURN_ON_ERROR ;
   }

   if (pWhereColumnSearch)
   {
       index = cColumns + 1 ;
       dbstatus = BindWhere( index,
                             pWhereColumnSearch,
                             cWhere,
                             pStatement ) ;
       RETURN_ON_ERROR ;
   }

   // Next, execute.
   dbstatus = ExecuteUpdate( pStatement ) ;
   return dbstatus ;
}

//******************************************************************
//
// Prepare an UPDATE statement.
//
//******************************************************************

MQDBSTATUS CMQODBCTable::PrepareUpdate(
                              IN MQDBCOLUMNVAL     aColumnVal[],
                              IN LONG              cColumns,
                              IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                              IN LPSTR             lpszSearchCondition,
                              IN LONG              cWhere,
                              IN MQDBOP            opWhere )
{
   MQDBSTATUS dbstatus = MQDB_OK ;
   DECLARE_BUFFER(szBuffer, UPDATE_BUFFER_LEN) ;

   dbstatus =  FormatUpdateCmd( aColumnVal,
                                cColumns,
                                NULL,
                                NULL,
                                szBuffer ) ;
   RETURN_ON_ERROR ;

   if (lpszSearchCondition)
   {
      lstrcatA(szBuffer, " WHERE ") ;
      lstrcatA(szBuffer, lpszSearchCondition) ;
   }
   else if (pWhereColumnSearch)
   {
      dbstatus = FormatOpWhereString( pWhereColumnSearch,
                                      cWhere,
                                      opWhere,
                                      NULL,
                                      NULL,
                                      szBuffer ) ;
      RETURN_ON_ERROR ;
   }

   VERIFY_BUFFER(szBuffer, UPDATE_BUFFER_LEN) ;

   RETCODE  sqlstatus ;

   // Create a new statement.
   //
	ASSERT(!m_pUpdateStatement) ;
	m_pUpdateStatement = new CMQDBOdbcSTMT( m_hConnection) ;
	ASSERT(m_pUpdateStatement) ;

   // Prepare the "UPDATE" statement.
   //
	m_pUpdateStatement->Allocate(szBuffer);
	sqlstatus = m_pUpdateStatement->Prepare();

   dbstatus = CheckSqlStatus( sqlstatus, m_pUpdateStatement) ;
   if (dbstatus != MQDB_OK)
   {
	   delete m_pUpdateStatement ;
	   m_pUpdateStatement = NULL ;
   }

   return dbstatus ;
}

//********************************************************************
//
//  MQDBSTATUS CMQODBCTable::ExecuteUpdate
//
// Execute the update and set the return code.
// If no record was updated then error "MQDB_E_NO_ROW_UPDATED" is returned.
//
//********************************************************************

MQDBSTATUS CMQODBCTable::ExecuteUpdate( IN CMQDBOdbcSTMT *pStatement,
                                        IN LPSTR         lpszCommand )
{
	RETCODE sqlstatus = pStatement->Execute(lpszCommand);

   MQDBSTATUS dbstatus = CheckSqlStatus( sqlstatus, pStatement ) ;
   if (dbstatus == MQDB_OK)
   {
      LONG lCount ;
      sqlstatus = pStatement->GetRowsCount(&lCount) ;
      if (ODBC_SUCCESS(sqlstatus))
      {
         if (lCount == 0)
         {
            //
            // No row was updated. We consider this an error, although
            // SQL semantic consider this as success.
            //
            dbstatus = MQDB_E_NO_ROW_UPDATED ;
         }
      }
   }

   return dbstatus ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqdbodbc\tbloutil.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		tbloutil.cpp

Abstract:
   Implement utility methods for the database table class,
   for use with ODBC drivers.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      14-Feb-96   Adapted and updated for the mqdbmgr dll.

--*/

#include "dbsys.h"
#include "dbodbc.h"
#include "tblodbc.h"

#include "tbloutil.tmh"

MQDBSTATUS CMQODBCTable::CheckSqlStatus(
                             IN RETCODE        sqlError,
	                          IN CMQDBOdbcSTMT  *pStatement,
                             IN HSTMT          hStmtIn /* SQL_NULL_HSTMT */ )
{
   MQDBSTATUS dbstatus = MQDB_OK ;

   if (!ODBC_SUCCESS(sqlError))
   {
      CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) m_hDatabase ;
      ASSERT(pDatabase) ;
      dbstatus = pDatabase->CheckSqlStatus( sqlError,
	                                         pStatement,
                                            hStmtIn ) ;
   }

   return dbstatus ;
}


//***********************************************************************
//
//  MQDBSTATUS CMQODBCTable::FormatDirectData
//
//  Format the data into the command string of a direct execution string.
//  If data need binding then replace it with the '?' mark and bind.
//
//  Input
//  =====
// int* nBind- index for binding. Incremented here if binding was done.
//
//***********************************************************************

MQDBSTATUS CMQODBCTable::FormatDirectData(
                                 IN MQDBCOLUMNVAL  *pColumnVal,
                                 IN int*           pBind,
                                 IN LPSTR          lpszBuffer,
	                              IN CMQDBOdbcSTMT  *pStatement)
{
   MQDBSTATUS dbstatus = MQDB_OK ;

   switch (pColumnVal->mqdbColumnType)
   {
      case MQDB_SHORT:
      case MQDB_LONG:
      case MQDB_IDENTITY:
      {
          char szTmpBuff[ 24 ] ;
          wsprintfA(szTmpBuff, "%ld,", pColumnVal->nColumnValue) ;
          lstrcatA(lpszBuffer, szTmpBuff) ;
          break ;
      }

      case MQDB_STRING:
      {
          lstrcatA(lpszBuffer, "'") ;
          lstrcatA(lpszBuffer, (LPSTR) pColumnVal->nColumnValue) ;
          lstrcatA(lpszBuffer, "',") ;
          break ;
      }

      default:
      {
          lstrcatA(lpszBuffer, "?,") ;
          ASSERT(pBind) ;
          dbstatus = BindParameter( *pBind,
                                    pColumnVal,
                                    pStatement) ;
          RETURN_ON_ERROR ;
          (*pBind)++ ;
          break ;
      }
   }

   return dbstatus ;
}

/***********************************************************
*
*  BOOL  CMQODBCTable::FormatOpWhereString
*
*  Format a "WHERE" string for a SELECT, UPDATE or DELETE.
*
* Input:
* ======
* IN pWhereColumnSearch - poitner to a search structure.
* IN cWhere - Number of search conditions in the Where arrary.
* IN opWhere - Operation to be performed between the conditions (AND or OR).
* IN OUT  lpszBuf - buffer to contain the string. The string prepared
*                   by this function is catenated to the present content
*                   of lpszBuf.
*
* Output:
* =======
* TRUE if one of the value must be bound before execution.
*
************************************************************/

MQDBSTATUS  CMQODBCTable::FormatOpWhereString(
                           IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                           IN DWORD             cWhere,
                           IN MQDBOP            opWhere,
                           IN OUT  int*         pBind,
	                        IN CMQDBOdbcSTMT     *pStatement,
                           IN OUT LPSTR         lpszBuf )
{
   ASSERT((opWhere == AND) || (opWhere == OR)) ;

   MQDBSTATUS dbstatus = MQDB_OK ;

   lstrcatA( lpszBuf, " WHERE ") ;

   DWORD index = 0 ;
   for ( ; index < cWhere ; index++ )
   {
      lstrcatA(lpszBuf, " (") ;
      lstrcatA(lpszBuf, pWhereColumnSearch->mqdbColumnVal.lpszColumnName) ;

      switch (pWhereColumnSearch->mqdbColumnVal.mqdbColumnType)
      {
         case MQDB_STRING:
            lstrcatA( lpszBuf,
                         dbODBCOpNameStr[ pWhereColumnSearch->mqdbOp ] ) ;
            lstrcatA( lpszBuf,
                  (LPSTR) pWhereColumnSearch->mqdbColumnVal.nColumnValue) ;
            break ;

         case MQDB_SHORT:
         case MQDB_LONG:
         case MQDB_IDENTITY:
         {
            char szTmpBuff[ 24 ] ;
            lstrcatA( lpszBuf,
                         dbODBCOpNameStr[ pWhereColumnSearch->mqdbOp ] ) ;
            wsprintfA( szTmpBuff, "%ld)",
                         pWhereColumnSearch->mqdbColumnVal.nColumnValue) ;
            lstrcatA( lpszBuf, szTmpBuff) ;
            break ;
         }

         default:
         {
            // bind the "where".
            //
            MQDBCOLUMNTYPE cType =
                       pWhereColumnSearch->mqdbColumnVal.mqdbColumnType ;
            if ((dbODBCSQLTypes[ cType ] == SQL_LONGVARBINARY) &&
              pWhereColumnSearch->mqdbOp == EQ)
            {
               lstrcatA( lpszBuf, " LIKE ?)") ;
            }
            else
            {
               lstrcatA( lpszBuf,
                         dbODBCOpNameStr[ pWhereColumnSearch->mqdbOp ] ) ;
               lstrcatA( lpszBuf, "?)") ;
            }

            if (pStatement)
            {
               // Bind
               //
               ASSERT(pBind) ;
               dbstatus = BindParameter( *pBind,
                                      &pWhereColumnSearch->mqdbColumnVal,
                                      pStatement) ;
               RETURN_ON_ERROR ;
               (*pBind)++ ;
            }
         }
      }

      if (index < (cWhere - 1))
      {
         lstrcatA( lpszBuf, dbODBCOpNameStr[ opWhere ]) ;
      }
      pWhereColumnSearch++ ;
   }

   return dbstatus ;
}

/*************************************************************************
*
*  ExecWhereStatement
*
*  Execute a statement with a WHERE clause. Only for SELECT or DELETE.
*  UPDATE is done differently, because its statement may already be
*  prepared and the updated values must be bound.
*
**************************************************************************/

MQDBSTATUS  CMQODBCTable::ExecWhereStatement(
                                       IN LPSTR            lpszBuf,
                                       IN MQDBCOLUMNSEARCH *pColSearch,
                                       IN DWORD            cWhere,
                                       IN CMQDBOdbcSTMT    *pStatement )
{
    UNREFERENCED_PARAMETER(cWhere);
    UNREFERENCED_PARAMETER(pColSearch);

   ASSERT(pStatement) ;

   RETCODE  sqlstatus ;
   MQDBSTATUS dbstatus = MQDB_OK ;

   CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) m_hDatabase ;
   ASSERT(pDatabase) ;
   if ( pDatabase->GetMultipleQueriesState() )
   {
      DWORD dwDBMSType = pDatabase->GetDMBSType() ;
      RETCODE st = pStatement->EnableMultipleQueries( dwDBMSType ) ;
      DBG_USED(st);
      ASSERT( st == SQL_SUCCESS ) ;
   }

   sqlstatus = pStatement->Execute(lpszBuf);
   if (!ODBC_SUCCESS(sqlstatus))
   {
      SDWORD  sdwNativeError ;
      UCHAR   szSqlState[SQLSTATELEN];

      if ( !OdbcStateIsEx( m_hConnection,
                           pStatement->GetHandle(),
                           OERR_SQL_OPTION_CHANGED,
                           &sdwNativeError,
                           szSqlState ))
      {
         if (!lstrcmpA((const char *)szSqlState, OERR_DBMS_NOT_AVAILABLE))
         {
            dbstatus = MQDB_E_DBMS_NOT_AVAILABLE ;
         }
         else
         {
            ASSERT( sqlstatus != SQL_SUCCESS_WITH_INFO ) ;
            dbstatus = pDatabase->GetDBStatus( sdwNativeError,
                                               szSqlState ) ;
            if (dbstatus == MQDB_OK)
            {
               dbstatus = MQDB_E_DATABASE ;
            }
         }
      }
      else
      {
         //
         // SQL server change the cursor type. This is OK!.
         //
         ASSERT( sqlstatus == SQL_SUCCESS_WITH_INFO ) ;
         ASSERT( (pDatabase->GetMultipleQueriesState()) ||
                 (pDatabase->GetNoLockQueriesState()) ) ;
      }
   }

   return dbstatus ;
}

//*****************************************************************
//
//  MQDBSTATUS CMQODBCTable::BindParameter
//
// Bind a parameter
//
//*****************************************************************

MQDBSTATUS CMQODBCTable::BindParameter( IN LONG           index,
                                        IN MQDBCOLUMNVAL  *pColumnVal,
                                        IN CMQDBOdbcSTMT  *pStatement)
{
   ASSERT(pColumnVal->cbSize == 24) ;

   RETCODE sqlstatus ;
   SWORD fSqlType = dbODBCSQLTypes[ pColumnVal->mqdbColumnType ] ;
   switch (fSqlType)
   {
      case SQL_SMALLINT:
      case SQL_INTEGER:
      {
         sqlstatus = pStatement->BindParameter( (UDWORD) index,
                                                SQL_C_DEFAULT,
                                                fSqlType,
              dbODBCPrecision[ pColumnVal->mqdbColumnType ],
                               pColumnVal->nColumnLength,
                               (PTR) &(pColumnVal->nColumnValue),
                               (SDWORD *) NULL) ;
         break ;
      }

      default:
      {
         SDWORD  *sdSize = (SDWORD *) &(pColumnVal->dwReserve_A) ;
         *sdSize = pColumnVal->nColumnLength ;
         sqlstatus = pStatement->BindParameter( (UDWORD) index,
                                                SQL_C_DEFAULT,
                                                fSqlType,
                                        pColumnVal->nColumnLength,
                                        pColumnVal->nColumnLength,
                                        (PTR) pColumnVal->nColumnValue,
                                                sdSize) ;
         break ;
      }
   }
   if (!ODBC_SUCCESS(sqlstatus))
   {
       MQDBSTATUS dbstatus = MQDB_E_DATABASE ;
       if (OdbcStateIs( m_hConnection, pStatement->GetHandle(),
                                                     OERR_DBMS_NOT_AVAILABLE))
       {
          dbstatus = MQDB_E_DBMS_NOT_AVAILABLE ;
       }
       return dbstatus ;
   }
   return MQDB_OK ;
}

MQDBSTATUS CMQODBCTable::BindWhere( IN LONG             index,
                                    IN MQDBCOLUMNSEARCH *pColSearch,
                                    IN LONG             cWhere,
                                    IN CMQDBOdbcSTMT    *pStatement )
{
   MQDBSTATUS dbstatus = MQDB_OK ;
   LONG windex = 0 ;
   for ( ; windex < cWhere ; windex++ )
   {
      if (TypeMustBind(pColSearch->mqdbColumnVal.mqdbColumnType))
      {
         dbstatus = BindParameter( index,
                                   &(pColSearch->mqdbColumnVal),
                                   pStatement) ;
         if (dbstatus != MQDB_OK)
         {
            return dbstatus ;
         }
         index++ ;
      }
      pColSearch++ ;
   }
   return dbstatus ;
}


MQDBSTATUS CMQODBCTable::UpdateStatistics()
{
   char szCommand[128] = {"UPDATE STATISTICS "} ;
   lstrcatA(szCommand,  m_lpszTableName) ;

   CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) m_hDatabase ;
   return  pDatabase->Escape( szCommand ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqdbodbc\tblodbc.h ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		tblodbc.h

Abstract:
   Define a database table class, for use with ODBC drivers.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      11-Jan-96   Created

--*/

#ifndef __TBLODBC_H__
#define __TBLODBC_H__

#include "mqdbodbc.h"
#include "odbcstmt.h"

class CMQODBCTable
{
public:
   CMQODBCTable() ;   // Constructor.
   CMQODBCTable( MQDBHANDLE hDatabase ) ;   // Constructor.
   ~CMQODBCTable() ;  // Destructor.

   MQDBSTATUS  Init(IN MQDBHANDLE hDatabase,
                    IN LPSTR      lpszTableName) ;
   MQDBSTATUS  Close() ;

   MQDBSTATUS  DirectInsertExec( IN MQDBCOLUMNVAL     aColumnVal[],
                                 IN LONG              cColumns) ;

   MQDBSTATUS  ExecuteInsert(
	                     IN CMQDBOdbcSTMT    *pStatement,
                        IN MQDBCOLUMNVAL     aColumnVal[],
                        IN LONG              cColumns) ;

   MQDBSTATUS  PrepareInsert( IN MQDBCOLUMNVAL     aColumnVal[],
                              IN LONG              cColumns) ;

   inline void DeletePreparedInsert() ;

   MQDBSTATUS  Truncate() ;

   MQDBSTATUS  UpdateRecord(
                        IN MQDBCOLUMNVAL     aColumnVal[],
                        IN LONG              cColumns,
                        IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                        IN LPSTR             lpszSearchCondition,
                        IN LONG              cWhere,
                        IN MQDBOP            opWhere,
                        IN OUT LPMQDBHANDLE  lphUpdate) ;

   MQDBSTATUS  DeleteRecord(
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition,
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere) ;

   MQDBSTATUS  OpenQuery(
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition,
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere,
                     IN LPMQDBSEARCHORDER lpOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout = 0) ;

   MQDBSTATUS  OpenAggrQuery(
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN MQDBAGGR          mqdbAggr,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition,
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere,
                     IN DWORD             dwTimeout = 0) ;

   MQDBSTATUS  OpenJoin(
                     IN MQDBHANDLE        hDatabase,
                     IN LPSTR             lpszLeftTableName,
                     IN LPSTR             lpszRightTableName,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cLefts,
                     IN LONG              cRights,
                     IN LPMQDBJOINOP      opJoin,
                     IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                     IN LONG              cWhereLeft,
                     IN LONG              cWhereRight,
                     IN MQDBOP            opWhere,
                     IN LPMQDBSEARCHORDER pOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout = 0) ;

   MQDBSTATUS  UpdateStatistics() ;

   MQDBSTATUS  GetCount(IN UINT              *puCount,
                        IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                        IN LONG               cWhere,
                        IN MQDBOP             opWhere) ;

protected:
	CMQDBOdbcSTMT *  GetInsertStmt() { return m_pInsertStatement ; }

   friend MQDBSTATUS APIENTRY  MQDBInsertRecord(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN OUT LPMQDBHANDLE  lphInsert) ;

private:
   MQDBSTATUS  BindParameter( IN LONG           index,
                              IN MQDBCOLUMNVAL  *pColumnCal,
                              IN CMQDBOdbcSTMT  *pStatement) ;

   MQDBSTATUS  FormatDirectData(  IN MQDBCOLUMNVAL  *pColumnVal,
                                  IN int*           pBind,
                                  IN LPSTR          lpszBuffer,
	                               IN CMQDBOdbcSTMT  *pStatement) ;

   void        FormatOrderString( IN LPSTR szBuffer,
                                  IN LPMQDBSEARCHORDER pOrder,
                                  IN LONG              cOrders ) ;

   MQDBSTATUS  FormatOpWhereString(
                           IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                           IN DWORD             cWhere,
                           IN MQDBOP            opWhere,
                           IN OUT int *         pBind,
	                        IN CMQDBOdbcSTMT     *pStatement,
                           IN OUT LPSTR         lpszBuf ) ;

   MQDBSTATUS  FormatJoinWhereString(
                           IN LPSTR             lpszLeftTableName,
                           IN LPSTR             lpszRightTableName,
                           IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                           IN DWORD             cWhereLeft,
                           IN DWORD             cWhereRight,
                           IN MQDBOP            opWhere,
                           IN OUT int *         pBind,
                        	IN CMQDBOdbcSTMT     *pStatement,
                           IN OUT LPSTR         lpszBuf) ;

   MQDBSTATUS  FormatDirectJoinData(
                            IN LPSTR             lpszTableName,
                            IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                            IN OUT int *         pBind,
                            IN CMQDBOdbcSTMT     *pStatement,
                            IN OUT LPSTR         lpszBuf ) ;

   MQDBSTATUS  DirectUpdateExec( IN MQDBCOLUMNVAL     aColumnVal[],
                                 IN LONG              cColumns,
                                 IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                                 IN LPSTR             lpszSearchCondition,
                                 IN LONG              cWhere,
                                 IN MQDBOP            opWhere ) ;

   MQDBSTATUS  ExecuteUpdate( IN CMQDBOdbcSTMT *pStatement,
                              IN LPSTR         lpszCommand = NULL ) ;

   MQDBSTATUS  FormatUpdateCmd(
                             IN MQDBCOLUMNVAL   aColumnVal[],
                             IN LONG            cColumns,
                             IN OUT  int *      pBind,
	                          IN CMQDBOdbcSTMT   *pStatement,
                             IN OUT LPSTR       lpBuffer ) ;

   MQDBSTATUS  BindAndExecuteUpdate(
	                     IN CMQDBOdbcSTMT    *pStatement,
                        IN MQDBCOLUMNVAL     aColumnVal[],
                        IN LONG              cColumns,
                        IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                        IN LPSTR             lpszSearchCondition,
                        IN LONG              cWhere,
                        IN MQDBOP            opWhere ) ;

   MQDBSTATUS  PrepareUpdate( IN MQDBCOLUMNVAL     aColumnVal[],
                              IN LONG              cColumns,
                              IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                              IN LPSTR             lpszSearchCondition,
                              IN LONG              cWhere,
                              IN MQDBOP            opWhere ) ;

   MQDBSTATUS  ExecWhereStatement( IN LPSTR            lpszBuf,
                                   IN MQDBCOLUMNSEARCH *pColSearch,
                                   IN DWORD            cWhere,
	                                IN CMQDBOdbcSTMT    *pStatement ) ;

   MQDBSTATUS  BindWhere( IN LONG             index,
                          IN MQDBCOLUMNSEARCH *pColSearch,
                          IN LONG             cWhere,
                          IN CMQDBOdbcSTMT    *pStatement ) ;

   MQDBSTATUS  CreateQueryStatement(
                                 IN LPSTR             szBuffer,
                                 IN MQDBCOLUMNVAL     aColumnVal[],
                                 IN LONG              cVal,
                                 IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                                 IN LONG              cWhere,
                              	IN CMQDBOdbcSTMT     *pStatement,
                                 OUT LPMQDBHANDLE     phQuery,
                                 IN BOOL              fGetFirst) ;

   MQDBSTATUS  FormatInsertData( IN MQDBCOLUMNVAL  *pColumnVal,
                                 IN LONG           cColumns,
                                 IN LPSTR          lpszBuffer,
	                              IN CMQDBOdbcSTMT  *pStatement) ;

   MQDBSTATUS  CheckSqlStatus( IN RETCODE        sqlError,
	                            IN CMQDBOdbcSTMT  *pStatement,
                               IN HSTMT          hStmt = SQL_NULL_HSTMT ) ;

   MQDBSTATUS  FormatInsertCmd( IN MQDBCOLUMNVAL   aColumnVal[],
                                IN LONG            cColumns,
                                IN OUT LPSTR       lpBuffer ) ;

   MQDBHANDLE     m_hDatabase ;        // database handle
	HDBC				m_hConnection ;  		// Connection handle
   LPSTR          m_lpszTableName ;
	CMQDBOdbcSTMT *m_pInsertStatement ; // Prepared insert statement.
	CMQDBOdbcSTMT *m_pUpdateStatement ; // Prepared update statement.
	CMQDBOdbcSTMT *m_pDeleteStatement ;

} ;

//
// delete the prepared insert statement.
//
inline void CMQODBCTable::DeletePreparedInsert()
{
   ASSERT(m_pInsertStatement) ;
   delete m_pInsertStatement ;
   m_pInsertStatement = NULL ;
}

#endif // __TBLODBC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqdbodbc\tblquery.cpp ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
		tblquery.cpp

Abstract:
   Implement the query methods in the database table class,
   for use with ODBC drivers.

Author:
	Doron Juster (DoronJ)

Revisions:
   DoronJ      11-Aug-96   Created

--*/

#include "dbsys.h"
#include "tblodbc.h"
#include "dbodbc.h"

#include "tblquery.tmh"

#define QUERY_BUFFER_LEN  1024
#define JOIN_BUFFER_LEN   2048

//*******************************************************************
//
//  MQDBSTATUS CMQODBCTable::OpenQuery
//
// Query and get records from the database.
//
//*******************************************************************

MQDBSTATUS CMQODBCTable::OpenQuery(
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition,
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere,
                     IN LPMQDBSEARCHORDER lpOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout )
{
   MQDBSTATUS dbstatus = MQDB_OK ;

   //
   // Check validity of parameters.
   //
   if (cColumns < 0)
   {
      return MQDB_E_BAD_CCOLUMNS ;
   }
   else if (fGetFirst)
   {
      if (!aColumnVal)
      {
         return MQDB_E_INVALID_DATA ;
      }
   }
   else if (!phQuery)
   {
      return MQDB_E_INVALID_DATA ;
   }

   //
   // Parameters are valid. Format the query command.
   //
   DECLARE_BUFFER(szBuffer, QUERY_BUFFER_LEN) ;

   lstrcatA(szBuffer, "SELECT ") ;
   if (!aColumnVal || !aColumnVal[0].lpszColumnName)
   {
      // Retrieve all columns.
      //
      lstrcatA(szBuffer, " *") ;
   }
   else
   {
      LONG index ;
      for ( index = 0 ; index < cColumns ; index++ )
      {
         lstrcatA( szBuffer, aColumnVal[ index ].lpszColumnName) ;
         lstrcatA( szBuffer, ", ") ;
      }
      int nLen = lstrlenA(szBuffer) ;
      szBuffer[ nLen - 2 ] = '\0' ;
   }
   lstrcatA( szBuffer, " FROM " ) ;
   lstrcatA( szBuffer, m_lpszTableName ) ;

   //
   // Create a new statement.
   //
	CMQDBOdbcSTMT *pStatement = new CMQDBOdbcSTMT( m_hConnection ) ;
   ASSERT(pStatement) ;
	pStatement->Allocate(NULL) ;

   //
   //  Handle the "NoLock" condition
   //
   CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) m_hDatabase ;
   ASSERT(pDatabase) ;
   if ( pDatabase->GetNoLockQueriesState() )
   {
      DWORD dwDBMSType = pDatabase->GetDMBSType() ;
      pStatement->EnableNoLockQueries( dwDBMSType ) ;
      lstrcatA( szBuffer, " NOLOCK " ) ;
   }

   //
   // Handle timeout
   //
   if (dwTimeout != 0)
   {
      dbstatus = pStatement->SetQueryTimeout( dwTimeout ) ;
      if (dbstatus != MQDB_OK)
      {
         delete pStatement ;
         return dbstatus ;
      }
   }

   if (lpszSearchCondition)
   {
      ASSERT(cWhere == 1) ;
      lstrcatA( szBuffer, " WHERE ") ;
      lstrcatA( szBuffer, lpszSearchCondition) ;
   }
   else if (pWhereColumnSearch)
   {
      int nBind = 1 ;
      dbstatus = FormatOpWhereString( pWhereColumnSearch,
                                      cWhere,
                                      opWhere,
                                      &nBind,
                                      pStatement,
                                      szBuffer) ;
      RETURN_ON_ERROR ;
   }

   FormatOrderString( szBuffer,
                      lpOrder,
                      cOrders ) ;

   VERIFY_BUFFER(szBuffer, QUERY_BUFFER_LEN) ;

   return CreateQueryStatement( szBuffer,
                                aColumnVal,
                                cColumns,
                                pWhereColumnSearch,
                                cWhere,
                                pStatement,
                                phQuery,
                                fGetFirst) ;
}

//*******************************************************************
//
//  MQDBSTATUS CMQODBCTable::OpenJoin
//
//*******************************************************************

MQDBSTATUS CMQODBCTable::OpenJoin(
                     IN MQDBHANDLE        hDatabase,
                     IN LPSTR             lpszLeftTableName,
                     IN LPSTR             lpszRightTableName,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cLefts,
                     IN LONG              cRights,
                     IN LPMQDBJOINOP      opJoin,
                     IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                     IN LONG              cWhereLeft,
                     IN LONG              cWhereRight,
                     IN MQDBOP            opWhere,
                     IN LPMQDBSEARCHORDER pOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout )
{
    UNREFERENCED_PARAMETER(dwTimeout);

   CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) hDatabase ;
   if (!pDatabase)
   {
      return MQDB_E_BAD_HDATABASE ;
   }
   m_hConnection = pDatabase->GethDbc() ;

   DECLARE_BUFFER(szBuffer, JOIN_BUFFER_LEN) ;
   char szTmpBuff[ JOIN_BUFFER_LEN ] ;
   MQDBSTATUS dbstatus = MQDB_OK ;
   LONG index ;

   if (cLefts > 0)
   {
      lstrcatA( szBuffer, "SELECT ") ;
      for ( index = 0 ; index < cLefts ; index++ )
      {
         wsprintfA( szTmpBuff, "%s.%s, ", lpszLeftTableName,
                                  aColumnVal[ index ].lpszColumnName) ;
         lstrcatA( szBuffer, szTmpBuff) ;
      }
      int nLen = lstrlenA( szBuffer ) ;
      szBuffer[ nLen - 2 ] = '\0' ;
   }
   else if (cRights <= 0)
   {
      return MQDB_E_INVALID_DATA ;
   }
   else
   {
      wsprintfA(szBuffer, "SELECT %s.%s", lpszRightTableName,
                                       aColumnVal[0].lpszColumnName) ;
   }

   for ( index = cLefts ; index < (cRights + cLefts) ; index++ )
   {
        wsprintfA(szTmpBuff, ", %s.%s", lpszRightTableName,
                                  aColumnVal[ index ].lpszColumnName) ;
        lstrcatA( szBuffer, szTmpBuff) ;
   }

   if (opJoin->fOuterJoin)
   {
      wsprintfA(szTmpBuff, " FROM {oj %s LEFT OUTER JOIN %s",
                               lpszLeftTableName, lpszRightTableName) ;
      lstrcatA( szBuffer, szTmpBuff) ;
      wsprintfA(szTmpBuff, " ON %s.%s %s %s.%s}", lpszLeftTableName,
                                        opJoin->lpszLeftColumnName,
                                        dbODBCOpNameStr[ opJoin->opJoin ],
                                        lpszRightTableName,
                                        opJoin->lpszRightColumnName) ;
      lstrcatA( szBuffer, szTmpBuff) ;
   }
   else
   {
      // Inner Join.
      wsprintfA(szTmpBuff, " FROM %s, %s", lpszLeftTableName,
                                           lpszRightTableName) ;
      lstrcatA( szBuffer, szTmpBuff) ;
   }

   //
   // Create a new statement.
   //
	CMQDBOdbcSTMT *pStatement = new CMQDBOdbcSTMT( m_hConnection ) ;
   ASSERT(pStatement) ;
	pStatement->Allocate(NULL) ;

   int nBind = 1 ;
   if (pWhereColumnSearch)
   {
      dbstatus = FormatJoinWhereString( lpszLeftTableName,
                                        lpszRightTableName,
                                        pWhereColumnSearch,
                                        cWhereLeft,
                                        cWhereRight,
                                        opWhere,
                                        &nBind,
                                        pStatement,
                                        szBuffer) ;
      RETURN_ON_ERROR ;
      if (!opJoin->fOuterJoin)
      {
         lstrcatA(szBuffer, " AND") ;
      }
   }
   else if (!opJoin->fOuterJoin)
   {
      lstrcatA(szBuffer, " WHERE") ;
   }

   if (!opJoin->fOuterJoin)
   {
      wsprintfA(szTmpBuff, " %s.%s%s%s.%s", lpszLeftTableName,
                                        opJoin->lpszLeftColumnName,
                                        dbODBCOpNameStr[ opJoin->opJoin ],
                                        lpszRightTableName,
                                        opJoin->lpszRightColumnName) ;
      lstrcatA( szBuffer, szTmpBuff) ;
   }

   FormatOrderString( szBuffer,
                      pOrder,
                      cOrders ) ;

   VERIFY_BUFFER(szBuffer, JOIN_BUFFER_LEN) ;

   return CreateQueryStatement( szBuffer,
                                aColumnVal,
                                (cLefts + cRights),
                                pWhereColumnSearch,
                                (cWhereLeft + cWhereRight),
                                pStatement,
                                phQuery,
                                fGetFirst) ;
}

//*******************************************************************
//
//  MQDBSTATUS CMQODBCTable::OpenAggrQuery
//
//  Aggregate query
//
//*******************************************************************

MQDBSTATUS CMQODBCTable::OpenAggrQuery(
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN MQDBAGGR          mqdbAggr,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition,
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere,
                     IN DWORD             dwTimeout)
{
   MQDBSTATUS dbstatus = MQDB_OK ;
   LONG       cColumns = 1 ;

   //
   // Parameters are valid. Format the query command.
   //
   DECLARE_BUFFER(szBuffer, QUERY_BUFFER_LEN) ;

   lstrcatA(szBuffer, "SELECT ") ;
   if (!aColumnVal || !aColumnVal[0].lpszColumnName)
   {
      //
      // A column must be specified.
      //
      return  MQDB_E_INVALID_DATA ;
   }
   else if ((aColumnVal[ 0 ].mqdbColumnType != MQDB_SHORT) &&
            (aColumnVal[ 0 ].mqdbColumnType != MQDB_LONG)  &&
            (aColumnVal[ 0 ].mqdbColumnType != MQDB_FIXBINARY))
   {
      //
      // We can aggregate only a numeric column.
      //
      return  MQDB_E_INVALID_DATA ;
   }
   else
   {
      lstrcatA( szBuffer, dbODBCAggrNameStr[ mqdbAggr ]) ;
      lstrcatA( szBuffer, aColumnVal[ 0 ].lpszColumnName) ;
      lstrcatA( szBuffer, ")" ) ;
   }
   lstrcatA( szBuffer, " FROM " ) ;
   lstrcatA( szBuffer, m_lpszTableName ) ;

   //
   // Create a new statement.
   //
   CMQDBOdbcSTMT *pStatement = new CMQDBOdbcSTMT( m_hConnection ) ;
   ASSERT(pStatement) ;
   pStatement->Allocate(NULL) ;

   //
   //  Handle the "NoLock" condition
   //
   CMQODBCDataBase *pDatabase = (CMQODBCDataBase *) m_hDatabase ;
   ASSERT(pDatabase) ;
   if ( pDatabase->GetNoLockQueriesState() )
   {
      DWORD dwDBMSType = pDatabase->GetDMBSType() ;
      pStatement->EnableNoLockQueries( dwDBMSType ) ;
      lstrcatA( szBuffer, " NOLOCK " ) ;
   }

   //
   // Handle timeout
   //
   if (dwTimeout != 0)
   {
      dbstatus = pStatement->SetQueryTimeout( dwTimeout ) ;
      if (dbstatus != MQDB_OK)
      {
         delete pStatement ;
         return dbstatus ;
      }
   }

   if (lpszSearchCondition)
   {
      ASSERT(cWhere == 1) ;
      lstrcatA( szBuffer, " WHERE ") ;
      lstrcatA( szBuffer, lpszSearchCondition) ;
   }
   else if (pWhereColumnSearch)
   {
      int nBind = 1 ;
      dbstatus = FormatOpWhereString( pWhereColumnSearch,
                                      cWhere,
                                      opWhere,
                                      &nBind,
                                      pStatement,
                                      szBuffer) ;
      RETURN_ON_ERROR ;
   }

   VERIFY_BUFFER(szBuffer, QUERY_BUFFER_LEN) ;

   return CreateQueryStatement( szBuffer,
                                aColumnVal,
                                cColumns,
                                pWhereColumnSearch,
                                cWhere,
                                pStatement,
                                NULL,
                                TRUE ) ;
}

//*******************************************************************
//
//  MQDBSTATUS  CMQODBCTable::FormatDirectJoinData
//
//*******************************************************************

MQDBSTATUS  CMQODBCTable::FormatDirectJoinData(
                            IN LPSTR             lpszTableName,
                            IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                            IN OUT int *         pBind,
                            IN CMQDBOdbcSTMT     *pStatement,
                            IN OUT LPSTR         lpszBuf )
{
   MQDBSTATUS  dbstatus = MQDB_OK ;

   char szTmpBuff[ JOIN_BUFFER_LEN ] ;
   wsprintfA( szTmpBuff, " (%s.%s %s ",  lpszTableName,
            pWhereColumnSearch->mqdbColumnVal.lpszColumnName,
            dbODBCOpNameStr[ pWhereColumnSearch->mqdbOp ]) ;
   lstrcatA( lpszBuf, szTmpBuff) ;

   switch (pWhereColumnSearch->mqdbColumnVal.mqdbColumnType)
   {
      case MQDB_STRING:
      {
         lstrcatA( lpszBuf, "'") ;
         lstrcatA( lpszBuf, (LPSTR)
                     pWhereColumnSearch->mqdbColumnVal.nColumnValue) ;
         lstrcatA( lpszBuf, "')") ;
         break ;
      }

      case MQDB_SHORT:
      case MQDB_LONG:
      {
         wsprintfA( szTmpBuff, "%ld)",
                      pWhereColumnSearch->mqdbColumnVal.nColumnValue) ;
         lstrcatA( lpszBuf, szTmpBuff) ;
         break ;
      }

      default:
      {
         // bind the "where".
         //
         lstrcatA( lpszBuf, "?)") ;
         ASSERT(pBind) ;
         dbstatus = BindParameter( *pBind,
                                   &pWhereColumnSearch->mqdbColumnVal,
                                   pStatement) ;
         RETURN_ON_ERROR ;
         (*pBind)++ ;
         break ;
      }
   }

   return dbstatus ;
}

//*******************************************************************
//
//  MQDBSTATUS  CMQODBCTable::FormatJoinWhereString
//
//*******************************************************************

MQDBSTATUS  CMQODBCTable::FormatJoinWhereString(
                           IN LPSTR             lpszLeftTableName,
                           IN LPSTR             lpszRightTableName,
                           IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                           IN DWORD             cWhereLeft,
                           IN DWORD             cWhereRight,
                           IN MQDBOP            opWhere,
                           IN OUT int *         pBind,
                        	IN CMQDBOdbcSTMT     *pStatement,
                           IN OUT LPSTR         lpszBuf)
{
   ASSERT((opWhere == AND) || (opWhere == OR)) ;

   MQDBSTATUS dbstatus = MQDB_OK ;
   lstrcatA( lpszBuf, " WHERE ") ;

   DWORD index = 0 ;
   for ( ; index < cWhereLeft ; index++ )
   {
      dbstatus = FormatDirectJoinData( lpszLeftTableName,
                                       pWhereColumnSearch,
                                       pBind,
                                       pStatement,
                                       lpszBuf ) ;
      RETURN_ON_ERROR ;

      if (index < ((cWhereLeft + cWhereRight) - 1))
      {
         lstrcatA( lpszBuf, dbODBCOpNameStr[ opWhere ]) ;
      }
      pWhereColumnSearch++ ;
   }

   index = cWhereLeft ;
   for ( ; index < (cWhereLeft + cWhereRight) ; index++ )
   {
      dbstatus = FormatDirectJoinData( lpszRightTableName,
                                       pWhereColumnSearch,
                                       pBind,
                                       pStatement,
                                       lpszBuf ) ;
      RETURN_ON_ERROR ;

      if (index < ((cWhereLeft + cWhereRight) - 1))
      {
         lstrcatA( lpszBuf, dbODBCOpNameStr[ opWhere ]) ;
      }
      pWhereColumnSearch++ ;
   }

   return dbstatus ;
}

//*********************************************************************
//
//  void  CMQODBCTable::FormatOrderString
//
//*********************************************************************

void  CMQODBCTable::FormatOrderString( IN LPSTR szBuffer,
                                       IN LPMQDBSEARCHORDER pOrder,
                                       IN LONG              cOrders )
{
	LONG index ;

   if (pOrder && (cOrders > 0))
   {
      lstrcatA( szBuffer, " ORDER BY ") ;
      for ( index = 0 ; index < cOrders ; index++ )
      {
         lstrcatA( szBuffer, pOrder->lpszColumnName) ;
         lstrcatA( szBuffer, dbODBCOrderNameStr[ pOrder->nOrder ]) ;
         pOrder++ ;
      }

      int nLen = lstrlenA( szBuffer ) ;
      szBuffer[ nLen - 2 ] = '\0' ;
   }
}

//*********************************************************************
//
//  MQDBSTATUS CMQODBCTable::CreateQueryStatement
//
//*********************************************************************

MQDBSTATUS CMQODBCTable::CreateQueryStatement(
                                 IN LPSTR             szBuffer,
                                 IN MQDBCOLUMNVAL     aColumnVal[],
                                 IN LONG              cColumns,
                                 IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                                 IN LONG              cWhere,
                                 IN CMQDBOdbcSTMT     *pStatement,
                                 OUT LPMQDBHANDLE     phQuery,
                                 IN BOOL              fGetFirst)
{
   MQDBSTATUS dbstatus = MQDB_OK ;
   dbstatus = ExecWhereStatement( szBuffer,
                                  pWhereColumnSearch,
                                  cWhere,
                                  pStatement ) ;
   RETURN_ON_ERROR ;

   pStatement->SetColumnsCount(cColumns);

   try
   {
      if (fGetFirst)
      {
         // Fetch the data.
         //
         dbstatus = pStatement->RetrieveRecordData( aColumnVal ) ;
         if ((dbstatus == MQDB_OK) && phQuery)
         {
            *phQuery = (MQDBHANDLE) pStatement ;
         }
         else
         {
            // We can reach here if dbstatus == MQDB_E_NO_MORE_DATA.
            // In this case it seems ok to delete the statemant. The
            // caller can't use it for retrieving data.
            delete pStatement ;
            pStatement = NULL ;
         }
      }
      else
      {
         *phQuery = (MQDBHANDLE) pStatement ;
      }
   }
	catch(...)
   {
      delete pStatement ;
      pStatement = NULL ;
      dbstatus = MQDB_E_INVALID_DATA ;
   }

   return dbstatus ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\cmighelp.cpp ===
// cMigHelp.cpp : implementation file
//

#include "stdafx.h"
#include "mqmig.h"
#include "cMigHelp.h"

#include "cmighelp.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BOOL g_fHelpRead = FALSE;

/////////////////////////////////////////////////////////////////////////////
// cMigHelp property page

IMPLEMENT_DYNCREATE(cMigHelp, CPropertyPageEx)

cMigHelp::cMigHelp() : CPropertyPageEx(cMigHelp::IDD,0, IDS_HELP_TITLE, IDS_HELP_SUBTITLE)
{
	//{{AFX_DATA_INIT(cMigHelp)
	m_fRead = FALSE;
	//}}AFX_DATA_INIT
}

cMigHelp::~cMigHelp()
{
}

void cMigHelp::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageEx::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(cMigHelp)
	DDX_Check(pDX, IDC_MQMIG_CHECK1, m_fRead);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(cMigHelp, CPropertyPageEx)
	//{{AFX_MSG_MAP(cMigHelp)
	ON_BN_CLICKED(IDC_MQMIG_CHECK1, OnCheckRead)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// cMigHelp message handlers

BOOL cMigHelp::OnSetActive() 
{
	// The default button is Back
	CPropertySheetEx* pageFather;
	pageFather = (CPropertySheetEx*)GetParent();
	pageFather->SetWizardButtons(PSWIZB_BACK);
	return CPropertyPageEx::OnSetActive();
}

void cMigHelp::OnCheckRead() 
{
	UpdateData(TRUE);
	CPropertySheetEx* pageFather;	
	pageFather = (CPropertySheetEx*)GetParent();
	if(m_fRead)
	{
		pageFather->SetWizardButtons(PSWIZB_BACK|PSWIZB_NEXT);
		g_fHelpRead = TRUE;
	}
	else
	{
		pageFather->SetWizardButtons(PSWIZB_BACK);
		g_fHelpRead = FALSE;
	}
}

BOOL cMigHelp::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	switch (((NMHDR FAR *) lParam)->code) 
	{
		case PSN_HELP:
						openHtmlHelp();
						return TRUE;
		
	}		
	return CPropertyPageEx::OnNotify(wParam, lParam, pResult);
}

void cMigHelp::openHtmlHelp()
{
	HtmlHelp(m_hWnd,LPCTSTR(g_strHtmlString),HH_DISPLAY_TOPIC,0);
	CPropertySheetEx* pageFather;
	pageFather = (CPropertySheetEx*)GetParent();
	pageFather->SetWizardButtons(PSWIZB_NEXT|PSWIZB_BACK);
	g_fHelpRead = TRUE;
	m_fRead = TRUE;
	UpdateData(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\cmigfin.h ===
#if !defined(AFX_CMQMIGFINISH_H__B8874CD0_CDF3_11D1_938E_0020AFEDDF63__INCLUDED_)
#define AFX_CMQMIGFINISH_H__B8874CD0_CDF3_11D1_938E_0020AFEDDF63__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// cMqMigFinish.h : header file
//

#include "HtmlHelp.h" 
extern CString g_strHtmlString;
/////////////////////////////////////////////////////////////////////////////
// cMqMigFinish dialog

class cMqMigFinish : public CPropertyPageEx
{
	DECLARE_DYNCREATE(cMqMigFinish)

// Construction
public:
	cMqMigFinish();
	~cMqMigFinish();

// Dialog Data
	//{{AFX_DATA(cMqMigFinish)
	enum { IDD = IDD_MQMIG_FINISH };
	CButton	m_cbViewLogFile;
	BOOL m_cbSkip;
	CStatic	m_Text;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(cMqMigFinish)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(cMqMigFinish)
	afx_msg void OnViewLogFile();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMQMIGFINISH_H__B8874CD0_CDF3_11D1_938E_0020AFEDDF63__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\cmigfin.cpp ===
//
// cMqMigFinish.cpp : implementation file
//

#include "stdafx.h"
#include "MqMig.h"
#include "mqsymbls.h"
#include "cMigFin.h"
#include "loadmig.h"

#include "cmigfin.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern HRESULT  g_hrResultMigration ;
extern BOOL     g_fIsLoggingDisable ;
DWORD g_CurrentState = msScanMode;

/////////////////////////////////////////////////////////////////////////////
// cMqMigFinish property page

IMPLEMENT_DYNCREATE(cMqMigFinish, CPropertyPageEx)

cMqMigFinish::cMqMigFinish() : CPropertyPageEx(cMqMigFinish::IDD)
{
	//{{AFX_DATA_INIT(cMqMigFinish)
	//}}AFX_DATA_INIT
	m_psp.dwFlags |= PSP_HIDEHEADER;
}

cMqMigFinish::~cMqMigFinish()
{
}

void cMqMigFinish::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageEx::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(cMqMigFinish)
	DDX_Control(pDX, IDC_VIEW_LOG_FILE, m_cbViewLogFile);
	DDX_Check(pDX, IDC_SKIP, m_cbSkip);
	DDX_Control(pDX, IDC_FINISH_TEXT, m_Text);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(cMqMigFinish, CPropertyPageEx)
	//{{AFX_MSG_MAP(cMqMigFinish)
	ON_BN_CLICKED(IDC_VIEW_LOG_FILE, OnViewLogFile)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// cMqMigFinish message handlers

BOOL cMqMigFinish::OnSetActive()
{
    CPropertyPageEx::OnSetActive();

	CPropertySheetEx* pageFather;
	pageFather = (CPropertySheetEx*) GetParent();
	
    CString strMessage;
    
	ASSERT(g_CurrentState != msScanMode);

	//
	// Ths state we're in is the state we just finished.
	//
	switch( g_CurrentState )
	{	
		case msMigrationMode:
			{ 
				//
				// We finished the main migration phase.
				//
		        if (SUCCEEDED(g_hrResultMigration))
				{
					//
			        // disable the "back" button if migration was successful.
			        //
			        pageFather->SetWizardButtons(PSWIZB_NEXT);

					//
					// Enable the "Skip this step" since it might we hidden because of a previous unsuccessful migration.
					//
					((CButton*)GetDlgItem(IDC_SKIP))->ShowWindow(SW_SHOW);
			        strMessage.LoadString(IDS_MIGRATION_SUCCEEDED);
			        CString strMessage2;
			        strMessage2.LoadString(IDS_MIGRATION_NEXT_TO_UPDATE_CLIENTS);
			        strMessage += strMessage2;
		        }
		        else
			    {
			    	//
			    	// Migration failed - no "Skip" checkbox and no "Next"
			    	//
			    	((CButton*)GetDlgItem(IDC_SKIP))->ShowWindow(SW_HIDE);
			        pageFather->SetWizardButtons(PSWIZB_FINISH | PSWIZB_BACK);

			        if (g_hrResultMigration == HRESULT_FROM_WIN32(E_ACCESSDENIED) ||
			            g_hrResultMigration == HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM))
			        {
			            strMessage.LoadString(IDS_INSUFFICIENT_PERMISSION);
			        }
			        else if (g_fIsLoggingDisable)
			        {
			            strMessage.LoadString(IDS_MIGRATION_FAILED_NO_LOG);	
			        }
			        else
			        {
			            strMessage.LoadString(IDS_MIGRATION_FAILED);	
			        }
			    }
			}
	        break;
	        
	    case msUpdateClientsMode:
	    	{
	    		//
	    		// Uncheck the "Skip" checkbox in case state was saved from last time.
	    		//
	    		((CButton*)GetDlgItem(IDC_SKIP))->SetCheck(BST_UNCHECKED);
	    		pageFather->SetWizardButtons(PSWIZB_NEXT);
	    		if (SUCCEEDED(g_hrResultMigration))
				{
			        strMessage.LoadString(IDS_UPDATE_CLIENTS_SUCCEEDED);			        
	    		}
	    		else
	    		{
					strMessage.LoadString(IDS_UPDATE_CLIENTS_FAILED);	
	    		}
	    		
	    		CString strMessage2;
		        strMessage2.LoadString(IDS_MIGRATION_NEXT_TO_UPDATE_SERVERS);
		        strMessage += strMessage2;
	    		
	    	}
	        break;
	        
	    case msUpdateServersMode:
	    	{
		        ((CButton*)GetDlgItem(IDC_SKIP))->ShowWindow(SW_HIDE);
		        pageFather->SetWizardButtons(PSWIZB_FINISH);
				if (SUCCEEDED(g_hrResultMigration))
				{
			        strMessage.LoadString(IDS_UPDATE_SERVERS_SUCCEEDED);			        
	    		}
				else
				{
					strMessage.LoadString(IDS_UPDATE_SERVERS_FAILED);
				}
		        
		        CString strMessage2;
		        strMessage2.LoadString(IDS_MIGRATION_PROCESS_COMPLETE);
		        strMessage += strMessage2;
	    	}
	        break;
	        
	    case msQuickMode:
	    	//
	    	// Quick mode - all at once in the same loop. Updating the registry will fail the whole migartion.
	    	//
	    	
	    	//
	        // No need for "Skip" since we alreday finished everything.
	        //
	        ((CButton*)GetDlgItem(IDC_SKIP))->ShowWindow(SW_HIDE);
        	if (SUCCEEDED(g_hrResultMigration))
			{
				//
				// Display the finish button
				//
		        pageFather->SetWizardButtons(PSWIZB_FINISH);
				
		        strMessage.LoadString(IDS_MIGRATION_COPMPLETED_SUCCESSFULLY);
		        CString strMessage2;
		        strMessage2.LoadString(IDS_MIGRATION_PROCESS_COMPLETE);
		        strMessage += strMessage2;
        	}
        	else
        	{
        		//
        		// Migration failed - allow also "back"
        		//
 				pageFather->SetWizardButtons(PSWIZB_FINISH | PSWIZB_BACK);

		        if (g_hrResultMigration == HRESULT_FROM_WIN32(E_ACCESSDENIED) ||
		            g_hrResultMigration == HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM))
		        {
		            strMessage.LoadString(IDS_INSUFFICIENT_PERMISSION);
		        }
		        else if (g_fIsLoggingDisable)
		        {
		            strMessage.LoadString(IDS_MIGRATION_FAILED_NO_LOG);	
		        }
		        else
		        {
		            strMessage.LoadString(IDS_MIGRATION_FAILED);	
		        }
        	}
        	break;

        case msUpdateOnlyRegsitryMode:
        {
    		pageFather->SetWizardButtons(PSWIZB_NEXT);

    		//
			// Enable the "Skip this step".
			//
			((CButton*)GetDlgItem(IDC_SKIP))->ShowWindow(SW_SHOW);
    		strMessage.LoadString(IDS_MIGRATION_SUCCEEDED);
    		CString strMessage2;
	        strMessage2.LoadString(IDS_MIGRATION_NEXT_TO_UPDATE_CLIENTS);
	        strMessage += strMessage2;
        }
        break;
        	
	    default:
	        	ASSERT(0);
	        	break;
    }
    

    m_Text.SetWindowText( strMessage );

    if (g_fIsLoggingDisable)
    {
        //
        // disable "view log file" button
        //
        m_cbViewLogFile.EnableWindow( FALSE );
    }
    else
    {
        m_cbViewLogFile.EnableWindow() ;
    }

    return TRUE ;
}

void cMqMigFinish::OnViewLogFile()
{
	ViewLogFile();
}

LRESULT cMqMigFinish::OnWizardBack()
{
	ASSERT(g_CurrentState == msMigrationMode);
	return IDD_MQMIG_PREMIG ;
}

LRESULT cMqMigFinish::OnWizardNext()
{
	ASSERT((g_CurrentState != msQuickMode) && (g_CurrentState != msScanMode));

	switch(g_CurrentState)
	{
	case msMigrationMode:
	case msUpdateServersMode:
	case msUpdateClientsMode:
		g_CurrentState++;
		if (((CButton*)GetDlgItem(IDC_SKIP))->GetCheck() == BST_CHECKED)
		{
			//
			// We need to skip this phase
			//
			g_hrResultMigration = MQMig_E_UNKNOWN;
			return IDD_MQMIG_FINISH;
		}
		break;
		
	case msUpdateOnlyRegsitryMode:
		g_CurrentState = msUpdateClientsMode;
		if (((CButton*)GetDlgItem(IDC_SKIP))->GetCheck() == BST_CHECKED)
		{
			//
			// We need to skip this phase
			//
			g_hrResultMigration = MQMig_E_UNKNOWN;
			return IDD_MQMIG_FINISH;
		}
		break;
	default:
		ASSERT(0);
		break;
	}

	return IDD_MQMIG_WAIT;
}

BOOL cMqMigFinish::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	switch (((NMHDR FAR *) lParam)->code) 
	{
		case PSN_HELP:
						HtmlHelp(m_hWnd,LPCTSTR(g_strHtmlString),HH_DISPLAY_TOPIC,0);
						return TRUE;
		
	}
	return CPropertyPageEx::OnNotify(wParam, lParam, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\cmighelp.h ===
#if !defined(AFX_CMIGHELP_H__8FD65A45_E034_11D2_BE6C_0020AFEDDF63__INCLUDED_)
#define AFX_CMIGHELP_H__8FD65A45_E034_11D2_BE6C_0020AFEDDF63__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// cMigHelp.h : header file
//

#include "HtmlHelp.h" 
extern CString g_strHtmlString;
/////////////////////////////////////////////////////////////////////////////
// cMigHelp dialog

class cMigHelp : public CPropertyPageEx
{
	DECLARE_DYNCREATE(cMigHelp)

// Construction
public:
	cMigHelp();
	~cMigHelp();

// Dialog Data
	//{{AFX_DATA(cMigHelp)
	enum { IDD = IDD_MQMIG_HELP };
	BOOL	m_fRead;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(cMigHelp)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	void openHtmlHelp();
	// Generated message map functions
	//{{AFX_MSG(cMigHelp)
	afx_msg void OnCheckRead();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMIGHELP_H__8FD65A45_E034_11D2_BE6C_0020AFEDDF63__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\cmigpre.cpp ===
// cMigPre.cpp : implementation file
//

#include "stdafx.h"
#include "mqmig.h"
#include "cMigPre.h"
#include "loadmig.h"

#include "cmigpre.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern HRESULT  g_hrResultAnalyze ;
extern DWORD     g_CurrentState ;
extern BOOL     g_fIsLoggingDisable ;
extern BOOL 	g_QuickMode;

/////////////////////////////////////////////////////////////////////////////
// cMigPre property page

IMPLEMENT_DYNCREATE(cMigPre, CPropertyPageEx)

cMigPre::cMigPre() : CPropertyPageEx( cMigPre::IDD,
                                      0,
                                      IDS_PREIMPORT_TITLE,
                                      IDS_PREIMPORT_SUBTITLE )
{
	//{{AFX_DATA_INIT(cMigPre)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

cMigPre::~cMigPre()
{
}

void cMigPre::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageEx::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(cMigPre)
	DDX_Control(pDX, IDC_VIEW_LOG_FILE, m_cbViewLogFile);
	DDX_Control(pDX, IDC_TEXT1, m_Text);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(cMigPre, CPropertyPageEx)
	//{{AFX_MSG_MAP(cMigPre)
	ON_BN_CLICKED(IDC_VIEW_LOG_FILE, OnViewLogFile)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// cMigPre message handlers

BOOL cMigPre::OnSetActive()
{

	CPropertySheetEx* pageFather;
	HWND hCancel;

	pageFather = (CPropertySheetEx*) GetParent();
    pageFather->SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);

    //
    // Enable the cancel button.
    //
	hCancel=::GetDlgItem( ((CWnd*)pageFather)->m_hWnd ,IDCANCEL);
	ASSERT(hCancel != NULL);
	if(FALSE == ::IsWindowEnabled(hCancel))
    {
		::EnableWindow(hCancel,TRUE);
    }
	
    //
    // By default, disable "view log file" button
    //
    m_cbViewLogFile.EnableWindow( FALSE );

    CString strMessage;
    if (SUCCEEDED(g_hrResultAnalyze))
    {
        strMessage.LoadString(IDS_ANALYSIS_SUCCEEDED);
    }
    else
    {
        if (!g_fIsLoggingDisable)
        {
            strMessage.LoadString(IDS_ANALYSIS_FAILED);	
            m_cbViewLogFile.EnableWindow();
        }
        else
        {
            strMessage.LoadString(IDS_ANALYSIS_FAILED_NO_LOG);	
        }
    }
    m_Text.SetWindowText( strMessage );

	return CPropertyPageEx::OnSetActive();
}

LRESULT cMigPre::OnWizardNext()
{
    //
    // skip to the wait page  and clear flag.
    //
    if (!g_QuickMode)
    {
	    g_CurrentState = msMigrationMode;
    }
    else
    {
    	g_CurrentState = msQuickMode;
    }
    	
    g_fReadOnly = FALSE;

	return CPropertyPageEx::OnWizardNext();
}

LRESULT cMigPre::OnWizardBack()
{
    //
    // jump diretctly to the server page
    //
	return IDD_MQMIG_SERVER;
}

void cMigPre::OnViewLogFile()
{
	// TODO: Add your control notification handler code here
	ViewLogFile();
}



BOOL cMigPre::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	switch (((NMHDR FAR *) lParam)->code) 
	{
		case PSN_HELP:
						HtmlHelp(m_hWnd,LPCTSTR(g_strHtmlString),HH_DISPLAY_TOPIC,0);
						return TRUE;
		
	}	
	return CPropertyPageEx::OnNotify(wParam, lParam, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\cmiglog.cpp ===
// cMigLog.cpp : implementation file
//

#include "stdafx.h"
#include "mqmig.h"
#include "cMigLog.h"
#include "loadmig.h"
#include "Shlwapi.h"
#include "..\migrepl.h"
#include "migservc.h"

#include "cmiglog.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern LPTSTR  g_pszLogFileName ;
extern ULONG   g_ulTraceFlags ;
extern DWORD   g_CurrentState;

BOOL g_fIsLoggingDisable = FALSE;
const int DISABLE_LOGGING = 4 ;
BOOL g_fAlreadyAsked = FALSE;

BOOL FormDirectory( IN const TCHAR * lpPathName);
BOOL CreateDirectoryTree( IN const TCHAR * pszDirTree);


/////////////////////////////////////////////////////////////////////////////
// cMigLog property page

IMPLEMENT_DYNCREATE(cMigLog, CPropertyPageEx)

cMigLog::cMigLog() : CPropertyPageEx(cMigLog::IDD, 0, IDS_LOGGING_TITLE, IDS_LOGGING_SUBTITLE)
{	
	TCHAR strPathName[MAX_PATH];
	CString cPathName;
	GetSystemDirectory(strPathName,MAX_PATH);
	cPathName=strPathName;
	cPathName+="\\mqmig.log";
	
	//{{AFX_DATA_INIT(cMigLog)
	m_iValue = 0 ; // Error Button as default button
	m_strFileName = cPathName;
	//}}AFX_DATA_INIT
}

cMigLog::~cMigLog()

{
}

void cMigLog::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageEx::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(cMigLog)
	DDX_Radio(pDX, IDC_RADIO_ERR, m_iValue);
	DDX_Text(pDX, IDC_EDIT_LOGFILE, m_strFileName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(cMigLog, CPropertyPageEx)
	//{{AFX_MSG_MAP(cMigLog)
	ON_BN_CLICKED(IDC_MQMIG_BROWSE, OnBrowse)
	ON_BN_CLICKED(IDC_RADIO_DISABLE, OnRadioDisable)
	ON_BN_CLICKED(IDC_RADIO_ERR, OnRadioErr)
	ON_BN_CLICKED(IDC_RADIO_INFO, OnRadioInfo)
	ON_BN_CLICKED(IDC_RADIO_TRACE, OnRadioTrace)
	ON_BN_CLICKED(IDC_RADIO_WARN, OnRadioWarn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// cMigLog message handlers

BOOL cMigLog::OnSetActive()
{
	/*enabeling the back and next button for the server page by using a pointer to the father*/
	CPropertySheetEx* pageFather;
	pageFather = (CPropertySheetEx*)GetParent();
	pageFather->SetWizardButtons(PSWIZB_NEXT |PSWIZB_BACK);

	return CPropertyPageEx::OnSetActive();
}

LRESULT cMigLog::OnWizardNext()
{

	UpdateData(TRUE);  // executing DDX to get data to the object
	//
	//if disable radio button was picked there is no need for further cheacking
	//
    g_fIsLoggingDisable = FALSE ;
	if (m_iValue != DISABLE_LOGGING)
	{

		if( m_strFileName.GetLength() == 0)
		{
			CResString cMustFile(IDS_STR_MUST_FILE) ;
			CResString cErrorTitle(IDS_STR_ERROR_TITLE) ;

			::MessageBox( NULL,
			              cMustFile.Get(),
				          cErrorTitle.Get(),
					      (MB_TASKMODAL | MB_OK | MB_ICONSTOP )) ;
			return -1; // error we must stay in the same page
		}
		
		if ((m_strFileName[1] != TEXT(':')) || (m_strFileName[2] != TEXT('\\')))
		{
			CResString cMustFile(IDS_STR_WRONG_PATH) ;
			CResString cErrorTitle(IDS_STR_ERROR_TITLE) ;

			::MessageBox( NULL,
			              cMustFile.Get(),
				          cErrorTitle.Get(),
					      (MB_TASKMODAL | MB_OK | MB_ICONSTOP )) ;
			return -1;
		}

		CString strRootPath;
        strRootPath.Format(TEXT("%c:\\"), m_strFileName[0]);
        if (GetDriveType(strRootPath) != DRIVE_FIXED)
        {
            CResString cMustFile(IDS_DRIVE_NOT_VALID) ;
			CResString cErrorTitle(IDS_STR_ERROR_TITLE) ;

			::MessageBox( NULL,
			              cMustFile.Get(),
				          cErrorTitle.Get(),
					      (MB_TASKMODAL | MB_OK | MB_ICONSTOP )) ;
			return -1;
        }
		if (GetFileAttributes(m_strFileName) == 0xFFFFFFFF )
	    {
            ULONG ulError = GetLastError();
            if (ulError == ERROR_PATH_NOT_FOUND)
            {
                CResString cMustFile(IDS_STR_WRONG_PATH) ;
				CResString cErrorTitle(IDS_STR_ERROR_TITLE) ;

				::MessageBox( NULL,
							  cMustFile.Get(),
							  cErrorTitle.Get(),
							  (MB_TASKMODAL | MB_OK | MB_ICONSTOP )) ;
				return -1;               
            }
		}

		//
	    // if disasble logging was not selected if file exists but user was already asked about file replacing
		// (funtion: OnBrowse) to do nothing
		//
		if ( GetFileAttributes(m_strFileName) != 0xFFFFFFFF &&
			 !g_fAlreadyAsked  )
		{	
			//
			// the file exists, replace it?
			//
		    CResString cReplaceFile(IDS_STR_REPLACE_FILE);
            CResString cErrorTitle(IDS_STR_ERROR_TITLE) ;

			TCHAR szError[1024] ;
            _stprintf(szError,_T("%s %s"), m_strFileName, cReplaceFile.Get());
	
		    if (::MessageBox (
			        NULL,
				    szError,
					cErrorTitle.Get(),
				    (MB_TASKMODAL | MB_YESNO | MB_ICONEXCLAMATION )) == IDNO)
		    {
		        return -1; // NO was selected, we must stay in that page
		    }
            //
            // YES was selected, it is time to delete this file
            //
            DeleteFile (m_strFileName);
		}
	
		LPTSTR strPathName = new  TCHAR[ 1 + _tcslen(m_strFileName) ] ;
		_tcscpy(strPathName, m_strFileName) ;
		BOOL bNameWasRemoved = PathRemoveFileSpec(strPathName);
        UNREFERENCED_PARAMETER(bNameWasRemoved);
		//
		//if disable logging was not selected and if path doesn't exists at all prompt a messsage
		//(i.e)it is ok that the file itself doesn't exists in this part
		//

		if(FALSE == PathIsDirectory(strPathName))
		{
			//
			// the path doesn't exists, create it?
			//
			CResString cPreCreatePath(IDS_STR_PRE_CREATE_PATH);
			CResString cCreatePath(IDS_STR_CREATE_PATH);
	        CResString cErrorTitle(IDS_STR_ERROR_TITLE) ;

		    TCHAR szError[1024] ;
		    _stprintf(szError, _T("%s %s %s"), cPreCreatePath.Get(), strPathName, cCreatePath.Get());

			if (::MessageBox (
				    NULL,
					szError,
			        cErrorTitle.Get(),
				    (MB_TASKMODAL | MB_YESNO | MB_ICONEXCLAMATION )) == IDNO)
		    {
			    return -1; // NO was selected, we must stay in this page
		    }
			else //== IDYES -> create the specified path
			{
				BOOL bCreateSuccess = CreateDirectoryTree(strPathName);
				if(bCreateSuccess == FALSE)
				{
					CResString cPathCreateFail(IDS_STR_PATH_CREATE_ERROR);
					::MessageBox(
						          NULL,cPathCreateFail.Get(),
								  cErrorTitle.Get(),
								  MB_TASKMODAL | MB_OK | MB_ICONEXCLAMATION);
					return -1;//we must stay in the same page
				}
			
			}

		}

	}//(m_iValue != DISABLE_LOGGING)
    else
    {
        g_fIsLoggingDisable = TRUE;
    }

	if (g_pszLogFileName)
    {
        delete[] g_pszLogFileName ;
    }
    LPCTSTR pName = m_strFileName ;
    g_pszLogFileName = new TCHAR[ 1 + _tcslen(pName) ] ;
    _tcscpy(g_pszLogFileName, pName) ;

    g_ulTraceFlags = m_iValue ;

	if (CheckRegistry(MIGRATION_UPDATE_REGISTRY_ONLY))
	{
		g_CurrentState = msUpdateOnlyRegsitryMode;
		return IDD_MQMIG_FINISH;
	}

	return CPropertyPageEx::OnWizardNext() ;
}

void cMigLog::OnBrowse()
{	
	CString fileName;

	// DDX is called to ensure that data from the radio buttons will be instored in the object
	UpdateData(TRUE);
	static CFileDialog browse( FALSE,
                               TEXT("log"),
                               TEXT("mqmig"),
                                 (OFN_NOCHANGEDIR   |
                                  OFN_PATHMUSTEXIST |
                                  OFN_HIDEREADONLY  |
                                  OFN_OVERWRITEPROMPT) ) ;
		
	if(browse.DoModal() == IDOK)
	{	
        g_fAlreadyAsked = TRUE;
		m_strFileName = browse.GetPathName();
		UpdateData(FALSE);
	}
	else // IDCANCEL
	{

	}

}

static BOOL s_fEnabled = TRUE ;//TRUE if Edit & Browse are Enabled

void cMigLog::OnRadioDisable()
{
    if (!s_fEnabled)
    {
        return ;
    }

    CWnd *hEdit = GetDlgItem(IDC_EDIT_LOGFILE) ;
    if (hEdit)
    {
        ::EnableWindow(hEdit->m_hWnd, FALSE) ;
    }

    hEdit = GetDlgItem(IDC_MQMIG_BROWSE) ;
    if (hEdit)
    {
        ::EnableWindow(hEdit->m_hWnd, FALSE) ;
    }

    s_fEnabled = FALSE ;

    if (g_pszLogFileName)
    {
        delete g_pszLogFileName ;
        g_pszLogFileName = NULL ;
    }
}

void cMigLog::_EnableBrowsing()
{
    if (s_fEnabled)
    {
        return ;
    }

    CWnd *hEdit = GetDlgItem(IDC_EDIT_LOGFILE) ;
    if (hEdit)
    {
        ::EnableWindow(hEdit->m_hWnd, TRUE) ;
    }

    hEdit = GetDlgItem(IDC_MQMIG_BROWSE) ;
    if (hEdit)
    {
        ::EnableWindow(hEdit->m_hWnd, TRUE) ;
    }

    s_fEnabled = TRUE ;
}

void cMigLog::OnRadioErr()
{
    _EnableBrowsing() ;
}

void cMigLog::OnRadioInfo()
{
    _EnableBrowsing() ;
}

void cMigLog::OnRadioTrace()
{
    _EnableBrowsing() ;
}

void cMigLog::OnRadioWarn()
{
    _EnableBrowsing() ;
}


//+-------------------------------------------------------------------------
//
//  Function:   FormDirectory
//
//  Synopsis:   Handle directory creation.
//
//--------------------------------------------------------------------------
BOOL FormDirectory(  IN const TCHAR * lpPathName  )
{
    if (!CreateDirectory(lpPathName, 0))
    {
        DWORD dwError = GetLastError();
        if (dwError != ERROR_ALREADY_EXISTS)
        {
            return FALSE;
        }
    }

    return TRUE;//directory was created succesfully

} //FormDirectory


//+-------------------------------------------------------------------------
//
//  Function:   CreateDirectoryTree
//
//  Synopsis:   Handle directory tree creation.
//
//--------------------------------------------------------------------------
BOOL CreateDirectoryTree(  IN const TCHAR * pszDirTree   )
{
    //
    // pszDirTree must include a drive letter, such that its format is:
    // x:\dir1\dir2\dir3
    // Where dir1\dir2\dir3 is optional, but x:\ is not optional.
    //
    if (!pszDirTree)//pointer is null
	{
        return FALSE;
	}
    if (lstrlen(pszDirTree) < 3)//the path must include a drive letter "X:\"
	{
        return FALSE;
	}

	//
	//check if the path begin with the ":\" sign
	//
    if ( (TEXT(':') != pszDirTree[1]) ||
		 (TEXT('\\') != pszDirTree[2] )          )
	{
        return FALSE;
	}

	//
    // check if drive letter is legal
    //
	TCHAR cDriveLetter =  pszDirTree[0];
	TCHAR szDrive[4]= _T("x:\\");
	szDrive[0] = cDriveLetter;
	if (FALSE == PathFileExists(szDrive))
	{
		return FALSE;
	}

    if (3 == lstrlen(pszDirTree))//the path is the root
	{
        return TRUE;
	}

    TCHAR szDirectory[MAX_PATH];
    lstrcpy(szDirectory, pszDirTree);
    TCHAR * pszDir = szDirectory,
          * pszDirStart = szDirectory;
    UINT uCounter = 0;
    while ( *pszDir )
    {
        //
        // Ignore first backslash - it's right after drive letter
        //
        if ( *pszDir == TEXT('\\'))
        {
            uCounter++;
            if (1 != uCounter)
            {
                *pszDir = 0;// set the new end of the string

                if (!FormDirectory(pszDirStart))
				{
                    return FALSE;
				}

                *pszDir = TEXT('\\') ;//reset the sttring to it's original status
            }
        }

        pszDir = CharNext(pszDir);
    }//While

    if (!FormDirectory(pszDirStart))//last directory
	{
        return FALSE;
	}

    return TRUE;

} //CreateDirectoryTree



BOOL cMigLog::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	switch (((NMHDR FAR *) lParam)->code) 
	{
		case PSN_HELP:
						HtmlHelp(m_hWnd,LPCTSTR(g_strHtmlString),HH_DISPLAY_TOPIC,0);
						return TRUE;
		
	}	
	return CPropertyPageEx::OnNotify(wParam, lParam, pResult);
}

LRESULT cMigLog::OnWizardBack() 
{
	//
	//we need to skip the help page and go directly to the welcome page
	//
	return IDD_MQMIG_WELCOME;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\cmigser.h ===
#if !defined(AFX_CMQMIGSERVER_H__B8874CD1_CDF3_11D1_938E_0020AFEDDF63__INCLUDED_)
#define AFX_CMQMIGSERVER_H__B8874CD1_CDF3_11D1_938E_0020AFEDDF63__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// cMqMigServer.h : header file
//
#include "HtmlHelp.h" 
extern CString g_strHtmlString;
/////////////////////////////////////////////////////////////////////////////
// cMqMigServer dialog

class cMqMigServer : public CPropertyPageEx
{
	DECLARE_DYNCREATE(cMqMigServer)

// Construction
public:
	cMqMigServer();
	~cMqMigServer();

// Dialog Data
	//{{AFX_DATA(cMqMigServer)
	enum { IDD = IDD_MQMIG_SERVER };
	BOOL	m_bRead;
	//}}AFX_DATA

	CString m_strMachineName;
// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(cMqMigServer)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(cMqMigServer)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMQMIGSERVER_H__B8874CD1_CDF3_11D1_938E_0020AFEDDF63__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\cmiglog.h ===
#if !defined(AFX_CMIGLOG_H__5377E054_D1F6_11D1_9394_0020AFEDDF63__INCLUDED_)
#define AFX_CMIGLOG_H__5377E054_D1F6_11D1_9394_0020AFEDDF63__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// cMigLog.h : header file
//

#include "HtmlHelp.h" 
extern CString g_strHtmlString;
/////////////////////////////////////////////////////////////////////////////
// cMigLog dialog

class cMigLog : public CPropertyPageEx
{
	DECLARE_DYNCREATE(cMigLog)

// Construction
public:
	cMigLog();
	~cMigLog();

// Dialog Data
	//{{AFX_DATA(cMigLog)
	enum { IDD = IDD_MQMIG_LOGIN };
	int		m_iValue;
	CString	m_strFileName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(cMigLog)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(cMigLog)
	afx_msg void OnBrowse();
	afx_msg void OnRadioDisable();
	afx_msg void OnRadioErr();
	afx_msg void OnRadioInfo();
	afx_msg void OnRadioTrace();
	afx_msg void OnRadioWarn();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void _EnableBrowsing() ;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMIGLOG_H__5377E054_D1F6_11D1_9394_0020AFEDDF63__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\cmigser.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    cmigser.cpp

Abstract:

    Thie page enable you to choose analysis of MQIS SQL database.
    User can uncheck the check box and skip the analysis phase.

Author:

    Erez  Vizel
    Doron Juster  (DoronJ)

--*/

#include "stdafx.h"
#include "MqMig.h"
#include "cMigSer.h"
#include "loadmig.H"
#include "mqsymbls.h"

#include "cmigser.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern HRESULT   g_hrResultAnalyze ;
extern DWORD g_CurrentState;
//
// Flag to deterine which page will follow the wait page (as it is used twice)
//

/////////////////////////////////////////////////////////////////////////////
// cMqMigServer property page

IMPLEMENT_DYNCREATE(cMqMigServer, CPropertyPageEx)

cMqMigServer::cMqMigServer() : CPropertyPageEx(cMqMigServer::IDD, 0, IDS_ANALYZE_TITLE, IDS_ANALYZE_SUBTITLE)
{
	//{{AFX_DATA_INIT(cMqMigServer)
	m_bRead = TRUE;
	//}}AFX_DATA_INIT

	/* obtaining the deafult MQIS Server Name ( host computer)  */
    if (g_fIsRecoveryMode || g_fIsClusterMode)
    {
        m_strMachineName = g_pszRemoteMQISServer;
    }
    else
    {
        TCHAR buffer[MAX_COMPUTERNAME_LENGTH+1];
	    unsigned long length=MAX_COMPUTERNAME_LENGTH+1;
	    GetComputerName(buffer,&length);
	    m_strMachineName = buffer;
    }	
}

cMqMigServer::~cMqMigServer()
{
}

void cMqMigServer::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageEx::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(cMqMigServer)
	DDX_Check(pDX, IDC_CHECK_READ, m_bRead);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(cMqMigServer, CPropertyPageEx)
	//{{AFX_MSG_MAP(cMqMigServer)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// cMqMigServer message handlers

BOOL cMqMigServer::OnSetActive()
{
	/*enabeling the back and next button for the server page by using a pointer to the father*/
	HWND hCancel;
	CPropertySheetEx* pageFather;

    g_CurrentState = msScanMode ;

	pageFather = (CPropertySheetEx*)GetParent();
	pageFather->SetWizardButtons(PSWIZB_NEXT |PSWIZB_BACK);

	hCancel=::GetDlgItem( ((CWnd*)pageFather)->m_hWnd ,IDCANCEL);/*enable the cancel button*/
	ASSERT(hCancel != NULL);
	if(FALSE == ::IsWindowEnabled(hCancel))
    {
		::EnableWindow(hCancel,TRUE);
	}
    return CPropertyPageEx::OnSetActive();
}

BOOL cMqMigServer::OnInitDialog()
{
	CPropertyPageEx::OnInitDialog();
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT cMqMigServer::OnWizardNext()
{
	UpdateData(TRUE); // executing DDX(retrive data)
	
    g_fReadOnly = m_bRead ;

    if (g_pszMQISServerName)
    {
        delete[] g_pszMQISServerName ;
    }

    LPCTSTR pName = m_strMachineName ;
    g_pszMQISServerName = new TCHAR[ 1 + _tcslen(pName) ] ;
    _tcscpy(g_pszMQISServerName, pName) ;

	if (m_bRead == FALSE)
	{
        //
        // if analysis is unchecked then skip to the pre-migration page.
        //
        g_hrResultAnalyze = MQMig_OK ;
        g_CurrentState = msMigrationMode ;
	    return IDD_MQMIG_PREMIG; //skip to the pre migration page
	}

	return CPropertyPageEx::OnWizardNext();//if analyze is checked go to wait page
}



BOOL cMqMigServer::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	switch (((NMHDR FAR *) lParam)->code) 
	{
		case PSN_HELP:
						HtmlHelp(m_hWnd,LPCTSTR(g_strHtmlString),HH_DISPLAY_TOPIC,0);
						return TRUE;
		
	}	
	return CPropertyPageEx::OnNotify(wParam, lParam, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\cmigwait.cpp ===
//
// cMigWait.cpp : implementation file
//

#include "stdafx.h"
#include "mqmig.h"
#include "cMigWait.h"
#include "sThrPrm.h"
#include <uniansi.h>
#include <autoptr.h>
#include "thrSite.h"
#include "loadmig.h"
#include "..\mqmigrat\mqmigui.h"
#include "loadmig.h"

#include "cmigwait.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern DWORD g_CurrentState ;
extern UINT _PRE_MIGRATION_PAGE;
extern UINT _FINISH_PAGE;

const UINT g_iSiteLowLimit = 0 ;
UINT       g_iSiteHighLimit = 0 ;// will be set during run time
const UINT g_iMachineLowLimit = 0 ;
UINT       g_iMachineHighLimit = 0 ;
const UINT g_iQueueLowLimit=0 ;
UINT       g_iQueueHighLimit = 0 ;
const UINT g_iUserLowLimit=0 ;
UINT       g_iUserHighLimit = 0 ;

extern BOOL g_fMigrationCompleted ;

BOOL setLimit();

DWORD g_InitTime;


/////////////////////////////////////////////////////////////////////////////
// cMigWait property page

IMPLEMENT_DYNCREATE(cMigWait, CPropertyPageEx)

cMigWait::cMigWait()
{
    ASSERT(0) ;
}

cMigWait::cMigWait(UINT uTitle, UINT uSubTitle) :
    CPropertyPageEx(cMigWait::IDD, 0, uTitle, uSubTitle)
{
	//{{AFX_DATA_INIT(cMigWait)		
	//}}AFX_DATA_INIT
    m_strQueue.LoadString(IDS_QUEUES) ;
	m_strMachine.LoadString(IDS_MACHINES) ;
	m_strSite.LoadString(IDS_MQMIG_SITES) ;
	m_strUser.LoadString(IDS_USERS) ;	
}

cMigWait::~cMigWait()
{
}

void cMigWait::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageEx::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(cMigWait)
	DDX_Control(pDX, IDC_ELAPSED_TIME, m_ElapsedTimeText);
	DDX_Control(pDX, IDC_STATIC_USER, m_UserText);
	DDX_Control(pDX, IDC_STATIC_SITE, m_SiteText);
	DDX_Control(pDX, IDC_STATIC_QUEUE, m_QueueText);
	DDX_Control(pDX, IDC_PROGRESS_USER, m_cProgressUser);
	DDX_Control(pDX, IDC_PLEASE_WAIT, m_WaitText);
	DDX_Control(pDX, IDC_PROGRESS_SITE, m_cProgressSite);
	DDX_Control(pDX, IDC_PROGRESS_QUEUE, m_cProgressQueue);
	DDX_Control(pDX, IDC_PROGRESS_MACHINE, m_cProgressMachine);
	DDX_Text(pDX, IDC_STATIC_QUEUE, m_strQueue);
	DDX_Text(pDX, IDC_STATIC_MACHINE, m_strMachine);
	DDX_Text(pDX, IDC_STATIC_SITE, m_strSite);
	DDX_Text(pDX, IDC_STATIC_USER, m_strUser);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(cMigWait, CPropertyPageEx)
	//{{AFX_MSG_MAP(cMigWait)
	ON_WM_TIMER()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// cMigWait message handlers

BOOL cMigWait::OnSetActive()
{	
	g_InitTime = GetTickCount ();
	OnStartTimer() ;
	HWND hCancel;
	sThreadParm  *pProgressBar;
    sThreadParm  *pMigration;
	CPropertySheetEx* pageFather;

	pageFather = (CPropertySheetEx*)GetParent();
	pageFather->SetWizardButtons(0);/*Disabling the back and next buttons*/
	hCancel=::GetDlgItem( ((CWnd*)pageFather)->m_hWnd ,IDCANCEL);/*Disable the cancel button*/

	//
	// ISSUE-2002/09/26-talk-This timer doesn't work properly, hide it for now...
	//
	((CButton*)GetDlgItem(IDC_ELAPSED_TIME))->ShowWindow(SW_HIDE);
	ASSERT(hCancel != NULL);
	::EnableWindow(hCancel,FALSE);

	setLimit(); //initialyzing high limit

	pProgressBar = new sThreadParm;
	
	pProgressBar->pPageFather = pageFather;
	pProgressBar->pSiteProgress = &m_cProgressSite;
	pProgressBar->pMachineProgress = &m_cProgressMachine;
	pProgressBar->pQueueProgress = &m_cProgressQueue;
	pProgressBar->pUserProgress = &m_cProgressUser;
	
	if (g_iUserHighLimit == 0)
	{
		//
		// either there are no users or migration tool runs on PSC =>
		// disable this control
		//
		m_cProgressUser.ShowWindow(SW_HIDE);
		m_UserText.ShowWindow(SW_HIDE);
	}
	else
	{
		m_cProgressUser.ShowWindow(SW_SHOW);
		m_UserText.ShowWindow(SW_SHOW);		
	}

    pMigration = new  sThreadParm;
    pMigration->pPageFather = pageFather;
	pMigration->pSiteProgress = &m_cProgressSite;
	pMigration->pMachineProgress = &m_cProgressMachine;
	pMigration->pQueueProgress = &m_cProgressQueue;
	pMigration->pUserProgress = &m_cProgressUser;

    g_fMigrationCompleted = FALSE;
    CString strMessage;

	ASSERT(g_CurrentState != msUpdateOnlyRegsitryMode);
	
    switch(g_CurrentState)
    {
		case msScanMode:
			pProgressBar->iPageNumber=_PRE_MIGRATION_PAGE;
	        pMigration->iPageNumber=_PRE_MIGRATION_PAGE;
    	    strMessage.LoadString(IDS_WAIT_ANALYZE) ;
    	    break;
    	    
    	case msMigrationMode:
   		case msQuickMode:
			pProgressBar->iPageNumber=_FINISH_PAGE;
	        pMigration->iPageNumber=_FINISH_PAGE;
    	    strMessage.LoadString(IDS_WAIT_MIGRATE) ;
    	    break;   

    	case msUpdateClientsMode:
			SetOnlyComputersActive(); 
			pProgressBar->iPageNumber=_FINISH_PAGE;
	        pMigration->iPageNumber=_FINISH_PAGE;
	        strMessage.LoadString(IDS_WAIT_MIGRATE_CLIENTS) ;
	        break;
	        
    	case msUpdateServersMode:
			SetOnlyComputersActive();
    	    pProgressBar->iPageNumber=_FINISH_PAGE;
	        pMigration->iPageNumber=_FINISH_PAGE;
    	    strMessage.LoadString(IDS_WAIT_MIGRATE_SERVERS) ;
    	    break;   
    	    
	    default:
	    	ASSERT(0);
	    	break;
    }

    m_WaitText.SetWindowText( strMessage );

	CString strElapsedTime;
	strElapsedTime.Format(IDS_ELAPSED_TIME_TEXT, 0, 0, 0);
	m_ElapsedTimeText.SetWindowText (strElapsedTime);

    //
    // ProgressBarsThread is the thread that advance the progress bars.
    //
	AfxBeginThread((ProgressBarsThread),(void *)(pProgressBar));

	if (g_CurrentState >= msMigrationMode)
    {
		AfxBeginThread((RunMigrationThread),(void *)(pMigration));
    }
	else
    {
		AfxBeginThread((AnalyzeThread),(void *)(pMigration));
    }
	
	return CPropertyPageEx::OnSetActive();
}

///////////////////////////////////////////////////////////////////////////////
// void SetOnlyComputersActive()

void cMigWait::SetOnlyComputersActive()
{
	m_cProgressUser.ShowWindow(SW_HIDE);
	m_UserText.ShowWindow(FALSE);

	m_cProgressSite.ShowWindow(SW_HIDE);
	m_SiteText.ShowWindow(FALSE);

	m_cProgressQueue.ShowWindow(SW_HIDE);
	m_QueueText.ShowWindow(FALSE);
}


///////////////////////////////////////////////////////////////////////////////
// void ChangeStringValue()

void cMigWait::ChangeStringValue()
{
	m_strSite.LoadString(IDS_USERS) ;
	m_strQueue = "  ";
	m_strMachine ="  ";
	UpdateData(FALSE);
}

///////////////////////////////////////////////////////////////////////////////////////
// Void setLimit() - set the limit of the progress bars, using exported function
BOOL setLimit()
{
    BOOL f = LoadMQMigratLibrary(); // load dll
    if (!f)
    {
        return FALSE;
    }

    MQMig_GetObjectsCount_ROUTINE pfnGetObjectsCount =
            (MQMig_GetObjectsCount_ROUTINE)
                         GetProcAddress( g_hLib, "MQMig_GetObjectsCount" ) ;
    ASSERT(pfnGetObjectsCount != NULL) ;

    if (pfnGetObjectsCount != NULL)
    {
        TCHAR ServerName[MAX_COMPUTERNAME_LENGTH+1];
        if (g_fIsRecoveryMode)
        {
            lstrcpy (ServerName, g_pszRemoteMQISServer);
        }
        else
        {
            unsigned long length=MAX_COMPUTERNAME_LENGTH+1;
            GetComputerName(ServerName,&length);
        }

		HRESULT hr = (*pfnGetObjectsCount)( ServerName, 
                                           &g_iSiteHighLimit,
							               &g_iMachineHighLimit,
							               &g_iQueueHighLimit,
										   &g_iUserHighLimit) ;
        UNREFERENCED_PARAMETER(hr);
	}
	else //false
	{
		return FALSE;
	}

    return TRUE ;
}



BOOL cMigWait::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	switch (((NMHDR FAR *) lParam)->code)
	{
		case PSN_HELP:
						HtmlHelp(m_hWnd,LPCTSTR(g_strHtmlString),HH_DISPLAY_TOPIC,0);
						return TRUE;
		
	}	
	return CPropertyPageEx::OnNotify(wParam, lParam, pResult);
}

void cMigWait::OnStartTimer()
{
   m_nTimer = SetTimer(1, 15000, 0);
}

void cMigWait::OnStopTimer()
{
   ::KillTimer(m_hWnd, m_nTimer);
}

void cMigWait::OnTimer(UINT nIDEvent)
{
	// TODO: Add your message handler code here and/or call default
	DWORD dwCurTime = GetTickCount ();	
	
	//
	// Elapsed time in seconds
	//
	DWORD dwElapsedTime = (dwCurTime - g_InitTime) / 1000;

	DWORD dwElapsedSec = dwElapsedTime % 60;
	DWORD dwElapsedMin = dwElapsedTime / 60;
	DWORD dwElapsedHour = dwElapsedMin / 60;
	dwElapsedMin = dwElapsedMin % 60;
		
	static ULONG sTimer = 0;
	CString strElapsedTime;
	strElapsedTime.Format(IDS_ELAPSED_TIME_TEXT,
			dwElapsedHour, dwElapsedMin, dwElapsedSec);
	m_ElapsedTimeText.SetWindowText (strElapsedTime);	

	CPropertyPageEx::OnTimer(nIDEvent);
}

BOOL cMigWait::OnKillActive()
{
	// TODO: Add your specialized code here and/or call the base class
	OnStopTimer();
	return CPropertyPageEx::OnKillActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\cmigpre.h ===
#if !defined(AFX_CMIGPRE_H__09A53B26_52B0_11D2_BE44_0020AFEDDF63__INCLUDED_)
#define AFX_CMIGPRE_H__09A53B26_52B0_11D2_BE44_0020AFEDDF63__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// cMigPre.h : header file
//

#include "HtmlHelp.h" 
extern CString g_strHtmlString;
/////////////////////////////////////////////////////////////////////////////
// cMigPre dialog

class cMigPre : public CPropertyPageEx
{
	DECLARE_DYNCREATE(cMigPre)

// Construction
public:
	cMigPre();
	~cMigPre();

// Dialog Data
	//{{AFX_DATA(cMigPre)
	enum { IDD = IDD_MQMIG_PREMIG };
	CButton	m_cbViewLogFile;
	CStatic	m_Text;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(cMigPre)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(cMigPre)
	afx_msg void OnViewLogFile();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMIGPRE_H__09A53B26_52B0_11D2_BE44_0020AFEDDF63__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\cmigwel.cpp ===
// cMqMigWelcome.cpp : implementation file
//

#include "stdafx.h"
#include "MqMig.h"
#include "cMigWel.h"
#include "textfont.h"

#include "cmigwel.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// cMqMigWelcome property page

IMPLEMENT_DYNCREATE(cMqMigWelcome, CPropertyPageEx)

cMqMigWelcome::cMqMigWelcome() : CPropertyPageEx(cMqMigWelcome::IDD)
{
	//{{AFX_DATA_INIT(cMqMigWelcome)
	//}}AFX_DATA_INIT
	m_psp.dwFlags |= PSP_HIDEHEADER;
}

cMqMigWelcome::~cMqMigWelcome()
{
}

void cMqMigWelcome::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageEx::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(cMqMigWelcome)
	DDX_Control(pDX, IDC_WELCOME_TEXT, m_strWelcomeTitle);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(cMqMigWelcome, CPropertyPageEx)
	//{{AFX_MSG_MAP(cMqMigWelcome)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// cMqMigWelcome message handlers

BOOL cMqMigWelcome::OnSetActive()
{
	/*disabeling the back button for the welcome page by using a pointer to the father*/

	CPropertySheetEx* pageFather;
	pageFather = (CPropertySheetEx*)GetParent();
	pageFather->SetWizardButtons(PSWIZB_NEXT);

    CFont cFont ;
    LOGFONT lf = { 0,
                   0,
                   0,
                   0,
                   WELCONE_TITLE_WEIGHT,
                   0,
                   0,
                   0,
                   0,
                   0,
                   0,
                   0,
                   DEFAULT_PITCH,
                   TEXT("Verdana")};
    BOOL fFont = cFont.CreateFontIndirect(&lf) ;
    if (fFont)
    {
        m_strWelcomeTitle.SetFont(&cFont, TRUE) ;
    }

    CString strMessage;
    strMessage.LoadString(IDS_WELCOME_TITLE_TEXT) ;
    m_strWelcomeTitle.SetWindowText( strMessage );
	BOOL fSetActive = CPropertyPageEx::OnSetActive();
	return fSetActive;
}


BOOL cMqMigWelcome::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	switch (((NMHDR FAR *) lParam)->code) 
	{
		case PSN_HELP:
						HtmlHelp(m_hWnd,LPCTSTR(g_strHtmlString),HH_DISPLAY_TOPIC,0);
						//
						//Help file was viewed mark the help as read
						//
						g_fHelpRead = TRUE;
						return TRUE;
		
	}

	
	return CPropertyPageEx::OnNotify(wParam, lParam, pResult);
}




LRESULT cMqMigWelcome::OnWizardNext() 
{
	if(g_fHelpRead )
	{	
		//
		//If the help file was viewed in this page or the second page skip
		//directly to the third page
		//
		return IDD_MQMIG_LOGIN;
	}
	else
	{
		return CPropertyPageEx::OnWizardNext();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\cmigwait.h ===
#if !defined(AFX_CMIGWAIT_H__E7C820A6_2B76_11D2_BE3B_0020AFEDDF63__INCLUDED_)
#define AFX_CMIGWAIT_H__E7C820A6_2B76_11D2_BE3B_0020AFEDDF63__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// cMigWait.h : header file
//

#include "HtmlHelp.h" 
extern CString g_strHtmlString;
/////////////////////////////////////////////////////////////////////////////
// cMigWait dialog

class cMigWait : public CPropertyPageEx
{
	DECLARE_DYNCREATE(cMigWait)

// Construction
public:
	void ChangeStringValue();
	cMigWait();
	cMigWait(UINT uTitle, UINT uSubTitle);
	~cMigWait();
	void OnStartTimer() ;
	void OnStopTimer() ;	
	UINT m_nTimer;

// Dialog Data
	//{{AFX_DATA(cMigWait)
	enum { IDD = IDD_MQMIG_WAIT };
	CStatic	m_ElapsedTimeText;
	CStatic	m_UserText;
	CStatic	m_QueueText;
	CStatic	m_SiteText;
	CProgressCtrl	m_cProgressUser;
	CStatic	m_WaitText;
	CProgressCtrl	m_cProgressSite;
	CProgressCtrl	m_cProgressQueue;
	CProgressCtrl	m_cProgressMachine;
	CString	m_strQueue;
	CString	m_strMachine;
	CString	m_strSite;
	CString	m_strUser;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(cMigWait)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(cMigWait)
	afx_msg void OnTimer(UINT nIDEvent);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	void SetOnlyComputersActive();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMIGWAIT_H__E7C820A6_2B76_11D2_BE3B_0020AFEDDF63__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\commonui.h ===
//
// file: commonui.h
//

#ifndef _COMMONUI_H_
#define _COMMONUI_H_

const UINT cwcResBuf = 2048;

extern HINSTANCE g_hResourceMod ;

class CResString
{
public:
    CResString() { _awc[ 0 ] = 0; }

    CResString( UINT strIDS )
    {
        _awc[ 0 ] = 0;
        LoadString( g_hResourceMod,
                    strIDS,
                    _awc,
                    sizeof _awc / sizeof TCHAR );
    }

    BOOL Load( UINT strIDS )
    {
        _awc[ 0 ] = 0;
        LoadString( g_hResourceMod,
                    strIDS,
                    _awc,
                    sizeof _awc / sizeof TCHAR );
        return ( 0 != _awc[ 0 ] );
    }

    TCHAR const * Get() { return _awc; }

private:
    TCHAR _awc[ cwcResBuf ];
};

#endif // _COMMONUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\cmigwel.h ===
#if !defined(AFX_CMQMIGWELCOME_H__B8874CD5_CDF3_11D1_938E_0020AFEDDF63__INCLUDED_)
#define AFX_CMQMIGWELCOME_H__B8874CD5_CDF3_11D1_938E_0020AFEDDF63__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// cMqMigWelcome.h : header file
//

#include "HtmlHelp.h" 
extern CString g_strHtmlString;
extern BOOL g_fHelpRead;
/////////////////////////////////////////////////////////////////////////////
// cMqMigWelcome dialog

class cMqMigWelcome : public CPropertyPageEx
{
	DECLARE_DYNCREATE(cMqMigWelcome)

// Construction
public:
	cMqMigWelcome();
	~cMqMigWelcome();

// Dialog Data
	//{{AFX_DATA(cMqMigWelcome)
	enum { IDD = IDD_MQMIG_WELCOME };
	CStatic	m_strWelcomeTitle;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(cMqMigWelcome)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(cMqMigWelcome)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMQMIGWELCOME_H__B8874CD5_CDF3_11D1_938E_0020AFEDDF63__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\cwizsht.cpp ===
// cWizSheet.cpp : implementation file
//

#include "stdafx.h"
#include "mqmig.h"
#include "cWizSht.h"

#include "cwizsht.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

UINT _PRE_MIGRATION_PAGE;
UINT _FINISH_PAGE;
CString g_strHtmlString;
/////////////////////////////////////////////////////////////////////////////
// cWizSheet

IMPLEMENT_DYNAMIC(cWizSheet, CPropertySheetEx)

cWizSheet::cWizSheet() :
    CPropertySheetEx(IDS_MIGTOOL_CAPTION, 0, 0, GetHbmWatermark(), 0, GetHbmHeader())
{	
	
    m_hIcon = AfxGetApp()->LoadIcon( IDI_ICON1 );//load the icon
    ASSERT(m_hIcon != NULL);
    UINT uiPageCount = 0;
    AddPage(&m_cWelcome);

    uiPageCount++;
    AddPage(&m_cHelp);

    uiPageCount++;
    AddPage(&m_cLoginning);

    uiPageCount++;
    AddPage(&m_cServer);

    uiPageCount++;
    m_pcWaitFirst = new cMigWait(IDS_WAIT_TITLE, IDS_WAIT_SUBTITLE) ;
    AddPage(m_pcWaitFirst);

    uiPageCount++;
    _PRE_MIGRATION_PAGE = uiPageCount;
    AddPage(&m_cPreMigration);

    uiPageCount++;
    m_pcWaitSecond = new cMigWait(IDS_WAIT2_TITLE, IDS_WAIT2_SUBTITLE) ;
    AddPage(m_pcWaitSecond);

    uiPageCount++;
    _FINISH_PAGE  = uiPageCount;
    AddPage(&m_cFinish);    

    // set the WIZARD97 flag so we'll get the new look
    m_psh.dwFlags |= PSH_WIZARD97;
}

cWizSheet::~cWizSheet()
{
	if (theApp.m_hWndMain == m_hWnd)
	{
		theApp.m_hWndMain = 0;
	}
}


BEGIN_MESSAGE_MAP(cWizSheet, CPropertySheetEx)
	//{{AFX_MSG_MAP(cWizSheet)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// cWizSheet message handlers

BOOL cWizSheet::OnInitDialog()
{	
	CMenu* pMenu;
	BOOL bResult = CPropertySheetEx::OnInitDialog();
	theApp.m_hWndMain = m_hWnd;
	
	SetIcon(m_hIcon,TRUE); //Set the Big Icon
	SetIcon(m_hIcon,FALSE);//Set the Small Icon
	::SetWindowLong( m_hWnd, GWL_STYLE, GetStyle() |WS_MINIMIZEBOX );//add minimize button
	pMenu=GetSystemMenu(FALSE);
    int count = pMenu->GetMenuItemCount();
    //
    // add the menu item to the end
    //
	pMenu->InsertMenu(count,MF_BYPOSITION | MF_STRING,SC_MINIMIZE, _T("Minimize"));
	DrawMenuBar();
	initHtmlHelpString();
	return bResult;

}



//////////////////////////////////////////////////////////////////////////////////
/// void AddPage() 
	
void cWizSheet::AddPage(CPropertyPageEx * pPage)
{
    CPropertySheetEx::AddPage(pPage);
}

HBITMAP cWizSheet::GetHbmWatermark()
{
    static CBitmap cbmWatermark;
    static LONG lFlag = -1;

    if (InterlockedIncrement(&lFlag) == 0) // First time
    {
        cbmWatermark.LoadBitmap(IDB_WIZARD_WATERMARK);
    }

    return cbmWatermark;
}

HBITMAP cWizSheet::GetHbmHeader()
{
    static CBitmap cbmHeader;
    static LONG lFlag = -1;

    if (InterlockedIncrement(&lFlag) == 0) // First time
    {
        cbmHeader.LoadBitmap(IDB_WIZARD_HEADER);
    }

    return cbmHeader;

}

void cWizSheet::initHtmlHelpString()
{	
	CString str;
	TCHAR szWinDir[MAX_PATH];
	::GetWindowsDirectory(szWinDir,MAX_PATH);
	g_strHtmlString = szWinDir;
	str.LoadString(IDS_HTML_HELP_PATH);
	g_strHtmlString += str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\initwait.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    initwait.cpp

Abstract:

    Display the initial "please wait" box.

Author:

    Doron Juster  (DoronJ)  17-Jan-1999

--*/

#include "stdafx.h"
#include "commonui.h"
#include "resource.h"
#include "initwait.h"
#include "mqmig.h"

#include "initwait.tmh"

static HWND    s_hwndWait = NULL ;
static HANDLE  s_hEvent = NULL ;
static HANDLE  s_hThread = NULL ;

extern BOOL g_fUpdateRemoteMQIS;

//+----------------------------------------------
//
//  void  DisplayInitError( DWORD dwError )
//
//  Display a "fatal" error at initialization.
//
//+----------------------------------------------

int  DisplayInitError( DWORD dwError,
                       UINT  uiType,
                       DWORD dwTitle )
{
    DestroyWaitWindow() ;

    uiType |= MB_SETFOREGROUND ;

    CResString cErrorText(dwError) ;
    CResString cErrorTitle(dwTitle) ;

    int iMsgStatus = MessageBox( NULL,
                                 cErrorText.Get(),
                                 cErrorTitle.Get(),
                                 uiType ) ;
    return iMsgStatus ;
}

//+--------------------------------------------------------------
//
// Function: _MsmqWaitDlgProc
//
// Synopsis: Dialog procedure for the Wait dialog
//
//+--------------------------------------------------------------

static INT_PTR CALLBACK  _MsmqWaitDlgProc( IN const HWND   hdlg,
                                        IN const UINT   msg,
                                        IN const WPARAM wParam,
                                        IN const LPARAM lParam )
{
    switch( msg )
    {
        case WM_DESTROY:
            if (s_hEvent)
            {
                SetEvent(s_hEvent) ;
            }
			//
            // Fall through
            //

        default:
            return DefWindowProc(hdlg, msg, wParam, lParam);
            break;
    }  

} // _MsmqWaitDlgProc

//+--------------------------------------------------------------
//
// Function: _DisplayWaitThread()
//
//+--------------------------------------------------------------

static DWORD  _DisplayWaitThread(void *lpV)
{
    UNREFERENCED_PARAMETER(lpV);
    if (s_hwndWait == NULL)
    {
        s_hEvent = CreateEvent( NULL,
                                FALSE,
                                FALSE,
                                NULL ) ;

        s_hwndWait = CreateDialog( g_hResourceMod ,
                                   MAKEINTRESOURCE(IDD_INIT_WAIT),
                                   NULL,
                                  _MsmqWaitDlgProc ) ;
        ASSERT(s_hwndWait);

        if (s_hwndWait)
        {
            if (g_fUpdateRemoteMQIS)
            {
                CString strInitWait;
                strInitWait.LoadString(IDS_INITUPDATE);
                
                SetDlgItemText(
                      s_hwndWait,           // handle to dialog box
                      IDC_INITTEXT,         // identifier of control
                      strInitWait           // text to set
                      );
 
            }
            ShowWindow(s_hwndWait, SW_SHOW);
        }

        while (TRUE)
        {
            DWORD result = MsgWaitForMultipleObjects( 1,
                                                      &s_hEvent,
                                                      FALSE,
                                                      INFINITE,
                                                      QS_ALLINPUT ) ;
            if (result == WAIT_OBJECT_0)
            {
                //
                // Our process terminated.
                //
                CloseHandle(s_hEvent) ;
                s_hEvent = NULL ;

                return 1 ;
            }
            else if (result == (WAIT_OBJECT_0 + 1))
            {
                // Read all of the messages in this next loop,
                // removing each message as we read it.
                //
                MSG msg ;
                while (PeekMessage(&msg, s_hwndWait, 0, 0, PM_REMOVE))
                {
                    if (msg.message == WM_QUIT)
                    {
                        // If it's a quit message, we're out of here.
                        return 0 ;
                    }
                    else
                    {
                       // Otherwise, dispatch the message.
                       DispatchMessage(&msg);
                    }
                }
            }
            else
            {
                ASSERT(0) ;
                return 0 ;
            }
        }
    }

    return 0 ;
}

//+--------------------------------------------------------------
//
// Function: DisplayWaitWindow()
//
//+--------------------------------------------------------------

void DisplayWaitWindow()
{
    if (s_hwndWait == NULL)
    {
        DWORD dwID ;
        s_hThread = CreateThread( NULL,
                                  0,
                          (LPTHREAD_START_ROUTINE) _DisplayWaitThread,
                                  NULL,
                                  0,
                                 &dwID ) ;
        if (s_hThread)
        {
            int j = 0 ;
            while ((j < 10) && (s_hwndWait == NULL))
            {
                Sleep(100) ;
                j++ ;
            }
        }
		theApp.m_hWndMain = s_hwndWait;
    }
    else
    {
        SetForegroundWindow(s_hwndWait) ;
        BringWindowToTop(s_hwndWait) ;
        ShowWindow(s_hwndWait, SW_SHOW);
    }
}

//+--------------------------------------------------------------
//
// Function: DestroyWaitWindow
//
// Synopsis: Kills the Wait dialog
//
//+--------------------------------------------------------------

void DestroyWaitWindow(BOOL fFinalDestroy)
{
    if (s_hwndWait)
    {
        ShowWindow(s_hwndWait, SW_HIDE);
        if (fFinalDestroy)
        {
			if (theApp.m_hWndMain == s_hwndWait)
			{
				theApp.m_hWndMain = 0;
			}
            SendMessage(s_hwndWait, WM_DESTROY, 0, 0);
            WaitForSingleObject(s_hThread, INFINITE) ;
            CloseHandle(s_hThread) ;
            s_hThread = NULL ;
            s_hwndWait = NULL  ;
        }
    }

} // DestroyWaitWindow
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\initwait.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    initwait.h

Abstract:

    Display the initial "please wait" box.

Author:

    Doron Juster  (DoronJ)  17-Jan-1999

--*/

void DisplayWaitWindow() ;
void DestroyWaitWindow(BOOL fFinalDestroy = FALSE) ;

int  DisplayInitError( DWORD dwError,
                       UINT  uiType = (MB_OK | MB_ICONSTOP | MB_TASKMODAL),
                       DWORD dwTitle = IDS_STR_ERROR_TITLE ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\cwizsht.h ===
#if !defined(AFX_CWIZSHEET_H__88BEB485_2CFA_11D2_BE3C_0020AFEDDF63__INCLUDED_)
#define AFX_CWIZSHEET_H__88BEB485_2CFA_11D2_BE3C_0020AFEDDF63__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "cMigWel.h"
#include "cMigSer.h"
#include "cMigFin.h"
#include "cMigLog.h"
#include "cmigWait.h"
#include "cMigPre.h"
#include "cMigHelp.h"	// Added by ClassView
 
// cWizSheet.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// cWizSheet

class cWizSheet : public CPropertySheetEx
{
	DECLARE_DYNAMIC(cWizSheet)

// Construction
public:
	cWizSheet();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(cWizSheet)
	public:
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
public:
	void AddPage(CPropertyPageEx *pPage);
	virtual ~cWizSheet();

// Data
private:
	
    HICON m_hIcon;
    cMqMigWelcome m_cWelcome;	
    cMqMigServer  m_cServer;
    cMigWait      *m_pcWaitFirst ;
    cMigLog       m_cLoginning ;
    cMigPre	      m_cPreMigration;
    cMigWait      *m_pcWaitSecond ;
    cMqMigFinish  m_cFinish;
    cMigHelp	  m_cHelp;


	// Generated message map functions
protected:
	void initHtmlHelpString();
	static HBITMAP GetHbmHeader();
	static HBITMAP GetHbmWatermark();
	//{{AFX_MSG(cWizSheet)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CWIZSHEET_H__88BEB485_2CFA_11D2_BE3C_0020AFEDDF63__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\loadmig.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: loadmig.h

Abstract: load the migration dll and run migration.

Author:

    Doron Juster  (DoronJ)   19-Apr-98

--*/


extern BOOL    g_fReadOnly  ;
extern BOOL    g_fAlreadyExist ;
extern LPTSTR  g_pszMQISServerName ;

extern HINSTANCE g_hLib ; //global handel for the migrate.dll

extern BOOL      g_fIsRecoveryMode ;
extern BOOL      g_fIsClusterMode ;
extern LPTSTR    g_pszRemoteMQISServer ;

extern BOOL      g_fIsPEC ;
extern BOOL      g_fIsOneServer ;

HRESULT  RunMigration() ;
void     ViewLogFile();

BOOL LoadMQMigratLibrary();

UINT __cdecl RunMigrationThread(LPVOID lpV) ;
UINT __cdecl AnalyzeThread(LPVOID lpV) ;

BOOL SetSiteIdOfPEC ();

#ifdef _DEBUG

UINT  ReadDebugIntFlag(TCHAR *pwcsDebugFlag, UINT iDefault) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\mgmtwin.cpp ===
// MgmtWin.cpp : implementation file
//

#include "stdafx.h"
#include "MgmtWin.h"
#include "mqmig.h"

#include "mgmtwin.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CManagementWindow

CManagementWindow::CManagementWindow()
{
}

CManagementWindow::~CManagementWindow()
{
}


BEGIN_MESSAGE_MAP(CManagementWindow, CWnd)
	//{{AFX_MSG_MAP(CManagementWindow)
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CManagementWindow message handlers

void CManagementWindow::OnSetFocus(CWnd* pOldWnd) 
{
	CWnd::OnSetFocus(pOldWnd);

	if (theApp.m_hWndMain == 0)
	{
		Sleep (500);
	}

	if (theApp.m_hWndMain != 0 && theApp.m_hWndMain != m_hWnd)
	{
		CResString cErrorTitle(IDS_STR_ERROR_TITLE) ;

		HWND ErrorWnd = ::FindWindow(
							NULL,				// pointer to class name
							cErrorTitle.Get()   // pointer to window name
						);
	
		::ShowWindow(theApp.m_hWndMain, SW_HIDE ); 
		::ShowWindow(theApp.m_hWndMain, SW_SHOWMINIMIZED ); 
		::ShowWindow(theApp.m_hWndMain, SW_SHOWNORMAL );

		if (ErrorWnd != NULL)
		{
			::ShowWindow(ErrorWnd, SW_HIDE ); 
			::ShowWindow(ErrorWnd, SW_SHOWMINIMIZED ); 
			::ShowWindow(ErrorWnd, SW_SHOWNORMAL );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\loadmig.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    loadmig.cpp

Abstract:

    Call different functions from migration dll.
Author:

    Doron Juster  (DoronJ)  07-Feb-1999

--*/

#include "stdafx.h"
#include <autoptr.h>
#include <winsvc.h>
#include "resource.h"
#include "mqsymbls.h"
#include "..\..\setup\msmqocm\service.h"
#include "..\..\setup\msmqocm\comreg.h"
#include <uniansi.h>
#include "..\mqmigrat\mqmigui.h"
#include "initwait.h"
#include "loadmig.h"
#include "migservc.h"
#include "..\migrepl.h"
#include "mqnames.h"
#include <strsafe.h>

#include "loadmig.tmh"

BOOL      g_fReadOnly  = FALSE ;
BOOL      g_fAlreadyExist = FALSE ;
LPTSTR    g_pszMQISServerName = NULL ;
LPTSTR    g_pszLogFileName = NULL ;
ULONG     g_ulTraceFlags = 0 ;
HINSTANCE g_hLib = NULL ;
HRESULT   g_hrResultAnalyze = MQMig_OK ;
HRESULT   g_hrResultMigration = MQMig_OK ;
BOOL      g_fMigrationCompleted = FALSE;

BOOL      g_fIsPEC = FALSE;
BOOL      g_fIsOneServer = FALSE;

extern DWORD g_CurrentState;

//+-------------------------------
//
//  BOOL _RemoveFromWelcome()
//
//+-------------------------------

BOOL _RemoveFromWelcome()
{
    LONG rc = RegDeleteKey (HKEY_LOCAL_MACHINE, WELCOME_TODOLIST_MSMQ_KEY) ;

	BOOL f;
    if (rc != ERROR_SUCCESS)
    {
		f = CheckRegistry ( REMOVED_FROM_WELCOME );
		if (!f)
		{
			DisplayInitError( IDS_STR_CANT_DEL_WELCOME,
                          (MB_OK | MB_ICONWARNING | MB_TASKMODAL),
                          IDS_STR_WARNING_TITLE ) ;
		}
    }
	else
	{
		f = UpdateRegistryDW ( REMOVED_FROM_WELCOME, 1 );
	}

    return TRUE ;
}

//+---------------------------------
//
//  BOOL _StartMSMQService()
//
//+---------------------------------

BOOL _StartMSMQService()
{
    CResString cErrorTitle(IDS_STR_SERVICE_FAIL_TITLE) ;
    CResString cWarningTitle(IDS_STR_SERVICE_WARNING_TITLE) ;

    SC_HANDLE hServiceCtrlMgr = OpenSCManager( NULL,
                                               NULL,
                                               SC_MANAGER_ALL_ACCESS );
    if (!hServiceCtrlMgr)
    {
        CResString cCantOpenMgr(IDS_STR_CANT_OPEN_MGR) ;
        MessageBox( NULL,
                    cCantOpenMgr.Get(),
                    cErrorTitle.Get(),
                    (MB_OK | MB_ICONSTOP | MB_TASKMODAL)) ;
        return FALSE;
    }

    //
    // Open a handle to the MSMQ service
    //
    SC_HANDLE hService = OpenService( hServiceCtrlMgr,
                                      MSMQ_SERVICE_NAME,
                                      SERVICE_ALL_ACCESS );
    if (!hService)
    {
        CResString cCantOpenMsmq(IDS_STR_CANT_OPEN_MSMQ) ;
        MessageBox( NULL,
                    cCantOpenMsmq.Get(),
                    cErrorTitle.Get(),
                    (MB_OK | MB_ICONSTOP | MB_TASKMODAL)) ;
        return FALSE;
    }

    //
    // Set the start mode to be autostart.
    //
    BOOL f = ChangeServiceConfig( hService,
                                  SERVICE_NO_CHANGE ,
                                  SERVICE_AUTO_START,
                                  SERVICE_NO_CHANGE,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL ) ;
    if (!f)
    {
        CResString cCantCnfgMsmq(IDS_STR_CANT_CNFG_MSMQ) ;
        MessageBox( NULL,
                    cCantCnfgMsmq.Get(),
                    cErrorTitle.Get(),
                    (MB_OK | MB_ICONSTOP | MB_TASKMODAL)) ;
        return FALSE;
    }

    //
    // Now start the MSMQ service.
    // Continue even if failed. User can start it later.
    //
    BOOL fMSMQStarted = TRUE ;
    if (!StartService( hService, 0, NULL ))
    {
    	DWORD gle = GetLastError();
    	if (gle != ERROR_SERVICE_ALREADY_RUNNING)
    	{
	        CResString cCantStartMsmq(IDS_STR_CANT_START_MSMQ) ;
	        MessageBox( NULL,
	                    cCantStartMsmq.Get(),
	                    cWarningTitle.Get(),
	                    (MB_OK | MB_ICONWARNING | MB_TASKMODAL)) ;
	        fMSMQStarted = FALSE ;
    	}
    }    

    CloseServiceHandle( hService ) ;
    CloseServiceHandle( hServiceCtrlMgr ) ;
    return f ;    
    
}

//+--------------------------------------
//
//  BOOL  LoadMQMigratLibrary()
//
//+--------------------------------------

BOOL LoadMQMigratLibrary()
{
    if (g_hLib)
    {
        return TRUE ;
    }

    WCHAR  szDllName[ MAX_PATH ] = L"" ;
    DWORD dw = GetModuleFileName( 
    							NULL,
                                szDllName,
                                STRLEN(szDllName)
                                ) ;
    if (dw == 0)
    {
        return FALSE ;
    }

    WCHAR *p = wcsrchr(szDllName, L'\\') ;
    if (p)
    {
        p++;
        *p = L'\0';
        StringCchCat(szDllName,  MAX_PATH, MQMIGRAT_DLL_NAME) ;
 
        g_hLib = LoadLibrary(szDllName) ;
        if (!g_hLib)
        {
            return FALSE ;
        }
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}

//+-----------------------------------------------------------------------
//
// UINT MQMigUI_DisplayMessageBox()
//
//  This is a callback routine, called from the migration dll. We want
//  to keep all localizable resources in the exe, not in the dll.
//
//+-----------------------------------------------------------------------

UINT MQMigUI_DisplayMessageBox( ULONG ulTextId,
                                UINT  ulMsgBoxType )
{
    CResString cText(ulTextId) ;
    CResString cWarningTitle(IDS_STR_DEL_WELCOME_TITLE) ;

    return MessageBox( NULL,
                       cText.Get(),
                       cWarningTitle.Get(),
                       ulMsgBoxType ) ;
}

//+--------------------------------------
//
//  BOOL  _RunMigrationInternal()
//
//+--------------------------------------

static BOOL  _RunMigrationInternal(HRESULT  *phrResult)
{
    BOOL f = LoadMQMigratLibrary();
    if (!f)
    {
        return FALSE;
    }

    MQMig_MigrateFromMQIS_ROUTINE  pfnMigrate =
                 (MQMig_MigrateFromMQIS_ROUTINE)
                         GetProcAddress( g_hLib, "MQMig_MigrateFromMQIS" ) ;
    if (pfnMigrate)
    {
        g_fIsPEC = FALSE ;
        g_fIsOneServer = FALSE;
       
        *phrResult = (*pfnMigrate) ( g_pszMQISServerName,
                                         NULL,
                                         g_fReadOnly,
                                         g_fIsRecoveryMode,
                                         g_fIsClusterMode,
                                         g_pszLogFileName,
                                         g_ulTraceFlags,
                                        &g_fIsPEC,
                                         g_CurrentState,
                                        &g_fIsOneServer
                                         ) ;
        
        g_fMigrationCompleted = TRUE;

#ifdef _DEBUG

        BOOL fErr = FALSE ;

        if (g_fReadOnly)
        {
            fErr =  ReadDebugIntFlag(TEXT("FailAnalysis"), 0) ;
        }
        else
        {
            fErr =  ReadDebugIntFlag(TEXT("FailUpgrade"), 0) ;
        }

        if (fErr)
        {
            *phrResult = MQMig_E_UNKNOWN ;
        }

#endif
        
        if (!g_fReadOnly)
        {
            if (SUCCEEDED(*phrResult))
            {
                //
                // Migration succeeded and non-read-only mode
                //
                BOOL fStart = _StartMSMQService() ;
                UNREFERENCED_PARAMETER(fStart);

                if (!g_fIsRecoveryMode && !g_fIsClusterMode)
                {
                    //
                    // we are in normal mode
                    //
                    BOOL fWelcome = _RemoveFromWelcome() ;
                    UNREFERENCED_PARAMETER(fWelcome);
                }
            }                        
        }        
    }
    else //pfnMigrate
    {
        return FALSE ;
    }

    return TRUE ;
}

//+----------------------------
//
//  BOOL  RunMigration()
//
//+----------------------------

HRESULT  RunMigration()
{
    HRESULT hrResult = MQMig_OK ;

    BOOL f = _RunMigrationInternal(&hrResult) ;

    if (!f)
    {
        DisplayInitError( IDS_STR_CANT_START ) ;
        hrResult = MQMig_E_QUIT ;
    }

    return hrResult;
}

//+--------------------------------------------------------------
//
//  BOOL  CheckVersionOfMQISServers()
//
//  returns TRUE if user choosed to continue migration process.
//
//+--------------------------------------------------------------

BOOL CheckVersionOfMQISServers()
{
    BOOL f = LoadMQMigratLibrary();
    if (!f)
    {
        DisplayInitError( IDS_STR_CANT_START ) ;
        return f;
    }

    MQMig_CheckMSMQVersionOfServers_ROUTINE pfnCheckVer =
                     (MQMig_CheckMSMQVersionOfServers_ROUTINE)
               GetProcAddress( g_hLib, "MQMig_CheckMSMQVersionOfServers" ) ;
    ASSERT(pfnCheckVer) ;

    if (pfnCheckVer)
    {
        TCHAR ServerName[MAX_COMPUTERNAME_LENGTH+1];
        if (g_fIsClusterMode)
        {
            StringCchCopy(ServerName, TABLE_SIZE(ServerName), g_pszRemoteMQISServer);
        }
        else
        {
            unsigned long length=MAX_COMPUTERNAME_LENGTH+1;
            GetComputerName(ServerName, &length);
        }        

        UINT iCount = 0;
        AP<WCHAR> wszOldVerServers = NULL;
        HRESULT hr = (*pfnCheckVer) (
                            ServerName,
                            g_fIsClusterMode,
                            &iCount,
                            &wszOldVerServers ) ;
        if (FAILED(hr))
        {
            CResString cCantCheck(IDS_STR_CANT_CHECK) ;
            CResString cToContinue(IDS_STR_TO_CONTINUE) ;
            TCHAR szError[1024] ;
            StringCchPrintf(szError, TABLE_SIZE(szError), L"%s %x.%s", cCantCheck.Get(), hr, cToContinue.Get());

            CResString cErrorTitle(IDS_STR_ERROR_TITLE) ;
            DestroyWaitWindow() ; 

            if (MessageBox( NULL,
                            szError,
                            cErrorTitle.Get(),
                            (MB_OKCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL)) == IDCANCEL)
            {			
                return FALSE;
            }
            return TRUE;    //continue migration process
        }

        if (iCount == 0)
        {
            return TRUE;
        }

        DWORD dwSize = wcslen(wszOldVerServers) + 1;
        CResString cOldVerServers(IDS_OLD_VER_SERVERS) ;
        CResString cToContinue(IDS_STR_TO_CONTINUE) ;
        AP<TCHAR> szError = new TCHAR[1024 + dwSize] ;
        StringCchPrintf(szError, 1024 + dwSize, L"%s%s%s", cOldVerServers.Get(), wszOldVerServers, cToContinue.Get());

        CResString cErrorTitle(IDS_STR_ERROR_TITLE) ;
        DestroyWaitWindow() ;

        if (MessageBox( NULL,
                    szError,
                    cErrorTitle.Get(),
                    (MB_OKCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL)) == IDCANCEL)
        {		
            return FALSE;
        }
    }

    return TRUE;
}


//+--------------------------------------------------------------
//
//  void  ViewLogFile()
//
//  Function shows log file using notepad
//
//+--------------------------------------------------------------

void ViewLogFile()
{
    PROCESS_INFORMATION infoProcess;
    STARTUPINFO	infoStartup;
    memset(&infoStartup, 0, sizeof(STARTUPINFO)) ;
    infoStartup.cb = sizeof(STARTUPINFO) ;
    infoStartup.dwFlags = STARTF_USESHOWWINDOW ;
    infoStartup.wShowWindow = SW_NORMAL ;

    //
    // Create the process
    //
    TCHAR szSystemDir[MAX_PATH];
    GetSystemDirectory( szSystemDir,MAX_PATH);

    CString strNotepad;
    strNotepad.LoadString(IDS_NOTEPAD) ;

    WCHAR FullPath[MAX_PATH];
    WCHAR CommandParams[MAX_PATH];
    HRESULT hr = StringCchPrintf(FullPath, MAX_PATH, L"%s\\%s", szSystemDir, strNotepad);
    if (FAILED(hr))
    	return;
    
    hr = StringCchPrintf(CommandParams, MAX_PATH, L"%s %s", strNotepad, g_pszLogFileName);
    if (FAILED(hr))
    	return;
    

    if (!CreateProcess( FullPath,
                        CommandParams,
                        NULL,
                        NULL,
                        FALSE,
                        CREATE_NEW_CONSOLE,
                        NULL,
                        NULL,
                        &infoStartup,
                        &infoProcess ))
    {
		DWORD dwErr = GetLastError();
        UNREFERENCED_PARAMETER(dwErr);
        return;
    }

    if (WaitForSingleObject(infoProcess.hProcess, 0) == WAIT_FAILED)
    {
       DWORD dwErr = GetLastError();
       UNREFERENCED_PARAMETER(dwErr);
    }

    //
    // Close the thread and process handles
    //
    CloseHandle(infoProcess.hThread);
    CloseHandle(infoProcess.hProcess);
}

//+--------------------------------------------------------------
//
//  BOOL  SetSiteIdOfPEC
//
//  returns TRUE if SiteID of PEC machine was set successfully.
//
//+--------------------------------------------------------------

BOOL SetSiteIdOfPEC ()
{
    BOOL f = LoadMQMigratLibrary();
    if (!f)
    {
        DisplayInitError(IDS_STR_CANT_START) ;
        return FALSE;
    }

    MQMig_SetSiteIdOfPEC_ROUTINE pfnSetSiteId =
                     (MQMig_SetSiteIdOfPEC_ROUTINE)
               GetProcAddress( g_hLib, "MQMig_SetSiteIdOfPEC" ) ;
    ASSERT(pfnSetSiteId) ;

    BOOL fRes = TRUE;
    if (pfnSetSiteId)
    {
        HRESULT hr = (*pfnSetSiteId) (
                            g_pszRemoteMQISServer,
                            g_fIsClusterMode,
                            IDS_STR_CANT_START,
                            IDS_CANT_CONNECT_DATABASE,
                            IDS_CANT_GET_SITEID,                            
                            IDS_CANT_UPDATE_REGISTRY,
                            IDS_CANT_UPDATE_DS                            
                            ) ;
        if (hr != MQMig_OK)
        {
            DisplayInitError(hr) ;
            fRes = FALSE;
        }
    }
    else
    {
        DisplayInitError(IDS_STR_CANT_START) ;
        fRes = FALSE;
    }

    return fRes;
}

//+--------------------------------------------------------------
//
//  BOOL  UpdateRemoteMQIS()
//
//  returns TRUE if remote MQIS databases were updated successfully.
//
//+--------------------------------------------------------------

BOOL UpdateRemoteMQIS()
{
    BOOL f = LoadMQMigratLibrary();
    if (!f)
    {
        DisplayInitError(IDS_STR_CANT_START) ;
        return FALSE;
    }

    MQMig_UpdateRemoteMQIS_ROUTINE pfnUpdateRemoteMQIS =
                     (MQMig_UpdateRemoteMQIS_ROUTINE)
               GetProcAddress( g_hLib, "MQMig_UpdateRemoteMQIS" ) ;
    ASSERT(pfnUpdateRemoteMQIS) ;

    BOOL fRes = TRUE;
    if (pfnUpdateRemoteMQIS)
    {        
        AP<WCHAR> pwszNonUpdatedServers = NULL;
        AP<WCHAR> pwszUpdatedServers = NULL;
        HRESULT hr = (*pfnUpdateRemoteMQIS) (                                                        
                            IDS_CANT_GET_REGISTRY,
                            IDS_STR_CANT_START,
                            IDS_CANT_UPDATE_MQIS,
                            &pwszUpdatedServers,
                            &pwszNonUpdatedServers
                            ) ;
        if (hr != MQMig_OK)
        {
            switch (hr)
            {
            case IDS_CANT_GET_REGISTRY:   
            case IDS_STR_CANT_START:
                DisplayInitError(hr) ;
                break;

            case IDS_CANT_UPDATE_MQIS:
                {      
                    DWORD dwLen = 1 + wcslen(pwszNonUpdatedServers) ;
                    AP<CHAR> pszNonUpdServerName = new CHAR[ dwLen ] ;
                    ConvertToMultiByteString(pwszNonUpdatedServers, pszNonUpdServerName, dwLen);                                       
                    
                    CString cTextFailed;
                    cTextFailed.FormatMessage(IDS_CANT_UPDATE_MQIS, pszNonUpdServerName);
                    
                    CString cText = cTextFailed;

                    CResString cTitle(IDS_STR_ERROR_TITLE) ;

                    if (pwszUpdatedServers)
                    {                        
                        dwLen = 1 + wcslen(pwszUpdatedServers) ;
                        AP<CHAR> pszUpdServerName = new CHAR[ dwLen ] ;
                        ConvertToMultiByteString(pwszUpdatedServers, pszUpdServerName, dwLen);                    

                        CString cTextSucc ;
                        cTextSucc.FormatMessage(IDS_UPDATE_SUCCEEDED, pszUpdServerName);
                                                
                        cText.FormatMessage(IDS_UPDATE_PARTIALLY, cTextFailed, cTextSucc);
                    }                    

                    MessageBox( NULL,
                                cText,
                                cTitle.Get(),
                                (MB_OK | MB_ICONSTOP | MB_TASKMODAL) ) ;
                }
                break;

            default:
                break;
            }            
            fRes = FALSE;
        }
        else
        {   
            if (pwszUpdatedServers)
            {
                DWORD dwLen = 1 + wcslen(pwszUpdatedServers) ;
                AP<CHAR> pszServerName = new CHAR[ dwLen ] ;
                ConvertToMultiByteString(pwszUpdatedServers, pszServerName, dwLen);                    

                CString cText ;
			    cText.FormatMessage(IDS_UPDATE_SUCCEEDED, pszServerName);
                
                CResString cTitle(IDS_MIGTOOL_CAPTION);
                MessageBox( NULL,
                            cText,
                            cTitle.Get(),
                            (MB_OK | MB_ICONINFORMATION | MB_TASKMODAL) ) ;
            }
            else
            {
                //
                // the list is empty: maybe we ran this on PSC or 
                // there were no servers in .ini list
                //
                CString cText ;
			    cText.FormatMessage(IDS_NO_SERVER_TO_UPDATE);
                
                CResString cTitle(IDS_MIGTOOL_CAPTION);
                MessageBox( NULL,
                            cText,
                            cTitle.Get(),
                            (MB_OK | MB_ICONINFORMATION | MB_TASKMODAL) ) ;
            }
        }
    }
    else
    {
        DisplayInitError(IDS_STR_CANT_START) ;
        fRes = FALSE;
    }

    return fRes;    
}

//+--------------------------------------------------------------
//
//  BOOL  IsValidDllVersion()
//
//  returns TRUE if valid dll version is loaded
//
//+--------------------------------------------------------------

BOOL IsValidDllVersion ()
{
    WCHAR   szExeName[ MAX_PATH ] ;
    WCHAR   szDllName[ MAX_PATH ] = L"";
    
    DWORD dw = GetModuleFileName( 
    							NULL,
                                szDllName,
                                STRLEN(szDllName)
                                ) ;
    if (dw == 0)
    {
        DisplayInitError(IDS_STR_CANT_START) ;
        return FALSE ;
    }

    StringCchCopy(szExeName, TABLE_SIZE(szExeName), szDllName);

    TCHAR *p = wcsrchr(szDllName, TEXT('\\')) ;
    if (p)
    {
        p++ ;
        *p = L'\0';
        StringCchCat(szDllName, TABLE_SIZE(szDllName), MQMIGRAT_DLL_NAME) ;        
    }
    else
    {
        DisplayInitError(IDS_STR_CANT_START) ;
        return FALSE;
    }

    //
    // get file version of .exe
    //
    DWORD dwZero;

    DWORD dwInfoSize = GetFileVersionInfoSize(
                                    szExeName,	// pointer to filename string
                                    &dwZero 	// pointer to variable to receive zero
                                );

    if (0 == dwInfoSize)
    {
        //
        // Probably file does not exist
        //
        DisplayInitError(IDS_STR_CANT_DETERMINE_FILE_VERSION) ;
        return FALSE;
    }

    P<char>bufExeVer = new char[dwInfoSize];

    BOOL f = GetFileVersionInfo(
                        szExeName,	// pointer to filename string
                        0,	// ignored
                        dwInfoSize,	// size of buffer
                        bufExeVer 	// pointer to buffer to receive file-version info.
                        );

    if (!f)
    {
        DisplayInitError(IDS_STR_CANT_DETERMINE_FILE_VERSION) ;
        return FALSE;
    }

    VS_FIXEDFILEINFO *pvExe;
    UINT uiBufLen;

    f =  VerQueryValue(
                bufExeVer,	// address of buffer for version resource
                _T("\\"),	// address of value to retrieve
                (void **)&pvExe,	// address of buffer for version pointer
                &uiBufLen 	// address of version-value length buffer
                );
    if (!f)
    {
        DisplayInitError(IDS_STR_CANT_DETERMINE_FILE_VERSION);
        return FALSE;
    }

    //
    // get file version of .dll
    //
    dwInfoSize = GetFileVersionInfoSize(
                        szDllName,	// pointer to filename string
                        &dwZero 	// pointer to variable to receive zero
                    );

    if (0 == dwInfoSize)
    {
        //
        // Probably file does not exist
        //
        DisplayInitError(IDS_STR_CANT_DETERMINE_FILE_VERSION) ;
        return FALSE;
    }

    P<char>bufDllVer = new char[dwInfoSize];

    f = GetFileVersionInfo(
                szDllName,	// pointer to filename string
                0,	// ignored
                dwInfoSize,	// size of buffer
                bufDllVer 	// pointer to buffer to receive file-version info.
                );

    if (!f)
    {
        DisplayInitError(IDS_STR_CANT_DETERMINE_FILE_VERSION) ;
        return FALSE;
    }

    VS_FIXEDFILEINFO *pvDll;
   
    f =  VerQueryValue(
                bufDllVer,	// address of buffer for version resource
                _T("\\"),	// address of value to retrieve
                (void **)&pvDll,	// address of buffer for version pointer
                &uiBufLen 	// address of version-value length buffer
                );
    if (!f)
    {
        DisplayInitError(IDS_STR_CANT_DETERMINE_FILE_VERSION);
        return FALSE;
    }

    //
    // compare version of .dll and .exe
    //
    if (pvExe->dwFileVersionMS == pvDll->dwFileVersionMS &&
        pvExe->dwFileVersionLS == pvDll->dwFileVersionLS)
    {
        return TRUE;
    }

    DisplayInitError (IDS_STR_WRONG_DLL_VERSION);        
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\mgmtwin.h ===
#if !defined(AFX_MGMTWIN_H__64E9578A_E2B2_11D2_B185_0004ACC6C88D__INCLUDED_)
#define AFX_MGMTWIN_H__64E9578A_E2B2_11D2_B185_0004ACC6C88D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// MgmtWin.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CManagementWindow window

class CManagementWindow : public CWnd
{
// Construction
public:
	CManagementWindow();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CManagementWindow)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CManagementWindow();

	// Generated message map functions
protected:
	//{{AFX_MSG(CManagementWindow)
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MGMTWIN_H__64E9578A_E2B2_11D2_B185_0004ACC6C88D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\localds.cpp ===
//
// file: localds.cpp
//
// Check if local machine is also a domain controller. Migration tool
// can run only on a Dc machine.
//

#include "stdafx.h"
#include <autoptr.h>
#include <winldap.h>

#include "localds.tmh"


static bool IsServerGC(LPCWSTR pwszServerName)
/*++

Routine Description:
	Check that the server is GC

Arguments:
	pwszServerName - Server Name

Return Value:
	true if server is GC, false otherwise 
--*/
{
	LDAP* pLdap = ldap_init(
						const_cast<LPWSTR>(pwszServerName), 
						LDAP_GC_PORT
						);

	if(pLdap == NULL)
	{
		return false;
	}

    ULONG LdapError = ldap_set_option( 
							pLdap,
							LDAP_OPT_AREC_EXCLUSIVE,
							LDAP_OPT_ON  
							);

	if (LdapError != LDAP_SUCCESS)
    {
		return false;
    }

	LdapError = ldap_connect(pLdap, 0);
	if (LdapError != LDAP_SUCCESS)
    {
		return false;
    }

    ldap_unbind(pLdap);
	return true;
}


//+----------------------------------
//
//   BOOL IsLocalMachineDC()
//
//+----------------------------------

BOOL IsLocalMachineDC()
{
    BOOL  fIsDc = FALSE;

    DWORD dwNumChars = 0;
    P<TCHAR>  pwszComputerName = NULL;
    BOOL f = GetComputerNameEx( 
					ComputerNameDnsFullyQualified,
					NULL,
					&dwNumChars 
					);
    if (dwNumChars > 0)
    {
        pwszComputerName = new TCHAR[dwNumChars];
        f = GetComputerNameEx( 
				ComputerNameDnsFullyQualified,
				pwszComputerName,
				&dwNumChars 
				);
    }
    else
    {
        //
        // Maybe DNS names not supported. Try netbios.
        //
        dwNumChars = MAX_COMPUTERNAME_LENGTH + 2;
        pwszComputerName = new TCHAR[dwNumChars];
        f = GetComputerName( 
				pwszComputerName,
				&dwNumChars 
				);
    }
    if (!f)
    {
        return FALSE;
    }

	if(IsServerGC(pwszComputerName))
    {
        //
        // We opened connection with local GC. So we're a GC :=)
        //
        fIsDc = TRUE;
    }

    return fIsDc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\migservc.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    migservc.h

Abstract:

    - generic code to handle services.
    - code to check status of SQL server.

Author:

    Doron Juster  (DoronJ)  17-Jan-1999

--*/

#include <winsvc.h>

BOOL StartAService(SC_HANDLE hService) ;

BOOL IsMSMQServiceDisabled() ;

BOOL PrepareSpecialMode ();

BOOL UpdateRegistryDW (
		   LPTSTR  lpszRegName,
           DWORD   dwValue 
		   );

BOOL CheckRegistry (LPTSTR  lpszRegName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\migservc.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    migservc.cpp

Abstract:

    - generic code to handle services.
    - code to check status of SQL server.

Author:

    Doron Juster  (DoronJ)  17-Jan-1999

--*/

#include "stdafx.h"
#include <winsvc.h>
#include "resource.h"
#include "initwait.h"
#include "loadmig.h"
#include "..\..\setup\msmqocm\service.h"
#include <autoptr.h>
#include <privque.h>
#include <uniansi.h>
#include <mqtypes.h>
#include <mqprops.h>
#include <_mqini.h>
#include <_mqdef.h>
#include "mqnames.h"

#include "migservc.tmh"

SC_HANDLE g_hServiceCtrlMgr = NULL ;

#define SQL_SERVICE_NAME                    TEXT("MSSqlServer")
#define WAIT_INTERVAL                       100
#define MAXIMUM_WAIT_FOR_SERVICE_IN_MINUTES 10

//+--------------------------------------------------------------
//
//  BOOL  StartAService(SC_HANDLE hService)
//
//  returns TRUE if service started
//
//+--------------------------------------------------------------

BOOL StartAService(SC_HANDLE hService)
{
    BOOL f = StartService (hService, 0, NULL);
    if (!f)
    {
        //
        // Failed to start service
        //
        return f;
    }

    //
    // Wait until the service has finished initializing
    //
    SERVICE_STATUS statusService;
    DWORD dwWait = 0;
    do
    {
        Sleep(WAIT_INTERVAL);
        dwWait += WAIT_INTERVAL;

        if (!QueryServiceStatus(hService, &statusService))
        {
            return FALSE;
        }
        if (statusService.dwCurrentState == SERVICE_RUNNING)
        {
            break;
        }

        if (dwWait > (MAXIMUM_WAIT_FOR_SERVICE_IN_MINUTES * 60000))
        {
            return FALSE;
		}
    } while (TRUE);

    return TRUE;
}

//+--------------------------------------------------------------
//
//  BOOL  StopAService(SC_HANDLE hService)
//
//  returns TRUE if service stopped
//
//+--------------------------------------------------------------

BOOL StopAService (SC_HANDLE hService)
{
    SERVICE_STATUS statusService;
    BOOL f = ControlService(
                    hService,               // handle to service
                    SERVICE_CONTROL_STOP,   // control code
                    &statusService          // pointer to service status structure
                    );

    if (!f)
    {
        return FALSE;
    }

    //
    // Wait until the service has finished stopping
    //
    DWORD dwWait = 0;
    do
    {
        if (statusService.dwCurrentState == SERVICE_STOPPED)
        {
            break;
        }

        if (dwWait > (MAXIMUM_WAIT_FOR_SERVICE_IN_MINUTES * 60000))
        {
            return FALSE;
		}

        Sleep(WAIT_INTERVAL);
        dwWait += WAIT_INTERVAL;

        if (!QueryServiceStatus(hService, &statusService))
        {
            return FALSE;
        }

    } while (TRUE);


    return TRUE;
}

//+--------------------------------------------------------------
//
//  BOOL  DisableAService(SC_HANDLE hService)
//
//  returns TRUE if service disabled
//
//+--------------------------------------------------------------

BOOL DisableAService (IN  SC_HANDLE  hService)
{
    BOOL f = ChangeServiceConfig(
                  hService ,            // handle to service
                  SERVICE_NO_CHANGE ,   // type of service
                  SERVICE_DISABLED ,    // when to start service
                  SERVICE_NO_CHANGE ,   // severity if service fails to start
                  NULL ,                // pointer to service binary file name
                  NULL ,                // pointer to load ordering group name
                  NULL ,                // pointer to variable to get tag identifier
                  NULL ,                // pointer to array of dependency names
                  NULL ,                // pointer to account name of service
                  NULL ,                // pointer to password for service account
                  NULL                  // pointer to display name
                  );
    if (!f)
    {
        HRESULT hr = GetLastError();
        UNREFERENCED_PARAMETER(hr);
        return FALSE;
    }

    //
    // Wait until the service will be disabled
    //
    P<QUERY_SERVICE_CONFIG> pConfig = new QUERY_SERVICE_CONFIG ;
    DWORD   dwReqSize = 0 ;
    DWORD   dwWait = 0;
    do
    {
        BOOL fConfig = QueryServiceConfig( hService,
                                           pConfig,
                                           sizeof(QUERY_SERVICE_CONFIG),
                                           &dwReqSize ) ;
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
           	pConfig.free() ;
            pConfig = (QUERY_SERVICE_CONFIG*) new BYTE[ dwReqSize ] ;
            fConfig = QueryServiceConfig( hService,
                                          pConfig,
                                          dwReqSize,
                                         &dwReqSize ) ;
        }

        if (!fConfig)
        {
            return FALSE;
        }

        if (pConfig->dwStartType  == SERVICE_DISABLED)
        {
            break;
        }

        Sleep(WAIT_INTERVAL);
        dwWait += WAIT_INTERVAL;

        if (dwWait > (MAXIMUM_WAIT_FOR_SERVICE_IN_MINUTES * 60000))
        {
            return FALSE;
		}
    } while (TRUE);

    return TRUE;
}

//+--------------------------------------------------------------
//
//  BOOL _GetServiceState()
//
//  This function query the service manager for status and configuration
//  of a service.
//  return TRUE if service is registered and its status is available.
//
//+--------------------------------------------------------------

static BOOL _GetServiceState( IN  LPTSTR     ptszServiceName,
                              IN  DWORD      dwManagerError,
                              IN  DWORD      dwOpenError,
                              IN  DWORD      dwQueryError,
                              OUT SC_HANDLE *phService,
                              OUT DWORD     *pdwErrorCode,
                              OUT DWORD     *pdwStatus,
                              OUT DWORD     *pdwConfig )
{
    if (!g_hServiceCtrlMgr)
    {
        g_hServiceCtrlMgr = OpenSCManager( NULL,
                                           NULL,
                                           SC_MANAGER_ALL_ACCESS );
    }
    if (!g_hServiceCtrlMgr)
    {
        *pdwErrorCode = dwManagerError ;
        return FALSE;
	}

    //
    // Open a handle to the service
    //
    *phService = OpenService( g_hServiceCtrlMgr,
                              ptszServiceName,
                              SERVICE_ALL_ACCESS) ;
    if (!*phService)
    {
        //
        // Service not installed
        //
        *pdwErrorCode = dwOpenError ;
        return FALSE;
    }

    if (pdwStatus)
    {
        SERVICE_STATUS statusService;
        if (!QueryServiceStatus(*phService, &statusService))
        {
            //
            // Service is not installed
            //
            *pdwErrorCode = dwQueryError ;
            CloseServiceHandle(*phService);
            *phService = NULL;

            return FALSE;
        }
        *pdwStatus = statusService.dwCurrentState ;
    }

    if (pdwConfig)
    {
        P<QUERY_SERVICE_CONFIG> pConfig = new QUERY_SERVICE_CONFIG ;
        DWORD  dwReqSize = 0 ;
        SetLastError(0) ;
        BOOL fConfig = QueryServiceConfig(*phService,
                                           pConfig,
                                           sizeof(QUERY_SERVICE_CONFIG),
                                           &dwReqSize ) ;
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            delete pConfig ;
            pConfig = (QUERY_SERVICE_CONFIG*) new BYTE[ dwReqSize ] ;
            fConfig = QueryServiceConfig(*phService,
                                          pConfig,
                                          dwReqSize,
                                         &dwReqSize ) ;
        }

        if (fConfig)
        {
            *pdwConfig = pConfig->dwStartType ;
        }
        else
        {
            *pdwErrorCode = dwQueryError ;
            CloseServiceHandle(*phService);
            *phService = NULL;

            return FALSE;
        }
    }

    return TRUE;
}

//+--------------------------------------------------------------
//
//  BOOL  CheckSQLServerStatus()
//
//  returns TRUE if SQL Server is running
//
//+--------------------------------------------------------------

BOOL CheckSQLServerStatus()
{
    DWORD     dwErr = 0 ;
    DWORD     dwServiceStatus = 0 ;
    SC_HANDLE hService = NULL;
    BOOL f = _GetServiceState( SQL_SERVICE_NAME,
                               IDS_STR_FAILED_OPEN_MGR,
                               IDS_STR_CANT_OPEN_SQLSERVER,
                               IDS_STR_CANT_GET_SQLSERVER_STATUS,
                              &hService,
                              &dwErr,
                              &dwServiceStatus,
                               NULL ) ;

    if (f && (dwServiceStatus == SERVICE_RUNNING))
    {
        //
        // SQL Server is running
        //
        CloseServiceHandle(hService);
        return f;
    }

    if (!hService)
    {
        ASSERT(dwErr) ;
        DisplayInitError( dwErr ) ;

        return FALSE;
    }

    int iMsgStatus = DisplayInitError( IDS_SQL_NOT_STARTED,
                      (MB_OKCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL)) ;
    if (iMsgStatus == IDCANCEL)
    {
        CloseServiceHandle(hService);
        return FALSE;
    }

    //
    // start SQL Server
    //
    DisplayWaitWindow() ;

    f = StartAService(hService);
    CloseServiceHandle(hService);
    if (f)
    {
        return f;
    }

    //
    // failed to start SQL Server
    //
    DisplayInitError( IDS_STR_CANT_START_SQL_SERVER ) ;
    return f;
}

//+------------------------------------------------------------------------
//
//  BOOL IsMSMQServiceDisabled()
//
//  Check if MSMQ service is disabled. If not, don't run the migration tool.
//  We don't want that the tool be run by mistake, after MQIS was already
//  migrated and MSMQ service started.
//  Return TRUE if MSMQ service is disabled.
//
//+------------------------------------------------------------------------

BOOL IsMSMQServiceDisabled()
{
    DWORD     dwErr = 0 ;
    DWORD     dwServiceConfig = 0 ;
    DWORD 	  dwServiceState = 0;
    SC_HANDLE hService = NULL;
    BOOL f = _GetServiceState( MSMQ_SERVICE_NAME,
                               IDS_STR_FAILED_OPEN_MGR,
                               IDS_CANT_OPEN_MSMQ_SRVICE,
                               IDS_CANT_GET_MSMQ_CONFIG,
                               &hService,
                               &dwErr,
                               &dwServiceState,
                               &dwServiceConfig ) ;
    if (f)
    {
        CloseServiceHandle(hService);
        if ((dwServiceConfig == SERVICE_DISABLED) && (dwServiceState == SERVICE_STOPPED))
        {
            return TRUE ;
        }
        dwErr = IDS_MSMQ_NOT_DISABLED ;
    }

    ASSERT(dwErr) ;
    DisplayInitError( dwErr ) ;

    return FALSE ;
}

//+--------------------------------------------------------------
//
//  BOOL  CheckRegistry ()
//
//	Function checks if specific value exists in registry
//  returns TRUE if registry value exists
//
//+--------------------------------------------------------------

BOOL CheckRegistry (LPTSTR  lpszRegName)
{
	HKEY hRegKey;

    TCHAR szKeyName[256 * MAX_BYTES_PER_CHAR];
    _stprintf(szKeyName, TEXT("%s\\%s"), FALCON_REG_KEY, lpszRegName);

	TCHAR *pLastBackslash = _tcsrchr(szKeyName, TEXT('\\'));

    TCHAR szValueName[256 * MAX_BYTES_PER_CHAR];
    _tcscpy(szValueName, _tcsinc(pLastBackslash));
    _tcscpy(pLastBackslash, TEXT(""));

	HRESULT hResult = RegOpenKeyEx(
						  FALCON_REG_POS,			// handle to open key
						  szKeyName,				// address of name of subkey to open
						  0,						// reserved
						  KEY_QUERY_VALUE ,			// security access mask
						  &hRegKey					// address of handle to open key
						  );
	if (hResult != ERROR_SUCCESS)
	{
		return FALSE;
	}

	hResult =  RegQueryValueEx(
					hRegKey,            // handle to key to query
					szValueName,		// address of name of value to query
					NULL,				// reserved
					NULL,				// address of buffer for value type
					NULL,				// address of data buffer
					NULL				// address of data buffer size
					);
	RegCloseKey(hRegKey);
	if (hResult != ERROR_SUCCESS)
	{
		return FALSE;
	}

	return TRUE;
}

//+--------------------------------------------------------------
//
//  BOOL  UpdateRegistryDW ()
//
//  returns TRUE if registry was updated succesfully
//
//+--------------------------------------------------------------

BOOL UpdateRegistryDW (LPTSTR  lpszRegName,
                       DWORD   dwValue )
{
	HKEY hRegKey;

    TCHAR szKeyName[256 * MAX_BYTES_PER_CHAR];
    _stprintf(szKeyName, TEXT("%s\\%s"), FALCON_REG_KEY, lpszRegName);

    TCHAR *pLastBackslash = _tcsrchr(szKeyName, TEXT('\\'));

    TCHAR szValueName[256 * MAX_BYTES_PER_CHAR];
    _tcscpy(szValueName, _tcsinc(pLastBackslash));
    _tcscpy(pLastBackslash, TEXT(""));

    //
    // Create the subkey, if necessary
    //
    DWORD dwDisposition;	
	HRESULT hResult = RegCreateKeyEx( FALCON_REG_POS,
							  szKeyName,
							  0,
							  NULL,
							  REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS,
							  NULL,
							  &hRegKey,
							  &dwDisposition);

	if (hResult != ERROR_SUCCESS)
	{
        DisplayInitError( IDS_CANT_UPDATE_REGISTRY );
		return FALSE;
	}

    BYTE *pValueData = (BYTE *) &dwValue;
	hResult = RegSetValueEx( hRegKey,
                             szValueName,
                             0,
                             REG_DWORD,
                             pValueData,
                             sizeof(DWORD));

    if (hResult != ERROR_SUCCESS)
	{
        RegCloseKey(hRegKey);
        DisplayInitError( IDS_CANT_UPDATE_REGISTRY );
		return FALSE;
	}

    RegFlushKey(hRegKey);
    RegCloseKey(hRegKey);

    return TRUE;
}


//+------------------------------------------------------------------------
//
//  BOOL StopAndDisableService ()
//
//  Return TRUE if service was stopped and disabled
//
//+------------------------------------------------------------------------

BOOL StopAndDisableService (IN  LPTSTR     ptszServiceName)
{
    //
    // stop and disable service
    //
    DWORD     dwErr = 0 ;
    DWORD     dwServiceConfig = 0 ;
    DWORD     dwServiceStatus = 0 ;
    SC_HANDLE hService = NULL;

    DWORD      dwOpenError;
    DWORD      dwQueryError;
    DWORD      dwStopError;
    DWORD      dwDisableError;

    if (lstrcmpi(ptszServiceName, MSMQ_SERVICE_NAME) == 0)
    {
        dwOpenError = IDS_CANT_OPEN_MSMQ_SRVICE;
        dwQueryError = IDS_CANT_GET_MSMQ_CONFIG;
        dwStopError = IDS_STR_CANT_STOP_MSMQ;
        dwDisableError = IDS_STR_CANT_DISABLE_MSMQ;
    }
    else
    {
        ASSERT(0);
        return FALSE;
    }

    BOOL f = _GetServiceState( ptszServiceName,
                               IDS_STR_FAILED_OPEN_MGR,
                               dwOpenError,
                               dwQueryError,
                              &hService,
                              &dwErr,
                              &dwServiceStatus,
                              &dwServiceConfig ) ;
    if (!f)
    {
        ASSERT(dwErr) ;
        DisplayInitError( dwErr ) ;
        return FALSE;
    }

    if (dwServiceStatus != SERVICE_STOPPED)
    {
        f = StopAService (hService) ;
        if (!f)
        {
            DisplayInitError(dwStopError) ;
            return FALSE;
        }
    }

    if (dwServiceConfig != SERVICE_DISABLED)
    {
        f = DisableAService (hService) ;
        if (!f)
        {
            DisplayInitError(dwDisableError) ;
            return FALSE;
        }
    }
    CloseServiceHandle(hService);

    return TRUE;
}

//+------------------------------------------------------------------------
//
//  BOOL PrepareSpecialMode()
//
//  For recovery purpose we have to do the following:
//      - stop msmq service
//      - recovery mode: set to registry correct SiteId of this machine
//
//
//  Return TRUE if every thing succeeded
//
//+------------------------------------------------------------------------

BOOL PrepareSpecialMode ()
{
    //
    // stop and disable msmq service
    //
    BOOL f = StopAndDisableService (MSMQ_SERVICE_NAME);
    if (!f)
    {
        return FALSE;
    }

    //
    // Setup set SiteID of Default-First-Site to registry.
    // We need to get MasterId of the PEC/PSC machine (its site id)
    // from remote MQIS database and create entry MasterId in Migration section
    // with this value and (only in recovery mode) change value of SiteId entry
    // in registry and in DS. In addition, we'll get service of remote machine
    // and put this value to registry.
    //
    f = SetSiteIdOfPEC();
    if (!f)
    {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\miguidbg.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    miguidbg.cpp

Abstract:

    Code for debugging the migration tool.
Author:

    Doron Juster  (DoronJ)  07-Feb-1999

--*/

#include "stdafx.h"

#include "miguidbg.tmh"

//+------------------------------------
//
//  UINT  ReadDebugIntFlag()
//
//+------------------------------------

#ifdef _DEBUG

UINT  ReadDebugIntFlag(TCHAR *pwcsDebugFlag, UINT iDefault)
{
    static BOOL   s_fInitialized = FALSE ;
    static TCHAR  s_szIniName[ MAX_PATH ] = {TEXT('\0')} ;

    if (!s_fInitialized)
    {
        DWORD dw = GetModuleFileName( NULL,
                                      s_szIniName,
                       (sizeof(s_szIniName) / sizeof(s_szIniName[0]))) ;
        if (dw != 0)
        {
            TCHAR *p = _tcsrchr(s_szIniName, TEXT('\\')) ;
            if (p)
            {
                p++ ;
                _tcscpy(p, TEXT("migtool.ini")) ;
            }
        }
        s_fInitialized = TRUE ;
    }

    UINT uiDbg = GetPrivateProfileInt( TEXT("Debug"),
                                       pwcsDebugFlag,
                                       iDefault,
                                       s_szIniName ) ;
    return uiDbg ;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\mqmig.h ===
// MqMig.h : main header file for the MQMIG application
//

#if !defined(AFX_MQMIG_H__0EDB9A87_CDF2_11D1_938E_0020AFEDDF63__INCLUDED_)
#define AFX_MQMIG_H__0EDB9A87_CDF2_11D1_938E_0020AFEDDF63__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

enum MigrationState
{
	msScanMode,
	msMigrationMode,
	msUpdateClientsMode,
	msUpdateServersMode,
	msQuickMode,
	msUpdateOnlyRegsitryMode
};

/////////////////////////////////////////////////////////////////////////////
// CMqMigApp:
// See MqMig.cpp for the implementation of this class
//

class CMqMigApp : public CWinApp
{
public:
	HWND m_hWndMain;
	CMqMigApp();
    BOOL AnalyzeCommandLine() ;
    LPTSTR SkipSpaces (LPTSTR pszStr) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMqMigApp)
	public:
	virtual BOOL InitInstance();
	virtual int  ExitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMqMigApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

extern CMqMigApp theApp;
/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MQMIG_H__0EDB9A87_CDF2_11D1_938E_0020AFEDDF63__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\prgrsbar.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: prgrsbar.cpp

Abstract: implement the progress bars in the "wait" page.

Author:

    Erez Vizel
    Doron Juster

--*/

#include "stdafx.h"
#include "thrSite.h"
#include "sThrPrm.h"
#include "loadmig.h"
#include "..\mqmigrat\mqmigui.h"

#include "prgrsbar.tmh"

extern BOOL g_fMigrationCompleted;

//+----------------------------------------------------------------------
//
//  UINT ProgSiteThread(LPVOID var)
//
//  This thread read the migration counters from mqmigrat.dll and update
//  the progress bars.
//
//+----------------------------------------------------------------------

UINT __cdecl ProgressBarsThread(LPVOID lpV)
{	
	UINT iLastSitePosition = 0 ;
    UINT iLastQueuePosition = 0 ;
    UINT iLastMachinePosition = 0 ;
	UINT iLastUserPosition = 0 ;
	UINT iSiteCounter = 0 ;
    UINT iMachineCounter = 0 ;
    UINT iQueueCounter = 0 ;
	UINT iUserCounter = 0 ;

	sThreadParm* pVar = (sThreadParm*) lpV ;

	//
    //  Setting the progress ranges
    //
	(pVar->pSiteProgress)->SetRange( (short) g_iSiteLowLimit, (short) g_iSiteHighLimit);
	(pVar->pMachineProgress)->SetRange( (short) g_iMachineLowLimit, (short) g_iMachineHighLimit) ;
	(pVar->pQueueProgress)->SetRange( (short) g_iQueueLowLimit, (short) g_iQueueHighLimit) ;
	(pVar->pUserProgress)->SetRange( (short) g_iUserLowLimit, (short) g_iUserHighLimit);

	//
    //  Reseting the progress bars
    //
    (pVar->pSiteProgress)->SetPos(g_iSiteLowLimit);
	(pVar->pQueueProgress)->SetPos(g_iQueueLowLimit);
	(pVar->pMachineProgress)->SetPos(g_iMachineLowLimit);
	(pVar->pUserProgress)->SetPos(g_iUserLowLimit);

	//
	// Loading the Dll
	//
    BOOL f = LoadMQMigratLibrary(); // load dll
    if (!f)
    {
        return FALSE;  //error in loading the dll
    }

    MQMig_GetAllCounters_ROUTINE pfnGetAllCounters =
                 (MQMig_GetAllCounters_ROUTINE)
                          GetProcAddress( g_hLib, "MQMig_GetAllCounters" ) ;
	ASSERT(pfnGetAllCounters != NULL);

	if(pfnGetAllCounters == NULL)
	{	
		//
		//Error free the dll
		//
		return FALSE;
	}

	while( !g_fMigrationCompleted )
	{	
		//
		//Updating the value of the counters
		//
		HRESULT hr = (*pfnGetAllCounters)( &iSiteCounter,
                                           &iMachineCounter,
                                           &iQueueCounter,
										   &iUserCounter) ;
        UNREFERENCED_PARAMETER(hr);
		if(	(iSiteCounter    != iLastSitePosition)    ||
			(iMachineCounter != iLastMachinePosition) ||
			(iQueueCounter   != iLastQueuePosition)	  ||
			(iUserCounter    != iLastUserPosition)	)
		{
			iLastSitePosition =
                        (pVar->pSiteProgress)->SetPos((iSiteCounter)) ;
			iLastMachinePosition =
                        (pVar->pMachineProgress)->SetPos(iMachineCounter) ;
			iLastQueuePosition =
                        (pVar->pQueueProgress)->SetPos(iQueueCounter) ;
			iLastUserPosition =
                        (pVar->pUserProgress)->SetPos(iUserCounter) ;
		}
        Sleep(250);
	}

	//
    //  Leave the progress bars full.
    //
    delete lpV ;

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\sthrprm.h ===
#ifndef _THRPARM
#define _THRPARM
#include "stdafx.h"
typedef struct ThreadParm
{
	CPropertySheetEx* pPageFather;
	CProgressCtrl*  pSiteProgress;
	CProgressCtrl*  pMachineProgress;
	CProgressCtrl*  pQueueProgress;
	CProgressCtrl*  pUserProgress;
	int iPageNumber;
	
} sThreadParm;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\resource.h ===
#include "..\..\mqutil\res\migtools\migdllres.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\textfont.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    textfont.h

Abstract:

    define fonts for text in the upgrade wizard.

Author:

    Doron Juster  (DoronJ)  07-Feb-1999

--*/

#define  WELCONE_TITLE_WEIGHT   (FW_BOLD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\mqmig.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name: MqMig.cpp

Abstract: Defines the class behaviors for the application.

Author:

    Erez Vizel
    Doron Juster

--*/

#include "stdafx.h"
#include "MqMig.h"
#include "cWizSht.h"
#include "initwait.h"
#include "migservc.h"
#include "mgmtwin.h"
#include "..\migrepl.h"
#include "_mqres.h"

#include "mqmig.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern HINSTANCE g_hLib ;
HINSTANCE  g_hResourceMod = MQGetResourceHandle();

/////////////////////////////////////////////////////////////////////////////
// CMqMigApp

BEGIN_MESSAGE_MAP(CMqMigApp, CWinApp)
	//{{AFX_MSG_MAP(CMqMigApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMqMigApp construction

CMqMigApp::CMqMigApp() :
	m_hWndMain(0)
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMqMigApp object

CMqMigApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CMqMigApp initialization

BOOL IsLocalMachineDC() ;
BOOL CheckVersionOfMQISServers();
BOOL CheckSQLServerStatus();
BOOL UpdateRemoteMQIS();
BOOL IsValidDllVersion ();

BOOL      g_fIsRecoveryMode = FALSE;
BOOL      g_fIsClusterMode = FALSE;
LPTSTR    g_pszRemoteMQISServer = NULL ;
BOOL      g_fUpdateRemoteMQIS = FALSE;
BOOL 	  g_QuickMode = FALSE;

LPVOID s_lpvMem = NULL;
HANDLE s_hMapMem = NULL;

BOOL CMqMigApp::InitInstance()
{

#ifdef _CHECKED
    // Send asserts to message box
    _set_error_mode(_OUT_TO_MSGBOX);
#endif

    CManagementWindow mgmtWin;
	if (mgmtWin.CreateEx(0, AfxRegisterWndClass(0), TEXT("MsmqMigrationMgmtWin"), 0, 0,0,0,0, 
		               HWND_DESKTOP, 0) == 0)
	{
		ASSERT(0);
		mgmtWin.m_hWnd = 0;
	}

	// create a global memory file map

	s_hMapMem = CreateFileMapping(
						INVALID_HANDLE_VALUE,
                        NULL,                   // Security descriptor
                        PAGE_READWRITE,
						0,                      // Size (high)
                        1024,                   // Size (low)
                        TEXT("mqmig")
                        );
	if ( !s_hMapMem )
	{
		return FALSE;
	}
	DWORD dwLastErr = GetLastError();
	// Get a pointer to the shared memory
	s_lpvMem = MapViewOfFile( s_hMapMem, FILE_MAP_WRITE, 0,0, 0 );
	if ( !s_lpvMem ) {
		return FALSE;
	}

	if (dwLastErr == ERROR_ALREADY_EXISTS)
	{	
		HWND hWnd;
		memcpy( &hWnd, (char*)s_lpvMem, sizeof (ULONG) );
		::PostMessage(hWnd, WM_SETFOCUS, 0 , 0);
        return FALSE;
	}
	else
	{
		memcpy( (char*)s_lpvMem, &(mgmtWin.m_hWnd), sizeof (ULONG) );
	}

    AfxSetResourceHandle(g_hResourceMod);
    
    //
    // analyze command line
    //
    if (m_lpCmdLine[0] != '\0')
    {
        BOOL f = AnalyzeCommandLine();
        if (!f)
        {
            //
            // parameters were wrong
            //
            CString cText ;
			cText.FormatMessage(IDS_MQMIG_USAGE, m_pszExeName);

            CResString cTitle(IDS_STR_ERROR_TITLE) ;

            MessageBox( NULL,
                        cText,
                        cTitle.Get(),
                        (MB_OK | MB_ICONSTOP | MB_TASKMODAL) ) ;
            return FALSE;
        }
    }

    //
    // Display the "please wait" box.
    // Do it after acquiring the module handle.
    //
    DisplayWaitWindow() ;

    //
    // first of all, verify that dll version is valid
    //
    BOOL f = IsValidDllVersion ();
    if (!f)
    {
        DestroyWaitWindow(TRUE) ;
        return FALSE;
    }

    if (g_fUpdateRemoteMQIS)
    {
        //
        // we don't need UI in this mode
        //
        BOOL f = UpdateRemoteMQIS();
        UNREFERENCED_PARAMETER(f);
        DestroyWaitWindow(TRUE) ;        
        return FALSE;
    }

    if (g_fIsRecoveryMode || g_fIsClusterMode)
    {
        BOOL f = PrepareSpecialMode ();
        if (!f)
        {
            DestroyWaitWindow(TRUE) ;
            return FALSE;
        }
    }        

    if (!IsMSMQServiceDisabled() && !CheckRegistry(MIGRATION_UPDATE_REGISTRY_ONLY))
    {
        //
        // Service is not disabled. and we're not only updating the registry - quit!
        // The MSMQ service must be disabled in order for the migration
        // tool to start running.
        //
        DestroyWaitWindow(TRUE) ;
        return FALSE ;
    }

    //
    // Next, check if we're a DC.
    //
    f = IsLocalMachineDC() ;
    if (!f)
    {
        DisplayInitError( IDS_STR_NOT_DC ) ;
        DestroyWaitWindow(TRUE) ;
        return FALSE ;
    }

    //
    // Check now if SQL server is installed and running on this computer
    // If we are in recovery/cluster mode we don't have SQL Server installed on this
    // computer
    //
    if (!g_fIsRecoveryMode && !g_fIsClusterMode)
    {
        f = CheckSQLServerStatus();
        if (!f)
        {
            DestroyWaitWindow(TRUE) ;
            return FALSE;
        }
    }

    if (!g_fIsRecoveryMode && !CheckRegistry(MIGRATION_UPDATE_REGISTRY_ONLY))
    {
        //
        // Check now if version of each MQIS server is not less than MSMQ SP4
        // We need to check that in both normal and cluster modes.
        //
        f = CheckVersionOfMQISServers();
        if (!f)
        {
            DestroyWaitWindow(TRUE) ;
            return FALSE;
        }
    }

	cWizSheet cMigSheet ;
    DestroyWaitWindow(TRUE) ;

	int nResponse = cMigSheet.DoModal();	
    UNREFERENCED_PARAMETER(nResponse);

	//
    // Since the dialog has been closed, return FALSE so that we exit the
	// application, rather than start the application's message pump.
    //
	return FALSE;
}

//+----------------------------------------------------------------
//
// int  CMqMigApp::ExitInstance()
//
//  this is called when process exit. Free the migration dll.
//
//+----------------------------------------------------------------

int  CMqMigApp::ExitInstance()
{
	if (s_lpvMem)
	{
		// disconect process from global shared memory
		UnmapViewOfFile( s_lpvMem );
	}

	if (s_hMapMem)
	{
		// close the global memory FileMapping handle
		CloseHandle( s_hMapMem );
	}

    if (g_hLib)
    {
        FreeLibrary(g_hLib) ;
        g_hLib = NULL ;
    }
    return 0 ;
}

LPTSTR CMqMigApp::SkipSpaces (LPTSTR pszStr)
{
    while (*pszStr == _T(' '))
    {
        pszStr = CharNext(pszStr);
    }	
	return pszStr;
}

BOOL CMqMigApp::AnalyzeCommandLine()
{
    //
	// skip program name
	//
    LPTSTR pszCurParam = m_lpCmdLine;
    pszCurParam = CharLower(pszCurParam);

    while (*pszCurParam != _T('/') && *pszCurParam != _T('\0') )
    {
        pszCurParam = CharNext(pszCurParam);
    }
    if (*pszCurParam == _T('\0'))
    {
        return FALSE;
    }

    while (*pszCurParam != _T('\0') )
	{		
        if (*pszCurParam != _T('/'))
        {
            return FALSE;
        }
				
        pszCurParam = CharNext(pszCurParam);	
        switch (*pszCurParam)
        {
        case 'r':
            if (g_fIsRecoveryMode)
            {
                //
                // we already got this parameter
                //
                return FALSE;
            }
            g_fIsRecoveryMode = TRUE;
            pszCurParam = CharNext(pszCurParam);
            pszCurParam = SkipSpaces(pszCurParam);
            break;
        case 'c':
            if (g_fIsClusterMode)
            {
                //
                // we already got this parameter
                //
                return FALSE;
            }
            g_fIsClusterMode = TRUE;
            pszCurParam = CharNext(pszCurParam);
            pszCurParam = SkipSpaces(pszCurParam);
            break;
        case 'u':
            if (g_fUpdateRemoteMQIS)
            {
                //
                // we already got this parameter
                //
                return FALSE;
            }
            g_fUpdateRemoteMQIS = TRUE;
            pszCurParam = CharNext(pszCurParam);
            pszCurParam = SkipSpaces(pszCurParam);
            break;
        case 's':
            {
                if (g_pszRemoteMQISServer)
                {
                    //
                    // we already got this parameter
                    //
                    return FALSE;
                }						
                pszCurParam = CharNext(pszCurParam);
			    pszCurParam = SkipSpaces(pszCurParam);

                g_pszRemoteMQISServer = new TCHAR[ 1 + _tcslen(pszCurParam)] ;

                LPTSTR pszServer = g_pszRemoteMQISServer;
                while ( *pszCurParam != _T('\0') &&
                        *pszCurParam != _T('/') &&
                        *pszCurParam != _T(' '))
			    {				
                    *pszServer = *pszCurParam;
                    pszCurParam = CharNext(pszCurParam);
                    pszServer = CharNext(pszServer);
			    }			
                *pszServer = _T('\0');
			
                if (g_pszRemoteMQISServer[0] == '\0')
                {
                    //
                    // we did not get value
                    //
                    delete g_pszRemoteMQISServer;
                    return FALSE;
                }
                if (*pszCurParam != _T('\0'))
                {
                    pszCurParam = CharNext(pszCurParam);
			        pszCurParam = SkipSpaces(pszCurParam);
                }
            }
            break;
		case 'q':
			g_QuickMode = TRUE;
			pszCurParam = CharNext(pszCurParam);
            pszCurParam = SkipSpaces(pszCurParam);
			break;
        case '?':
            return FALSE;
        default:
            return FALSE;
		}	
	}

    //
    // verify all parameters: /r OR /c AND /s <server name> are mandatory
    //
    if ( (g_fIsRecoveryMode || g_fIsClusterMode) && // for these parameters 
          g_pszRemoteMQISServer == NULL )           // server name is mandatory
    {
        g_fIsRecoveryMode = FALSE;
        g_fIsClusterMode = FALSE;
        return FALSE;
    }

    if (g_fUpdateRemoteMQIS  &&  //for this flag we don't need server name       
        g_pszRemoteMQISServer)
    {        
        delete[] g_pszRemoteMQISServer;
        g_pszRemoteMQISServer = NULL;
        return FALSE;
    }

    if (!g_fIsRecoveryMode && 
        !g_fIsClusterMode &&
        !g_fUpdateRemoteMQIS)
    {
        delete[] g_pszRemoteMQISServer;
        g_pszRemoteMQISServer = NULL;
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__0EDB9A8B_CDF2_11D1_938E_0020AFEDDF63__INCLUDED_)
#define AFX_STDAFX_H__0EDB9A8B_CDF2_11D1_938E_0020AFEDDF63__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _DEBUG
#undef _DEBUG
#endif

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxdlgs.h>

#ifdef DBG
    #include <assert.h>
	#undef ASSERT
	#define ASSERT(f) assert(f)
#endif // DBG


#include <mqmacro.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0EDB9A8B_CDF2_11D1_938E_0020AFEDDF63__INCLUDED_)

#include "commonui.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\thranz.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    thranz.cpp

Abstract:

    Thread that run the migration process in "analysis", read only, mode.

Author:

    Erez  Vizel
    Doron Juster  (DoronJ)

--*/

#include "stdafx.h"
#include "loadmig.h"
#include "sThrPrm.h"
#include "mqsymbls.h"

#include "thranz.tmh"

extern HRESULT   g_hrResultAnalyze ;

//+------------------------------------
//
//  UINT AnalyzeThread(LPVOID lpV)
//
//+------------------------------------

UINT __cdecl AnalyzeThread(LPVOID lpV)
{
    sThreadParm* pVar = (sThreadParm*) (lpV) ;
	
	//
    //  Reseting the progress bars
    //	
    (pVar->pSiteProgress)->SetPos(0);
	(pVar->pQueueProgress)->SetPos(0);
	(pVar->pMachineProgress)->SetPos(0);
	(pVar->pUserProgress)->SetPos(0);


    g_hrResultAnalyze = RunMigration() ;

    if (g_hrResultAnalyze == MQMig_E_QUIT)
    {
        ExitProcess(0) ;
    }

    //
    // Activating the next page,
    // either Pre-Migration page or the Finish page.
    //	
    UINT i=( (pVar->pPageFather)->SetActivePage(pVar->iPageNumber));
    UNREFERENCED_PARAMETER(i);

	delete lpV ;
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\thranz.h ===
#ifndef _ANALYZE_THREAD
#define _ANALYZE_THREAD

extern HRESULT RunMigration();
extern  g_fSuccess;

UINT AnalyzeThread(LPVOID Dummy);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\thrmig.h ===
#ifndef _RUN_MIGRATION_THREAD
#define _RUN_MIGRATION_THREAD

extern HRESULT RunMigration();
extern  g_fSuccess;
UINT RunMigrationThread(LPVOID Dummy);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\thrmig.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    thrmig.cpp

Abstract:

    thread to run migration code (in mqmigrat.dll)

Author:

    Erez Vizel

--*/

#include "stdafx.h"
#include "loadmig.h"
#include "sThrPrm.h"
#include "mqsymbls.h"

#include "thrmig.tmh"

extern HRESULT   g_hrResultMigration ;

extern UINT _FINISH_PAGE;

//+-----------------------------------------
//
//  UINT RunMigrationThread(LPVOID lpV)
//
//+-----------------------------------------

UINT __cdecl RunMigrationThread(LPVOID lpV)
{
    sThreadParm* pVar = (sThreadParm*)(lpV);
	//
    //  Reseting the progress bars
    //	
    (pVar->pSiteProgress)->SetPos(0);
	(pVar->pQueueProgress)->SetPos(0);
	(pVar->pMachineProgress)->SetPos(0);
	(pVar->pUserProgress)->SetPos(0);

    g_hrResultMigration = RunMigration() ;

    if (g_hrResultMigration == MQMig_E_QUIT)
    {
        ExitProcess(0) ;
    }

	//
	// Display finish page.
	// 
    pVar->iPageNumber = _FINISH_PAGE;


    UINT i=( (pVar->pPageFather)->SetActivePage(pVar->iPageNumber));
    UNREFERENCED_PARAMETER(i);

	delete lpV ;
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmig\thrsite.h ===
//
//
//
#ifndef _progSiteThread_h_
#define _progSiteThread_h_

extern UINT       g_iSiteHighLimit;
extern const UINT g_iSiteLowLimit;
extern UINT       g_iMachineHighLimit;
extern const UINT g_iMachineLowLimit;
extern UINT       g_iQueueHighLimit;
extern const UINT g_iQueueLowLimit;
extern UINT       g_iUserHighLimit;
extern const UINT g_iUserLowLimit;


UINT __cdecl ProgressBarsThread(LPVOID progress);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\database.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    database.cpp

Abstract:

    SQL database related code.
Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

#include "migrat.h"
#include <mqsec.h>

#include "database.tmh"

void StringToSeqNum( IN TCHAR    pszSeqNum[],
                     OUT CSeqNum *psn );


MQDBHANDLE g_hDatabase = NULL ;
MQDBHANDLE g_hEntTable = NULL ;
MQDBHANDLE g_hSiteTable = NULL ;
MQDBHANDLE g_hSiteLinkTable = NULL ;
MQDBHANDLE g_hCNsTable = NULL ;
MQDBHANDLE g_hMachineTable = NULL ;
MQDBHANDLE g_hMachineCNsTable = NULL ;
MQDBHANDLE g_hQueueTable = NULL ;
MQDBHANDLE g_hUsersTable = NULL ;
MQDBHANDLE g_hDeletedTable = NULL ;

//--------------------------------------------------
//
//  HRESULT ConnectToDatabase()
//
//--------------------------------------------------

HRESULT ConnectToDatabase(BOOL fConnectAlways)
{
    static BOOL s_fConnected = FALSE ;
    if (s_fConnected && !fConnectAlways)
    {
        return TRUE ;
    }

    HRESULT hr = MQDBInitialize() ;
    CHECK_HR(hr) ;

    MQDBOPENDATABASE mqdbOpen = {DSN_NAME,
                                 NULL,
                                 "msmq",
                                 "Falcon",
                                 FALSE,
                                 NULL} ;
    hr = MQDBOpenDatabase(&mqdbOpen) ;
    CHECK_HR(hr) ;

    g_hDatabase =  mqdbOpen.hDatabase ;
    s_fConnected = TRUE;
    return hr  ;
}

//--------------------------------------------------
//
//   HRESULT OpenUsersTable()
//
//--------------------------------------------------

HRESULT OpenUsersTable()
{
    HRESULT hr ;
    if (!g_hUsersTable)
    {
        hr = MQDBOpenTable( g_hDatabase,
                            USER_TABLE_NAME,
                            &g_hUsersTable ) ;
        CHECK_HR(hr) ;
    }
    return MQ_OK ;
}

//--------------------------------------------------
//
//  HRESULT GetUserCount(UINT *pcUsers)
//
//--------------------------------------------------

HRESULT GetUserCount(UINT *pcUsers)
{
    HRESULT hr = OpenUsersTable();
    CHECK_HR(hr) ;

    hr = MQDBGetTableCount( g_hUsersTable,
                            pcUsers ) ;
    return hr ;
}

//--------------------------------------------------
//
//   HRESULT _OpenMachineTable()
//
//--------------------------------------------------

static HRESULT _OpenMachineTable()
{
    HRESULT hr ;
    if (!g_hMachineTable)
    {
        hr = MQDBOpenTable( g_hDatabase,
                            MACHINE_TABLE_NAME,
                            &g_hMachineTable ) ;
        CHECK_HR(hr) ;
    }
    return MQ_OK ;
}

//--------------------------------------------------
//
//   HRESULT OpenMachineCNsTable()
//
//--------------------------------------------------

HRESULT OpenMachineCNsTable()
{
    HRESULT hr ;
    if (!g_hMachineCNsTable)
    {
        hr = MQDBOpenTable( g_hDatabase,
                            MACHINE_CN_TABLE_NAME,
                            &g_hMachineCNsTable ) ;
        CHECK_HR(hr) ;
    }
    return MQ_OK ;
}

//--------------------------------------------------
//
//   HRESULT OpenCNsTable()
//
//--------------------------------------------------

HRESULT OpenCNsTable()
{
    HRESULT hr ;
    if (!g_hCNsTable)
    {
        hr = MQDBOpenTable( g_hDatabase,
                            CN_TABLE_NAME,
                            &g_hCNsTable ) ;
        CHECK_HR(hr) ;
    }
    return MQ_OK ;
}

//--------------------------------------------------
//
//  HRESULT GetCNCount(UINT *pcCNs)
//
//--------------------------------------------------

HRESULT GetCNCount(UINT *pcCNs)
{
    HRESULT hr = OpenCNsTable();
    CHECK_HR(hr) ;

    hr = MQDBGetTableCount( g_hCNsTable,
                            pcCNs ) ;
    return hr ;
}

//--------------------------------------------------
//
//   HRESULT OpenQueueTable()
//
//--------------------------------------------------

HRESULT OpenQueueTable()
{
    HRESULT hr ;
    if (!g_hQueueTable)
    {
        hr = MQDBOpenTable( g_hDatabase,
                            QUEUE_TABLE_NAME,
                            &g_hQueueTable ) ;
        CHECK_HR(hr) ;
    }
    return MQ_OK ;
}

//--------------------------------------------------
//
//   HRESULT OpenDeletedTable()
//
//--------------------------------------------------

HRESULT OpenDeletedTable()
{
    HRESULT hr ;
    if (!g_hDeletedTable)
    {
        hr = MQDBOpenTable( g_hDatabase,
                            DELETED_TABLE_NAME,
                            &g_hDeletedTable ) ;
        CHECK_HR(hr) ;
    }
    return MQ_OK ;
}

//--------------------------------------------------
//
//   HRESULT OpenEntTable()
//
//--------------------------------------------------

HRESULT OpenEntTable()
{
    HRESULT hr ;
    if (!g_hEntTable)
    {
        hr = MQDBOpenTable( g_hDatabase,
                            ENTERPRISE_TABLE_NAME,
                            &g_hEntTable ) ;
        CHECK_HR(hr) ;
    }
    return MQ_OK ;
}

//--------------------------------------------------
//
//   HRESULT OpenSiteLinkTable()
//
//--------------------------------------------------

HRESULT OpenSiteLinkTable()
{
    HRESULT hr ;
    if (!g_hSiteLinkTable)
    {
        hr = MQDBOpenTable( g_hDatabase,
                            LINK_TABLE_NAME,
                            &g_hSiteLinkTable ) ;
        CHECK_HR(hr) ;
    }
    return MQ_OK ;
}

//--------------------------------------------------
//
//  HRESULT GetSiteLinkCount(UINT *pcSiteLinks)
//
//--------------------------------------------------

HRESULT GetSiteLinkCount(UINT *pcSiteLinks)
{
    HRESULT hr = OpenSiteLinkTable();
    CHECK_HR(hr) ;

    hr = MQDBGetTableCount( g_hSiteLinkTable,
                            pcSiteLinks ) ;
    return hr ;
}

//--------------------------------------------------
//
//   HRESULT _OpenSiteTable()
//
//--------------------------------------------------

HRESULT _OpenSiteTable()
{
    HRESULT hr ;
    if (!g_hSiteTable)
    {
        hr = MQDBOpenTable( g_hDatabase,
                            SITE_TABLE_NAME,
                            &g_hSiteTable ) ;
        CHECK_HR(hr) ;
    }
    return MQ_OK ;
}

//--------------------------------------------------
//
//  HRESULT GetSitesCount(UINT *pcSites)
//
//--------------------------------------------------

HRESULT GetSitesCount(UINT *pcSites)
{
    HRESULT hr = _OpenSiteTable ();
    CHECK_HR(hr) ;

    hr = MQDBGetTableCount( g_hSiteTable,
                            pcSites ) ;
    return hr ;
}

//--------------------------------------------------
//
//  HRESULT GetAllMachinesCount(UINT *pcMachines)
//
//--------------------------------------------------

HRESULT GetAllMachinesCount(UINT *pcMachines)
{
    HRESULT hr = _OpenMachineTable() ;
    CHECK_HR(hr) ;

    hr = MQDBGetTableCount( g_hMachineTable,
                            pcMachines ) ;
    return hr ;
}

//--------------------------------------------------
//
//  HRESULT GetAllQueuesCount(UINT *pcQueues)
//
//--------------------------------------------------

HRESULT GetAllQueuesCount(UINT *pcQueues)
{
    HRESULT hr = OpenQueueTable() ;
    CHECK_HR(hr) ;

    hr = MQDBGetTableCount( g_hQueueTable,
                            pcQueues ) ;
    return hr ;
}

//--------------------------------------------------
//
//  HRESULT GetMachinesCount(UINT *pcMachines)
//
//--------------------------------------------------

HRESULT GetMachinesCount(IN  GUID *pSiteGuid,
                         OUT UINT *pcMachines)
{
    HRESULT hr = _OpenMachineTable() ;
    CHECK_HR(hr) ;

    MQDBCOLUMNSEARCH ColSearch[2] ;
    INIT_COLUMNSEARCH(ColSearch[0]) ;
    ColSearch[0].mqdbColumnVal.lpszColumnName = M_OWNERID_COL ;
    ColSearch[0].mqdbColumnVal.mqdbColumnType = M_OWNERID_CTYPE ;
    ColSearch[0].mqdbColumnVal.nColumnValue = (LONG) pSiteGuid ;
    ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
    ColSearch[0].mqdbOp = EQ ;

    hr = MQDBGetTableCount( g_hMachineTable,
                            pcMachines,
                            ColSearch ) ;
    return hr ;
}

//--------------------------------------------------
//
//  HRESULT GetQueuesCount(UINT *pcMachines)
//
//--------------------------------------------------

HRESULT GetQueuesCount( IN  GUID *pMachineGuid,
                        OUT UINT *pcQueues )
{
    HRESULT hr = OpenQueueTable() ;
    CHECK_HR(hr) ;

    LONG cColumns = 0 ;
    MQDBCOLUMNSEARCH ColSearch[2] ;

    INIT_COLUMNSEARCH(ColSearch[ cColumns ]) ;
    ColSearch[ cColumns ].mqdbColumnVal.lpszColumnName = Q_QMID_COL ;
    ColSearch[ cColumns ].mqdbColumnVal.mqdbColumnType = Q_QMID_CTYPE ;
    ColSearch[ cColumns ].mqdbColumnVal.nColumnValue = (LONG) pMachineGuid ;
    ColSearch[ cColumns ].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
    ColSearch[ cColumns ].mqdbOp = EQ ;
    cColumns++ ;

    hr = MQDBGetTableCount( g_hQueueTable,
                            pcQueues,
                            ColSearch,
                            cColumns ) ;

    return hr ;
}

//--------------------------------------------------
//
//  HRESULT GetAllQueuesInSiteCount(IN  GUID *pSiteGuid,
//                                  OUT UINT *pcQueues)
//
//--------------------------------------------------

HRESULT GetAllQueuesInSiteCount( IN  GUID *pSiteGuid,
                                 OUT UINT *pcQueues )
{
    HRESULT hr = OpenQueueTable() ;
    CHECK_HR(hr) ;

    LONG cColumns = 0 ;
    MQDBCOLUMNSEARCH ColSearch[2] ;

    INIT_COLUMNSEARCH(ColSearch[ cColumns ]) ;
    ColSearch[ cColumns ].mqdbColumnVal.lpszColumnName = Q_OWNERID_COL ;
    ColSearch[ cColumns ].mqdbColumnVal.mqdbColumnType = Q_OWNERID_CTYPE ;
    ColSearch[ cColumns ].mqdbColumnVal.nColumnValue = (LONG) pSiteGuid ;
    ColSearch[ cColumns ].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
    ColSearch[ cColumns ].mqdbOp = EQ ;
    cColumns++ ;

    hr = MQDBGetTableCount( g_hQueueTable,
                            pcQueues,
                            ColSearch,
                            cColumns ) ;

    return hr ;
}

HRESULT GetAllObjectsNumber (IN  GUID *pSiteGuid,
                             IN  BOOL    fPec,
                             OUT UINT *puiAllObjectNumber )
{
    HRESULT hr;
    UINT CurNum;	
    if (fPec)
    {
        // get site number
        hr = GetSitesCount(&CurNum);
        CHECK_HR(hr);
        *puiAllObjectNumber += CurNum;

        // get user number
        hr = GetUserCount(&CurNum);
        CHECK_HR(hr);
        *puiAllObjectNumber += CurNum;

        // get sitelink number
        hr = GetSiteLinkCount(&CurNum);
        CHECK_HR(hr);
        *puiAllObjectNumber += CurNum;

        // get CN number (if needed)
        hr = GetCNCount(&CurNum);
        CHECK_HR(hr);
        *puiAllObjectNumber += CurNum;

        // +1 (enterprise object)
        (*puiAllObjectNumber) ++;
    }
    else
    {
        hr = GetAllQueuesInSiteCount( pSiteGuid, &CurNum );
        CHECK_HR(hr);
        *puiAllObjectNumber += CurNum;

        hr = GetMachinesCount( pSiteGuid, &CurNum);
        CHECK_HR(hr);
        *puiAllObjectNumber += CurNum;
    }

    return MQMig_OK;
}

//--------------------------------------------------
//
//  HRESULT  FindLargestSeqNum(GUID *pMasterId)
//
//--------------------------------------------------

#define  PROCESS_RESULT     \
    if (SUCCEEDED(hr) &&                                                  \
        ((const unsigned char *) pColumns[ iSeqNumIndex ].nColumnValue )) \
    {                                                                     \
        snLsn.SetValue(                                                   \
          (const unsigned char *) pColumns[ iSeqNumIndex ].nColumnValue ) ; \
                                                                            \
        if (snLsn > snMaxLsn)                                               \
        {                                                                   \
            snMaxLsn = snLsn;                                               \
        }                                                                   \
        MQDBFreeBuf ((void *) pColumns[ iSeqNumIndex ].nColumnValue) ;      \
    }                                                                       \
    else if (SUCCEEDED(hr))                                                 \
    {                                                                       \
        /*                                                                  \
           success with NULL value. It's OK, as NO_MORE_DATA                \
        */                                                                  \
    }                                                                       \
    else if (hr == MQDB_E_NO_MORE_DATA)                                     \
    {                                                                       \
        /*                                                                  \
           that's OK.                                                       \
        */                                                                  \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        ASSERT(0) ;                                                         \
        return hr ;                                                         \
    }

HRESULT  FindLargestSeqNum( GUID    *pMasterId,
                            CSeqNum &snMaxLsn,
                            BOOL    fPec )
{
    CSeqNum snLsn;

    LONG cAlloc = 1 ;
    LONG cColumns = 0 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;
    MQDBCOLUMNSEARCH ColSearch[1] ;

    if (fPec)
    {
        //
        // for PEC, look also in the Enterprise, Site, CN and users table.
        //

        HRESULT hr = OpenUsersTable() ;
        CHECK_HR(hr) ;

        INIT_COLUMNVAL(pColumns[ cColumns ]) ;
        pColumns[ cColumns ].lpszColumnName = U_SEQNUM_COL ;
        pColumns[ cColumns ].nColumnValue   = 0 ;
        pColumns[ cColumns ].nColumnLength  = 0 ;
        pColumns[ cColumns ].mqdbColumnType = U_SEQNUM_CTYPE ;
        UINT iSeqNumIndex = cColumns ;
        cColumns++ ;

        ASSERT(cColumns == cAlloc) ;

        hr =  MQDBOpenAggrQuery( g_hUsersTable,
                                 pColumns,
                                 MQDBAGGR_MAX,
                                 NULL,
                                 0,
                                 AND);
        PROCESS_RESULT ;

        //
        // Search the enterprise table.
        //
        hr = OpenEntTable() ;
        CHECK_HR(hr) ;

        cColumns = 0 ;
        INIT_COLUMNVAL(pColumns[ cColumns ]) ;
        pColumns[ cColumns ].lpszColumnName = E_SEQNUM_COL ;
        pColumns[ cColumns ].nColumnValue   = 0 ;
        pColumns[ cColumns ].nColumnLength  = 0 ;
        pColumns[ cColumns ].mqdbColumnType = E_SEQNUM_CTYPE ;
        iSeqNumIndex = cColumns ;
        cColumns++ ;

        ASSERT(cColumns == cAlloc) ;

        hr =  MQDBOpenAggrQuery( g_hEntTable,
                                 pColumns,
                                 MQDBAGGR_MAX,
                                 NULL,
                                 0,
                                 AND);
        PROCESS_RESULT ;

        //
        // Search the CNs table.
        //
        hr = OpenCNsTable() ;
        CHECK_HR(hr) ;

        cColumns = 0 ;
        INIT_COLUMNVAL(pColumns[ cColumns ]) ;
        pColumns[ cColumns ].lpszColumnName = CN_SEQNUM_COL ;
        pColumns[ cColumns ].nColumnValue   = 0 ;
        pColumns[ cColumns ].nColumnLength  = 0 ;
        pColumns[ cColumns ].mqdbColumnType = CN_SEQNUM_CTYPE ;
        iSeqNumIndex = cColumns ;
        cColumns++ ;

        ASSERT(cColumns == cAlloc) ;

        hr =  MQDBOpenAggrQuery( g_hCNsTable,
                                 pColumns,
                                 MQDBAGGR_MAX,
                                 NULL,
                                 0,
                                 AND);
        PROCESS_RESULT ;

        //
        // Search the site table.
        //
        cColumns = 0 ;
        INIT_COLUMNVAL(pColumns[ cColumns ]) ;
        pColumns[ cColumns ].lpszColumnName = S_SEQNUM_COL ;
        pColumns[ cColumns ].nColumnValue   = 0 ;
        pColumns[ cColumns ].nColumnLength  = 0 ;
        pColumns[ cColumns ].mqdbColumnType = S_SEQNUM_CTYPE ;
        iSeqNumIndex = cColumns ;
        cColumns++ ;

        ASSERT(cColumns == cAlloc) ;
        ASSERT(g_hSiteTable) ;

        hr =  MQDBOpenAggrQuery( g_hSiteTable,
                                 pColumns,
                                 MQDBAGGR_MAX,
                                 NULL,
                                 0,
                                 AND);
        PROCESS_RESULT ;

        //
        // search the sitelink table
        //
        hr = OpenSiteLinkTable() ;
        CHECK_HR(hr) ;

        cColumns = 0 ;
        INIT_COLUMNVAL(pColumns[ cColumns ]) ;
        pColumns[ cColumns ].lpszColumnName = L_SEQNUM_COL ;
        pColumns[ cColumns ].nColumnValue   = 0 ;
        pColumns[ cColumns ].nColumnLength  = 0 ;
        pColumns[ cColumns ].mqdbColumnType = L_SEQNUM_CTYPE ;
        iSeqNumIndex = cColumns ;
        cColumns++ ;

        ASSERT(cColumns == cAlloc) ;

        hr =  MQDBOpenAggrQuery( g_hSiteLinkTable,
                                 pColumns,
                                 MQDBAGGR_MAX,
                                 NULL,
                                 0,
                                 AND);
        PROCESS_RESULT ;
    }
    else
    {
        //
        // Reteive SeqNum from the Queue table.
        //
        HRESULT hr = OpenQueueTable() ;
        CHECK_HR(hr) ;

        INIT_COLUMNVAL(pColumns[ cColumns ]) ;
        pColumns[ cColumns ].lpszColumnName = Q_SEQNUM_COL ;
        pColumns[ cColumns ].nColumnValue   = 0 ;
        pColumns[ cColumns ].nColumnLength  = 0 ;
        pColumns[ cColumns ].mqdbColumnType = Q_SEQNUM_CTYPE ;
        UINT iSeqNumIndex = cColumns ;
        cColumns++ ;

        INIT_COLUMNSEARCH(ColSearch[0]) ;
        ColSearch[0].mqdbColumnVal.lpszColumnName = Q_OWNERID_COL ;
        ColSearch[0].mqdbColumnVal.mqdbColumnType = Q_OWNERID_CTYPE ;
        ColSearch[0].mqdbColumnVal.nColumnValue = (LONG) pMasterId ;
        ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
        ColSearch[0].mqdbOp = EQ ;

        ASSERT(cColumns == cAlloc) ;

        hr =  MQDBOpenAggrQuery( g_hQueueTable,
                                 pColumns,
                                 MQDBAGGR_MAX,
                                 ColSearch,
                                 1,
                                 AND);
        PROCESS_RESULT ;

        //
        // Reteive SeqNum from the Machine table.
        //
        hr = _OpenMachineTable() ;
        CHECK_HR(hr) ;

        cColumns = 0 ;
        INIT_COLUMNVAL(pColumns[ cColumns ]) ;
        pColumns[ cColumns ].lpszColumnName = M_SEQNUM_COL ;
        pColumns[ cColumns ].nColumnValue   = 0 ;
        pColumns[ cColumns ].nColumnLength  = 0 ;
        pColumns[ cColumns ].mqdbColumnType = M_SEQNUM_CTYPE ;
        iSeqNumIndex = cColumns ;
        cColumns++ ;

        INIT_COLUMNSEARCH(ColSearch[0]) ;
        ColSearch[0].mqdbColumnVal.lpszColumnName = M_OWNERID_COL ;
        ColSearch[0].mqdbColumnVal.mqdbColumnType = M_OWNERID_CTYPE ;
        ColSearch[0].mqdbColumnVal.nColumnValue = (LONG) pMasterId ;
        ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
        ColSearch[0].mqdbOp = EQ ;

        ASSERT(cColumns == cAlloc) ;

        hr =  MQDBOpenAggrQuery( g_hMachineTable,
                                 pColumns,
                                 MQDBAGGR_MAX,
                                 ColSearch,
                                 1,
                                 AND);
        PROCESS_RESULT ;
    }

    //
    // Reteive SeqNum from the Deleted table.
    //
    HRESULT hr = OpenDeletedTable() ;
    CHECK_HR(hr) ;

    cColumns = 0 ;
    INIT_COLUMNVAL(pColumns[ cColumns ]) ;
    pColumns[ cColumns ].lpszColumnName = D_SEQNUM_COL ;
    pColumns[ cColumns ].nColumnValue   = 0 ;
    pColumns[ cColumns ].nColumnLength  = 0 ;
    pColumns[ cColumns ].mqdbColumnType = D_SEQNUM_CTYPE ;
    UINT iSeqNumIndex = cColumns ;
    cColumns++ ;

    INIT_COLUMNSEARCH(ColSearch[0]) ;
    ColSearch[0].mqdbColumnVal.lpszColumnName = D_OWNERID_COL ;
    ColSearch[0].mqdbColumnVal.mqdbColumnType = D_OWNERID_CTYPE ;
    ColSearch[0].mqdbColumnVal.nColumnValue = (LONG) pMasterId ;
    ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
    ColSearch[0].mqdbOp = EQ ;

    ASSERT(cColumns == cAlloc) ;

    hr =  MQDBOpenAggrQuery( g_hDeletedTable,
                             pColumns,
                             MQDBAGGR_MAX,
                             ColSearch,
                             1,
                             AND);
    PROCESS_RESULT ;

    return S_OK ;
}

//+--------------------------------------------------
//
//  HRESULT EnableMultipleQueries(BOOL fEnable)
//
//+--------------------------------------------------

HRESULT EnableMultipleQueries(BOOL fEnable)
{
    HRESULT hr = MQDBSetOption( g_hDatabase,
                                MQDBOPT_MULTIPLE_QUERIES,
                                fEnable,
                                NULL ) ;
    return hr ;
}

//--------------------------------------------------
//
//  void    CleanupDatabase()
//
//--------------------------------------------------

void    CleanupDatabase()
{
    if (g_hEntTable)
    {
        MQDBCloseTable(g_hEntTable) ;
        g_hEntTable = NULL ;
    }
    if (g_hSiteTable)
    {
        MQDBCloseTable(g_hSiteTable) ;
        g_hSiteTable = NULL ;
    }
    if (g_hMachineTable)
    {
        MQDBCloseTable(g_hMachineTable) ;
        g_hMachineTable = NULL ;
    }
    if (g_hMachineCNsTable)
    {
        MQDBCloseTable(g_hMachineCNsTable) ;
        g_hMachineCNsTable = NULL ;
    }
    if (g_hCNsTable)
    {
        MQDBCloseTable(g_hCNsTable) ;
        g_hCNsTable = NULL ;
    }
    if (g_hQueueTable)
    {
        MQDBCloseTable(g_hQueueTable) ;
        g_hQueueTable = NULL ;
    }
    if (g_hUsersTable)
    {
        MQDBCloseTable(g_hUsersTable) ;
        g_hUsersTable = NULL ;
    }
    if (g_hDeletedTable)
    {
        MQDBCloseTable(g_hDeletedTable) ;
        g_hDeletedTable = NULL ;
    }
}

//--------------------------------------------------
//
//  HRESULT    CheckVersion (UINT   *piCount, LPTSTR *ppszServers)
//
//--------------------------------------------------
#define INIT_MACHINE_COLUMN(_ColName, _ColIndex, _Index)            \
    INIT_COLUMNVAL(pColumns[ _Index ]) ;                            \
    pColumns[ _Index ].lpszColumnName = ##_ColName##_COL ;          \
    pColumns[ _Index ].nColumnValue   = 0 ;                         \
    pColumns[ _Index ].nColumnLength  = 0 ;                         \
    pColumns[ _Index ].mqdbColumnType = ##_ColName##_CTYPE ;        \
    UINT _ColIndex = _Index ;                                       \
    _Index++ ;

HRESULT CheckVersion (
              OUT UINT   *piOldVerServersCount,
              OUT LPTSTR *ppszOldVerServers
              )
{
    HRESULT hr = _OpenMachineTable() ;
    CHECK_HR(hr) ;

    UINT cMachines;
    hr = MQDBGetTableCount( g_hMachineTable,
                            &cMachines ) ;
    CHECK_HR(hr) ;

    if (cMachines == 0)
    {
        return MQMig_E_NO_MACHINES_AVAIL ;
    }

    ULONG cAlloc = 5 ;
    ULONG cbColumns = 0 ;
    AP<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

    INIT_MACHINE_COLUMN(M_NAME1,          iName1Index,      cbColumns) ;
    INIT_MACHINE_COLUMN(M_NAME2,          iName2Index,      cbColumns) ;
    INIT_MACHINE_COLUMN(M_SERVICES,       iServiceIndex,    cbColumns) ;
    INIT_MACHINE_COLUMN(M_MTYPE,          iTypeIndex,       cbColumns) ;
    INIT_MACHINE_COLUMN(M_OWNERID,        iOwnerIdIndex,    cbColumns) ;

    #undef  INIT_MACHINE_COLUMN

    //
    // Restriction. query by machine service.
    //
    MQDBCOLUMNSEARCH ColSearch[1] ;
    INIT_COLUMNSEARCH(ColSearch[0]) ;
    ColSearch[0].mqdbColumnVal.lpszColumnName = M_SERVICES_COL ;
    ColSearch[0].mqdbColumnVal.mqdbColumnType = M_SERVICES_CTYPE ;
    ColSearch[0].mqdbColumnVal.nColumnValue = (ULONG) SERVICE_BSC ;
    ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(ULONG) ;
    ColSearch[0].mqdbOp = GE ;

    ASSERT(cbColumns == cAlloc) ;

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hMachineTable,
                                       pColumns,
                                       cbColumns,
                                       ColSearch,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
							           TRUE ) ;
    CHECK_HR(status) ;

    LPWSTR *ppwcsOldVerServers = new LPWSTR[cMachines];
    *piOldVerServersCount = 0;

    UINT iIndex = 0 ;
	
    TCHAR *pszFileName = GetIniFileName ();
    ULONG ulServerCount = 0;

    while(SUCCEEDED(status))
    {
        if (iIndex >= cMachines)
        {
            status = MQMig_E_TOO_MANY_MACHINES ;
            break ;
        }

        //
        // Get one name buffer from both name columns.
        //
        P<BYTE> pwzBuf = NULL ;
        DWORD  dwIndexs[2] = { iName1Index, iName2Index } ;
        HRESULT hr =  BlobFromColumns( pColumns,
                                       dwIndexs,
                                       2,
                                       (BYTE**) &pwzBuf ) ;
        CHECK_HR(hr) ;
        WCHAR *pwzMachineName = (WCHAR*) (pwzBuf + sizeof(DWORD)) ;

        //
        // we check version on all PSCs and on all BSCs of PEC
        //
        if ( (DWORD)pColumns[ iServiceIndex ].nColumnValue == SERVICE_PSC   ||
             ( (DWORD)pColumns[ iServiceIndex ].nColumnValue == SERVICE_BSC &&
                memcmp (  &g_MySiteGuid,
                          (void*) pColumns[ iOwnerIdIndex ].nColumnValue,
                          sizeof(GUID)) == 0 ) )
        {
            BOOL fOldVersion;
            hr = AnalyzeMachineType ((LPWSTR) pColumns[ iTypeIndex ].nColumnValue,
                                     &fOldVersion);
            if (FAILED(hr))
            {
                LogMigrationEvent(  MigLog_Error,
                                    hr,
                                    pwzMachineName,
                                    (LPWSTR) pColumns[ iTypeIndex ].nColumnValue
                                    ) ;
            }
            if (SUCCEEDED(hr) && fOldVersion)
            {
                LogMigrationEvent(  MigLog_Info,
                                    MQMig_I_OLD_MSMQ_VERSION,
                                    pwzMachineName,
                                    (LPWSTR) pColumns[ iTypeIndex ].nColumnValue
                                    ) ;

                ppwcsOldVerServers[*piOldVerServersCount] = new WCHAR[wcslen(pwzMachineName)+1];
		        wcscpy (ppwcsOldVerServers[*piOldVerServersCount], pwzMachineName);
                (*piOldVerServersCount)++;
            }
            if (g_fClusterMode)
            {
                //
                // we have to save all PSC's name and all PEC's BSCs in .ini file 
                // in order to send them new PEC name at the end of migration
                //
                ulServerCount++;
                TCHAR tszKeyName[50];
                _stprintf(tszKeyName, TEXT("%s%lu"), 
					MIGRATION_ALLSERVERS_NAME_KEY, ulServerCount);
                BOOL f = WritePrivateProfileString( 
                                        MIGRATION_ALLSERVERS_SECTION,
                                        tszKeyName,
                                        pwzMachineName,
                                        pszFileName ) ;
                UNREFERENCED_PARAMETER(f);
            }
        }

        MQDBFreeBuf((void*) pColumns[ iName1Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iName2Index ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iTypeIndex ].nColumnValue) ;
        MQDBFreeBuf((void*) pColumns[ iOwnerIdIndex ].nColumnValue) ;
        for ( ULONG i = 0 ; i < cbColumns; i++ )
        {		
            pColumns[ i ].nColumnValue  = 0 ;
            pColumns[ i ].nColumnLength  = 0 ;
        }
        CHECK_HR(hr) ;

        iIndex++ ;
        status = MQDBGetData( hQuery,
                              pColumns ) ;
    }

    if (g_fClusterMode)
    {
        //
        // we have to save all PSC's name and all PEC's BSCs in .ini file 
        // in order to send them new PEC name at the end of migration
        //
        TCHAR szBuf[20];
        _ltot( ulServerCount, szBuf, 10 );
        BOOL f = WritePrivateProfileString( 
                                MIGRATION_ALLSERVERSNUM_SECTION,
                                MIGRATION_ALLSERVERSNUM_KEY,
                                szBuf,
                                pszFileName ) ;
        UNREFERENCED_PARAMETER(f);
    }

    MQDBSTATUS status1 = MQDBCloseQuery(hQuery) ;
    UNREFERENCED_PARAMETER(status1);

    hQuery = NULL ;

    if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_MACHINES_SQL_FAIL, status) ;
        return status ;
    }

    if (*piOldVerServersCount == 0)
    {
        delete[] ppwcsOldVerServers;
        return MQMig_OK;
    }

    //
    // build list of servers
    //
    DWORD dwSize = 0;
    for (UINT i=0; i<*piOldVerServersCount; i++)
    {
        dwSize += wcslen(ppwcsOldVerServers[i]);
    }
    //
    // add place for '\n' after each server name
    //
    dwSize += *piOldVerServersCount;

    WCHAR *pwcsServersList = new WCHAR[dwSize + 1];
    pwcsServersList[0] = L'\0';
    for (i=0; i<*piOldVerServersCount; i++)
    {
        wcscat (pwcsServersList, ppwcsOldVerServers[i]);
        delete[] ppwcsOldVerServers[i];
        wcscat (pwcsServersList, L"\n");
    }
    delete [] ppwcsOldVerServers;

    *ppszOldVerServers = pwcsServersList;

    return MQMig_OK;
}

//--------------------------------------------------
//
//  HRESULT    GetSiteIdOfPEC (IN  GUID *pMyMachineGuid, OUT GUID *pSiteId)
//
//--------------------------------------------------

#define INIT_MACHINE_COLUMN(_ColName, _ColIndex, _Index)            \
    INIT_COLUMNVAL(pColumns[ _Index ]) ;                            \
    pColumns[ _Index ].lpszColumnName = ##_ColName##_COL ;          \
    pColumns[ _Index ].nColumnValue   = 0 ;                         \
    pColumns[ _Index ].nColumnLength  = 0 ;                         \
    pColumns[ _Index ].mqdbColumnType = ##_ColName##_CTYPE ;        \
    UINT _ColIndex = _Index ;                                       \
    _Index++ ;

HRESULT GetSiteIdOfPEC (IN LPTSTR pszRemoteMQISName,
                        OUT ULONG *pulService,
                        OUT GUID  *pSiteId)
{
    HRESULT hr = _OpenMachineTable() ;
    CHECK_HR(hr) ;

    UINT cMachines;
    hr = MQDBGetTableCount( g_hMachineTable,
                            &cMachines ) ;
    CHECK_HR(hr) ;

    if (cMachines == 0)
    {
        return MQMig_E_NO_MACHINES_AVAIL ;
    }

    ULONG cAlloc = 2 ;
    ULONG cbColumns = 0 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

    INIT_MACHINE_COLUMN(M_OWNERID,  iOwnerIdIndex,  cbColumns) ;
    INIT_MACHINE_COLUMN(M_SERVICES, iServicesIndex, cbColumns) ;

    #undef  INIT_MACHINE_COLUMN

    ASSERT(cbColumns == cAlloc) ;

    //
    // For cluster mode we get remote clustered server and we have to 
    // find Services and OwnerId of this server according to its name.
    // For recovery mode we have to find OwnerId according to Services
    // since we run wizard in this mode only for crashed PEC. In this case
    // given server name is server where we recovery PEC from.
    //        
    MQDBCOLUMNSEARCH ColSearch[1] ;
    INIT_COLUMNSEARCH(ColSearch[0]) ;

    if (g_fClusterMode)
    {
        DWORD dwHashKey = CalHashKey( pszRemoteMQISName );
        
        ColSearch[0].mqdbColumnVal.lpszColumnName = M_HKEY_COL ;
        ColSearch[0].mqdbColumnVal.mqdbColumnType = M_HKEY_CTYPE ;
        ColSearch[0].mqdbColumnVal.nColumnValue = (LONG) dwHashKey ;
        ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(LONG) ;
        ColSearch[0].mqdbOp = EQ ;                  
    }
    else
    {
        //
        // recovery mode
        //       
        ColSearch[0].mqdbColumnVal.lpszColumnName = M_SERVICES_COL ;
        ColSearch[0].mqdbColumnVal.mqdbColumnType = M_SERVICES_CTYPE ;
        ColSearch[0].mqdbColumnVal.nColumnValue = (LONG) SERVICE_PEC ;
        ColSearch[0].mqdbColumnVal.nColumnLength = sizeof(LONG) ;
        ColSearch[0].mqdbOp = EQ ;                        
    }

    CHQuery hQuery ;   

    MQDBSTATUS status = MQDBOpenQuery( g_hMachineTable,
                                       pColumns,
                                       cbColumns,
                                       ColSearch,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
						               TRUE ) ;        
    CHECK_HR(status) ;

    UINT iIndex = 0 ;

    while(SUCCEEDED(status))
    {
        if (iIndex >= 1)
        {
            //
            // only one machine with the given service/ name must be found
            //
            status = MQMig_E_TOO_MANY_MACHINES ;
            break ;
        }
        memcpy (pSiteId, (void*) pColumns[ iOwnerIdIndex ].nColumnValue, sizeof(GUID));        
        MQDBFreeBuf((void*) pColumns[ iOwnerIdIndex ].nColumnValue) ;

        *pulService = pColumns[ iServicesIndex ].nColumnValue;

        for ( ULONG i = 0 ; i < cbColumns; i++ )
        {		
            pColumns[ i ].nColumnValue  = 0 ;
            pColumns[ i ].nColumnLength  = 0 ;
        }
        CHECK_HR(hr) ;

        iIndex++ ;
        status = MQDBGetData( hQuery,
                              pColumns ) ;    
    }
    MQDBSTATUS status1 = MQDBCloseQuery(hQuery) ;
    UNREFERENCED_PARAMETER(status1);

    hQuery = NULL ;

    if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_MACHINES_SQL_FAIL, status) ;
        return status ;
    }  

    if (*pulService < SERVICE_PSC && g_fClusterMode)
    {
        //
        // for cluster mode: remote machine on cluster must be either PSC or PEC
        //
        LogMigrationEvent(  MigLog_Error, MQMig_E_CLUSTER_WRONG_SERVICE, 
                            pszRemoteMQISName, *pulService) ;
        return MQMig_E_CLUSTER_WRONG_SERVICE;
    }

    return MQMig_OK;
}

//--------------------------------------------------
//
//  HRESULT _UpdateEnterpriseTable()
//  Update enterprise table of remote databases: 
//		change PEC name to name of this local machine
//
//--------------------------------------------------

HRESULT _UpdateEnterpriseTable(LPTSTR pszLocalComputerName)
{
    HRESULT hr = OpenEntTable();
    if (FAILED(hr))
    {
        return hr;
    }

    MQDBCOLUMNVAL mqdbPecNameUpdate =
    { sizeof(MQDBCOLUMNVAL), E_PECNAME_COL, (long)pszLocalComputerName, E_PECNAME_CLEN, E_PECNAME_CTYPE, 0};
       
    hr =  MQDBUpdateRecord(
               g_hEntTable,
               &mqdbPecNameUpdate,
               1,
               NULL,
               NULL,
               NULL) ;
    return hr;
}

//--------------------------------------------------
//
//  HRESULT _UpdateMachineTable()
//  Update machine table of remote databases: 
//		change services of former PEC to SERVICE_SRV
//
//--------------------------------------------------

HRESULT _UpdateMachineTable()
{
    HRESULT hr = _OpenMachineTable();
    if (FAILED(hr))
    {
        return hr;
    }
	
    ASSERT(g_FormerPECGuid != GUID_NULL);
    
    MQDBCOLUMNVAL mqdbServiceUpdate =
    { sizeof(MQDBCOLUMNVAL), M_SERVICES_COL, (long)SERVICE_SRV, M_SERVICES_CLEN, M_SERVICES_CTYPE, 0};
   
    MQDBCOLUMNSEARCH mqdbServiceSearch =
    {{sizeof(MQDBCOLUMNVAL), M_QMID_COL, (long)(&g_FormerPECGuid), M_QMID_CLEN, M_QMID_CTYPE, 0}, EQ, FALSE};
   
    hr =  MQDBUpdateRecord(
               g_hMachineTable,
               &mqdbServiceUpdate,
               1,
               &mqdbServiceSearch,
               NULL,
               NULL) ;
		
    return hr;
}

//--------------------------------------------------
//
//  HRESULT _UpdateSiteTable()
//  Update site table of remote databases: 
//		change PSC name of former PEC site to new PEC name
//
//--------------------------------------------------

HRESULT _UpdateSiteTable(LPTSTR pszLocalComputerName)
{
    HRESULT hr = _OpenSiteTable();
    if (FAILED(hr))
    {
        return hr;
    }	

    MQDBCOLUMNVAL mqdbPSCNameUpdate =
    { sizeof(MQDBCOLUMNVAL), S_PSC_COL, (long)pszLocalComputerName, S_PSC_CLEN, S_PSC_CTYPE, 0};
   
    MQDBCOLUMNSEARCH mqdbPSCNameSearch =
    {{sizeof(MQDBCOLUMNVAL), S_ID_COL, (long)(&g_MySiteGuid), S_ID_CLEN, S_ID_CTYPE, 0}, EQ, FALSE};
   
    hr =  MQDBUpdateRecord(
               g_hSiteTable,
               &mqdbPSCNameUpdate,
               1,
               &mqdbPSCNameSearch,
               NULL,
               NULL) ;
		
    return hr;
}

//--------------------------------------------------
//
//  void _PrepareMultipleColumns ()
//	Split values for multiple columns
//
//--------------------------------------------------

void _PrepareMultipleColumns (
			IN	ULONG           ulNumOfColumns,
			IN	unsigned char   *pData,
			IN	long            lSize,
			OUT	MQDBCOLUMNVAL   *pColumns
			)
{	
    unsigned char * pcNextToCopy = pData ;	
    MQDBCOLUMNVAL * pColumnVal = pColumns;
    char *pTempBuff ;

    for (ULONG i=0; i<ulNumOfColumns; i++, pColumnVal++)
    {
        if ( lSize )
        {
            //
            //  Into each section of the value we add the length.
            //  The reason for this is:
            //  the first entries of multiple entry property are of fixbinary type
            //  No matter which part of a fixbinary enrty is filled, when it is read,
            //  The returned length is field length ( not the length of the part
            //  which was filled).
            //

            //
            //  For the length we leave two bytes
            //
            if ( pColumnVal->nColumnLength == 0)    // this is a varbinary column
            {
                pColumnVal->nColumnLength = lSize + MQIS_LENGTH_PREFIX_LEN;
            }
            else
            {
                pColumnVal->nColumnLength = ( lSize + MQIS_LENGTH_PREFIX_LEN > pColumnVal->nColumnLength ) ? pColumnVal->nColumnLength : lSize + MQIS_LENGTH_PREFIX_LEN;
            }
            pTempBuff = new char[pColumnVal->nColumnLength];

            //
            //  Data legth = column length - 2
            //
            *((short *)pTempBuff) = (short)pColumnVal->nColumnLength - MQIS_LENGTH_PREFIX_LEN;
            memcpy( pTempBuff + MQIS_LENGTH_PREFIX_LEN, pcNextToCopy, pColumnVal->nColumnLength -MQIS_LENGTH_PREFIX_LEN);
            pColumnVal->nColumnValue = (long)pTempBuff;
            lSize -= pColumnVal->nColumnLength - MQIS_LENGTH_PREFIX_LEN;
            pcNextToCopy += pColumnVal->nColumnLength - MQIS_LENGTH_PREFIX_LEN;
        }
        else
        {
            //
            // size is 0
            //
            pColumnVal->nColumnLength = 0;            
        }
    }
    return;
}
	
//--------------------------------------------------
//
//  HRESULT    _AddThisMachine(LPTSTR pszLocalComputerName)
//	Add this local machine to remote databases
//
//--------------------------------------------------

HRESULT _AddThisMachine(LPTSTR pszLocalComputerName)
{
    HRESULT hr = _OpenMachineTable();
    if (FAILED(hr))
    {
	    return hr;
    }

    //
    // the first is to get max seqnum from registry
    //
    static BOOL		s_fIsMaxSNFound = FALSE;
    static CSeqNum  s_snMax;

    if (!s_fIsMaxSNFound)
    {
        unsigned short *lpszGuid ;
        UuidToString( &g_MySiteGuid, &lpszGuid ) ;
    	        
        TCHAR wszSeq[ SEQ_NUM_BUF_LEN ] ;
        memset(wszSeq, 0, sizeof(wszSeq)) ;

        TCHAR *pszFileName = GetIniFileName ();
        GetPrivateProfileString( MIGRATION_SEQ_NUM_SECTION,
                                 lpszGuid,
                                 TEXT(""),
                                 wszSeq,
                                 (sizeof(wszSeq) / sizeof(wszSeq[0])),
                                 pszFileName ) ;
        RpcStringFree( &lpszGuid ) ;

        if (_tcslen(wszSeq) != 16)
        {
	        //
	        // all seq numbers are saved in the ini file as strings of 16
	        // chatacters
	        //        
	        return MQMig_E_CANNOT_UPDATE_SERVER;
        }

        //
        // it will be SN for this machine object in remote MQIS database
        //
        StringToSeqNum( wszSeq,
                        &s_snMax ) ;

        s_fIsMaxSNFound = TRUE;
    }

    //
    // get properties from ADS
    //
    #define PROP_NUM	5
    PROPID propIDs[PROP_NUM];
    PROPVARIANT propVariants[PROP_NUM];
    DWORD iProps = 0;

    propIDs[ iProps ] = PROPID_QM_OLDSERVICE ;   
    propVariants[ iProps ].vt = VT_UI4 ;
    DWORD dwServiceIndex = iProps;
    iProps++;
    
    propIDs[ iProps ] = PROPID_QM_SIGN_PKS ;
    propVariants[ iProps ].vt = VT_NULL ;
    propVariants[ iProps ].blob.cbSize = 0 ;
    propVariants[ iProps ].blob.pBlobData = NULL ;
    DWORD dwSignKeyIndex = iProps ;
    iProps++;

    propIDs[ iProps ] = PROPID_QM_ENCRYPT_PKS ;
    propVariants[ iProps ].vt = VT_NULL ;
    propVariants[ iProps ].blob.cbSize = 0 ;
    propVariants[ iProps ].blob.pBlobData = NULL ;
    DWORD dwExchKeyIndex = iProps ;
    iProps++;

    propIDs[ iProps ] = PROPID_QM_SECURITY ;
    propVariants[ iProps ].vt = VT_NULL ;
    propVariants[ iProps ].blob.cbSize = 0 ;
    propVariants[ iProps ].blob.pBlobData = NULL ;
    DWORD dwSecurityIndex = iProps ;
    iProps++;

    propIDs[ iProps ] = PROPID_QM_SITE_ID ;
    propVariants[ iProps ].vt = VT_NULL ;
    propVariants[ iProps ].puuid = NULL ;
    DWORD dwSiteIdIndex = iProps ;
    iProps++;    

    ASSERT (iProps <= PROP_NUM);

    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);  

    hr = DSCoreGetProps(
             MQDS_MACHINE,
             NULL, // pathname
             &g_MyMachineGuid,
             iProps,
             propIDs,
             &requestContext,
             propVariants);

    if (FAILED(hr))
    {
        return hr;
    }

    P<MQDSPUBLICKEYS> pPublicSignKeys = NULL ;
    P<MQDSPUBLICKEYS> pPublicExchKeys = NULL ;

    if (propVariants[ dwSignKeyIndex ].blob.pBlobData)
    {
        //
        // Extract msmq1.0 public key from Windows ADS blob.
        //
        BYTE *pSignKey = NULL ;
        DWORD dwKeySize = 0 ;
        pPublicSignKeys = (MQDSPUBLICKEYS *)
                       propVariants[ dwSignKeyIndex ].blob.pBlobData ;

        HRESULT hr1 =  MQSec_UnpackPublicKey(
                                     pPublicSignKeys,
                                     x_MQ_Encryption_Provider_40,
                                     x_MQ_Encryption_Provider_Type_40,
                                    &pSignKey,
                                    &dwKeySize ) ;
        
        if (SUCCEEDED(hr1))
        {
            ASSERT(pSignKey && dwKeySize) ;
            propVariants[ dwSignKeyIndex ].blob.pBlobData = pSignKey ;
            propVariants[ dwSignKeyIndex ].blob.cbSize = dwKeySize ;
        }
        else
        {
            propVariants[ dwSignKeyIndex ].blob.pBlobData = NULL ;
            propVariants[ dwSignKeyIndex ].blob.cbSize = 0 ;
        }
    }

    if (propVariants[ dwExchKeyIndex ].blob.pBlobData)
    {
        //
        // Extract msmq1.0 public key from Windows ADS blob.
        //
        BYTE *pExchKey = NULL ;
        DWORD dwKeySize = 0 ;
        pPublicExchKeys = (MQDSPUBLICKEYS *)
                       propVariants[ dwExchKeyIndex ].blob.pBlobData ;

        HRESULT hr1 =  MQSec_UnpackPublicKey(
                                     pPublicExchKeys,
                                     x_MQ_Encryption_Provider_40,
                                     x_MQ_Encryption_Provider_Type_40,
                                    &pExchKey,
                                    &dwKeySize ) ;
        
        if (SUCCEEDED(hr1))
        {
            ASSERT(pExchKey && dwKeySize) ;
            propVariants[ dwExchKeyIndex ].blob.pBlobData = pExchKey ;
            propVariants[ dwExchKeyIndex ].blob.cbSize = dwKeySize ;
        }
        else
        {
            propVariants[ dwExchKeyIndex ].blob.pBlobData = NULL ;
            propVariants[ dwExchKeyIndex ].blob.cbSize = 0 ;
        }
    }

    //
    // prepare columns
    //
    #define     COL_NUM  26
    MQDBCOLUMNVAL aColumnVal[COL_NUM];
    LONG cColumns =0;

    //
    // prepare name columns
    //
    #define NAME_COL_NUM	2
    MQDBCOLUMNVAL NameColumn[NAME_COL_NUM] = 
    {
        {sizeof(MQDBCOLUMNVAL), M_NAME1_COL, 0, M_NAME1_CLEN, M_NAME1_CTYPE, 0},
        {sizeof(MQDBCOLUMNVAL), M_NAME2_COL, 0, M_NAME2_CLEN, M_NAME2_CTYPE, 0}		
    } ;		
	    
    _PrepareMultipleColumns (
            NAME_COL_NUM,
            (unsigned char *)pszLocalComputerName,
            (1 + lstrlen(pszLocalComputerName))* sizeof(TCHAR),
            NameColumn
            );
    for (ULONG i=0; i<NAME_COL_NUM; i++)
    {
        aColumnVal[cColumns].cbSize			= NameColumn[i].cbSize ;
        aColumnVal[cColumns].lpszColumnName = NameColumn[i].lpszColumnName ; 
        aColumnVal[cColumns].nColumnValue	= NameColumn[i].nColumnValue ;
        aColumnVal[cColumns].nColumnLength	= NameColumn[i].nColumnLength ;
        aColumnVal[cColumns].mqdbColumnType = NameColumn[i].mqdbColumnType ;
        aColumnVal[cColumns].dwReserve_A	= NameColumn[i].dwReserve_A ;
        cColumns++ ;
    }

    aColumnVal[cColumns].cbSize			= sizeof(MQDBCOLUMNVAL) ;
    aColumnVal[cColumns].lpszColumnName = M_SITE_COL ; 
    aColumnVal[cColumns].nColumnValue	= (long) (propVariants[ dwSiteIdIndex ].puuid) ;
    aColumnVal[cColumns].nColumnLength	= M_SITE_CLEN ;
    aColumnVal[cColumns].mqdbColumnType = M_SITE_CTYPE ;
    aColumnVal[cColumns].dwReserve_A	= 0 ;
    cColumns++ ;

    aColumnVal[cColumns].cbSize			= sizeof(MQDBCOLUMNVAL) ;
    aColumnVal[cColumns].lpszColumnName = M_OWNERID_COL ; 
    aColumnVal[cColumns].nColumnValue	= (long) (&g_MySiteGuid) ;
    aColumnVal[cColumns].nColumnLength	= M_OWNERID_CLEN ;
    aColumnVal[cColumns].mqdbColumnType = M_OWNERID_CTYPE ;
    aColumnVal[cColumns].dwReserve_A	= 0 ;
    cColumns++ ;

    aColumnVal[cColumns].cbSize			= sizeof(MQDBCOLUMNVAL) ;
    aColumnVal[cColumns].lpszColumnName = M_QMID_COL ; 
    aColumnVal[cColumns].nColumnValue	= (long) (&g_MyMachineGuid) ;
    aColumnVal[cColumns].nColumnLength	= M_QMID_CLEN ;
    aColumnVal[cColumns].mqdbColumnType = M_QMID_CTYPE ;
    aColumnVal[cColumns].dwReserve_A	= 0 ;
    cColumns++ ;

    aColumnVal[cColumns].cbSize			= sizeof(MQDBCOLUMNVAL) ;
    aColumnVal[cColumns].lpszColumnName = M_SEQNUM_COL ; 
    aColumnVal[cColumns].nColumnValue	= (long) (&s_snMax) ;
    aColumnVal[cColumns].nColumnLength	= M_SEQNUM_CLEN ;
    aColumnVal[cColumns].mqdbColumnType = M_SEQNUM_CTYPE ;
    aColumnVal[cColumns].dwReserve_A	= 0 ;
    cColumns++ ;

    //
    // prepare OutFRS columns
    //
    GUID guidNull = GUID_NULL;
    #define OUTFRS_COL_NUM 3
    MQDBCOLUMNVAL OutFRSColumn[OUTFRS_COL_NUM] = 
    {
        {sizeof(MQDBCOLUMNVAL), M_OUTFRS1_COL, long (&guidNull), M_OUTFRS1_CLEN, M_OUTFRS1_CTYPE, 0},
        {sizeof(MQDBCOLUMNVAL), M_OUTFRS2_COL, long (&guidNull), M_OUTFRS2_CLEN, M_OUTFRS2_CTYPE, 0},
        {sizeof(MQDBCOLUMNVAL), M_OUTFRS3_COL, long (&guidNull), M_OUTFRS3_CLEN, M_OUTFRS3_CTYPE, 0}
    } ;	

    for (i=0; i<OUTFRS_COL_NUM; i++)
    {
        aColumnVal[cColumns].cbSize			= OutFRSColumn[i].cbSize ;
        aColumnVal[cColumns].lpszColumnName = OutFRSColumn[i].lpszColumnName ;         
        aColumnVal[cColumns].nColumnValue	= OutFRSColumn[i].nColumnValue ;
        aColumnVal[cColumns].nColumnLength	= OutFRSColumn[i].nColumnLength ;
        aColumnVal[cColumns].mqdbColumnType = OutFRSColumn[i].mqdbColumnType ;
        aColumnVal[cColumns].dwReserve_A	= OutFRSColumn[i].dwReserve_A ;        
        cColumns++ ;
    }

    //
    // prepare InFRS columns
    //
    #define INFRS_COL_NUM 3
    MQDBCOLUMNVAL InFRSColumn[INFRS_COL_NUM] = 
    {
        {sizeof(MQDBCOLUMNVAL), M_INFRS1_COL, long (&guidNull), M_INFRS1_CLEN, M_INFRS1_CTYPE, 0},
        {sizeof(MQDBCOLUMNVAL), M_INFRS2_COL, long (&guidNull), M_INFRS2_CLEN, M_INFRS2_CTYPE, 0},
        {sizeof(MQDBCOLUMNVAL), M_INFRS3_COL, long (&guidNull), M_INFRS3_CLEN, M_INFRS3_CTYPE, 0}
    } ;

    for (i=0; i<INFRS_COL_NUM; i++)
    {
        aColumnVal[cColumns].cbSize			= InFRSColumn[i].cbSize ;
        aColumnVal[cColumns].lpszColumnName = InFRSColumn[i].lpszColumnName ; 
        aColumnVal[cColumns].nColumnValue	= InFRSColumn[i].nColumnValue ;
        aColumnVal[cColumns].nColumnLength	= InFRSColumn[i].nColumnLength ;
        aColumnVal[cColumns].mqdbColumnType = InFRSColumn[i].mqdbColumnType ;
        aColumnVal[cColumns].dwReserve_A	= InFRSColumn[i].dwReserve_A ;        
        cColumns++ ;
    }

    //
    // prepare sign crpt columns
    //
    #define SIGNCRT_COL_NUM	2
    MQDBCOLUMNVAL SignCrtColumn[SIGNCRT_COL_NUM] = 
    {
        {sizeof(MQDBCOLUMNVAL), M_SIGNCRT1_COL, 0, M_SIGNCRT1_CLEN, M_SIGNCRT1_CTYPE, 0},
        {sizeof(MQDBCOLUMNVAL), M_SIGNCRT2_COL, 0, M_SIGNCRT2_CLEN, M_SIGNCRT2_CTYPE, 0}		
    } ;		
	    
    _PrepareMultipleColumns (
            SIGNCRT_COL_NUM,
            propVariants[ dwSignKeyIndex ].blob.pBlobData,
            propVariants[ dwSignKeyIndex ].blob.cbSize,
            SignCrtColumn
            );
    for (i=0; i<SIGNCRT_COL_NUM; i++)
    {
        aColumnVal[cColumns].cbSize			= SignCrtColumn[i].cbSize ;
        aColumnVal[cColumns].lpszColumnName = SignCrtColumn[i].lpszColumnName ; 
        aColumnVal[cColumns].nColumnValue	= SignCrtColumn[i].nColumnValue ;
        aColumnVal[cColumns].nColumnLength	= SignCrtColumn[i].nColumnLength ;
        aColumnVal[cColumns].mqdbColumnType = SignCrtColumn[i].mqdbColumnType ;
        aColumnVal[cColumns].dwReserve_A	= SignCrtColumn[i].dwReserve_A ;
        cColumns++ ;
    }

    //
    // prepare encrpt columns
    //
    #define ENCRPTCRT_COL_NUM	2
    MQDBCOLUMNVAL EncrptCrtColumn[ENCRPTCRT_COL_NUM] = 
    {
        {sizeof(MQDBCOLUMNVAL), M_ENCRPTCRT1_COL, 0, M_ENCRPTCRT1_CLEN, M_ENCRPTCRT1_CTYPE, 0},
        {sizeof(MQDBCOLUMNVAL), M_ENCRPTCRT2_COL, 0, M_ENCRPTCRT2_CLEN, M_ENCRPTCRT2_CTYPE, 0}		
    } ;		
	    
    _PrepareMultipleColumns (
            ENCRPTCRT_COL_NUM,
            propVariants[ dwExchKeyIndex ].blob.pBlobData,
            propVariants[ dwExchKeyIndex ].blob.cbSize,
            EncrptCrtColumn
            );
    for (i=0; i<ENCRPTCRT_COL_NUM; i++)
    {
        aColumnVal[cColumns].cbSize			= EncrptCrtColumn[i].cbSize ;
        aColumnVal[cColumns].lpszColumnName = EncrptCrtColumn[i].lpszColumnName ; 
        aColumnVal[cColumns].nColumnValue	= EncrptCrtColumn[i].nColumnValue ;
        aColumnVal[cColumns].nColumnLength	= EncrptCrtColumn[i].nColumnLength ;
        aColumnVal[cColumns].mqdbColumnType = EncrptCrtColumn[i].mqdbColumnType ;
        aColumnVal[cColumns].dwReserve_A	= EncrptCrtColumn[i].dwReserve_A ;
        cColumns++ ;
    }	

    aColumnVal[cColumns].cbSize			= sizeof(MQDBCOLUMNVAL) ;
    aColumnVal[cColumns].lpszColumnName = M_SERVICES_COL ; 
    aColumnVal[cColumns].nColumnValue	= propVariants[ dwServiceIndex ].ulVal ;
    aColumnVal[cColumns].nColumnLength	= M_SERVICES_CLEN ;
    aColumnVal[cColumns].mqdbColumnType = M_SERVICES_CTYPE ;
    aColumnVal[cColumns].dwReserve_A	= 0 ;
    cColumns++ ;	

    aColumnVal[cColumns].cbSize			= sizeof(MQDBCOLUMNVAL) ;
    aColumnVal[cColumns].lpszColumnName = M_HKEY_COL ; 
    aColumnVal[cColumns].nColumnValue	= CalHashKey( pszLocalComputerName ) ; ;
    aColumnVal[cColumns].nColumnLength	= M_HKEY_CLEN ;
    aColumnVal[cColumns].mqdbColumnType = M_HKEY_CTYPE ;
    aColumnVal[cColumns].dwReserve_A	= 0 ;
    cColumns++ ;	
	    
    //
    // prepare security columns
    //
    #define SECURITY_COL_NUM	3
    MQDBCOLUMNVAL SecurityColumn[SECURITY_COL_NUM] = 
    {
        {sizeof(MQDBCOLUMNVAL), M_SECURITY1_COL, 0, M_SECURITY1_CLEN, M_SECURITY1_CTYPE, 0},
        {sizeof(MQDBCOLUMNVAL), M_SECURITY2_COL, 0, M_SECURITY2_CLEN, M_SECURITY2_CTYPE, 0},
        {sizeof(MQDBCOLUMNVAL), M_SECURITY3_COL, 0, M_SECURITY3_CLEN, M_SECURITY3_CTYPE, 0}
    } ;		
	    
    _PrepareMultipleColumns (
            SECURITY_COL_NUM,
            propVariants[ dwSecurityIndex ].blob.pBlobData,
            propVariants[ dwSecurityIndex ].blob.cbSize,
            SecurityColumn
            );

    for (i=0; i<SECURITY_COL_NUM; i++)
    {
        aColumnVal[cColumns].cbSize			= SecurityColumn[i].cbSize ;
        aColumnVal[cColumns].lpszColumnName = SecurityColumn[i].lpszColumnName ; 
        aColumnVal[cColumns].nColumnValue	= SecurityColumn[i].nColumnValue ;
        aColumnVal[cColumns].nColumnLength	= SecurityColumn[i].nColumnLength ;
        aColumnVal[cColumns].mqdbColumnType = SecurityColumn[i].mqdbColumnType ;
        aColumnVal[cColumns].dwReserve_A	= SecurityColumn[i].dwReserve_A ;
        cColumns++ ;
    }

    ASSERT (cColumns <= COL_NUM);
    //
    // insert records
    //
    hr = MQDBInsertRecord(
             g_hMachineTable,
             aColumnVal,
             cColumns,
             NULL
             ) ;

    if (FAILED(hr))
    {
        //
        // maybe this record was created at the previous time
        // it is OK
        //
        
    }

    if (propVariants[ dwSecurityIndex ].blob.pBlobData)
    {
        delete propVariants[ dwSecurityIndex ].blob.pBlobData ;
    }
    if (propVariants[ dwSiteIdIndex ].puuid)
    {
        delete propVariants[ dwSiteIdIndex ].puuid ;
    }    
    
    for (i=0; i<SECURITY_COL_NUM; i++)
    {
        MQDBFreeBuf((void*) SecurityColumn[i].nColumnValue) ;
    }
    for (i=0; i<ENCRPTCRT_COL_NUM; i++)
    {		
        MQDBFreeBuf((void*) EncrptCrtColumn[i].nColumnValue) ;
    }
    for (i=0; i<SIGNCRT_COL_NUM; i++)
    {
        MQDBFreeBuf((void*) SignCrtColumn[i].nColumnValue) ;
    }
    for (i=0; i<NAME_COL_NUM; i++)
    {
        MQDBFreeBuf((void*) NameColumn[i].nColumnValue) ;
    }

    return MQMig_OK;
}

//--------------------------------------------------
//
//  HRESULT    ChangeRemoteMQIS()
//  We have to change PEC name and other properties on all PSC and PEC's BSCs.
//
//--------------------------------------------------

HRESULT ChangeRemoteMQIS ()
{
    HRESULT hr = MQMig_OK;

    TCHAR *pszFileName = GetIniFileName ();
    ULONG ulServerNum = GetPrivateProfileInt(
                                MIGRATION_ALLSERVERSNUM_SECTION,	// address of section name
                                MIGRATION_ALLSERVERSNUM_KEY,      // address of key name
                                0,							    // return value if key name is not found
                                pszFileName					    // address of initialization filename);
                                );

    if (ulServerNum == 0)
    {
        return MQMig_OK;
    }

    //
    // get local computer name
    //
    WCHAR wszComputerName[ MAX_COMPUTERNAME_LENGTH + 2 ] ;
    DWORD dwSize = sizeof(wszComputerName) / sizeof(wszComputerName[0]) ;
    GetComputerName( wszComputerName,
                     &dwSize ) ;
    CharLower( wszComputerName);	//we save names in database in lower case


    HRESULT hr1 = MQMig_OK;
    BOOL f;

    //
    // for each server in .ini file change 
    // - PEC name to local computer name
    // - service of former PEC to SERVICE_SRV
    // - PSC name in former PEC's site to local computer name
    // - add local machine to machine table
    //
    ULONG ulNonUpdatedServers = 0;
    
    for (ULONG i=0; i<ulServerNum; i++)
    {
        TCHAR szCurServerName[MAX_PATH];
        TCHAR tszKeyName[50];
        _stprintf(tszKeyName, TEXT("%s%lu"), MIGRATION_ALLSERVERS_NAME_KEY, i+1);
        DWORD dwRetSize =  GetPrivateProfileString(
                                    MIGRATION_ALLSERVERS_SECTION ,			// points to section name
                                    tszKeyName,	// points to key name
                                    TEXT(""),                 // points to default string
                                    szCurServerName,          // points to destination buffer
                                    MAX_PATH,                 // size of destination buffer
                                    pszFileName               // points to initialization filename);
                                    );
        if (_tcscmp(szCurServerName, TEXT("")) == 0 ||  
            dwRetSize == 0)     //low resources
        {
            //
            // we cannot get server name: either low resources
            // or there is no this section. It means that server from
            // this section was updated at the previous time
            //
            continue;
        }

        //
        // connect to database on server with the name szCurServerName
        //
        CleanupDatabase();
        MQDBCloseDatabase (g_hDatabase);
        g_hDatabase = NULL;

        char szDSNServerName[ MAX_PATH ] ;
#ifdef UNICODE
        ConvertToMultiByteString(szCurServerName,
                                 szDSNServerName,
			         (sizeof(szDSNServerName) / sizeof(szDSNServerName[0])) ) ;
#else
        lstrcpy(szDSNServerName, szCurServerName) ;
#endif		
        hr = MakeMQISDsn(szDSNServerName, TRUE) ;
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_CANT_MAKEDSN, szCurServerName, hr) ;
            hr1 = MQMig_E_CANNOT_UPDATE_SERVER;	
            ulNonUpdatedServers++;
            continue;			
        }

        hr =  ConnectToDatabase(TRUE) ;
        if (FAILED(hr))
        {
            LogMigrationEvent(MigLog_Error, MQMig_E_CANT_CONNECT_DB, szCurServerName, hr) ;
            hr1 = MQMig_E_CANNOT_UPDATE_SERVER;	
            ulNonUpdatedServers++;
            continue;
        }        

        //
        // update remote database tables
        //
        hr = _UpdateEnterpriseTable(wszComputerName);		
        if (FAILED(hr))
        {
            hr1 = MQMig_E_CANNOT_UPDATE_SERVER;
            LogMigrationEvent(MigLog_Error, MQMig_E_CANNOT_UPDATE_SERVER, 
                                szCurServerName, hr) ;
            ulNonUpdatedServers++;
            continue;
        }

        hr = _UpdateMachineTable();
        if (FAILED(hr))
        {
            hr1 = MQMig_E_CANNOT_UPDATE_SERVER;			
            LogMigrationEvent(MigLog_Error, MQMig_E_CANNOT_UPDATE_SERVER, 
                                szCurServerName, hr) ;
            ulNonUpdatedServers++;
            continue;
        }

        //
        // in general we need to do it only for BSCs of PEC
        //
        hr = _UpdateSiteTable(wszComputerName);
        if (FAILED(hr))
        {
            hr1 = MQMig_E_CANNOT_UPDATE_SERVER;			
            LogMigrationEvent(MigLog_Error, MQMig_E_CANNOT_UPDATE_SERVER, 
                                szCurServerName, hr) ;
            ulNonUpdatedServers++;
            continue;
        }

        hr = _AddThisMachine(wszComputerName);
        if (FAILED(hr))
        {
            hr1 = MQMig_E_CANNOT_UPDATE_SERVER;			
            LogMigrationEvent(MigLog_Error, MQMig_E_CANNOT_UPDATE_SERVER, 
                                szCurServerName, hr) ;
            ulNonUpdatedServers++;
            continue;
        }

        //
        // remove this key from .ini
        //
        f = WritePrivateProfileString( 
                    MIGRATION_ALLSERVERS_SECTION,
                    tszKeyName,
                    NULL,
                    pszFileName ) ;        
    }

    if (ulNonUpdatedServers)
    {
        //
        // save number of all non-updated MQIS servers in .ini
        //
        TCHAR szBuf[10];
        _ltot( ulNonUpdatedServers, szBuf, 10 );
        f = WritePrivateProfileString( MIGRATION_NONUPDATED_SERVERNUM_SECTION,
                                       MIGRATION_ALLSERVERSNUM_KEY,
                                       szBuf,
                                       pszFileName ) ;
        ASSERT(f) ;
    }
    else
    {
        //
        // we are here if all MQIS servers were updated successfully
        //
        f = WritePrivateProfileString( 
                            MIGRATION_ALLSERVERS_SECTION,
                            NULL,
                            NULL,
                            pszFileName ) ;
        ASSERT(f) ;

        f = WritePrivateProfileString( 
                            MIGRATION_ALLSERVERSNUM_SECTION,
                            NULL,
                            NULL,
                            pszFileName ) ;
        ASSERT(f) ;

        f = WritePrivateProfileString( 
                            MIGRATION_NONUPDATED_SERVERNUM_SECTION,
                            NULL,
                            NULL,
                            pszFileName ) ;
        ASSERT(f) ;
    }

    if (FAILED(hr1))
    {
        return hr1;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\machutil.cpp ===
#include "migrat.h"
#include <mixmode.h>
#include <lmaccess.h>
#include "resource.h"
#include <dsproto.h>
#include <mqsec.h>

#include "machutil.tmh"

//+--------------------------------------------------------------
//
//  BOOL IsInsertPKey
//  Returns FALSE if we are run on the PEC not at the first time.
//
//+--------------------------------------------------------------

BOOL IsInsertPKey (GUID *pMachineGuid)
{
    if ( (g_dwMyService == SERVICE_PEC) &&        //migration tool run on PEC machine
         (*pMachineGuid == g_MyMachineGuid) )     //current machine is the PEC machine
    {
        //
        // We have to check if PEC machine already exist in ADS.
        // If so, don't change its public key in DS.
        //
        PROPID      PKeyProp = PROPID_QM_ENCRYPT_PK;
        PROPVARIANT PKeyVar;
        PKeyVar.vt = VT_NULL ;
        PKeyVar.blob.cbSize = 0 ;

        CDSRequestContext requestContext( e_DoNotImpersonate,
                                          e_ALL_PROTOCOLS);

        HRESULT hr = DSCoreGetProps( MQDS_MACHINE,
                                     NULL,  // path name
                                     pMachineGuid,
                                     1,
                                     &PKeyProp,
                                     &requestContext,
                                     &PKeyVar);
        if (SUCCEEDED(hr))
        {            
            delete PKeyVar.blob.pBlobData;
            return FALSE;
        }
    }    
    return TRUE;
}

//+--------------------------------------------------------------
//
//  HRESULT GetFRSs
//  Returns array of Out or In FRSs
//
//+--------------------------------------------------------------

HRESULT GetFRSs (IN MQDBCOLUMNVAL    *pColumns,
                 IN UINT             uiFirstIndex,
                 OUT UINT            *puiFRSCount, 
                 OUT GUID            **ppguidFRS )
{       
    GUID guidNull = GUID_NULL;
    AP<GUID> pFRSs = new GUID[ 3 ] ;                           

    *puiFRSCount = 0;    

    for (UINT iCount=0; iCount < 3; iCount++)
    {        
        GUID *pGuid = (GUID*) pColumns[ uiFirstIndex + iCount ].nColumnValue;
        if (memcmp(pGuid, &guidNull, sizeof(GUID)) != 0)
        {
            memcpy (&pFRSs[*puiFRSCount],
                    pGuid,
                    sizeof(GUID));
            (*puiFRSCount) ++;
        }
    }

    if (*puiFRSCount)
    {
        *ppguidFRS = pFRSs.detach() ; 
    }
        
    return MQMig_OK;
}

//+----------------------------------
//
//  HRESULT  PreparePBKeysForNT5DS
//  Returns size and value of machine public keys
//
//+----------------------------------

HRESULT PreparePBKeysForNT5DS( 
                   IN MQDBCOLUMNVAL *pColumns,
                   IN UINT           iIndex1,
                   IN UINT           iIndex2,
                   OUT ULONG         *pulSize,
                   OUT BYTE          **ppPKey
                   )
{
    P<BYTE> pBuf = NULL ;
    DWORD  dwIndexs[2] = { iIndex1, iIndex2 } ;
    HRESULT hr =  BlobFromColumns( pColumns,
                                   dwIndexs,
                                   2,
                                  &pBuf ) ;
    if (FAILED(hr))
    {
        ASSERT(!pBuf) ;
        return hr ;
    }

    BYTE *pTmpB = pBuf ;
    PMQDS_PublicKey pPbKey = (PMQDS_PublicKey) pTmpB ;

    P<MQDSPUBLICKEYS> pPublicKeys = NULL ;

    hr = MQSec_PackPublicKey( (BYTE*)pPbKey->abPublicKeyBlob,
                               pPbKey->dwPublikKeyBlobSize,
                               x_MQ_Encryption_Provider_40,
                               x_MQ_Encryption_Provider_Type_40,
                              &pPublicKeys ) ;
    if (FAILED(hr))
    {
       return hr ;
    }   
    
    *pulSize = 0;
    MQDSPUBLICKEYS *pTmpK = pPublicKeys ;
    BYTE *pData = NULL;

    if (pPublicKeys)
    {
        *pulSize = pPublicKeys->ulLen ;  
        pData = new BYTE[*pulSize];
        memcpy (pData, (BYTE*) pTmpK, *pulSize);
        *ppPKey = pData; 
    }   

    return hr ;
}

//+------------------------------
//
//  HRESULT  ResetSettingFlag ()
//  Touch setting attribute: either MQ_SET_NT4_ATTRIBUTE or MQ_SET_MIGRATED_ATTRIBUTE
//  The first set to 0, the second is to FALSE
//
//+------------------------------

HRESULT  ResetSettingFlag( IN DWORD   dwNumSites,
                           IN GUID*   pguidSites,
                           IN LPWSTR  wszMachineName,
                           IN WCHAR   *wszAttributeName,
                           IN WCHAR   *wszValue)
{
    HRESULT hr;

    PLDAP pLdap = NULL ;
    TCHAR *pwszDefName = NULL ;

    hr =  InitLDAP(&pLdap, &pwszDefName) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    ASSERT (dwNumSites == 1);
    for (DWORD i = 0; i<dwNumSites; i++)
    {
        //
        // get site name by guid
        //
        PROPID      SiteNameProp = PROPID_S_FULL_NAME;
        PROPVARIANT SiteNameVar;
        SiteNameVar.vt = VT_NULL;
        SiteNameVar.pwszVal = NULL ;

        CDSRequestContext requestContext( e_DoNotImpersonate,
                                    e_ALL_PROTOCOLS);  // not relevant

        hr  = DSCoreGetProps( MQDS_SITE,
                              NULL, // pathname
                              &pguidSites[i],
                              1,
                              &SiteNameProp,
                              &requestContext,
                              &SiteNameVar ) ;
        if (FAILED(hr))
        {
            return hr;
        }

        DWORD len = wcslen(SiteNameVar.pwszVal);
        const WCHAR x_wcsCnServers[] =  L"CN=Servers,";
        const DWORD x_wcsCnServersLength = (sizeof(x_wcsCnServers)/sizeof(WCHAR)) -1;
        AP<WCHAR> pwcsServersContainer =  new WCHAR [ len + x_wcsCnServersLength + 1];
        swprintf(
             pwcsServersContainer,
             L"%s%s",
             x_wcsCnServers,
             SiteNameVar.pwszVal
             );
        delete SiteNameVar.pwszVal;

        DWORD LenSuffix = lstrlen(pwcsServersContainer);
        DWORD LenPrefix = lstrlen(wszMachineName);
        DWORD LenObject = lstrlen(x_MsmqSettingName); //MSMQ Setting
        DWORD Length =
                CN_PREFIX_LEN +                   // "CN="
                CN_PREFIX_LEN +                   // "CN="
                LenPrefix +                       // "pwcsPrefix"
                2 +                               // ",", ","
                LenSuffix +                       // "pwcsSuffix"
                LenObject +                       // "MSMQ Setting"
                1 ;                               // '\0'

        AP<unsigned short> pwcsPath = new WCHAR[Length];

        swprintf(
            pwcsPath,
            L"%s"             // "CN="
            L"%s"             // "MSMQ Setting"
            TEXT(",")
            L"%s"             // "CN="
            L"%s"             // "pwcsPrefix"
            TEXT(",")
            L"%s",            // "pwcsSuffix"
            CN_PREFIX,
            x_MsmqSettingName,
            CN_PREFIX,
            wszMachineName,
            pwcsServersContainer
            );

        hr = ModifyAttribute(
                 pwcsPath,
                 wszAttributeName, 
                 wszValue 
                 );
        if (FAILED(hr))
        {
            return hr;
        }
    }

    return MQMig_OK;
}
            
//+--------------------------------------------------------------
//
//  HRESULT GetAllMachineSites
//	For foreign machine returns all its foreign CN
//  For connector returns all real sites + all its foreign CNs
//  Otherwise returns all real sites
//
//  Currently instead of all real site we put guid of NT4 site (pOwnerId)
//
//+--------------------------------------------------------------

HRESULT GetAllMachineSites ( IN GUID    *pMachineGuid,
                             IN LPWSTR  wszMachineName,
                             IN GUID    *pOwnerGuid,
                             IN BOOL    fForeign,
                             OUT DWORD  *pdwNumSites,
                             OUT GUID   **ppguidSites,
                             OUT BOOL   *pfIsConnector) 
{    
    DWORD   dwNumCNs = 0;
    GUID    *pguidCNs = NULL ;    
    HRESULT hr = GetMachineCNs(pMachineGuid,
                               &dwNumCNs,
                               &pguidCNs ) ;

    if (fForeign)
    {     
        *pdwNumSites = dwNumCNs;          
        *ppguidSites = pguidCNs;
        return hr;
    }

    //
    // For now, ownerid is also siteid.
    // In the future, when code is ready, will look for "real site", the
    // nt5 site where machine should really be. Now just call that
    // funtion, but don't use the site it return.
    //    
    //DWORD     dwRealNumSites = 0;    	
    //AP<GUID>  pguidRealSites = NULL ;

    //hr = DSCoreGetComputerSites(wszMachineName,
    //                            &dwRealNumSites,
    //                            &pguidRealSites ) ;
    //CHECK_HR(hr) ;
    //ASSERT(dwRealNumSites); // Must be > 0

    GUID *pSites = new GUID[ dwNumCNs + 1 ] ;                     
    *ppguidSites = pSites ;   

    //
    // NT4 site is the first site in array
    //
    *pdwNumSites = 1;
    memcpy (&pSites[0], pOwnerGuid, sizeof(GUID));

    //
    // Bug 5012.
    // Find all foreign CNs in pguidCNs and add them to array of Site Ids
    //
    *pfIsConnector = FALSE;
    UINT iIndex = 0;
    TCHAR *pszFileName = GetIniFileName ();

    for (UINT i=0; i<dwNumCNs; i++)
    {
	    //
	    // look for this CN guid in .ini file in ForeignCN section		
	    //
	    if (IsObjectGuidInIniFile (&(pguidCNs[i]), MIGRATION_FOREIGN_SECTION))
	    {
            *pfIsConnector = TRUE;

            memcpy (&pSites[*pdwNumSites], &pguidCNs[i], sizeof(GUID));
            (*pdwNumSites)++;
       
            unsigned short *lpszForeignCN ;

            UuidToString( &pguidCNs[i], &lpszForeignCN ) ;                            

            //
            // save foreign cn guid in .ini to create site link later
            //         
            iIndex ++;
            TCHAR szBuf[20];
            _ltot( iIndex, szBuf, 10 );

            TCHAR tszName[50];
            _stprintf(tszName, TEXT("%s - %s"), 
                MIGRATION_CONNECTOR_FOREIGNCN_NUM_SECTION, wszMachineName);
            BOOL f = WritePrivateProfileString( tszName,
                                                MIGRATION_CONNECTOR_FOREIGNCN_NUM_KEY,
                                                szBuf,
                                                pszFileName ) ;
            ASSERT(f) ;   

            _stprintf(tszName, TEXT("%s%lu"), 
                MIGRATION_CONNECTOR_FOREIGNCN_KEY, iIndex);                
            f = WritePrivateProfileString(  wszMachineName,
                                            tszName,
                                            lpszForeignCN,
                                            pszFileName ) ;
            ASSERT(f) ; 
                                                
            RpcStringFree( &lpszForeignCN ) ;     
	    }
    }

    return hr;
}

//+-----------------------------------------------
//
//  HRESULT SaveMachineWithInvalidNameInIniFile()
//
//+-----------------------------------------------

void SaveMachineWithInvalidNameInIniFile (LPWSTR wszMachineName, GUID *pMachineGuid)
{
    TCHAR *pszFileName = GetIniFileName ();
    //
    // we save machine in the form 
    // <guid>=<machine name> in order to improve searching by GUID
    //
    unsigned short *lpszMachineId ;
	UuidToString( pMachineGuid, &lpszMachineId ) ;    
    BOOL f = WritePrivateProfileString(  
                    MIGRATION_MACHINE_WITH_INVALID_NAME,
                    lpszMachineId,
                    wszMachineName,                                        
                    pszFileName ) ;
    DBG_USED(f);
    ASSERT(f);
    RpcStringFree( &lpszMachineId );
}

//+-----------------------------------------------
//
//  HRESULT _CreateComputersObject()
//
//+-----------------------------------------------

static HRESULT _CreateComputerObject( LPWSTR wszMachineName, GUID *pMachineGuid )
{
    PLDAP pLdap = NULL ;
    TCHAR *pwszDefName = NULL ;

    HRESULT hr =  InitLDAP(&pLdap, &pwszDefName) ;
    if (FAILED(hr))
    {
        LogMigrationEvent( MigLog_Error, MQMig_E_COMPUTER_CREATED, wszMachineName, hr ) ;
        return hr ;
    }

    //
    // Now that container object exist, it's time to
    // create the computer object.
    //
	DWORD iComProperty =0;
    PROPID propComIDs[2] ;
    PROPVARIANT propComVariants[2] ;

    //
    // Ronit says that sam account should end with a $.
    //
    // The PROPID_COM_SAM_ACCOUNT contains the first MAX_COM_SAM_ACCOUNT_LENGTH (19)
    // characters of the computer name, as unique ID. (6295 - ilanh - 03-Jan-2001)
    //
    DWORD dwNetBiosNameLen = __min(wcslen( wszMachineName ), MAX_COM_SAM_ACCOUNT_LENGTH);

    AP<TCHAR> tszAccount = new TCHAR[2 + dwNetBiosNameLen];
    _tcsncpy(tszAccount, wszMachineName, dwNetBiosNameLen);
    tszAccount[dwNetBiosNameLen] = L'$';
    tszAccount[dwNetBiosNameLen + 1] = 0;

    propComIDs[iComProperty] = PROPID_COM_SAM_ACCOUNT ;
    propComVariants[iComProperty].vt = VT_LPWSTR ;
    propComVariants[iComProperty].pwszVal = tszAccount ;
    iComProperty++;

    propComIDs[iComProperty] = PROPID_COM_ACCOUNT_CONTROL ;
    propComVariants[iComProperty].vt = VT_UI4 ;
    propComVariants[iComProperty].ulVal = DEFAULT_COM_ACCOUNT_CONTROL ;
    iComProperty++;

	DWORD iComPropertyEx =0;
    PROPID propComIDsEx[1] ;
    PROPVARIANT propComVariantsEx[1] ;

    DWORD dwSize = _tcslen(pwszDefName) +
                   _tcslen(MIG_DEFAULT_COMPUTERS_CONTAINER) +
                   OU_PREFIX_LEN + 2 ;
    P<TCHAR> tszContainer = new TCHAR[ dwSize ] ;
    _tcscpy(tszContainer, OU_PREFIX) ;
    _tcscat(tszContainer, MIG_DEFAULT_COMPUTERS_CONTAINER) ;
    _tcscat(tszContainer, LDAP_COMMA) ;
    _tcscat(tszContainer, pwszDefName) ;

    propComIDsEx[iComPropertyEx] = PROPID_COM_CONTAINER ;
    propComVariantsEx[iComPropertyEx].vt = VT_LPWSTR ;
    propComVariantsEx[iComPropertyEx].pwszVal = tszContainer ;
    iComPropertyEx++;

    ASSERT( iComProperty ==
            (sizeof(propComIDs) / sizeof(propComIDs[0])) ) ;
    ASSERT( iComPropertyEx ==
            (sizeof(propComIDsEx) / sizeof(propComIDsEx[0])) ) ;

    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);

    hr = DSCoreCreateObject( MQDS_COMPUTER,
                             wszMachineName,
                             iComProperty,
                             propComIDs,
                             propComVariants,
                             iComPropertyEx,
                             propComIDsEx,
                             propComVariantsEx,
                             &requestContext,
                             NULL,
                             NULL ) ;
    if (SUCCEEDED(hr))
    {
        LogMigrationEvent( MigLog_Info, MQMig_I_COMPUTER_CREATED, wszMachineName ) ;
    }
    else 
    {
        LogMigrationEvent( MigLog_Error, MQMig_E_COMPUTER_CREATED, wszMachineName, hr ) ;
        if (!IsObjectNameValid(wszMachineName))
        {
            SaveMachineWithInvalidNameInIniFile (wszMachineName, pMachineGuid);           
            LogMigrationEvent(MigLog_Event, MQMig_E_INVALID_MACHINE_NAME, wszMachineName) ;
            hr = MQMig_E_INVALID_MACHINE_NAME ;
        }   
    }

    return hr ;
}

//+--------------------------------------------------------------
//
//  HRESULT CreateMachineObject
//  Create machine object and computer object if needed
//  If local machine is PSC or we are in the "web" mode try to set
//  properties at first
//
//+--------------------------------------------------------------
                             
HRESULT CreateMachineObjectInADS (
                IN DWORD    dwService,
                IN BOOL     fWasServerOnCluster,
                IN GUID     *pOwnerGuid,
                IN GUID     *pMachineGuid,
                IN LPWSTR   wszSiteName,
                IN LPWSTR   wszMachineName,
                IN DWORD    SetPropIdCount,
                IN DWORD    iProperty,
                IN PROPID   *propIDs,
                IN PROPVARIANT *propVariants
                )
{
    HRESULT hr = MQMig_OK;
    
    if (g_dwMyService == SERVICE_PSC)
    {
        //
        // We are here if the wizard run on PSC. We try to set properties at first.
        // If it is web mode "set" allow us to repair                   
        //      - server msmq object in ADS to resolve connector machine problem
        //      - client msmq object in ADS to resolve Out/In FRS problem
        //            
        if (memcmp(pMachineGuid, &g_MyMachineGuid, sizeof(GUID)) == 0 ||
            fWasServerOnCluster)
        {
            //
            // current machine is local server OR
            // (bug 5423) we handle machine that was PSC on cluster
            //
            // assume that server already exist in DS, we have to reset NT4Flag
            //
            hr = ResetSettingFlag(  1,                  //dwNumSites,
                                    pOwnerGuid,         //pguidSites,
                                    wszMachineName,
                                    const_cast<WCHAR*> (MQ_SET_NT4_ATTRIBUTE),
                                    L"0");
        }

        //
        // this is PSC, assume that object exist, try to set properties
        //
        if (SUCCEEDED(hr))
        {
            CDSRequestContext requestContext( e_DoNotImpersonate,
                                    e_ALL_PROTOCOLS);

            hr = DSCoreSetObjectProperties (  MQDS_MACHINE,
                                              NULL,
                                              pMachineGuid,
                                              SetPropIdCount,
                                              propIDs,
                                              propVariants,
                                              &requestContext,
                                              NULL );
            if (SUCCEEDED(hr))
            {
                return MQMig_OK;
            }
        }
    }
   
    PROPID      propIDsSetting[3];
    PROPVARIANT propVariantsSetting[3] ;
    DWORD       iPropsSetting = 0 ;

    PROPID  *pPropIdSetting = NULL;
    PROPVARIANT *pPropVariantSetting = NULL;

    if (dwService != SERVICE_NONE)   
    {
        pPropIdSetting = propIDsSetting;
        pPropVariantSetting = propVariantsSetting; 

		//
        // for a Falcon server, prepare the PROPID_SET properties too.
		// Migration will always set the migrated object mSMQNT4Flags = false
		// There is no mixed mode, all object migrated to AD are not NT4 objects anymore.
		//
        propIDsSetting[ iPropsSetting ] = PROPID_SET_NT4 ;
	    propVariantsSetting[ iPropsSetting ].vt = VT_UI4 ;
        propVariantsSetting[ iPropsSetting ].ulVal = 0;
	    iPropsSetting++;

        propIDsSetting[ iPropsSetting ] = PROPID_SET_MASTERID;
	    propVariantsSetting[ iPropsSetting ].vt = VT_CLSID;
        propVariantsSetting[ iPropsSetting ].puuid = pOwnerGuid ;
	    iPropsSetting++;

        propIDsSetting[ iPropsSetting ] = PROPID_SET_SITENAME ;
	    propVariantsSetting[ iPropsSetting ].vt = VT_LPWSTR ;
        propVariantsSetting[ iPropsSetting ].pwszVal = wszSiteName ;
	    iPropsSetting++;

	    ASSERT(iPropsSetting == 3) ;        
    }

    hr = DSCoreCreateMigratedObject( MQDS_MACHINE,
                                     wszMachineName,
                                     iProperty,
                                     propIDs,
                                     propVariants,
                                     iPropsSetting,
                                     pPropIdSetting,
                                     pPropVariantSetting,
                                     NULL,
                                     NULL,
                                     NULL,
                                     FALSE,
                                     FALSE,
                                     NULL,
                                     NULL) ;

    if (hr == MQ_ERROR_MACHINE_NOT_FOUND ||
        hr == MQDS_OBJECT_NOT_FOUND)
    {
        hr = _CreateComputerObject( wszMachineName, pMachineGuid ) ;
        if (SUCCEEDED(hr))
        {
            //
            // Try again to create the MSMQ machine, now that the
            // DS computer object was already created.
            //
            CDSRequestContext requestContext( e_DoNotImpersonate,
                                        e_ALL_PROTOCOLS);

            hr = DSCoreCreateObject( MQDS_MACHINE,
                                     wszMachineName,
                                     iProperty,
                                     propIDs,
                                     propVariants,
                                     iPropsSetting,
                                     pPropIdSetting,
                                     pPropVariantSetting,
                                     &requestContext,
                                     NULL,
                                     NULL ) ;
        }
    }
   
    if ((hr == MQ_ERROR_MACHINE_EXISTS) || (hr == HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM)))
    {
    	//
        // it is possible if we run migtool at the second time on PEC
        // or we run it on PSC
        //
    	PROPID propID = PROPID_QM_MACHINE_ID;
	    PROPVARIANT propVariant;
	    propVariant.vt = VT_NULL;
		
	    CDSRequestContext requestContext( e_DoNotImpersonate, e_ALL_PROTOCOLS);

		HRESULT hr = DSCoreGetProps( 
								MQDS_MACHINE,
								NULL, //pathname
								pMachineGuid,
								1,
								&propID,
								&requestContext,
								&propVariant ) ;

		if (FAILED(hr))
		{
			return hr;
		}
		
		ASSERT(memcmp(pMachineGuid, propVariant.puuid, sizeof (GUID)) == 0);
		delete propVariant.puuid;

        return MQMig_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\exstub.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    exstub.cpp

Abstract:
    Ex stub function

Author:
    Ilan Herbst (ilanh) 19-July-2000

Environment:
    Platform-independent,

--*/

#include "migrat.h"
#include "mqmacro.h"
#include "ex.h"

#include "exstub.tmh"

VOID                             
ExSetTimer(
    CTimer* /*pTimer*/,
    const CTimeDuration& /*Timeout*/
    )
{
    ASSERT(("MQMIGRAT dont suppose to call ExSetTimer", 0));
    return;
}


BOOL
ExCancelTimer(
    CTimer* /*pTimer*/
    )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\makedsn.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    makedsn.cpp

Abstract:

    Configure ODBC manager related code.
Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

//#ifdef UNICODE
//
// ODBC is ANSI
//
#undef   UNICODE
#undef  _UNICODE
#define _MBCS
//#endif

#define STRICT 1
#include <windows.h>

#define __FALCON_STDH_H
#define _NO_SEQNUM_
#define _NO_NT5DS_
#include "migrat.h"

#include <odbcinst.h>

#include "makedsn.tmh"

//
// ODBC data source parameters for the SQL Server database
//
const char MQIS_DSN_STRING[] = { "DSN=" DSN_NAME "\0"
                                 "Database=MQIS\0"
                                 "UseProcForPrepare=Yes\0"
                                 "Description=Remote MQIS database\0" } ;

#define MQIS_SERVER_STRING      "Server=%s"


HRESULT  MakeMQISDsn(LPSTR lpszServerName, BOOL fMakeAlways)
{
    HRESULT hr = MQMig_OK ;
    static BOOL s_fMakeDsn = FALSE ;
    if (s_fMakeDsn && !fMakeAlways)
    {
        return MQMig_OK ;
    }
   
    //
    // Load ODBCCP32.DLL, the ODBC control panel library
    //
    HINSTANCE hODBCCP32DLL = LoadLibrary(TEXT("ODBCCP32.DLL"));
    if (hODBCCP32DLL == NULL)
    {
        hr = MQMig_E_CANT_LOAD_ODBCCP ;
        LogMigrationEvent( MigLog_Error,
                           hr,
                           GetLastError()) ;
        return hr ;
    }

    //
    // Obtain a pointer to the data source configuration function
    //
    typedef HRESULT (APIENTRY *FUNCSQLCONFIGDATASOURCE)
                                        (HWND, WORD, LPCSTR, LPCSTR);
    FUNCSQLCONFIGDATASOURCE pfSQLConfigDataSource =
        (FUNCSQLCONFIGDATASOURCE)GetProcAddress(hODBCCP32DLL,
                                                "SQLConfigDataSource");
    if (pfSQLConfigDataSource == NULL)
    {
        hr = MQMig_E_CANT_GETADRS_ODBCCP ;
        LogMigrationEvent( MigLog_Error,
                           hr,
                           GetLastError()) ;
        return hr ;
    }

    //
    // Create the ODBC data source for the SQL Server database; if unable to
    // add the data source, try configuring it, in case it already exists
    //
    char szDSNServer[ 512 ] ;
    sprintf(szDSNServer, MQIS_SERVER_STRING, lpszServerName) ;

    char szDSNString[ 1024 ] ;
    DWORD dwSize = sizeof(MQIS_DSN_STRING) ;
    memcpy( szDSNString, MQIS_DSN_STRING, dwSize) ;
    //_tcscpy(&szDSNString[ dwSize-1 ], szDSNServer) ;
    //dwSize += _tcslen(szDSNServer) ;
    strcpy(&szDSNString[ dwSize-1 ], szDSNServer) ;
    dwSize += strlen(szDSNServer) ;

    szDSNString[dwSize] = '\0' ;
    szDSNString[dwSize+1] = '\0' ;

    if (!pfSQLConfigDataSource(NULL, ODBC_ADD_SYS_DSN,
                               "SQL Server", szDSNString) &&
        !pfSQLConfigDataSource(NULL, ODBC_CONFIG_SYS_DSN,
                               "SQL Server", szDSNString))
    {
        hr = MQMig_E_CANT_CREATE_DSN ;
        LogMigrationEvent( MigLog_Error,
                           hr ) ;
        return hr ;
    }

    //
    // Free the ODBC control panel library
    //
    FreeLibrary(hODBCCP32DLL);

    s_fMakeDsn = TRUE;

    return MQMig_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\migent.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migent.cpp

Abstract:

    Migration NT4 Enterprise objects to NT5 ADS.
Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

#include "migrat.h"
#include "resource.h"
#include "dsreqinf.h"
#include "_guid.h"

#include "migent.tmh"

#define SITELINK_PROP_NUM  7

//+-------------------------------------------------------------------------
//
//  HRESULT SaveSiteLink()
//
//	If we are going to delete Enterprise Object we have to save before
//	all site links those were created in Windows2000 Enterprise.
//	It allows us to mix two enterprises correctly.
//	When we'll create new Enterprise Object with NT4 guid, we'll restore 
//	all site links.
//
//+-------------------------------------------------------------------------

HRESULT SaveSiteLink ()
{
	HRESULT hr = MQMig_OK;

    //
    // Lookup the Neighbors Id and Gates of the object Site Link
    //
	PROPID columnsetPropertyIDs[SITELINK_PROP_NUM]; 

	DWORD dwCount = 0;	
	columnsetPropertyIDs[dwCount] = PROPID_L_NEIGHBOR1;
	DWORD dwNeighbor1Id = dwCount;
	dwCount ++;

	columnsetPropertyIDs[dwCount] = PROPID_L_NEIGHBOR2;
	DWORD dwNeighbor2Id = dwCount;
	dwCount ++;

	columnsetPropertyIDs[dwCount] = PROPID_L_GATES_DN;
	DWORD dwGates = dwCount;
	dwCount ++;

	columnsetPropertyIDs[dwCount] = PROPID_L_FULL_PATH;
	DWORD dwFullPath = dwCount;
	dwCount ++;

	columnsetPropertyIDs[dwCount] = PROPID_L_COST;
	DWORD dwCost = dwCount;
	dwCount ++;

	columnsetPropertyIDs[dwCount] = PROPID_L_DESCRIPTION;
	DWORD dwDescription = dwCount;
	dwCount ++;

	columnsetPropertyIDs[dwCount] = PROPID_L_ID ;
	DWORD dwId = dwCount;
	dwCount ++;

	ASSERT (dwCount == SITELINK_PROP_NUM);

    MQCOLUMNSET columnsetSiteLink;
    columnsetSiteLink.cCol = SITELINK_PROP_NUM;
    columnsetSiteLink.aCol = columnsetPropertyIDs;

    HANDLE hQuery;    
	
	hr = LookupBegin(&columnsetSiteLink, &hQuery);
	if (FAILED(hr))
	{
		LogMigrationEvent(	MigLog_Error, 
							MQMig_E_SITELINK_LOOKUPBEGIN_FAILED, 
							hr) ;
		return hr;
	}	
	
	PROPVARIANT paVariant[SITELINK_PROP_NUM];
	ULONG ulSiteLinkCount = 0;

	TCHAR *pszFileName = GetIniFileName ();

	TCHAR szBuf[20];
	BOOL f;
	HRESULT hr1 = MQMig_OK;	

	while (SUCCEEDED(hr))
    {
		hr = LookupNext( hQuery,
		                 &dwCount,
                         paVariant ) ;
		if (FAILED(hr))		
		{
			LogMigrationEvent(	MigLog_Error, 
								MQMig_E_SITELINK_LOOKUPNEXT_FAILED, 
								hr) ;
			break;
		}

		if (dwCount == 0)
		{
			//there is no result
			break;
		}
		
		ulSiteLinkCount ++;
		TCHAR tszSectionName[50];
		_stprintf(tszSectionName, TEXT("%s%lu"), MIGRATION_SITELINK_SECTION, ulSiteLinkCount);
				
		//
		//	Save all properties in .ini
		//
		//	Save Neighbor1 ID
		//		
		unsigned short *lpszGuid ;
		UuidToString( paVariant[dwNeighbor1Id].puuid, &lpszGuid ) ;				
				
		f = WritePrivateProfileString( tszSectionName,
                                       MIGRATION_SITELINK_NEIGHBOR1_KEY,
                                       lpszGuid,
                                       pszFileName ) ;
		ASSERT(f);

		RpcStringFree( &lpszGuid ) ;
		delete paVariant[dwNeighbor1Id].puuid;		
					
		//
		//	Save Neighbor2 ID
		//		
		UuidToString( paVariant[dwNeighbor2Id].puuid, &lpszGuid ) ;				
				
		f = WritePrivateProfileString( tszSectionName,
                                       MIGRATION_SITELINK_NEIGHBOR2_KEY,
                                       lpszGuid,
                                       pszFileName ) ;
		ASSERT(f);

		RpcStringFree( &lpszGuid ) ;
		delete paVariant[dwNeighbor2Id].puuid;		

		//
		//	Save cost
		//		
		if (paVariant[dwCost].ulVal > MQ_MAX_LINK_COST)
		{
			//
			// if one of the neighbors is foreign site, LookupNext returns
			// cost = real cost + MQ_MAX_LINK_COST
			// We have to save real value in order to create link with real value
			//
			paVariant[dwCost].ulVal -= MQ_MAX_LINK_COST;

		}
		_ltot( paVariant[dwCost].ulVal, szBuf, 10 );
		f = WritePrivateProfileString( tszSectionName,
                                       MIGRATION_SITELINK_COST_KEY,
                                       szBuf,
                                       pszFileName ) ;
		ASSERT(f);

		//
		//	Save full path
		//
		f = WritePrivateProfileString( tszSectionName,
                                       MIGRATION_SITELINK_PATH_KEY,
                                       paVariant[dwFullPath].pwszVal,
                                       pszFileName ) ;
		ASSERT(f);

		_ltot( wcslen(paVariant[dwFullPath].pwszVal), szBuf, 10 );
		f = WritePrivateProfileString( tszSectionName,
                                       MIGRATION_SITELINK_PATHLENGTH_KEY,
                                       szBuf,
                                       pszFileName ) ;
		ASSERT(f);

		delete paVariant[dwFullPath].pwszVal;

		//
		//	Save description
		//
		f = WritePrivateProfileString( tszSectionName,
                                       MIGRATION_SITELINK_DESCRIPTION_KEY,
                                       paVariant[dwDescription].pwszVal,
                                       pszFileName ) ;
		ASSERT(f);
		
		_ltot( wcslen(paVariant[dwDescription].pwszVal), szBuf, 10 );
		f = WritePrivateProfileString( tszSectionName,
                                       MIGRATION_SITELINK_DESCRIPTIONLENGTH_KEY,
                                       szBuf,
                                       pszFileName ) ;
		ASSERT(f);

		delete paVariant[dwDescription].pwszVal;

		//
		//	Save gates
		//
		//	Save number of gates
		//
		_ltot( paVariant[dwGates].calpwstr.cElems, szBuf, 10 );
		f = WritePrivateProfileString( tszSectionName,
                                       MIGRATION_SITELINK_SITEGATENUM_KEY,
                                       szBuf,
                                       pszFileName ) ;
		ASSERT(f);	
		
		//
		// save all site gates if needed
		//
		if (paVariant[dwGates].calpwstr.cElems)
		{
			//
			//	Save length of all site gate names
			//
			ULONG ulLength = 0;
			for (ULONG i = 0; i < paVariant[dwGates].calpwstr.cElems; i++)
			{
				ulLength += wcslen (paVariant[dwGates].calpwstr.pElems[i]) + 1;			
			}
			_ltot( ulLength, szBuf, 10 );
			f = WritePrivateProfileString( tszSectionName,
										   MIGRATION_SITELINK_SITEGATELENGTH_KEY,
										   szBuf,
										   pszFileName ) ;
			ASSERT(f);	

			//
			//	construct and save site gate string: SiteGateName1;SiteGateName2; ...
			//
			AP<WCHAR> pwszSiteGates = new WCHAR [ulLength + 1];
			pwszSiteGates[0] = L'\0';
			for (i = 0; i < paVariant[dwGates].calpwstr.cElems; i++)
			{
				wcscat (pwszSiteGates, paVariant[dwGates].calpwstr.pElems[i]);
				wcscat (pwszSiteGates, L";");
			}
			f = WritePrivateProfileString( tszSectionName,
										   MIGRATION_SITELINK_SITEGATE_KEY,
										   pwszSiteGates,
										   pszFileName ) ;
			ASSERT(f);
		}
		delete [] paVariant[dwGates].calpwstr.pElems;	

		//
		// delete this sitelink
		//		
		CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);

		hr = DSCoreDeleteObject( 
					MQDS_SITELINK,
                    NULL,
                    paVariant[dwId].puuid,
                    &requestContext,
                    NULL
					);		
		if (FAILED(hr))
		{		
			UuidToString( paVariant[dwId].puuid, &lpszGuid ) ;				
			LogMigrationEvent( MigLog_Error, MQMig_E_CANNOT_DELETE_SITELINK, 
				lpszGuid, 
				hr) ;
			RpcStringFree( &lpszGuid ) ;

			hr1 = MQMig_E_CANNOT_DELETE_SITELINK ;
			//
			// we continue with the next site link			
			//
			hr = MQMig_OK;
		}

		delete paVariant[dwId].puuid ;	
    }

	HRESULT hRes = LookupEnd( hQuery ) ;
    DBG_USED(hRes);
	ASSERT(SUCCEEDED(hRes)) ;


	if (ulSiteLinkCount == 0)
	{
		LogMigrationEvent(MigLog_Info, MQMig_I_NO_SITELINK );		
	}
	else
	{
		LogMigrationEvent( MigLog_Info, MQMig_I_SITELINK_COUNT, ulSiteLinkCount);
		_ltot( ulSiteLinkCount, szBuf, 10 );
		f = WritePrivateProfileString( MIGRATION_SITELINKNUM_SECTON,
                                       MIGRATION_SITELINKNUM_KEY,
                                       szBuf,
                                       pszFileName ) ;
	}		

	if (FAILED(hr1))
	{
		return hr1;
	}
	return hr;
}

//+-------------------------------------------------------------------------
//
//  HRESULT _RestoreSiteLink()
//
//	Restore all Windows2000 MSMQ site link: get all properties from
//	.ini file and create these site link with new guid under new msmqServices
//
//+-------------------------------------------------------------------------

HRESULT _RestoreSiteLink()
{
	HRESULT hr = MQMig_OK;

	TCHAR *pszFileName = GetIniFileName ();
	ULONG ulSiteLinkCount = GetPrivateProfileInt(
								  MIGRATION_SITELINKNUM_SECTON,	// address of section name
								  MIGRATION_SITELINKNUM_KEY,    // address of key name
								  0,							// return value if key name is not found
								  pszFileName					// address of initialization filename);
								  );
	if (ulSiteLinkCount == 0)
	{
		return MQMig_OK;
	}

	HRESULT hr1 = MQMig_OK;
	ULONG ulNonCreatedSiteLinkCount = ulSiteLinkCount;

	for (ULONG ulCount=0; ulCount<ulSiteLinkCount; ulCount++)
	{
		TCHAR tszSectionName[50];
		_stprintf(tszSectionName, TEXT("%s%lu"), MIGRATION_SITELINK_SECTION, ulCount+1);
		
        DWORD dwRetSize;				
		//
		// get Neighbor1 
		//
		GUID Neighbor1Id = GUID_NULL;
		TCHAR szGuid[50];
	
		dwRetSize =  GetPrivateProfileString(
                          tszSectionName,			// points to section name
                          MIGRATION_SITELINK_NEIGHBOR1_KEY,	// points to key name
                          TEXT(""),                 // points to default string
                          szGuid,          // points to destination buffer
                          50,                 // size of destination buffer
                          pszFileName               // points to initialization filename);
                          );
        if (_tcscmp(szGuid, TEXT("")) == 0)
        {
			//
			// we cannot create such site link
			//
			hr1 = MQMig_E_CANNOT_CREATE_SITELINK;
            continue;
        }	
		UuidFromString(&(szGuid[0]), &Neighbor1Id);

		//
		// get Neighbor2 
		//		
		GUID Neighbor2Id = GUID_NULL;		
	
		dwRetSize =  GetPrivateProfileString(
                          tszSectionName,			// points to section name
                          MIGRATION_SITELINK_NEIGHBOR2_KEY,	// points to key name
                          TEXT(""),                 // points to default string
                          szGuid,          // points to destination buffer
                          50,                 // size of destination buffer
                          pszFileName               // points to initialization filename);
                          );
        if (_tcscmp(szGuid, TEXT("")) == 0)
        {
            //
			// we cannot create such site link
			//
			hr1 = MQMig_E_CANNOT_CREATE_SITELINK;
            continue;
        }	
		UuidFromString(&(szGuid[0]), &Neighbor2Id);		

		//
		// get cost
		//
		ULONG ulCost = GetPrivateProfileInt(
								  tszSectionName,	// address of section name
								  MIGRATION_SITELINK_COST_KEY,    // address of key name
								  0,							// return value if key name is not found
								  pszFileName					// address of initialization filename);
								  );

		//
		// get full path of site link
		//
		ULONG ulLength = GetPrivateProfileInt(
							  tszSectionName,	// address of section name
							  MIGRATION_SITELINK_PATHLENGTH_KEY,    // address of key name
							  0,							// return value if key name is not found
							  pszFileName					// address of initialization filename);
							  );
		ASSERT(ulLength);

		AP<TCHAR> pszSiteLinkPath = new TCHAR[ulLength+1];
		dwRetSize =  GetPrivateProfileString(
                          tszSectionName,			// points to section name
                          MIGRATION_SITELINK_PATH_KEY,	// points to key name
                          TEXT(""),                 // points to default string
                          pszSiteLinkPath,          // points to destination buffer
                          ulLength+1,                 // size of destination buffer
                          pszFileName               // points to initialization filename);
                          );
        if ((dwRetSize != 0) && (_tcscmp(pszSiteLinkPath, TEXT("")) == 0))
        {
            //
			// we cannot create such site link
			//
			hr1 = MQMig_E_CANNOT_CREATE_SITELINK;
            continue;
        }
		
		//
		// get site gates
		//
		ULONG ulGatesNum = GetPrivateProfileInt(
								  tszSectionName,	// address of section name
								  MIGRATION_SITELINK_SITEGATENUM_KEY,    // address of key name
								  0,							// return value if key name is not found
								  pszFileName					// address of initialization filename);
								  );			
		LPTSTR* ppSiteGates = NULL;			
		if (ulGatesNum)
		{
			//
			// there is site gate for this site link
			//
			ulLength = GetPrivateProfileInt(
								  tszSectionName,	// address of section name
								  MIGRATION_SITELINK_SITEGATELENGTH_KEY,    // address of key name
								  0,							// return value if key name is not found
								  pszFileName					// address of initialization filename);
								  );
			ASSERT(ulLength);
			AP<TCHAR> pszSiteGate = new TCHAR[ulLength+1];

			dwRetSize =  GetPrivateProfileString(
							  tszSectionName,			// points to section name
							  MIGRATION_SITELINK_SITEGATE_KEY,	// points to key name
							  TEXT(""),                 // points to default string
							  pszSiteGate,		        // points to destination buffer
							  ulLength+1,                 // size of destination buffer
							  pszFileName               // points to initialization filename);
							  );
			//
			// create array of site gates
			//
			ppSiteGates = new LPTSTR[ ulGatesNum ];
			memset(ppSiteGates, 0, sizeof(LPTSTR)*ulGatesNum);
			
			TCHAR *ptr = pszSiteGate;
			TCHAR chFind = _T(';');

			for (ULONG i=0; i<ulGatesNum && *ptr != _T('\0'); i++)
			{
				//
				// site gate names are separated by ';'
				//
				TCHAR *pdest = _tcschr( ptr, chFind );
				ULONG ulCurLength = pdest - ptr ;  //not including last ';' 
				
				ppSiteGates[i] = new TCHAR[ulCurLength+1];				
				_tcsncpy( ppSiteGates[i], ptr, ulCurLength );
				TCHAR *ptrTmp = ppSiteGates[i];
				ptrTmp[ulCurLength] = _T('\0');

				ptr = pdest + 1;	//the first character after ';'
			}
		}

		//
		// get description
		//
		ulLength = GetPrivateProfileInt(
						  tszSectionName,	// address of section name
						  MIGRATION_SITELINK_DESCRIPTIONLENGTH_KEY,    // address of key name
						  0,							// return value if key name is not found
						  pszFileName					// address of initialization filename);
						  );		

		AP<TCHAR> pszDescription = NULL;	
		if (ulLength)
		{
			//
			// there is description in .ini for this sitelink
			//
			pszDescription = new TCHAR[ulLength+1];
			dwRetSize =  GetPrivateProfileString(
							  tszSectionName,			// points to section name
							  MIGRATION_SITELINK_DESCRIPTION_KEY,	// points to key name
							  TEXT(""),                 // points to default string
							  pszDescription,	        // points to destination buffer
							  ulLength+1,                 // size of destination buffer
							  pszFileName               // points to initialization filename);
							  );	
		}

		//
		// Create this sitelink in DS
		//	
		// Prepare the properties for DS call.
		//		
		PROPVARIANT paVariant[SITELINK_PROP_NUM];
		PROPID      paPropId[SITELINK_PROP_NUM];
		DWORD          PropIdCount = 0;
	
		paPropId[ PropIdCount ] = PROPID_L_FULL_PATH;    //PropId
		paVariant[ PropIdCount ].vt = VT_LPWSTR;          //Type
		paVariant[ PropIdCount ].pwszVal = pszSiteLinkPath;
		PropIdCount++;

		paPropId[ PropIdCount ] = PROPID_L_NEIGHBOR1;    //PropId
		paVariant[ PropIdCount ].vt = VT_CLSID;          //Type
		paVariant[ PropIdCount ].puuid = &Neighbor1Id;
		PropIdCount++;

		paPropId[ PropIdCount ] = PROPID_L_NEIGHBOR2;    //PropId
		paVariant[ PropIdCount ].vt = VT_CLSID;          //Type
		paVariant[ PropIdCount ].puuid = &Neighbor2Id;
		PropIdCount++;

		paPropId[ PropIdCount ] = PROPID_L_COST;    //PropId
		paVariant[ PropIdCount ].vt = VT_UI4;       //Type
		paVariant[ PropIdCount ].ulVal = ulCost;
		PropIdCount++;

		if (pszDescription)
		{
		    //
		    // BUG 5225.
		    // Add description only if exists.
		    //
		    paPropId[ PropIdCount ] = PROPID_L_DESCRIPTION;    //PropId
		    paVariant[ PropIdCount ].vt = VT_LPWSTR;          //Type
		    paVariant[ PropIdCount ].pwszVal = pszDescription;
		    PropIdCount++;
		}
		
		paPropId[ PropIdCount ] = PROPID_L_GATES_DN;    //PropId
		paVariant[ PropIdCount ].vt = VT_LPWSTR | VT_VECTOR;          //Type
		paVariant[ PropIdCount ].calpwstr.cElems = ulGatesNum;
		paVariant[ PropIdCount ].calpwstr.pElems = ppSiteGates;	
		PropIdCount++;

		ASSERT((LONG) PropIdCount <= SITELINK_PROP_NUM) ;  

		CDSRequestContext requestContext( e_DoNotImpersonate,
									e_ALL_PROTOCOLS);  // not relevant 

		HRESULT hr = DSCoreCreateObject ( MQDS_SITELINK,
										  NULL,			//or pszSiteLinkPath??
										  PropIdCount,
										  paPropId,
										  paVariant,
										  0,        // ex props
										  NULL,     // ex props
										  NULL,     // ex props
										  &requestContext,
										  NULL,
										  NULL ) ;

		if (FAILED(hr))
		{
			LogMigrationEvent(	MigLog_Warning, 
								MQMig_E_CANNOT_CREATE_SITELINK, 
								pszSiteLinkPath, hr) ;	
			hr1 = MQMig_E_CANNOT_CREATE_SITELINK;
		}
		else
		{
			//
			// site link was created successfully
			//
			LogMigrationEvent(	MigLog_Info, 
								MQMig_I_SITELINK_CREATED, 
								pszSiteLinkPath) ;
			//
			// remove this section from .ini
			//
			BOOL f = WritePrivateProfileString( 
								tszSectionName,
								NULL,
								NULL,
								pszFileName ) ;
            UNREFERENCED_PARAMETER(f);
			ulNonCreatedSiteLinkCount --;
		}
	
		if (ppSiteGates)
		{
			for (ULONG i=0; i<ulGatesNum; i++)
			{
				delete[] ppSiteGates[i];
			}
			delete[] ppSiteGates;
		}
	
	}	//for

	//
	// remove this section from .ini file.
	// If we leave some site link section to handle them later
	// we have to put here real site link number, i.e. number of
	// non-created site link. We need to renumerate site link sections too.
	//
	BOOL f;
	if (FAILED(hr) || FAILED(hr1))
	{
		ASSERT (ulNonCreatedSiteLinkCount);

		TCHAR szBuf[10];
		_ltot( ulNonCreatedSiteLinkCount, szBuf, 10 );
		f = WritePrivateProfileString( MIGRATION_NONRESTORED_SITELINKNUM_SECTON,
                                       MIGRATION_SITELINKNUM_KEY,
                                       szBuf,
                                       pszFileName ) ;
	}
	else
	{
		//
		// remove this section from .ini file.
		//
		ASSERT (ulNonCreatedSiteLinkCount == 0);
		f = WritePrivateProfileString( 
						MIGRATION_SITELINKNUM_SECTON,
						NULL,
						NULL,
						pszFileName ) ;
	}

	return hr;
}

//+-------------------------------------------------------------------------
//
//  HRESULT _DeleteEnterprise()
//
//  Delete the enterprise object.
//  By default, when promoting the first server in a new NT5 enterprise to
//  be a domain controller, it has a default msmq enterprise object.
//  When migrating an existing msmq enterprise, we delete this default
//  object and create a new one with the existing guid.
//
//+-------------------------------------------------------------------------

HRESULT _DeleteEnterprise()
{
    HRESULT hr;

	//
	// save all SiteLink if there is in .ini file and then delete them
	//
	hr = SaveSiteLink ();
	if (FAILED(hr))
	{
		//
		// it is critical error: if there is non-deleted site link object
		// we can't delete msmqService object
		//
		return hr;
	}

    PLDAP pLdap = NULL ;
    TCHAR *pwszDefName = NULL ;

    hr =  InitLDAP(&pLdap, &pwszDefName) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    const WCHAR x_wcsCnServices[] =  L"CN=MsmqServices,";

    DWORD Length = (sizeof(x_wcsCnServices)/sizeof(WCHAR))  +  //CN=MsmqServices,
                   (sizeof(SITE_LINK_ROOT) / sizeof(TCHAR)) +  //CN=Services,CN=Configuration,
                   wcslen(pwszDefName) + 1;
    AP<unsigned short> pwcsPath = new WCHAR[Length];
    swprintf(
            pwcsPath,
            L"%s"             // "CN=MsmqServices,"
            L"%s"             // "CN=Services,CN=Configuration,"
            L"%s",            // pwszDefName
            x_wcsCnServices,
            SITE_LINK_ROOT,
            pwszDefName
            );	
	
    ULONG ulRes = ldap_delete_s( pLdap,
                                 pwcsPath ) ;

    if (ulRes != LDAP_SUCCESS)
    {
        LogMigrationEvent( MigLog_Error, MQMig_E_CANNOT_DELETE_ENTERPRISE, pwcsPath, ulRes) ;
        return MQMig_E_CANNOT_DELETE_ENTERPRISE ;
    }
    else
    {
        LogMigrationEvent( MigLog_Info, MQMig_I_DELETE_ENTERPRISE, pwcsPath) ;
    }

    return MQMig_OK;
}

//+----------------------------------------------
//
//  HRESULT CreateMSMQEnterprise()
//
//  Create the msmqService object in NT5 DS.
//
//+----------------------------------------------
HRESULT  _CreateMSMQEnterprise(
                IN ULONG                uLongLived,
                IN GUID                *pEntGuid,
                IN SECURITY_DESCRIPTOR *pEsd,
                IN BYTE                 bNameStyle,
                IN LPWSTR               pwszCSPName,
                IN USHORT               uiVersion,
                IN USHORT               uiInterval1,
                IN USHORT               uiInterval2
                )
{
    UNREFERENCED_PARAMETER(uiVersion);

	PROPID   propIDs[] = { PROPID_E_LONG_LIVE,
                           PROPID_E_NT4ID,
                           PROPID_E_NAMESTYLE,
                           PROPID_E_CSP_NAME,
                           PROPID_E_VERSION,
                           PROPID_E_S_INTERVAL1,
                           PROPID_E_S_INTERVAL2,
                           PROPID_E_SECURITY };
	const DWORD nProps = sizeof(propIDs) / sizeof(propIDs[0]);
	PROPVARIANT propVariants[ nProps ] ;
	DWORD       iProperty = 0 ;

	propVariants[iProperty].vt = VT_UI4;
	propVariants[iProperty].ulVal = uLongLived ;
	iProperty++ ;

	propVariants[iProperty].vt = VT_CLSID;
	propVariants[iProperty].puuid = pEntGuid ;
	iProperty++ ;

    propVariants[iProperty].vt = VT_UI1;
	propVariants[iProperty].bVal = bNameStyle ;
	iProperty++ ;

    propVariants[iProperty].vt = VT_LPWSTR;
	propVariants[iProperty].pwszVal = pwszCSPName ;
	iProperty++ ;

    propVariants[iProperty].vt = VT_UI2;
	propVariants[iProperty].uiVal = DEFAULT_E_VERSION ; //uiVersion
	iProperty++ ;

    propVariants[iProperty].vt = VT_UI2;
	propVariants[iProperty].uiVal = uiInterval1 ;
	iProperty++ ;

    propVariants[iProperty].vt = VT_UI2;
	propVariants[iProperty].uiVal = uiInterval2 ;
	iProperty++ ;

    ASSERT(pEsd && IsValidSecurityDescriptor(pEsd)) ;
    if (pEsd)
    {
        propVariants[iProperty].vt = VT_BLOB ;
	    propVariants[iProperty].blob.pBlobData = (BYTE*) pEsd ;
    	propVariants[iProperty].blob.cbSize =
                                      GetSecurityDescriptorLength(pEsd) ;
	    iProperty++ ;
    }

    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);  // not relevant for enterprise object

    HRESULT hr = DSCoreCreateObject( MQDS_ENTERPRISE,
                                     NULL,
                                     iProperty,
                                     propIDs,
                                     propVariants,
                                     0,        // ex props
                                     NULL,     // ex props
                                     NULL,     // ex props
                                     &requestContext,
                                     NULL,
                                     NULL ) ; 

	if (hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) ||
		hr == HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS) ||
		hr == HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM))
    {
        LogMigrationEvent(MigLog_Warning, MQMig_I_ENT_ALREADY_EXIST) ;
        //
        // if it is MSMQ Enterprise created in the previous time do nothing
        // if it is not, delete it and create enterprise with EntGuid
        //
        PROPID NT4IdProp = PROPID_E_NT4ID;
        PROPVARIANT NT4IdVar;
        NT4IdVar.vt = VT_NULL ;

        CDSRequestContext requestContext( e_DoNotImpersonate,
                                    e_ALL_PROTOCOLS);  // not relevant for enterprise object

        hr = DSCoreGetProps( MQDS_ENTERPRISE,
                             NULL,  // path name
                             pEntGuid,
                             1,
                             &NT4IdProp,
                             &requestContext,
                             &NT4IdVar);

        if (SUCCEEDED(hr))
        {
			bool fDelete = (memcmp(pEntGuid, NT4IdVar.puuid, sizeof (GUID)) != 0);
			delete NT4IdVar.puuid;   
			
			if (fDelete)
			{
				//
	            // delete enterprise
	            //
	            hr = _DeleteEnterprise();
	            if (FAILED(hr))
	            {
	                LogMigrationEvent(MigLog_Error, MQMig_E_CANT_DELETE_ENT, hr) ;
	                return hr;
	            }

	            CDSRequestContext requestContext( e_DoNotImpersonate,
                                    e_ALL_PROTOCOLS);  // not relevant for enterprise object

		        hr = DSCoreCreateObject( MQDS_ENTERPRISE,
		                                 NULL,
		                                 iProperty,
		                                 propIDs,
		                                 propVariants,
		                                 0,        // ex props
		                                 NULL,     // ex props
		                                 NULL,     // ex props
		                                 &requestContext,
		                                 NULL,
		                                 NULL ) ;
			}   
        }
    }
	
    if (SUCCEEDED(hr))
    {
		//
		// At the first time we have to restore pre-migration site link.
		// At the second and more time we have to check: 
		// if there is site link section in .ini it means that we do not yet
		// restore site link at the previous time. 
		// It means, in any case try to restore pre-migration site link.
		//			
		HRESULT hr1 = _RestoreSiteLink();
        UNREFERENCED_PARAMETER(hr1);

		if (!MigWriteRegistryGuid(MSMQ_ENTERPRISEID_REGNAME, pEntGuid))
		{
			GUID_STRING strUuid;
        	MQpGuidToString(pEntGuid, strUuid);
			LogMigrationEvent(MigLog_Error, MQMig_E_SET_REG_SZ, MSMQ_ENTERPRISEID_REGNAME, strUuid) ;
			return MQMig_E_SET_REG_SZ;
		}
		
		//
		// We can continue to migration despite on failure in RestoreSiteLink
		// So, we don't check return code hr1.
		//
        LogMigrationEvent(MigLog_Trace, MQMig_I_ENTERPRISE_CREATED) ;
    }
    else
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_CANT_CREATE_ENT, hr) ;
    }

    return hr ;
}

//-------------------------------------------
//
//  HRESULT MigrateEnterprise()
//
//-------------------------------------------

#define INIT_ENT_COLUMN(_ColName, _ColIndex, _Index)                \
    INIT_COLUMNVAL(pColumns[ _Index ]) ;                            \
    pColumns[ _Index ].lpszColumnName = ##_ColName##_COL ;          \
    pColumns[ _Index ].nColumnValue   = 0 ;                         \
    pColumns[ _Index ].nColumnLength  = 0 ;                         \
    pColumns[ _Index ].mqdbColumnType = ##_ColName##_CTYPE ;        \
    UINT _ColIndex = _Index ;                                       \
    _Index++ ;

HRESULT MigrateEnterprise()
{
    HRESULT hr = OpenEntTable() ;
    CHECK_HR(hr) ;

    LONG cAlloc = 9 ;
    LONG cbColumns = 0 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

    INIT_ENT_COLUMN(E_NAME,         iEntNameIndex,   cbColumns) ;
    INIT_ENT_COLUMN(E_LONGLIVE,     iLongLiveIndex,  cbColumns) ;
    INIT_ENT_COLUMN(E_ID,           iEntIDIndex,     cbColumns) ;
    INIT_ENT_COLUMN(E_SECURITY,     iSecIndex,       cbColumns) ;
    INIT_ENT_COLUMN(E_NAMESTYLE,    iNameStyleIndex, cbColumns) ;
    INIT_ENT_COLUMN(E_CSP_NAME,     iCSPNameIndex,   cbColumns) ;
    INIT_ENT_COLUMN(E_VERSION,      iVersionIndex,   cbColumns) ;
    INIT_ENT_COLUMN(E_SINTERVAL1,   iInterval1Index, cbColumns) ;
    INIT_ENT_COLUMN(E_SINTERVAL2,   iInterval2Index, cbColumns) ;

    ASSERT(cbColumns == cAlloc) ;

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hEntTable,
                                       pColumns,
                                       cbColumns,
                                       NULL,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
							           TRUE ) ;
    CHECK_HR(status) ;

    ULONG uLongLived = (ULONG) pColumns[ iLongLiveIndex ].nColumnValue ;
    SECURITY_DESCRIPTOR *pEsd =
                (SECURITY_DESCRIPTOR*) pColumns[ iSecIndex ].nColumnValue ;

    LogMigrationEvent(MigLog_Info, MQMig_I_ENT_INFO,
                   (LPTSTR) pColumns[ iEntNameIndex ].nColumnValue,
                                                uLongLived, uLongLived) ;

    if (!g_fReadOnly)
    {
        hr = _CreateMSMQEnterprise(
                    uLongLived,                                        //LONG_LIVE
                    (GUID*) pColumns[ iEntIDIndex ].nColumnValue,      //ID
                    pEsd,                                              //SECURITY
                    (BYTE) pColumns[ iNameStyleIndex ].nColumnValue,   //NAME_STYLE
                    (LPTSTR) pColumns[ iCSPNameIndex ].nColumnValue,   //CSP_NAME
                    (USHORT) pColumns[ iVersionIndex ].nColumnValue,   //VERSION
                    (USHORT) pColumns[ iInterval1Index ].nColumnValue, //INTERVAL1
                    (USHORT) pColumns[ iInterval2Index ].nColumnValue  //INTERVAL2                    
                    ) ;
    }
    MQDBFreeBuf((void*) pColumns[ iEntNameIndex ].nColumnValue) ;
    MQDBFreeBuf((void*) pColumns[ iSecIndex ].nColumnValue) ;
    MQDBFreeBuf((void*) pColumns[ iEntIDIndex ].nColumnValue) ;
    MQDBFreeBuf((void*) pColumns[ iCSPNameIndex ].nColumnValue) ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\migcfgsd.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migcfgsd.cpp

Abstract:

    Set SecurityDescriptor of the cn=configuration object to let use
    "addGuid".

Author:

    Doron Juster  (DoronJ)  03-Feb-1998

--*/

#include "migrat.h"
#include <aclapi.h>
#include "..\..\mqsec\inc\permit.h"

#include "migcfgsd.tmh"

static  PACTRL_ACCESS        s_pCurrentAccessDomain = NULL;
static  PACTRL_ACCESS        s_pCurrentAccessCnfg   = NULL;

static BOOL s_fConfigurationSDChanged = FALSE ;

//+------------------------------------------
//
//  HRESULT _SetAddGuidPermission()
//
//+------------------------------------------

static  HRESULT _SetAddGuidPermission(BOOL fConfiguration)
{
    PLDAP pLdap = NULL ;
    TCHAR *wszPathDef = NULL ;

    HRESULT hr =  InitLDAP(&pLdap, &wszPathDef) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    TCHAR *wszPath = wszPathDef ;
    P<TCHAR> pPath = NULL ;

    if (fConfiguration)
    {
        DWORD dwSize = _tcslen(wszPathDef) + _tcslen(CN_CONFIGURATION) + 2 ;
        pPath = new WCHAR[ dwSize ] ;
        _tcscpy(pPath, CN_CONFIGURATION) ;
        _tcscat(pPath, wszPathDef) ;
        wszPath = pPath ;
    }

    WCHAR wszUser[ 512 ] ;
    DWORD dwSize = sizeof(wszUser) / sizeof(wszUser[0]) ;
    BOOL f = GetUserName(wszUser, &dwSize) ;

    DWORD dwLastErr ;
    if (!f)
    {
        hr = MQMig_E_CANT_GET_USER ;
        dwLastErr = GetLastError() ;
        LogMigrationEvent(MigLog_Error, hr, dwLastErr, dwLastErr) ;
        return hr ;
    }

    WCHAR *pwszProvider = NULL ; // L"Windows NT Access Provider",

    PACTRL_ACCESS         pAccess = NULL;
    SECURITY_INFORMATION  SeInfo = DACL_SECURITY_INFORMATION;

    PACTRL_ACCESS  pCurrentAccess ;
    DWORD dwErr = GetNamedSecurityInfoEx( wszPath,
                                          SE_DS_OBJECT_ALL,
                                          SeInfo,
                                          pwszProvider,
                                          NULL,
                                          &pCurrentAccess,
                                          NULL,
                                          NULL,
                                          NULL ) ;
    if (dwErr != ERROR_SUCCESS)
    {
        hr = MQMig_E_CANT_GET_SECURITYINFO ;
        dwLastErr = GetLastError() ;
        LogMigrationEvent(MigLog_Error, hr, dwErr, dwErr) ;
        return hr ;
    }

    if (fConfiguration)
    {
        s_pCurrentAccessCnfg = pCurrentAccess ;
    }
    else
    {
        s_pCurrentAccessDomain = pCurrentAccess ;
    }

    //
    // Add the right to set guid.
    //
    PWSTR  pwszControlGuids[] = {L"440820ad-65b4-11d1-a3da-0000f875ae0d"} ;

    ACTRL_ACCESS_ENTRY  AccessEntry;
    //
    // Build the entry
    //
    BuildTrusteeWithName(&(AccessEntry.Trustee),
                         wszUser) ;

    AccessEntry.Access             = RIGHT_DS_READ_PROPERTY  |
                                     RIGHT_DS_WRITE_PROPERTY |
                                     RIGHT_DS_CONTROL_ACCESS ;

    AccessEntry.fAccessFlags       = ACTRL_ACCESS_ALLOWED ;
    AccessEntry.Inheritance        = OBJECT_INHERIT_ACE ; //NO_INHERITANCE ;
    AccessEntry.lpInheritProperty  = NULL;
    AccessEntry.ProvSpecificAccess = 0;

    if (g_fReadOnly)
    {
        //
        ///  Query was ok. leave.
        //
        return MQMig_OK ;
    }

    dwErr = SetEntriesInAccessList(1,
                                   &AccessEntry,
                                   GRANT_ACCESS,
                                   pwszControlGuids[0],
                                   pCurrentAccess,
                                   &pAccess);
    if(dwErr != ERROR_SUCCESS)
    {
        hr = MQMig_E_CANT_SET_ENTRIES ;
        dwLastErr = GetLastError() ;
        LogMigrationEvent(MigLog_Error, hr, dwErr, dwErr) ;
        return hr ;
    }

    dwErr = SetNamedSecurityInfoEx( wszPath,
                                    SE_DS_OBJECT_ALL,
                                    SeInfo,
                                    pwszProvider,
                                    pAccess,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL);
    LocalFree(pAccess) ;
    if (dwErr != ERROR_SUCCESS)
    {
        hr = MQMig_E_CANT_SET_SECURITYINFO ;
        dwLastErr = GetLastError() ;
        LogMigrationEvent(MigLog_Error, hr, dwErr, dwErr) ;
        return hr ;
    }

    LogMigrationEvent(MigLog_Trace, MQMig_I_SET_PERMISSION, wszPath) ;
    s_fConfigurationSDChanged = TRUE ;
    return MQMig_OK ;
}

//+------------------------------------------
//
//  HRESULT GrantAddGuidPermissions()
//
//+------------------------------------------

HRESULT GrantAddGuidPermissions()
{
    HRESULT hr =  _SetAddGuidPermission(FALSE) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    hr =  _SetAddGuidPermission(TRUE) ;
    return hr ;
}

//+----------------------------------------------
//
// HRESULT _RestorePermissionsInternal()
//
//+----------------------------------------------

static HRESULT _RestorePermissionsInternal(BOOL fConfiguration)
{
    HRESULT hr = MQMig_OK ;

    PLDAP pLdap = NULL ;
    TCHAR *wszPathDef = NULL ;

    hr =  InitLDAP(&pLdap, &wszPathDef) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    TCHAR *wszPath = wszPathDef ;
    P<TCHAR> pPath = NULL ;

    if (fConfiguration)
    {
        DWORD dwSize = _tcslen(wszPathDef) + _tcslen(CN_CONFIGURATION) + 2 ;
        pPath = new WCHAR[ dwSize ] ;
        _tcscpy(pPath, CN_CONFIGURATION) ;
        _tcscat(pPath, wszPathDef) ;
        wszPath = pPath ;
    }

    WCHAR *pwszProvider = NULL ; // L"Windows NT Access Provider",
    SECURITY_INFORMATION  SeInfo = DACL_SECURITY_INFORMATION;

    PACTRL_ACCESS  pCurrentAccess ;
    if (fConfiguration)
    {
        pCurrentAccess = s_pCurrentAccessCnfg ;
    }
    else
    {
        pCurrentAccess = s_pCurrentAccessDomain ;
    }

    DWORD dwErr = SetNamedSecurityInfoEx( wszPath,
                                          SE_DS_OBJECT_ALL,
                                          SeInfo,
                                          pwszProvider,
                                          pCurrentAccess,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL);
    if (dwErr != ERROR_SUCCESS)
    {
        hr = MQMig_E_CANT_RSTR_SECURITYINFO ;
        DWORD dwLastErr = GetLastError() ;
        LogMigrationEvent(MigLog_Error, hr, wszPath, dwErr, dwErr) ;
        return hr ;
    }

    LogMigrationEvent(MigLog_Trace, MQMig_I_RESTORE_PERMISSION, wszPath) ;
    return hr ;
}

//+------------------------------------
//
//  HRESULT RestorePermissions()
//
//+------------------------------------

HRESULT RestorePermissions()
{
    if (!s_fConfigurationSDChanged)
    {
        return MQMig_OK ;
    }

    HRESULT hr = _RestorePermissionsInternal(FALSE) ;
    hr = _RestorePermissionsInternal(TRUE) ;

    //
    // Free memory.
    //
    if (s_pCurrentAccessDomain)
    {
        LocalFree(s_pCurrentAccessDomain) ;
        s_pCurrentAccessDomain = NULL ;
    }
    if (s_pCurrentAccessCnfg)
    {
        LocalFree(s_pCurrentAccessCnfg) ;
        s_pCurrentAccessCnfg = NULL ;
    }

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\migdebug.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migdebug.cpp

Abstract:

    Code for debugging the migration tool.
Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

#include "migrat.h"

#include "migdebug.tmh"

//+------------------------------------
//
//  UINT  ReadDebugIntFlag()
//
//+------------------------------------

UINT  ReadDebugIntFlag(WCHAR *pwcsDebugFlag, UINT iDefault)
{
    static BOOL   s_fInitialized = FALSE ;
    static TCHAR  s_szIniName[ MAX_PATH ] = L"";

    if (!s_fInitialized)
    {
        DWORD dw = GetModuleFileName(
        							NULL,
                                    s_szIniName,
                       				STRLEN(s_szIniName)
                       				) ;
        if (dw != 0)
        {
            TCHAR *p = _tcsrchr(s_szIniName, TEXT('\\')) ;
            if (p)
            {
                p++ ;
                _tcscpy(p, TEXT("migtool.ini")) ;
            }
        }
        s_fInitialized = TRUE ;
    }

    UINT uiDbg = GetPrivateProfileInt( TEXT("Debug"),
                                       pwcsDebugFlag,
                                       iDefault,
                                       s_szIniName ) ;
    return uiDbg ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\migcns.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migcns.cpp

Abstract:

    Migration NT4 CN objects to NT5 ADS.
Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

#include "migrat.h"
#include <_ta.h>

#include "migcns.tmh"

#define INIT_CNS_COLUMN(_ColName, _ColIndex, _Index)                \
    INIT_COLUMNVAL(pColumns[ _Index ]) ;                            \
    pColumns[ _Index ].lpszColumnName = ##_ColName##_COL ;          \
    pColumns[ _Index ].nColumnValue   = 0 ;                         \
    pColumns[ _Index ].nColumnLength  = 0 ;                         \
    pColumns[ _Index ].mqdbColumnType = ##_ColName##_CTYPE ;        \
    UINT _ColIndex = _Index ;                                       \
    _Index++ ;

//+----------------------------------------
//
//  HRESULT  GetMachineCNs()
//
//  Get all the CNs of a machine.
//
//+----------------------------------------

HRESULT  GetMachineCNs(IN  GUID   *pMachineGuid,
                       OUT DWORD  *pdwNumofCNs,
                       OUT GUID   **ppCNGuids )
{
    HRESULT hr = OpenMachineCNsTable() ;
    CHECK_HR(hr) ;

    //
    // First, get number of records we need to retrieve.
    //
    LONG cColumns = 0 ;
    MQDBCOLUMNSEARCH ColSearch[1] ;

    INIT_COLUMNSEARCH(ColSearch[ cColumns ]) ;
    ColSearch[ cColumns ].mqdbColumnVal.lpszColumnName = MCN_QMID_COL ;
    ColSearch[ cColumns ].mqdbColumnVal.mqdbColumnType = MCN_QMID_CTYPE ;
    ColSearch[ cColumns ].mqdbColumnVal.nColumnValue = (LONG) pMachineGuid ;
    ColSearch[ cColumns ].mqdbColumnVal.nColumnLength = sizeof(GUID) ;
    ColSearch[ cColumns ].mqdbOp = EQ ;
    cColumns++ ;

    hr = MQDBGetTableCount( g_hMachineCNsTable,
                            (UINT*) pdwNumofCNs,
                            ColSearch,
                            cColumns ) ;
    CHECK_HR(hr) ;
    if (*pdwNumofCNs == 0)
    {
        ASSERT(*pdwNumofCNs > 0) ;
        return MQMig_E_NO_FOREIGN_CNS ;
    }

    //
    // Next, fetch all these CNs.
    //
    GUID *pCNs = new GUID[ *pdwNumofCNs ] ;    
    *ppCNGuids = pCNs;

    cColumns = 0 ;
	LONG cAlloc = 1 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

	INIT_CNS_COLUMN(MCN_CNVAL,  iCNValIndex,	 cColumns) ;
    ASSERT(cColumns == cAlloc) ;

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hMachineCNsTable,
                                       pColumns,
                                       cColumns,
                                       ColSearch,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
							           TRUE ) ;
    CHECK_HR(status) ;

    UINT iIndex = 0 ;
    while(SUCCEEDED(status))
    {
        if (iIndex >= *pdwNumofCNs)
        {
            status = MQMig_E_TOO_MANY_MCNS ;
            break ;
        }

        memcpy( &pCNs[ iIndex ], 
                (void*) pColumns[ iCNValIndex ].nColumnValue,
                sizeof(GUID) ) ;

        for ( LONG i = 0 ; i < cColumns ; i++ )
        {
            MQDBFreeBuf((void*) pColumns[ i ].nColumnValue) ;
            pColumns[ i ].nColumnValue  = 0 ;
            pColumns[ i ].nColumnLength  = 0 ;
        }

        iIndex++ ;
        status = MQDBGetData( hQuery,
                              pColumns ) ;
    }

    MQDBSTATUS status1 = MQDBCloseQuery(hQuery) ;
    UNREFERENCED_PARAMETER(status1);

    hQuery = NULL ;

    if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_MCNS_SQL_FAIL, status) ;
        return status ;
    }
    else if (iIndex != *pdwNumofCNs)
    {
        //
        // Mismatch in number of CNs records.
        //
        hr = MQMig_E_FEWER_MCNS ;
        LogMigrationEvent(MigLog_Error, hr, iIndex, *pdwNumofCNs) ;
        return hr ;
    }
    return MQMig_OK ;
}

//-----------------------------------------
//
//  HRESULT _MigrateACN()
//
//-----------------------------------------

static HRESULT _MigrateACN (
			WCHAR   *wcsCNName,
			GUID    *pCNGuid,
			UINT	uiProtocolId,
			UINT    iIndex
			)
{
    DBG_USED(iIndex);
    static DWORD  s_dwForeignSiteNumber = 0  ;

    HRESULT hr = MQMig_OK ;
    BOOL  fForeign = FALSE ;
    unsigned short *lpszGuid ;

#ifdef _DEBUG
    UuidToString( pCNGuid, &lpszGuid ) ;
	
    LogMigrationEvent(MigLog_Info, MQMig_I_CN_INFO,
							iIndex,
                            wcsCNName,
							lpszGuid,
							uiProtocolId
							) ;

    RpcStringFree( &lpszGuid ) ;	
#endif

    if (g_fReadOnly)
    {
        //
        // Read-Only mode.
        //
        return MQMig_OK ;
    }

    TCHAR *pszFileName = GetIniFileName ();

    static ULONG s_ulIpCount = 0;
    static ULONG s_ulIpxCount = 0;
    static ULONG s_ulForeignCount = 0;

    UuidToString( pCNGuid, &lpszGuid ) ;

    TCHAR tszCNSectionName[50];
    TCHAR tszNumSectionName[50];
    ULONG ulCurNum;

    switch (uiProtocolId)
    {
        case IP_ADDRESS_TYPE:
		case IP_RAS_ADDRESS_TYPE:
			_tcscpy(tszCNSectionName, MIGRATION_IP_SECTION);
            _tcscpy(tszNumSectionName, MIGRATION_IP_CNNUM_SECTION);
			s_ulIpCount++;
            ulCurNum = s_ulIpCount;
			break;

		case IPX_ADDRESS_TYPE:
		case IPX_RAS_ADDRESS_TYPE:
			_tcscpy(tszCNSectionName, MIGRATION_IPX_SECTION);
            _tcscpy(tszNumSectionName, MIGRATION_IPX_CNNUM_SECTION);
			s_ulIpxCount++;
            ulCurNum = s_ulIpxCount;
			break;

		case FOREIGN_ADDRESS_TYPE:
            fForeign = TRUE ;
			_tcscpy(tszCNSectionName, MIGRATION_FOREIGN_SECTION);
            _tcscpy(tszNumSectionName, MIGRATION_FOREIGN_CNNUM_SECTION);
			s_ulForeignCount++;
            ulCurNum = s_ulForeignCount;
			break;

		default:
			ASSERT(0) ;
			return MQMig_E_CNS_SQL_FAIL;		
    }

    TCHAR tszKeyName[50];
    _stprintf(tszKeyName, TEXT("%s%lu"), MIGRATION_CN_KEY, ulCurNum);
    
    TCHAR szBuf[20];
    _ltot( ulCurNum, szBuf, 10 );
    BOOL f = WritePrivateProfileString( tszNumSectionName,
                                        MIGRATION_CNNUM_KEY,
                                        szBuf,
                                        pszFileName ) ;
    ASSERT(f) ;   

    if (!fForeign)
    {
        f = WritePrivateProfileString(  tszCNSectionName,
                                        tszKeyName,
                                        lpszGuid,
                                        pszFileName ) ;
        ASSERT(f) ;                 	
    }
    else
    {        
        //
        // if cn is foreign we save it in the form 
        // <guid>=CN<number> in order to improve searching by GUID
        //
        f = WritePrivateProfileString(  tszCNSectionName,
                                        lpszGuid,
                                        tszKeyName,                                        
                                        pszFileName ) ;
        ASSERT(f) ;        

        if (g_dwMyService == SERVICE_PEC)
        {
            //
            // Bug 5012.
            // Create foreign site only if this machine is PEC.
            //
            hr = CreateSite( pCNGuid, wcsCNName, TRUE ) ;
            if (SUCCEEDED(hr))
            {
                LogMigrationEvent( MigLog_Trace,
                                   MQMig_I_FOREIGN_SITE,
                                   wcsCNName ) ;
            }
            else
            {
                LogMigrationEvent( MigLog_Error,
                                   MQMig_E_FOREIGN_SITE,
                                   wcsCNName, hr ) ;
            }
        }
    }
    RpcStringFree( &lpszGuid ) ;

    return hr ;
}

//-------------------------------------------
//
//  HRESULT MigrateCNs()
//
//  CNs are not really migrated. What we're doing is to record all CNs
//  in the ini file. that is needed for replication of machine objects from
//  NT5 to NT4. Because we don't keep CN data in the Nt5 DS, we assign
//  all CNs to each machine address when replicating the machine to NT4
//  world. That may make routing on the nt4 side less efficient.
//  As a side effect, when encounting a foreign CN, we create a foreign
//  site which has its GUID.
//
//-------------------------------------------

HRESULT MigrateCNs()
{
    HRESULT hr = OpenCNsTable() ;
    CHECK_HR(hr) ;

    ULONG cColumns = 0 ;
	ULONG cAlloc = 3 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

	INIT_CNS_COLUMN(CN_NAME,		iNameIndex,		cColumns) ;
	INIT_CNS_COLUMN(CN_VAL,			iGuidIndex,		cColumns) ;
	INIT_CNS_COLUMN(CN_PROTOCOLID,	iProtocolIndex, cColumns);
	
    ASSERT(cColumns == cAlloc);

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hCNsTable,
                                       pColumns,
                                       cColumns,
                                       NULL,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
							           TRUE ) ;
	if (status == MQDB_E_NO_MORE_DATA)
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_NO_CNS) ;
        return MQMig_E_NO_CNS ;
    }
    CHECK_HR(status) ;

    UINT iIndex = 0 ;

    while(SUCCEEDED(status))
    {
        //
        // Migrate each CN
		//
		status = _MigrateACN (
					(WCHAR *) pColumns[ iNameIndex ].nColumnValue,		//cn name
					(GUID *) pColumns[ iGuidIndex ].nColumnValue,		//cn guid						
					(UINT) pColumns[ iProtocolIndex ].nColumnValue,
					iIndex
					);

        for ( ULONG i = 0 ; i < cColumns; i++ )
        {		
			if (i != iProtocolIndex)
			{
				MQDBFreeBuf((void*) pColumns[ i ].nColumnValue) ;
			}
            pColumns[ i ].nColumnValue  = 0 ;
            pColumns[ i ].nColumnLength  = 0 ;
        }
		CHECK_HR(status) ;

        iIndex++ ;
        status = MQDBGetData( hQuery,
                              pColumns ) ;
    }

    MQDBSTATUS status1 = MQDBCloseQuery(hQuery) ;
    UNREFERENCED_PARAMETER(status1);

    hQuery = NULL ;

    if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_CNS_SQL_FAIL, status) ;
        return status ;
    }

    return MQMig_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\miggates.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    miggates.cpp

Abstract:

    Migration NT4 SiteGate objects to NT5 ADS.
Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

#include "migrat.h"

#include "miggates.tmh"

//+--------------------------------------------------------------
//
//  HRESULT  LookupBegin()
//
//+--------------------------------------------------------------

HRESULT  LookupBegin( MQCOLUMNSET *pColumnSet,
                      HANDLE      *phQuery )
{
	if (g_fReadOnly)
    {
        //
        // Read only mode.
        //
        return S_OK ;
    }
    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);  // not relevant

	HRESULT hr = DSCoreLookupBegin( NULL,
                                    NULL,
                                    pColumnSet,
                                    NULL,
                                    &requestContext,
                                    phQuery ) ;
	return hr;
}

//+--------------------------------------------------------------
//
//  HRESULT  LookupNext()
//
//+--------------------------------------------------------------

HRESULT LookupNext( HANDLE       hQuery,
                    DWORD       *pdwCount,
                    PROPVARIANT  paVariant[] )
{
	if (g_fReadOnly)
    {
        //
        // Read only mode.
        //
        return S_OK ;
    }   

	HRESULT hr = DSCoreLookupNext ( hQuery,
	                				pdwCount,
                					paVariant ) ;
	return hr;
}

//+--------------------------------------------------------------
//
//  HRESULT  LookupEnd()
//
//+--------------------------------------------------------------

HRESULT LookupEnd(HANDLE hQuery)
{
	if (g_fReadOnly)
    {
        //
        // Read only mode.
        //
        return S_OK ;
    }

	HRESULT hr = DSCoreLookupEnd ( hQuery );			
	return hr;
}

//+--------------------------------------------------------------
//
//  HRESULT  GetFullPathNameByGuid()
//
//+--------------------------------------------------------------

HRESULT GetFullPathNameByGuid ( GUID   MachineId,
                                LPWSTR *lpwcsFullPathName )
{	
	PROPID propID = PROPID_QM_FULL_PATH;
    PROPVARIANT propVariant;

    propVariant.vt = VT_NULL;
	
    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);

	HRESULT hr = DSCoreGetProps( MQDS_MACHINE,
                                 NULL, //pathname
	            				 &MachineId,
                                 1,
            					 &propID,
                                 &requestContext,
			            		 &propVariant ) ;
	if (SUCCEEDED(hr))
	{
		*lpwcsFullPathName = propVariant.pwszVal;
	}

	return hr;
}

//+--------------------------------------------------------------
//
//  HRESULT  _AddSiteGatesToSiteLink()
//
//+--------------------------------------------------------------

static HRESULT  _AddSiteGatesToSiteLink (
			GUID *pLinkId,				//link id
			ULONG ulNumOfOldSiteGates,	//number of current site gates
			LPWSTR *lpwcsOldGates,		//current site gates
			ULONG ulNumOfNewGates,		//number of new site gates
			LPWSTR *lpwcsNewSiteGates	//new site gates
			)
{	
	ASSERT( ulNumOfNewGates != 0);

	PROPID propID = PROPID_L_GATES_DN;
    PROPVARIANT propVariant;
	
	propVariant.vt = VT_LPWSTR | VT_VECTOR;
	propVariant.calpwstr.cElems = ulNumOfOldSiteGates + ulNumOfNewGates;
	propVariant.calpwstr.pElems = new LPWSTR[propVariant.calpwstr.cElems];

	ULONG i;
	if (ulNumOfOldSiteGates > 0)
	{
		for (	i=0; i<ulNumOfOldSiteGates; i++)
		{
			propVariant.calpwstr.pElems[i] = new WCHAR [wcslen(lpwcsOldGates[i]) + 1];
			wcscpy (propVariant.calpwstr.pElems[i], lpwcsOldGates[i]);
		}
	}
	
	for (i=0; i<ulNumOfNewGates; i++)
	{
		propVariant.calpwstr.pElems[i + ulNumOfOldSiteGates] =
									new WCHAR [wcslen(lpwcsNewSiteGates[i]) + 1];
		wcscpy (propVariant.calpwstr.pElems[i + ulNumOfOldSiteGates], lpwcsNewSiteGates[i]);
	}
	
    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);  // not relevant

	HRESULT hr = DSCoreSetObjectProperties( MQDS_SITELINK,
                                            NULL, // pathname
					                    	pLinkId,
                    						1,
					                       &propID,
                                           &propVariant,
                                           &requestContext,
                                            NULL ) ;
	delete [] propVariant.calpwstr.pElems;

	if (hr == HRESULT_FROM_WIN32(ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS))
    {
        return MQMig_OK ;
    }

	return hr ;
}

//-------------------------------------------------------------------------
//
//  HRESULT  _CopySiteGatesValueToMig()
//
//  Copy the MSMQ SiteGates in the SiteLink object to the "mig" attributes.
//  These attributes mirror the  "normal" msmq attributes in the SiteLink
//  object and are used in the replication service, to enable replication
//  of changes to MSMQ1.0.
//
//-------------------------------------------------------------------------

HRESULT _CopySiteGatesValueToMig()
{
    HRESULT hr = MQMig_OK;

    PLDAP pLdap = NULL ;
    TCHAR *pszDefName = NULL ;

    hr =  InitLDAP(&pLdap, &pszDefName) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    TCHAR *pszSchemaDefName = NULL ;
    hr = GetSchemaNamingContext ( pLdap, &pszSchemaDefName ) ;
    if (FAILED(hr))
    {
        return hr;
    }

    DWORD dwDNSize = SITE_LINK_ROOT_LEN + wcslen(pszDefName) ;
    P<WCHAR> pwszDN = new WCHAR[ 1 + dwDNSize ] ;
    swprintf(pwszDN, L"%s%s", SITE_LINK_ROOT, pszDefName);

    TCHAR *pszCategoryName = const_cast<LPTSTR> (x_LinkCategoryName);
    
    TCHAR wszFullName[256];    
    _stprintf(wszFullName, TEXT("%s,%s"), pszCategoryName, pszSchemaDefName);

     TCHAR  wszFilter[ 512 ] ;    
    _tcscpy(wszFilter, TEXT("(&(objectCategory=")) ;    
    _tcscat(wszFilter, wszFullName);

    _tcscat(wszFilter, TEXT(")(")) ;
    _tcscat(wszFilter, MQ_L_SITEGATES_ATTRIBUTE) ;
    _tcscat(wszFilter, TEXT("=*))")) ;

    PWSTR rgAttribs[3] = {NULL, NULL, NULL} ;
    rgAttribs[0] = const_cast<LPWSTR> (MQ_L_SITEGATES_ATTRIBUTE);
    rgAttribs[1] = const_cast<LPWSTR> (MQ_L_FULL_PATH_ATTRIBUTE);

    LM<LDAPMessage> pRes = NULL ;
    ULONG ulRes = ldap_search_s( pLdap,
                                 pwszDN,
                                 LDAP_SCOPE_SUBTREE,
                                 wszFilter,
                                 rgAttribs, //ppAttributes,
                                 0,
                                 &pRes ) ;

    if (ulRes != LDAP_SUCCESS)
    {
        LogMigrationEvent( MigLog_Error,
                           MQMig_E_LDAP_SEARCH_FAILED,
                           pwszDN, wszFilter, ulRes) ;
        return MQMig_E_LDAP_SEARCH_FAILED ;
    }
    ASSERT(pRes) ;

    LogMigrationEvent( MigLog_Info,
                       MQMig_I_LDAP_SEARCH_GATES,
                       pwszDN, wszFilter );

    int iCount = ldap_count_entries(pLdap, pRes) ;

    if (iCount == 0)
    {
        LogMigrationEvent(MigLog_Info, MQMig_I_NO_SITEGATES_RESULTS,
                            pwszDN,wszFilter );
        return MQMig_OK ;
    }

    LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
    while(pEntry && SUCCEEDED(hr))
    {
        WCHAR **ppPath = ldap_get_values( pLdap,
                                          pEntry,
                        const_cast<LPWSTR> (MQ_L_FULL_PATH_ATTRIBUTE) ) ;
        ASSERT(ppPath) ;

        PLDAP_BERVAL *ppVal = ldap_get_values_len( pLdap,
                                                   pEntry,
                       const_cast<LPWSTR> (MQ_L_SITEGATES_ATTRIBUTE) ) ;
        ASSERT(ppVal) ;
        if (ppVal && ppPath)
        {
            hr = ModifyAttribute(
                     *ppPath,
                     const_cast<WCHAR*> (MQ_L_SITEGATES_MIG_ATTRIBUTE),
                     NULL,
                     ppVal
                     );
        }
        int i = ldap_value_free_len( ppVal ) ;
        ASSERT(i == LDAP_SUCCESS) ;

        i = ldap_value_free( ppPath ) ;
        ASSERT(i == LDAP_SUCCESS) ;

        LDAPMessage *pPrevEntry = pEntry ;
        pEntry = ldap_next_entry(pLdap, pPrevEntry) ;
    }

    return hr;   
}

//+--------------------------------------
//
//  HRESULT MigrateASiteGate()
//
//+--------------------------------------

HRESULT MigrateASiteGate (
			GUID *pSiteId,	
			GUID *pGatesIds,
			LONG NumOfGates
			)
{
	LONG i;

#ifdef _DEBUG
    unsigned short *lpszGuid ;
	P<TCHAR> lpszAllSiteGates = new TCHAR[40 * NumOfGates];
    lpszAllSiteGates[0] = _T('\0');

	UuidToString( pSiteId, &lpszGuid ) ;
	GUID *pCurGateGuid = pGatesIds;
	for ( i = 0 ; i < NumOfGates ; i++ )
	{
		unsigned short *lpszCurGate;
		UuidToString( pCurGateGuid, &lpszCurGate ) ;
		_tcscat(lpszAllSiteGates, lpszCurGate);
		_tcscat(lpszAllSiteGates, TEXT(" ")) ;
		RpcStringFree( &lpszCurGate );
		pCurGateGuid++;
	}

    LogMigrationEvent(MigLog_Info, MQMig_I_SITEGATES_INFO,
                                lpszGuid, NumOfGates, lpszAllSiteGates ) ;
    RpcStringFree( &lpszGuid ) ;
#endif

    if (g_fReadOnly)
    {
        //
        // Read only mode.
        //
        return S_OK ;
    }

	HRESULT status;
	
	//
	// Create array of site gates' full path name
	//
	LPWSTR *lpwcsSiteGates = new LPWSTR[ NumOfGates ];
	LPWSTR lpwcsCurSiteGate;
	
	for ( i = 0 ; i < NumOfGates ; i++ )
	{
		//
		// get full machine path name by guid
		//
		lpwcsCurSiteGate = NULL;
		status = GetFullPathNameByGuid(pGatesIds[i], &lpwcsCurSiteGate) ;
		CHECK_HR(status) ;
		lpwcsSiteGates[i] = new WCHAR[wcslen(lpwcsCurSiteGate)+1];
		wcscpy (lpwcsSiteGates[i], lpwcsCurSiteGate);
		delete lpwcsCurSiteGate;

#ifdef _DEBUG
        unsigned short *lpszGuid ;
        UuidToString( &pGatesIds[i], &lpszGuid ) ;
        LogMigrationEvent(MigLog_Info, MQMig_I_SITEGATE_INFO,
                                            lpszGuid, lpwcsSiteGates[i]) ;
		RpcStringFree( &lpszGuid ) ;
#endif
	}
	
	//
    // Lookup the Neighbors Id and Gates of the object Site Link
    //
	LONG cAlloc = 4;
	P<PROPID> columnsetPropertyIDs  = new PROPID[ cAlloc ];
	columnsetPropertyIDs[0] = PROPID_L_NEIGHBOR1;
	columnsetPropertyIDs[1] = PROPID_L_NEIGHBOR2;
	columnsetPropertyIDs[2] = PROPID_L_GATES_DN;
	columnsetPropertyIDs[3] = PROPID_L_ID;

    MQCOLUMNSET columnsetSiteLink;
    columnsetSiteLink.cCol = cAlloc;
    columnsetSiteLink.aCol = columnsetPropertyIDs;

    HANDLE hQuery;
    DWORD dwCount = cAlloc;
	
	status = LookupBegin(&columnsetSiteLink, &hQuery);
	CHECK_HR(status) ;	
	
	P<PROPVARIANT> paVariant = new PROPVARIANT[ cAlloc ];

	while (SUCCEEDED(status))
    {
		status = LookupNext( hQuery,
		                     &dwCount,
                              paVariant ) ;
		CHECK_HR(status) ;
		if (dwCount == 0)
		{
			//there is no result
			break;
		}
	
		if (memcmp (pSiteId, paVariant[0].puuid, sizeof(GUID)) == 0 ||
			memcmp (pSiteId, paVariant[1].puuid, sizeof(GUID)) == 0)
		{
			//
			// add site gates to that site link
			//
			status = _AddSiteGatesToSiteLink (
							paVariant[3].puuid,				//link id
							paVariant[2].calpwstr.cElems,	//number of current site gates
							paVariant[2].calpwstr.pElems,	//current site gates
							NumOfGates,						//number of new site gates
							lpwcsSiteGates					//new site gates
							);
			delete [] paVariant[2].calpwstr.pElems;
			delete paVariant[3].puuid;
			CHECK_HR(status) ;
		}
    }

	delete [] lpwcsSiteGates;

	HRESULT status1 = LookupEnd( hQuery ) ;
    UNREFERENCED_PARAMETER(status1);
	
    return MQMig_OK ;
}

//-----------------------------------------
//
//  HRESULT MigrateSiteGates()
//
//-----------------------------------------

HRESULT MigrateSiteGates()
{
	LONG cAlloc = 2 ;
    LONG cColumns = 0 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

    INIT_COLUMNVAL(pColumns[ cColumns ]) ;
    pColumns[ cColumns ].lpszColumnName = S_ID_COL ;
    pColumns[ cColumns ].nColumnValue   = 0 ;
    pColumns[ cColumns ].nColumnLength  = 0 ;
    pColumns[ cColumns ].mqdbColumnType = S_ID_CTYPE ;
    UINT iGuidIndex = cColumns ;
    cColumns++ ;

	INIT_COLUMNVAL(pColumns[ cColumns ]) ;
    pColumns[ cColumns ].lpszColumnName = S_GATES_COL ;
    pColumns[ cColumns ].nColumnValue   = 0 ;
    pColumns[ cColumns ].nColumnLength  = 0 ;
    pColumns[ cColumns ].mqdbColumnType = S_GATES_CTYPE ;
    UINT iGatesIndex = cColumns ;
    cColumns++ ;

    ASSERT(cColumns == cAlloc) ;
	
	CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hSiteTable,
                                       pColumns,
                                       cColumns,
                                       NULL,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
							           TRUE ) ;

    CHECK_HR(status) ;

    UINT iIndex = 0 ;
	MQDBSTATUS status1 = MQMig_OK;

    while(SUCCEEDED(status))
    {
		WORD  wSize = *((WORD *) pColumns[ iGatesIndex ].nColumnValue ) ;

		if (wSize != 0)
		{
			//
			// site has site gates
			//
			ASSERT ((ULONG)pColumns[ iGatesIndex ].nColumnLength == wSize * sizeof(GUID) + sizeof(WORD));
			WORD *tmp = (WORD *) pColumns[ iGatesIndex ].nColumnValue;
			GUID *ptrGatesGuid = (GUID *)(++tmp);

			status1 = MigrateASiteGate (
						(GUID *) pColumns[ iGuidIndex ].nColumnValue,	//site id
						ptrGatesGuid,									//gates id
						wSize											//number of gates
						);
		}

        for ( LONG i = 0 ; i < cColumns ; i++ )
        {
            MQDBFreeBuf((void*) pColumns[ i ].nColumnValue) ;
            pColumns[ i ].nColumnValue  = 0 ;
            pColumns[ i ].nColumnLength  = 0 ;
        }

		CHECK_HR(status1) ;

		iIndex++ ;
        status = MQDBGetData( hQuery,
                              pColumns ) ;
    }
	
	if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_SITEGATES_SQL_FAIL, status) ;
        return status ;
    }

    if (g_fReadOnly)
    {
        return MQMig_OK ;
    }

    //
    // copy msmqSiteGates to msmqSiteGatesMig
    //
    HRESULT hr = _CopySiteGatesValueToMig();
	
    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\migldap.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migldap.cpp

Abstract:

    Interface with LDAP.

Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

#include "migrat.h"
#include "..\..\ds\h\dsldap.h"

#include "migldap.tmh"

static P<TCHAR> s_tszDefaultName = NULL ;
static P<TCHAR> s_tszSchemaNamingContext = NULL ;

//
// Defaults for replacing site name if original name is not compatible
// with dns (rfc 1035).
//
#define  DEFAULT_SITE_NAME_PREFIX   (TEXT("msmqSite"))
#define  DEFAULT_SITE_NAME_LEN      (_tcslen(DEFAULT_SITE_NAME_PREFIX))

//
// Defaults name for foreign sites. These one replace the foreign CNs
// in MSMQ1.0
//
#define  DEFAULT_FOREIGN_SITE_NAME_PREFIX   (TEXT("msmqForeignSite"))
#define  DEFAULT_FOREIGN_SITE_NAME_LEN      (_tcslen(DEFAULT_FOREIGN_SITE_NAME_PREFIX))

//+----------------------------------------------
//
//   HRESULT  GetSchemaNamingContext()
//
//+----------------------------------------------
HRESULT  GetSchemaNamingContext ( PLDAP pLdap,
                                  TCHAR **ppszSchemaDefName )
{
    static BOOL s_fAlreadyInit = FALSE ;

    if (s_fAlreadyInit)
    {
        *ppszSchemaDefName = s_tszSchemaNamingContext ;

        return MQMig_OK ;
    }

    HRESULT hr = MQMig_OK ;

    LM<LDAPMessage> pRes = NULL ;

    ULONG ulRes = ldap_search_s( pLdap,
                                 NULL,
                                 LDAP_SCOPE_BASE,
                                 L"(objectClass=*)",
                                 NULL,
                                 0,
                                 &pRes ) ;

    if (ulRes != LDAP_SUCCESS)
    {
        hr =  MQMig_E_CANT_QUERY_ROOTDSE ;
        LogMigrationEvent(MigLog_Error, hr, ulRes) ;
        return hr ;
    }
    ASSERT(pRes) ;

    int iCount = ldap_count_entries(pLdap, pRes) ;
    LogMigrationEvent(MigLog_Info, MQMig_I_ROOTDSE_SUCCESS, iCount) ;

    if (iCount == 1)
    {
        LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
        WCHAR **ppValue = ldap_get_values( pLdap,
                                           pEntry,
                                           TEXT("schemaNamingContext")) ;
        if (ppValue && *ppValue)
        {
            ASSERT(s_tszSchemaNamingContext == NULL) ;
            s_tszSchemaNamingContext = new TCHAR[ 1 + _tcslen(*ppValue) ] ;
            _tcscpy(s_tszSchemaNamingContext, *ppValue) ;
            ldap_value_free(ppValue) ;

            LogMigrationEvent(MigLog_Info, MQMig_I_NAME_CONTEXT,
                                                         s_tszSchemaNamingContext) ;
        }
        else
        {
            return MQMig_E_CANT_READ_CONTEXT ;
        }
    }
    else
    {
        return MQMig_E_TOOMANY_ROOTDSE ;
    }

    *ppszSchemaDefName = s_tszSchemaNamingContext ;
    s_fAlreadyInit = TRUE;

    return MQMig_OK ;
}

//+----------------------------------------------
//
//   HRESULT  _GetDefaultNamingContext()
//
//+----------------------------------------------

static HRESULT  _GetDefaultNamingContext( PLDAP pLdap,
                                          TCHAR **ppszDefName )
{
    HRESULT hr = MQMig_OK ;
    LM<LDAPMessage> pRes = NULL ;

    ULONG ulRes = ldap_search_s( pLdap,
                                 NULL,
                                 LDAP_SCOPE_BASE,
                                 L"(objectClass=*)",
                                 NULL,
                                 0,
                                 &pRes ) ;

    if (ulRes != LDAP_SUCCESS)
    {
        hr =  MQMig_E_CANT_QUERY_ROOTDSE ;
        LogMigrationEvent(MigLog_Error, hr, ulRes) ;
        return hr ;
    }
    ASSERT(pRes) ;

    int iCount = ldap_count_entries(pLdap, pRes) ;
    LogMigrationEvent(MigLog_Info, MQMig_I_ROOTDSE_SUCCESS, iCount) ;

    if (iCount == 1)
    {
        LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
        WCHAR **ppValue = ldap_get_values( pLdap,
                                           pEntry,
                                           TEXT("defaultNamingContext")) ;
        if (ppValue && *ppValue)
        {
            ASSERT(*ppszDefName == NULL) ;
            *ppszDefName = new TCHAR[ 1 + _tcslen(*ppValue) ] ;
            _tcscpy(*ppszDefName, *ppValue) ;
            ldap_value_free(ppValue) ;

            LogMigrationEvent(MigLog_Info, MQMig_I_NAME_CONTEXT,
                                                         *ppszDefName) ;
        }
        else
        {
            return MQMig_E_CANT_READ_CONTEXT ;
        }
    }
    else
    {
        return MQMig_E_TOOMANY_ROOTDSE ;
    }

    return MQMig_OK ;
}

//+----------------------------------------------
//
//   HRESULT  InitLDAP() ;
//
//+----------------------------------------------

HRESULT
InitLDAP(
	PLDAP *ppLdap,
	TCHAR **ppwszDefName,
	ULONG ulPort
	)
{
    static PLDAP s_pLdap = NULL;
    static PLDAP s_pLdapGC = NULL;

    static BOOL s_fAlreadyInit = FALSE;
    static BOOL s_fAlreadyInitGC = FALSE;

    if (ulPort == LDAP_PORT && s_fAlreadyInit)
    {
        *ppLdap = s_pLdap;
        *ppwszDefName = s_tszDefaultName;

        return MQMig_OK;
    }

    if (ulPort == LDAP_GC_PORT && s_fAlreadyInitGC)
    {
        *ppLdap = s_pLdapGC;
        *ppwszDefName = s_tszDefaultName;

        return MQMig_OK;
    }

    WCHAR wszComputerName[MAX_COMPUTERNAME_LENGTH + 2];
    DWORD dwSize = sizeof(wszComputerName) / sizeof(wszComputerName[0]);
    GetComputerName(
		wszComputerName,
		&dwSize
		);

    PLDAP pLdap = NULL;
    if (ulPort == LDAP_PORT)
    {
        pLdap = ldap_init(wszComputerName, LDAP_PORT);
    }
    else
    {
        pLdap = ldap_init(wszComputerName, LDAP_GC_PORT);
    }

    if (!pLdap)
    {
        return MQMig_E_CANT_INIT_LDAP;
    }

    int iLdapVersion;
    int iret = ldap_get_option(
					pLdap,
					LDAP_OPT_PROTOCOL_VERSION,
					(void*) &iLdapVersion
					);
    if (iLdapVersion != LDAP_VERSION3)
    {
        iLdapVersion = LDAP_VERSION3;
        iret = ldap_set_option(
					pLdap,
					LDAP_OPT_PROTOCOL_VERSION,
					(void*) &iLdapVersion
					);
    }

    iret = ldap_set_option(
				pLdap,
				LDAP_OPT_AREC_EXCLUSIVE,
				LDAP_OPT_ON
				);

    ULONG ulRes = ldap_bind_s(pLdap, L"", NULL, LDAP_AUTH_NEGOTIATE);
    LogMigrationEvent(MigLog_Info, MQMig_I_LDAP_INIT,
                             wszComputerName, pLdap->ld_version, ulRes);

    if (ulRes != LDAP_SUCCESS)
    {
        return MQMig_E_CANT_BIND_LDAP;
    }

    if (s_tszDefaultName == NULL)
    {
        HRESULT hr =  _GetDefaultNamingContext(
							pLdap,
							&s_tszDefaultName
							);
        if (FAILED(hr))
        {
            return hr;
        }
    }

    *ppLdap = pLdap;
    *ppwszDefName = s_tszDefaultName;

    if (ulPort == LDAP_PORT)
    {
        s_fAlreadyInit = TRUE;
        s_pLdap = pLdap;
    }
    else
    {
        s_fAlreadyInitGC = TRUE;
        s_pLdapGC = pLdap;
    }
    return MQMig_OK;
}

//+----------------------------------------------
//
//  HRESULT CreateSite()
//
//+----------------------------------------------

HRESULT CreateSite( GUID   *pSiteGuid,
                    LPTSTR  pszSiteNameIn,
                    BOOL    fForeign,
                    USHORT  uiInterval1,
                    USHORT  uiInterval2)
{
    PLDAP pLdap = NULL ;
    WCHAR *pwszDefName = NULL ;

    HRESULT hr =  InitLDAP(&pLdap, &pwszDefName) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    P<TCHAR>  pszBuf = NULL ;
    LPTSTR  pszSiteName = NULL ;
    static  DWORD  s_dwSiteNumber = 0 ;
    static  DWORD  s_dwForeignSiteNumber = 0 ;

    BOOL fOk = IsObjectNameValid(pszSiteNameIn);

    if (g_fReadOnly)
    {
        return MQMig_OK ;
    }

    if (fOk)
    {
        pszSiteName = pszSiteNameIn ;
    }
    else
    {
        //
        // an illegal character was found. Replace site name with an
        // internal name.
        //
        if (fForeign)
        {
            s_dwForeignSiteNumber++ ;
            pszBuf = new TCHAR[ DEFAULT_FOREIGN_SITE_NAME_LEN + 20 ] ;
            _stprintf(pszBuf, TEXT("%s%lu"),
                  DEFAULT_FOREIGN_SITE_NAME_PREFIX, s_dwForeignSiteNumber) ;
        }
        else
        {
            s_dwSiteNumber++ ;
            pszBuf = new TCHAR[ DEFAULT_SITE_NAME_LEN + 20 ] ;
            _stprintf(pszBuf, TEXT("%s%lu"),
                                DEFAULT_SITE_NAME_PREFIX, s_dwSiteNumber) ;
        }
        pszSiteName = pszBuf ;

        LogMigrationEvent( MigLog_Event,
                           MQMig_I_SITE_NAME_CHANGED,
                           pszSiteNameIn,
                           pszSiteName ) ;
        //
        // BUG 5211.
        // Save new name in mqseqnum.ini to replicate it later.
        //
        TCHAR *pszFileName = GetIniFileName ();
        //
        // save number of all sites with changed name in .ini
        //
        TCHAR szBuf[10];
        _ltot( s_dwForeignSiteNumber + s_dwSiteNumber, szBuf, 10 );
        BOOL f = WritePrivateProfileString( MIGRATION_CHANGED_NT4SITE_NUM_SECTION,
                                            MIGRATION_CHANGED_NT4SITE_NUM_KEY,
                                            szBuf,
                                            pszFileName ) ;
        ASSERT(f) ;

        //
        // save new site name
        //
        TCHAR tszKeyName[50];
        _stprintf(tszKeyName, TEXT("%s%lu"),
			MIGRATION_CHANGED_NT4SITE_KEY, s_dwForeignSiteNumber + s_dwSiteNumber);

        unsigned short *lpszSiteId ;	
        UuidToString( pSiteGuid, &lpszSiteId ) ;
        f = WritePrivateProfileString(
                                MIGRATION_CHANGED_NT4SITE_SECTION,
                                tszKeyName,
                                lpszSiteId,
                                pszFileName ) ;
        RpcStringFree( &lpszSiteId ) ;
        ASSERT(f);

    }

    #define PATH_LEN  1024
    WCHAR  wszPath[ PATH_LEN ] ;

    wcscpy(wszPath, CN_PREFIX) ;
    wcscat(wszPath, pszSiteName) ;
    wcscat(wszPath, LDAP_COMMA) ;
    wcscat(wszPath, SITES_ROOT) ;
    wcscat(wszPath, pwszDefName) ;

    ASSERT(wcslen(wszPath) < PATH_LEN) ;

    #define         cAlloc  8
    PLDAPMod        rgMods[ cAlloc ];
    WCHAR           *ppwszObjectClassVals[2];
    WCHAR           *ppwszCnVals[2];
    WCHAR           *ppwszStubVals[2];
    WCHAR           *ppwszForeignVals[2];
    WCHAR           *ppwszInterval1Vals[2];
    WCHAR           *ppwszInterval2Vals[2];
    PLDAP_BERVAL    pBValsGuid[2];
    LDAP_BERVAL     BValGuid;
    LDAPMod         ModObjectClass;
    LDAPMod         ModCn;
    LDAPMod         ModGuid;
    LDAPMod         ModStub;
    LDAPMod         ModForeign;
    LDAPMod         ModInterval1;
    LDAPMod         ModInterval2;

    DWORD  dwIndex = 0 ;
    rgMods[ dwIndex ] = &ModCn;
    dwIndex++ ;
    rgMods[ dwIndex ] = &ModObjectClass;
    dwIndex++ ;
    rgMods[ dwIndex ] = &ModStub;
    dwIndex++ ;
    rgMods[ dwIndex ] = &ModInterval1;
    dwIndex++ ;
    rgMods[ dwIndex ] = &ModInterval2;
    //
    // For debug, always keep the guid the last in the list.
    //
    dwIndex++ ;
    rgMods[ dwIndex ] = &ModGuid;
    dwIndex++ ;
    rgMods[ dwIndex ] = NULL ;
    dwIndex++ ;
    ASSERT(dwIndex == (cAlloc-1)) ;

    //
    // objectClass
    //
    ppwszObjectClassVals[0] = TEXT("Site") ;
    ppwszObjectClassVals[1] = NULL ;

    ModObjectClass.mod_op      = LDAP_MOD_ADD ;
    ModObjectClass.mod_type    = L"objectClass" ;
    ModObjectClass.mod_values  = (PWSTR *) ppwszObjectClassVals ;

    //
    // Cn (site name)
    //
    ppwszCnVals[0] = pszSiteName ;
    ppwszCnVals[1] = NULL ;

    ModCn.mod_op      = LDAP_MOD_ADD ;
    ModCn.mod_type    = const_cast<WCHAR*> (MQ_S_NAME_ATTRIBUTE) ;
    ModCn.mod_values  = (PWSTR *) ppwszCnVals ;

    //
    // objectGUID
    //
    pBValsGuid[0] = &BValGuid;
    pBValsGuid[1] = NULL;

    BValGuid.bv_len = sizeof(GUID) ;
    BValGuid.bv_val = (PCHAR) pSiteGuid ;

    ModGuid.mod_op      = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
    ModGuid.mod_type    = const_cast<WCHAR*> (MQ_S_ID_ATTRIBUTE) ;
    ModGuid.mod_values  = (PWSTR *)pBValsGuid;

	//
	// Migration will always set the migrated object mSMQNt4Stub = false
	// There is no mixed mode, all object migrated to AD are not NT4 objects anymore.
	//
    WCHAR wszStub[ 24 ] ;
    _stprintf(wszStub, TEXT("0")) ;

    ppwszStubVals[0] = wszStub ;
    ppwszStubVals[1] = NULL ;

    ModStub.mod_op      = LDAP_MOD_ADD ;
    ModStub.mod_type    = const_cast<WCHAR*> (MQ_S_NT4_STUB_ATTRIBUTE) ;
    ModStub.mod_values  = (PWSTR *) ppwszStubVals ;

    //
    // interval1
    //
    WCHAR wszInterval1[ 24 ];
    _ltow( uiInterval1, wszInterval1, 10 );

    ppwszInterval1Vals[0] = wszInterval1 ;
    ppwszInterval1Vals[1] = NULL ;

    ModInterval1.mod_op      = LDAP_MOD_ADD ;
    ModInterval1.mod_type    = const_cast<WCHAR*> (MQ_S_INTERVAL1) ;
    ModInterval1.mod_values  = (PWSTR *) ppwszInterval1Vals ;

    //
    // interval2
    //
    WCHAR wszInterval2[ 24 ];
    _ltow( uiInterval2, wszInterval2, 10 );

    ppwszInterval2Vals[0] = wszInterval2 ;
    ppwszInterval2Vals[1] = NULL ;

    ModInterval2.mod_op      = LDAP_MOD_ADD ;
    ModInterval2.mod_type    = const_cast<WCHAR*> (MQ_S_INTERVAL2) ;
    ModInterval2.mod_values  = (PWSTR *) ppwszInterval2Vals ;

	WCHAR wszForeign[ 24 ] ;

	if (fForeign)
    {
        //
        // This is a boolean attribute. Specify it as "TRUE", not 1.
        //

        _stprintf(wszForeign, TEXT("TRUE")) ;

        ppwszForeignVals[0] = wszForeign ;
        ppwszForeignVals[1] = NULL ;

        ModForeign.mod_op      = LDAP_MOD_ADD ;
        ModForeign.mod_type    = const_cast<WCHAR*> (MQ_S_FOREIGN_ATTRIBUTE) ;
        ModForeign.mod_values  = (PWSTR *) ppwszForeignVals ;

        dwIndex-- ; // replace the NULL.
        rgMods[ dwIndex ] = &ModForeign;
        dwIndex++ ;
        rgMods[ dwIndex ] = NULL ;
        dwIndex++ ;
        ASSERT(dwIndex == cAlloc) ;
    }

    //
    // Now, we'll do the write...
    //
    ULONG ulRes = ldap_add_s( pLdap,
                              wszPath,
                              rgMods ) ;
   
    if ((ulRes == LDAP_ALREADY_EXISTS) || (ulRes == LDAP_UNWILLING_TO_PERFORM))
    {
        LogMigrationEvent( MigLog_Warning,
                                 MQMig_I_SITE_ALREADY_EXIST, wszPath ) ;
    }
    else if (ulRes != LDAP_SUCCESS)
    {
        #define BUF_SIZE  512

        WCHAR  wszBuf[ BUF_SIZE ] ;
        DWORD  dwErr = 0 ;

        DSCoreGetLdapError( pLdap,
                            &dwErr,
                            wszBuf,
                            BUF_SIZE ) ;

        #define STRING_SIZE  1024
        WCHAR wszErrString[ STRING_SIZE ] ;

        _snwprintf( wszErrString,
                    (STRING_SIZE - 1),
                   L"(%s, LDAP error- 0x%lx, LDAP description- %s)",
                   wszPath,
                   dwErr,
                   wszBuf ) ;
        wszErrString[ STRING_SIZE - 1 ] = 0 ;

        hr =  MQMig_E_CANT_CREATE_SITE ;
        LogMigrationEvent(MigLog_Error, hr, wszErrString, ulRes) ;

        return hr ;

        #undef BUF_SIZE
        #undef STRING_SIZE
    }
    else
    {
        LogMigrationEvent(MigLog_Trace, MQMig_I_SITE_CREATED, wszPath) ;
    }

    //
    // Wow, the site was created!
    // So now create the "Servers" container.
    //
    if (fForeign)
    {
        //
        // Foreign sites must not have a servers container. otherwise,
        // routing to foreign machines won't work.
        // So create the servers container only for "real" msmq sites.
        //
        return MQMig_OK ;
    }

    //
    // if we are in the web mode and name of site is changed and
    // site creation failed with ALREADY_EXISTS it means that we run
    // already old version of migtool with bug (new name of site was
    // incorrect if scan database was selected because of static variable init
    // in analyse phase. So we have to get old name to create server object
    // under existed site.
    // Even we are not in the web mode site name can be changed between the first
    // and second time of migration tool running. So, get the site name according
    // to the site guid
    //
    P<TCHAR> pszName = NULL;

    if (!fOk       &&                   //site name was changed
        ((ulRes == LDAP_ALREADY_EXISTS) || (ulRes == LDAP_UNWILLING_TO_PERFORM))
        )
    {
        PROPID propPath = PROPID_S_PATHNAME;
        PROPVARIANT varPath;
        varPath.vt = VT_NULL;
        varPath.pwszVal = NULL ;

        CDSRequestContext requestContext( e_DoNotImpersonate, e_ALL_PROTOCOLS);

        HRESULT hr = DSCoreGetProps(
                        MQDS_SITE,
                        NULL, // pathname
                        pSiteGuid,    //guid
                        1,
                        &propPath,
                        &requestContext,
                        &varPath ) ;
        if (FAILED(hr))
        {
			return hr;
        }

        DWORD len = _tcslen(varPath.pwszVal);
        pszName =  new TCHAR [ len + 1];
        _tcscpy (pszName, varPath.pwszVal);
        pszSiteName = pszName;
        delete varPath.pwszVal;
    }

    wcscpy(wszPath, SERVERS_PREFIX) ;
    wcscat(wszPath, pszSiteName) ;
    wcscat(wszPath, LDAP_COMMA) ;
    wcscat(wszPath, SITES_ROOT) ;
    wcscat(wszPath, pwszDefName) ;

    ASSERT(wcslen(wszPath) < PATH_LEN) ;
    #undef PATH_LEN

    dwIndex = 0 ;
    rgMods[ dwIndex ] = &ModCn;
    dwIndex++ ;
    rgMods[ dwIndex ] = &ModObjectClass;
    dwIndex++ ;
    rgMods[ dwIndex ] = NULL ;
    dwIndex++ ;
    ASSERT(dwIndex <= cAlloc) ;
    #undef  cAlloc

    //
    // objectClass
    //
    ppwszObjectClassVals[0] = TEXT("serversContainer") ;
    ppwszObjectClassVals[1] = NULL ;

    ModObjectClass.mod_op      = LDAP_MOD_ADD ;
    ModObjectClass.mod_type    = L"objectClass" ;
    ModObjectClass.mod_values  = (PWSTR *) ppwszObjectClassVals ;

    //
    // Cn (site name)
    //
    ppwszCnVals[0] = TEXT("Servers") ;
    ppwszCnVals[1] = NULL ;

    ModCn.mod_op      = LDAP_MOD_ADD ;
    ModCn.mod_type    = TEXT("cn") ;
    ModCn.mod_values  = (PWSTR *) ppwszCnVals ;

    //
    // Now, we'll do the write...
    //
    ulRes = ldap_add_s( pLdap,
                        wszPath,
                        rgMods ) ;
    if (ulRes == LDAP_ALREADY_EXISTS)
    {
        LogMigrationEvent( MigLog_Warning,
                                MQMig_I_SERVERS_ALREADY_EXIST, wszPath ) ;
    }
    else if (ulRes != LDAP_SUCCESS)
    {
        hr =  MQMig_E_CANT_CREATE_SERVERS ;
        LogMigrationEvent(MigLog_Error, hr, wszPath, ulRes) ;
        return hr ;
    }
    else
    {
        LogMigrationEvent(MigLog_Trace, MQMig_I_SERVERS_CREATED, wszPath) ;
    }

    return MQMig_OK ;
}

//+---------------------------------------------------------------
//
//   HRESULT  ReadFirstNT5Usn()
//
//  This one is called when migration is over, to retrieve and
//  register the last USN used in NT5 DS. This value is necessary
//  for future replications to NT4 PSCs.
//
//+-----------------------------------------------------------------

HRESULT  ReadFirstNT5Usn(TCHAR *wszHighestUsn)
{
    PLDAP pLdap = NULL ;
    WCHAR *pwszDefName = NULL ;

    HRESULT hr =  InitLDAP(&pLdap, &pwszDefName) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    LM<LDAPMessage> pRes = NULL ;

    ULONG ulRes = ldap_search_s( pLdap,
                                 NULL,
                                 LDAP_SCOPE_BASE,
                                 L"(objectClass=*)",
                                 NULL,
                                 0,
                                 &pRes ) ;
    if (ulRes != LDAP_SUCCESS)
    {
        hr =  MQMig_E_CANT_QUERY_ROOTDSE ;
        LogMigrationEvent(MigLog_Error, hr, ulRes) ;
        return hr ;
    }
    ASSERT(pRes) ;

    int iCount = ldap_count_entries(pLdap, pRes) ;
    LogMigrationEvent(MigLog_Info, MQMig_I_ROOTDSE_SUCCESS, iCount) ;

    if (iCount == 1)
    {
        LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
        WCHAR **ppValue = ldap_get_values( pLdap,
                                           pEntry,
                                           TEXT("highestCommittedUSN" )) ;
        if (ppValue && *ppValue)
        {
            wcscpy(wszHighestUsn, *ppValue) ;
            ldap_value_free(ppValue) ;

            LogMigrationEvent(MigLog_Info, MQMig_I_HIGHEST_USN,
                                                         wszHighestUsn) ;
        }
        else
        {
            return MQMig_E_CANT_READ_HIGHESTUSN ;
        }
    }
    else
    {
        return MQMig_E_TOOMANY_ROOTDSE ;
    }

    return MQMig_OK ;
}

//+-----------------------------------------
//
//  HRESULT  _GetUSNChanged
//
//+-----------------------------------------

HRESULT _GetUSNChanged (
                    IN  PLDAP   pLdapGC,
                    IN  TCHAR   *wszFilter,
                    IN  __int64 i64LastUsn,
                    OUT __int64 *pi64MinUsn
                    )
{
    PWSTR rgAttribs[2] = {NULL, NULL} ;
    rgAttribs[0] = const_cast<LPWSTR> (USNCHANGED_ATTRIBUTE);

    LM<LDAPMessage> pRes = NULL ;
    ULONG ulRes = ldap_search_s( pLdapGC,
                                 EMPTY_DEFAULT_CONTEXT,
                                 LDAP_SCOPE_SUBTREE,
                                 wszFilter,
                                 rgAttribs, //ppAttributes,
                                 0,
                                 &pRes ) ;
    if (ulRes != LDAP_SUCCESS)
    {
        LogMigrationEvent( MigLog_Error,
                           MQMig_E_LDAP_SEARCH_FAILED,
                           EMPTY_DEFAULT_CONTEXT, wszFilter, ulRes) ;
        return MQMig_E_LDAP_SEARCH_FAILED ;
    }
    ASSERT(pRes) ;

    LogMigrationEvent( MigLog_Info,
                       MQMig_I_LDAP_SEARCH,
                       EMPTY_DEFAULT_CONTEXT, wszFilter ) ;

    __int64 i64MinUsn = i64LastUsn;

    int iCount = ldap_count_entries(pLdapGC, pRes) ;
    UNREFERENCED_PARAMETER(iCount);

    LDAPMessage *pEntry = ldap_first_entry(pLdapGC, pRes) ;
    __int64 i64CurrentUsn;

    while(pEntry)
    {
        WCHAR **ppUSNChanged = ldap_get_values( pLdapGC,
                                                pEntry,
                        const_cast<LPWSTR> (USNCHANGED_ATTRIBUTE) ) ;
        ASSERT(ppUSNChanged) ;

        _stscanf(*ppUSNChanged, TEXT("%I64d"), &i64CurrentUsn) ;
        if (i64CurrentUsn < i64MinUsn)
        {
            i64MinUsn = i64CurrentUsn;
        }

        int i = ldap_value_free( ppUSNChanged ) ;
        DBG_USED(i);
        ASSERT(i == LDAP_SUCCESS) ;

        LDAPMessage *pPrevEntry = pEntry ;
        pEntry = ldap_next_entry(pLdapGC, pPrevEntry) ;
    }

    *pi64MinUsn = i64MinUsn;

    return MQMig_OK;

}

//+-----------------------------------------
//
//  HRESULT  FindMinMSMQUsn()
//
//+-----------------------------------------

HRESULT FindMinMSMQUsn(TCHAR *wszMinUsn)
{
    PLDAP pLdapGC = NULL ;
    WCHAR *pwszDefName = NULL ;

    HRESULT hr =  InitLDAP(&pLdapGC, &pwszDefName, LDAP_GC_PORT) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    LPWSTR pwcsSchemaDefName = NULL ;
    hr = GetSchemaNamingContext ( pLdapGC, &pwcsSchemaDefName ) ;
    if (FAILED(hr))
    {
        return hr;
    }

    static __int64 i64LastUsn = 0;

    TCHAR wszHighestUsn[ SEQ_NUM_BUF_LEN ] ;
    hr = ReadFirstNT5Usn(wszHighestUsn) ;
    if (FAILED(hr))
    {
        LogMigrationEvent(MigLog_Error, MQMig_E_GET_FIRST_USN, hr) ;
        return hr ;
    }
    _sntscanf(wszHighestUsn, SEQ_NUM_BUF_LEN, TEXT("%I64d"), &i64LastUsn) ;

    __int64 i64CurrentMinUsn;
    __int64 i64MinUsn = i64LastUsn;

    TCHAR  wszFilter[ 512 ] ;
    TCHAR  wszCategoryName[ 256 ];

    TCHAR *arCategoryNames[e_MSMQ_NUMBER_OF_CLASSES] = {
                                const_cast<LPWSTR> (x_ComputerConfigurationCategoryName),
                                const_cast<LPWSTR> (x_QueueCategoryName),
                                const_cast<LPWSTR> (x_ServiceCategoryName),
                                const_cast<LPWSTR> (x_LinkCategoryName),
                                const_cast<LPWSTR> (x_UserCategoryName),
                                const_cast<LPWSTR> (x_SettingsCategoryName),
                                const_cast<LPWSTR> (x_SiteCategoryName),
                                const_cast<LPWSTR> (x_ServerCategoryName),
                                const_cast<LPWSTR> (x_ComputerCategoryName),
                                const_cast<LPWSTR> (x_MQUserCategoryName)
                                };

    for ( DWORD i = e_MSMQ_COMPUTER_CONFIGURATION_CLASS; i < e_MSMQ_NUMBER_OF_CLASSES; i++)
    {
        _stprintf(wszCategoryName, TEXT("%s,%s"), arCategoryNames[i],pwcsSchemaDefName);
        _tcscpy(wszFilter, TEXT("(&(objectCategory=")) ;
        _tcscat(wszFilter, wszCategoryName) ;
        _tcscat(wszFilter, TEXT("))")) ;
        hr = _GetUSNChanged (pLdapGC, wszFilter, i64LastUsn, &i64CurrentMinUsn);

        if (i64CurrentMinUsn < i64MinUsn)
        {
            i64MinUsn = i64CurrentMinUsn;
        }
    }

    _stprintf(wszMinUsn, TEXT("%I64d"), i64MinUsn) ;

    return MQMig_OK;
}

//+-----------------------------------------
//
//  HRESULT  CreateMsmqContainer()
//
//+-----------------------------------------

HRESULT  CreateMsmqContainer(TCHAR wszContainerName[])
{
    PLDAP pLdap = NULL ;
    WCHAR *pwszDefName = NULL ;

    HRESULT hr =  InitLDAP(&pLdap, &pwszDefName) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    #define PATH_LEN  1024
    WCHAR  wszPath[ PATH_LEN ] ;

    _tcscpy(wszPath, OU_PREFIX) ;
    _tcscat(wszPath, wszContainerName) ;
    _tcscat(wszPath, LDAP_COMMA) ;
    _tcscat(wszPath, pwszDefName) ;

    ASSERT(wcslen(wszPath) < PATH_LEN) ;

    #define         cAlloc  3
    PLDAPMod        rgMods[ cAlloc ];
    WCHAR           *ppwszObjectClassVals[2];
    WCHAR           *ppwszOuVals[2];
    LDAPMod         ModObjectClass;
    LDAPMod         ModOu;

    DWORD  dwIndex = 0 ;
    rgMods[ dwIndex ] = &ModOu;
    dwIndex++ ;
    rgMods[ dwIndex ] = &ModObjectClass;
    dwIndex++ ;
    rgMods[ dwIndex ] = NULL ;
    dwIndex++ ;
    ASSERT(dwIndex == cAlloc) ;
    #undef  cAlloc

    //
    // objectClass
    //
    ppwszObjectClassVals[0] = CONTAINER_OBJECT_CLASS;
    ppwszObjectClassVals[1] = NULL ;

    ModObjectClass.mod_op      = LDAP_MOD_ADD ;
    ModObjectClass.mod_type    = TEXT("objectClass") ;
    ModObjectClass.mod_values  = (PWSTR *) ppwszObjectClassVals ;

    //
    // Ou (container name)
    //
    ppwszOuVals[0] = wszContainerName ;
    ppwszOuVals[1] = NULL ;

    ModOu.mod_op      = LDAP_MOD_ADD ;
    ModOu.mod_type    = TEXT("ou") ;
    ModOu.mod_values  = (PWSTR *) ppwszOuVals ;

    if (g_fReadOnly)
    {
        return MQMig_OK ;
    }

    //
    // Now, we'll do the write...
    //
    ULONG ulRes = ldap_add_s( pLdap,
                              wszPath,
                              rgMods ) ;
    if (ulRes == LDAP_ALREADY_EXISTS)
    {
        hr = MQMig_I_CONTAINER_ALREADY_EXIST ;
        LogMigrationEvent(MigLog_Warning, hr, wszPath) ;
    }
    else if (ulRes != LDAP_SUCCESS)
    {
        hr = MQMig_E_CANT_CREATE_CONTNER ;
        LogMigrationEvent(MigLog_Error, hr, wszPath, ulRes) ;
    }
    else
    {
        LogMigrationEvent(MigLog_Info, MQMig_I_CREATE_CONTAINER, wszPath) ;
        hr = MQMig_OK ;
    }

    return hr ;
}

//+-----------------------------
//
// UINT  GetNT5SitesCount()
//
//+-----------------------------

UINT  GetNT5SitesCount()
{
    return 0 ;
}

//+------------------------------
//
//  HRESULT ModifyAttribute()
//
//+------------------------------

HRESULT ModifyAttribute(
             WCHAR       wszPath[],
             WCHAR       pAttr[],
             WCHAR       pAttrVal[],
             PLDAP_BERVAL *ppBVals
             )
{
    PLDAP pLdap = NULL ;
    TCHAR *pszDefName = NULL ;

    HRESULT hr =  InitLDAP(&pLdap, &pszDefName) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    DWORD           dwIndex = 0 ;
    PLDAPMod        rgMods[2];
    WCHAR           *ppwszAttrVals[2];
    LDAPMod         ModAttr ;

    rgMods[ dwIndex ] = &ModAttr;
    dwIndex++ ;
    rgMods[ dwIndex ] = NULL;

    ModAttr.mod_op      = LDAP_MOD_REPLACE ;
    ModAttr.mod_type    = pAttr ;

    if (pAttrVal)
    {
        ppwszAttrVals[0] = pAttrVal ;
        ppwszAttrVals[1] = NULL ;

        ModAttr.mod_values  = (PWSTR *) ppwszAttrVals ;
    }
    else if (ppBVals)
    {
        ModAttr.mod_op |= LDAP_MOD_BVALUES;
        ModAttr.mod_values  = (PWSTR *)ppBVals;
    }
    else
    {
        //
        // delete value from entry
        //
        ModAttr.mod_op = LDAP_MOD_DELETE ;
        ModAttr.mod_values = NULL;
    }

    //
    // Now, we'll do the write...
    //
    ULONG ulRes = ldap_modify_s( pLdap,
                                 wszPath,
                                 rgMods ) ;

    if (ulRes != LDAP_SUCCESS)
    {
        LogMigrationEvent( MigLog_Error, MQMig_E_MODIFY_MIG_ATTRIBUTE, wszPath, ulRes) ;
        return MQMig_E_MODIFY_MIG_ATTRIBUTE;
    }
    else
    {
        LogMigrationEvent( MigLog_Info, MQMig_I_MODIFY_MIG_ATTRIBUTE, wszPath) ;
    }

    return MQMig_OK ;
}

//+------------------------------
//
//  HRESULT QueryDS()
// Queries DS using LDAP paging and calls HandleA<ObjectName> function to
// modify object attributes.
//
//+------------------------------

HRESULT QueryDS(
			IN	PLDAP			pLdap,
			IN	TCHAR			*pszDN,
			IN  TCHAR			*pszFilter,			
			IN	DWORD			dwObjectType,
            IN  PWSTR           *prgAttribs,
            IN  BOOL            fTouchUser
            )
{
    CLdapPageHandle hPage(pLdap);
	hPage = ldap_search_init_page(
                    pLdap,
					pszDN,                   //pwszDN
					LDAP_SCOPE_SUBTREE,     //scope
					pszFilter,              //search filter
					prgAttribs,              //attribute list
					0,                      //attributes only
					NULL,   	            //ServerControls
					NULL,                   //PLDAPControlW   *ClientControls,
                    0,						//PageTimeLimit,
                    0,                      //TotalSizeLimit
					NULL                    //PLDAPSortKey SortKeys
                    );

	ULONG ulRes;
	HRESULT hr = MQMig_OK;

    if (hPage == NULL)
    {
        ulRes = LdapGetLastError();
		hr = MQMig_E_LDAP_SEARCH_INITPAGE_FAILED;
		LogMigrationEvent(MigLog_Error, hr, pszDN, pszFilter, ulRes) ;
        return hr;
    }

    ULONG ulTotalCount;     	
	LM<LDAPMessage> pRes = NULL ;

    ulRes = ldap_get_next_page_s(
                        pLdap,
                        hPage,
                        NULL,						//timeout,
                        RP_DEFAULT_OBJECT_PER_LDAPPAGE,      //ULONG ulPageSize
                        &ulTotalCount,
                        &pRes);

    LogMigrationEvent(MigLog_Info,
						MQMig_I_NEXTPAGE,
						ulRes, pszDN, pszFilter) ;

	ULONG ulPageCount = 0;
	
    while (ulRes == LDAP_SUCCESS)
	{
		ASSERT(pRes);

		ulPageCount++;
        LogMigrationEvent (MigLog_Info, MQMig_I_PAGE_NUMBER, ulPageCount);

        //
        // pass through results on the current page
        //
        int iCount = ldap_count_entries(pLdap, pRes) ;
        LogMigrationEvent(MigLog_Info, MQMig_I_LDAP_PAGE_SEARCH,
                                             iCount, pszDN, pszFilter) ;	   	
		
		LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;		

		while(pEntry)
		{												
			switch(dwObjectType)
			{
			case MQDS_USER:
                if (fTouchUser)
                {
                    hr = TouchAUser (pLdap,
                                     pEntry
                                     );
                }
                else
                {
				    hr = HandleAUser(
							    pLdap,
							    pEntry
							    );
                }
				break;
			
            default:
				ASSERT(0);
				break;
            }

            LDAPMessage *pPrevEntry = pEntry ;
			pEntry = ldap_next_entry(pLdap, pPrevEntry) ;	    			
		}

        ldap_msgfree(pRes) ;
        pRes = NULL ;

		ulRes = ldap_get_next_page_s(
                        pLdap,
                        hPage,
                        NULL,						//timeout,
                        RP_DEFAULT_OBJECT_PER_LDAPPAGE,      //ULONG ulPageSize
                        &ulTotalCount,
                        &pRes);

        LogMigrationEvent(MigLog_Info,
						MQMig_I_NEXTPAGE,
						ulRes, pszDN, pszFilter) ;
	}

	if (ulRes != LDAP_NO_RESULTS_RETURNED)
	{
		hr = MQMig_E_LDAP_GET_NEXTPAGE_FAILED;
		LogMigrationEvent(MigLog_Error,
						hr, pszDN, pszFilter, ulRes ) ; 		
	}	
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\miglinks.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    miglinks.cpp

Abstract:

    Migration NT4 SiteLink objects to NT5 ADS.
Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

#include "migrat.h"

#include "miglinks.tmh"

//-----------------------------------------
//
//  HRESULT MigrateSiteLinks()
//
//-----------------------------------------

HRESULT MigrateASiteLink (
            IN GUID     *pLinkId,
            IN GUID     *pNeighbor1Id,
            IN GUID     *pNeighbor2Id,
            IN DWORD    dwCost,
            IN DWORD    dwSiteGateNum,
            IN LPWSTR   lpwcsSiteGates,
            IN UINT     iIndex
            )
{
    DBG_USED(iIndex);
#ifdef _DEBUG    
	unsigned short *lpszNeighbor1 ;
	unsigned short *lpszNeighbor2 ;
    
	UuidToString( pNeighbor1Id, &lpszNeighbor1 ) ;
	UuidToString( pNeighbor2Id, &lpszNeighbor2 ) ;

    LogMigrationEvent(MigLog_Info, MQMig_I_SITELINK_INFO,
							iIndex,
							lpszNeighbor1,
							lpszNeighbor2,
							dwCost ) ;
  
	RpcStringFree( &lpszNeighbor1 ) ;
	RpcStringFree( &lpszNeighbor2 ) ;
#endif
	
	//
    // Prepare the properties for DS call.
    //
    LONG cAlloc = 5;
    P<PROPVARIANT> paVariant = new PROPVARIANT[ cAlloc ];
    P<PROPID>      paPropId  = new PROPID[ cAlloc ];
    DWORD          PropIdCount = 0;

    if (pLinkId)
    {
        //
        // Bug 5012.
        // pLinkId may be NULL if site link for connector machine is created
        //
        paPropId[ PropIdCount ] = PROPID_L_ID;		//PropId
        paVariant[ PropIdCount ].vt = VT_CLSID;     //Type
        paVariant[PropIdCount].puuid = pLinkId ;
        PropIdCount++;
    }

    paPropId[ PropIdCount ] = PROPID_L_NEIGHBOR1;    //PropId
    paVariant[ PropIdCount ].vt = VT_CLSID;          //Type
    paVariant[ PropIdCount ].puuid = pNeighbor1Id;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_L_NEIGHBOR2;    //PropId
    paVariant[ PropIdCount ].vt = VT_CLSID;          //Type
    paVariant[ PropIdCount ].puuid = pNeighbor2Id;
    PropIdCount++;

    paPropId[ PropIdCount ] = PROPID_L_COST;    //PropId
    paVariant[ PropIdCount ].vt = VT_UI4;       //Type
    paVariant[ PropIdCount ].ulVal = dwCost;
    PropIdCount++;
    
    if (dwSiteGateNum)
    {
        ASSERT (lpwcsSiteGates);
        paPropId[ PropIdCount ] = PROPID_L_GATES_DN;
        paVariant[ PropIdCount ].vt = VT_LPWSTR | VT_VECTOR;
        paVariant[ PropIdCount ].calpwstr.cElems = dwSiteGateNum;
        paVariant[ PropIdCount ].calpwstr.pElems = &lpwcsSiteGates;
        PropIdCount++;
    }

    ASSERT((LONG) PropIdCount <= cAlloc) ;

    if (g_fReadOnly)
    {
        //
        // Read-Only mode.
        //
        return MQMig_OK ;
    }

    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);  // not relevant 

    HRESULT hr = DSCoreCreateObject ( MQDS_SITELINK,
                                      NULL,
                                      PropIdCount,
                                      paPropId,
                                      paVariant,
                                      0,        // ex props
                                      NULL,     // ex props
                                      NULL,     // ex props
                                      &requestContext,
                                      NULL,
                                      NULL ) ;

	if ((hr == MQDS_E_SITELINK_EXISTS) || (hr == HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM)))
    {
		if (pLinkId != NULL)
		{
			CDSRequestContext requestContext2( e_DoNotImpersonate, e_ALL_PROTOCOLS);
			
			PROPID propID = PROPID_L_ID;
	    	PROPVARIANT propVariant;
			propVariant.vt = VT_NULL;
			hr = DSCoreGetProps( 
						MQDS_SITELINK,
						NULL, //pathname
						pLinkId,
						1,
						&propID,
						&requestContext2,
						&propVariant ) ;
			if (FAILED(hr))
			{
				return hr;
			}

			ASSERT(memcmp(pLinkId, propVariant.puuid, sizeof (GUID)) == 0);
			delete propVariant.puuid;
		}
    }
    return hr ;
}

//-----------------------------------------
//
//  HRESULT MigrateSiteLinks()
//
//-----------------------------------------

#define INIT_SITELINK_COLUMN(_ColName, _ColIndex, _Index)           \
    INIT_COLUMNVAL(pColumns[ _Index ]) ;                            \
    pColumns[ _Index ].lpszColumnName = ##_ColName##_COL ;          \
    pColumns[ _Index ].nColumnValue   = 0 ;                         \
    pColumns[ _Index ].nColumnLength  = 0 ;                         \
    pColumns[ _Index ].mqdbColumnType = ##_ColName##_CTYPE ;        \
    UINT _ColIndex = _Index ;                                       \
    _Index++ ;

HRESULT MigrateSiteLinks()
{
	HRESULT hr = OpenSiteLinkTable() ;
    CHECK_HR(hr) ;

    ULONG cColumns = 0 ;
	ULONG cAlloc = 4 ;
    P<MQDBCOLUMNVAL> pColumns = new MQDBCOLUMNVAL[ cAlloc ] ;

	INIT_SITELINK_COLUMN(L_ID,			iGuidIndex,			cColumns) ;
	INIT_SITELINK_COLUMN(L_NEIGHBOR1,   iNeighbor1Index,	cColumns) ;
	INIT_SITELINK_COLUMN(L_NEIGHBOR2,   iNeighbor2Index,	cColumns) ;
	INIT_SITELINK_COLUMN(L_COST,		iCostIndex,			cColumns) ;

    ASSERT(cColumns == cAlloc);

    CHQuery hQuery ;
    MQDBSTATUS status = MQDBOpenQuery( g_hSiteLinkTable,
                                       pColumns,
                                       cColumns,
                                       NULL,
                                       NULL,
                                       NULL,
                                       0,
                                       &hQuery,
							           TRUE ) ;
	if (status == MQDB_E_NO_MORE_DATA)
    {
        LogMigrationEvent(MigLog_Warning, MQMig_I_NO_SITELINKS) ;
        return MQMig_OK ;
    }
    CHECK_HR(status) ;

    UINT iIndex = 0 ;

    while(SUCCEEDED(status))
    {
		//
        // Migrate each site link
		//
		status = MigrateASiteLink (
                        (GUID *) pColumns[ iGuidIndex ].nColumnValue,		//link id
                        (GUID *) pColumns[ iNeighbor1Index ].nColumnValue,	//neighbor1
                        (GUID *) pColumns[ iNeighbor2Index ].nColumnValue,	//neighbor2
                        (DWORD) pColumns[ iCostIndex ].nColumnValue,		//cost
                        0,
                        NULL,
                        iIndex
                        );               

        for ( ULONG i = 0 ; i < cColumns; i++ )
        {
			if (i != iCostIndex)
			{
				MQDBFreeBuf((void*) pColumns[ i ].nColumnValue) ;
			}
            pColumns[ i ].nColumnValue  = 0 ;
            pColumns[ i ].nColumnLength  = 0 ;
        }
		CHECK_HR(status) ;

        iIndex++ ;
        status = MQDBGetData( hQuery,
                              pColumns ) ;
    }

    MQDBSTATUS status1 = MQDBCloseQuery(hQuery) ;
    UNREFERENCED_PARAMETER(status1);

    hQuery = NULL ;

    if (status != MQDB_E_NO_MORE_DATA)
    {
        //
        // If NO_MORE_DATA is not the last error from the query then
        // the query didn't terminated OK.
        //
        LogMigrationEvent(MigLog_Error, MQMig_E_SITELINKS_SQL_FAIL, status) ;
        return status ;
    }

    return MQMig_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\migloger.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migloger.cpp

Abstract:

    Log errors and other messages of the migration tool.

Author:

    Doron Juster  (DoronJ)  08-Apr-1998

--*/

#include "migrat.h"

#include "migloger.tmh"

extern HINSTANCE  g_hResourceMod;

static LPTSTR  s_szLogFile = NULL ;
static ULONG   s_ulTraceFlags ;
static HANDLE  s_hLogFile = INVALID_HANDLE_VALUE ;

static TCHAR *s_pszPrefix[] = { TEXT("Event: "),
                                TEXT("Error: "),
                                TEXT("Warning: "),
                                TEXT("Trace: "),
                                TEXT("Info: ") } ;

static TCHAR s_pszAnalysisPhase[] = TEXT("Analysis phase");
static TCHAR s_pszMigrationPhase[] = TEXT("Migration phase");

//+--------------------------
//
//  void InitLogging()
//
//+--------------------------

void InitLogging( LPTSTR  szLogFile,
                  ULONG   ulTraceFlags,
				  BOOL	  fReadOnly)
{
    s_szLogFile = szLogFile ;
    s_ulTraceFlags =  ulTraceFlags + 1 ;

    if (s_ulTraceFlags <= 4 /*MQ_DBGLVL_INFO*/)
    {
        //
        // Logging enabled.
        // Open the log file
        //
        s_hLogFile = CreateFile( s_szLogFile,
                                 GENERIC_WRITE,
                                 0,
                                 NULL,
                                 OPEN_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL ) ;
		TCHAR *pszPhase;
		if (fReadOnly)
		{
			pszPhase = s_pszAnalysisPhase;			
		}
		else
		{
			pszPhase = s_pszMigrationPhase;
		}

        //
        // set pointer to the end of file
        //
        if (s_hLogFile != INVALID_HANDLE_VALUE)
        {
            DWORD dwRes = SetFilePointer(
                                 s_hLogFile,          // handle of file
                                 0,  // number of bytes to move file pointer
                                 NULL,
                                 // pointer to high-order DWORD of
                                 // distance to move
                                 FILE_END     // how to move
                                 );
            UNREFERENCED_PARAMETER(dwRes);
            //
            // Write to log file the line at the start and between two phases.
            //
			SYSTEMTIME SystemTime;
			GetLocalTime (&SystemTime);		

			TCHAR szSeparatorLine[128];
			_stprintf (szSeparatorLine,
				TEXT("** Start logging at %d:%d:%d on %d/%d/%d, %s **"),
					SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond,
					SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,
					pszPhase);

            DWORD dwSize = (_tcslen(szSeparatorLine) + 4) * 2 ;
            char *szLog = new char[ dwSize ] ;
            wcstombs(szLog, szSeparatorLine, dwSize) ;
            strcat(szLog, "\r\n\r\n") ;

            DWORD dwWritten = 0 ;
            WriteFile( s_hLogFile,
                       szLog,
                       strlen(szLog),
                       &dwWritten,
                       NULL ) ;
        }
    }
}

//+------------------------
//
//  void EndLogging()
//
//+------------------------

void EndLogging()
{
    if (s_hLogFile != INVALID_HANDLE_VALUE)
    {
		//
        // Write to log file the line at the end.
        //
		SYSTEMTIME SystemTime;
		GetLocalTime (&SystemTime);		

		TCHAR szSeparatorLine[128];
		_stprintf (szSeparatorLine,
				TEXT("** End of logging at %d:%d:%d on %d/%d/%d **"),
				SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond,
				SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear);

		DWORD dwSize = (_tcslen(szSeparatorLine) + 4) * 2 ;
        char *szLog = new char[ dwSize ] ;
        wcstombs(szLog, szSeparatorLine, dwSize) ;
        strcat(szLog, "\r\n\r\n") ;

        DWORD dwWritten = 0 ;
        WriteFile( s_hLogFile,
                   szLog,
                   strlen(szLog),
                   &dwWritten,
                   NULL ) ;

		//
		// close handle
		//
        CloseHandle(s_hLogFile) ;
        s_hLogFile = INVALID_HANDLE_VALUE ;
    }
}

//+--------------------------------
//
//  void LogMigrationEvent()
//
//+--------------------------------

void LogMigrationEvent(MigLogLevel eLevel, DWORD dwMsgId, ...)
{
    va_list Args;
    va_list *pArgs = &Args ;
    va_start(Args, dwMsgId);

    TCHAR *tszDisplay = NULL ;
    P<TCHAR> tszMessage = NULL ;
    TCHAR tszBuf[ 1024 ] ;

    DWORD dwMessageSize = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                                         g_hResourceMod,
                                         dwMsgId,
                                         0,
                                         tszBuf,
                                         sizeof(tszBuf) / sizeof(TCHAR),
                                         pArgs) ;
    if (dwMessageSize == 0)
    {
        _stprintf(tszBuf,
         TEXT("ERROR: Failed to format message (id- %lut), err- %lut"),
                                                  dwMsgId, GetLastError()) ;
        tszDisplay = tszBuf ;
    }
    else
    {
        DWORD dwLen = _tcslen(tszBuf) ;
        tszBuf[ dwLen - 1 ] = TEXT('\0') ; // remove newline

        dwLen += _tcslen(s_pszPrefix[ eLevel ]) ;
        tszMessage = new TCHAR[ dwLen + 6 ] ;
        _tcscpy(tszMessage, s_pszPrefix[ eLevel ]) ;
        _tcscat(tszMessage, tszBuf) ;
        tszDisplay = tszMessage ;
    }

    TrWARNING(GENERAL, "%ls", tszDisplay);

    if (((ULONG) eLevel <= s_ulTraceFlags) &&
        (s_hLogFile != INVALID_HANDLE_VALUE))
    {
        //
        // Write to log file.
        //
        DWORD dwSize = ConvertToMultiByteString(tszDisplay, NULL, 0);
        P<char> szLog = new char[dwSize+4];
        size_t rc = ConvertToMultiByteString(tszDisplay, szLog, dwSize);
        DBG_USED(rc);
        ASSERT(rc != (size_t)(-1));
        szLog[dwSize] = '\0';
        strcat(szLog, "\r\n") ;
   
        DWORD dwWritten = 0 ;
        WriteFile( s_hLogFile,
                   szLog,
                   strlen(szLog),
                   &dwWritten,
                   NULL ) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\migtool\mqmigrat\migmachn.cpp ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    migmachn.cpp

Abstract:

    Migration NT4 Machine objects to NT5 ADS.
Author:

    Doron Juster  (DoronJ)  22-Feb-1998

--*/

#include "migrat.h"
#include <mixmode.h>
#include <lmaccess.h>
#include "resource.h"
#include <dsproto.h>
#include <mqsec.h>
#include <autorel.h>
#include <string>
#include <_rstrct.h>

using namespace std;



#include "migmachn.tmh"

extern GUID       g_MyMachineGuid  ;
extern WCHAR 	  g_MachineName[MAX_COMPUTERNAME_LENGTH+1];
extern BOOL 	  g_fAllMachinesDemoted;
extern BOOL		  g_fUpdateRegistry;

// 
// The order is IMPORTANT. Please save it!
// We get machine properties from SQL database in this order. 
// Then we use these variables as index in the array of properties.
// Don't insert variables between lines with out/in frss. We based on the order.
//
enum enumPropIndex
{
    e_GuidIndex = 0,
    e_Name1Index,
    e_Name2Index,
    e_ServiceIndex,
    e_QuotaIndex,
    e_JQuotaIndex,
    e_OSIndex,
    e_MTypeIndex,
    e_ForeignIndex,
    e_Sign1Index,
    e_Sign2Index,
    e_Encrpt1Index,
    e_Encrpt2Index,
    e_SecD1Index, 
    e_SecD2Index,
    e_SecD3Index,
    e_OutFrs1Index,
    e_OutFrs2Index,
    e_OutFrs3Index, 
    e_InFrs1Index,
    e_InFrs2Index, 
    e_InFrs3Index
};


//+--------------------------------------------------------------
//
//  HRESULT _HandleMachineWithInvalidName
//
//+--------------------------------------------------------------
static HRESULT _HandleMachineWithInvalidName (
                           IN LPWSTR   wszMachineName,
                           IN GUID     *pMachineGuid)
{
    static BOOL s_fShowMessageBox = FALSE;    
    static BOOL s_fMigrate = FALSE;

    if (!s_fShowMessageBox )
    {

        CResString strCaption(IDS_CAPTION);
        CResString strText(IDS_INVALID_MACHINE_NAME);
        int iRet = MessageBox( NULL,
                        strText.Get(),
                        strCaption.Get(),
                        MB_YESNO | MB_ICONWARNING);

        s_fShowMessageBox = TRUE;
        if (iRet == IDYES)
        {
            s_fMigrate = TRUE;
        }
    }
    
    //
    // Bug 5281.
    //    
    if (s_fMigrate)
    {
        //
        // if user chooses to continue with the migration of this machine
        // do not save it in .ini file and return OK.
        // 
        LogMigrationEvent(MigLog_Info, MQMig_I_INVALID_MACHINE_NAME, wszMachineName) ;
        return MQMig_OK;
    }

    //
    // Save this machine name in .ini file to prevent queue migration
    // of this machine later.    
    //
    if (!g_fReadOnly)
    {
        SaveMachineWithInvalidNameInIniFile (wszMachineName, pMachineGuid);   
    }

    LogMigrationEvent(MigLog_Event, MQMig_E_INVALID_MACHINE_NAME, wszMachineName) ;
    return MQMig_E_INVALID_MACHINE_NAME;
}

//+--------------------------------------------------------------
//
//  HRESULT _CreateMachine()
//
//+--------------------------------------------------------------

static HRESULT _CreateMachine( IN GUID                *pOwnerGuid,
                               IN LPWSTR               wszSiteName,
                               IN LPWSTR               wszMachineName,
                               MQDBCOLUMNVAL          *pColumns,                               
                               IN UINT                 iIndex,
                               OUT BOOL               *pfIsConnector)
{    
    DBG_USED(iIndex);
    //
    // get machine guid from pColumns
    //
    GUID *pMachineGuid = (GUID*) pColumns[ e_GuidIndex ].nColumnValue;
       
#ifdef _DEBUG
    unsigned short *lpszGuid ;
    UuidToString( pMac