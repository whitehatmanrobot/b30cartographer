           false);
}

STDMETHODIMP
CDAPoint2::AnimateControlPositionPixel(BSTR propertyPath,
                                       BSTR scriptingLanguage,
                                       VARIANT_BOOL invokeAsMethod,
                                       double minUpdateInterval,
                                       IDAPoint2 **newPt)
{
    // These ensure the return pointer is dealt with correctly
    return Point2AnimateControlPosition(this, propertyPath,
                                        scriptingLanguage,
                                        invokeAsMethod ? true : false,
                                        minUpdateInterval,
                                        newPt,
                                        true);
}



CBvr * CDAPoint2Create(IDABehavior ** bvr)
{
    DAComObject<CDAPoint2> * pNew ;
    
    DAComObject<CDAPoint2>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAPoint2 *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAPoint2Factory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRPOINT2_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAString::Extract(BSTR * ret)
{
    TraceTag((tagCOMEntry, "CDAString::Extract(%lx)", this));

    PRIMPRECODE1(ret) ;
    /* NOELRET */ *ret = WideStringToBSTR(::CRExtract((CRString *) _bvr.p));
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAString::AnimateProperty(BSTR propertyPath,
                           BSTR scriptingLanguage,
                           VARIANT_BOOL invokeAsMethod,
                           double minUpdateInterval,
                           IDAString **newStr)
{ 
    // These ensure the return pointer is dealt with correctly
    return StringAnimateProperty(this, propertyPath,
                                 scriptingLanguage, 
                                 invokeAsMethod ? true : false,
                                 minUpdateInterval, newStr);
}



CBvr * CDAStringCreate(IDABehavior ** bvr)
{
    DAComObject<CDAString> * pNew ;
    
    DAComObject<CDAString>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAString *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAStringFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRSTRING_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAVector2::get_Length(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::get_Length(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector2 *)) CRLength , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector2::get_LengthSquared(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::get_LengthSquared(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector2 *)) CRLengthSquared , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector2::Normalize(IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::Normalize(%lx)", this));
    return CreatePrim1(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRVector2 *)) CRNormalize , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector2::MulAnim(IDANumber *  arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::MulAnim(%lx)", this));
    return CreatePrim2(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRVector2 *, CRNumber *)) CRMul , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector2::Mul(double arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::Mul(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAVector2, (CRBvrPtr) (::CRMul((CRVector2 *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAVector2::DivAnim(IDANumber *  arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::DivAnim(%lx)", this));
    return CreatePrim2(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRVector2 *, CRNumber *)) CRDiv , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector2::Div(double arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::Div(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAVector2, (CRBvrPtr) (::CRDiv((CRVector2 *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAVector2::get_X(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::get_X(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector2 *)) CRGetX , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector2::get_Y(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::get_Y(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector2 *)) CRGetY , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector2::get_PolarCoordAngle(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::get_PolarCoordAngle(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector2 *)) CRPolarCoordAngle , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector2::get_PolarCoordLength(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::get_PolarCoordLength(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector2 *)) CRPolarCoordLength , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector2::Transform(IDATransform2 *  arg0, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector2::Transform(%lx)", this));
    return CreatePrim2(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRVector2 *, CRTransform2 *)) CRTransform , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}



CBvr * CDAVector2Create(IDABehavior ** bvr)
{
    DAComObject<CDAVector2> * pNew ;
    
    DAComObject<CDAVector2>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAVector2 *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAVector2Factory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRVECTOR2_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDALineStyle::End(IDAEndStyle *  arg0, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::End(%lx)", this));
    return CreatePrim2(IID_IDALineStyle, (CRLineStyle * (STDAPICALLTYPE *)(CRLineStyle *, CREndStyle *)) CREnd , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDALineStyle::Join(IDAJoinStyle *  arg0, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::Join(%lx)", this));
    return CreatePrim2(IID_IDALineStyle, (CRLineStyle * (STDAPICALLTYPE *)(CRLineStyle *, CRJoinStyle *)) CRJoin , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDALineStyle::Dash(IDADashStyle *  arg0, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::Dash(%lx)", this));
    return CreatePrim2(IID_IDALineStyle, (CRLineStyle * (STDAPICALLTYPE *)(CRLineStyle *, CRDashStyle *)) CRDash , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDALineStyle::WidthAnim(IDANumber *  arg0, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::WidthAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) PointToNumBvr(::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDALineStyle, (CRBvrPtr) (::CRWidth((CRLineStyle *) _bvr.p, arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDALineStyle::width(double arg0, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::width(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDALineStyle, (CRBvrPtr) (::CRWidth((CRLineStyle *) _bvr.p, /* NOELARG */ PointToNum(arg0))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDALineStyle::AntiAliasing(double arg0, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::AntiAliasing(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDALineStyle, (CRBvrPtr) (::CRAntiAliasing((CRLineStyle *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDALineStyle::Detail(IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::Detail(%lx)", this));
    return CreatePrim1(IID_IDALineStyle, (CRLineStyle * (STDAPICALLTYPE *)(CRLineStyle *)) CRDetail , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDALineStyle::Color(IDAColor *  arg0, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::Color(%lx)", this));
    return CreatePrim2(IID_IDALineStyle, (CRLineStyle * (STDAPICALLTYPE *)(CRLineStyle *, CRColor *)) CRLineColor , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDALineStyle::DashStyle(DWORD arg1, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::DashStyle(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDALineStyle, (CRBvrPtr) (::CRDashEx((CRLineStyle *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDALineStyle::MiterLimit(double arg1, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::MiterLimit(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDALineStyle, (CRBvrPtr) (::CRMiterLimit((CRLineStyle *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDALineStyle::MiterLimitAnim(IDANumber *  arg1, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::MiterLimitAnim(%lx)", this));
    return CreatePrim2(IID_IDALineStyle, (CRLineStyle * (STDAPICALLTYPE *)(CRLineStyle *, CRNumber *)) CRMiterLimit , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDALineStyle::JoinStyle(DWORD arg1, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::JoinStyle(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDALineStyle, (CRBvrPtr) (::CRJoinEx((CRLineStyle *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDALineStyle::EndStyle(DWORD arg1, IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDALineStyle::EndStyle(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDALineStyle, (CRBvrPtr) (::CREndEx((CRLineStyle *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}



CBvr * CDALineStyleCreate(IDABehavior ** bvr)
{
    DAComObject<CDALineStyle> * pNew ;
    
    DAComObject<CDALineStyle>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDALineStyle *) pNew;

    return pNew ;
}

STDMETHODIMP
CDALineStyleFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRLINESTYLE_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}



CBvr * CDADashStyleCreate(IDABehavior ** bvr)
{
    DAComObject<CDADashStyle> * pNew ;
    
    DAComObject<CDADashStyle>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDADashStyle *) pNew;

    return pNew ;
}

STDMETHODIMP
CDADashStyleFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRDASHSTYLE_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAPair::get_First(IDABehavior *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPair::get_First(%lx)", this));
    return CreatePrim1(IID_IDABehavior, (CRBvr * (STDAPICALLTYPE *)(CRPair *)) CRFirst , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPair::get_Second(IDABehavior *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPair::get_Second(%lx)", this));
    return CreatePrim1(IID_IDABehavior, (CRBvr * (STDAPICALLTYPE *)(CRPair *)) CRSecond , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}



CBvr * CDAPairCreate(IDABehavior ** bvr)
{
    DAComObject<CDAPair> * pNew ;
    
    DAComObject<CDAPair>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAPair *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAPairFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRPAIR_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDATuple::Nth(long arg1, IDABehavior *  * ret)
{
    TraceTag((tagCOMEntry, "CDATuple::Nth(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDABehavior, (CRBvrPtr) (::CRNth((CRTuple *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDATuple::get_Length(long * ret)
{
    TraceTag((tagCOMEntry, "CDATuple::get_Length(%lx)", this));

    PRIMPRECODE1(ret) ;
    /* NOELRET */ *ret = (::CRLength((CRTuple *) _bvr.p));
    PRIMPOSTCODE1(ret) ;
}



CBvr * CDATupleCreate(IDABehavior ** bvr)
{
    DAComObject<CDATuple> * pNew ;
    
    DAComObject<CDATuple>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDATuple *) pNew;

    return pNew ;
}

STDMETHODIMP
CDATupleFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRTUPLE_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\bvrclas2.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/

#include "headers.h"
#include "cbvr.h"
#include "srvprims.h"
#include "comcb.h"
#include "privinc/resource.h"
#include "bvrtypes.h"
#include "comconv.h"
#include "propanim.h"

#include "primmth2.h"

bool CreatePrim0(REFIID iid, void *fp  , void **ret);

bool CreatePrim1(REFIID iid, void *fp , IDABehavior * arg1 , void **ret);

bool CreatePrim2(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2 , void **ret);

bool CreatePrim3(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2, IDABehavior * arg3 , void **ret);

bool CreatePrim4(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2, IDABehavior * arg3, IDABehavior * arg4 , void **ret);

bool CreateVar(REFIID iid, CRBvrPtr var, void **ret);

STDMETHODIMP
CDAColor::get_Red(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAColor::get_Red(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRColor *)) CRGetRed , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAColor::get_Green(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAColor::get_Green(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRColor *)) CRGetGreen , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAColor::get_Blue(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAColor::get_Blue(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRColor *)) CRGetBlue , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAColor::get_Hue(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAColor::get_Hue(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRColor *)) CRGetHue , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAColor::get_Saturation(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAColor::get_Saturation(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRColor *)) CRGetSaturation , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAColor::get_Lightness(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAColor::get_Lightness(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRColor *)) CRGetLightness , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAColor::AnimateProperty(BSTR propertyPath,
                          BSTR scriptingLanguage,
                          VARIANT_BOOL invokeAsMethod,
                          double minUpdateInterval,
                          IDA2Color **newCol)
{
    // These ensure the return pointer is dealt with correctly
    return ColorAnimateProperty(this, propertyPath,
                                 scriptingLanguage, 
                                 invokeAsMethod ? true : false,
                                 minUpdateInterval, newCol);
}


CBvr * CDAColorCreate(IDABehavior ** bvr)
{
    DAComObject<CDAColor> * pNew ;
    
    DAComObject<CDAColor>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAColor *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAColorFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRCOLOR_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAMatte::Transform(IDATransform2 *  arg0, IDAMatte *  * ret)
{
    TraceTag((tagCOMEntry, "CDAMatte::Transform(%lx)", this));
    return CreatePrim2(IID_IDAMatte, (CRMatte * (STDAPICALLTYPE *)(CRMatte *, CRTransform2 *)) CRTransform , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}



CBvr * CDAMatteCreate(IDABehavior ** bvr)
{
    DAComObject<CDAMatte> * pNew ;
    
    DAComObject<CDAMatte>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAMatte *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAMatteFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRMATTE_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDANumber::Extract(double * ret)
{
    TraceTag((tagCOMEntry, "CDANumber::Extract(%lx)", this));

    PRIMPRECODE1(ret) ;
    /* NOELRET */ *ret = (::CRExtract((CRNumber *) _bvr.p));
    PRIMPOSTCODE(S_OK) ;
}

STDMETHODIMP
CDANumber::ToStringAnim(IDANumber *  arg1, IDAString *  * ret)
{
    TraceTag((tagCOMEntry, "CDANumber::ToStringAnim(%lx)", this));
    return CreatePrim2(IID_IDAString, (CRString * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRToString , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDANumber::ToString(double arg1, IDAString *  * ret)
{
    TraceTag((tagCOMEntry, "CDANumber::ToString(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAString, (CRBvrPtr) (::CRToString((CRNumber *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}


STDMETHODIMP
CDANumber::AnimateProperty(BSTR propertyPath,
                           BSTR scriptingLanguage,
                           VARIANT_BOOL invokeAsMethod,
                           double minUpdateInterval,
                           IDANumber **newNum)
{
    // These ensure the return pointer is dealt with correctly
    return NumberAnimateProperty(this, propertyPath,
                                 scriptingLanguage,
                                 invokeAsMethod ? true : false,
                                 minUpdateInterval, newNum);
}



CBvr * CDANumberCreate(IDABehavior ** bvr)
{
    DAComObject<CDANumber> * pNew ;
    
    DAComObject<CDANumber>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDANumber *) pNew;

    return pNew ;
}

STDMETHODIMP
CDANumberFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRNUMBER_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAPoint3::Project(IDACamera *  arg1, IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint3::Project(%lx)", this));
    return CreatePrim2(IID_IDAPoint2, (CRPoint2 * (STDAPICALLTYPE *)(CRPoint3 *, CRCamera *)) CRProject , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint3::get_X(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint3::get_X(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint3 *)) CRGetX , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint3::get_Y(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint3::get_Y(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint3 *)) CRGetY , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint3::get_Z(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint3::get_Z(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint3 *)) CRGetZ , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint3::get_SphericalCoordXYAngle(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint3::get_SphericalCoordXYAngle(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint3 *)) CRSphericalCoordXYAngle , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint3::get_SphericalCoordYZAngle(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint3::get_SphericalCoordYZAngle(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint3 *)) CRSphericalCoordYZAngle , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint3::get_SphericalCoordLength(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint3::get_SphericalCoordLength(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint3 *)) CRSphericalCoordLength , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAPoint3::Transform(IDATransform3 *  arg0, IDAPoint3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAPoint3::Transform(%lx)", this));
    return CreatePrim2(IID_IDAPoint3, (CRPoint3 * (STDAPICALLTYPE *)(CRPoint3 *, CRTransform3 *)) CRTransform , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}



CBvr * CDAPoint3Create(IDABehavior ** bvr)
{
    DAComObject<CDAPoint3> * pNew ;
    
    DAComObject<CDAPoint3>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAPoint3 *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAPoint3Factory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRPOINT3_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDATransform2::Inverse(IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDATransform2::Inverse(%lx)", this));
    return CreatePrim1(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRTransform2 *)) CRInverse , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDATransform2::get_IsSingular(IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDATransform2::get_IsSingular(%lx)", this));
    return CreatePrim1(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRTransform2 *)) CRIsSingular , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}



CBvr * CDATransform2Create(IDABehavior ** bvr)
{
    DAComObject<CDATransform2> * pNew ;
    
    DAComObject<CDATransform2>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDATransform2 *) pNew;

    return pNew ;
}

STDMETHODIMP
CDATransform2Factory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRTRANSFORM2_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAVector3::get_Length(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::get_Length(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector3 *)) CRLength , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::get_LengthSquared(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::get_LengthSquared(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector3 *)) CRLengthSquared , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::Normalize(IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::Normalize(%lx)", this));
    return CreatePrim1(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRVector3 *)) CRNormalize , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::MulAnim(IDANumber *  arg0, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::MulAnim(%lx)", this));
    return CreatePrim2(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRVector3 *, CRNumber *)) CRMul , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::Mul(double arg0, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::Mul(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAVector3, (CRBvrPtr) (::CRMul((CRVector3 *) _bvr.p, /* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAVector3::DivAnim(IDANumber *  arg1, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::DivAnim(%lx)", this));
    return CreatePrim2(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRVector3 *, CRNumber *)) CRDiv , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::Div(double arg1, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::Div(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAVector3, (CRBvrPtr) (::CRDiv((CRVector3 *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAVector3::get_X(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::get_X(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector3 *)) CRGetX , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::get_Y(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::get_Y(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector3 *)) CRGetY , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::get_Z(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::get_Z(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector3 *)) CRGetZ , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::get_SphericalCoordXYAngle(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::get_SphericalCoordXYAngle(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector3 *)) CRSphericalCoordXYAngle , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::get_SphericalCoordYZAngle(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::get_SphericalCoordYZAngle(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector3 *)) CRSphericalCoordYZAngle , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::get_SphericalCoordLength(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::get_SphericalCoordLength(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector3 *)) CRSphericalCoordLength , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAVector3::Transform(IDATransform3 *  arg0, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAVector3::Transform(%lx)", this));
    return CreatePrim2(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRVector3 *, CRTransform3 *)) CRTransform , (IDA2Behavior *) (CBvr *)this, arg0, (void **) ret)?S_OK:Error(); 

}



CBvr * CDAVector3Create(IDABehavior ** bvr)
{
    DAComObject<CDAVector3> * pNew ;
    
    DAComObject<CDAVector3>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAVector3 *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAVector3Factory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRVECTOR3_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}



CBvr * CDAEndStyleCreate(IDABehavior ** bvr)
{
    DAComObject<CDAEndStyle> * pNew ;
    
    DAComObject<CDAEndStyle>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAEndStyle *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAEndStyleFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRENDSTYLE_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDABbox2::get_Min(IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDABbox2::get_Min(%lx)", this));
    return CreatePrim1(IID_IDAPoint2, (CRPoint2 * (STDAPICALLTYPE *)(CRBbox2 *)) CRMin , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDABbox2::get_Max(IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDABbox2::get_Max(%lx)", this));
    return CreatePrim1(IID_IDAPoint2, (CRPoint2 * (STDAPICALLTYPE *)(CRBbox2 *)) CRMax , (IDA2Behavior *) (CBvr *)this, (void **) ret)?S_OK:Error(); 

}



CBvr * CDABbox2Create(IDABehavior ** bvr)
{
    DAComObject<CDABbox2> * pNew ;
    
    DAComObject<CDABbox2>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDABbox2 *) pNew;

    return pNew ;
}

STDMETHODIMP
CDABbox2Factory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRBBOX2_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAEvent::Notify(IDAUntilNotifier * arg1, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAEvent::Notify(%lx)", this));

    PRIMPRECODE1(ret) ;
    DAComPtr<CRUntilNotifier > arg1VAL((CRUntilNotifier *) WrapCRUntilNotifier(arg1),false);
    if (!arg1VAL) return Error();

    CreateCBvr(IID_IDAEvent, (CRBvrPtr) (::CRNotify((CREvent *) _bvr.p, /* NOELARG */ arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAEvent::Snapshot(IDABehavior *  arg1, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAEvent::Snapshot(%lx)", this));
    return CreatePrim2(IID_IDAEvent, (CREvent * (STDAPICALLTYPE *)(CREvent *, CRBvr *)) CRSnapshot , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAEvent::AttachData(IDABehavior *  arg1, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAEvent::AttachData(%lx)", this));
    return CreatePrim2(IID_IDAEvent, (CREvent * (STDAPICALLTYPE *)(CREvent *, CRBvr *)) CRAttachData , (IDA2Behavior *) (CBvr *)this, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAEvent::ScriptCallback(BSTR arg0, BSTR arg2, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAEvent::ScriptCallback(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAEvent, (CRBvrPtr) (::ScriptCallback((CREvent *) _bvr.p, /* NOELARG */ arg0, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAEvent::NotifyScript(BSTR arg1, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAEvent::NotifyScript(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAEvent, (CRBvrPtr) (::NotifyScriptEvent((CREvent *) _bvr.p, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}



CBvr * CDAEventCreate(IDABehavior ** bvr)
{
    DAComObject<CDAEvent> * pNew ;
    
    DAComObject<CDAEvent>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAEvent *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAEventFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CREVENT_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}

STDMETHODIMP
CDAUserData::get_Data(IUnknown * * ret)
{
    TraceTag((tagCOMEntry, "CDAUserData::get_Data(%lx)", this));

    PRIMPRECODE1(ret) ;
    /* NOELRET */ *ret = (::CRGetData((CRUserData *) _bvr.p));
    PRIMPOSTCODE1(ret) ;
}



CBvr * CDAUserDataCreate(IDABehavior ** bvr)
{
    DAComObject<CDAUserData> * pNew ;
    
    DAComObject<CDAUserData>::CreateInstance(&pNew) ;
    
    // hack for IE 4.01 LM to work.  They require the class interface to be returned
    if (pNew && bvr) *bvr = (IDAUserData *) pNew;

    return pNew ;
}

STDMETHODIMP
CDAUserDataFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                   REFIID riid,
                                   void ** ppvObj)
{
    PRIMPRECODE(bool ok = false) ;
    ok = CreateCBvr(riid, CRUninitializedBvr(CRUSERDATA_TYPEID), ppvObj);
    PRIMPOSTCODE(ok?S_OK:E_OUTOFMEMORY) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\bvrti.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "bvrtypes.h"
#include "srvprims.h"

#define ENCODER     10000  // used to encode DISPID
                  
ITypeInfo* BvrComTypeInfoHolder::s_pImportInfo = NULL;
ITypeInfo* BvrComTypeInfoHolder::s_pModBvrInfo = NULL;
ITypeInfo* BvrComTypeInfoHolder::s_pBvr2Info = NULL;
long BvrComTypeInfoHolder::s_dwRef = 0;

HRESULT
BvrComTypeInfoHolder::LoadTypeInfo(LCID lcid, REFIID iid, ITypeInfo** ppInfo)
{
    HRESULT hRes = S_OK;
    
    EnterCriticalSection(&_Module.m_csTypeInfoHolder);

    DAComPtr<ITypeLib> pTypeLib;
    hRes = LoadRegTypeLib(LIBID_DirectAnimation, DA_MAJOR_VERSION, DA_MINOR_VERSION, lcid, &pTypeLib);

    if (SUCCEEDED(hRes)) {
        hRes = pTypeLib->GetTypeInfoOfGuid(iid, ppInfo);

        if (SUCCEEDED(hRes) && s_dwRef == 0) {
            Assert(s_pImportInfo == NULL);
            Assert(s_pModBvrInfo == NULL);
            Assert(s_pBvr2Info == NULL);
            
            hRes = pTypeLib->GetTypeInfoOfGuid(IID_IDAImport,
                                               &s_pImportInfo);
            if (SUCCEEDED(hRes)) {
                hRes = pTypeLib->GetTypeInfoOfGuid(IID_IDAModifiableBehavior,
                                                   &s_pModBvrInfo);
                if (SUCCEEDED(hRes)) {
                    hRes = pTypeLib->GetTypeInfoOfGuid(IID_IDA2Behavior,
                                                       &s_pBvr2Info);
                }
            }
        }
    }

    if (SUCCEEDED(hRes)) {
        Assert(s_pImportInfo);
        Assert(s_pModBvrInfo);
        Assert(s_pBvr2Info);
        Assert(*ppInfo);
        s_dwRef++;
    } else {
        if (s_dwRef == 0) {
            RELEASE(s_pImportInfo);
            RELEASE(s_pModBvrInfo);
            RELEASE(s_pBvr2Info);
        }
        
        RELEASE(*ppInfo);
    }

    LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
    
    return hRes;
}

void
BvrComTypeInfoHolder::FreeTypeInfo()
{
    EnterCriticalSection(&_Module.m_csTypeInfoHolder);
    if (--s_dwRef == 0) {
        RELEASE(s_pImportInfo);
        RELEASE(s_pModBvrInfo);
        RELEASE(s_pBvr2Info);
    }
    LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
}

void
BvrComTypeInfoHolder::AddRef()
{
    EnterCriticalSection(&_Module.m_csTypeInfoHolder);
    m_dwRef++;
    LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
}

void
BvrComTypeInfoHolder::Release()
{
    EnterCriticalSection(&_Module.m_csTypeInfoHolder);
    if (--m_dwRef == 0) {
        if (m_pInfo != NULL) {
            RELEASE(m_pInfo);
            // Only free type info if we had loaded the class specific
            // type info 
            FreeTypeInfo();
        }
    }
    LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
}

HRESULT
BvrComTypeInfoHolder::GetTI(LCID lcid, ITypeInfo** ppInfo)
{
    //If this assert occurs then most likely didn't initialize properly
    Assert(m_pguid != NULL);
    SET_NULL(ppInfo);
    
    HRESULT hRes = S_OK;
    EnterCriticalSection(&_Module.m_csTypeInfoHolder);

    if (m_pInfo == NULL) {
        hRes = LoadTypeInfo(lcid, *m_pguid, &m_pInfo);
    }

    if (SUCCEEDED(hRes)) {
        Assert(m_pInfo);
        Assert(s_pImportInfo);
        Assert(s_pModBvrInfo);
        Assert(s_pBvr2Info);
        Assert(s_dwRef);
        
        if (ppInfo) {
            *ppInfo = m_pInfo;
            m_pInfo->AddRef();
        }
    }
    LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
    return hRes;
}

HRESULT
BvrComTypeInfoHolder::GetTypeInfo(UINT /*itinfo*/,
                                  LCID lcid,
                                  ITypeInfo** pptinfo)
{
    HRESULT hRes = E_POINTER;
    if (pptinfo != NULL)
        hRes = GetTI(lcid, pptinfo);
    return hRes;
}

HRESULT
BvrComTypeInfoHolder::GetIDsOfNames(CRBvrPtr bvr,
                                    REFIID /*riid*/,
                                    LPOLESTR* rgszNames,
                                    UINT cNames,
                                    LCID lcid,
                                    DISPID* rgdispid)
{
    HRESULT hRes = GetTI(lcid, NULL);

    if (SUCCEEDED(hRes)) {
        // Everything should be valid since we succeeded with the
        // GetTI and our current object should have a reference count
        
        Assert(m_pInfo);
        Assert(s_pImportInfo);
        Assert(s_pModBvrInfo);
        Assert(s_pBvr2Info);
        Assert(s_dwRef);
        Assert(m_dwRef);

        ITypeInfo * TIList[] = { m_pInfo,
                                 CRIsImport(bvr)?s_pImportInfo:NULL,
                                 CRIsModifiableBvr(bvr)?s_pModBvrInfo:NULL,
                                 s_pBvr2Info };

        for (int i = 0; i < ARRAY_SIZE(TIList); i++) {
            if (TIList[i]) {
                hRes = TIList[i]->GetIDsOfNames(rgszNames,
                                                cNames,
                                                rgdispid);
            } else {
                hRes = DISP_E_UNKNOWNNAME;
            }

            // TODO: Should probably detect failures which indicate it
            // was the correct interface but just something else was
            // wrong
            
            if (SUCCEEDED(hRes)) {
                if (cNames >= 1) {
                    *rgdispid += (ENCODER*i);
                }
                break;
            }
        }
    }

    return hRes;
}

HRESULT
BvrComTypeInfoHolder::Invoke(CRBvrPtr bvr,
                             IDispatch* pbvr,
                             IDAImport* pimp,
                             IDAModifiableBehavior* pmod,
                             IDA2Behavior* pbvr2,
                             DISPID dispidMember,
                             REFIID riid,
                             LCID lcid,
                             WORD wFlags,
                             DISPPARAMS* pdispparams,
                             VARIANT* pvarResult,
                             EXCEPINFO* pexcepinfo,
                             UINT* puArgErr)
{
    SetErrorInfo(0, NULL);

    HRESULT hRes = GetTI(lcid, NULL);

    if (SUCCEEDED(hRes)) {
        // Everything should be valid since we succeeded with the
        // GetTI and our current object should have a reference count
        
        Assert(m_pInfo);
        Assert(s_pImportInfo);
        Assert(s_pModBvrInfo);
        Assert(s_pBvr2Info);
        Assert(s_dwRef);
        Assert(m_dwRef);

        // These lists must be in the same order and in the same order
        // as getidsofnames
        
        ITypeInfo * TIList[] = { m_pInfo,
                                 CRIsImport(bvr)?s_pImportInfo:NULL,
                                 CRIsModifiableBvr(bvr)?s_pModBvrInfo:NULL,
                                 s_pBvr2Info };

        IDispatch * DispList[] = { pbvr,
                                   pimp,
                                   pmod,
                                   pbvr2 };
        
        // convert the incomming dispid to the correct on and call invoke on the 
        // correct interface.....
        int nOffset;

        // Anything 0 or less (or too high) should just get passed to
        // the default interfaces (0 offset) to handle
        
        if (dispidMember > 0) {
            // Only the low word is relevant - the high word has some
            // misc information in it and is not relevant
            
            nOffset = LOWORD(dispidMember) / ENCODER;
            
            if(nOffset >= ARRAY_SIZE(TIList)) {
                // On an error just call the default interface with
                // the dispId which should be too high
                nOffset = 0;
            } else {
                // Adjust the dispid as appropriate
                dispidMember -= ENCODER * nOffset;
            }
        } else {
            nOffset = 0;
        }

        if (TIList[nOffset]) {
            hRes = TIList[nOffset]->Invoke(DispList[nOffset],
                                           dispidMember,
                                           wFlags,
                                           pdispparams,
                                           pvarResult,
                                           pexcepinfo,
                                           puArgErr);
        } else {
            hRes = DISP_E_UNKNOWNNAME;
        }
    }

    return hRes;
}

void
DeinitializeModule_BvrTI(bool bShutdown)
{
    Assert(!BvrComTypeInfoHolder::s_pImportInfo &&
           !BvrComTypeInfoHolder::s_pModBvrInfo &&
           !BvrComTypeInfoHolder::s_pBvr2Info &&
           BvrComTypeInfoHolder::s_dwRef == 0);

    RELEASE(BvrComTypeInfoHolder::s_pImportInfo);
    RELEASE(BvrComTypeInfoHolder::s_pModBvrInfo);
    RELEASE(BvrComTypeInfoHolder::s_pBvr2Info);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\bvrtypes.h ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/


#ifndef _BVRTYPES_H
#define _BVRTYPES_H

#include "cbvr.h"

//+-------------------------------------------------------------------------
//
//  Class:      BvrComTypeInfoHolder
//
//  Synopsis:
//
//--------------------------------------------------------------------------

class BvrComTypeInfoHolder
{
    // Should be 'protected' but can cause compiler to generate fat code.
  public:
    const GUID* m_pguid;

    ITypeInfo* m_pInfo;
    long m_dwRef;

    static ITypeInfo* s_pImportInfo;
    static ITypeInfo* s_pModBvrInfo;
    static ITypeInfo* s_pBvr2Info;
    static long s_dwRef;

    static HRESULT LoadTypeInfo(LCID lcid, REFIID iid, ITypeInfo** ppInfo);
    static void FreeTypeInfo();
  public:
    HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo);

    void AddRef();
    void Release();
    HRESULT GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    HRESULT GetIDsOfNames(CRBvrPtr bvr,
                          REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                          LCID lcid, DISPID* rgdispid);
    HRESULT Invoke(CRBvrPtr bvr,
                   IDispatch* pbvr,
                   IDAImport* pimp,
                   IDAModifiableBehavior* pmod,
                   IDA2Behavior* pbvr2,
                   DISPID dispidMember, REFIID riid,
                   LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                   EXCEPINFO* pexcepinfo, UINT* puArgErr);
};

//+-------------------------------------------------------------------------
//
//  Class:      CBvrBase
//
//  Synopsis:
//
//--------------------------------------------------------------------------

template <class TInterface,
          const IID * iid>
class ATL_NO_VTABLE CBvrBase :
    public CBvr,
    public TInterface
{
  public:
    CBvrBase() { _tih.AddRef(); }
    ~CBvrBase() { _tih.Release(); }

    STDMETHOD(GetClassName)(BSTR * str)
    { return BvrGetClassName(str); }

    STDMETHOD(Init)(IDABehavior *toBvr)
    { return BvrInit(toBvr); }

    STDMETHOD(Importance)(double relativeImportance,
                          IDABehavior **ppBvr)
    { return BvrImportance(relativeImportance,ppBvr); }

    STDMETHOD(RunOnce)(IDABehavior **bvr)
    { return BvrRunOnce(bvr); }
        
    STDMETHOD(SubstituteTime)(IDANumber *xform, IDABehavior **bvr)
    { return BvrSubstituteTime(xform, bvr); }
        
    STDMETHOD(Hook)(IDABvrHook *notifier, IDABehavior **bvr)
    { return BvrHook(notifier, bvr); }

    STDMETHOD(Duration)(double duration, IDABehavior **bvr)
    { return BvrDuration(duration, bvr); }
    
    STDMETHOD(DurationAnim)(IDANumber *duration, IDABehavior **bvr)
    { return BvrDuration(duration, bvr); }
    
    STDMETHOD(Repeat)(LONG count, IDABehavior **bvr)
    { return BvrRepeat(count, bvr); }

    STDMETHOD(RepeatForever)(IDABehavior **bvr)
    { return BvrRepeatForever(bvr); }


    STDMETHOD(IsReady)(VARIANT_BOOL bBlock, VARIANT_BOOL *b)
    { return BvrIsReady(bBlock,b); }

    STDMETHOD(SwitchTo)(IDABehavior *switchTo)
    { return BvrSwitchTo(switchTo); }

    STDMETHOD(SwitchToNumber)(double numToSwitchTo)
    { return BvrSwitchToNumber(numToSwitchTo); }
    
    STDMETHOD(SwitchToString)(BSTR strToSwitchTo)
    { return BvrSwitchToString(strToSwitchTo); }


    STDMETHOD(put_CurrentBehavior)(VARIANT bvr)
    { return BvrSetCurrentBvr(bvr); }

    STDMETHOD(get_CurrentBehavior)(IDABehavior **bvr)
    { return BvrGetCurrentBvr(bvr); }


    STDMETHOD(ImportStatus)(LONG * status)
    { return BvrImportStatus(status); }

    STDMETHOD(ImportCancel)()
    { return BvrImportCancel(); }
    
    STDMETHOD(get_ImportPriority)(float * prio)
    { return BvrGetImportPrio(prio); }
    
    STDMETHOD(put_ImportPriority)(float prio)
    { return BvrSetImportPrio(prio); }

    STDMETHOD(SwitchToEx)(IDABehavior *switchTo, DWORD dwFlags)
    { return BvrSwitchTo(switchTo, true, dwFlags); }
    
    STDMETHOD(ApplyPreference)(BSTR pref, VARIANT val, IDABehavior **bvr)
    { return BvrApplyPreference(pref, val, bvr); }

    STDMETHOD(ExtendedAttrib)(BSTR attrib, VARIANT val, IDABehavior **bvr)
    { return BvrExtendedAttrib(attrib, val, bvr); }
    
    // Need to copy this here since multiple interface need this
    // implemented
    
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {*pctinfo = 1; return S_OK;}

    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    { return _tih.GetTypeInfo(itinfo, lcid, pptinfo); }

    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                             LCID lcid, DISPID* rgdispid)
    { return _tih.GetIDsOfNames(_bvr, riid, rgszNames, cNames, lcid, rgdispid);}

    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
                      LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, UINT* puArgErr)
    { return _tih.Invoke(_bvr,
                         (TInterface *)this,this,this,this,
                         dispidMember, riid, lcid,
                         wFlags, pdispparams, pvarResult,
                         pexcepinfo, puArgErr); }
    
    virtual REFIID GetIID() { return *iid; }
  protected:
    static BvrComTypeInfoHolder _tih;
    static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
    { return _tih.GetTI(lcid, ppInfo); }
};

template <class T, const IID* piid>
BvrComTypeInfoHolder
CBvrBase<T, piid>::_tih =
{piid, NULL, 0};


enum PickableType {
    PT_IMAGE,
    PT_IMAGE_OCCLUDED,
    PT_GEOM,
    PT_GEOM_OCCLUDED,
};

bool PickableHelper (CRBvr*, PickableType, IDAPickableResult**);


#endif /* _BVRTYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\bvrtypes.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    IDABehavior implementation

*******************************************************************************/

#include "headers.h"
#include "cbvr.h"
#include "cview.h"
#include "drawsurf.h"
#include "srvprims.h"
#include "comcb.h"
#include "statics.h"
#include "control/dxactrl.h"
#include "bvrtypes.h"
#include "propanim.h"
#include "results.h"

DeclareTag(tagBvrTypes, "CBvr", "Bvr Types");

//+-------------------------------------------------------------------------
//
//  Initialization
//
//--------------------------------------------------------------------------

DACComModule _Module;

BEGIN_OBJECT_MAP(COMObjectMap)
    OBJECT_ENTRY(CLSID_DAStatics, CDAStatics)
    OBJECT_ENTRY(CLSID_DAView, CView)
    OBJECT_ENTRY(CLSID_DAViewerControl, CDAViewerControlWindowless)
    OBJECT_ENTRY(CLSID_DAViewerControlWindowed, CDAViewerControlWindowed)
END_OBJECT_MAP();

extern _ATL_OBJMAP_ENTRY PrimObjectMap0[];
extern _ATL_OBJMAP_ENTRY PrimObjectMap1[];
extern _ATL_OBJMAP_ENTRY PrimObjectMap2[];

#if DEVELOPER_DEBUG
LONG g_locksSinceLastTick = 0;
LONG g_unlocksSinceLastTick = 0;

LONG
GetLocksSinceLastTick()
{
    return g_locksSinceLastTick;
}

LONG
GetUnlocksSinceLastTick()
{
    return g_unlocksSinceLastTick;
}

void
ResetLockCounts()
{
    g_locksSinceLastTick = 0;
    g_unlocksSinceLastTick = 0;
}

#endif

LONG
DACComModule::Lock()
{
#if DEVELOPER_DEBUG
    InterlockedIncrement(&g_locksSinceLastTick);
#endif

    // Can't depend on value return from Lock to be accurate.  Since
    // the CRConnect can be called multiple times w/o a problem simply
    // check the internal variable to see if it is 0.  This should
    // never cause anything except multiple calls to CRConnect
    
    bool bNeedConnect = (GetLockCount() == 0);

    LONG l = CComModule::Lock();

    if (bNeedConnect) {
        CRConnect(hInst);
    }

    return l;
}

LONG
DACComModule::Unlock()
{
#if DEVELOPER_DEBUG
    InterlockedIncrement(&g_unlocksSinceLastTick);
#endif

    LONG l = CComModule::Unlock();
    if (l) return l;
    CRDisconnect(hInst);
    return 0;
}

#if DEVELOPER_DEBUG
typedef map<void *, const char *> ObjectMap;
ObjectMap *objMap = NULL;

void
DACComModule::AddComPtr(void *ptr, const char * name)
{
    EnterCriticalSection(&m_csObjMap);
    (*objMap)[ptr] = name;
    LeaveCriticalSection(&m_csObjMap) ;
}

void
DACComModule::RemoveComPtr(void *ptr)
{
    EnterCriticalSection(&m_csObjMap);
    objMap->erase(ptr);
    LeaveCriticalSection(&m_csObjMap) ;
}

void
DACComModule::DumpObjectList()
{
    if (objMap) {
        EnterCriticalSection(&m_csObjMap);
        if (objMap->size() > 0 || GetLockCount() > 0) {
            OutputDebugString ("DANIM.DLL: Detected unfreed COM pointers\n");
            OutputDebugString ("Listing pointers and types:\n");
            for (ObjectMap::iterator i = objMap->begin();
                 i != objMap->end();
                 i++) {

                char buf[1024];

                wsprintf(buf, "%#x:", (*i).first);
                OutputDebugString(buf);

                if ((*i).second)
                    OutputDebugString((*i).second);

                OutputDebugString("\n");
            }
        }
             
        LeaveCriticalSection(&m_csObjMap) ;
    }
}

void
DumpCOMObjectList()
{
    _Module.DumpObjectList();
}


#endif

#define MAX_OBJECT_MAP_SIZE 50

// Set the max size to something big so we do not have a problem
_ATL_OBJMAP_ENTRY FullObjectMap[MAX_OBJECT_MAP_SIZE + 1];

// =========================================
// Initialization
// =========================================

int
CountObjectMapEntries(_ATL_OBJMAP_ENTRY *objmap)
{
    for (int i = 0;objmap[i].pclsid != NULL;i++) ;

    return i;
}

int
CopyOneMap(int curnum, _ATL_OBJMAP_ENTRY *objmap)
{
    if (objmap) {
        int num = CountObjectMapEntries(objmap);
        int size = num * sizeof (_ATL_OBJMAP_ENTRY);

        Assert ((curnum + num) < MAX_OBJECT_MAP_SIZE);
        
        memcpy(&FullObjectMap[curnum], objmap, size);

        return curnum + num;
    } else {
        Assert (curnum < MAX_OBJECT_MAP_SIZE);
        memset (&FullObjectMap[curnum], 0, sizeof(_ATL_OBJMAP_ENTRY));

        return curnum;
    }
}

void
CreateFullObjectMap()
{
    // Copy base object map
    int curnum = 0;

    curnum = CopyOneMap(curnum, COMObjectMap);
    curnum = CopyOneMap(curnum, PrimObjectMap0);
    curnum = CopyOneMap(curnum, PrimObjectMap1);
    curnum = CopyOneMap(curnum, PrimObjectMap2);
    curnum = CopyOneMap(curnum, NULL); // This will terminate it

    Assert (curnum < MAX_OBJECT_MAP_SIZE);
}

void
InitializeModule_ATL()
{
    // Combine the object entry lists
    CreateFullObjectMap();
    
    _Module.Init(FullObjectMap, hInst);

#if DEVELOPER_DEBUG
    objMap = new ObjectMap;
#endif
}

void
DeinitializeModule_ATL(bool bShutdown)
{
#if DEVELOPER_DEBUG
    DumpCOMObjectList();
    
    delete objMap;
    objMap = NULL;
#endif
    _Module.Term();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\cbvr.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    IDABehavior implementation

Revision:

--*/

#include "headers.h"
#include "cbvr.h"
#include "srvprims.h"
#include "comcb.h"
#include "comconv.h"

DeclareTag(tagBvr, "CBvr", "CBvr methods");

#pragma warning(disable:4355)  // using 'this' in constructor

//+-------------------------------------------------------------------------
//
//  Method:     CBvr::CBvr
//
//  Synopsis:   Constructor
//
//  Arguments:  Bvr bvr - bvr to wrap
//
//--------------------------------------------------------------------------

CBvr::CBvr()
: _bvr(NULL)
{
    TraceTag((tagBvr, "CBvr(%lx)::CBvr", this));
}


//+-------------------------------------------------------------------------
//
//  Method:     CBvr::~CBvr
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CBvr::~CBvr()
{
    TraceTag((tagBvr, "CBvr(%lx)::~CBvr", this));
}

void
CBvr::SetBvr(CRBvrPtr bvr)
{
    _bvr = bvr;
}

HRESULT
CBvr::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return BvrError(str,hr);
    else
        return hr;
}

HRESULT
CBvr::BvrGetClassName(BSTR * str)
{
    TraceTag((tagBvr,
              "CBvr(%lx)::GetClassName()",
              this));
    
    CHECK_RETURN_SET_NULL(str);
    
    if ((*str = A2BSTR(GetName())) == NULL)
        return E_OUTOFMEMORY;
    
    return S_OK;
}
    
HRESULT
CBvr::BvrInit(IDABehavior *toBvr)
{
    PRIMPRECODE0(ok);

    MAKE_BVR_NAME(crbvr, toBvr);

    ok = CRInit(_bvr, crbvr);

    PRIMPOSTCODE0(ok);
}

HRESULT
CBvr::BvrImportance(double relativeImportance,
                    IDABehavior **bvr)
{
    PRIMPRECODE1(bvr);
    
    *bvr = CreateCBvr(CRImportance(_bvr, relativeImportance)) ;
    
    PRIMPOSTCODE1(bvr);
}

HRESULT
CBvr::BvrRunOnce(IDABehavior **bvr)
{
    PRIMPRECODE1(bvr) ;
    *bvr = CreateCBvr(CRRunOnce(_bvr));
    PRIMPOSTCODE1(bvr) ;
}
    
HRESULT
CBvr::BvrSubstituteTime(IDANumber *xform,
                        IDABehavior **bvr)
{
    PRIMPRECODE1(bvr) ;

    MAKE_BVR_TYPE_NAME(CRNumberPtr, xfbvr, xform);

    *bvr = CreateCBvr(CRSubstituteTime(_bvr, xfbvr));
    
    PRIMPOSTCODE1(bvr) ;
}

HRESULT
CBvr::BvrSwitchTo(IDABehavior *switchTo, bool bOverrideFlags, DWORD dwFlags)
{
    PRIMPRECODE0(ok);

    MAKE_BVR_NAME(crbvr, switchTo);

    ok = CRSwitchTo(_bvr, crbvr, bOverrideFlags, dwFlags, 0);
    
    PRIMPOSTCODE0(ok);
}

HRESULT
CBvr::BvrHook(IDABvrHook *notifier, IDABehavior **bvr)
{
    PRIMPRECODE1(bvr) ;

    MAKE_COM_TYPE_NAME(CRBvrHook, crnotifier, WrapCRBvrHook(notifier));

    *bvr = CreateCBvr(CRHook(_bvr, crnotifier));
    
    PRIMPOSTCODE1(bvr) ;
}

HRESULT
CBvr::BvrDuration(double duration, IDABehavior **bvr)
{
    PRIMPRECODE1(bvr) ;
    *bvr = CreateCBvr(CRDuration(_bvr, duration));
    PRIMPOSTCODE1(bvr) ;
}

HRESULT
CBvr::BvrDuration(IDANumber *duration, IDABehavior **bvr)
{
    PRIMPRECODE1(bvr) ;
    MAKE_BVR_TYPE_NAME(CRNumberPtr, crbvr, duration);
    *bvr = CreateCBvr(CRDuration(_bvr, crbvr));
    PRIMPOSTCODE1(bvr) ;
}

HRESULT
CBvr::BvrRepeat(long count, IDABehavior **bvr)
{
    PRIMPRECODE1(bvr) ;
    *bvr = CreateCBvr(::CRRepeat(_bvr, count));
    PRIMPOSTCODE1(bvr) ;
}

HRESULT
CBvr::BvrRepeatForever(IDABehavior **bvr)
{
    PRIMPRECODE1(bvr) ;
    *bvr = CreateCBvr(::CRRepeatForever(_bvr));
    PRIMPOSTCODE1(bvr) ;
}

HRESULT
CBvr::BvrSwitchToNumber(double numToSwitchTo)
{
    PRIMPRECODE0(ok);
    ok = CRSwitchToNumber((CRNumberPtr) _bvr.p, numToSwitchTo);
    PRIMPOSTCODE0(ok);
}

HRESULT
CBvr::BvrSwitchToString(BSTR strToSwitchTo)
{
    PRIMPRECODE0(ok);
    ok = CRSwitchToString((CRStringPtr) _bvr.p, strToSwitchTo);
    PRIMPOSTCODE0(ok);
}

STDMETHODIMP
CBvr::InterfaceSupportsErrorInfo(REFIID riid)
{
    if (InlineIsEqualGUID(riid,IID_IDABehavior) ||
        InlineIsEqualGUID(riid,GetIID()) ||
        InlineIsEqualGUID(riid,IID_IDAImport) ||
        InlineIsEqualGUID(riid,IID_IDAModifiableBehavior) ||
        InlineIsEqualGUID(riid,IID_IDA2Behavior))
        return S_OK;

    return S_FALSE;
}

HRESULT
CBvr::BvrIsReady(VARIANT_BOOL bBlock, VARIANT_BOOL *b)
{
    PRIMPRECODE1(b);
    *b = true;
    PRIMPOSTCODE1(b);
}

HRESULT
CBvr::BvrGetCurrentBvr(IDABehavior ** bvr)
{
    PRIMPRECODE1(bvr);
    Assert (CRIsModifiableBvr(_bvr));
    *bvr = CreateCBvr(CRGetModifiableBvr(_bvr));
    PRIMPOSTCODE1(bvr);
}

HRESULT
CBvr::BvrSetCurrentBvr(VARIANT value)
{
    PRIMPRECODE0(ok);

    Assert (CRIsModifiableBvr(_bvr));

    CRBvrPtr crbvr = VariantToBvr(value,CRGetTypeId(_bvr));
    if (!crbvr) return Error();

    ok = CRSwitchTo(_bvr, crbvr, false, 0, 0);

    PRIMPOSTCODE0(ok);
}

HRESULT
CBvr::BvrImportStatus(LONG * status)
{
    PRIMPRECODE(CHECK_RETURN_NULL(status));

    Assert (CRIsImport(_bvr));

    *status = CRImportStatus(_bvr);

    PRIMPOSTCODE(S_OK);
}

HRESULT
CBvr::BvrImportCancel()
{
    PRIMPRECODE0(ok);

    Assert (CRIsImport(_bvr));

    ok = CRImportCancel(_bvr);

    PRIMPOSTCODE0(ok);
}

HRESULT
CBvr::BvrGetImportPrio(float * prio)
{
    PRIMPRECODE(CHECK_RETURN_NULL(prio));

    Assert (CRIsImport(_bvr));
    
    *prio = CRGetImportPriority(_bvr);

    PRIMPOSTCODE(S_OK);
}

HRESULT
CBvr::BvrSetImportPrio(float prio)
{
    PRIMPRECODE0(ok);

    Assert (CRIsImport(_bvr));
    
    ok = CRSetImportPriority(_bvr,prio);

    PRIMPOSTCODE0(ok);
}

HRESULT
CBvr::BvrApplyPreference(BSTR pref, VARIANT val, IDABehavior **bvr)
{
    PRIMPRECODE1(bvr);
    CRBvrPtr b = CRBvrApplyPreference(_bvr, pref, val);
    *bvr = CreateCBvr(b);
    PRIMPOSTCODE1(bvr);
}


HRESULT
CBvr::BvrExtendedAttrib(BSTR arg1,
                        VARIANT arg2,
                        IDABehavior **ret)
{
    TraceTag((tagCOMEntry, "CBvr::ExtendedAttrib(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRBvr * arg0VAL;
    arg0VAL = (CRBvr *) (_bvr);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDABehavior,
               (CRBvrPtr) (::CRExtendedAttrib(arg0VAL, arg1, arg2)),
               (void **) ret);
    
    PRIMPOSTCODE1(ret) ;
}


HRESULT WINAPI
CBvr::InternalQueryInterface(CBvr* pThis,
                             const _ATL_INTMAP_ENTRY* pEntries,
                             REFIID iid,
                             void** ppvObject)
{
    if (InlineIsEqualGUID(iid, __uuidof(CBvr))) {
        *ppvObject = pThis->_bvr;
        return S_OK;
    } else if (InlineIsEqualGUID(iid, IID_IDAImport)) {
        if (!CRIsImport(pThis->_bvr))
            return E_NOINTERFACE;
    } else if (InlineIsEqualGUID(iid, IID_IDAModifiableBehavior)) {
        if (!CRIsModifiableBvr(pThis->_bvr))
            return E_NOINTERFACE;
    }
    
    return CComObjectRootEx<CComMultiThreadModelNoCS>::InternalQueryInterface((void *)pThis,
                                                                              pEntries,
                                                                              iid,
                                                                              ppvObject);
}
        
//+-------------------------------------------------------------------------
//
//  Creation function table
//
//--------------------------------------------------------------------------

static list <TypeInfoEntry> * createList = NULL ;

void
AddEntry (TypeInfoEntry & ce)
{
    createList->push_back (ce) ;
}

TypeInfoEntry *
GetTypeInfoEntry (CR_BVR_TYPEID ti)
{
    for (list <TypeInfoEntry>::iterator i = createList->begin() ;
         i != createList->end();
         i++) {

        if (ti == (*i).typeInfo)
            return &(*i) ;
    }

    Assert (!"Tried to use unsupported type.");
    CRSetLastError(E_UNEXPECTED,NULL);
    
    return NULL ;
}

//+-------------------------------------------------------------------------
//
//  Function:     CreateCBvr
//
//--------------------------------------------------------------------------

bool
CreateCBvr(REFIID riid,
           CRBvrPtr bvr,
           void ** ppv)
{
    bool ret = false;
    
    if (bvr) {
        TypeInfoEntry * entry = GetTypeInfoEntry(CRGetTypeId(bvr)) ;

        if (entry) {
            CBvr * c = entry->cbvrCreateFun(NULL);

            if (c) {
                c->SetBvr(bvr);
                
                HRESULT hr = ((IDA2Behavior *) c)->QueryInterface(riid, ppv);
                
                if (FAILED(hr)) {
                    delete c;
                    CRSetLastError(hr, NULL);
                } else {
                    ret = true;
                }
            } else {
                CRSetLastError(E_OUTOFMEMORY, NULL);
            }
        }
    }

    return ret;
}

IDABehavior *
CreateCBvr(CRBvrPtr bvr)
{
    IDABehavior * ret = NULL;
    
    if (bvr) {
        TypeInfoEntry * entry = GetTypeInfoEntry(CRGetTypeId(bvr)) ;

        if (entry) {
            // This is a hack for LM since they expect the full class
            // pointer to be returned when IDABehavior is returned
            CBvr * c = entry->cbvrCreateFun(&ret);

            if (c) {
                c->SetBvr(bvr);

                Assert (ret);
                ret->AddRef();
            } else {
                CRSetLastError(E_OUTOFMEMORY, NULL);
            }
        }
    } else {
        CRSetLastError(E_INVALIDARG, NULL);
    }

    return ret;
}

CRBvrPtr GetBvr(IUnknown * pbvr)
{
    CRBvrPtr bvr = NULL;

    if (pbvr) {
        pbvr->QueryInterface(__uuidof(CBvr),(void **)&bvr);
    }
    
    if (bvr == NULL) {
        CRSetLastError(E_INVALIDARG, NULL);
    }
                
    return bvr;
}

CRSTDAPI_(bool)
CRBvrToCOM(CRBvrPtr bvr,
           REFIID riid,
           void ** ppv)
{
    if (!ppv) {
        CRSetLastError(E_POINTER, NULL);
        return false;
    }

    *ppv = NULL;
    
    if (bvr == NULL) {
        CRSetLastError(E_INVALIDARG, NULL);
        return false;
    }

    return CreateCBvr(riid, bvr, ppv);
}

CRSTDAPI_(CRBvrPtr)
COMToCRBvr(IUnknown * pbvr)
{
    return GetBvr(pbvr);
}

extern void InitClasses0();
extern void InitClasses1();
extern void InitClasses2();

void
InitializeModule_CBvr()
{
    createList = NEW list <TypeInfoEntry> ;
    InitClasses0 () ;
    InitClasses1 () ;
    InitClasses2 () ;
}

void
DeinitializeModule_CBvr(bool bShutdown)
{
    delete createList ;
    createList = NULL ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\comcb.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _COMCB_H
#define _COMCB_H

CRUntilNotifierPtr WrapCRUntilNotifier(IDAUntilNotifier * notifier);
CRUntilNotifierPtr WrapScriptCallback(BSTR function, BSTR language);

CRBvrHookPtr WrapCRBvrHook(IDABvrHook *hook);

// Call arbitrary script on the current HTML page.
HRESULT CallScriptOnPage(BSTR scriptSourceToInvoke,
                         BSTR scriptLanguage,
                         VARIANT *retVal);

CRBvrPtr UntilNotifyScript(CRBvrPtr b0,
                           CREventPtr event,
                           BSTR scriptlet);

CREventPtr NotifyScriptEvent(CREventPtr event,
                             BSTR scriptlet);

CREventPtr ScriptCallback(BSTR function,
                          CREventPtr event,
                          BSTR language);

// This is because we expect the this pointer to be first
inline CREventPtr ScriptCallback(CREventPtr event,
                                 BSTR function,
                                 BSTR language)
{ return ScriptCallback(function, event, language); }

#endif /* _COMCB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\cbvr.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _CBVR_H
#define _CBVR_H

#include "engine.h"
#include "privinc/util.h"
#include "comconv.h"

#pragma warning(disable:4355)  // using 'this' in constructor

//+-------------------------------------------------------------------------
//
//  Class:      CBvr
//
//  Synopsis:
//
//--------------------------------------------------------------------------

class
ATL_NO_VTABLE
__declspec(uuid("2C19B7AE-C8BE-11d0-8794-00C04FC29D46"))
CBvr :
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public IObjectSafetyImpl<CBvr>,
    public ISupportErrorInfo,
    public IDAImport,
    public IDAModifiableBehavior,
    public IDA2Behavior
{
  public:
    CBvr() ;
    virtual ~CBvr() ;

    CRBvrPtr            GetBvr () { return _bvr ; }
    void                SetBvr (CRBvrPtr b);
    
    BEGIN_COM_MAP(CBvr)
        COM_INTERFACE_ENTRY2(IDispatch,IDA2Behavior)
        COM_INTERFACE_ENTRY(IDA2Behavior)
        COM_INTERFACE_ENTRY(IDAImport)
        COM_INTERFACE_ENTRY(IDAModifiableBehavior)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP();

    static HRESULT WINAPI
        InternalQueryInterface(CBvr* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject);
        
    HRESULT BvrGetClassName(BSTR * str);
    HRESULT BvrInit(IDABehavior *toBvr);
    HRESULT BvrImportance(double relativeImportance,
                          IDABehavior **ppBvr);
    HRESULT BvrRunOnce(IDABehavior **bvr);
    HRESULT BvrSubstituteTime(IDANumber *xform, IDABehavior **bvr);
    HRESULT BvrHook(IDABvrHook *notifier, IDABehavior **bvr);

    HRESULT BvrDuration(double duration, IDABehavior **bvr);
    HRESULT BvrDuration(IDANumber *duration, IDABehavior **bvr);
    HRESULT BvrRepeat(LONG count, IDABehavior **bvr);
    HRESULT BvrRepeatForever(IDABehavior **bvr);
    HRESULT BvrIsReady(VARIANT_BOOL bBlock, VARIANT_BOOL * b);
    HRESULT BvrSwitchTo(IDABehavior *switchTo, bool bOverrideFlags = false, DWORD dwFlags = 0);
    HRESULT BvrSwitchToNumber(double numToSwitchTo);
    HRESULT BvrSwitchToString(BSTR strToSwitchTo);
        
    HRESULT BvrImportStatus(LONG * status);
    HRESULT BvrImportCancel();
    HRESULT BvrGetImportPrio(float * prio);
    HRESULT BvrSetImportPrio(float prio);

    HRESULT BvrGetCurrentBvr(IDABehavior ** bvr);
    HRESULT BvrSetCurrentBvr(VARIANT bvr);

    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    HRESULT BvrApplyPreference(BSTR pref, VARIANT val, IDABehavior **bvr);

    HRESULT BvrExtendedAttrib(BSTR attrib, VARIANT val, IDABehavior **bvr);

    virtual CR_BVR_TYPEID GetTypeInfo () = 0 ;
    virtual const char * GetName () = 0 ;
    virtual REFIID GetIID() = 0 ;
  protected:
    CRPtr<CRBvr> _bvr;
    
    HRESULT Error();
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr) = 0;

    bool GetPixelMode() { return false; }
};

bool CreateCBvr(REFIID riid,
                CRBvrPtr bvr,
                void ** ppv) ;
IDABehavior * CreateCBvr(CRBvrPtr bvr) ;

CRBvrPtr GetBvr(IUnknown * pbvr);

inline CRBvrPtr GetBvr(IDABehavior * pbvr)
{ return GetBvr((IUnknown *) pbvr); }

CR_BVR_TYPEID GetTypeInfoFromName(const char * lpszClassName) ;

typedef CBvr * (* CBVR_CREATEFUN) (IDABehavior **) ;

struct TypeInfoEntry
{
    TypeInfoEntry ()
    : typeInfo(CRUNKNOWN_TYPEID),
      cbvrCreateFun(NULL)
    {}

    TypeInfoEntry (CR_BVR_TYPEID ti,
                   CBVR_CREATEFUN c)
    : typeInfo(ti),
      cbvrCreateFun(c)
    {}

    TypeInfoEntry & operator= (const TypeInfoEntry & tie) {
        memcpy(this,&tie,sizeof(*this)) ;
        return *this ;
    }
    
    bool operator<(const TypeInfoEntry &t) const {
        return this < &t ;
    }

    bool operator>(const TypeInfoEntry &t) const {
        return this > &t ;
    }

    bool operator!=(const TypeInfoEntry &t) const {
        return !(*this == t) ;
    }

    bool operator==(const TypeInfoEntry &t) const {
        return (memcmp (this, &t, sizeof(*this)) != 0) ;
    }

    CR_BVR_TYPEID typeInfo ;
    CBVR_CREATEFUN cbvrCreateFun ;
} ;

void AddEntry (TypeInfoEntry & ce);

#define MAKE_BVR_TYPE_NAME(type,name,bvr) \
    type name; name = (type) ::GetBvr(bvr); \
    if (!name) goto done
    
#define MAKE_BVR_NAME(name,bvr) MAKE_BVR_TYPE_NAME(CRBvrPtr,name,bvr)

#define MAKE_BVR_TYPE(type,bvr) MAKE_BVR_TYPE_NAME(type, bvr##CRBvr, bvr)
#define MAKE_BVR(bvr) MAKE_BVR_TYPE(CRBvrPtr,bvr)

#define MAKE_COM_TYPE_NAME(type,name,bvr) \
    DAComPtr<type> name(bvr,false); \
    if (!name) goto done
    
#define MAKE_COM_TYPE(type,bvr) MAKE_COM_TYPE_NAME(type,bvr##COM,bvr)

#endif /* _CBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\comconv.cpp ===
/*******************************************************************************
Copyright (c) 1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/


#include "headers.h"
#include "comconv.h"
#include "cbvr.h"

CRBvrPtr
RateToNumBvr(CRBvrPtr d, CRBvrPtr bStart)
{
    CRNumberPtr b = NULL;

    if (d) {
        b = CRMul((CRNumberPtr) d, CRLocalTime());

        if (b && bStart) {
            b = CRAdd(b,(CRNumberPtr)bStart);
        }
    }

    return (CRBvrPtr) b;
}

CRBvrPtr
PixelToNumBvr(double d)
{
    if (pixelConst != 0.0) {
        return (CRBvrPtr) CRCreateNumber(PixelToNum(d));
    } else {
        return PixelToNumBvr((CRBvrPtr) CRCreateNumber(d));
    }
}

CRBvrPtr
PixelYToNumBvr(double d)
{
    if (pixelConst != 0.0) {
        return (CRBvrPtr) CRCreateNumber(PixelYToNum(d));
    } else {
        return PixelYToNumBvr((CRBvrPtr) CRCreateNumber(d));
    }
}

#define DISPID_GETSAFEARRAY -2700

#define IS_VARTYPE(x,vt) ((V_VT(x) & VT_TYPEMASK) == (vt))
#define IS_VARIANT(x) IS_VARTYPE(x,VT_VARIANT)
#define GET_VT(x) (V_VT(x) & VT_TYPEMASK)

SafeArrayAccessor::SafeArrayAccessor(VARIANT & v,
                                     bool bPixelMode,
                                     CR_BVR_TYPEID ti,
                                     bool canBeNull,
                                     bool entriesCanBeNull)
: _inited(false),
  _ti(ti),
  _bPixelMode(bPixelMode),
  _isVar(false),
  _s(NULL),
  _entriesCanBeNull(entriesCanBeNull),
  _numObjects(0)
{
    HRESULT hr;
    VARIANT *pVar;

    // Check if it is a reference to another variant
    
    if (V_ISBYREF(&v) && !V_ISARRAY(&v) && IS_VARIANT(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    // Check for an array
    if (!V_ISARRAY(pVar)) {
        // For JSCRIPT
        // See if it is a IDispatch and see if we can get a safearray from
        // it
        if (!IS_VARTYPE(pVar,VT_DISPATCH)) {
            if (canBeNull && (IS_VARTYPE(pVar, VT_EMPTY) ||
                              IS_VARTYPE(pVar, VT_NULL))) {

                
                // if we allow empty, then just set the safearray
                // to null.
                _s = NULL;
                _v = NULL;
                _ubound = _lbound = 0;
                _numObjects = 0;
                _inited = true;
                return;
            } else {
                CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
                return;
            }
        }

        IDispatch * pdisp;
        
        if (V_ISBYREF(pVar))
            pdisp = *V_DISPATCHREF(pVar);
        else
            pdisp = V_DISPATCH(pVar);
    
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
        
        // Need to pass in a VARIANT that we own and will free.  Use
        // the internal _retVar parameter
        
        hr = pdisp->Invoke(DISPID_GETSAFEARRAY,
                           IID_NULL,
                           LOCALE_USER_DEFAULT,
                           DISPATCH_METHOD|DISPATCH_PROPERTYGET,
                           &dispparamsNoArgs,
                           &_retVar, NULL, NULL);
        
        if (FAILED(hr)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
        
        // No need to check for a reference since you cannot return
        // VARIANT references
        pVar = &_retVar;
        
        // Check for an array
        if (!V_ISARRAY(pVar)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
    }
    
    // If it is an object then we know how to handle it
    if (IS_VARTYPE(pVar,VT_UNKNOWN) ||
        IS_VARTYPE(pVar,VT_DISPATCH)) {
        _type = SAT_OBJECT;
        _vt = VT_UNKNOWN;
    } else {
        switch (ti) {
          case CRNUMBER_TYPEID: 
            _type = SAT_NUMBER;
            _vt = VT_R8;
            break;
          case CRPOINT2_TYPEID:
          case CRVECTOR2_TYPEID:
            _type = SAT_POINT2;
            _vt = VT_R8;
            break;
          case CRPOINT3_TYPEID:
          case CRVECTOR3_TYPEID:
            _type = SAT_POINT3;
            _vt = VT_R8;
            break;
          default:
            _type = SAT_OBJECT;
            _vt = VT_UNKNOWN;
            break;
        }

        // If it is a variant then just delay the check
        if (IS_VARIANT(pVar))
            _isVar = true;
        // Check the type to see if it is one of the options
        else if (!IS_VARTYPE(pVar,_vt)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
    }

    if (V_ISBYREF(pVar))
        _s = *V_ARRAYREF(pVar);
    else
        _s = V_ARRAY(pVar);
    
    if (_s == NULL) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }

    if (SafeArrayGetDim(_s) != 1) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }

    hr = SafeArrayGetLBound(_s,1,&_lbound);
        
    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    hr = SafeArrayGetUBound(_s,1,&_ubound);
        
    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    hr = SafeArrayAccessData(_s,(void **)&_v);

    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    _inited = true;

    // If it is a variant see if they are objects or not

    if (_isVar) {
        if (GetArraySize() > 0) {
            // Check the first argument to see its type
            // If it is not an object then we assume we will need to
            // use the alternative type.

            VARIANT * pVar = &_pVar[0];

            // Check if it is a reference to another variant
            
            if (V_ISBYREF(pVar) && !V_ISARRAY(pVar) && IS_VARIANT(pVar))
                pVar = V_VARIANTREF(pVar);

            // Check if it is an object
            if (IS_VARTYPE(pVar,VT_UNKNOWN) ||
                IS_VARTYPE(pVar,VT_DISPATCH)) {
                _type = SAT_OBJECT;
                _vt = VT_UNKNOWN;
            }
        } else {
            // If we have no elements then just assume they were objects
            _type = SAT_OBJECT;
            _vt = VT_UNKNOWN;
        }
    }

    int ElmsPerObject;
    
    switch (_type) {
      default:
        ElmsPerObject = 1;
        break;
      case SAT_POINT2:
        ElmsPerObject = 2;
        break;
      case SAT_POINT3:
        ElmsPerObject = 3;
        break;
    }

    _numObjects = GetArraySize() / ElmsPerObject;
}

SafeArrayAccessor::~SafeArrayAccessor()
{
    if (_inited && _s)
        SafeArrayUnaccessData(_s);
}

CRBvrPtr *
SafeArrayAccessor::ToBvrArray(CRBvrPtr *bvrArray)
{
    HRESULT hr;
    int i;

    if (!_inited){
        CRSetLastError(DISP_E_TYPEMISMATCH, NULL);
        goto Error;
    }
    
    if (!bvrArray) {
        CRSetLastError(E_OUTOFMEMORY, NULL);
        goto Error;
    }
    
    for (i = 0; i < _numObjects; i++) {
        CRBvrPtr bvr;
        
        switch (_type) {
          case SAT_OBJECT:
            {
                IUnknown * punk;
                
                if (_isVar) {
                    CComVariant var;

                    if (IS_VARTYPE(&_pVar[i], VT_NULL) ||
                        IS_VARTYPE(&_pVar[i], VT_EMPTY)) {
                        
                        punk = NULL;
                        
                    } else {
                        
                        HRESULT hr = var.ChangeType(VT_UNKNOWN, &_pVar[i]);
                    
                        if (FAILED(hr)) {
                            CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                            goto Error;
                        }
                    
                        punk = var.punkVal;
                        
                    }
                    
                } else {
                    punk = _ppUnk[i];
                }

                if (punk == NULL && _entriesCanBeNull) {

                    bvr = NULL;
                    
                } else {
                    
                    bvr = GetBvr(punk);

                    if (bvr == NULL) {
                        // Error code is already set
                        goto Error;
                    }
                
                    if (_ti != CRUNKNOWN_TYPEID && CRGetTypeId(bvr) != _ti) {
                        CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                        goto Error;
                    }
                }

                break;
            }
          case SAT_NUMBER:
            {
                double dbl;
                
                if (_isVar) {
                    CComVariant num;
                    
                    hr = num.ChangeType(VT_R8, &_pVar[i]);
                    
                    if (FAILED(hr)) {
                        CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                        goto Error;
                    }

                    dbl = num.dblVal;
                } else {
                    dbl = _pDbl[i];
                }
                
                bvr = (CRBvrPtr) CRCreateNumber(dbl);

                if (bvr == NULL) {
                    // Error code is already set
                    goto Error;
                }
                
                break;
            }
          case SAT_POINT2:
            {
                double x,y;
                
                if (_isVar) {
                    CComVariant ptx,pty;
                    
                    hr = ptx.ChangeType(VT_R8, &_pVar[i * 2]);
                    
                    if (FAILED(hr)) {
                        CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                        goto Error;
                    }
                    
                    hr = pty.ChangeType(VT_R8, &_pVar[i * 2 + 1]);
                    
                    if (FAILED(hr)) {
                        CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                        goto Error;
                    }
                    
                    x = ptx.dblVal;
                    y = pty.dblVal;
                } else {
                    x = _pDbl[i * 2];
                    y = _pDbl[i * 2 + 1];
                }
                
                if (_bPixelMode) {
                    if (_ti==CRPOINT2_TYPEID) {
                        if (pixelConst != 0.0) {
                            bvr = (CRBvrPtr) CRCreatePoint2(PixelToNum(x),
                                                            PixelYToNum(y));
                        } else {
                            bvr = (CRBvrPtr) CRCreatePoint2((CRNumberPtr) PixelToNumBvr(x),
                                                            (CRNumberPtr) PixelYToNumBvr(y));
                        }
                    } else {
                        if (pixelConst != 0.0) {
                            bvr = (CRBvrPtr) CRCreateVector2(PixelToNum(x),
                                                             PixelYToNum(y));
                        } else {
                            bvr = (CRBvrPtr) CRCreateVector2((CRNumberPtr) PixelToNumBvr(x),
                                                             (CRNumberPtr) PixelYToNumBvr(y));
                        } 
                    }
                } else {
                    if (_ti==CRPOINT2_TYPEID) {
                        bvr = (CRBvrPtr) CRCreatePoint2(x,y);
                    } else {
                        bvr = (CRBvrPtr) CRCreateVector2(x,y);
                    }
                }

                if (bvr == NULL) {
                    goto Error;
                }
                
                break;
            }
          case SAT_POINT3:
            {
                double x,y,z;
                
                if (_isVar) {
                    CComVariant ptx,pty,ptz;
                    
                    hr = ptx.ChangeType(VT_R8, &_pVar[i * 3]);
                    
                    if (FAILED(hr)) {
                        CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                        goto Error;
                    }

                    hr = pty.ChangeType(VT_R8, &_pVar[i * 3 + 1]);
                    
                    if (FAILED(hr)) {
                        CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                        goto Error;
                    }
                    
                    hr = ptz.ChangeType(VT_R8, &_pVar[i * 3 + 2]);
                    
                    if (FAILED(hr)) {
                        CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                        goto Error;
                    }
                    
                    x = ptx.dblVal;
                    y = pty.dblVal;
                    z = ptz.dblVal;
                } else {
                    x = _pDbl[i * 3];
                    y = _pDbl[i * 3 + 1];
                    z = _pDbl[i * 3 + 2];
                }

                if (_ti==CRPOINT3_TYPEID) {
                    bvr = (CRBvrPtr) CRCreatePoint3(x,y,z);
                } else {
                    bvr = (CRBvrPtr) CRCreateVector3(x,y,z);
                }
                
                if (bvr == NULL) {
                    // Error code is already set
                    goto Error;
                }
                
                break;
            }
          default:
            Assert (!"Invalid type in ToBvrArray");
            CRSetLastError(E_FAIL,NULL);
            goto Error;
        }

        bvrArray[i] = bvr;
    }

    return bvrArray;
    
  Error:
    return NULL;
}

CRArrayPtr
SafeArrayAccessor::ToArrayBvr(DWORD dwFlags,
                              ARRAYFILL toFill,
                              void **fill, 
                              unsigned int *count)
{
    // Clear the fill return values.

    if (fill)  *fill = NULL;
    if (count) *count = 0;

    if (!_inited){
        CRSetLastError(DISP_E_TYPEMISMATCH, NULL);
        return NULL;
    }
    
    unsigned int len = GetArraySize();
    
    if (count) *count = len;

    // See if we can optimize the construction of the array
    // If not then just use the ToBvrArray mechanism

    if ((dwFlags & CR_ARRAY_CHANGEABLE_FLAG) ||
        _ti == CRUNKNOWN_TYPEID ||
        _type == SAT_OBJECT ||
        ((_type == SAT_POINT2 || _type == SAT_VECTOR2)
         && pixelConst == 0.0)) {

        CRBvrPtr * arr = (CRBvrPtr *) _alloca(_numObjects * sizeof (CRBvrPtr));

        if (arr == NULL || !ToBvrArray(arr))
            return NULL;

        return CRCreateArray(_numObjects, arr, dwFlags);
    }


    HRESULT hr;
    
    double * dblArray = NULL;
    if (toFill == ARRAYFILL_NONE) {
        dblArray = NEW double[len];
        if (!dblArray) {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto Error;
        }
    } else {
        if (toFill == ARRAYFILL_DOUBLE) {
            dblArray = NEW double[len];
            *fill = (void *) dblArray;
        } else {
            *fill = (void *) NEW float[len]; 
        }
        if (!*fill) {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto Error;
        }
    }

    if (_type == SAT_POINT2 && _bPixelMode) {
        for (int i = 0; i < _numObjects; i++) {
            double x,y;
                
            if (_isVar) {
                CComVariant ptx,pty;
                
                hr = ptx.ChangeType(VT_R8, &_pVar[i * 2]);
                
                if (FAILED(hr)) {
                    CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                    goto Error;
                }
                    
                hr = pty.ChangeType(VT_R8, &_pVar[i * 2 + 1]);
                
                if (FAILED(hr)) {
                    CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                    goto Error;
                }
                    
                x = ptx.dblVal;
                y = pty.dblVal;
            } else {
                x = _pDbl[i * 2];
                y = _pDbl[i * 2 + 1];
            }
            
            if (toFill == ARRAYFILL_FLOAT) {
                float *d = (float *) (*fill);
                d[i * 2] = PixelToNum(x);
                d[i * 2 + 1] = PixelYToNum(y);
            } else {
                dblArray[i * 2] = PixelToNum(x);
                dblArray[i * 2 + 1] = PixelYToNum(y);
            }
        }
    } else {
        for (int i = 0; i < len; i++) {
            double dbl;
                
            if (_isVar) {
                CComVariant num;
                
                hr = num.ChangeType(VT_R8, &_pVar[i]);
                
                if (FAILED(hr)) {
                    CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                    goto Error;
                }
                    
                dbl = num.dblVal;
            } else {
                dbl = _pDbl[i];
            }

            if (toFill==ARRAYFILL_FLOAT) {
                float *d = (float *) (*fill);
                d[i] = dbl;
            } else {
                dblArray[i] = dbl;
            }          
        }
    }

    {
        if (toFill==ARRAYFILL_NONE) {
            CRArrayPtr arr = CRCreateArray(len, dblArray, _ti);
        
            delete [] dblArray;

            return arr;
        }
    }
    
  Error:
    return NULL;
}

int *
SafeArrayAccessor::ToIntArray()
{
    unsigned int len = GetArraySize();

    int *intArray = NEW int[len];
    if (!intArray) {
        CRSetLastError(E_OUTOFMEMORY, NULL);
        return NULL;
    }
        
    for (unsigned int i = 0; i < len; i++) {
        if (_isVar) {
            CComVariant num;
                
            HRESULT hr = num.ChangeType(VT_I4, &_pVar[i]);
                
            if (FAILED(hr)) {
                CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                return NULL;
            }
                    
            intArray[i] = num.intVal;
        } 
    }

    return intArray;
}

CRBvrPtr
VariantToBvr(VARIANT & v, CR_BVR_TYPEID ti)
{
    VARIANT *pVar;
    CRBvrPtr bvr = NULL;

    // Check if it is a reference to another variant
    
    if (V_ISBYREF(&v) && !V_ISARRAY(&v) && IS_VARIANT(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    // If it is an object then we know how to handle it
    if (V_VT(pVar) == VT_UNKNOWN ||
        V_VT(pVar) == VT_DISPATCH) {
        CComVariant var;
                    
        if (FAILED(var.ChangeType(VT_UNKNOWN, pVar))) {
            CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
            goto Error;
        }
                    
        bvr = GetBvr(V_UNKNOWN(&var));

        if (bvr == NULL) {
            // Error code is already set
            goto Error;
        }
                
        if (ti != CRUNKNOWN_TYPEID && CRGetTypeId(bvr) != ti) {
            CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
            goto Error;
        }

        // Fall through
    } else {
        VARTYPE vt;
        
        switch (ti) {
          case CRNUMBER_TYPEID: 
            vt = VT_R8;
            break;
          case CRSTRING_TYPEID:
            vt = VT_BSTR;
            break;
          case CRBOOLEAN_TYPEID:
            vt = VT_BOOL;
            break;
          case CRUNKNOWN_TYPEID:
            vt = GET_VT(pVar);

            // If it is not a bool or bstr and we do not know what
            // type we want - convert it to a number
            // This is kind of arbitrary but we should not really be
            // asked to do this

            if (vt != VT_BSTR && vt != VT_BOOL)
                vt = VT_R8;

            break;
          default:
            CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
            goto Error;
        }

        CComVariant var;

        if (FAILED(var.ChangeType(vt, pVar))) {
            CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
            goto Error;
        }
        
        switch (vt) {
          case VT_R8:
            bvr = (CRBvrPtr) CRCreateNumber(V_R8(&var));
            break;
          case VT_BOOL:
            bvr = (CRBvrPtr) CRCreateBoolean(V_BOOL(&var)?true:false);
            break;
          case VT_BSTR:
            bvr = (CRBvrPtr) CRCreateString(V_BSTR(&var));
            break;
          default:
            Assert (!"Invalid type in VariantToBvr");
        }
    }

    return bvr;

  Error:
    
    return NULL;
}

CRBvrPtr *
_CBvrsToBvrs(long size, IDABehavior *pCBvrs[], CRBvrPtr * bvrs)
{
    if (bvrs == NULL) {
        CRSetLastError(E_OUTOFMEMORY,NULL);
    } else {
        for (int i=0; i<size; i++) {
            bvrs[i] = GetBvr(pCBvrs[i]);
        }
    }

    return bvrs;
}

CRArrayPtr
ToArrayBvr(long size, IDABehavior *pCBvrs[], DWORD dwFlags)
{
    if (size == 0)
    {
        CRSetLastError(E_INVALIDARG,NULL);
        return NULL;
    }
    
    CRBvrPtr * bvrs = CBvrsToBvrs(size, pCBvrs);

    if (bvrs == NULL)
        return NULL;

    return CRCreateArray(size, bvrs, dwFlags);
}

CRArrayPtr SrvArrayBvr(VARIANT & v,
                       bool bPixelMode,
                       CR_BVR_TYPEID ti,
                       DWORD dwFlags,
                       ARRAYFILL toFill,
                       void **fill,
                       unsigned int *count)
{
    CRArrayPtr result = NULL;

    // See if an IDAArray is coming in, if so, just use it.
    // Otherwise, need to access the SafeArray.
    
    CComVariant var;
    
    if (SUCCEEDED(var.ChangeType(VT_UNKNOWN, &v))) {
        CRBvrPtr bvr = GetBvr(V_UNKNOWN(&var));
    
        if (bvr != NULL &&
            CRGetTypeId(bvr) == CRARRAY_TYPEID) {

            if (ti == CRUNKNOWN_TYPEID || CRGetArrayTypeId(bvr) == ti) {
                result = (CRArrayPtr) bvr;
            }
        }
    }

    if (!result) {
        SafeArrayAccessor acc(v,bPixelMode,ti);

        if (acc.IsOK()) {
            result = acc.ToArrayBvr(dwFlags,toFill,fill,count);
        }
    }
    
    return result;
}

CRBvrPtr RateToNumBvr(double d)
{ return RateToNumBvr((CRBvrPtr) CRCreateNumber(d)); }

CRBvrPtr ScaleRateToNumBvr(double d)
{ return RateToNumBvr((CRBvrPtr) CRCreateNumber(d),
                      (CRBvrPtr) CRCreateNumber(1)); }

CRBvrPtr RateDegreesToNumBvr(double d) {
    return RateToNumBvr(DegreesToNum(d));
}

CRBvrPtr PixelToNumBvr(CRBvrPtr b) {
    return (CRBvrPtr) CRMul((CRNumberPtr)b,CRPixel());
}

CRBvrPtr PixelYToNumBvr(CRBvrPtr b)
{ return (CRBvrPtr) CRMul((CRNumberPtr) b,negPixel); }

CRBvrPtr PointToNumBvr(double d) {
    return (CRBvrPtr) CRCreateNumber(d * METERS_PER_POINT);
}

CRBvrPtr PointToNumBvr(CRBvrPtr b) {
    return (CRBvrPtr) CRMul((CRNumberPtr) b, pointCnv);
}

CRNumberPtr pointCnv = NULL;
double pixelConst = 0.0;
double meterConst = 0.0;
CRNumberPtr negPixel = NULL;

void
InitializeModule_COMConv()
{
    pointCnv = CRCreateNumber(METERS_PER_POINT);
    if (CRIsConstantBvr((CRBvrPtr) CRPixel())) {
        pixelConst = CRExtract(CRPixel());
        if (pixelConst) {
            meterConst = 1 / pixelConst;
        }
    }
    negPixel = (pixelConst != 0)?CRCreateNumber(-1 * pixelConst):CRMul(CRCreateNumber(-1),CRPixel());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\comconv.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _COMCONV_H
#define _COMCONV_H

inline bool BOOLTobool(VARIANT_BOOL b) { return b?TRUE:FALSE ; }
inline VARIANT_BOOL boolToBOOL(bool b) { return (VARIANT_BOOL) b ; }

inline BSTR StringToBSTR(RawString str) { return A2BSTR(str) ; }

inline BSTR WideStringToBSTR(WideString str) { return W2BSTR(str) ; }

enum ARRAYFILL {
    ARRAYFILL_NONE,
    ARRAYFILL_DOUBLE,
    ARRAYFILL_FLOAT,
};

CRBvrPtr RateToNumBvr(CRBvrPtr b,CRBvrPtr bStart = NULL);
CRBvrPtr RateToNumBvr(double d);

CRBvrPtr ScaleRateToNumBvr(double d);
inline double DegreesToNum(double d) {
    return ((d * pi) / 180.0);
}

CRBvrPtr RateDegreesToNumBvr(double d);

extern double pixelConst;
extern CRNumberPtr pointCnv;
extern CRNumberPtr negPixel;

CRBvrPtr PixelToNumBvr(CRBvrPtr b);
CRBvrPtr PixelToNumBvr(double d);

CRBvrPtr PixelYToNumBvr(CRBvrPtr b);
CRBvrPtr PixelYToNumBvr(double d);

CRBvrPtr PointToNumBvr(double d);
inline double PointToNum(double d) {
    return d * METERS_PER_POINT;
}
CRBvrPtr PointToNumBvr(CRBvrPtr b);

#define CBvrsToBvrs(size, cbvrs) \
    _CBvrsToBvrs(size, (IDABehavior **)cbvrs, (CRBvrPtr *) _alloca(size * sizeof(CRBvrPtr)))

CRBvrPtr * _CBvrsToBvrs(long size, IDABehavior *pCBvrs[], CRBvrPtr * bvrs);

CRArrayPtr ToArrayBvr(long size,
                      IDABehavior *pCBvrs[],
                      DWORD dwFlags = 0);

class SafeArrayAccessor
{
  public:
    SafeArrayAccessor(VARIANT & v,
                      bool bPixelMode = false,
                      CR_BVR_TYPEID ti = CRUNKNOWN_TYPEID,
                      bool allowNullArray = false,
                      bool allowNullEntries = false);
    ~SafeArrayAccessor();

    void * GetArray() { return _v;}
    unsigned int GetArraySize() { return _ubound - _lbound + 1; }
    unsigned int GetNumObjects() { return _numObjects; }

    CRArrayPtr ToArrayBvr(DWORD dwFlags, 
                          ARRAYFILL toFill = ARRAYFILL_NONE,
                          void **fill = NULL, 
                          unsigned int *count = NULL);
    CRBvrPtr * ToBvrArray(CRBvrPtr *bvrArray);

    int *ToIntArray();

    bool IsNullArray() {
        return (_s == NULL || _numObjects == 0);
    }
    
    bool IsOK() { return _inited; }
  protected:
    enum SATYPE {
        SAT_OBJECT = 0,
        SAT_NUMBER = 1,
        SAT_POINT2 = 2,
        SAT_POINT3 = 3,
        SAT_VECTOR2= 4,
        SAT_VECTOR3= 5,
    };
    
    SAFEARRAY * _s;
    union {
        VARIANT * _pVar;
        double * _pDbl;
        IUnknown ** _ppUnk;
        void *_v;
    };
    
    SATYPE _type;
    VARTYPE _vt;
    CR_BVR_TYPEID _ti;
    long _lbound;
    long _ubound;
    bool _inited;
    bool _isVar;
    unsigned int _numObjects;
    CComVariant _retVar;
    bool _bPixelMode;
    bool _entriesCanBeNull;
};

CRArrayPtr SrvArrayBvr(VARIANT & v,
                       bool bPixelMode = false,
                       CR_BVR_TYPEID ti = CRUNKNOWN_TYPEID,
                       DWORD dwFlags = 0,
                       ARRAYFILL toFill = ARRAYFILL_NONE,
                       void **fill = NULL, 
                       unsigned int *count = NULL);

CRBvrPtr VariantToBvr(VARIANT & v, CR_BVR_TYPEID ti = CRUNKNOWN_TYPEID);

template <class T>
class CRPtr
{
  public:
    typedef T _PtrClass;
    CRPtr() { p = NULL; }
    CRPtr(T* lp, bool baddref = true)
    {
        p = lp;
        if (p != NULL && baddref)
            CRAddRefGC(p);
    }
    CRPtr(const CRPtr<T>& lp, bool baddref = true)
    {
        p = lp.p;

        if (p != NULL && baddref)
            CRAddRefGC(p);
    }
    ~CRPtr() {
        CRReleaseGC(p);
    }
    void Release() {
        CRReleaseGC(p);
        p = NULL;
    }
    operator T*() { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const CRPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;
  protected:
    T* Assign(T* lp) {
        if (lp != NULL)
            CRAddRefGC(lp);

        CRReleaseGC(p);

        p = lp;

        return lp;
    }
};

#endif /* _COMCONV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\comobj0.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "cbvr.h"
#include "srvprims.h"
#include "comcb.h"
#include "bvrtypes.h"

#include "primmth0.h"

void InitClasses0 ()
{
    AddEntry (TypeInfoEntry(CRBOOLEAN_TYPEID,CDABooleanCreate)) ;
    AddEntry (TypeInfoEntry(CRGEOMETRY_TYPEID,CDAGeometryCreate)) ;
    AddEntry (TypeInfoEntry(CRMICROPHONE_TYPEID,CDAMicrophoneCreate)) ;
    AddEntry (TypeInfoEntry(CRPATH2_TYPEID,CDAPath2Create)) ;
    AddEntry (TypeInfoEntry(CRSOUND_TYPEID,CDASoundCreate)) ;
    AddEntry (TypeInfoEntry(CRTRANSFORM3_TYPEID,CDATransform3Create)) ;
    AddEntry (TypeInfoEntry(CRFONTSTYLE_TYPEID,CDAFontStyleCreate)) ;
    AddEntry (TypeInfoEntry(CRJOINSTYLE_TYPEID,CDAJoinStyleCreate)) ;
    AddEntry (TypeInfoEntry(CRBBOX3_TYPEID,CDABbox3Create)) ;
    AddEntry (TypeInfoEntry(CRARRAY_TYPEID,CDAArrayCreate)) ;
    AddEntry (TypeInfoEntry(CRUNKNOWN_TYPEID,CDABehaviorCreate)) ;
}

_ATL_OBJMAP_ENTRY PrimObjectMap0[] = {
    OBJECT_ENTRY(CLSID_DABoolean,CDABoolean)
    OBJECT_ENTRY(CLSID_DAGeometry,CDAGeometry)
    OBJECT_ENTRY(CLSID_DAMicrophone,CDAMicrophone)
    OBJECT_ENTRY(CLSID_DAPath2,CDAPath2)
    OBJECT_ENTRY(CLSID_DASound,CDASound)
    OBJECT_ENTRY(CLSID_DATransform3,CDATransform3)
    OBJECT_ENTRY(CLSID_DAFontStyle,CDAFontStyle)
    OBJECT_ENTRY(CLSID_DAJoinStyle,CDAJoinStyle)
    OBJECT_ENTRY(CLSID_DABbox3,CDABbox3)
    OBJECT_ENTRY(CLSID_DAArray,CDAArray)
    OBJECT_ENTRY(CLSID_DABehavior,CDABehavior)
    {NULL, NULL, NULL, NULL}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\cdrawsur.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of DrawingSurface.

*******************************************************************************/

#include "headers.h"
#include "engine.h"
#include "drawsurf.h"
#include "privinc/resource.h"
#include "privinc/util.h"

// -------------------------------------------------------
// CDADrawingSurface
// -------------------------------------------------------

CDADrawingSurface::CDADrawingSurface()
{
    _st = NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDADrawingSurface::~CDADrawingSurface
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CDADrawingSurface::~CDADrawingSurface()
{
    // Pop the stack till it's empty.
    DrawingContext *dc;
    while (!_ctxStack.empty()) {
        dc = _ctxStack.top();
        _ctxStack.pop();
        delete dc;
    }
    CleanUpImgVec();
}

void CDADrawingSurface::CleanUpImgVec() {

    // Release the images in _imgVec.
    vector<IDAImage *>::iterator begin = _imgVec.begin();
    vector<IDAImage *>::iterator end = _imgVec.end();

    vector<IDAImage *>::iterator i;
    for (i = begin; i < end; i++) {
        (*i)->Release();
    }
    _imgVec.clear();
}

HRESULT CDADrawingSurface::Init(IDAStatics *st)
{
    if (_st && _ctxStack.empty() && _imgVec.empty()) {
        Assert(FALSE && "Init called twice");
        return E_ABORT;
    }

    DrawingContext *dc = new DrawingContext(st, this);
    if (dc == NULL) {
        return E_OUTOFMEMORY;
    }

    _ctxStack.push(dc);
    _st = st;
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::SaveGraphicsState()
{
    DrawingContext *dcNew = NULL, *dc = GetCurrentContext();
    dcNew = new DrawingContext(_st, this, dc);
    _ctxStack.push(dcNew);

    if (dcNew == NULL)
        return E_OUTOFMEMORY;
    else
        return S_OK;
}

STDMETHODIMP CDADrawingSurface::RestoreGraphicsState()
{
    // Never restore more GraphicsState than we have saved.
    // Always keep at least one DrawingContext on the stack.

    if (_ctxStack.size() > 1) {
        DrawingContext *dc = GetCurrentContext();
        _ctxStack.pop();
        delete dc;
    }

    return S_OK;
}

HRESULT CDADrawingSurface::OverlayImages(vector<IDAImage *> &imgVec,
                                         IDAImage **ppimg)
{
    CHECK_RETURN_SET_NULL(ppimg);

    HRESULT hr;

    int size = imgVec.size();
    if (size == 0) {
        hr = _st->get_EmptyImage(ppimg);
    } else if (size == 1) {
        *ppimg = imgVec.front();
        (*ppimg)->AddRef();
        hr = S_OK;
    } else {

        IDAImage** imgArr = new IDAImage*[size];

        if (imgArr != NULL) {
            vector<IDAImage *>::iterator begin = imgVec.begin();
            vector<IDAImage *>::iterator end = imgVec.end();

            vector<IDAImage *>::iterator i = begin;

            for (int j = size-1; i < end; i++, j--) {
                imgArr[j] = *i;
            }
            hr = _st->OverlayArrayEx(size, imgArr, ppimg);
            delete imgArr;
        } else {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

STDMETHODIMP CDADrawingSurface::get_Image(IDAImage ** ppImg)
{
    return OverlayImages(_imgVec, ppImg);
}

DrawingContext *CDADrawingSurface::GetCurrentContext()
{
    return _ctxStack.top();
}

STDMETHODIMP CDADrawingSurface::get_LocalContextImage(IDAImage ** ppImg)
{
    return OverlayImages(GetCurrentContext()->imgVec(), ppImg);
}

STDMETHODIMP CDADrawingSurface::put_LineStyle(IDALineStyle *ls)
{
    CHECK_RETURN_NULL(ls);
    
    GetCurrentContext()->SetLineStyle(ls);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::put_BorderStyle(IDALineStyle *bs)
{
    CHECK_RETURN_NULL(bs);
    GetCurrentContext()->SetBorderStyle(bs);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::put_FontStyle(IDAFontStyle *fs)
{
    CHECK_RETURN_NULL(fs);
    GetCurrentContext()->SetFontStyle(fs);
    return S_OK;
}

// Fill Type selection methods 
STDMETHODIMP CDADrawingSurface::TextureFill(IDAImage *img, double startx, double starty)
{
    CHECK_RETURN_NULL(img);

    // Calculate lower left position
    CComPtr<IDAImage> temp;
    CComPtr<IDATransform2> xf;
    CComPtr<IDABbox2> bb;
    CComPtr<IDAPoint2> max,min;
    CComPtr<IDANumber> minX,minY, sX,sY, newX, newY;       
    
    RETURN_IF_ERROR(img->get_BoundingBox(&bb)) 
    RETURN_IF_ERROR(bb->get_Min(&min))
    RETURN_IF_ERROR(min->get_X(&minX))
    RETURN_IF_ERROR(min->get_Y(&minY))
    RETURN_IF_ERROR(_st->DANumber(startx,&sX))
    RETURN_IF_ERROR(_st->DANumber(starty,&sY))

    RETURN_IF_ERROR(_st->Sub(sX, minX, &newX))
    RETURN_IF_ERROR(_st->Sub(sY, minY, &newY))               

    RETURN_IF_ERROR(_st->Translate2Anim(newX, newY, &xf))
    img->Transform(xf, &temp);
    GetCurrentContext()->SetFillStyle(fill_texture);
    GetCurrentContext()->SetTexture(temp);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::FillTexture(IDAImage *img)
{
    CHECK_RETURN_NULL(img);
    GetCurrentContext()->SetFillStyle(fill_texture);
    GetCurrentContext()->SetTexture(img);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::ImageFill(IDAImage *img, double startx, double starty)
{
    CHECK_RETURN_NULL(img);

    TextureFill(img,startx,starty);
    // Override the texture style by setting it to image fill
    GetCurrentContext()->SetFillStyle(fill_image);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::FillImage(IDAImage *img)
{
    CHECK_RETURN_NULL(img);
    GetCurrentContext()->SetFillStyle(fill_image);
    GetCurrentContext()->SetTexture(img);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::FillStyle(int ID)
{
    if((ID<0) || (ID>15))
        ID=0;
    GetCurrentContext()->SetFillStyle(ID);
    return S_OK;
}



STDMETHODIMP CDADrawingSurface::FillColor(IDAColor *foreground)
{
    CHECK_RETURN_NULL(foreground);
    GetCurrentContext()->SetForeColor(foreground);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::SecondaryFillColor(IDAColor *val)
{
    CHECK_RETURN_NULL(val);
    GetCurrentContext()->SetBackColor(val);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::GradientShape(VARIANT pts)
{    
    return GetCurrentContext()->SetGradientShape(pts);
}

STDMETHODIMP CDADrawingSurface::GradientExtent(double startx, double starty, double finishx, double finishy)
{
    CComPtr<IDAPoint2> startPt, finishPt;
    RETURN_IF_ERROR(_st->Point2(startx, starty, &startPt))
    RETURN_IF_ERROR(_st->Point2(finishx, finishy, &finishPt))
    GetCurrentContext()->SetGradientExtent(startPt, finishPt);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::GradientExtentPoints(IDAPoint2 *start, IDAPoint2 *stop)
{
    CHECK_RETURN_NULL(start);
    CHECK_RETURN_NULL(stop);
    
    GetCurrentContext()->SetGradientExtent(start, stop);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::GradientRolloffPower(double power)
{
    CComPtr<IDANumber> pow;
    RETURN_IF_ERROR(_st->DANumber(power, &pow))
    GetCurrentContext()->SetGradientRolloffPower(pow);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::GradientRolloffPowerAnim(IDANumber *power)
{
    CHECK_RETURN_NULL(power);
    GetCurrentContext()->SetGradientRolloffPower(power);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::FixedFillScale()
{
    GetCurrentContext()->SetXScaling(false);
    GetCurrentContext()->SetYScaling(false);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::HorizontalFillScale()
{
    GetCurrentContext()->SetXScaling(true);
    GetCurrentContext()->SetYScaling(false);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::VerticalFillScale()
{
    GetCurrentContext()->SetXScaling(false);
    GetCurrentContext()->SetYScaling(true);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::AutoSizeFillScale()
{
    GetCurrentContext()->SetXScaling(true);
    GetCurrentContext()->SetYScaling(true);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::Opacity(double op)
{
    IDANumber *opAnim;
    RETURN_IF_ERROR(_st->DANumber(op, &opAnim))

    return OpacityAnim(opAnim);
}

STDMETHODIMP CDADrawingSurface::OpacityAnim(IDANumber *op)
{
    CHECK_RETURN_NULL(op);
    GetCurrentContext()->SetOpacity(op);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::put_ClipMatte(IDAMatte *matte)
{
    CHECK_RETURN_NULL(matte);
    GetCurrentContext()->SetClip(matte);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::put_MouseEventsEnabled(VARIANT_BOOL on)
{
    GetCurrentContext()->SetMouseEventsEnabled(on?true:false);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::put_HatchFillTransparent(VARIANT_BOOL on)
{
    GetCurrentContext()->SetHatchFill(on?true:false);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::CropPoints(IDAPoint2 *min, IDAPoint2 *max)
{
    CHECK_RETURN_NULL(min);
    CHECK_RETURN_NULL(max);
    GetCurrentContext()->SetCrop(min, max);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::Crop(double minX, double minY, double maxX, double maxY)
{
    CComPtr<IDAPoint2> minPt, maxPt;
    RETURN_IF_ERROR(_st->Point2(minX, minY, &minPt))
    RETURN_IF_ERROR(_st->Point2(maxX, maxY, &maxPt))
    return CropPoints(minPt, maxPt);
}

STDMETHODIMP CDADrawingSurface::Transform(IDATransform2 *xf)
{
    CHECK_RETURN_NULL(xf);
    return GetCurrentContext()->Transform(xf);
}

STDMETHODIMP CDADrawingSurface::Reset()
{
    return GetCurrentContext()->Reset();
}

STDMETHODIMP CDADrawingSurface::Clear()
{
    HRESULT hr = GetCurrentContext()->Reset();
    if (SUCCEEDED(hr)) {
        GetCurrentContext()->CleanUpImgVec();
        CleanUpImgVec();
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CDADrawingSurface::PolylineEx(LONG numPts, IDAPoint2 *pts[])
{
    CHECK_RETURN_NULL(pts);
    
    CComPtr<IDAPath2> pth;
    RETURN_IF_ERROR(_st->PolylineEx(numPts, pts, &pth))
    return GetCurrentContext()->Draw(pth, false);
}

STDMETHODIMP CDADrawingSurface::Polyline(VARIANT pts)
{
    CComPtr<IDAPath2> pth;
    RETURN_IF_ERROR(_st->Polyline(pts, &pth))
    return GetCurrentContext()->Draw(pth, false);
}

STDMETHODIMP CDADrawingSurface::PolygonEx(LONG numPts, IDAPoint2 *pts[])
{
    CHECK_RETURN_NULL(pts);

    CComPtr<IDAPath2> pth, closedPth;
    RETURN_IF_ERROR(_st->PolylineEx(numPts, pts, &pth))
    RETURN_IF_ERROR(pth->Close(&closedPth))
    return GetCurrentContext()->Draw(closedPth, true);
}

STDMETHODIMP CDADrawingSurface::Polygon(VARIANT pts)
{
    CComPtr<IDAPath2> pth, closedPth;
    RETURN_IF_ERROR(_st->Polyline(pts, &pth))
    RETURN_IF_ERROR(pth->Close(&closedPth))
    return GetCurrentContext()->Draw(closedPth, true);
}

STDMETHODIMP CDADrawingSurface::LinePoints(IDAPoint2 *p1, IDAPoint2 *p2)
{
    CHECK_RETURN_NULL(p1);
    CHECK_RETURN_NULL(p2);
    CComPtr<IDAPath2> pth;
    RETURN_IF_ERROR(_st->Line(p1, p2, &pth))
    return GetCurrentContext()->Draw(pth, false);
}

STDMETHODIMP CDADrawingSurface::Line(double startX, double startY,
                      double endX, double endY)
{
    CComPtr<IDAPoint2> startPt, endPt;
    RETURN_IF_ERROR(_st->Point2(startX, startY, &startPt))
    RETURN_IF_ERROR(_st->Point2(endX, endY, &endPt))
    return LinePoints(startPt, endPt);
}

// The passed in xRadius and yRadius is the half width and half height of
// the bounding ellipse.
STDMETHODIMP CDADrawingSurface::ArcRadians(double x, double y, double startAngle, double endAngle, double width, double height)
{
    CComPtr<IDAPath2> pthTemp, pth;
    RETURN_IF_ERROR(_st->ArcRadians(startAngle, endAngle, width, height, &pthTemp))

    // The passed in x, y is the lower left corner of the bounding ellipse.
    // We'll move it from (-width/2, -height/2) to (x, y)
    CComPtr<IDATransform2> xf;
    RETURN_IF_ERROR(_st->Translate2(x + width/2, y + height/2, &xf))
    RETURN_IF_ERROR(pthTemp->Transform(xf, &pth))

    return GetCurrentContext()->Draw(pth, false);
}

STDMETHODIMP CDADrawingSurface::ArcDegrees(double x, double y, double startAngle, double endAngle, double width, double height)
{
    double startAngleRadian = startAngle * degToRad;
    double endAngleRadian = endAngle * degToRad;
    return ArcRadians(x, y, startAngleRadian, endAngleRadian, width, height);
}

STDMETHODIMP CDADrawingSurface::Oval(double x, double y, double width, double height)
{
    CComPtr<IDAPath2> pthTemp, pth;
    RETURN_IF_ERROR(_st->Oval(width, height, &pthTemp))

    CComPtr<IDATransform2> xf;
    RETURN_IF_ERROR(_st->Translate2(x + width/2, y + height/2, &xf))
    RETURN_IF_ERROR(pthTemp->Transform(xf, &pth))
    return GetCurrentContext()->Draw(pth, true);
}

STDMETHODIMP CDADrawingSurface::Rect(double x, double y, double width, double height)
{
    CComPtr<IDAPath2> pthTemp, pth;
    RETURN_IF_ERROR(_st->Rect(width, height, &pthTemp))

    CComPtr<IDATransform2> xf;
    RETURN_IF_ERROR(_st->Translate2(x + width/2, y + height/2, &xf))
    RETURN_IF_ERROR(pthTemp->Transform(xf, &pth))
    return GetCurrentContext()->Draw(pth, true);
}

STDMETHODIMP CDADrawingSurface::RoundRect(double x, double y,
                                          double width, double height,
                                          double arcWidth, double arcHeight)
{
    CComPtr<IDAPath2> pthTemp, pth;
    RETURN_IF_ERROR(_st->RoundRect(width, height, arcWidth, arcHeight, &pthTemp))

    // The passed in x, y is the lower left corner of the bounding box.
    // We'll move it from (-width/2, -height/2) to (x, y)
    CComPtr<IDATransform2> xf;
    RETURN_IF_ERROR(_st->Translate2(x + width/2, y + height/2, &xf))
    RETURN_IF_ERROR(pthTemp->Transform(xf, &pth))
    return GetCurrentContext()->Draw(pth, true);
}

STDMETHODIMP CDADrawingSurface::PieRadians(double x, double y, double startAngle, double endAngle,
                                           double width, double height)
{
    CComPtr<IDAPath2> pthTemp, pth;
    RETURN_IF_ERROR(_st->PieRadians(startAngle, endAngle, width, height, &pthTemp))

    // The passed in x, y is the lower left corner of the bounding ellipse.
    // We'll move it from (-width/2, -height/2) to (x, y)
    CComPtr<IDATransform2> xf;
    RETURN_IF_ERROR(_st->Translate2(x + width/2, y + height/2, &xf))
    RETURN_IF_ERROR(pthTemp->Transform(xf, &pth))

    return GetCurrentContext()->Draw(pth, true);
}

STDMETHODIMP CDADrawingSurface::PieDegrees(double x, double y, double startAngle, double endAngle,
                                           double width, double height)
{
    double startAngleRadian = startAngle * degToRad;
    double endAngleRadian = endAngle * degToRad;
    return PieRadians(x, y, startAngleRadian, endAngleRadian, width, height);
}

STDMETHODIMP CDADrawingSurface::Text(BSTR str, double x, double y)
{
    CComPtr<IDAPoint2> pt;
    RETURN_IF_ERROR(_st->Point2(x, y, &pt))
    return TextPoint(str, pt);
}

STDMETHODIMP CDADrawingSurface::TextPoint(BSTR str, IDAPoint2 *pt)
{
    CHECK_RETURN_NULL(pt);
    return GetCurrentContext()->TextPoint(str, pt);
}

STDMETHODIMP CDADrawingSurface::FillPath(IDAPath2 *pth)
{
    CHECK_RETURN_NULL(pth);
    return GetCurrentContext()->Draw(pth, true);
}

STDMETHODIMP CDADrawingSurface::DrawPath(IDAPath2 *pth)
{
    CHECK_RETURN_NULL(pth);
    return GetCurrentContext()->Draw(pth, false);
}

STDMETHODIMP CDADrawingSurface::OverlayImage(IDAImage *img)
{
    CHECK_RETURN_NULL(img);
    return GetCurrentContext()->Overlay(img);
}

STDMETHODIMP CDADrawingSurface::LineColor(IDAColor *clr)
{
    CHECK_RETURN_NULL(clr);
    CComPtr<IDALineStyle> newLs;
    RETURN_IF_ERROR(GetCurrentContext()->GetLineStyle()->Color(clr, &newLs))
    GetCurrentContext()->SetLineStyle(newLs);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::LineWidth(double width)
{
    CComPtr<IDALineStyle> newLs;
    RETURN_IF_ERROR(GetCurrentContext()->GetLineStyle()->width(width, &newLs))
    GetCurrentContext()->SetLineStyle(newLs);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::LineDashStyle(DA_DASH_STYLE id)
{
    return GetCurrentContext()->LineDashStyle(id);
}

STDMETHODIMP CDADrawingSurface::LineEndStyle(DA_END_STYLE id)
{
    CComPtr<IDALineStyle> newLs;
    CComPtr<IDAEndStyle> end;

    // Use the default end style - flat, if invalid index.
    if (id == DAEndSquare) {
        RETURN_IF_ERROR(_st->get_EndStyleSquare(&end))
    } else if (id == DAEndRound) {
        RETURN_IF_ERROR(_st->get_EndStyleRound(&end))
    } else {
        RETURN_IF_ERROR(_st->get_EndStyleFlat(&end))
    }

    RETURN_IF_ERROR(GetCurrentContext()->GetLineStyle()->End(end, &newLs))
    GetCurrentContext()->SetLineStyle(newLs);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::LineJoinStyle(DA_JOIN_STYLE id)
{
    CComPtr<IDALineStyle> newLs;
    CComPtr<IDAJoinStyle> join;

    // Use the default join style - bevel, if invalid index.
    if (id == DAJoinMiter) {
        RETURN_IF_ERROR(_st->get_JoinStyleMiter(&join))
    } else if (id == DAJoinRound) {
        RETURN_IF_ERROR(_st->get_JoinStyleRound(&join))
    } else {
        RETURN_IF_ERROR(_st->get_JoinStyleBevel(&join))
    }

    RETURN_IF_ERROR(GetCurrentContext()->GetLineStyle()->Join(join, &newLs))
    GetCurrentContext()->SetLineStyle(newLs);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::BorderColor(IDAColor *clr)
{
    CHECK_RETURN_NULL(clr);
    IDALineStyle * newLs;
    RETURN_IF_ERROR(GetCurrentContext()->GetBorderStyle()->Color(clr, &newLs))
    GetCurrentContext()->SetBorderStyle(newLs);
    newLs->Release();
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::BorderWidth(double width)
{
    IDALineStyle * newLs;
    RETURN_IF_ERROR(GetCurrentContext()->GetBorderStyle()->width(width, &newLs))
    GetCurrentContext()->SetBorderStyle(newLs);
    newLs->Release();
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::BorderDashStyle(DA_DASH_STYLE id)
{
    return GetCurrentContext()->BorderDashStyle(id);
}

STDMETHODIMP CDADrawingSurface::BorderEndStyle(DA_END_STYLE id)
{
    CComPtr<IDALineStyle> oldLs, newLs;
    CComPtr<IDAEndStyle> end;
    oldLs = GetCurrentContext()->GetBorderStyle();

    // Use the default end style - flat, if invalid index.
    if (id == DAEndSquare) {
        RETURN_IF_ERROR(_st->get_EndStyleSquare(&end))
    } else if (id == DAEndRound) {
        RETURN_IF_ERROR(_st->get_EndStyleRound(&end))
    } else {
        RETURN_IF_ERROR(_st->get_EndStyleFlat(&end))
    }

    RETURN_IF_ERROR(oldLs->End(end, &newLs))
    GetCurrentContext()->SetBorderStyle(newLs);
    return S_OK;
}

STDMETHODIMP CDADrawingSurface::BorderJoinStyle(DA_JOIN_STYLE id)
{
    CComPtr<IDALineStyle> oldLs, newLs;
    CComPtr<IDAJoinStyle> join;
    oldLs = GetCurrentContext()->GetBorderStyle();

    // Use the default join style - bevel, if invalid index.
    if (id == DAJoinMiter) {
        RETURN_IF_ERROR(_st->get_JoinStyleMiter(&join))
    } else if (id == DAJoinRound) {
        RETURN_IF_ERROR(_st->get_JoinStyleRound(&join))
    } else {
        RETURN_IF_ERROR(_st->get_JoinStyleBevel(&join))
    }

    RETURN_IF_ERROR(oldLs->Join(join, &newLs))
    GetCurrentContext()->SetBorderStyle(newLs);
    return S_OK;
}

STDMETHODIMP  CDADrawingSurface::Font(BSTR FontFace, LONG sizeInPoints,
                                      VARIANT_BOOL Bold, VARIANT_BOOL italic,
                                      VARIANT_BOOL underline, VARIANT_BOOL strikethrough)
{
    // Note: underline and strikethrough not supported.

    CComPtr<IDAFontStyle> fs1,fs2,fs3,fs4,fs;
    CComPtr<IDAColor> clr;
    _st->get_Black(&clr);
    RETURN_IF_ERROR(_st->Font(FontFace, sizeInPoints, clr, &fs1))
    if(Bold)
        fs1->Bold(&fs2);
    else
        fs2 = fs1;

    if(italic)
        fs2->Italic(&fs3);
    else
        fs3 = fs2;

    if(underline)
        fs3->Underline(&fs4);
    else
        fs4 = fs3;

    if(strikethrough)
        fs4->Strikethrough(&fs);
    else
        fs = fs4;

    GetCurrentContext()->SetFontStyle(fs);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\comcb.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "comcb.h"
#include "srvprims.h"
#include "cview.h"
#include "privinc/resource.h"
#include <mshtml.h>
#include "privinc/comutil.h"

static bool InitEventData(IDABehavior **data,
                          IDABehavior **curBvr,
                          CRBvrPtr eventData,
                          CRBvrPtr curRunningBvr)
{
    if (eventData) {
        *data = CreateCBvr(eventData);
        if (*data == NULL)
            goto Error;
    }
    
    if (curRunningBvr) {
        *curBvr = CreateCBvr(curRunningBvr);
        if (*curBvr == NULL)
            goto Error;
    }

    return true;
  Error:
    RELEASE(*data);
    RELEASE(*curBvr);

    return false;
}

// ================================================
// COMUntilNotifier
//
// ================================================

class COMUntilNotifier : public CRUntilNotifier
{
  public:
    COMUntilNotifier(IDAUntilNotifier * notifier)
    : _notifier(notifier),_cRef(1)  { _notifier->AddRef(); }
    ~COMUntilNotifier() {
        SAFERELEASE(_notifier);
    }
    
    CRSTDAPICB_(ULONG) AddRef() { return InterlockedIncrement(&_cRef); }
    CRSTDAPICB_(ULONG) Release() {
        ULONG ul = InterlockedDecrement(&_cRef) ;
        if (ul == 0) delete this;
        return ul;
    }
    
    CRSTDAPICB_(CRBvrPtr) Notify(CRBvrPtr eventData,
                                 CRBvrPtr curRunningBvr,
                                 CRViewPtr curView)
    {
        DAComPtr<IDABehavior> event ;
        DAComPtr<IDABehavior> curBvr ;
        DAComPtr<IDAView> v;
        DAComPtr<IDABehavior> pResult ;
        HRESULT hr ;
        CRBvrPtr bvr = NULL;
        
        if (!InitEventData(&event, &curBvr, eventData, curRunningBvr))
            goto done;
        
        // Need to assign the internal pointer directly so we do not
        // get the addref
        Assert (!v); // To ensure we do not leak by accident
        
        v.p = (CView *)CRGetSite(curView);

        Assert(v);

        if (!v) {
            CRSetLastError(E_UNEXPECTED, NULL);
            goto done;
        }
    
        Assert (_notifier) ;
        hr = THR(_notifier->Notify(event,
                                   curBvr,
                                   v,
                                   &pResult));
        
        event.Release();
        curBvr.Release();
        v.Release();

        if (FAILED(hr)) {
            CRSetLastError(IDS_ERR_BE_UNTILNOTIFY, NULL);
            goto done;
        }

        // If this call fails then it will just fall through and
        // return NULL.  The error is already set by GetBvr
        
        bvr = GetBvr(pResult) ;

      done:
        return bvr ;
    }

  protected:
    IDAUntilNotifier * _notifier ;
    long _cRef;
} ;

CRUntilNotifierPtr
WrapCRUntilNotifier(IDAUntilNotifier * notifier)
{
    if (notifier == NULL) {
        CRSetLastError(E_INVALIDARG,NULL);
        return NULL;
    } else {
        CRUntilNotifierPtr ret = NEW COMUntilNotifier(notifier) ;
        if (ret == NULL)
            CRSetLastError(E_OUTOFMEMORY, NULL);
        return ret;
    }
}

// ================================================
// COMBvrHook
// TODO: Merge the code with COMUntilNotifier
// ================================================

class COMBvrHook : public CRBvrHook
{
  public:
    COMBvrHook(IDABvrHook * notifier)
    : _notifier(notifier),_cRef(1)  { _notifier->AddRef(); }
    ~COMBvrHook() {
        SAFERELEASE(_notifier);
    }
    
    CRSTDAPICB_(ULONG) AddRef() { return InterlockedIncrement(&_cRef); }
    CRSTDAPICB_(ULONG) Release() {
        ULONG ul = InterlockedDecrement(&_cRef) ;
        if (ul == 0) delete this;
        return ul;
    }
    
    virtual CRSTDAPICB_(CRBvrPtr) Notify(long id,
                                         bool start,
                                         double startTime,
                                         double gTime,
                                         double lTime,
                                         CRBvrPtr sampleVal,
                                         CRBvrPtr curRunningBvr)
    {
        DAComPtr<IDABehavior> valCBvr ;
        DAComPtr<IDABehavior> curCBvr ;
        DAComPtr<IDABehavior> pResult ;
        HRESULT hr ;
        CRBvrPtr bvr = NULL;

        if (!InitEventData(&valCBvr,
                           &curCBvr,
                           sampleVal,
                           curRunningBvr))
            goto done;
        
        Assert (_notifier) ;
        hr = THR(_notifier->Notify(id,
                                   start,
                                   startTime,
                                   gTime,
                                   lTime,
                                   valCBvr,
                                   curCBvr,
                                   &pResult));
        
        valCBvr.Release();
        curCBvr.Release();

        if (FAILED(hr)) {
            CRSetLastError(IDS_ERR_BE_UNTILNOTIFY, NULL);
            goto done;
        }

        // If this call fails then it will just fall through and
        // return NULL.  The error is already set by GetBvr
        
        bvr = GetBvr(pResult) ;

      done:
        return bvr ;
    }
  protected:
    IDABvrHook * _notifier;
    long _cRef;
} ;

CRBvrHookPtr
WrapCRBvrHook(IDABvrHook * notifier)
{
    if (notifier == NULL) {
        CRSetLastError(E_INVALIDARG,NULL);
        return NULL;
    } else {
        CRBvrHookPtr ret = NEW COMBvrHook(notifier) ;
        if (ret == NULL)
            CRSetLastError(E_OUTOFMEMORY, NULL);
        return ret;
    }
}
    
// ================================================
// COMScriptCallback
//
// ================================================

class COMScriptCallback : public CRUntilNotifier
{
  public:
    COMScriptCallback(BSTR fun, BSTR language)
    : _fun(NULL), _varLanguage(NULL),_cRef(1)  {
        _fun = CopyString(fun);
        _varLanguage = CopyString(language);
    }

    ~COMScriptCallback() {
        delete [] _fun;
        delete [] _varLanguage;
    }

    CRSTDAPICB_(ULONG) AddRef() { return InterlockedIncrement(&_cRef); }
    CRSTDAPICB_(ULONG) Release() {
        ULONG ul = InterlockedDecrement(&_cRef) ;
        if (ul == 0) delete this;
        return ul;
    }
    
    bool CallScript();

    virtual CRSTDAPICB_(CRBvrPtr) Notify(CRBvrPtr eventData,
                                         CRBvrPtr curRunningBvr,
                                         CRViewPtr curView) {
        CallScript();
        return curRunningBvr;
    }
  protected:
    long _cRef;
    WideString _fun;
    WideString _varLanguage;
};

bool
COMScriptCallback::CallScript()
{
    CComVariant retVal;
    CComBSTR fun(_fun);
    CComBSTR varLanguage(_varLanguage);
    
    return SUCCEEDED(CallScriptOnPage(fun,
                                      varLanguage,
                                      &retVal));
}

HRESULT
CallScriptOnPage(BSTR scriptSourceToInvoke,
                 BSTR scriptLanguage,
                 VARIANT *retVal)
{
    // TODO: At some point, may want to cache some of these elements,
    // since this will be repeatedly called.
    
    DAComPtr<IServiceProvider> pSp;
    DAComPtr<IHTMLWindow2> pHTMLWindow2;
    
    if (!GetCurrentServiceProvider(&pSp) ||
        FAILED(pSp->QueryService(SID_SHTMLWindow,
                                 IID_IHTMLWindow2,
                                 (void **)&pHTMLWindow2)))
        return FALSE;

    VariantInit(retVal);
    return pHTMLWindow2->execScript(scriptSourceToInvoke,
                                    scriptLanguage,
                                    retVal);
}

CRUntilNotifierPtr WrapScriptCallback(BSTR bstr, BSTR language)
{ return NEW COMScriptCallback(bstr,language) ; }

// ================================================
// COMScriptNotifier
// ================================================
class COMScriptNotifier : public CRUntilNotifier
{
  public:
    COMScriptNotifier(BSTR scriptlet) : _fun(NULL),_cRef(1)  {
        _fun = CopyString(scriptlet);
    }

    ~COMScriptNotifier()
    { delete [] _fun; }

    CRSTDAPICB_(ULONG) AddRef() { return InterlockedIncrement(&_cRef); }
    CRSTDAPICB_(ULONG) Release() {
        ULONG ul = InterlockedDecrement(&_cRef) ;
        if (ul == 0) delete this;
        return ul;
    }
    
    virtual CRSTDAPICB_(CRBvrPtr) Notify(CRBvrPtr eventData,
                                         CRBvrPtr curRunningBvr,
                                         CRViewPtr curView) {
        DISPID dispid;
        DAComPtr<IServiceProvider> pSp;
        DAComPtr<IDispatch> pDispatch;
        CRBvrPtr bvr = NULL;
        DAComPtr<IDABehavior> event;
        DAComPtr<IDABehavior> curBvr;
        CComVariant retVal;
        HRESULT hr;
        
        {
            CComBSTR fun(_fun);

            if (!GetCurrentServiceProvider(&pSp) ||
                FAILED(pSp->QueryService(SID_SHTMLWindow,
                                         IID_IDispatch,
                                         (void **) &pDispatch)) ||
                FAILED(pDispatch->GetIDsOfNames(IID_NULL, &fun, 1,
                                                LOCALE_USER_DEFAULT,
                                                &dispid))) {
                CRSetLastError(E_FAIL,NULL);
                goto done;
            }
        }

        
        if (!InitEventData(&event, &curBvr, eventData, curRunningBvr))
            goto done;

        // paramters needed to be pushed in reverse order
        VARIANT rgvarg[2];
        rgvarg[1].vt = VT_DISPATCH;
        rgvarg[1].pdispVal = event;
        rgvarg[0].vt = VT_DISPATCH;
        rgvarg[0].pdispVal = curBvr;

        DISPPARAMS dp;
        dp.cNamedArgs = 0;
        dp.rgdispidNamedArgs = 0;
        dp.cArgs = 2;
        dp.rgvarg = rgvarg;

        hr = pDispatch->Invoke(dispid, IID_NULL,
                               LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                               &dp, &retVal, NULL, NULL);

        event.Release();
        curBvr.Release();

        if (FAILED(hr)) {
            CRSetLastError(IDS_ERR_BE_UNTILNOTIFY, NULL);
            goto done;
        }

        if (FAILED(retVal.ChangeType(VT_UNKNOWN))) {
            CRSetLastError(IDS_ERR_BE_UNTILNOTIFY, NULL);
            goto done;
        }

        // If this call fails then it will just fall through and
        // return NULL.  The error is already set by GetBvr
        
        bvr = GetBvr(V_UNKNOWN(&retVal));
      done:
        return bvr ;
    }

  protected:
    long _cRef;
    WideString _fun;
};

CREventPtr
NotifyScriptEvent(CREventPtr event, BSTR scriptlet)
{
    CREventPtr ret = NULL;

    CRUntilNotifierPtr un = NEW COMScriptNotifier(scriptlet);

    if (un) {
        ret = CRNotify(event, un);
    } else {
        CRSetLastError(E_OUTOFMEMORY, NULL);
    }

    if (!ret)
        delete un;
    
    return ret;
}

CRBvrPtr
UntilNotifyScript(CRBvrPtr b0, CREventPtr event, BSTR scriptlet)
{
    CRBvrPtr ret = NULL;

    CREventPtr scriptEvent = NotifyScriptEvent(event, scriptlet);

    // No need to cleanup since everything will get GC'd

    if (scriptEvent) {
        ret = CRUntilEx(b0, scriptEvent);
    }

    return ret;
}

CREventPtr
ScriptCallback(BSTR function, CREventPtr event, BSTR language)
{
    return CRNotify(event, WrapScriptCallback(function, language));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\comobj1.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "cbvr.h"
#include "srvprims.h"
#include "comcb.h"
#include "bvrtypes.h"

#include "primmth1.h"


void InitClasses1 ()
{
    AddEntry (TypeInfoEntry(CRCAMERA_TYPEID,CDACameraCreate)) ;
    AddEntry (TypeInfoEntry(CRIMAGE_TYPEID,CDAImageCreate)) ;
    AddEntry (TypeInfoEntry(CRMONTAGE_TYPEID,CDAMontageCreate)) ;
    AddEntry (TypeInfoEntry(CRPOINT2_TYPEID,CDAPoint2Create)) ;
    AddEntry (TypeInfoEntry(CRSTRING_TYPEID,CDAStringCreate)) ;
    AddEntry (TypeInfoEntry(CRVECTOR2_TYPEID,CDAVector2Create)) ;
    AddEntry (TypeInfoEntry(CRLINESTYLE_TYPEID,CDALineStyleCreate)) ;
    AddEntry (TypeInfoEntry(CRDASHSTYLE_TYPEID,CDADashStyleCreate)) ;
    AddEntry (TypeInfoEntry(CRPAIR_TYPEID,CDAPairCreate)) ;
    AddEntry (TypeInfoEntry(CRTUPLE_TYPEID,CDATupleCreate)) ;
}

_ATL_OBJMAP_ENTRY PrimObjectMap1[] = {
    OBJECT_ENTRY(CLSID_DACamera,CDACamera)
    OBJECT_ENTRY(CLSID_DAImage,CDAImage)
    OBJECT_ENTRY(CLSID_DAMontage,CDAMontage)
    OBJECT_ENTRY(CLSID_DAPoint2,CDAPoint2)
    OBJECT_ENTRY(CLSID_DAString,CDAString)
    OBJECT_ENTRY(CLSID_DAVector2,CDAVector2)
    OBJECT_ENTRY(CLSID_DALineStyle,CDALineStyle)
    OBJECT_ENTRY(CLSID_DADashStyle,CDADashStyle)
    OBJECT_ENTRY(CLSID_DAPair,CDAPair)
    OBJECT_ENTRY(CLSID_DATuple,CDATuple)
    {NULL, NULL, NULL, NULL}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\context.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef DA_CONTEXT_H
#define DA_CONTEXT_H

#include "backend/bvr.h"
#include "dartapi.h"
#include "dartapipriv.h"
#include "privinc/mutex.h"
#include "backend/gc.h"
#include <dxtrans.h>

class SoundBufferCache ;
class ImageDisplayDev;
class QuartzRenderer;

// =========================================
// Context Class
// =========================================

class ATL_NO_VTABLE ViewIterator {
  public:
    virtual void Process(CRViewPtr) = 0;
};

class ATL_NO_VTABLE SiteIterator {
  public:
    virtual void Process(CRSitePtr) = 0;
};

class Context : public AxAThrowingAllocatorClass {
  public:
    Context () ;
    ~Context () { Cleanup(false); }

    void Cleanup(bool bShutdown);

    DynamicHeap & GetGCHeap () { return _gcHeap ; }
    DynamicHeap & GetTmpHeap () { return _tmpHeap ; }

    // DEADLOCK - Be careful what you do in the view iterator and
    // from the thread calling these functions since it can cause
    // deadlock
    
    void AddView(CRViewPtr v);
    void RemoveView(CRViewPtr v);
    void IterateViews(ViewIterator& proc);
    void ViewDecPickEvent(CRViewPtr v);

    CritSect & GetCritSect () { return _critSect; }

    GCList GetGCList() { return _gcList ; }

    GCRoots GetGCRoots() { return _gcRoots ; }

    SoundBufferCache* GetSoundBufferCache() { return _soundBufferCache ; }

    typedef set< CRViewPtr, less<CRViewPtr> > ViewSet;

    void AddSite(CRSitePtr v);
    void RemoveSite(CRSitePtr v);
    void IterateSite(SiteIterator& proc);

    typedef set< CRSitePtr, less<CRSitePtr> > SiteSet;

    void AcquireMIDIHardware(Sound *snd, QuartzRenderer *filterGraph);
    bool IsUsingMIDIHardware(Sound *snd, QuartzRenderer *filterGraph);
    
  protected:

    DynamicHeap & _gcHeap ;
    DynamicHeap & _tmpHeap;
    
    // SEH
    void IterateSite_helper(SiteIterator& proc, SiteSet::iterator i);
    void IterateViews_helper(ViewIterator& proc, set< CRViewPtr, less<CRViewPtr> >::iterator i);
    

    GCList _gcList ;

    GCRoots _gcRoots ;

    CritSect _critSect;

    // caches buffers from import before view/device exists
    SoundBufferCache *_soundBufferCache; 

    // TODO: like not to use pointer, but compiler complains.
    ViewSet & _viewSet;
    SiteSet & _siteSet;

    bool _inited;

    QuartzRenderer *_filterGraph;
    Sound *_txSnd;
} ;

Context & GetCurrentContext() ;
SoundBufferCache* GetSoundBufferCache();

#endif /* DA_CONTEXT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\context.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Context implementation

*******************************************************************************/


#include "headers.h"
#include "context.h"
#include "view.h"
#include "eventq.h"
#include "import.h"
#include "privinc/util.h"
#include "privinc/registry.h"
#include "privinc/discimg.h"
#include "privinc/dddevice.h"
#include "privinc/bufferl.h"
#include "privinc/snddev.h"
#include "privinc/helpq.h"
#include "backend/sndbvr.h"


#if PRODUCT_PROF
#include "../../../tools/x86/icecap/icapexp.h"
#endif

Context * globalCtx = NULL ;

//TODO this is here because of a bug in cl.exe v. 7071. It is not
//referenced and should be optimized out.
Context::ViewSet cvs;    
Context::SiteSet css;    

Context::Context ()
: _inited(false),
  _gcHeap(CreateWin32Heap("Context GC Win32 Heap", 0, 0, 0)),
  _gcList(CreateGCList()),
  _gcRoots(CreateGCRoots()),
  _viewSet(* new ViewSet),
  _siteSet(* new SiteSet),
  _filterGraph(NULL),
  _tmpHeap(TransientHeap("Tmp Value Heap", 2000))
{
    TraceTag((tagServerCtx, "Context(%lx)::Context", this));

    _soundBufferCache = new SoundBufferCache();

    _inited = true;
}

void 
Context::Cleanup (bool bShutdown)
{
    if (!_inited) return;

    _inited = false;

    // Cleans up data structures

    TraceTag((tagServerCtx, "Context(%lx)::~Context", this));

#if DEVELOPER_DEBUG
    DumpGCRoots(_gcRoots);
#endif

    // TODO: We should do a GCCleanup but this seems to cause problems
    
    if (!bShutdown) {
        CleanUpGCList(_gcList, _gcRoots);
        delete _soundBufferCache;
    }
    

    FreeGCList(_gcList);
    FreeGCRoots(_gcRoots);

    Assert(_viewSet.size() == 0);
    delete & _viewSet;          // DecPickEvent needs the viewSet

    Assert(_siteSet.size() == 0);
    delete & _siteSet;

    DestroyWin32Heap (_gcHeap) ;
    delete &_tmpHeap;

}

void Context::AddView(CRViewPtr v)
{
    CritSectGrabber csg(GetCritSect());
    
    v->AddRef();
    
    _viewSet.insert(v);

    TraceTag((tagServerCtx, "AddView: %lx", v));
}

void Context::RemoveView(CRViewPtr v)
{
    CritSectGrabber csg(GetCritSect());

    TraceTag((tagServerCtx, "RemoveView: %lx", v));
    
    if (_viewSet.find(v) != _viewSet.end()) {

        TraceTag((tagServerCtx, "RemoveView - Found %x", v));
    
        _viewSet.erase(v);

        v->Release();
    }
}

void Context::IterateViews(ViewIterator& proc)
{
    set< CRViewPtr, less<CRViewPtr> > viewSetCopy ;
    
    // Copy the list so that we do not have the critical section while
    // we are calling the user supplied function - otherwise we could
    // (and likely will) cause deadlock

    TraceTag((tagServerCtx, "IterateViews::_viewSet(%d)",
              _viewSet.size()));
    
    {
        CritSectGrabber csg(GetCritSect());

        for (set< CRViewPtr, less<CRViewPtr> >::iterator i = _viewSet.begin();
             i != _viewSet.end();
             i++) {

            viewSetCopy.insert(*i);

#ifdef _DEBUG
            int refCnt =
#endif          
            // Need to AddRef to ensure it is not deleted while we are
            // processing it
            (*i)->AddRef();

            TraceTag((tagServerCtx,
                      "IterateViews(%lx) - After AddRef %d, dwRef=%d",
                      (*i), refCnt, (*i)->GetRefCount()));
        }
    }
    
    for (set< CRViewPtr, less<CRViewPtr> >::iterator i = viewSetCopy.begin();
         i != viewSetCopy.end(); i++) {

        IterateViews_helper(proc, i);

#ifdef _DEBUG
        int refCnt =
#endif          
        // Release it now since we do not need it anymore
        (*i)->Release();

        TraceTag((tagServerCtx,
                  "IterateViews(%lx) - After Release %d",
                  (*i), refCnt));

        // DON'T USE (*i) AFTER THE RELEASE!!!! THE VIEW MIGHT BE GONE
    }
}

void Context::IterateViews_helper(
    ViewIterator& proc,
    set< CRViewPtr, less<CRViewPtr> >::iterator i)
{
    __try {
        proc.Process(*i);
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        ReportErrorHelper(DAGetLastError(), DAGetLastErrorString());
        // Do nothing for now but we need to make sure we release everything
    }
}

void Context::ViewDecPickEvent(CRViewPtr v)
{
    CritSectGrabber csg(GetCritSect());

    if (_viewSet.find(v) != _viewSet.end())
        v->DecPickEvent();
}

void
Context::AcquireMIDIHardware(Sound *snd, QuartzRenderer *filterGraph)
{
    CritSectGrabber csg(GetCritSect());

    if (_filterGraph)
        _filterGraph->Stop();

    _filterGraph = filterGraph;
    _txSnd = snd;
}
    
bool
Context::IsUsingMIDIHardware(Sound *snd, QuartzRenderer *filterGraph)
{
    CritSectGrabber csg(GetCritSect());

    return (_filterGraph == filterGraph) && (_txSnd == snd);
}


void ViewDecPickEvent(CRViewPtr v)
{ globalCtx->ViewDecPickEvent(v); }


class DiscreteImageDeleter : public ViewIterator {
 public:
    DiscreteImageDeleter(DiscreteImage *img, DirectDrawViewport *vprt)
    : _img(img), _viewport(vprt) {}

    virtual void Process(CRViewPtr v) {
        ViewPusher vp (v,TRUE);

        DirectDrawViewport *viewport = v->GetImageDev();

        // todo: minor redundancy:  !_viewport.
        if (viewport) {
            if (!_viewport || (_viewport == viewport))
                viewport->DiscreteImageGoingAway(_img);
        }
    }
  private:
    DiscreteImage *_img;
    DirectDrawViewport *_viewport;
};


void DiscreteImageGoingAway(DiscreteImage *img,
                            DirectDrawViewport *vprt)
{
    GetCurrentContext().IterateViews(DiscreteImageDeleter(img, vprt));
}

class SoundDeleter : public ViewIterator {
 public:
    SoundDeleter(Sound *sound) : _sound(sound) {}

    virtual void Process(CRViewPtr view) {
        ViewPusher vp (view, TRUE);

        // remove TxSound
        
        SoundInstanceList *s = view->GetSoundInstanceList();

        // the list may have been gone after StopModel, so s can be
        // NULL
        if (s) {
            s->Stop(_sound);
        }

        MetaSoundDevice *currentDev = view->GetSoundDev();

        if (currentDev) {
            DirectSoundDev *dsDev = currentDev->dsDevice;
            Assert(dsDev);
            dsDev->RemoveStreamFile(_sound);
            dsDev->RemoveDSMasterBuffer(_sound);
        }
    }
    
  private:
    Sound *_sound;
};

void SoundGoingAway(Sound *sound)
{
    GetCurrentContext().IterateViews(SoundDeleter(sound));
}

void Context::AddSite(CRSitePtr s)
{
    CritSectGrabber csg(GetCritSect());
    
    s->AddRef();
    
    _siteSet.insert(s);
}

void Context::RemoveSite(CRSitePtr s)
{
    CritSectGrabber csg(GetCritSect());

    if (_siteSet.find(s) != _siteSet.end()) {

        _siteSet.erase(s);
    
        s->Release();
    }
}

void Context::IterateSite(SiteIterator& proc)
{
    set< CRSitePtr, less<CRSitePtr> > siteSetCopy ;
    
    // Copy the list so that we do not have the critical section while
    // we are calling the user supplied function - otherwise we could
    // (and likely will) cause deadlock
    
    {
        CritSectGrabber csg(GetCritSect());

        for (SiteSet::iterator i = _siteSet.begin();
             i != _siteSet.end();
             i++) {

            siteSetCopy.insert(*i);

            // Need to AddRef to ensure it is not deleted while we are
            // processing it
            (*i)->AddRef();
        }
    }

    for (SiteSet::iterator i = siteSetCopy.begin();
         i != siteSetCopy.end(); i++) {

        IterateSite_helper(proc, i);

        // Release it now since we do not need it anymore
        (*i)->Release();
    }
}

void Context::
IterateSite_helper(SiteIterator& proc, SiteSet::iterator i)
{    
    __try {
        proc.Process(*i);
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        // Do since reporting the error can be reentrant
    }
}


// =========================================
// C Calls
// =========================================

Context &
GetCurrentContext()
{
    return *globalCtx ;
}


SoundBufferCache *
GetSoundBufferCache()
{
    return(GetCurrentContext().GetSoundBufferCache());
}

DynamicHeap &
GetTmpHeap()
{
    if (!globalCtx)
        return GetGCHeap();
    
    return globalCtx->GetTmpHeap();
}

DynamicHeap &
GetGCHeap()
{
    if (!globalCtx)
        return (GetSystemHeap()) ;

    return globalCtx->GetGCHeap() ;
}

GCList
GetCurrentGCList()
{
    if (!globalCtx)
        return NULL ;

    return globalCtx->GetGCList () ;
}

GCRoots GetCurrentGCRoots()
{ return globalCtx->GetGCRoots() ; }

void
SetStatusTextHelper(char * szStatus)
{
    CRViewPtr view = IntGetCurrentView();

    if (view)
        view->SetStatusText(szStatus);
}

class ErrorIterator : public SiteIterator {
 public:
    ErrorIterator(HRESULT hr, LPCWSTR szErrorText)
    : _hr(hr), _str(szErrorText) {}

    virtual void Process(CRSitePtr s) {
        Assert(s);

        s->ReportError(_hr, _str);
    }
  private:
    HRESULT _hr;
    LPCWSTR _str;
};

void
ReportErrorHelper(HRESULT errcode, LPCWSTR szErrorText)
{
    GetCurrentContext().IterateSite(ErrorIterator(errcode, szErrorText));
}

class ReportGCIterator : public SiteIterator {
 public:
    ReportGCIterator(bool b)
    : _b(b) {}

    virtual void Process(CRSitePtr s) {
        Assert(s);

        s->ReportGC(_b);
    }
  private:
    bool _b;
};

void
ReportGCHelper(bool bStarting)
{
    GetCurrentContext().IterateSite(ReportGCIterator(bStarting));
}

void
AcquireMIDIHardware(Sound *snd, QuartzRenderer *filterGraph)
{
    GetCurrentContext().AcquireMIDIHardware(snd, filterGraph);
}

bool
IsUsingMIDIHardware(Sound *snd, QuartzRenderer *filterGraph)
{
    return GetCurrentContext().IsUsingMIDIHardware(snd, filterGraph);
}

void
FreeSoundBufferCache()
{
    GetCurrentContext().GetSoundBufferCache()->FlushCache();
}

// =========================================
// Initialization
// =========================================

void
InitializeModule_Context()
{
    globalCtx = NEW Context ;
}

void
DeinitializeModule_Context(bool bShutdown)
{
    if (globalCtx) globalCtx->Cleanup(bShutdown);

    delete globalCtx ;
    globalCtx = NULL ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\daviewevents.h ===
#include "..\..\types\idl\danimid.h"

//////////////////////////////////////////////////////////////////////////////
// CProxy_IDAViewEvents
template <class T>
class CProxy_IDAViewEvents : public IConnectionPointImpl<T, &DIID__IDAViewEvents, CComDynamicUnkArray>
{
public:
    //methods:
    //_IDAViewEvents : IDispatch
public:

    void Fire_Start()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_VIEWEVENT_START, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }
 
    void Fire_Stop()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_VIEWEVENT_STOP, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }

    void Fire_OnMouseMove(double when,
                          LONG xPos, 
                          LONG yPos,
                          short modifiers)
    {
        VARIANTARG* pvars = NEW VARIANTARG[4];
        
        for (int i = 0; i < 4; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
		    if (*pp != NULL)
            {
                pvars[3].vt = VT_R8;
                pvars[3].dblVal = when;
                pvars[2].vt = VT_I4;
                pvars[2].lVal = xPos;
                pvars[1].vt = VT_I4;
                pvars[1].lVal = yPos;
                pvars[0].vt = VT_I2;
                pvars[0].bVal = modifiers;
                DISPPARAMS disp = { pvars, NULL, 4, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_VIEWEVENT_ONMOUSEMOVE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }
    
    
    void Fire_OnMouseButton(double when,
                           LONG xPos, 
                           LONG yPos,
                           short button,
                           VARIANT_BOOL bPressed,
                           short modifiers)
    {
        VARIANTARG* pvars = NEW VARIANTARG[6];
        for (int i = 0; i < 6; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[5].vt = VT_R8;
                pvars[5].dblVal = when;
                pvars[4].vt = VT_I4;
                pvars[4].lVal = xPos;
                pvars[3].vt = VT_I4;
                pvars[3].lVal= yPos;
                pvars[2].vt = VT_I2;
                pvars[2].bVal = button;
                pvars[1].vt = VT_BOOL;
                pvars[1].boolVal = bPressed;
                pvars[0].vt = VT_I2;
                pvars[0].bVal = modifiers;
                
                DISPPARAMS disp = { pvars, NULL, 6, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_VIEWEVENT_ONMOUSEBUTTON, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_OnKey(double when,
                    LONG key,
                    VARIANT_BOOL bPressed,
                    short modifiers)
    {
        VARIANTARG* pvars = NEW VARIANTARG[4];
        
        for (int i = 0; i < 4; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[3].vt = VT_R8;
                pvars[3].dblVal = when;
                pvars[2].vt = VT_I4;
                pvars[2].lVal = key;
                pvars[1].vt = VT_BOOL;
                pvars[1].boolVal = bPressed;
                pvars[0].vt = VT_I2;
                pvars[0].bVal = modifiers;
                
                DISPPARAMS disp = { pvars, NULL, 4, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_VIEWEVENT_ONKEY, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }

    void Fire_OnFocus(VARIANT_BOOL bHasFocus)
    {
        VARIANTARG* pvars = NEW VARIANTARG[1];

        for (int i = 0; i < 1; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[0].vt = VT_BOOL;
                pvars[0].boolVal= bHasFocus;
                
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_VIEWEVENT_ONFOCUS, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }
 
    void Fire_Pause()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_VIEWEVENT_PAUSE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }
 
    void Fire_Resume()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_VIEWEVENT_RESUME, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }

    void Fire_Error(HRESULT HResult, LPCWSTR ErrorString)
    {
        VARIANTARG* pvars = NEW VARIANTARG[2];
        for (int i = 0; i < 2; i++)
            VariantInit(&pvars[i]);
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                pvars[0].vt = VT_I4;
                pvars[0].lVal= (long)HResult;
                pvars[1].vt = VT_BSTR;
                pvars[1].bstrVal= SysAllocString(ErrorString);
                
                DISPPARAMS disp = { pvars, NULL, 2, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(DISPID_VIEWEVENT_ERROR, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
                SysFreeString(pvars[1].bstrVal);
            }
            pp++;
        }
        pT->Unlock();
        delete[] pvars;
    }
 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\comobj2.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "cbvr.h"
#include "srvprims.h"
#include "comcb.h"
#include "bvrtypes.h"

#include "primmth2.h"

void InitClasses2 ()
{
    AddEntry (TypeInfoEntry(CRCOLOR_TYPEID,CDAColorCreate)) ;
    AddEntry (TypeInfoEntry(CRMATTE_TYPEID,CDAMatteCreate)) ;
    AddEntry (TypeInfoEntry(CRNUMBER_TYPEID,CDANumberCreate)) ;
    AddEntry (TypeInfoEntry(CRPOINT3_TYPEID,CDAPoint3Create)) ;
    AddEntry (TypeInfoEntry(CRTRANSFORM2_TYPEID,CDATransform2Create)) ;
    AddEntry (TypeInfoEntry(CRVECTOR3_TYPEID,CDAVector3Create)) ;
    AddEntry (TypeInfoEntry(CRENDSTYLE_TYPEID,CDAEndStyleCreate)) ;
    AddEntry (TypeInfoEntry(CRBBOX2_TYPEID,CDABbox2Create)) ;
    AddEntry (TypeInfoEntry(CREVENT_TYPEID,CDAEventCreate)) ;
    AddEntry (TypeInfoEntry(CRUSERDATA_TYPEID,CDAUserDataCreate)) ;
}

_ATL_OBJMAP_ENTRY PrimObjectMap2[] = {
    OBJECT_ENTRY(CLSID_DAColor,CDAColor)
    OBJECT_ENTRY(CLSID_DAMatte,CDAMatte)
    OBJECT_ENTRY(CLSID_DANumber,CDANumber)
    OBJECT_ENTRY(CLSID_DAPoint3,CDAPoint3)
    OBJECT_ENTRY(CLSID_DATransform2,CDATransform2)
    OBJECT_ENTRY(CLSID_DAVector3,CDAVector3)
    OBJECT_ENTRY(CLSID_DAEndStyle,CDAEndStyle)
    OBJECT_ENTRY(CLSID_DABbox2,CDABbox2)
    OBJECT_ENTRY(CLSID_DAEvent,CDAEvent)
    OBJECT_ENTRY(CLSID_DAUserData,CDAUserData)
    {NULL, NULL, NULL, NULL}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\cview.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of views.
    TODO: This file needs to be broken up and lots of code factoring.

*******************************************************************************/


#include "headers.h"
#include "cview.h"
#include "comconv.h"
#include "privinc/resource.h"
#include "privinc/util.h"
#include "srvprims.h"
#include "mshtml.h"

DeclareTag(tagCView, "CView", "CView methods");

// -------------------------------------------------------
// CView
// -------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CView::CView
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------------

CView::CView()
: _view(NULL),
  _dwSafety(0),
  _startFlags(0)
{
    TraceTag((tagCView, "CView(%lx)::CView", this));
}


//+-------------------------------------------------------------------------
//
//  Method:     CView::~CView
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CView::~CView()
{
    TraceTag((tagCView, "CView(%lx)::~CView", this));
    TraceTag((tagGCMedia, "CView(%lx)::~CView", this));

    if (_view)
        CRDestroyView(_view);
}


bool
CView::Init()
{
    _view = CRCreateView();
    return _view != NULL;
}

HRESULT
CView::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    Fire_Error(hr, str);
    if (str)
        return CComCoClass<CView, &CLSID_DAView>::Error(str,
                                                        IID_IDAView,
                                                        hr);
    else
        return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::Tick
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::Render()
{
    TraceTag((tagCView,
              "CView(%lx)::Render()",
              this));

    if (CRRender(_view))
        return S_OK;
    else {

        HRESULT dahr = CRGetLastError();

        if (dahr == DAERR_VIEW_SURFACE_BUSY)
            return S_OK;
        else
            return Error();
    }
}


// SetSimulation time sets the time for subsequent rendering
STDMETHODIMP
CView::Tick(double simTime, VARIANT_BOOL *needToRender) 
{
    // Ensure output parameters are setup correctly
    if (needToRender)
        *needToRender = false;

    bool bRender = false;
    bool bOk;

    bOk = CRTick(_view, simTime, &bRender);
    if (needToRender)
        *needToRender = bRender;

    TraceTag((tagCView,
              "CView(%lx)::Tick(%g), needRender = %d",
              this, simTime, bRender));

    if (bOk)
        return S_OK;
    else {

        HRESULT dahr = CRGetLastError();

        if (dahr == DAERR_VIEW_SURFACE_BUSY)
            return S_OK;

        if (!(_startFlags & CRAsyncFlag) && dahr == E_PENDING)
            return S_OK;
        
        return Error();
    }
}

STDMETHODIMP
CView::get_SimulationTime(double * simTime) 
{
    CHECK_RETURN_NULL(simTime);

    *simTime = CRGetSimulationTime(_view);

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::AddBvrToRun
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::AddBvrToRun(IDABehavior *bvr, long *pId)
{
    TraceTag((tagCView, "CView(%lx)::AddBvrToRun(%lx)", this, bvr));

    bool ok = false;
    
    CHECK_RETURN_NULL(pId);
    MAKE_BVR_NAME(crbvr,bvr);
    
    ok = CRAddBvrToRun(_view, crbvr, false, pId);

  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CView::RemoveRunningBvr(long id)
{
    TraceTag((tagCView, "CView(%lx)::RemoveRunningBvr(%d)", this, id));

    if (CRRemoveRunningBvr(_view, id))
        return S_OK;
    else
        return Error();
}

STDMETHODIMP
CView::StartModelEx(IDAImage * pImage,
                    IDASound * pSound,
                    double startTime,
                    DWORD dwFlags)
{
    TraceTag((tagCView,
              "CView(%lx)::StartModel(%lx,%lx,%lg)",
              this, pImage, pSound, startTime));
    TraceTag((tagGCMedia,
              "CView(%lx)::StartModel(%lx,%lx,%lg)",
              this, pImage, pSound, startTime));

    bool ok = false;
    bool bPending = false;
    
    // First thing is to set ourselves as the service provider
    if (!CRSetServiceProvider(_view, (IServiceProvider *) this))
    {
        goto done;
    }

    // Store the flags so we know whether to return E_PENDING errors
    // from tick

    _startFlags = dwFlags;
    
    CRImagePtr img;

    if (pImage)
    {
        img = (CRImagePtr) ::GetBvr(pImage);
        if (!img)
        {
            goto done;
        }
    }
    else
    {
        img = NULL;
    }
                
    CRSoundPtr snd;

    if (pSound)
    {
        snd = (CRSoundPtr) ::GetBvr(pSound);
        if (!snd)
        {
            goto done;
        }
    }
    else
    {
        snd = NULL;
    }

    // Since the site creates a cycle make sure we do not leak unless
    // the client does not call stopmodel
    
    CRSetSite(_view, this);

    
    ok = CRStartModel(_view, img, snd, startTime, dwFlags, &bPending);

    if (!ok) {
        CRSetSite(_view, NULL);
    }
  done:

    if (ok) {
        Fire_Start();
        return bPending?E_PENDING:S_OK;

    } else {

        HRESULT dahr = CRGetLastError();

        if (dahr == DAERR_VIEW_SURFACE_BUSY)
            return S_OK;
        else
        {
            // Clear the service provider
            CRSetServiceProvider(_view, NULL);
            return Error();
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::StopModel
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::StopModel()
{
    TraceTag((tagCView, "CView(%lx)::StopModel()", this));
    TraceTag((tagGCMedia, "CView(%lx)::StopModel()", this));

    // Break the cycle
    CRSetSite(_view, NULL);

    Fire_Stop();

    _vs.Release();
    _pClientSite.Release();
    CRSetServiceProvider(_view, NULL);

    if (CRStopModel(_view))
    {
        return S_OK;
    }
    else
    {   
        return Error();
    }
}

STDMETHODIMP
CView::Pause()
{
    TraceTag((tagCView, "CView(%lx)::Pause()", this));

    if (CRPauseModel(_view)) 
    {
        Fire_Pause();
        return S_OK;
    }
    else
    {
        return Error();
    }
}

STDMETHODIMP
CView::Resume()
{
    TraceTag((tagCView, "CView(%lx)::Resume()", this));

    if (CRResumeModel(_view)) 
    {
        Fire_Resume();
        return S_OK;
    }
    else
    {
        return Error();
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::get_Window
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::get_Window(long * phwnd)
{
    TraceTag((tagCView,
              "CView(%lx)::get_Window",
              this));

    CHECK_RETURN_NULL(phwnd);

    *phwnd = PtrToUlong(CRGetWindow(_view));

    return S_OK;
}

STDMETHODIMP
CView::get_Window2(HWND * phwnd)
{
    TraceTag((tagCView,
              "CView(%lx)::get_Window",
              this));

    CHECK_RETURN_NULL(phwnd);

    *phwnd = CRGetWindow(_view) ;

    return S_OK;
}
//+-------------------------------------------------------------------------
//
//  Method:     CView::put_Window
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::put_Window(long hwnd)
{
    TraceTag((tagCView,
              "CView(%lx)::put_Window(%lx)",
              this,hwnd));

    if (CRSetWindow(_view,(HWND)LongToHandle(hwnd)))
        return S_OK;
    else
        return Error();
}

STDMETHODIMP
CView::put_Window2(HWND hwnd)
{
    TraceTag((tagCView,
              "CView(%lx)::put_Window2(%lx)",
              this,hwnd));

    if (CRSetWindow(_view,hwnd))
        return S_OK;
    else
        return Error();
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::put_IDirectDrawSurface(IUnknown *ddsurf)
{
    if (CRSetDirectDrawSurface(_view, ddsurf))
        return S_OK;
    else
        return Error();
}

STDMETHODIMP
CView::get_IDirectDrawSurface(IUnknown **iunk)
{
    CHECK_RETURN_SET_NULL(iunk);
    *iunk = CRGetDirectDrawSurface(_view);
    return S_OK;
}

STDMETHODIMP
CView::put_DC(HDC dc)
{
    if (CRSetDC(_view, dc))
        return S_OK;
    else
        return Error();
}

STDMETHODIMP
CView::get_DC(HDC *dc)
{
    CHECK_RETURN_NULL(dc);
    
    *dc = CRGetDC(_view);
    return S_OK;
}


STDMETHODIMP
CView::put_CompositeDirectlyToTarget(VARIANT_BOOL composeToTarget)
{
    if (CRSetCompositeDirectlyToTarget(_view, composeToTarget?true:false))
        return S_OK;
    else
        return Error();
}

STDMETHODIMP
CView::get_CompositeDirectlyToTarget(VARIANT_BOOL *composeToTarget)
{
    CHECK_RETURN_NULL(composeToTarget);
    
    *composeToTarget = CRGetCompositeDirectlyToTarget(_view);
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::RePaint
//
//  Synopsis:   Called when a window needs to be repainted
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::RePaint(long x, long y, long width, long height)
{
    TraceTag((tagCView,
              "CView(%lx)::Paint(%ld,%ld,%ld,%ld)",
              this, x,y,width,height));

    if (CRRepaint(_view, x, y, width, height))
        return S_OK;
    else
        return Error();
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::SetViewport
//
//  Synopsis:   Called to set the window size relative
//              to the rendering target.  This rectangle
//              defines our coordinate space.
//
//--------------------------------------------------------------------------
STDMETHODIMP
CView::SetViewport(long x, long y, long width, long height)
{
    TraceTag((tagCView,
              "CView(%lx)::SetSize(%ld,%ld,%ld,%ld)",
              this, x,y,width,height));
    
    if (CRSetViewport(_view, x, y, width, height))
        return S_OK;
    else
        return Error();
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::SetClipRect
//
//  Synopsis:   Relative to the viewport, clip rendering
//              to this rectangle.
//
//--------------------------------------------------------------------------
STDMETHODIMP
CView::SetClipRect(long x, long y, long width, long height)
{
    if (CRSetClipRect(_view, x, y, width, height))
        return S_OK;
    else
        return Error();
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::PaletteChanged
//
//  Synopsis:   Indicates that the palette has changed
//
//  NOTE [Hollasch]:  This method is never called -- seems like a good
//                    candidate for deletion.
//
//--------------------------------------------------------------------------
STDMETHODIMP
CView::PaletteChanged(VARIANT_BOOL bNew)
{
    TraceTag((tagCView, "CView(%lx)::PaletteChanged (%d)",
              this,bNew));

    return S_OK;
}

CRSTDAPICB_(void)
CView::SetStatusText(LPCWSTR StatusText)
{
    if (_vs) {
        BSTR bstr = W2BSTR(StatusText);
        
        if (bstr) {
            _vs->SetStatusText(bstr);
            SysFreeString(bstr);
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::put_Site
//
//  Synopsis:   Sets an view site.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::put_Site(IDAViewSite * pViewSite)
{
    TraceTag((tagCView,
              "CView(%lx)::put_ViewSite(%lx)",
              this, pViewSite));

    Lock();
    _vs = pViewSite;
    Unlock();
    
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::get_Site
//
//  Synopsis:   Sets an view site.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::get_Site(IDAViewSite ** pViewSite)
{
    TraceTag((tagCView,
              "CView(%lx)::get_ViewSite()",
              this));

    CHECK_RETURN_SET_NULL(pViewSite);

    Lock();
    
    if (_vs) _vs->AddRef();
    
    *pViewSite = _vs;

    Unlock();
    
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::put_ClientSite
//
//  Synopsis:   Sets a view's ClientSite.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::put_ClientSite(IOleClientSite * pClientSite)
{
    TraceTag((tagCView,
              "CView(%lx)::put_ClientSite(%lx)",
              this, pClientSite));

    _pClientSite = pClientSite;

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::get_ClientSite
//
//  Synopsis:   Sets an view ClientSite.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::get_ClientSite(IOleClientSite ** pClientSite)
{
    TraceTag((tagCView,
              "CView(%lx)::get_ViewClientSite()",
              this));

    CHECK_RETURN_SET_NULL(pClientSite);

    if (_pClientSite)
    {
        _pClientSite->AddRef();
        *pClientSite = _pClientSite;
    }

    return S_OK;
}

class
__declspec(uuid("5DA88D2C-0DB0-11d1-87F4-00C04FC29D46")) 
ATL_NO_VTABLE CDAPreferences : public CComObjectRootEx<CComMultiThreadModel>,
                               public CComCoClass<CDAPreferences, &__uuidof(CDAPreferences)>,
                               public IDispatchImpl<IDAPreferences, &IID_IDAPreferences, &LIBID_DirectAnimation>,
                               public IObjectSafetyImpl<CDAPreferences>,
                               public ISupportErrorInfoImpl<&IID_IDAPreferences>
{
  public:
#if _DEBUG
    const char * GetName() { return "CDAPreferences"; }
#endif
    BEGIN_COM_MAP(CDAPreferences)
        COM_INTERFACE_ENTRY(IDAPreferences)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP()

    // IDAPreferences methods
    STDMETHOD(PutPreference)(BSTR prefName, VARIANT v) {
        Assert(_cv);
        
        if (CRPutPreference(_cv->GetView(), prefName, v))
            return S_OK;
        else
            return _cv->Error();
    }
    
    STDMETHOD(GetPreference)(BSTR prefName, VARIANT *pV) {
        Assert(_cv);

        CHECK_RETURN_NULL(pV);
        
        if (CRGetPreference(_cv->GetView(), prefName, pV))
            return S_OK;
        else
            return _cv->Error();
    }
    
    STDMETHOD(Propagate)() {
        Assert (_cv);
        if (CRPropagate(_cv->GetView()))
            return S_OK;
        else
            return _cv->Error();
    }

    CDAPreferences(CView * cv = NULL) : _cv(cv) {
        if (_cv) ((IDAPreferences *)_cv)->AddRef();
    }

    ~CDAPreferences() {
        if (_cv) ((IDAPreferences *)_cv)->Release();
    }
    
    void SetView(CView * cv) {
        if (_cv) ((IDAPreferences *)_cv)->Release();
        _cv = cv;
        if (_cv) ((IDAPreferences *)_cv)->AddRef();
    }
    CView * GetView() { return _cv; }
    
  protected:
    CView * _cv;
};

STDMETHODIMP
CView::get_Preferences(IDAPreferences **ppPrefs)
{
    HRESULT hr = E_FAIL;
    CHECK_RETURN_SET_NULL(ppPrefs);

    // See if we have a preference object and create one if we do not
    
    DAComObject<CDAPreferences> *pNew;
    DAComObject<CDAPreferences>::CreateInstance(&pNew);

    if (!pNew) {
        hr = E_OUTOFMEMORY;
    }
    else {
        
        pNew->SetView(this);
        
        hr = pNew->QueryInterface(IID_IDAPreferences, (void **)ppPrefs);
    }
    if (FAILED(hr))
        delete pNew;
    return hr;
}

STDMETHODIMP
CView::QueryHitPoint(DWORD dwAspect,
                     LPCRECT prcBounds,
                     POINT ptLoc,
                     LONG lCloseHint,
                     DWORD *pHitResult)
{
    CHECK_RETURN_NULL(pHitResult);

    *pHitResult = CRQueryHitPoint(_view,
                                  dwAspect,
                                  prcBounds,
                                  ptLoc,
                                  lCloseHint);

    return S_OK;
}


STDMETHODIMP
CView::QueryHitPointEx(LONG s,
                       DWORD_PTR *cookies,
                       double *points,
                       LPCRECT prcBounds,
                       POINT   ptLoc,
                       LONG *hits)
{
    CHECK_RETURN_NULL (hits);
    CHECK_RETURN_NULL (cookies);
    CHECK_RETURN_NULL (points);

    if (s<1) return E_INVALIDARG;

    *hits = CRQueryHitPointEx(_view, s, cookies, points, prcBounds, ptLoc);

    return S_OK;
}


//----------------------------------------------------------------------------
// Returns the set of invalidated rectangles from the last Render.  If
// the list of rects is null, return total number of rects in
// pNumRects.  Otherwise, fill in pRects up to size elements, putting
// number filled in in pNumRects.
//----------------------------------------------------------------------------
STDMETHODIMP
CView::GetInvalidatedRects(DWORD flags,
                           LONG size,
                           RECT *pRects,
                           LONG *pNumRects)
{
    CHECK_RETURN_NULL (pNumRects);

    *pNumRects = CRGetInvalidatedRects(_view,
                                       flags,
                                       size,
                                       pRects);

    return S_OK;
}


//----------------------------------------------------------------------------
// This method fetches the DirectDraw and Direct3DRM interfaces that
// correspond to the view.
//----------------------------------------------------------------------------

STDMETHODIMP
CView::GetDDD3DRM (IUnknown **DirectDraw, IUnknown **D3DRM)
{
    if (CRGetDDD3DRM(_view, DirectDraw, D3DRM))
        return S_OK;
    else
        return Error();
}



//----------------------------------------------------------------------------
// This method fetches the D3D RM device associated with the view, and a
// sequence number.  This number is incremented
//----------------------------------------------------------------------------

STDMETHODIMP
CView::GetRMDevice (IUnknown **D3DRMDevice, DWORD *SeqNum)
{
    CHECK_RETURN_SET_NULL(D3DRMDevice);

    if (CRGetRMDevice(_view, D3DRMDevice, SeqNum))
        return S_OK;
    else
        return Error();
}

STDMETHODIMP
CViewFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppv)
{
    if (ppv)
        *ppv = NULL;
    
    DAComObject<CView>* pNew;
    DAComObject<CView>::CreateInstance(&pNew);

    HRESULT hr = S_OK;

    if (pNew && pNew->Init()) {
        hr = pNew->QueryInterface(riid, ppv);
    } else {
        hr = E_OUTOFMEMORY;
    }

    if (FAILED(hr))
        delete pNew;
    
    return hr;
}

//
// IServiceProvider implementation
//

STDMETHODIMP
CView::QueryService(REFGUID guidService,
                       REFIID riid,
                       void** ppv)
{
    HRESULT hr = E_FAIL;

    DAComPtr<IServiceProvider> sp;

    CHECK_RETURN_SET_NULL(ppv);
    
    if (!_pClientSite)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(_pClientSite->QueryInterface(IID_IServiceProvider,
                                          (void **) &sp));

    if (SUCCEEDED(hr))
    {
        hr = THR(sp->QueryService(guidService,
                                  riid,
                                  ppv));

        if (SUCCEEDED(hr))
        {
            hr = S_OK;
            goto done;
        }
    }
    
    // This means that we could not get the service
    // Specifically catch the window service and see if we can get it
    // from the IOleClientSite
    
    if (!InlineIsEqualGUID(guidService, SID_SHTMLWindow))
    {
        hr = E_FAIL;
        goto done;
    }
    
    {
        CComPtr<IOleContainer> root;
        CComPtr<IHTMLDocument2> htmlDoc;
        DAComPtr<IHTMLWindow2> wnd;

        hr = THR(_pClientSite->GetContainer(&root));

        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = THR(root->QueryInterface(IID_IHTMLDocument2, (void **)&htmlDoc));

        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = THR(htmlDoc->get_parentWindow(&wnd));

        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = THR(wnd->QueryInterface(riid, ppv));

        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
  done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\cview.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _CVIEW_H
#define _CVIEW_H

#include "engine.h"
#include "daviewevents.h"
class ATL_NO_VTABLE CViewFactory : public CComClassFactory {
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//-------------------------------------------------------------------------
//
//  Class:      CView
//
//  Synopsis:
//
//--------------------------------------------------------------------------

class ATL_NO_VTABLE CView :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CView, &CLSID_DAView>,
    public IDispatchImpl<IDA3View, &IID_IDA3View, &LIBID_DirectAnimation>,
    public IObjectSafetyImpl<CView>,
    public ISupportErrorInfoImpl<&IID_IDA3View>,
    public CProxy_IDAViewEvents<CView>,
    public IProvideClassInfo2Impl<&CLSID_DAView, &DIID__IDAViewEvents, &LIBID_DirectAnimation>,
    public IConnectionPointContainerImpl<CView>,
    public CRViewSite,
    public IServiceProvider
{
  public:
    CView();
    virtual ~CView();

    bool Init();

#if _DEBUG
    const char * GetName() { return "CView"; }
#endif

    DECLARE_REGISTRY(CLSID_DAView,
                     LIBID ".DAView.1",
                     LIBID ".DAView",
                     0,
                     THREADFLAGS_BOTH);

    DA_DECLARE_NOT_AGGREGATABLE(CView);
    DECLARE_CLASSFACTORY_EX(CViewFactory);

    BEGIN_COM_MAP(CView)
        COM_INTERFACE_ENTRY(IDA3View)
        COM_INTERFACE_ENTRY(IDA2View)
        COM_INTERFACE_ENTRY(IDAView)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
    END_COM_MAP();

    BEGIN_CONNECTION_POINT_MAP(CView)
        CONNECTION_POINT_ENTRY(DIID__IDAViewEvents)
    END_CONNECTION_POINT_MAP();

    // IDAView methods

    // SetSimulation time sets the time for subsequent rendering
    STDMETHOD(Tick)(double simTime, VARIANT_BOOL *needToRender);
    STDMETHOD(get_SimulationTime)(double * simTime);

    // These methods Render to the given hwnd or surface
    STDMETHOD(Render)();
    STDMETHOD(put_IDirectDrawSurface)(IUnknown *ddsurf);
    STDMETHOD(get_IDirectDrawSurface)(IUnknown **ddsurf);
    STDMETHOD(put_DC)(HDC  dc);
    STDMETHOD(get_DC)(HDC *dc);
    STDMETHOD(put_CompositeDirectlyToTarget)(VARIANT_BOOL  composeToTarget);
    STDMETHOD(get_CompositeDirectlyToTarget)(VARIANT_BOOL *composeToTarget);

    STDMETHOD(AddBvrToRun)(IDABehavior *bvr, long *pId);
    STDMETHOD(RemoveRunningBvr)(long id);

    STDMETHOD(StartModel)(IDAImage * pImage,
                          IDASound * pSound,
                          double startTime)
    { return StartModelEx(pImage, pSound, startTime, 0); }

    STDMETHOD(StartModelEx)(IDAImage * pImage,
                            IDASound * pSound,
                            double startTime,
                            DWORD dwFlags);
    STDMETHOD(StopModel)();
    STDMETHOD(Pause)();
    STDMETHOD(Resume)();
    STDMETHOD(get_Window)(long * hwnd);
    STDMETHOD(get_Window2)(HWND * hwnd);
    STDMETHOD(put_Window)(long hwnd);
    STDMETHOD(put_Window2)(HWND hwnd);
    STDMETHOD(SetViewport)(long x, long y, long width, long height);
    STDMETHOD(SetClipRect)(long x, long y, long width, long height);
    STDMETHOD(RePaint)(long x, long y, long width, long height);
    STDMETHOD(PaletteChanged)(VARIANT_BOOL bNew);
    STDMETHOD(put_Site)(IDAViewSite * pViewSite);
    STDMETHOD(get_Site)(IDAViewSite ** pViewSite);
    STDMETHOD(put_ClientSite)(IOleClientSite * pClientSite);
    STDMETHOD(get_ClientSite)(IOleClientSite ** pClientSite);

    // IDAViewEvent methods

    STDMETHOD(OnMouseMove)(double when,
                           long x, long y,
                           BYTE modifiers);
    STDMETHOD(OnMouseLeave)(double when);
    STDMETHOD(OnMouseButton)(double when,
                             long x, long y,
                             BYTE button,
                             VARIANT_BOOL bPressed,
                             BYTE modifiers);
    STDMETHOD(OnKey)(double when,
                     long key,
                     VARIANT_BOOL bPressed,
                     BYTE modifiers);
    STDMETHOD(OnFocus)(VARIANT_BOOL bHasFocus);

    STDMETHOD(get_Preferences)(IDAPreferences **prefs);

    STDMETHOD(QueryHitPoint)(DWORD dwAspect,
                             LPCRECT prcBounds,
                             POINT ptLoc,
                             LONG lCloseHint,
                             DWORD *pHitResult);

    STDMETHOD(QueryHitPointEx)(LONG s,
                               DWORD_PTR *cookies,
                               double *points,
                               LPCRECT prcBounds,
                               POINT   ptLoc,
                               LONG *hits);

    STDMETHOD(GetDDD3DRM) (IUnknown **DirectDraw,
                           IUnknown **D3DRM);

    STDMETHOD(GetRMDevice) (IUnknown **D3DRMDevice,
                            DWORD     *SequenceNumber);


    STDMETHOD(GetInvalidatedRects)(DWORD flags,
                                   LONG size,
                                   RECT *pRects,
                                   LONG *pNumRects);
    
    //
    // IServiceProvider interfaces
    //

    STDMETHOD(QueryService)(REFGUID guidService,
                            REFIID riid,
                            void** ppv);

    CRView * GetView () { return _view ; }

    HRESULT Error();

    CRSTDAPICB_(void) SetStatusText(LPCWSTR StatusText);
    
  private:
    CRView *              _view;
    DWORD                 _dwSafety;
    DAComPtr<IDAViewSite> _vs;
    DAComPtr<IOleClientSite> _pClientSite;
    DWORD                 _startFlags;
};

#endif /* _CVIEW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\crview.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of views.
    TODO: This file needs to be broken up and lots of code factoring.

*******************************************************************************/


#include "headers.h"
#include "context.h"
#include "view.h"
#include "privinc/resource.h"
#include "privinc/util.h"
#include "privinc/htimer.h"
#include "privinc/viewport.h"
#include "import.h"
#include "privinc/dddevice.h"
#include "privinc/d3dutil.h"    // For GetD3DRM()

extern void ReapElderlyMasterBuffers();
DeclareTag(tagCRView2, "CRView", "CRView methods");

DirectDrawViewport * g_dummyImageDev = NULL;
DirectDrawViewport *CreateDummyImageDev();

#if PERFORMANCE_REPORTING
GlobalTimers *globalTimers = NULL;
#endif  // PERFORMANCE_REPORTING

#ifdef _DEBUG
void DumpWindowSize(HWND hwnd, char * str = "")
{
    RECT r;
    GetClientRect(hwnd,&r);
    char buf[2048];
    
    sprintf (buf,
             "%s: left - %d, top - %d, right - %d, bottom - %d\n",
             str,
             r.left,r.top,r.right,r.bottom);

    TraceTag((tagCRView2, buf));
}
#endif

// -------------------------------------------------------
// CRView
// -------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CRView::CRView
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------------

CRView::CRView()
: _cRef(0),
  _localHiresTimer(NULL),
  _firstRender(true),
  _bRenderLock(false),
  _bPaused(false)
{
    TraceTag((tagCRView2, "CRView(%lx)::CRView", this));

    _localHiresTimer = &CreateHiresTimer();
    
    // This should make us AddRef to 1 since we started at 0
    
    GetCurrentContext().AddView(this);

    Assert(_cRef == 1);
}


//+-------------------------------------------------------------------------
//
//  Method:     CRView::~CRView
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CRView::~CRView()
{
    TraceTag((tagCRView2, "CRView(%lx)::~CRView", this));

    // TODO: We need to clean this up since the view destructor also
    // calls stop but does not setup the state correctly

    // Push ourselves to ensure we can make the correct calls
    ViewPusher vp (this,false) ;
    // Also push the same heap we were created on
    DynamicHeapPusher dhp(GetSystemHeap()) ;
    
    Stop();

    delete _localHiresTimer;
}


// We need to be careful with InterlockedDecrement.  It only returns
// <0, == 0, or >0 not the actually value

// >0 means it has an outstanding reference
// 0 means no outstanding references - remove from global list
// <0 means it needs to be deleted

ULONG
CRView::Release()
{
    LONG l = InterlockedDecrement(&_cRef) ;

    TraceTag((tagCRView2, "CRView(%lx)::Release _cRef=%d, l=%d",
              this, _cRef, l));
    
    // We need to be careful since the removeview should also call
    // release and go in this same code and delete the object before
    // it returns
    
    if (l == 0) {
        GetCurrentContext().RemoveView(this);
    } else if (l < 0) {
        delete this;
    }

    return (l <= 0) ? 0 : (ULONG)l;
}

//+-------------------------------------------------------------------------
//
//  Method:     CRView::Tick
//
//  Synopsis:
//
//--------------------------------------------------------------------------

// SetSimulation time sets the time for subsequent rendering
bool
CRView::Tick(double simTime) 
{
    if (ImportsPending())
        RaiseException_UserError(E_PENDING, IDS_ERR_NOT_READY);

#if 0
#if _DEBUGMEM
    _CrtMemState diff, oldState, newState;
    _CrtMemCheckpoint(&oldState);
#endif
#endif

    // timestamp _currentTime based on our internal hires clock!
    _currentTime = simTime;
    
    if (_firstRender) { // reset the timer if this is the first time
        _localHiresTimer->Reset(); // Zero timer
        _firstRender = false;
    }
    
    if (!IsStarted ())
        RaiseException_UserError(E_FAIL, 0);
    
    bool bNeedRender = Sample(simTime, _bPaused);
    
    // See if we got imports pending during the tick and return
    // the error code
    
    if (ImportsPending()) {
        bNeedRender = false;
        RaiseException_UserError(E_PENDING, IDS_ERR_NOT_READY);
    }
    
    //RenderSound(); // render audio

    ReapElderlyMasterBuffers(); // free old static sound master buffers
    // ReapSoundInstanceResources();

#if 0
#if _DEBUGMEM
    _CrtMemCheckpoint(&newState);
    _CrtMemDifference(&diff, &oldState, &newState);
    _CrtMemDumpStatistics(&diff);
    _CrtMemDumpAllObjectsSince(&oldState);
#endif
#endif

    return bNeedRender;
}

void
CRView::StopModel()
{
    Stop();
    _bPaused = false;
    _pServiceProvider.Release();
}

void
CRView::PauseModel()
{
    if (IsStarted())
    {
        Pause();
        _bPaused = true;
    }
}

void
CRView::ResumeModel()
{
    if (IsStarted())
    {
        Resume();
        _bPaused = false;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CRView::StartModel
//
//  Synopsis:
//
//--------------------------------------------------------------------------

void
CRView::StartModel(Bvr img,
                   Bvr snd,
                   double startTime,
                   DWORD dwFlags,
                   bool & bPending)
{
    TraceTag((tagGCMedia,
              "CRView(%lx)::StartModel(%lx,%lx,%lg)",
              this, img, snd, startTime));

#ifdef _DEBUG
    DumpWindowSize(GetWindow(),"StartModel");
#endif

    if (IsStarted ())
        RaiseException_UserError(E_FAIL, 0);
    
    // Grab the Preferences iface, and propagate the preferences
    // to the view before we start the view going.
    Propagate();
        
    _ticksAtStart = GetPerfTickCount();

#ifndef _NO_CRT
#if PERFORMANCE_REPORTING
    {
        double audioLoadTime = GetTimers().audioLoadTimer.GetTime();
        double geometryLoadTime = GetTimers().geometryLoadTimer.GetTime();
        double imageLoadTime = GetTimers().imageLoadTimer.GetTime();
        double downloadTime = GetTimers().downloadTimer.GetTime();
        double importblockingTime = GetTimers().importblockingTimer.GetTime();
        
        double mediaLoadTime = (audioLoadTime +
                                geometryLoadTime +
                                imageLoadTime +
                                importblockingTime +
                                downloadTime);
      
        PerfPrintLine("CRView::StartModel - Media Load Time: %g s composed of:",
                      mediaLoadTime);

        PerfPrintLine ("\tGeometry:             %g", geometryLoadTime);
        PerfPrintLine ("\tImage:                %g", imageLoadTime);
        PerfPrintLine ("\tSound:                %g", audioLoadTime);
        PerfPrintLine ("\tLoad:                 %g", downloadTime);
        PerfPrintLine ("\tImport Blocking:      %g", importblockingTime);
    }
#endif
#endif

    __try {
        _bPaused = false;
        Start(img, snd, startTime) ;
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        TraceTag((tagError, "CRView::StartModel - exception caught: "));
        TraceTag((tagError, " --> (hr: %x) %ls: ", DAGetLastError(), DAGetLastErrorString()));
        Stop();
        RETHROW;
    }

    // See if imports are pending
    
    bPending = ImportsPending();
}

//+-------------------------------------------------------------------------
//
//  Method:     CRView::SetStatusText
//
//  Synopsis:   Helper to set the status bar text.
//
//--------------------------------------------------------------------------

void
CRView::SetStatusText(char * szStatus)
{
    TraceTag((tagCRView2,
              "CRView(%lx)::SetStatusText(%s)",
              this, szStatus));

    DAComPtr<CRViewSite> s;

    {
        CritSectGrabber csg(_crit);
        s = _pViewSite ;
    }

    if (s) {
        USES_CONVERSION;
        s->SetStatusText(A2W(szStatus));
    }
}

// -------------------------------------------------------
// C Functions
// -------------------------------------------------------

static CritSect *dummyDevCritSect = NULL;

DirectDrawViewport *GetCurrentViewport( bool dontCreateOne )
{
    CRView * v = IntGetCurrentView() ;

    if (v) 
        return v->GetImageDev() ;
    else {

        if( dontCreateOne ) return NULL;
        
        TraceTag((tagImageDeviceInformative,
                  "GetCurrentImageDisplayDevice - no view"));

        // TODO: should check for if there is a context (which happens
        // at init time) and do something, unfortunately
        // GetCurrentContext returns a reference
        {
            CritSectGrabber csg(*dummyDevCritSect);
            if(!g_dummyImageDev) {
                g_dummyImageDev = CreateDummyImageDev();
            }

            return g_dummyImageDev;
        }
    }
}

DirectDrawImageDevice *GetImageRendererFromViewport(DirectDrawViewport *vp)
{
    return vp->GetImageRenderer();
}

MetaSoundDevice * GetCurrentSoundDevice()
{
    CRView * v = IntGetCurrentView() ;

    if (v) 
        return v->GetSoundDev() ;
    else
        return NULL ;
}

DirectSoundDev * GetCurrentDSoundDevice()
{
    MetaSoundDevice *metaDev = GetCurrentSoundDevice();
    if (metaDev)
        return metaDev->dsDevice;
    else
        return NULL;
}

DynamicHeap &GetCurrentSampleHeap()
{ return GetCurrentView().GetSampleHeap() ; }

DynamicHeap &GetViewRBHeap()
{ return GetCurrentView().GetRBHeap() ; }

Time GetLastSampleTime()
{ return GetCurrentView().GetLastSampleTime(); }

HWND GetCurrentSampleWindow()
{ return GetCurrentView().GetWindow () ; }

void ViewEventHappened()
{
    CRViewPtr v = IntGetCurrentView();
    
    if (v)
        v->EventHappened();
}

SoundInstanceList *
ViewGetSoundInstanceList()
{
    return GetCurrentView().GetSoundInstanceList(); 
}

double
ViewGetFramePeriod()
{
    return GetCurrentView().GetFramePeriod();
}

EventQ & GetCurrentEventQ()
{ return GetCurrentView().GetEventQ(); }

PickQ & GetCurrentPickQ()
{ return GetCurrentView().GetPickQ(); }

double ViewGetFrameRate()
{ return GetCurrentView().GetFrameRate(); }

double ViewGetTimeDelta()
{ return GetCurrentView().GetTimeDelta(); }

#if PERFORMANCE_REPORTING
GlobalTimers &
GetCurrentTimers()
{
    CRView * v = IntGetCurrentView() ;

    if (v) 
        return v->GetTimers() ;
    else
        return *globalTimers ;
}
#endif  // PERFORMANCE_REPORTING

// TODO: Making the trigger event happen at the current time would be
// ok for async trigger case, but will cause problem if it's called
// inside a notifier.   In such case, the user really wants it to
// happen at the event time.  Even if we can do so, since trigger
// affects all performances, we need to map that view's event time to
// other views', which would not be possible.  Thus we're doing a hack
// to make the trigger happen slightly before current tick time, so
// that at current frame, it's AFTER the event.   This could break if
// the user is driving tick with very fine intervals.  Probably ok for
// most of the cases though.

static const double EPSILON = 1e-15;

class AppTriggerProc : public ViewIterator {
  public:
    AppTriggerProc(DWORD id, Bvr data) : _id(id), _data(data) {}
    
    virtual void Process(CRView* v) {
        Bvr bvr;
        
        GC_CREATE_BEGIN;                                                        

        bvr = _data ? _data : TrivialBvr();

        // When the entry is clear, is should remove it from the set
        GCAddToRoots(bvr, GetCurrentGCRoots());

        GC_CREATE_END;

        {
            ViewPusher vp (v,true) ;

            
            double time = v->GetCurrentSimulationTime() - EPSILON;

            // We want our current time clamped at something slightly 
            // greater than zero so that events at zero can be considered
            // to have occured already.
            if(time < EPSILON)
                time = EPSILON;            

            v->GetEventQ().Add(
                AXAWindEvent(AXAE_APP_TRIGGER, time, (DWORD_PTR) bvr, 0,
                             0, _id, 0));
        }
    }

  private:
    DWORD _id;
    Bvr _data;
};

void TriggerEvent(DWORD eventId, Bvr data, bool bAllViews)
{
    AppTriggerProc p(eventId, data);

    if (bAllViews)
        GetCurrentContext().IterateViews(p);
    else
        p.Process(&GetCurrentView());
}

void RunViewBvrs(Time startGlobalTime, TimeXform tt)
{
    GetCurrentView().RunBvrs(startGlobalTime, tt);
}

bool ViewLastSampledTime(DWORD& lastSystemTime,
                         DWORD& currentSystemTime,
                         Time & t)
{
    CRView * v = IntGetCurrentView() ;

    if (v)
    {
        lastSystemTime = v->GetLastSystemTime();
        currentSystemTime = v->GetCurrentSystemTime();
        t = v->GetLastSampleTime();
        return true;
    }

    return false;
}

CRView *ViewAddPickEvent()
{
    CRView& view = GetCurrentView();

    view.AddPickEvent();

    return &view;
}

unsigned int
ViewGetSampleID()
{
    CRView& view = GetCurrentView();

    return view.GetSampleID();
}

bool
GetCurrentServiceProvider(IServiceProvider ** sp)
{
    Assert (sp);
    
    CRView * v = IntGetCurrentView() ;

    if (v) {
        {
            CritSectGrabber csg(v->GetCritSect());
            *sp = v->GetServiceProvider();
        }
        
        if (*sp) {
            (*sp)->AddRef();
        }
        return true;
    } else {
        *sp = NULL ;
        return false ;
    }
}

class ImportProc : public ViewIterator {
  public:
    ImportProc(Bvr bvr) : _bvr(bvr) {}
    
    virtual void Process(CRView* v) {
        v->RemoveIncompleteImport(_bvr);
    }

  private:
    Bvr _bvr;
};

void ViewNotifyImportComplete(Bvr bvr, bool bDying)
{
    GetCurrentContext().IterateViews(ImportProc(bvr));
}

#define BOGUS_IMAGEDEV_CLASS "ImageWindowClass"

DirectDrawViewport *
CreateDummyImageDev()
{
    DirectDrawViewport * imageDev;

    WNDCLASS wndclass;
        
    memset(&wndclass, 0, sizeof(WNDCLASS));
    wndclass.style          = 0;
    wndclass.lpfnWndProc    = DefWindowProc;
    wndclass.hInstance      = hInst;
    wndclass.hCursor        = NULL;
    wndclass.hbrBackground  = NULL;
    wndclass.lpszClassName  = BOGUS_IMAGEDEV_CLASS;
        
    RegisterClass(&wndclass) ;
    
    HWND hwnd = ::CreateWindow (BOGUS_IMAGEDEV_CLASS,
                                "",
                                0,0,0,2,2,NULL,NULL,hInst,NULL);

    imageDev = CreateImageDisplayDevice();

    targetPackage_t targetPackage;  // rendering target info
    targetPackage.Reset();
        
    targetPackage.SetHWND(hwnd);

    imageDev->SetTargetPackage( &targetPackage );

    return imageDev;
}

// =========================================
// Initialization
// =========================================

void
InitializeModule_CRView()
{

    dummyDevCritSect = NEW CritSect;

#if PERFORMANCE_REPORTING
    globalTimers = NEW GlobalTimers;
#endif  // PERFORMANCE_REPORTING
}

void
DeinitializeModule_CRView(bool bShutdown)
{
#if 0
    if (g_dummyImageDev) {
        DestroyImageDisplayDevice(g_dummyImageDev);
        g_dummyImageDev = NULL ;
    }
#endif

#if PERFORMANCE_REPORTING
    delete globalTimers;
#endif  // PERFORMANCE_REPORTING

    delete dummyDevCritSect;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\drawctx.cpp ===
#include "headers.h"
#include "drawsurf.h"
#include "privinc/stlsubst.h"

DrawingContext::DrawingContext(IDAStatics *st,
                               CDADrawingSurface *ds,
                               DrawingContext *dc) :
    _st(st),
    _ds(ds)
{
    if (dc == NULL) {
        Reset();
    } else {
        // copy all attrs.
        _xf         = dc->_xf;
        _matte      = dc->_matte;
        _op         = dc->_op;
        _ls         = dc->_ls;
        _bs         = dc->_bs;
        _savedLs    = dc->_savedLs;
        _savedBs    = dc->_savedBs;
        _fs         = dc->_fs;
        _cropMin    = dc->_cropMin;
        _cropMax    = dc->_cropMax;
        _fillTex    = dc->_fillTex;
        _fillGrad   = dc->_fillGrad;
        _fore       = dc->_fore;
        _back       = dc->_back;
        _start      = dc->_start;
        _back       = dc->_back;
        _start      = dc->_start;
        _finish     = dc->_finish;
        _power      = dc->_power;

        _fillType   = dc->_fillType;
        _hatchFillOff = dc->_hatchFillOff;
        _mouseEvents= dc->_mouseEvents;
        _scaleX     = dc->_scaleX;
        _scaleY     = dc->_scaleY;
        _extentChgd = dc->_extentChgd;
        _opChgd     = dc->_opChgd;
        _xfChgd     = dc->_xfChgd;
        _cropChgd   = dc->_cropChgd;
        _clipChgd   = dc->_clipChgd;
    }

    Assert(_imgVec.empty());
}

DrawingContext::~DrawingContext() {
    CleanUpImgVec();
}

void DrawingContext::CleanUpImgVec() {
    vector<IDAImage *>::iterator begin = _imgVec.begin();
    vector<IDAImage *>::iterator end = _imgVec.end();

    vector<IDAImage *>::iterator i;
    for (i = begin; i < end; i++) {
        (*i)->Release();
    }
    _imgVec.clear();
}


HRESULT DrawingContext::Reset() {

    _opChgd = false;
    _xfChgd = false;
    _cropChgd = false;
    _clipChgd = false;
    _extentChgd = false;
    _scaleX = true;
    _scaleY = true;
    _hatchFillOff = false;
    _fillType = fill_solid;

    _ls.Release();
    _bs.Release();
    _savedLs.Release();
    _savedBs.Release();
    _fs.Release();
    _xf.Release();
    _fore.Release();
    _back.Release();
    _power.Release();
    _fillTex.Release();
    _fillGrad.Release();

    RETURN_IF_ERROR(_st->get_White(&_fore))
    RETURN_IF_ERROR(_st->get_White(&_back))
    RETURN_IF_ERROR(_st->DANumber(1, &_power))
    RETURN_IF_ERROR(_st->get_DefaultLineStyle(&_ls))
    RETURN_IF_ERROR(_st->get_DefaultFont(&_fs))
    RETURN_IF_ERROR(_st->get_EmptyImage(&_fillTex))
    RETURN_IF_ERROR(_st->get_EmptyImage(&_fillGrad))

    _bs = _ls;
    return _st->get_IdentityTransform2(&_xf);
}

HRESULT DrawingContext::Overlay(IDAImage *img) {

    img->AddRef();
    VECTOR_PUSH_BACK_PTR(_imgVec, img);
    img->AddRef();
    VECTOR_PUSH_BACK_PTR(_ds->_imgVec, img);

    return S_OK;
}

HRESULT DrawingContext::Draw(IDAPath2 *pth, VARIANT_BOOL bFill) {   
    // we must switch to meter mode for the calculations to be valid.
    VARIANT_BOOL pixelMode;
    _st->get_PixelConstructionMode(&pixelMode);
    _st->put_PixelConstructionMode(VARIANT_FALSE);

    // Auto-resetter of pixel mode.
    class PixelModeGrabber {
    public:
        PixelModeGrabber(IDAStatics *st, VARIANT_BOOL mode) : _mode(mode), _st(st) {}
        ~PixelModeGrabber() {
            _st->put_PixelConstructionMode(_mode);
        }

    protected:
        IDAStatics *_st;
        VARIANT_BOOL _mode;
    };

    PixelModeGrabber myGrabber(_st, pixelMode);

    CComPtr<IDAImage> img;

    if (bFill) {
        CComPtr<IDAImage> interiorImg;
        CComPtr<IDAImage> edgeImg;
        CComPtr<IDAImage> fillImg;
        CComPtr<IDAImage> foreFillImg;
        CComPtr<IDAImage> backFillImg;
        CComPtr<IDAMatte> matte;
            
        // Now construct the inner fill image for the path        
        if(_fillType == fill_solid) {    
            RETURN_IF_ERROR(_st->SolidColorImage(_fore, &fillImg)) 
        }
        else if(_fillType == fill_detectableEmpty) {
            RETURN_IF_ERROR(_st->get_DetectableEmptyImage(&fillImg))
        }
        else if((_fillType >= fill_hatchHorizontal) && (_fillType <= fill_hatchDiagonalCross)) 
        {
            // Define a standard hatch size for the drawing surface
            // since the SG control has a fixed hatch size.  
            // This value is chosen to attempt to match it.
            CComPtr<IDANumber> hatchSize;
            RETURN_IF_ERROR(_st->DANumber(.003, &hatchSize))            

            // Fill the foreground image with the appropriate pattern
            if(_fillType == fill_hatchHorizontal) {
                RETURN_IF_ERROR(_st->HatchHorizontalAnim(_fore, hatchSize, &foreFillImg))
            }
            else if(_fillType == fill_hatchVertical) {
                RETURN_IF_ERROR(_st->HatchVerticalAnim(_fore, hatchSize, &foreFillImg))
            }
            else if(_fillType == fill_hatchForwardDiagonal) {
                RETURN_IF_ERROR(_st->HatchForwardDiagonalAnim(_fore, hatchSize, &foreFillImg))
            }
            else if(_fillType == fill_hatchBackwardDiagonal) {
                RETURN_IF_ERROR(_st->HatchBackwardDiagonalAnim(_fore, hatchSize, &foreFillImg))
            }
            else if(_fillType == fill_hatchCross) {
                RETURN_IF_ERROR(_st->HatchCrossAnim(_fore, hatchSize, &foreFillImg))
            }
            else if(_fillType == fill_hatchDiagonalCross) {
                RETURN_IF_ERROR(_st->HatchDiagonalCrossAnim(_fore, hatchSize, &foreFillImg))
            }

            // If the hatch background fill is on, overlay a solid color
            if(!_hatchFillOff) {
                RETURN_IF_ERROR(_st->SolidColorImage(_back, &backFillImg))
                RETURN_IF_ERROR(_st->Overlay(foreFillImg,backFillImg, &fillImg))
            }
            else {
                fillImg = foreFillImg;
             }

        }
        else if((_fillType >= fill_horizontalGradient) && (_fillType <= fill_image))
        {
            // The gradient and image fills abide by scaling parameters and hence are grouped
            // together. Fore control compatibility, the vertical and horizontal gradients
            // are the two cases that do not respond to rotation within the start and stop value.

            IDAImage*               tempImg;
            CComPtr<IDAImage>       solidImg;
            CComPtr<IDATransform2>  xf;
            CComPtr<IDABbox2>       bb;
            CComPtr<IDAPoint2>      max,min;
            CComPtr<IDANumber>      xScale,yScale,
                                    pathMinX, pathMinY,
                                    maxx,maxy,minx,miny, 
                                    pathWidth,pathHeight, 
                                    solidMinX, solidMinY,
                                    solidMaxX, solidMaxY,
                                    pathSnapX, pathSnapY,
                                    newGradMinX, newGradMinY, 
                                    newGradMaxX, newGradMaxY,
                                    gradientWidth, gradientHeight,
                                    gradTranslateX, gradTranslateY,
                                    newGradientWidth, newGradientHeight;
            CComPtr<IDAColor>       _newForeVal, _newBackVal;           
            CComPtr<IDABoolean>     yOrientation, xOrientation;

            // If the user specified extents, grab the specified Start and Finish 
            // points and dimensions 
            CComPtr<IDANumber> xStart, yStart, xFinish, yFinish,  newStartVal, newFinishVal,
                               extentWidth, extentHeight, extentDiagonal;                
            if(_extentChgd) {
                RETURN_IF_ERROR(_start->get_X(&xStart))
                RETURN_IF_ERROR(_start->get_Y(&yStart))
                RETURN_IF_ERROR(_finish->get_X(&xFinish))
                RETURN_IF_ERROR(_finish->get_Y(&yFinish))
                RETURN_IF_ERROR(_st->Sub(xFinish, xStart, &extentWidth))
                RETURN_IF_ERROR(_st->Sub(yFinish, yStart, &extentHeight))                
                RETURN_IF_ERROR(_st->DistancePoint2(_start, _finish, &extentDiagonal))
            }
            
            // It is important for us to include the orientation of the intended
            // gradient so the gradient start and stop position can be reversed 
            // and it will have the desired effect. We can get this real easily
            // by swapping the _fore and _back for the gradient types
            // that need it (rather than using complex transformation logic)
            if(_extentChgd && (_fillType == fill_horizontalGradient) ) 
            {
                RETURN_IF_ERROR(_st->LT(xStart, xFinish, &xOrientation))

                RETURN_IF_ERROR(_st->Cond(xOrientation, 
                                          (IDABehavior*)  _fore, 
                                          (IDABehavior*)  _back,
                                          (IDABehavior**) &_newForeVal))

                RETURN_IF_ERROR(_st->Cond(xOrientation, 
                                          (IDABehavior*)  _back, 
                                          (IDABehavior*)  _fore,
                                          (IDABehavior**) &_newBackVal))              

                                RETURN_IF_ERROR(_st->Cond(xOrientation, 
                                          (IDABehavior*)  xStart, 
                                          (IDABehavior*)  xFinish,
                                          (IDABehavior**) &newStartVal))

                                RETURN_IF_ERROR(_st->Cond(xOrientation, 
                                          (IDABehavior*)  xFinish, 
                                          (IDABehavior*)  xStart,
                                          (IDABehavior**) &newFinishVal))

                                xStart.Release();
                                xFinish.Release();
                                xStart = newStartVal;
                                xFinish = newFinishVal;

            } 
            else if(_extentChgd && (_fillType == fill_verticalGradient))
            {
                RETURN_IF_ERROR(_st->GT(yStart, yFinish, &yOrientation))

                RETURN_IF_ERROR(_st->Cond(yOrientation, 
                                          (IDABehavior*)  _fore, 
                                          (IDABehavior*)  _back,
                                          (IDABehavior**) &_newForeVal))

                RETURN_IF_ERROR(_st->Cond(yOrientation, 
                                          (IDABehavior*)  _back, 
                                          (IDABehavior*)  _fore,
                                          (IDABehavior**) &_newBackVal))

                                RETURN_IF_ERROR(_st->Cond(yOrientation, 
                                          (IDABehavior*)  yStart, 
                                          (IDABehavior*)  yFinish,
                                          (IDABehavior**) &newStartVal))

                                RETURN_IF_ERROR(_st->Cond(yOrientation, 
                                          (IDABehavior*)  yFinish, 
                                          (IDABehavior*)  yStart,
                                          (IDABehavior**) &newFinishVal))
                                yStart.Release();
                                yFinish.Release();
                                yStart = newStartVal;
                                yFinish = newFinishVal;                                  
                
            }
            else {
                _newForeVal = _fore;
                _newBackVal = _back;
            }                


            // Create the gradient image based on the gradient fillType:
            CComPtr<IDAImage> gradientImg;            
            if(_fillType == fill_horizontalGradient) {
                RETURN_IF_ERROR(_st->GradientHorizontalAnim(_fore, _back, _power, &gradientImg))
            }
            else if(_fillType == fill_verticalGradient) {                                   
                RETURN_IF_ERROR(_st->GradientHorizontalAnim(_fore, _back, _power, &tempImg))
                RETURN_IF_ERROR(_st->Rotate2(pi/2,&xf))
                RETURN_IF_ERROR(tempImg->Transform(xf, &gradientImg))
                tempImg->Release();
                xf.Release();                
            }
            else if(_fillType == fill_radialGradient) {
                CComPtr<IDANumber> sides;
                RETURN_IF_ERROR(_st->DANumber(40,&sides))                
                RETURN_IF_ERROR(_st->RadialGradientRegularPolyAnim( _fore, _back, 
                                                                    sides, _power, &gradientImg))
            }
            else if(_fillType == fill_lineGradient) {
                RETURN_IF_ERROR(_st->GradientHorizontalAnim(_fore, _back,
                                                            _power, &gradientImg))
            }
            else if(_fillType == fill_rectGradient) {    
                RETURN_IF_ERROR(_st->RadialGradientSquareAnim(_fore, _back,
                                                              _power, &gradientImg))
            }
            else if(_fillType == fill_shapeGradient) {
                gradientImg = _fillGrad;
            }
            else if(_fillType == fill_image) {    
                gradientImg = _fillTex;
            }                     
                                           
            // Now calculate the bounding box of the fill gradient and store 
            // it in gradientWidth and gradientHeight:
            RETURN_IF_ERROR(gradientImg->get_BoundingBox(&bb)) 
            RETURN_IF_ERROR(bb->get_Max(&max))
            RETURN_IF_ERROR(bb->get_Min(&min))
            RETURN_IF_ERROR(max->get_X(&maxx))
            RETURN_IF_ERROR(min->get_X(&minx))
            RETURN_IF_ERROR(max->get_Y(&maxy))
            RETURN_IF_ERROR(min->get_Y(&miny))
            RETURN_IF_ERROR(_st->Sub(maxx,minx, &gradientWidth))
            RETURN_IF_ERROR(_st->Sub(maxy,miny, &gradientHeight))  

            // Stash away max and min Y bounds for later
            solidMinX = minx;         
            solidMinY = miny;
            solidMaxX = maxx;
            solidMaxY = maxy;                        

            // Cleanup variables for reuse -- Release() sets pointer to NULL.
            bb.Release();   max.Release();  min.Release(); 
            maxx.Release(); maxy.Release(); minx.Release(); miny.Release();

            // Calculate the Path bounding box and store it in pathWidth, pathHeight                       
            // Note that the correct bounding box here is the drawn path's bounding box
            CComPtr<IDABbox2> bbBackup, bbTight;
            CComPtr<IDABoolean> nullBbox;
            CComPtr<IDABehavior> tempBB;
            RETURN_IF_ERROR(pth->Draw(_bs, &tempImg))
            RETURN_IF_ERROR(tempImg->get_BoundingBox(&bbTight))
            RETURN_IF_ERROR(bbTight->get_Max(&max))
            RETURN_IF_ERROR(bbTight->get_Min(&min))
            RETURN_IF_ERROR(max->get_X(&maxx))
            RETURN_IF_ERROR(min->get_X(&minx))
            RETURN_IF_ERROR(max->get_Y(&maxy))
            RETURN_IF_ERROR(min->get_Y(&miny))
            RETURN_IF_ERROR(_st->GT(minx, maxx, &nullBbox))
            RETURN_IF_ERROR(pth->BoundingBox(_bs, &bbBackup))
            RETURN_IF_ERROR(_st->Cond(nullBbox, bbBackup, bbTight, &tempBB))
            RETURN_IF_ERROR(tempBB->QueryInterface(IID_IDABbox2, 
                                                                                            (void**)&bb))
            max.Release(); min.Release(); 
            maxx.Release(); minx.Release(); maxy.Release(); miny.Release();
            RETURN_IF_ERROR(bb->get_Max(&max))
            RETURN_IF_ERROR(bb->get_Min(&min))
            RETURN_IF_ERROR(max->get_X(&maxx))
            RETURN_IF_ERROR(min->get_X(&minx))
            RETURN_IF_ERROR(max->get_Y(&maxy))
            RETURN_IF_ERROR(min->get_Y(&miny))
            RETURN_IF_ERROR(_st->Sub(maxx,minx, &pathWidth))
            RETURN_IF_ERROR(_st->Sub(maxy,miny, &pathHeight))            

            // Stash path min points for later
            pathMinX = minx;
            pathMinY = miny;
            tempImg->Release();

            // Cleanup for reuse -- Release() sets pointer to NULL
            bb.Release();   max.Release();  min.Release(); 
            maxx.Release(); maxy.Release(); minx.Release(); miny.Release();


            // If the user has set the gradient extents, set the scaling factors 
            // based on the type of gradient and the Start and Finish measurements.
            if(_extentChgd) {
                if(_fillType == fill_lineGradient) {
                    // Scale the X component of gradient to the extentDiagonal and
                    // Keep the Y component at its current size (1 meter)
                    newGradientWidth = extentDiagonal;                    
                    newGradientHeight = gradientHeight;
                }
                else if(_fillType == fill_verticalGradient) {
                    // Scale the X component of gradient to the path width and 
                    // Scale the Y component to extentHeight
                    newGradientWidth = pathWidth;
                    newGradientHeight = extentHeight;
                }
                else if(_fillType == fill_horizontalGradient) {
                    // Scale the Y component of gradient to the path height and 
                    // Scale the X component to extentWidth 
                    newGradientWidth = extentWidth;
                    newGradientHeight = pathHeight;
                }
                else {
                    // For radial gradients, the distance between points is a radius 
                    // and the image should be scaled by two times the diagonal in
                    // both the X and Y direction.
                    CComPtr<IDANumber> two;
                    RETURN_IF_ERROR(_st->DANumber(2, &two))
                    RETURN_IF_ERROR(_st->Mul(extentDiagonal, two, &newGradientWidth))
                    newGradientHeight = newGradientWidth;
                }
            }

            // Scale the gradient image to the user indicated dimensions.
            if(_scaleX || _scaleY || _extentChgd) {                
                if(_extentChgd)
                   RETURN_IF_ERROR(_st->Div(newGradientWidth,gradientWidth, &xScale))
                else if(_scaleX)                   
                   RETURN_IF_ERROR(_st->Div(pathWidth,gradientWidth, &xScale))
                else
                   RETURN_IF_ERROR(_st->DANumber(1, &xScale))

                if(_extentChgd)
                   RETURN_IF_ERROR(_st->Div(newGradientHeight,gradientHeight, &yScale))
                else if(_scaleY)
                   RETURN_IF_ERROR(_st->Div(pathHeight,gradientHeight, &yScale))
                else
                   RETURN_IF_ERROR(_st->DANumber(1, &yScale))

                RETURN_IF_ERROR(_st->Scale2Anim(xScale, yScale, &xf))
                RETURN_IF_ERROR(gradientImg->Transform(xf, &tempImg))
                gradientImg.p->Release();   
                gradientImg.p = tempImg;               
                xf.Release();
            }      
            
            // Get the new bounds of the gradient image (post scaling) and the 
            // translation vector for moving the image to the path minX and minY
            RETURN_IF_ERROR(gradientImg->get_BoundingBox(&bb))            
            RETURN_IF_ERROR(bb->get_Min(&min))
            RETURN_IF_ERROR(bb->get_Max(&max))
            RETURN_IF_ERROR(min->get_X(&newGradMinX))
            RETURN_IF_ERROR(min->get_Y(&newGradMinY))
            RETURN_IF_ERROR(max->get_X(&newGradMaxX))
            RETURN_IF_ERROR(max->get_Y(&newGradMaxY))
            RETURN_IF_ERROR(_st->Sub(pathMinX, newGradMinX, &pathSnapX))
            RETURN_IF_ERROR(_st->Sub(pathMinY, newGradMinY, &pathSnapY))

            // Cleanup for reuse -- Release() sets pointer to NULL
            bb.Release();   max.Release();  min.Release(); 

            // Here are the final gradient extent specific additions to the image
            if(_extentChgd) {

                // For line gradient types, we must overlay the gradient with the cropped
                // solid image from the foreground. It must be positioned to the left of 
                // the gradient for line and horizontal gradients, and over the gradient 
                // for vertical gradients.               
                if((_fillType == fill_lineGradient)       ||
                   (_fillType == fill_horizontalGradient) ||
                   (_fillType == fill_verticalGradient))
                {                
                    CComPtr<IDAImage> scaledSolidImg, croppedSolidImg;
                    CComPtr<IDANumber> zero, one, negOne, scaleFac;                                                   
                    CComPtr<IDAPoint2> solidMin, solidMax;
                    RETURN_IF_ERROR(_st->DANumber(0, &zero))
                    // BUG: A meter doesn't seem to be meter here. I was creating
                    // a solid that is cropped to 2 meters on a side yet it fits
                    // neatly on the screen without being scaled. The scale by ten 
                    // is a fudge factor to get the desired effect.
                    RETURN_IF_ERROR(_st->DANumber(10, &scaleFac))
                    RETURN_IF_ERROR(_st->DANumber(1, &one))
                    RETURN_IF_ERROR(_st->DANumber(-1, &negOne))
                    RETURN_IF_ERROR(_st->SolidColorImage(_newForeVal, &solidImg))
                    
                    if(_fillType == fill_verticalGradient) {
                        // For vertical gradients, the solid must be cropped at the
                        // bottom at newGradMaxY - solidMinY.
                        RETURN_IF_ERROR(_st->Point2Anim(one,one, &solidMax))
                        RETURN_IF_ERROR(_st->Point2Anim(negOne, zero, &solidMin))
                        RETURN_IF_ERROR(_st->Scale2UniformAnim(scaleFac, &xf))
                    }
                    else {
                        // For horizontal gradients, the solid must be cropped at
                        // the left by newGradMinX - solidMaxX.               
                        RETURN_IF_ERROR(_st->Point2Anim(negOne, negOne, &solidMin))
                        RETURN_IF_ERROR(_st->Point2Anim(zero, one, &solidMax))                                                           
                        RETURN_IF_ERROR(_st->Scale2UniformAnim(scaleFac, &xf))
                    }
                    RETURN_IF_ERROR(solidImg->Crop(solidMin, solidMax, &croppedSolidImg))                    
                    RETURN_IF_ERROR(croppedSolidImg->Transform(xf, &scaledSolidImg))                                                                               
                    RETURN_IF_ERROR(_st->Overlay(gradientImg, scaledSolidImg, &tempImg))                                                  
                    gradientImg.p->Release();
                    gradientImg.p = tempImg;                                        
                    xf.Release();
                }

                // Fold in the rotation component of the extent settings. Note: the rotation
                // does not affect vertical, horizontal, and radial fill styles.               
                if((_fillType != fill_horizontalGradient) &&
                   (_fillType != fill_verticalGradient) &&
                   (_fillType != fill_radialGradient)) 
                {                                                                                     
                    // Rotate to angle atan2(f.y - s.y, f.x - s.x)))                   
                    CComPtr<IDANumber> deltaX, deltaY, delta, angle;                                        
                    RETURN_IF_ERROR(_st->Sub(yFinish, yStart, &deltaY))
                    RETURN_IF_ERROR(_st->Sub(xFinish, xStart, &deltaX))
                    RETURN_IF_ERROR(_st->Atan2(deltaY, deltaX, &angle))                                                    
                    RETURN_IF_ERROR(_st->Rotate2Anim(angle, &xf))
                    RETURN_IF_ERROR(gradientImg->Transform(xf, &tempImg))
                    gradientImg.p->Release();
                    gradientImg.p = tempImg;
                    xf.Release();                                                                                
                }           

                // Finally, complete translation component for the gradient types that
                // support translation and the dimensions that are affected by it.
                if(_fillType == fill_lineGradient) {
                    // For line gradients, the image must be translated
                    // by (xStart - gradMinX, yStart - (gradMaxY + gradMinY)/2).                   
                    CComPtr<IDANumber> tempSum, midY, two;
                    RETURN_IF_ERROR(_st->DANumber(2, &two))
                    RETURN_IF_ERROR(_st->Sub(xStart, newGradMinX, &gradTranslateX))
                    RETURN_IF_ERROR(_st->Add(newGradMaxY, newGradMinY, &tempSum))
                    RETURN_IF_ERROR(_st->Div(tempSum, two, &midY))
                    RETURN_IF_ERROR(_st->Sub(yStart, midY, &gradTranslateY))                  
                }
                else if(_fillType == fill_verticalGradient) {
                    // Ignore the X value in the translation
                    gradTranslateX = pathSnapX;
                    RETURN_IF_ERROR(_st->Sub(yStart, newGradMaxY, &gradTranslateY))
                }
                else if(_fillType == fill_horizontalGradient) {
                    // Ignore the Y value in the translation
                    gradTranslateY = pathSnapY;  
                    RETURN_IF_ERROR(_st->Sub(xStart, newGradMinX, &gradTranslateX))                   
                }
                else {
                    // Translate to startX and startY
                    gradTranslateX = xStart;
                    gradTranslateY = yStart;
                }
                RETURN_IF_ERROR(_st->Translate2Anim(gradTranslateX, gradTranslateY, &xf))
                RETURN_IF_ERROR(gradientImg->Transform(xf, &tempImg))
                gradientImg.p->Release();
                gradientImg.p = tempImg;
            }
            else if((_fillType == fill_image) && (!_scaleX) && (!_scaleY));
                                // This is a fixed image, do nothing            
                        else {
                RETURN_IF_ERROR(_st->Translate2Anim(pathSnapX, pathSnapY, &xf))
                RETURN_IF_ERROR(gradientImg->Transform(xf, &tempImg))      
                gradientImg.p->Release();
                gradientImg.p = tempImg;
            }

            // To simulate a gradient of infinite extent, the backFill color is
            // used to create a solidColorImage and overlaid with the ForeFillImg.
            // This doesn't apply to image fills.
            if(_fillType != fill_image) {
               solidImg.Release();
               RETURN_IF_ERROR(_st->SolidColorImage(_newBackVal, &solidImg))
               RETURN_IF_ERROR(_st->Overlay(gradientImg,solidImg, &fillImg))
            }
            else            
               fillImg = gradientImg;          
        }
        else if(_fillType == fill_texture) {
            RETURN_IF_ERROR(_fillTex->Tile(&fillImg))
        }
        else
            RETURN_IF_ERROR(_st->get_EmptyImage(&fillImg))
       
        RETURN_IF_ERROR(pth->Fill(_bs, fillImg, &img))

    } else {
        RETURN_IF_ERROR(pth->Draw(_ls, &img))
    }

    //
    //  NOTE:  The following code is optimized for CComPtr to avoid unnecessary
    //         addref/release calls.  Since we know that img.p is always valid, we
    //         simply release the reference and reassign it to the new image.
    //
    if (_xfChgd) {
        IDAImage *imgTemp;
        RETURN_IF_ERROR(img->Transform(_xf, &imgTemp))
        img.p->Release();
        img.p = imgTemp;
    }

    if (_opChgd) {
        IDAImage *imgTemp;
        RETURN_IF_ERROR(img->OpacityAnim(_op, &imgTemp))
        img.p->Release();
        img.p = imgTemp;
    }

    if (_cropChgd) {
        IDAImage *imgTemp;
        RETURN_IF_ERROR(img->Crop(_cropMin, _cropMax, &imgTemp))
        img.p->Release();
        img.p = imgTemp;
    }

    if (_clipChgd) {
        IDAImage *imgTemp;
        RETURN_IF_ERROR(img->Clip(_matte, &imgTemp))
        img.p->Release();
        img.p = imgTemp;
    }   

    return Overlay(img);
}

HRESULT DrawingContext::Transform(IDATransform2 *xf) {

    _xfChgd = true;
    IDATransform2 *temp;
    HRESULT hr = _st->Compose2(_xf, xf, &temp);
    if (_xf.p) _xf.p->Release();
    _xf.p = temp;
    return hr;
}

void DrawingContext::SetOpacity(IDANumber *op) {

    _opChgd = true;
    _op = op;
}

void DrawingContext::SetClip(IDAMatte *matte) {

    _clipChgd = true;
    _matte = matte;
}

void DrawingContext::SetCrop(IDAPoint2 *min, IDAPoint2 *max) {

    _cropChgd = true;
    _cropMin = min;
    _cropMax = max;
}

HRESULT DrawingContext::TextPoint(BSTR str, IDAPoint2 *pt)
{
    // we must switch to meter mode for the calculations to be valid.
    VARIANT_BOOL pixelMode;
    _st->get_PixelConstructionMode(&pixelMode);
    _st->put_PixelConstructionMode(VARIANT_FALSE);

    // Auto-resetter of pixel mode.
    class PixelModeGrabber {
    public:
        PixelModeGrabber(IDAStatics *st, VARIANT_BOOL mode) : _mode(mode), _st(st) {}
        ~PixelModeGrabber() {
            _st->put_PixelConstructionMode(_mode);
        }

    protected:
        IDAStatics *_st;
        VARIANT_BOOL _mode;
    };

    PixelModeGrabber myGrabber(_st, pixelMode);

    CComPtr<IDAPath2> pthTemp, pth;
    RETURN_IF_ERROR(_st->StringPath(str, _fs, &pthTemp))

    CComPtr<IDABbox2> bbox;
    RETURN_IF_ERROR(pthTemp->BoundingBox(_bs, &bbox))

    // The passed in x, y is the lower left corner of the text.
    // We'll move it from (-box.min.x, -box.min.y) to (x, y)
    CComPtr<IDATransform2> xf;
    CComPtr<IDAPoint2> min;
    CComPtr<IDAVector2> xlate;
    CComPtr<IDAPoint2> newmin;
    CComPtr<IDANumber> xmin;
    CComPtr<IDANumber> ymin;

    RETURN_IF_ERROR(bbox->get_Min(&min))
    RETURN_IF_ERROR(min->get_X(&xmin))
    RETURN_IF_ERROR(_st->DANumber(0.0, &ymin))
    RETURN_IF_ERROR(_st->Point2Anim(xmin, ymin, &newmin))
    RETURN_IF_ERROR(_st->SubPoint2(pt, newmin, &xlate))
    RETURN_IF_ERROR(_st->Translate2Vector(xlate, &xf))
    RETURN_IF_ERROR(pthTemp->Transform(xf, &pth))

    return Draw(pth, true);
}



HRESULT DrawingContext::SetGradientShape(VARIANT pts) {
    CComPtr<IDAImage> gradient;
    RETURN_IF_ERROR(_st->RadialGradientPolygonAnim(_fore, _back, pts, _power, &gradient))
    _fillGrad = gradient;
    return S_OK;
}

void DrawingContext::SetGradientExtent(IDAPoint2 *start, IDAPoint2 *finish){
    _extentChgd = true;
    _start = start;
    _finish = finish;
}

HRESULT DrawingContext::LineDashStyle(DA_DASH_STYLE id)
{
    // If we're setting to the emtpy dash style, save the current line style
    // into _savedLs before overiding the current line style to empty.
    // If _savedLs is NULL when we enter this routine, it means that the last
    // LineDashStyle call didn't set it to empty style.  Otherwise, the last
    // call sets it to empty style.

    CComPtr<IDALineStyle> newLs;

    if (id == DAEmpty) {
        if (_savedLs != NULL) {
            // the last LineDashStyle also sets the dash style to empty.
            return S_OK;
        }

        RETURN_IF_ERROR(_st->get_EmptyLineStyle(&newLs))
        _savedLs = _ls;

    } else {

        CComPtr<IDADashStyle> dash;  
        CComPtr<IDALineStyle> oldLs;

        // Use the default dash style - solid, if invalid index.
        if (id == DADash) {
            RETURN_IF_ERROR(_st->get_DashStyleDashed(&dash))
        } else {
            RETURN_IF_ERROR(_st->get_DashStyleSolid(&dash))
        }

        if (_savedLs == NULL)
            oldLs = _ls;
        else
            oldLs = _savedLs;

        RETURN_IF_ERROR(oldLs->Dash(dash, &newLs))
        _savedLs.Release();
    }

    _ls = newLs;
    return S_OK;
}

HRESULT DrawingContext::BorderDashStyle(DA_DASH_STYLE id)
{
    // If we're setting to the emtpy dash style, save the current border style
    // into _savedBs before overiding the current line style to empty.
    // If _savedBs is NULL when we enter this routine, it means that the last
    // BorderDashStyle call didn't set it to empty style.  Otherwise, the last
    // call sets it to empty style.

    CComPtr<IDALineStyle> oldBs, newBs;

    if (id == DAEmpty) {
        if (_savedBs != NULL) {
            // the last LineDashStyle also sets the dash style to empty.
            return S_OK;
        }

        RETURN_IF_ERROR(_st->get_EmptyLineStyle(&newBs))
        _savedBs = _bs;

    } else {

        CComPtr<IDADashStyle> dash;
        // Use the default dash style - solid, if invalid index.
        if (id == DADash) {
            RETURN_IF_ERROR(_st->get_DashStyleDashed(&dash))
        } else {
            RETURN_IF_ERROR(_st->get_DashStyleSolid(&dash))
        }

        if (_savedBs == NULL)
            oldBs = _bs;
        else
            oldBs = _savedBs;

        RETURN_IF_ERROR(oldBs->Dash(dash, &newBs))
        _savedBs = NULL;
    }

    _bs = newBs;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\engine.h ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    IDAEngine interface implementation

Revision:

--*/

#ifndef _ENGINE_H_
#define _ENGINE_H_

class IImportSite;

typedef CComClassFactory CDXMClassFactory ;

#define LIBID "DirectAnimation"

#endif  // _ENGINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\eventq.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

*******************************************************************************/


#ifndef _AXAEVENTQ_H
#define _AXAEVENTQ_H

class EventQ
{
  public:
    EventQ () ;
    ~EventQ () ;

    void Add (AXAWindEvent & evt) ;
    void Prune (Time curTime) ;

    AXAWindEvent * OccurredAfter(Time when,
                                 AXAEventId id,
                                 DWORD data,
                                 BOOL bState,
                                 BYTE modReq,
                                 BYTE modOpt) ;
    
    BOOL GetState(Time when,
                  AXAEventId id,
                  DWORD data,
                  BYTE mod) ;

    void GetMousePos(Time when, DWORD & x, DWORD & y) ;

    void MouseLeave(Time when);
    bool IsMouseInWindow(Time when);

    void Reset () ;

    // This is cleared when the event queue is cleared
    void SizeChanged(BOOL b) { _resized = b ; }
    BOOL IsResized() { return _resized ; }
  protected:
    list < DWORD > _keysDown;
    list < BYTE > _buttonsDown;
    DWORD _mousex;
    DWORD _mousey;
    list< AXAWindEvent > _msgq ;

    BOOL  _resized;

    bool  _mouseLeft;
    Time  _mouseLeftTime;

    // Needs to be callable from constructor
    void ClearStates () ;
} ;

#endif /* _AXAEVENTQ_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\events.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of views.

*******************************************************************************/


#include "headers.h"
#include "cview.h"
#include "axadefs.h"

DeclareTag(tagCViewEvent, "CView", "CView IDAViewEvent methods");

//+-------------------------------------------------------------------------
//
//  Method:     CView::OnMouseMove
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::OnMouseMove(double when, 
                   long x, long y,
                   BYTE modifiers)
{
    TraceTag((tagCViewEvent,
              "CView(%lx)::OnMouseMove(%lg, %ld, %ld, %hd)",
              this, when, x, y, modifiers));

    
    if (CROnMouseMove(_view, when, x, y, modifiers))
    {
        Fire_OnMouseMove(when, x, y, modifiers);
        return S_OK;
    }
    else
    {
        return Error();
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::OnMouseLeave
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::OnMouseLeave(double when)
{
    TraceTag((tagCViewEvent,
              "CView(%lx)::OnMouseLeave(%lg, %ld)",
              this, when));

    
    if (CROnMouseLeave(_view, when))
        return S_OK;
    else
        return Error();
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::OnMouseButton
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::OnMouseButton(double when, 
                     long x, long y,
                     BYTE button,
                     VARIANT_BOOL bPressed,
                     BYTE modifiers)
{
    TraceTag((tagCViewEvent,
              "CView(%lx)::OnMouseButton(%lg, %ld, %ld, %hd, %s, %hd)",
              this, when, x, y,
              button, (bPressed?"Down":"Up"),
              modifiers));

    if (CROnMouseButton(_view,
                        when,
                        x, y, button,
                        bPressed?true:false,
                        modifiers))
    {
        Fire_OnMouseButton(when, x, y, button, bPressed, modifiers);
        return S_OK;
    }
    else
    {
        return Error();
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::OnKey
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::OnKey(double when, 
             long key,
             VARIANT_BOOL bPressed,
             BYTE modifiers)

{
    TraceTag((tagCViewEvent,
              "CView(%lx)::OnKey(%lg, %lx, %s, %hd)",
              this, when, key,
              (bPressed?"Down":"Up"), modifiers));

    if (CROnKey(_view,
                when,
                key,
                bPressed?true:false,
                modifiers))
    {
        Fire_OnKey(when, key, bPressed, modifiers);
        return S_OK;
    }
    else
    {
        return Error();
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CView::OnFocus
//
//  Synopsis:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CView::OnFocus(VARIANT_BOOL bHasFocus)
{
    TraceTag((tagCViewEvent, "CView(%lx)::OnFocus(%s)",
              this,
              (bHasFocus?"TRUE":"FALSE")));
    
    if (CROnFocus(_view, bHasFocus?true:false))
    {
        Fire_OnFocus(bHasFocus);
        return S_OK;
    }
    else
    {
        return Error();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\impgeom.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

   This module implements all functionality associated w/
   importing image media.

*******************************************************************************/

#include "headers.h"
#include "import.h"
#include "include/appelles/axaprims.h"
#include "include/appelles/readobj.h"

#if INCLUDE_VRML
//-------------------------------------------------------------------------
//  Wrl import site
//--------------------------------------------------------------------------
void ImportWrlSite::OnComplete()
{
    TraceTag((tagImport, "ImportWrlSite::OnComplete for %s", m_pszPath));

    __try {
        Geometry *geo = ReadVrmlForImport(m_pszPath);
        if (fBvrIsValid(m_bvr))
            SwitchOnce(m_bvr, ConstBvr(geo));
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        OnError();
    }

    ImportGeomSite::OnComplete();
}


void ImportWrlSite::ReportCancel(void)
{
    ImportGeomSite::ReportCancel();
}
#endif

//-------------------------------------------------------------------------
//  X import site
//--------------------------------------------------------------------------
void ImportXSite::OnComplete()
{
    TraceTag((tagImport, "ImportXSite::OnComplete for %s", m_pszPath));

    __try {
        Geometry *geo = ReadXFileForImport
                        (m_pszPath, _v1Compatible, _wrap ? &_wrapInfo : NULL);
        if (fBvrIsValid(m_bvr))
            SwitchOnce(m_bvr, ConstBvr(geo));
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        OnError();
    }

    ImportGeomSite::OnComplete();
}


void ImportXSite::ReportCancel(void)
{
    ImportGeomSite::ReportCancel();
}

//-------------------------------------------------------------------------
//  Geom import site
//--------------------------------------------------------------------------
void
ImportGeomSite::OnError(bool bMarkFailed)
{
    HRESULT hr = DAGetLastError();
    LPCWSTR sz = DAGetLastErrorString();

    if (bMarkFailed && fBvrIsValid(m_bvr))
        ImportSignal(m_bvr, hr, sz);

    IImportSite::OnError();
}

void ImportGeomSite::ReportCancel(void)
{
    if (fBvrIsValid(m_bvr)) {
        char szCanceled[MAX_PATH];
        LoadString(hInst,IDS_ERR_ABORT,szCanceled,sizeof(szCanceled));
        ImportSignal(m_bvr, E_ABORT, szCanceled);
    }
    IImportSite::ReportCancel();
}

void ImportGeomSite::OnComplete()
{
    if (fBvrIsValid(m_bvr))
        ImportSignal(m_bvr);

    IImportSite::OnComplete();
}

bool ImportGeomSite::fBvrIsDying(Bvr deadBvr)
{
    bool fBase = IImportSite::fBvrIsDying(deadBvr);
    if (deadBvr == m_bvr) {
        m_bvr = NULL;
    }
    if (m_bvr)
        return false;
    else
        return fBase;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\eventq.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Event Queue management

*******************************************************************************/

#include "headers.h"
#include "context.h"
#include "eventq.h"
#include "view.h"
#include "privinc/vec2i.h"
#include "privinc/vec3i.h"
#include "privinc/probe.h"
#include "privinc/xformi.h"
#include "privinc/xform2i.h"
#include "appelles/image.h"
#include "privinc/mutex.h"
#include "privinc/resource.h"
#include "privinc/registry.h"
#include "privinc/debug.h"

EventQ::EventQ ()
{
    ClearStates () ;
}

EventQ::~EventQ()
{
}

// Offset to distinguish win event of same time
static const Time DIFFERENTIAL_OFFSET = 0.0000001;      

// Ensures events are enqueued sorted by time and no times are the
// same

void
EventQ::Add (AXAWindEvent & ev)
{
    if (!_msgq.empty()) {
        AXAWindEvent & lastEvent = _msgq.back();

        if (ev.when <= lastEvent.when) {
            ev.when = lastEvent.when + DIFFERENTIAL_OFFSET;
        }

        if (ev.id == AXAE_MOUSE_MOVE) {
            _mouseLeft = false;
        }
    }
    
    _msgq.push_back(ev);
}

void
EventQ::ClearStates ()
{
    _mousex = _mousey = 1000000000 ;
    _keysDown.erase(_keysDown.begin(), _keysDown.end());
    _buttonsDown.erase(_buttonsDown.begin(), _buttonsDown.end());
    _resized = FALSE ;
    _mouseLeft = false;
    _mouseLeftTime = 0.0;
}

void
EventQ::Reset ()
{
    _msgq.erase(_msgq.begin(), _msgq.end());
    ClearStates () ;
}

// Keep events for DELTA time
static const Time DELTA = 0.5;

void
EventQ::Prune(Time curTime)
{
    Time cutOff = curTime - DELTA;
    
    while (!_msgq.empty()) {
        AXAWindEvent & ev = _msgq.front();

        if (ev.when > cutOff)
            break;

        switch (ev.id) {
          case AXAE_MOUSE_BUTTON:
            if (ev.bState)
                _buttonsDown.push_front((BYTE) ev.data) ;
            else
                _buttonsDown.remove((BYTE) ev.data) ;
            break;
          case AXAE_KEY:
            if (ev.bState)
                _keysDown.push_front(ev.data) ;
            else
                _keysDown.remove(ev.data) ;
            break;
          case AXAE_MOUSE_MOVE:
            _mousex = ev.x ;
            _mousey = ev.y ;
            break ;
          case AXAE_APP_TRIGGER:
            GCRemoveFromRoots((Bvr) ev.x, GetCurrentGCRoots());
            break;
          case AXAE_FOCUS:
            if (!ev.bState) {
                // When we lose focus clear all the key states
                _keysDown.erase(_keysDown.begin(), _keysDown.end());
            }
            break ;
          default:
            break;
        }

        _msgq.pop_front();
    }
}

// Search for event with event time > t0
AXAWindEvent *
EventQ::OccurredAfter(Time when,
                      AXAEventId id,
                      DWORD data,
                      BOOL bState,
                      BYTE modReq,
                      BYTE modOpt)
{
    for (list<AXAWindEvent>::iterator i = _msgq.begin();
         i != _msgq.end();
         i++) {
        
        if ((*i).id == id &&
            (*i).data == data &&
            (*i).bState == bState &&
            ((*i).modifiers & modReq) == modReq &&
            ((*i).modifiers & (~modOpt)) == 0 &&
            (*i).when > when) {

            return &(*i);
        }
    }

    return NULL;
}

BOOL
EventQ::GetState(Time when,
                 AXAEventId id,
                 DWORD data,
                 BYTE mod)
{
    // Look through the list to see if we have any messages
    // Start looking from the end and if we find one return it
    
    for (list<AXAWindEvent>::reverse_iterator i = _msgq.rbegin();
         i != _msgq.rend();
         i++) {
             
        AXAWindEvent & ev = *i;

        if (ev.when > when)
            continue;

        // If we are looking for a key press and we have a lost focus
        // event then the key cannot be pressed
        if (ev.id == AXAE_FOCUS &&
            id == AXAE_KEY &&
            !ev.bState) {
            return FALSE ;
        }

        // Found the latest state - return it
        if (ev.id == id && ev.data == data && ev.modifiers == mod)
            return ev.bState ;
    }
    
    // Lookup the last known state

    switch (id) {
      case AXAE_MOUSE_BUTTON:
        {
            for (list<BYTE>::iterator i = _buttonsDown.begin();
                 i != _buttonsDown.end();
                 i++) {

                if (*i == data) return TRUE ;
            }

            break ;
        }
      case AXAE_KEY:
        {
            for (list<DWORD>::iterator i = _keysDown.begin();
                 i != _keysDown.end();
                 i++) {
                if (*i == data) return TRUE ;
            }

            break ;
        }
      default:
        RaiseException_InternalError ("EventGetState: Invalid event type") ;
    }

    // The data was out of range - return FALSE
    
    return FALSE ;
}

void
EventQ::GetMousePos(Time when, DWORD & x, DWORD & y)
{
    // Look through the list to see if we have any messages
    // Start looking from the end and if we find one return it
    
    for (list<AXAWindEvent>::reverse_iterator i = _msgq.rbegin();
         i != _msgq.rend();
         i++) {

        AXAWindEvent & ev = *i;

        if (ev.when > when)
            continue;

        if (ev.id == AXAE_MOUSE_MOVE || ev.id == AXAE_MOUSE_BUTTON) {
            x = ev.x ;
            y = ev.y ;
            return;
        }
    }

    // No queued events - return last known position

    x = _mousex ;
    y = _mousey ;
}

void
EventQ::MouseLeave(Time when)
{
    _mouseLeft = true;
    _mouseLeftTime = when;
} 

bool
EventQ::IsMouseInWindow(Time when)
{
    if (_mouseLeft && (when > _mouseLeftTime)) {
        return false;
    }

    return true;
}

// ======================================================
// C Functions
// ======================================================

AXAWindEvent* AXAEventOccurredAfter(Time when,
                                    AXAEventId id,
                                    DWORD data,
                                    BOOL bState,
                                    BYTE modReq,
                                    BYTE modOpt)
{ return GetCurrentEventQ().OccurredAfter(when, id, data, bState,
                                          modReq, modOpt) ; }

BOOL AXAEventGetState(Time when,
                      AXAEventId id,
                      DWORD data,
                      BYTE mod)
{ return GetCurrentEventQ().GetState(when, id, data, mod) ; }

void AXAGetMousePos(Time when, DWORD & x, DWORD & y)
{ GetCurrentEventQ().GetMousePos (when, x, y) ; }

BOOL AXAWindowSizeChanged()
{ return GetCurrentEventQ().IsResized() ; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\drawsurf.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    DrawingSurface interface

*******************************************************************************/


#ifndef _DADRARSURF_H
#define _DADRARSURF_H

#include "cbvr.h"
#include "engine.h"
#include "statics.h"
#include "srvprims.h"
#include "comconv.h"


#define RETURN_IF_ERROR(fn) {HRESULT hr = fn; if (FAILED(hr)) return hr; }

class DrawingContext;

//-------------------------------------------------------------------------
//
//  Class:      CDADrawingSurface
//
//  Synopsis:
//
//--------------------------------------------------------------------------

class
__declspec(uuid("6230F9F9-D221-11d0-9385-00C04FB6BD36")) 
ATL_NO_VTABLE CDADrawingSurface : public CComObjectRootEx<CComMultiThreadModel>,
                            public CComCoClass<CDADrawingSurface, &__uuidof(CDADrawingSurface)>,
                            public IDispatchImpl<IDADrawingSurface, &IID_IDADrawingSurface, &LIBID_DirectAnimation>,
                            public IObjectSafetyImpl<CDADrawingSurface>,
                            public ISupportErrorInfoImpl<&IID_IDADrawingSurface>
{
  friend class DrawingContext;

  public:
#if _DEBUG
    const char * GetName() { return "CDADrawingSurface"; }
#endif
    BEGIN_COM_MAP(CDADrawingSurface)
        COM_INTERFACE_ENTRY(IDADrawingSurface)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP()

    // IDADrawingSurface methods

    STDMETHOD(get_Image)(IDAImage ** img);
    STDMETHOD(put_LineStyle)(IDALineStyle *ls);
    STDMETHOD(put_BorderStyle)(IDALineStyle *bs);
    STDMETHOD(put_FontStyle)(IDAFontStyle *fs);
    STDMETHOD(put_ClipMatte)(IDAMatte *matte);
    STDMETHOD(put_MouseEventsEnabled)(VARIANT_BOOL on);
    STDMETHOD(put_HatchFillTransparent)(VARIANT_BOOL fillOff);
    STDMETHOD(get_LocalContextImage)(IDAImage ** img);

    STDMETHOD(Reset)();
    STDMETHOD(Clear)();
    STDMETHOD(SaveGraphicsState)();
    STDMETHOD(RestoreGraphicsState)();
    STDMETHOD(Opacity)(double opac);
    STDMETHOD(OpacityAnim)(IDANumber *opac);

    STDMETHOD(Crop)(double minX, double minY, double maxX, double maxY);
    STDMETHOD(CropPoints)(IDAPoint2 *min, IDAPoint2 *max);
    STDMETHOD(Transform)(IDATransform2 *xform);

    STDMETHOD(LineColor)(IDAColor *clr);
    STDMETHOD(LineWidth)(double width);
    STDMETHOD(LineDashStyle)(DA_DASH_STYLE id);
    STDMETHOD(LineEndStyle)(DA_END_STYLE id);
    STDMETHOD(LineJoinStyle)(DA_JOIN_STYLE id);

    STDMETHOD(BorderColor)(IDAColor *clr);
    STDMETHOD(BorderWidth)(double width);
    STDMETHOD(BorderDashStyle)(DA_DASH_STYLE id);
    STDMETHOD(BorderEndStyle)(DA_END_STYLE id);
    STDMETHOD(BorderJoinStyle)(DA_JOIN_STYLE id);

    STDMETHOD(Font)(BSTR FontFace, LONG sizeInPoints,
                    VARIANT_BOOL Bold, VARIANT_BOOL italic,
                    VARIANT_BOOL underline, VARIANT_BOOL strikethrough);

    // Fill Type selection methods 
    STDMETHOD(TextureFill)(IDAImage *obsolete1, double obsolete2, double obsolete3);
    STDMETHOD(ImageFill)(IDAImage *obsolete1, double obsolete2, double obsolete3);
    STDMETHOD(FillTexture)(IDAImage *img);
    STDMETHOD(FillImage)(IDAImage *img);
    STDMETHOD(FillStyle)(int ID);
    STDMETHOD(FillColor)(IDAColor *foreground);
    STDMETHOD(SecondaryFillColor)(IDAColor *val);

    STDMETHOD(GradientShape)(VARIANT pts);
    STDMETHOD(GradientExtent)(double startx, double starty, double finishx, double finishy);
    STDMETHOD(GradientExtentPoints)(IDAPoint2 *start, IDAPoint2 *stop);
    STDMETHOD(GradientRolloffPower)(double power);
    STDMETHOD(GradientRolloffPowerAnim)(IDANumber *power);

    STDMETHOD(FixedFillScale)();
    STDMETHOD(HorizontalFillScale)();
    STDMETHOD(VerticalFillScale)();
    STDMETHOD(AutoSizeFillScale)();    

    // IDADrawingSurface Draw methods
    STDMETHOD(PolylineEx)(LONG numPts, IDAPoint2 *pts[]);
    STDMETHOD(Polyline)(VARIANT pts);
    STDMETHOD(PolygonEx)(LONG numPts, IDAPoint2 *pts[]);
    STDMETHOD(Polygon)(VARIANT pts);
    STDMETHOD(LinePoints)(IDAPoint2 *point1, IDAPoint2 *point2);
    STDMETHOD(Line)(double startX, double startY,
                          double endX, double endY);
    STDMETHOD(ArcRadians)(double x, double y, double startAngle, double endAngle, double arcWidth, double arcHeight);
    STDMETHOD(ArcDegrees)(double x, double y, double startAngle, double endAngle, double arcWidth, double arcHeight);
    STDMETHOD(Oval)(double x, double y, double width, double height);
    STDMETHOD(Rect)(double x, double y, double width, double height);
    STDMETHOD(RoundRect)(double x, double y,
                         double width, double height,
                         double arcWidth, double arcHeight);
    STDMETHOD(PieRadians)(double x, double y, double startAngle, double endAngle, double arcWidth, double arcHeight);
    STDMETHOD(PieDegrees)(double x, double y, double startAngle, double endAngle, double arcWidth, double arcHeight);
    STDMETHOD(Text)(BSTR str, double x, double y);
    STDMETHOD(TextPoint)(BSTR str, IDAPoint2 *pt);
    STDMETHOD(FillPath)(IDAPath2 *path);
    STDMETHOD(DrawPath)(IDAPath2 *path);
    STDMETHOD(OverlayImage)(IDAImage *img);

    // BUGBUG -- What happens with this template parameter? vector<>??
    HRESULT OverlayImages(vector<IDAImage *> &imgVec, IDAImage **ppimg);

    CDADrawingSurface();
    virtual ~CDADrawingSurface();
    HRESULT Init(IDAStatics *st);

    DrawingContext *GetCurrentContext();
    void CleanUpImgVec();

    CComPtr<IDAStatics>    _st;
    stack<DrawingContext*> _ctxStack;
    vector<IDAImage *>     _imgVec;
};

class DrawingContext
{
public:
    DrawingContext(IDAStatics *st, CDADrawingSurface *ds,
                   DrawingContext *dc = NULL);
    ~DrawingContext();

    void SetLineStyle(IDALineStyle *ls) { _ls = ls; }
    void SetBorderStyle(IDALineStyle *bs) { _bs = bs; }
    void SetFontStyle(IDAFontStyle *fs) { _fs = fs; }
    void SetOpacity(IDANumber *op);
    void SetCrop(IDAPoint2 *min, IDAPoint2 *max);
    void SetClip(IDAMatte *matte);
    void SetXScaling(bool scaleX) { _scaleX = scaleX; }
    void SetYScaling(bool scaleY) { _scaleY = scaleY; }
    void SetForeColor(IDAColor *fore) { _fore = fore; }
    void SetBackColor(IDAColor *back) { _back = back; }
    void SetHatchFill(bool fillOff) { _hatchFillOff = fillOff; }
    void SetTexture(IDAImage *img) { _fillTex = img; }
    void SetGradientExtent(IDAPoint2 *start, IDAPoint2 *finish);
    void SetGradientRolloffPower(IDANumber *power) { _power = power; }
    void SetFillStyle(int type) { _fillType = type; }
    void SetMouseEventsEnabled(bool val) { _mouseEvents = val; }
    void CleanUpImgVec();
    vector<IDAImage *> imgVec()             {return _imgVec;}

    HRESULT LineDashStyle(DA_DASH_STYLE id);
    HRESULT BorderDashStyle(DA_DASH_STYLE id);
    HRESULT SetGradientShape(VARIANT pts);
    HRESULT Transform(IDATransform2 *xf);
    HRESULT TextPoint(BSTR str, IDAPoint2 *pt);
    HRESULT Draw(IDAPath2 *pth, VARIANT_BOOL bFill);
    HRESULT Overlay(IDAImage *img);
    HRESULT Reset();

    IDALineStyle * GetLineStyle()    { return _ls; }
    IDALineStyle * GetBorderStyle()  { return _bs; }

private:
    CComPtr<IDAStatics>     _st;
    CComPtr<IDATransform2>  _xf;
    CComPtr<IDAMatte>       _matte;
    CComPtr<IDANumber>      _op;
    CComPtr<IDALineStyle>   _ls;
    CComPtr<IDALineStyle>   _bs;
    CComPtr<IDALineStyle>   _savedLs;
    CComPtr<IDALineStyle>   _savedBs;
    CComPtr<IDAFontStyle>   _fs;
    CComPtr<IDAPoint2>      _cropMin;
    CComPtr<IDAPoint2>      _cropMax;
    CComPtr<IDAImage>       _fillTex;
    CComPtr<IDAImage>       _fillGrad;
    CComPtr<IDAColor>       _fore;
    CComPtr<IDAColor>       _back;
    CComPtr<IDAPoint2>      _start;
    CComPtr<IDAPoint2>      _finish;
    CComPtr<IDANumber>      _power;


    vector<IDAImage *>  _imgVec;
    CDADrawingSurface   *_ds;
    int                 _fillType;
    bool                _mouseEvents;
    bool                _scaleX, _scaleY;
    bool                _hatchFillOff;
    bool                _extentChgd;
    bool                _opChgd;
    bool                _xfChgd;
    bool                _cropChgd;
    bool                _clipChgd;
};

enum {  // Fill Styles
    fill_empty = 0,
    fill_solid = 1,
    fill_detectableEmpty = 2,
    fill_hatchHorizontal = 3,
    fill_hatchVertical = 4,
    fill_hatchForwardDiagonal = 5,
    fill_hatchBackwardDiagonal = 6,
    fill_hatchCross = 7,
    fill_hatchDiagonalCross = 8,
    fill_horizontalGradient = 9,
    fill_verticalGradient = 10,
    fill_radialGradient = 11,
    fill_lineGradient = 12,  
    fill_rectGradient = 13,
    fill_shapeGradient = 14,
    fill_image = 15,
    fill_texture = 16
};
#endif /* _DADRAWSURF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\impmovie.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

   This module implements all functionality associated w/ 
   importing image media. 

*******************************************************************************/
#include "headers.h"
#include "import.h"
#include "include/appelles/axaprims.h"
#include "include/appelles/readobj.h"
#include "privinc/movieimg.h"
#include "privinc/soundi.h"
#include "privinc/miscpref.h"
#include "impprim.h"
#include "backend/sndbvr.h"

//-------------------------------------------------------------------------
//  Movie import site
//--------------------------------------------------------------------------
void
ImportMovieSite::OnError(bool bMarkFailed)
{
    HRESULT hr = S_OK; // all import errs are handled (was: DAGetLastError())
    LPCWSTR sz = DAGetLastErrorString();
    
    if(bMarkFailed) {
        if(fBvrIsValid(_soundBvr))
            ImportSignal(_soundBvr, hr, sz);
        if(fBvrIsValid(_imageBvr))
            ImportSignal(_imageBvr, hr, sz);
    }

    StreamableImportSite::OnError();
}
    

void ImportMovieSite::ReportCancel(void)
{
    // @@@ XXX shouldn't we change this to be natively wide strings ?
    char szCanceled[MAX_PATH];
    LoadString(hInst,IDS_ERR_ABORT,szCanceled,sizeof(szCanceled));
    if(fBvrIsValid(_soundBvr))
        ImportSignal(_soundBvr, E_ABORT, szCanceled);
    if(fBvrIsValid(_imageBvr))
        ImportSignal(_imageBvr, E_ABORT, szCanceled);
    StreamableImportSite::ReportCancel();
}
    

bool
EnableAVmode() // enable avmode based on the criteria of the day
{
    // registry(if present) overides tracetag (if debug) which overides default
    // we also check to ensure that all the post 4.0.1 amstream interfaces 
    //    needed for avmode are present

    // ----> CHANGE THE DEFAULT AVMODE HERE! <-----
    bool movieFix = true;  // default to on!

#ifdef REMOVEDFORNOW
#if _DEBUG
    // if debug set movieFix to tracetag value (subject to registry overide)
    movieFix = IsTagEnabled(tagMovieFix) ? true : false;
#endif
#endif

    { // open registry key, read value
    HKEY hKey;
    char *subKey = "Software\\Microsoft\\DirectAnimation\\Preferences\\AUDIO";
    char *valueName = "avmode";
    DWORD     type;
    DWORD     data;
    DWORD     dataSize = sizeof(data);

    // does reg entry exist?
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, subKey, 
                                      NULL, KEY_ALL_ACCESS, &hKey)) {

        // if we can read value...
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, valueName, NULL, &type,
                                      (LPBYTE) &data, &dataSize))
            movieFix = data ? true : false; // force mode if regentry exists
    }

    RegCloseKey(hKey);
    }

    if(!QuartzAVmodeSupport())
        movieFix = false;  // dissable if we have an old amstream

return(movieFix);
}

void ImportMovieSite::OnComplete()
{
    int delay = -1; // default to -1
    double videoLength = 0.0, soundLength = 0.0;

    TraceTag((tagImport, "ImportMovieSite::OnComplete for %s", m_pszPath));

    LeafSound      *sound  = NULL;
    Bvr      movieImageBvr = NULL;

    // pick pathname 'raw' url for streaming or urlmon download path
    char *pathname = GetStreaming() ? m_pszPath : GetCachePath();
    Assert(pathname);

    bool _enableAVmode = EnableAVmode(); 

    if(!_enableAVmode) {
        // conventional code path, attempt to create 1 sound and 1 movie object
        TraceTag((tagAVmodeDebug,
            "ImportMovieSite::OnComplete seperate A and V movie creation"));
        __try {
            sound = ReadQuartzAudioForImport(pathname, &soundLength);
        } __except ( HANDLE_ANY_DA_EXCEPTION ) {
            sound   = NULL;  // FAILED! OK, we will try to continue w/o audio
        }
        
        __try {
            movieImageBvr = ReadQuartzVideoForImport(pathname, &videoLength);
        } __except ( HANDLE_ANY_DA_EXCEPTION ) {
            // FAILED! OK, we will try to continue w/o video
            movieImageBvr = NULL; 
        }
    }
    else {
        // wild'n'crazy workaround mode.  Create one object both audio, video
        TraceTag((tagAVmodeDebug,
            "ImportMovieSite::OnComplete AV movie creation"));

        __try {
            ReadAVmovieForImport(pathname, &sound, &movieImageBvr, &videoLength);
            soundLength = videoLength;  // these are boundup together!
        } __except ( HANDLE_ANY_DA_EXCEPTION ) {
            movieImageBvr = NULL; // FAILED!
            sound      = NULL; // FAILED!
        }
    }
    

    __try {
        // Switch only after importing everything.  Should probably lock
        // the switchers for to make these synchronized but that still
        // wouldn't guarantee that they would happen on the same frame.
        if(!sound && !movieImageBvr) {  // did we fail completely?
            // The errors have already been set
            RaiseException_UserError();
        }
        else {  // at least we have audio or video
            if(sound && fBvrIsValid(_soundBvr))
                SwitchOnce(_soundBvr, SoundBvr(sound));
            else if(fBvrIsValid(_soundBvr))
                SwitchOnce(_soundBvr, ConstBvr(silence));

            if (movieImageBvr && fBvrIsValid(_imageBvr))
                SwitchOnce(_imageBvr, movieImageBvr);
            else if(fBvrIsValid(_imageBvr))
                SwitchOnce(_imageBvr, ConstBvr(emptyImage));

            double length;
            if(sound && movieImageBvr)
                length = (soundLength > videoLength) ? soundLength : videoLength;
            else if(movieImageBvr)
                length = videoLength;
            else
                length = soundLength;
            if(fBvrIsValid(_lengthBvr)) {
                // XXX TODO DON'T CALCULATE LENGTH if _lengthBvr isn't valid!
                SwitchOnce(_lengthBvr, NumToBvr(length)); 
            }
        }
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        // ImportSignal only needed to be explicitly called if for some reason
        // there exists a failure.  Switch once calls Signal and is side 
        // effecting nulling the bvr member on the import object
        if(fBvrIsValid(_imageBvr))
           ImportSignal(_imageBvr);
        if(fBvrIsValid(_soundBvr))
           ImportSignal(_soundBvr);
    }

    // SwitchOnce, or failing that, ImportSignal should have nulled these
    Assert(!_imageBvr); 
    Assert(!_soundBvr);

    StreamableImportSite::OnComplete();
}


bool ImportMovieSite::fBvrIsDying(Bvr deadBvr)
{
    bool fBase = StreamableImportSite::fBvrIsDying(deadBvr);
    if(deadBvr == _imageBvr) {
        _imageBvr = NULL;
    }
    else if(deadBvr == _soundBvr) {
        _soundBvr = NULL;
    }
    else if(deadBvr == _lengthBvr) {
        _lengthBvr = NULL;
    }
    if(_imageBvr || _soundBvr || _lengthBvr)
        return false;
    else
        return fBase;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\impimage.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

   This module implements all functionality associated w/ 
   importing image media. 

*******************************************************************************/
#include "headers.h"
#include "privinc/backend.h"
#include "import.h"
#include "include/appelles/axaprims.h"
#include "include/appelles/readobj.h"
#include "privinc/movieimg.h"
#include "impprim.h"
//-------------------------------------------------------------------------
//  Image import site
//--------------------------------------------------------------------------


void
ImportImageSite::OnError(bool bMarkFailed)
{
    HRESULT hr = DAGetLastError();
    LPCWSTR sz = DAGetLastErrorString();
    
    if (bMarkFailed && fBvrIsValid(m_bvr))
        ImportSignal(m_bvr, hr, sz);

    IImportSite::OnError();
}
    
void ImportImageSite::ReportCancel(void)
{
    if (fBvrIsValid(m_bvr)) {
        char szCanceled[MAX_PATH];
        LoadString(hInst,IDS_ERR_ABORT,szCanceled,sizeof(szCanceled));
        ImportSignal(m_bvr, E_ABORT, szCanceled);
    }
    IImportSite::ReportCancel();
}
    
void ImportImageSite::OnComplete()
{
    int count = 0;
    int *delays = (int*)ThrowIfFailed(malloc(sizeof(int)));
    int loop = 0;

    TraceTag((tagImport, "ImportImageSite::OnComplete for %s", m_pszPath));

    Image **p;

    // See if it's a type we handle natively.
    
    __try {
        // ReadDibForImport returns an array that's allocated on
        // GCHeap 
    
        p = ReadDibForImport(const_cast<char*>(GetPath()),
                             GetCachePath(),
                             GetStream(),
                             m_useColorKey,
                             m_ckRed,
                             m_ckGreen,
                             m_ckBlue,
                             &count, 
                             &delays,
                             &loop);

        Bvr importedImageBvr = NULL;
    
        if (p) {
            if (count == 1) {
        
                importedImageBvr = ConstBvr(*p);
    
                // Free the return array as we're only interested in the first
                // element. 
                StoreDeallocate(GetGCHeap(), p);
            } else {
                // animated images
                importedImageBvr = AnimImgBvr(p, count, delays, loop);
            }
        }

        if (importedImageBvr && fBvrIsValid(m_bvr)) {
            SwitchOnce(m_bvr, importedImageBvr);
        }
        
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        OnError();
    }

    if (fBvrIsValid(m_bvr))
        ImportSignal(m_bvr);

    IImportSite::OnComplete();    
}


bool ImportImageSite::fBvrIsDying(Bvr deadBvr)
{
    bool fBase = IImportSite::fBvrIsDying(deadBvr);
    if (deadBvr == m_bvr) {
        m_bvr = NULL;
    }
    if (m_bvr)
        return FALSE;
    else
        return fBase;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\impprim.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

   This module implements all import primitives (level below COM)

*******************************************************************************/

#include "headers.h"
#include "context.h"
#include "guids.h"
#include "dispids.h"
#include "include/appelles/readobj.h"
#include "include/appelles/axaprims.h"
#include "backend/events.h"
#include "backend/jaxaimpl.h"
#include "privinc/urlbuf.h"
#include "privinc/resource.h"
#include "privinc/movieimg.h"
#include "privinc/soundi.h"
#include "privinc/midi.h"
#include "privinc/qmidi.h"
#include "privinc/server.h"
#include "privinc/opt.h"
#include "privinc/debug.h"
#include "privinc/stream.h"
#include "privinc/stquartz.h"
#include "privinc/util.h"
#include "privinc/soundi.h"
#include "appelles/sound.h"
#include "appelles/readobj.h"
#include "axadefs.h"
#include "include/appelles/hacks.h"
#include "privinc/miscpref.h"
#include "privinc/bufferl.h"
#include "impprim.h"
#include "privinc/viewport.h" // GetDirectDraw
#include "backend/moviebvr.h"

class AnimatedImageBvrImpl : public BvrImpl {
  public:
    AnimatedImageBvrImpl(Image **i, int count, int *delays, int loop) :
    _images(i), _count(count), _delays(delays), _loop(loop) {
        Assert( (count > 1) && "Bad image count (<=1)");
            
        _delaySum = 0.0;
        Assert(_delays);
        for(int x=0; x<_count; x++)
            _delaySum += double(_delays[x]) / 1000.0;
    }

    ~AnimatedImageBvrImpl() {
        StoreDeallocate(GetGCHeap(), _images);
        StoreDeallocate(GetGCHeap(), _delays);
    }
        
    virtual DWORD GetInfo(bool) { return BVR_TIMEVARYING_ONLY; }

    virtual Perf _Perform(PerfParam& p);

    virtual void _DoKids(GCFuncObj proc) { 
                for (int i=0; i<_count; i++)
                        (*proc)(_images[i]);
        }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "AnimatedGif"; }
#endif

    virtual DXMTypeInfo GetTypeInfo () { return ImageType ; }

    Image **_images;
    int _count;
    int _loop;
    int *_delays;
    double      _delaySum;
};

class AnimatedImagePerfImpl : public PerfImpl {
  public:
    AnimatedImagePerfImpl(AnimatedImageBvrImpl *base, TimeXform tt)
    : _base(base), _tt(tt) {}

    AxAValue _Sample(Param& p) {
        double localTime = EvalLocalTime(p, _tt);           // Get local time
        unsigned long curLoop =
            (unsigned long) floor( localTime / double(_base->_delaySum) );
        double curDelay = localTime - double(curLoop) * _base->_delaySum;
        double accumDelay = 0.0;
        long index = 0;

        // Detect a boundary condition and return the max index.
        Assert(_base->_loop >= -1);
        Assert(_base->_count > 0);
        if( (_base->_count == 1) ||
            (_base->_loop == -1) ||
            ((_base->_loop != 0) && (curLoop > _base->_loop)) ) {
            return _base->_images[_base->_count-1];
        }        

        // walk through delays to determine our index value
        double delay = double(_base->_delays[index]) / 1000.0; // delay value in milliSeconds  
        while ((curDelay > accumDelay+delay) && (index < _base->_count)) {            
            accumDelay += delay;
            delay = double(_base->_delays[++index]) / 1000.0;  
        }
                              
        return _base->_images[index];  
    }

    virtual void _DoKids(GCFuncObj proc) { 
        (*proc)(_tt); 
        (*proc)(_base);
        }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "AnimatedGif perf"; }
#endif

  private:
    TimeXform     _tt;
    AnimatedImageBvrImpl *_base;
};

Perf
AnimatedImageBvrImpl::_Perform(PerfParam& p)
{
    return NEW AnimatedImagePerfImpl(this, p._tt);
}

Bvr AnimImgBvr(Image **i, int count, int *delays, int loop)
{return NEW AnimatedImageBvrImpl(i,count,delays,loop);}


Sound *
ReadMidiFileWithLength(char *pathname, double *length) // returns length
{
    Assert(pathname);
    if(!pathname)
        RaiseException_InternalError("cache path name not set");
    return(ReadMIDIfileForImport(pathname, length));
}


extern miscPrefType miscPrefs; // registry prefs struct setup in miscpref.cpp
LeafSound *ReadMIDIfileForImport(char *pathname, double *length)
{
    TraceTag((tagImport, "Read MIDI file %s", pathname));

    Assert(pathname);
    if(!pathname)
        RaiseException_InternalError("cache path name not set");

#ifdef REGISTRY_MIDI
    // select aaMIDI/qMIDI based on a registry entry...
    MIDIsound *snd;
    if(miscPrefs._qMIDI) 
        snd = NEW  qMIDIsound;
    else
        snd = NEW aaMIDIsound;
#else
    qMIDIsound *snd = NEW qMIDIsound;
#endif
    snd->Open(pathname);

    *length = snd->GetLength();

    return snd;
}

static StreamQuartzPCM *_NewStreamQuartzPCM(char *pathname)
{
    return NEW StreamQuartzPCM(pathname);
}

static StreamQuartzPCM *_Nonthrowing_NewSteamQuartzPCM(char *pathname)
{
    StreamQuartzPCM *sound = NULL;
    __try {  // need to test this to allow only audio or video to
             // succeed
        sound = _NewStreamQuartzPCM(pathname);
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {}

    return sound;
}


static MovieImage *_NewMovieImage(QuartzAVstream *quartzAVstream)
{
    return NEW MovieImage(quartzAVstream, ViewerResolution());
}

static MovieImage *_Nonthrowing_NewMovieImage(QuartzAVstream *quartzAVstream)
{
    MovieImage *image = NULL;
    
    __try { // need to test this to allow only audio or video to succeed

        image = _NewMovieImage(quartzAVstream);

    } __except ( HANDLE_ANY_DA_EXCEPTION ) {}

    return image;
}

// returns null sound, or image if failure...
// added complexity to allow audio or video to fail
void ReadAVmovieForImport(char *simplePathname, 
                          LeafSound **sound,
                          Bvr *pImageBvr,
                          double *length)
{
    MovieImage *image = NULL;  // make sure these default to null if we throw
    *pImageBvr = NULL;
    *sound = NULL;
    StreamQuartzPCM *snd;
    
    Assert(simplePathname);
    if(!simplePathname)
        RaiseException_InternalError("cache path name not set");

    char *pathname = simplePathname;

    *length = HUGE_VAL; // default to something big!

    // for the purposes of speeding up first use, instantiate and cache a fg
    
    // try to create an AVstream (we might find it fails audio or video)
    QuartzAVstream *quartzAVstream = NEW QuartzAVstream(pathname);
    if(quartzAVstream) {
        // if we don't have audio and video destroy and get us what we wanted!
        if(!quartzAVstream->GetAudioValid() && !quartzAVstream->GetVideoValid()) {
            // XXX bad scene, no audio or video!
            delete quartzAVstream;  // forget the stream, leave sound + image null
        }
        else if(!quartzAVstream->GetAudioValid()) { // no audio, do ReadVideo()
            delete quartzAVstream;  // forget the stream
            *pImageBvr = ReadQuartzVideoForImport(simplePathname, length);
        }
        else if(!quartzAVstream->GetVideoValid()) { // no video, do ReadAudio()
            delete quartzAVstream;  // forget the stream
            *sound = ReadQuartzAudioForImport(simplePathname, length);
        } 
        else {  // avstream with audio and video! (lets actually do the work)
            *sound = snd = _Nonthrowing_NewSteamQuartzPCM(pathname);

            // RobinSp says we can't count on GetDuration being accurate!
            *length = 
                quartzAVstream->QuartzVideoReader::GetDuration();  // get the duration

            image = _Nonthrowing_NewMovieImage(quartzAVstream);

            // add qstream to context sound cache list to be recycled later!
            SoundBufferCache *sndCache = GetCurrentContext().GetSoundBufferCache();
            if(sound) {
                QuartzBufferElement *bufferElement =
                    NEW QuartzBufferElement(snd, quartzAVstream, NULL); // NULL path
                bufferElement->SetNonAging();  // dissable aging for imports
                sndCache->AddBuffer(*sound, bufferElement);
            }

            if(image) {
                QuartzVideoBufferElement *bufferElement =
                    NEW QuartzVideoBufferElement(quartzAVstream);
                *pImageBvr = MovieImageBvr(image, bufferElement);
            }
        }
    }
}


LeafSound *
ReadQuartzAudioForImport(char *simplePathname, double *length)
{
    Assert(simplePathname);
    if(!simplePathname)
        RaiseException_InternalError("cache path name not set");

    char *pathname = simplePathname;

    StreamQuartzPCM *snd = NEW StreamQuartzPCM(pathname);
    *length = HUGE_VAL; // default to something big!

    // GetHeapOnTopOfStack().RegisterDynamicDeleter(NEW
        // DynamicPtrDeleter<Sound>(snd));

    // for the purposes of speeding up first use, instantiate and cache a fg
    QuartzAudioStream *quartzStream = NEW QuartzAudioStream(pathname);
    if(quartzStream) {
        // XXX RobinSp says we can't count on GetDuration being accurate!
        *length = quartzStream->GetDuration();  // get the duration

        // add qstream to context sound cache list to be recycled later!
        QuartzBufferElement *bufferElement =
            NEW QuartzBufferElement(snd, quartzStream, NULL);

        SoundBufferCache *sndCache = GetCurrentContext().GetSoundBufferCache();
        // allow aging: bufferElement->SetNonAging();  // dissable aging for imports
        sndCache->AddBuffer(snd, bufferElement);
    }

    return snd;
}


Bvr
ReadQuartzVideoForImport(char *simplePathname, double *length)
{
    Assert(simplePathname);
    if(!simplePathname)
        RaiseException_InternalError("cache path name not set");

    char *pathname = simplePathname;
    MovieImage *movieImage = NULL;

    *length = HUGE_VAL; // default to something big!
    QuartzVideoStream *quartzStream = NEW QuartzVideoStream(pathname);
    if(quartzStream) {
        movieImage = NEW MovieImage(quartzStream, ViewerResolution());

        // XXX RobinSp says we can't count on GetDuration being accurate!
        *length = quartzStream->GetDuration();  // get the duration

        // add qstream to context sound cache list to be recycled later!
        QuartzVideoBufferElement *bufferElement =
            NEW QuartzVideoBufferElement(quartzStream);

        return MovieImageBvr(movieImage, bufferElement);
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\import.h ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    async moniker import header

Revision:

--*/
#ifndef _IMPORT_H_
#define _IMPORT_H_

#include "privinc/comutil.h"
#include "privinc/ipc.h"
#include "backend/bvr.h"
#include "privinc/importgeo.h"

//-------------------------------------------
//forward declarations
//-------------------------------------------
class IImportSite;

void SetImportOnBvr(IImportSite * import,Bvr b);
void SetImportOnEvent(IImportSite * import,Bvr b);

class ImportThread : public DAThread
{
  public:
    // This is callable from any thread to add an import to the import
    // queue
    void AddImport(IImportSite* pICB);
    bool FinishImport(IImportSite* pICB);

    void StartThread();
    void StopThread();

  protected:
    virtual void ProcessMsg(DWORD dwMsg,
                            DWORD dwNumParams,
                            DWORD_PTR dwParams[]);

    CritSect _cs;

#if DEVELOPER_DEBUG
    virtual char * GetName() { return "ImportThread"; }
#endif
};

void StartImportThread();
void StopImportThread();

//use this structure to override default behavior of IBSC
struct BSCInfo {
    DWORD grfBINDF;  //bindinfo flags
};

//-------------------------------------------
// asynchronouse URL callback interface
//-------------------------------------------
class CImportBindStatusCallback : public IBindStatusCallback,
                                  public IAuthenticate,
                                  public AxAThrowingAllocatorClass
{
  public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid,void ** ppv);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IBindStatusCallback methods
    STDMETHOD(OnStartBinding)(DWORD grfBSCOption, IBinding* pbinding);
    STDMETHOD(GetPriority)(LONG* pnPriority);
    STDMETHOD(OnLowResource)(DWORD dwReserved);
    STDMETHOD(OnProgress)(
        ULONG ulProgress,
        ULONG ulProgressMax,
        ULONG ulStatusCode,
        LPCWSTR pwzStatusText);
    STDMETHOD(OnStopBinding)(HRESULT hrResult, LPCWSTR szError);
    STDMETHOD(GetBindInfo)(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHOD(OnDataAvailable)(
        DWORD grfBSCF,
        DWORD dwSize,
        FORMATETC *pfmtetc,
        STGMEDIUM* pstgmed);
    STDMETHOD(OnObjectAvailable)(REFIID riid, IUnknown* punk);

    // IAuthenticate methods
    STDMETHOD(Authenticate)(HWND * phwnd,LPWSTR * pwszUser,LPWSTR * pwszPassword);

    // Constructors/destructors
    CImportBindStatusCallback(IImportSite* pIIS);
    virtual ~CImportBindStatusCallback();

  private:
    char m_szCacheFileName[INTERNET_MAX_URL_LENGTH];
    IImportSite* m_pIIS;
    CComPtr<IBinding> m_pbinding;
    DWORD     m_cRef;
    UINT m_ulProgressMax;
    friend class ASyncImport;
    friend class IImportSite;
};


//------------------------------------------------------------
// Import Site
// Site specific outgoing interface used by
// the asynchronous URL moniker.  All media
// import sites should inherit from this interface
// NOTE: all bvrs used in import sites MUST be ImportSwitcherBvr
// or ImportEvent
//------------------------------------------------------------
//REVIEW--garbage collection

class ATL_NO_VTABLE IImportSite : public AxAThrowingAllocatorClass
{
#define _SimImports 2
  public:
    IImportSite(LPSTR pszPath,
                CRImportSitePtr site,
                IBindHost * bh,
                bool bAsync,
                Bvr ev = NULL,
                Bvr progress = NULL,
                Bvr size = NULL);
    virtual ~IImportSite();

    ULONG AddRef() { return InterlockedIncrement(&m_cRef); }
    ULONG Release() {
        ULONG ul = InterlockedDecrement(&m_cRef) ;
        if (ul == 0) delete this;
        return ul;
    }

    Bvr  GetEvent() { return m_ev ; }
    void SetEvent(Bvr event) ;

    Bvr  GetProgress() { return m_progress; }
    void SetProgress(Bvr progress) ;

    Bvr  GetSize() { return m_size; }
    void SetSize(Bvr size) ;

    // This is callable from any thread and is the main call to add
    // the import site to the queue of imports to begin downloading
    void StartDownloading();

    //OnProgress--called during download, if file size is available.
    //%complete = ulProgress/ulProgressMax * 100
    virtual void OnProgress(ULONG ulProgress,
                            ULONG ulProgressMax) ;

    //OnStartLoading-called by async moniker on OnStartBinding
    virtual void OnStartLoading();

    //OnStartLoading-called by async moniker for any type of error.
    //Returns hresult and error string of error.
    virtual void OnError(bool bMarkFailed = true);

    // This must be provided by any derived classes
    // This is called from OnSerializeFinish with the critical section
    // already obtained and the heaps set
    virtual void OnComplete();

    IStream *GetStream() {
        return m_IStream;
    }

    LPCSTR  GetPath()      { return m_pszPath;   }
    char   *GetCachePath() { return  _cachePath; }
    void    SetCachePath(char *path);

    void vBvrIsDying(Bvr deadBvr);
    virtual bool fBvrIsDying(Bvr deadBvr);
    bool fBvrIsValid(Bvr myBvr){return ((myBvr != NULL) && (myBvr->Valid()));}
    bool AllBvrsDead(){return m_fAllBvrsDead;}
    void SetAllBvrsDead(){m_fAllBvrsDead = true;}
    bool IsCanceled(){return m_bCanceled;}
    CritSect m_CS;

    DWORD GetImportId() { return m_id; }
  protected:
    DWORD m_id;
    LPSTR m_pszPath;
    double m_lastProgress;
    bool m_bSetSize;
    bool m_fReportedError;
    bool m_bAsync;
    DAComPtr<IStream> m_IStream;
    DAComPtr<CRImportSite> m_site;
    DAAPTCOMPTR(IBindHost) m_bindhost;

    //OnSerializeFinish-called via a thread message in OnStopLoading.
    //Used to serialize calls to import primitives.
    void OnSerializeFinish();
    // SEH
    void OnSerializeFinish_helper();
    void OnSerializeFinish_helper2();
    void Import_helper(LPWSTR &pwszUrl);

    // If bDone is false then num cannot be >= 1
    void UpdateProgress(double num, bool bDone = false);

    friend class ASyncImport;
    friend class CImportBindStatusCallback;

    long m_cRef;

    char *_cachePath; // CImportBindStatusCallback::OnProgress sets this

    // This is called to complete the processing of the data after the
    // IStream is valid
    void CompleteDownloading();

    virtual HRESULT Import();

    static const int LOAD_OK;
    static const int LOAD_FAILED;

  private:
    bool m_fAllBvrsDead;
    Bvr m_ev;
    Bvr m_progress;
    Bvr m_size;
    bool m_bCanceled;

    // TODO: Don you may want to change this back to how it was but I
    // wanted to separate them from the StartDownloading call I added
    friend ImportThread;

    // Protect these from being called from the wrong thread
    HRESULT QueueImport();
    HRESULT CompleteImport();
    bool DeQueueImport();
    static HRESULT StartAnImport();

    // some stuff to sync sim import limits
    float m_ImportPrio;
    bool  m_bQueued;
    bool  m_bImporting;
    bool  IsQueued(){return m_bQueued;}
    void  StartingImport();
    void  EndingImport();
    bool  IsImporting(){return m_bImporting;}

    static int SimImports();
#ifdef _DEBUG
    DWORD dwconsttime;
    DWORD dwqueuetime;
    DWORD dwstarttime;
    DWORD dwfirstProgtime;
    DWORD dwCompletetime;
#endif
    // protect the stack;
  public:
    // cancel needs to do more later...
    void CancelImport();
    virtual void ReportCancel(void){return;}
    void   SetImportPrio(float ip) { m_ImportPrio = ip; }
    float  GetImportPrio() { return m_ImportPrio; }
    static CritSect * s_pCS;
    static char s_Fmt[100];
    static list<IImportSite *> * s_pSitelist;
    static ImportThread * s_thread;
};


#define STREAM_THREASHOLD 200000  // size in bytes where we automaticaly stream

class StreamableImportSite : public IImportSite
{
  public:
    StreamableImportSite(LPSTR      pszPath,
                         CRImportSitePtr site,
                         IBindHost * bh,
                         bool       bAsync,
                         Bvr        ev        = NULL,
                         Bvr        progress  = NULL,
                         Bvr size = NULL)
    : IImportSite(pszPath, site, bh, bAsync, ev, progress, size), _stream(false)
    {}

    HRESULT Import();
    virtual void ReportCancel(void){IImportSite::ReportCancel();}
    void    SetStreaming(bool mode) { _stream = mode;  }
    bool    GetStreaming()          { return(_stream); }

  protected:
    bool    _stream;
};


struct ImportSiteGrabber
{
    ImportSiteGrabber(IImportSite & p, bool bAddRef = true)
    : _pSite(p)
    {
        if (bAddRef) _pSite.AddRef();
    }
    ~ImportSiteGrabber(){
        _pSite.Release();
    }

  protected:
    IImportSite & _pSite;
};


//-------------------------------------------
// Image Import Site
//-------------------------------------------
class ImportImageSite : public IImportSite
{
  public:
    ImportImageSite(LPSTR pszPath,
                    CRImportSitePtr site,
                    IBindHost * bh,
                    bool bAsync,
                    Bvr bvr,
                    bool useColorKey,
                    BYTE ckRed,
                    BYTE ckGreen,
                    BYTE ckBlue,
                    Bvr ev = NULL,
                    Bvr progress = NULL)
    : IImportSite(pszPath,site,bh,bAsync,ev,progress),
      m_bvr(bvr),
      m_useColorKey(useColorKey),
      m_ckRed(ckRed),
      m_ckGreen(ckGreen),
      m_ckBlue(ckBlue)
    {
        // register the import site with the bvrs.  all derived classes must do
        // this for their contained bvrs so the callbacks will work...
        SetImportOnBvr(this,m_bvr);
    }

    ~ImportImageSite(){
    }

    virtual void ReportCancel(void);
    virtual void OnComplete();
    virtual void OnError(bool bMarkFailed = true);
    virtual bool fBvrIsDying(Bvr deadBvr);

  protected:
    Bvr  m_bvr;
    bool m_useColorKey;
    BYTE m_ckRed;
    BYTE m_ckGreen;
    BYTE m_ckBlue;
};


//-------------------------------------------
// Movie Import Site
//-------------------------------------------
class ImportMovieSite : public StreamableImportSite
{
  public:
    ImportMovieSite(LPSTR pszPath,
                    CRImportSitePtr site,
                    IBindHost * bh,
                    bool bAsync,
                    Bvr imageBvr,
                    Bvr sndBvr,
                    Bvr lengthBvr,
                    Bvr ev = NULL,
                    Bvr progress = NULL)
    : StreamableImportSite(pszPath,site,bh,bAsync,ev,progress),
      _imageBvr(imageBvr),
      _soundBvr(sndBvr),
      _lengthBvr(lengthBvr)
    {
        // register the import site with the bvrs.  all derived classes must do
        // this for their contained bvrs so the callbacks will work...
        SetImportOnBvr(this,_imageBvr);
        SetImportOnBvr(this,_soundBvr);
        SetImportOnBvr(this,_lengthBvr);
    }

    ~ImportMovieSite(){
    }

    virtual void ReportCancel(void);
    virtual void OnComplete();
    virtual void OnError(bool bMarkFailed = true);
    virtual bool fBvrIsDying(Bvr deadBvr);

  protected:
    Bvr       _imageBvr;
    Bvr       _soundBvr;
    Bvr       _lengthBvr;
};


//-------------------------------------------
// AMstream Import Site
//-------------------------------------------
class ATL_NO_VTABLE ImportSndsite : public StreamableImportSite
{
  public:
    ImportSndsite(LPSTR pszPath,
                  CRImportSitePtr site,
                  IBindHost * bh,
                  bool  bAsync,
                  Bvr   bvr,
                  Bvr   lengthBvr,
                  Bvr   ev         = NULL,
                  Bvr   progress   = NULL)
    : StreamableImportSite(pszPath, site, bh, bAsync, ev, progress),
      m_bvr(bvr), m_lengthBvr(lengthBvr)
    {
        SetImportOnBvr(this,m_bvr);
        SetImportOnBvr(this,m_lengthBvr);
    }

    virtual void OnProgress(ULONG ulProgress, ULONG ulProgressMax)
        { IImportSite::OnProgress(ulProgress,ulProgressMax); }

    ~ImportSndsite() { }
    virtual void ReportCancel(void);
    virtual void OnComplete();
    virtual void OnError(bool bMarkFailed = true);
    virtual bool fBvrIsDying(Bvr deadBvr);

  protected:
    Bvr   m_bvr;
    Bvr   m_lengthBvr;
};


class ImportPCMsite : public ImportSndsite
{
  public:
    ImportPCMsite(LPSTR pszPath,
                  CRImportSitePtr site,
                  IBindHost * bh,
                  bool  bAsync,
                  Bvr   bvr,
                  Bvr   bvrNum,
                  Bvr   lengthBvr,
                  Bvr   ev         = NULL,
                  Bvr   progress   = NULL)
    : ImportSndsite(pszPath,site,bh,bAsync,bvr,lengthBvr,ev,progress),
      m_bvrNum(bvrNum)
    { SetImportOnBvr(this,m_bvrNum); }

    ~ImportPCMsite() { }

    virtual void OnProgress(ULONG ulProgress, ULONG ulProgressMax)
    {
        _soundBytes = ulProgressMax;

        // compute average bandwidth (need to know current time!)

        // if time remaining to download < (the time it takes to play what we
        // already have downloaded) AND the file is over a certain length
        // then early play it (stream type2)...
    }


    virtual void ReportCancel(void);
    virtual void OnComplete();
    virtual bool fBvrIsDying(Bvr deadBvr);

  protected:

    // SEH
    void OnComplete_helper(Sound * &sound,
                           Bvr &soundBvr,
                           double &length,
                           bool &nonFatal);

    Bvr   m_bvrNum;
    ULONG  _soundBytes;
};


//-------------------------------------------
// Mid Import Site
//-------------------------------------------
class ImportMIDIsite : public ImportSndsite
{
  public:
    ImportMIDIsite(LPSTR pszPath,
                   CRImportSitePtr site,
                   IBindHost * bh,
                   bool bAsync,
                   Bvr  bvr,
                   Bvr  lengthBvr,
                   Bvr  ev       = NULL,
                   Bvr  progress = NULL)
    : ImportSndsite(pszPath,site,bh,bAsync,bvr,lengthBvr,ev,progress) { }

    ~ImportMIDIsite(){ }
    virtual void ReportCancel(void);
    virtual void OnComplete();

};


//-------------------------------------------
// geom Import Site
//-------------------------------------------
class ATL_NO_VTABLE ImportGeomSite : public IImportSite
{
  public:
    ImportGeomSite(LPSTR pszPath,
                   CRImportSitePtr site,
                   IBindHost * bh,
                   bool bAsync,
                   Bvr bvr,
                   Bvr ev = NULL,
                   Bvr progress = NULL)
    : IImportSite(pszPath,site,bh,bAsync,ev,progress),
      m_bvr(bvr)
    {
        SetImportOnBvr(this,m_bvr);
    }

    ~ImportGeomSite(){
    }

    virtual void ReportCancel(void);
    virtual void OnComplete();
    virtual void OnError(bool bMarkFailed = true);
    virtual bool fBvrIsDying(Bvr deadBvr);
  protected:
    Bvr m_bvr;
};


#if INCLUDE_VRML
//-------------------------------------------
// wrl Import Site
//-------------------------------------------
class ImportWrlSite : public ImportGeomSite
{
  public:
    ImportWrlSite(LPSTR pszPath,
                  CRImportSitePtr site,
                  IBindHost * bh,
                  bool bAsync,
                  Bvr bvr,
                  Bvr ev = NULL,
                  Bvr progress = NULL)
    : ImportGeomSite(pszPath,site,bh,bAsync,bvr,ev,progress)
    {
    }

    ~ImportWrlSite(){
    }

    virtual void ReportCancel(void);
    virtual void OnComplete();
};
#endif

//-------------------------------------------
// x Import Site
//-------------------------------------------
class ImportXSite : public ImportGeomSite
{
  public:
    ImportXSite(LPSTR pszPath,
                CRImportSitePtr site,
                IBindHost * bh,
                bool bAsync,
                Bvr bvr,
                Bvr ev = NULL,
                Bvr progress = NULL,
                bool wrap = false,
                TextureWrapInfo *pWrapInfo = NULL,
                bool v1Compatible = true)
    : ImportGeomSite(pszPath,site,bh,bAsync,bvr,ev,progress),
      _v1Compatible (v1Compatible)
    {
        if (pWrapInfo) {

            // If we have wrap information, then we look at the wrap flag to
            // determine if it's valid to apply, and if so we copy the data.
            // All wrapped (valid or not) geometry is imported properly (this
            // is incompatible with version 1 of DA).

            _wrap = wrap;

            if (wrap) {
                _wrapInfo = *pWrapInfo;
            }

        } else {

            // If we have no wrap information, then this is the legacy
            // unwrapped geometry import code, and we need to maintain
            // backwards compatible with a bug in version 1 of DA.

            _wrap = false;
        }
    }

    ~ImportXSite(){
    }

    virtual void ReportCancel(void);
    virtual void OnComplete();

  private:
      bool _wrap;
      bool _v1Compatible;
      TextureWrapInfo _wrapInfo;
};


#endif  // _IMPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\import.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

   This module implements all functionality associated w/ 
   importing media. 

*******************************************************************************/

#include "headers.h"
#include "import.h"
#include "backend/jaxaimpl.h"

#define MSG_DOWNLOAD 0x01
#define MSG_FINISHLOADING 0x02

// Cannot assume static initialization from C runtime - use module
// initialization mechanism

list<IImportSite *> * IImportSite::s_pSitelist = NULL;
CritSect * IImportSite::s_pCS = NULL;
char IImportSite::s_Fmt[100];
ImportThread * IImportSite::s_thread = NULL;
long dwImportId = 0;

const int IImportSite::LOAD_OK = 0;
const int IImportSite::LOAD_FAILED = -1;

//-------------------------------------------------------------------------
//  Base import site
//--------------------------------------------------------------------------
IImportSite::IImportSite(char * pszPath,
                         CRImportSitePtr site,
                         IBindHost * bh,
                         bool bAsync,
                         Bvr ev,
                         Bvr progress,
                         Bvr size)
: m_ev(ev),
  m_progress(progress),
  m_size(size),
  m_lastProgress(0),
  m_fReportedError(false),
  m_bSetSize(false),
  m_cRef(1), // always start refcount at 1
  m_bindhost(bh),
  m_site(site),
  m_pszPath(NULL),
  m_bAsync(bAsync),
  m_bQueued(false),
  m_bImporting(false),
  m_ImportPrio(0),
  m_fAllBvrsDead(false),
  m_bCanceled(false),
#if _DEBUG
  dwconsttime(timeGetTime()),
  dwqueuetime(0),
  dwstarttime(0),
  dwfirstProgtime(0),
  dwCompletetime(0),
#endif
   _cachePath(NULL)
{
    m_pszPath = CopyString(pszPath);

    // register the import site with the bvrs.  all derived classes must do
    // this for their contained bvrs so the callbacks will work...
    SetImportOnEvent(this,m_ev);
    SetImportOnBvr(this,m_progress);
    SetImportOnBvr(this,m_size);

    // put this pointer on the list so we can track it
    // if we don't have a crit section pointer, we are in shutdown...
    if (s_pCS) {
        CritSectGrabber csg(*s_pCS);
        m_id = ++dwImportId;
        AddRef();
        s_pSitelist->push_back(this);
    } else {
        m_id = ++dwImportId;
    }

    if (m_site)
    {
        m_site->OnImportCreate(m_id, m_bAsync);
    }
}


IImportSite::~IImportSite()
{
    if (m_site)
    {
        m_site->OnImportStop(m_id);
    }
    
    delete m_pszPath;
    delete  _cachePath;

    TraceTag((tagImport, "~IImportSite --- Done,"));
}


void
IImportSite::SetCachePath(char *path)
{
    if(!_cachePath) { // only bother setting path once
        int length = lstrlen(path) + 1; // length including terminator
        _cachePath = NEW char[length];
        memmove(_cachePath, path, length); // no crt
    }
}


void
IImportSite::SetEvent(Bvr event)
{
    Assert(m_ev == NULL);
    m_ev = event;
    SetImportOnEvent(this,m_ev);
}


void
IImportSite::SetProgress(Bvr progress)
{
    Assert(m_progress == NULL);
    m_progress = progress;
    SetImportOnBvr(this,m_progress);
    
}


void
IImportSite::SetSize(Bvr size)
{
    Assert(m_size == NULL);
    m_size = size;
    SetImportOnBvr(this,m_size);
}


void
IImportSite::OnStartLoading()
{
}


void
IImportSite::OnProgress(ULONG ulProgress,
                        ULONG ulProgressMax)
{
    CritSectGrabber csg(m_CS);
    {
#ifdef _DEBUG
        if (dwfirstProgtime == 0)
            dwfirstProgtime = timeGetTime();
#endif
        DynamicHeapPusher dhp(GetGCHeap()) ;
        
        if (ulProgressMax != 0) {
            GC_CREATE_BEGIN;                                                        
            // Set the size if it has not been set yet
            if (!m_bSetSize && fBvrIsValid(m_size)) {
                SwitchTo(m_size,
                         NumToBvr((double) ulProgressMax),
                         true,
                         SW_FINAL);
                m_bSetSize = true ;
            }

            UpdateProgress(((double) ulProgress) /
                           ((double) ulProgressMax)) ;

            GC_CREATE_END;
        }
    }
#if _DEBUG
    if (ulProgressMax==0)
       TraceTag((tagImport, "percent complete = unknown"));
    else
       TraceTag((tagImport, "percent complete = %i",(ulProgress/ulProgressMax)*100));
#endif
}


void
IImportSite::OnSerializeFinish_helper2()
{
    // IMPORTANT!
    // This should look almost identical to srvprim.h:PRECODE
        
    CritSectGrabber csg(m_CS);
    GC_CREATE_BEGIN;                                                        
    OnComplete() ;
    if (fBvrIsValid(m_ev))
        SetImportEvent(m_ev, LOAD_OK) ;
    UpdateProgress(1,true) ;
    GC_CREATE_END;
}

void
IImportSite::OnSerializeFinish_helper()
{
    __try {
        OnSerializeFinish_helper2();
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        OnError();
    }    
}

void
IImportSite::OnSerializeFinish()
{
    TraceTag((tagImport, "ImportSite::OnSerializeFinish for %s", m_pszPath));

    // Only do this if there were no errors
    if (!m_fReportedError) {
        {
            // just for debug, we should always get one allocated.
            if (m_site) {
                char szStatus[INTERNET_MAX_URL_LENGTH + sizeof(s_Fmt)];
                wsprintf(szStatus, s_Fmt, m_pszPath);
        
                USES_CONVERSION;
                m_site->SetStatusText(m_id,A2W(szStatus));
            }
        }

        DynamicHeapPusher dhp(GetGCHeap()) ;

        OnSerializeFinish_helper();

        // Indicate the import is done ASAP
        if (m_site) {
            m_site->OnImportStop(m_id);
            m_site.Release();
        }
    }
}


// just a place holder so all the code looks the same
// every site that knows about a bvr that must be signaled should do it here
// and then call its base class OnComplete
void IImportSite::OnComplete()
{
}

void
IImportSite::OnError(bool bMarkFailed)
{
    HRESULT hr = DAGetLastError();
    LPCWSTR sz = DAGetLastErrorString();
    
    //external user message from szPath; only report once.
    if (!m_fReportedError && m_site) {
        m_site->ReportError(m_id,hr,sz);
        m_fReportedError=true;
    }

    // Set this to true even if there isn't a site, since
    // OnSerializeFinish will look at it.
    m_fReportedError = true;

    GC_CREATE_BEGIN;                                                        
    if (fBvrIsValid(m_ev))
        SetImportEvent(m_ev, LOAD_FAILED) ;
    GC_CREATE_END;
    
    // Indicate the import is done ASAP
    if (m_site) {
        m_site->OnImportStop(m_id);
        m_site.Release();
    }
}

#define PROGRESS_INC 0.0001
#define MAX_PROGRESS 0.999999

// !! Assumes the create lock and heap are already pushed

void
IImportSite::UpdateProgress(double num, bool bDone)
{
    CritSectGrabber csg(m_CS);
    if (fBvrIsValid(m_progress)) {
#if 0
        if (num < 0) {
            num = 0 ;
        } else if (bDone) {
            num = 1 ;
        } else {
            if (num > MAX_PROGRESS) num = MAX_PROGRESS ;
            if (num < (m_lastProgress + PROGRESS_INC))
                return ;
        }
#endif

        m_lastProgress = num ;

        SwitchTo(m_progress,NumToBvr(num),true,bDone?SW_FINAL:SW_DEFAULT);
    }
}

void IImportSite::Import_helper(LPWSTR &pwszUrl)
{
    HRESULT hr;
    int i;
    
    DAComPtr<IBindStatusCallback> pbsc(NEW CImportBindStatusCallback(this),false);
    if (!pbsc)
        RaiseException_UserError (E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY);
    
    i =  MultiByteToWideChar(CP_ACP, 0, GetPath(), -1, NULL, 0);
    Assert(i > 0);
    pwszUrl = THROWING_ARRAY_ALLOCATOR(WCHAR, i * sizeof(WCHAR));
    MultiByteToWideChar(CP_ACP, 0, GetPath(), -1, pwszUrl, i);
    pwszUrl[i - 1] = 0;
    
    CComPtr<IMoniker> _pmk;
    CComPtr<IStream> _pStream;
    if ( m_bindhost ) {  //coordinate moniker create & bind through container's IBindHost

        hr=THR(m_bindhost->CreateMoniker(pwszUrl,NULL,&_pmk,0));
        if (FAILED(hr)) {
            RaiseException_UserError (hr, IDS_ERR_FILE_NOT_FOUND, GetPath());
        }

        hr=THR(m_bindhost->MonikerBindToStorage(_pmk,NULL,pbsc,IID_IStream,(void**)&_pStream));    
        if (FAILED(hr)) {
            RaiseException_UserError (hr, IDS_ERR_FILE_NOT_FOUND, GetPath());
        }
    }
    else {  //no bind host
        CComPtr<IBindCtx> _pbc;

        hr=THR(CreateAsyncBindCtx(0,pbsc,NULL,&_pbc));
        if (FAILED(hr)) {
            RaiseException_UserError (hr, IDS_ERR_FILE_NOT_FOUND, GetPath());
        }

        hr=THR(CreateURLMoniker(NULL,pwszUrl, &_pmk));
        if (FAILED(hr)) {
            RaiseException_UserError (hr, IDS_ERR_FILE_NOT_FOUND, GetPath());
        }

        hr=THR(_pbc->RegisterObjectParam(SZ_ASYNC_CALLEE,_pmk));
        if (FAILED(hr)) {
            RaiseException_UserError (hr, IDS_ERR_FILE_NOT_FOUND, GetPath());
        }

        hr=THR(_pmk->BindToStorage(_pbc,NULL,IID_IStream,(void**)&_pStream));
        if (FAILED(hr)) {
            RaiseException_UserError (hr, IDS_ERR_FILE_NOT_FOUND, GetPath());
        }
    }
}

HRESULT
IImportSite::Import()
{
    LPWSTR pwszUrl=NULL;
    HRESULT ret = S_OK;
    
#ifdef _DEBUG
    dwstarttime = timeGetTime();
#endif
    
    __try {
        
        Import_helper( pwszUrl );
        
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {

        ret = DAGetLastError();
        OnError();
        CompleteImport();
        
    }

    delete pwszUrl;
    return ret;
}

// set the state of the import site because it is starting an import
void
IImportSite::StartingImport()
{
    Assert(!m_bImporting);
    m_bImporting = true;

    // Indicate the import is starting
    if (m_site) {
        m_site->OnImportStart(m_id);
    }
}

// set the state of the import site because it is done importing
void
IImportSite::EndingImport()
{
    Assert(m_bImporting);
    // set not queued so we won't try to restart the import
    m_bQueued = false;
    // reset the imporing flag so we can start another import or
    // remove this one from the queue
    m_bImporting = false;
}
// set the state so the import site is able to be imported
HRESULT
IImportSite::QueueImport()
{
    Assert(!m_bQueued);
    // mark this site as ready to import
    m_bQueued = true;
#ifdef _DEBUG
    dwqueuetime = timeGetTime();
#endif
    // try and start an import
    StartAnImport();
    // tell the world we are happy
    return S_OK;
}

// do all the housekeeping for when and import is complete
HRESULT
IImportSite::CompleteImport()
{
    // ture off the importing flag so we can remove it from the queue
    EndingImport();
    // remove this entry from the queue
    if (!DeQueueImport()) {
        Assert(false);
    }

    // We no longer need the IStream so to avoid file locks we release it
    m_IStream.Release();

    // try and start a NEW import
    StartAnImport();
    // tell the world we are happy
#ifdef _DEBUG
    dwCompletetime = timeGetTime();
    TraceTag((tagImport, "IImportSite::CompleteImport, %s",m_pszPath));
    TraceTag((tagImport, "Const time      = %lx  delta from const",dwconsttime));
    TraceTag((tagImport, "Queue time      = %lx   %lu ms",dwqueuetime, dwqueuetime-dwconsttime));
    TraceTag((tagImport, "Start time      = %lx   %lu ms",dwstarttime, dwstarttime-dwconsttime));
    TraceTag((tagImport, "First Prog time = %lx   %lu ms",dwfirstProgtime, dwfirstProgtime-dwconsttime));
    TraceTag((tagImport, "Complete time   = %lx   %lu ms",dwCompletetime, dwCompletetime-dwconsttime));
#endif
    return S_OK;
}

// remove an import site from the import queue
bool
IImportSite::DeQueueImport()
{
    bool bret = false;
    TraceTag((tagImport, "DequeueImport -- site=%lx",this));
    // remove the site from our import list if it's import
    // is not in progress
    if (!IsImporting()) {
        CritSectGrabber csg(*s_pCS);
        TraceTag((tagImport, "DequeueImport -- removing site from list=%lx",this));
        
        // Make sure it is in the list before we Release it
        list<IImportSite *>::iterator i = s_pSitelist->begin() ;
        while (i != s_pSitelist->end()) {
            // we add refed it when we added it to the list, so release it now
            if ((*i) == this) 
                Release();
            i++;
        }
        
        s_pSitelist->remove(this);
        
        bret = true;
    }
    return bret;
}

// find an import on the list to start its import
// if we are not doing too many imports already
HRESULT
IImportSite::StartAnImport()
{
    IImportSite * pStartMe = NULL;
    float currentprio = -1;
    // if we are not busy yet, start another one.
    if(SimImports() < _SimImports) {
        {
            CritSectGrabber csg(*s_pCS);
            list<IImportSite *>::iterator i = s_pSitelist->begin() ;

            // go through the list and start the highest prio import we find
            // if they all are the same, we start the first
            while (i != s_pSitelist->end()) {
                if(!(*i)->IsImporting() &&
                    (*i)->IsQueued() &&
                    (*i)->GetImportPrio() > currentprio) {
                        pStartMe = *i;
                        currentprio = pStartMe->GetImportPrio();
                }
                i++;
            }
        }
        // if we found one, start it
        if (pStartMe) {
            pStartMe->StartingImport();
            pStartMe->Import();
        }
    }
    return S_OK;
}

// return the number of sites importing at this time
int
IImportSite::SimImports()
{
    // count the number of imports in progress
    CritSectGrabber csg(*s_pCS);
    int count = 0;
    list<IImportSite *>::iterator i = s_pSitelist->begin() ;
    
    while (i != s_pSitelist->end()) {
        if((*i)->IsImporting())
            count++;
        i++;
    }
    return count;
}

void
IImportSite::CancelImport()
{
    if (!m_bCanceled) {
        m_bCanceled = true;
        DeQueueImport();
        if (!m_bAsync)
            ReportCancel();
    }
}

void IImportSite::vBvrIsDying(Bvr deadBvr)

{
    if (!AllBvrsDead()) {
        CritSectGrabber csg(m_CS);
        if (fBvrIsDying(deadBvr))
        {
            SetAllBvrsDead();
            // cancel the import if nobody cares anymore
            CancelImport();
        }
    }
}

// is is up to the derived classes to call this
bool IImportSite::fBvrIsDying(Bvr deadBvr)
{
    if (deadBvr == m_ev)
    {
        m_ev = NULL;
    }
    else if (deadBvr == m_progress)
    {
        m_progress = NULL;
    }
    else if (deadBvr == m_size)
    {
        m_size = NULL;
    }
    if (m_ev || m_progress || m_size)
        return FALSE;
    else
        return TRUE;
}

void
IImportSite::StartDownloading()
{
    s_thread->AddImport(this);
}

void
IImportSite::CompleteDownloading()
{
    if (!s_thread->FinishImport(this)) {
        TraceTag((tagImport,
                  "CompleteDownload failed for import - %s", m_pszPath));

        DASetLastError(E_FAIL, IDS_ERR_FILE_NOT_FOUND, m_pszPath);
        OnError();
    }
}

HRESULT
StreamableImportSite::Import()
{
    if(GetStreaming()) { // do spacey magic to spoof import for streaming
        OnProgress((ULONG)100, (ULONG)100); // spoof an OnProgress complete

        // spoof completion the most std way (causes an OnComplete())
        CompleteDownloading();

    }
    else {
        IImportSite::Import();              // do the std urlmon based import
    }

    return S_OK;
}


//-------------------------------------------------------
//  Import thread
//-------------------------------------------------------

void
ImportThread::AddImport(IImportSite* pIIS)
{
    StartThread();
    
    pIIS->AddRef();
    if (!SendAsyncMsg(MSG_DOWNLOAD, 1, (DWORD_PTR) pIIS)) {
        pIIS->Release();
        RaiseException_InternalError("Unable to schedule import");
    }
}

bool
ImportThread::FinishImport(IImportSite* pIIS)
{
    Assert (IsStarted());
    
    pIIS->AddRef();
    if (!SendAsyncMsg(MSG_FINISHLOADING, 1, (DWORD_PTR) pIIS)) {
        pIIS->Release();
        return false;
    }

    return true;
}

void
ImportThread::StartThread()
{
    CritSectGrabber csg(_cs);
    if (!Start())
        RaiseException_InternalError("Unable to start import thread");
}

void
ImportThread::StopThread()
{
    CritSectGrabber csg(_cs);
    if (!Stop())
        RaiseException_InternalError("Unable to stop import thread");
}

void
ImportThread::ProcessMsg(DWORD dwMsg,
                         DWORD dwNumParams,
                         DWORD_PTR dwParams[])
{
    switch (dwMsg) {
      case MSG_DOWNLOAD:
        Assert (dwNumParams == 1);
        // queue the import, will also start the next one
        // if we are not maxed already
        ((IImportSite*)dwParams[0])->QueueImport();
        ((IImportSite*)dwParams[0])->Release();
        break;
      case MSG_FINISHLOADING:
        Assert (dwNumParams == 1);
        ((IImportSite*)dwParams[0])->OnSerializeFinish();
        // this is so the import queue can start another import
        ((IImportSite*)dwParams[0])->CompleteImport();
        ((IImportSite*)dwParams[0])->Release();
        break;
      default:
        Assert (false && "Invalid message sent to import thread");
    }
}

void
StartImportThread()
{
    IImportSite::s_thread->StartThread();
}

void
StopImportThread()
{
    IImportSite::s_thread->StopThread();

    CritSectGrabber csg(*IImportSite::s_pCS);
    
    // Make sure it is in the list before we Release it
    list<IImportSite *>::iterator i = IImportSite::s_pSitelist->begin() ;
    while (i != IImportSite::s_pSitelist->end()) {
        // we add refed it when we added it to the list, so release it now
        (*i)->CancelImport();
        (*i)->Release();
        i++;
    }
    
    IImportSite::s_pSitelist->clear();
}

//+-------------------------------------------------------------------------
//
//  CImportBindStatusCallback implementation
//
//  Generic implementation of IBindStatusCallback.  This is the root
//  class.
//
//--------------------------------------------------------------------------
CImportBindStatusCallback::CImportBindStatusCallback(IImportSite* pIIS) :
m_pIIS(pIIS)
{
    m_cRef = 1;
    m_szCacheFileName[0] = NULL;

    if (m_pIIS) m_pIIS->AddRef();
}


CImportBindStatusCallback::~CImportBindStatusCallback(void)
{
    RELEASE(m_pIIS);
}


STDMETHODIMP
CImportBindStatusCallback::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown)) {
        *ppv = (IUnknown *) (IBindStatusCallback *) this;
    }
    else if (IsEqualIID(riid, IID_IBindStatusCallback)) {
        *ppv = (IBindStatusCallback *) this;
    }
    else if (IsEqualIID(riid, IID_IAuthenticate)) {
        TraceTag((tagImport, "CImportBindStatusCallback::QI for IAuthenticate"));
        *ppv = (IAuthenticate *) this;
    }
    else {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG)
    CImportBindStatusCallback::AddRef(void)
{
    return InterlockedIncrement((long *)&m_cRef);
}


STDMETHODIMP_(ULONG)
    CImportBindStatusCallback::Release(void)
{
    ULONG ul = InterlockedDecrement((long *)&m_cRef) ;

    if (ul == 0) delete this;

    return ul;
}


STDMETHODIMP
CImportBindStatusCallback::GetPriority(LONG* pnPriority)
{
    return S_OK;
}


STDMETHODIMP
CImportBindStatusCallback::OnLowResource(DWORD dwReserved)
{
    return S_OK;
}


STDMETHODIMP
CImportBindStatusCallback::OnProgress(ULONG ulProgress,  ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
{
    if (m_pIIS->IsCanceled()) {
        if (m_pbinding != NULL) {
            m_pbinding->Abort();
        }
        else {
            // if no binding, cant cancel...
            Assert(0);
        }
    }
    else {
        if (ulStatusCode==BINDSTATUS_CACHEFILENAMEAVAILABLE) {
            if (WideCharToMultiByte(CP_ACP, 0, szStatusText, 
                lstrlenW(szStatusText)+1, m_szCacheFileName, MAX_PATH, 
                NULL, NULL)==0) {
                m_szCacheFileName[0] = NULL;
            }
            m_pIIS->SetCachePath(m_szCacheFileName); // stash the filename
            TraceTag((tagImport, "OnProcess:  cache file name obtained(%s)",m_szCacheFileName));
        }

        else if (ulStatusCode==BINDSTATUS_BEGINDOWNLOADDATA ||
                 ulStatusCode==BINDSTATUS_DOWNLOADINGDATA ||
                 ulStatusCode==BINDSTATUS_ENDDOWNLOADDATA) {

            m_pIIS->OnProgress(ulProgress,ulProgressMax);
        }
    }

    return S_OK;
}


STDMETHODIMP
CImportBindStatusCallback::OnStartBinding(DWORD dwReserved, IBinding* pbinding)
{
    m_pbinding = pbinding;

    if (m_pIIS)
        m_pIIS->OnStartLoading();

    return S_OK;
}


STDMETHODIMP
CImportBindStatusCallback::OnStopBinding(HRESULT hrStatus, LPCWSTR szError)
{
    Assert(m_pIIS);

    // Release the binding so that synchronous operations on the url
    // will work
    m_pbinding.Release();

    if (hrStatus) {
        DASetLastError(hrStatus, IDS_ERR_FILE_NOT_FOUND, m_pIIS->GetPath());
        m_pIIS->OnError();
    }
    
    if (m_pIIS) 
        m_pIIS->CompleteDownloading();

    // We no longer need it - free it now
    RELEASE(m_pIIS);
    
    return S_OK;
}


STDMETHODIMP
CImportBindStatusCallback::GetBindInfo(DWORD * pgrfBINDF, BINDINFO * pbindInfo)
{
    *pgrfBINDF=BINDF_ASYNCHRONOUS;
    
    if (StrCmpNIA("res://", m_pIIS->GetPath(), 6) == 0)
        *pgrfBINDF |= BINDF_PULLDATA;

    pbindInfo->cbSize = sizeof(BINDINFO);
    pbindInfo->szExtraInfo = NULL;
    memset(&pbindInfo->stgmedData, 0, sizeof(STGMEDIUM));
    pbindInfo->grfBindInfoF = 0;
    pbindInfo->dwBindVerb = BINDVERB_GET;
    pbindInfo->szCustomVerb = NULL;
    return S_OK;
}


STDMETHODIMP
CImportBindStatusCallback::OnDataAvailable(DWORD grfBSCF,DWORD dwSize, FORMATETC * pfmtetc,
                                           STGMEDIUM * pstgmed)
{
    if (BSCF_FIRSTDATANOTIFICATION & grfBSCF) {
        if (!m_pIIS->m_IStream && pstgmed->tymed == TYMED_ISTREAM) {
            m_pIIS->m_IStream=pstgmed->pstm;
            TraceTag((tagImport, "IBSC::OnDataAvailable: addref on pstgmed %s",m_szCacheFileName));
        }
    }

    return S_OK;
}


STDMETHODIMP
CImportBindStatusCallback::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    TraceTag((tagImport, "IBSC::OnObjectAvailable."));
    return S_OK;
}


STDMETHODIMP
CImportBindStatusCallback::Authenticate(HWND * phwnd,
                                        LPWSTR * pwszUser,
                                        LPWSTR * pwszPassword)
{
    if ((phwnd == NULL) || (pwszUser == NULL) || (pwszPassword == NULL)) {
        return E_INVALIDARG;
    }

    *phwnd = GetDesktopWindow();
    *pwszUser = NULL;
    *pwszPassword = NULL;

    TraceTag((tagImport, "-- hwnd=%lx, user=%ls, password=%ls", *phwnd,*pwszUser,  *pwszPassword));

    return S_OK;
}

// =========================================
// Initialization
// =========================================
void
InitializeModule_Import()
{
    IImportSite::s_pSitelist = NEW list<IImportSite *>;
    IImportSite::s_pCS = NEW CritSect;
    LoadString(hInst, IDS_DOWNLOAD_FILE, IImportSite::s_Fmt, sizeof(IImportSite::s_Fmt));
    IImportSite::s_thread = NEW ImportThread;
}

void
DeinitializeModule_Import(bool bShutdown)
{
    // Do not grab critsect since the thread may have been terminated
    // and never released the critsect.  Also there is no need - we
    // are terminating and all other threads are dead by now.
    
    delete IImportSite::s_thread;
    IImportSite::s_thread = NULL;

    delete IImportSite::s_pSitelist;
    IImportSite::s_pSitelist = NULL;

    delete IImportSite::s_pCS;
    IImportSite::s_pCS = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\oleobj.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Ole Object initialization

Revision:

--*/

#include "headers.h"

#undef map
#undef SubclassWindow

// Put this here to initialize all the ATL stuff

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>

DeclareTag(tagATL, "ATL", "Trace Messages");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\impprim.h ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    import primitive header

Revision:

--*/

#ifndef _IMPPRIM_H_
#define _IMPPRIM_H_

Bvr AnimImgBvr(Image **i, int count, int *delays, int loop);
Sound      *ReadMidiFileWithLength(char *pathname,Real *length); // out argument
LeafSound  *ReadMIDIfileForImport(char *pathname, double *length);
LeafSound  *ReadQuartzAudioForImport(char *pathname, double *length);
Bvr         ReadQuartzVideoForImport(char *pathname, double *length);
LeafSound  *ReadQuartzStreamForImport(char *pathname); // XXX old remove
void        ReadAVmovieForImport(char *simplePathname,
                                 LeafSound **sound,
                                 Bvr *imageBvr,
                                 double *length);

#endif  // _IMPPRIM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\impsound.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

   This module implements all functionality associated w/ 
   importing image media. 

*******************************************************************************/
#include "headers.h"
#include "import.h"
#include "context.h"
#include "include/appelles/axaprims.h"
#include "include/appelles/readobj.h"
#include "privinc/stquartz.h"
#include "privinc/soundi.h"
#include "privinc/bufferl.h"
#include "privinc/movieimg.h"
#include "impprim.h"
#include "backend/bvr.h"  // EndBvr()
#include "backend/sndbvr.h"

//-------------------------------------------------------------------------
//  PCM import site
//--------------------------------------------------------------------------
void ImportPCMsite::OnComplete_helper(
    Sound * &sound, // ref to ptr
    Bvr &soundBvr,
    double &length,
    bool &nonFatal)
{
    // pick pathname 'raw' url for streaming or urlmon download path
    char *pathname = GetStreaming() ? m_pszPath : GetCachePath();
    Assert(pathname);

    QuartzAudioStream *quartzStream = NEW QuartzAudioStream(pathname);

    // XXX RobinSp says we can't count on GetDuration being accurate!
    double  seconds = quartzStream->GetDuration();  // get the duration
    long soundBytes = quartzStream->pcm.SecondsToBytes(seconds); // determine size
    if(!soundBytes) {
        nonFatal = true;
        RaiseException_InternalError("empty audio file"); // this is silence...
    }

    quartzStream->pcm.SetNumberBytes(soundBytes);

    bool useStaticWaveOnly = false;

    LeafSound *snd;
    StreamQuartzPCM *pcmSnd = NULL;

    if (soundBytes > STREAM_THREASHOLD) {
        // stream the sound
        
        TraceTag((tagSoundLoads, "Streaming %s (%d)", pathname, soundBytes));
        sound = snd = pcmSnd = NEW StreamQuartzPCM(pathname);
        pcmSnd->_pcm.SetNumberBytes(soundBytes);
        length = seconds;
    }
    else {  // its small.  Statically load it into a dsound buffer!
        // add a fudge factor to combat inaccuracy in GetDuration!
        double fudgedSeconds = seconds * 1.5;
        long bytesToRequest  = 
            quartzStream->pcm.SecondsToBytes(fudgedSeconds);
        long framesToRequest = quartzStream->pcm.SecondsToFrames(fudgedSeconds);

        unsigned char *buffer = (unsigned char *)
            StoreAllocate(GetSystemHeap(), bytesToRequest);
        
        if(!buffer) {
#if _MEMORY_TRACKING
            OutputDebugString("\nDirectAnimation: Out Of Memory\n");
            F3DebugBreak();
#endif
            TraceTag((tagSoundErrors, "WavSoundClass buffer malloc failed"));
            RaiseException_OutOfMemory("WavSoundClass buffer malloc failed", 
                                       bytesToRequest);
        }

        // do a blocking read
        long actualFrames = 
            quartzStream->ReadFrames(framesToRequest, buffer, true);
        Assert(actualFrames);

        // XXX we should somehow cancel the import if we fail to read!

        quartzStream->pcm.SetNumberFrames(actualFrames); // set our pcm info
        length = quartzStream->pcm.FramesToSeconds(actualFrames);

        Assert(actualFrames < framesToRequest); // fudge factor large enough?
        TraceTag((tagSoundLoads, "Static ld %s quartz:%d, actual:%d (err:%d)",
                  pathname, soundBytes, quartzStream->pcm.FramesToBytes(actualFrames), 
                  quartzStream->pcm.FramesToBytes(actualFrames)-soundBytes));

        // NOTE: StaticWaveSound is responsible for deleting buffer
        sound = snd = NEW StaticWaveSound(buffer, &(quartzStream->pcm));

        delete quartzStream;
        quartzStream = NULL; // no need to cache the quartzStream for staticSnd
    }

    if(quartzStream) {
        // add qstream to context sound cache list to be recycled later!
        QuartzBufferElement *bufferElement = 
            NEW QuartzBufferElement(pcmSnd, quartzStream, NULL); // NULL path

        // hold IStream handle to keep file from being purged by ie
        bufferElement->SetFile(GetStream()); 

        SoundBufferCache *soundCache = 
            GetCurrentContext().GetSoundBufferCache();
        // allow aging: bufferElement->SetNonAging();  // dissable aging for imports
        soundCache->AddBuffer(sound, bufferElement);
    }

    soundBvr = SoundBvr(snd);
}


void ImportPCMsite::OnComplete()
{
    TraceTag((tagImport, "ImportPCMsite::OnComplete for %s", m_pszPath));
    Bvr soundBvr;
    double length = 0.0;
    bool nonFatal = false;

    __try {

        Sound *sound;
        OnComplete_helper( sound, soundBvr, length, nonFatal );
        
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        if(!nonFatal) {
            RETHROW;
        }
        soundBvr = ConstBvr(silence);
    }

    if(fBvrIsValid(m_bvr))
        SwitchOnce(m_bvr, soundBvr);

    if(fBvrIsValid(m_lengthBvr))
        SwitchOnce(m_lengthBvr, NumToBvr(length));

    ImportSndsite::OnComplete();
}


bool ImportPCMsite::fBvrIsDying(Bvr deadBvr)
{
    bool fBase = ImportSndsite::fBvrIsDying(deadBvr);
    if (deadBvr == m_bvrNum) {
        m_bvrNum = NULL;
    }
    if (m_bvrNum)
        return false;
    else
        return fBase;
}

void ImportPCMsite::ReportCancel(void)
{
    ImportSndsite::ReportCancel();
}
    
//-------------------------------------------------------------------------
//  Mid import site
//--------------------------------------------------------------------------
void ImportMIDIsite::OnComplete()
{
    TraceTag((tagImport, "ImportMIDIsite::OnComplete for %s", m_pszPath));

    double length;
    
    // pick pathname 'raw' url for streaming or urlmon download path
    char *pathname = GetStreaming() ? m_pszPath : GetCachePath();
    Assert(pathname);
    LeafSound *sound = ReadMIDIfileForImport(pathname, &length);
    
    if(fBvrIsValid(m_bvr))
        SwitchOnce(m_bvr, SoundBvr(sound));
    if(fBvrIsValid(m_lengthBvr))
        SwitchOnce(m_lengthBvr, NumToBvr(length));

    ImportSndsite::OnComplete();
}


void ImportMIDIsite::ReportCancel(void)
{
    ImportSndsite::ReportCancel();
}
    
//-------------------------------------------------------------------------
//  Common Snd import site
//--------------------------------------------------------------------------
void ImportSndsite::OnError(bool bMarkFailed)
{
    HRESULT hr = S_OK; // all snd import errs are handled (was: DAGetLastError)
    LPCWSTR sz = DAGetLastErrorString();
    
    if (bMarkFailed && fBvrIsValid(m_bvr))
        ImportSignal(m_bvr, hr, sz);

    StreamableImportSite::OnError(bMarkFailed);
}
    
void ImportSndsite::ReportCancel(void)
{
    if (fBvrIsValid(m_bvr)) {
        char szCanceled[MAX_PATH];
        LoadString(hInst,IDS_ERR_ABORT,szCanceled,sizeof(szCanceled));
        ImportSignal(m_bvr, E_ABORT, szCanceled);
    }
    StreamableImportSite::ReportCancel();
}
    
bool ImportSndsite::fBvrIsDying(Bvr deadBvr)
{
    bool fBase = IImportSite::fBvrIsDying(deadBvr);
    if (deadBvr == m_bvr) {
        m_bvr = NULL;
    }
    else if (deadBvr == m_lengthBvr) {
        m_lengthBvr = NULL;
    }
    if (m_bvr || m_lengthBvr)
        return false;
    else
        return fBase;
}

void ImportSndsite::OnComplete()
{
    if(fBvrIsValid(m_bvr))
        ImportSignal(m_bvr);
    StreamableImportSite::OnComplete();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\pickq.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    // TODO: Should rename this file or merge into privinc/evenq.h

*******************************************************************************/


#ifndef _PICKQ_H
#define _PICKQ_H

#include "privinc/server.h"
#include "privinc/probe.h"

// Need comparison for constructing a map.  We don't really care what
// the results are, though...
typedef list<PickQData> PickEventQ;

typedef map< int, PickEventQ*, less<int> > PickMap;

class PickQ
{
  public:
    PickQ () ;
    ~PickQ () ;
    
    // This copies the data
    
    void Add (int eventId, PickQData & data) ;
    
    PickMap & GetCurrentPickMap() { return _pm ; }
    DynamicHeap & GetCurrentHeap () { return *_heap ; }

    void GatherPicks(Image* image, Time time, Time lastPollTime);
    
    BOOL CheckForPickEvent(int id, Time time, PickQData & result) ;

    void Reset(Time curTime, BOOL noLeftover);
    
  protected:
    PickMap _pm ;

    DynamicHeap * _heap;
    DynamicHeap * _heap1;
    DynamicHeap * _heap2;

    Time _heapSwitchTime;
} ;

#endif /* _PICKQ_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\primmth0.h ===
/*******************************************************************************
Copyright (c) 1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/

//
// DABoolean
//

class CDABooleanFactory;

class ATL_NO_VTABLE CDABoolean:
    public CBvrBase < IDABoolean,
                      &IID_IDABoolean>,
    public CComCoClass<CDABoolean, &CLSID_DABoolean>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDABoolean);

    DECLARE_CLASSFACTORY_EX(CDABooleanFactory);

    DECLARE_REGISTRY(CLSID_DABoolean,
                     LIBID ".DABoolean.1",
                     LIBID ".DABoolean",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDABoolean)
        COM_INTERFACE_ENTRY(IDABoolean)

        COM_INTERFACE_ENTRY2(IDABehavior,IDABoolean)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRBOOLEAN_TYPEID ; }
    const char * GetName () { return "DABoolean" ; }
    STDMETHOD(Extract) (VARIANT_BOOL * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDABoolean, &CLSID_DABoolean>::Error(str, IID_IDABoolean,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDABooleanCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDABooleanFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAGeometry
//

class CDAGeometryFactory;

class ATL_NO_VTABLE CDAGeometry:
    public CBvrBase < IDA3Geometry,
                      &IID_IDA3Geometry>,
    public CComCoClass<CDAGeometry, &CLSID_DAGeometry>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAGeometry);

    DECLARE_CLASSFACTORY_EX(CDAGeometryFactory);

    DECLARE_REGISTRY(CLSID_DAGeometry,
                     LIBID ".DAGeometry.1",
                     LIBID ".DAGeometry",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAGeometry)
        COM_INTERFACE_ENTRY(IDAGeometry)
        COM_INTERFACE_ENTRY(IDA2Geometry)
        COM_INTERFACE_ENTRY(IDA3Geometry)

        COM_INTERFACE_ENTRY2(IDABehavior,IDA3Geometry)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRGEOMETRY_TYPEID ; }
    const char * GetName () { return "DAGeometry" ; }
    STDMETHOD(RenderSound) (IDAMicrophone *  arg1, IDASound *  * ret);
    STDMETHOD(Pickable) (IDAPickableResult * * ret);
    STDMETHOD(PickableOccluded) (IDAPickableResult * * ret);
    STDMETHOD(AddPickData) (IUnknown * arg1, VARIANT_BOOL arg2, IDAGeometry *  * ret);
    STDMETHOD(Undetectable) (IDAGeometry *  * ret);
    STDMETHOD(EmissiveColor) (IDAColor *  arg0, IDAGeometry *  * ret);
    STDMETHOD(DiffuseColor) (IDAColor *  arg0, IDAGeometry *  * ret);
    STDMETHOD(SpecularColor) (IDAColor *  arg0, IDAGeometry *  * ret);
    STDMETHOD(SpecularExponent) (double arg0, IDAGeometry *  * ret);
    STDMETHOD(SpecularExponentAnim) (IDANumber *  arg0, IDAGeometry *  * ret);
    STDMETHOD(Texture) (IDAImage *  arg0, IDAGeometry *  * ret);
    STDMETHOD(Opacity) (double arg0, IDAGeometry *  * ret);
    STDMETHOD(OpacityAnim) (IDANumber *  arg0, IDAGeometry *  * ret);
    STDMETHOD(Transform) (IDATransform3 *  arg0, IDAGeometry *  * ret);
    STDMETHOD(Shadow) (IDAGeometry *  arg1, IDAPoint3 *  arg2, IDAVector3 *  arg3, IDAGeometry *  * ret);
    STDMETHOD(get_BoundingBox) (IDABbox3 *  * ret);
    STDMETHOD(Render) (IDACamera *  arg1, IDAImage *  * ret);
    STDMETHOD(LightColor) (IDAColor *  arg0, IDAGeometry *  * ret);
    STDMETHOD(LightRangeAnim) (IDANumber *  arg0, IDAGeometry *  * ret);
    STDMETHOD(LightRange) (double arg0, IDAGeometry *  * ret);
    STDMETHOD(LightAttenuationAnim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAGeometry *  * ret);
    STDMETHOD(LightAttenuation) (double arg0, double arg1, double arg2, IDAGeometry *  * ret);
    STDMETHOD(BlendTextureDiffuse) (IDABoolean *  arg1, IDAGeometry *  * ret);
    STDMETHOD(AmbientColor) (IDAColor *  arg0, IDAGeometry *  * ret);
    STDMETHOD(D3DRMTexture) (IUnknown * arg1, IDAGeometry *  * ret);
    STDMETHOD(ModelClip) (IDAPoint3 *  arg0, IDAVector3 *  arg1, IDAGeometry *  * ret);
    STDMETHOD(Lighting) (IDABoolean *  arg0, IDAGeometry *  * ret);
    STDMETHOD(TextureImage) (IDAImage *  arg0, IDAGeometry *  * ret);
    STDMETHOD(Billboard) (IDAVector3*, IDAGeometry**);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAGeometry, &CLSID_DAGeometry>::Error(str, IID_IDA3Geometry,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAGeometryCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAGeometryFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAMicrophone
//

class CDAMicrophoneFactory;

class ATL_NO_VTABLE CDAMicrophone:
    public CBvrBase < IDAMicrophone,
                      &IID_IDAMicrophone>,
    public CComCoClass<CDAMicrophone, &CLSID_DAMicrophone>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAMicrophone);

    DECLARE_CLASSFACTORY_EX(CDAMicrophoneFactory);

    DECLARE_REGISTRY(CLSID_DAMicrophone,
                     LIBID ".DAMicrophone.1",
                     LIBID ".DAMicrophone",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAMicrophone)
        COM_INTERFACE_ENTRY(IDAMicrophone)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAMicrophone)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRMICROPHONE_TYPEID ; }
    const char * GetName () { return "DAMicrophone" ; }
    STDMETHOD(Transform) (IDATransform3 *  arg0, IDAMicrophone *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAMicrophone, &CLSID_DAMicrophone>::Error(str, IID_IDAMicrophone,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAMicrophoneCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAMicrophoneFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAPath2
//

class CDAPath2Factory;

class ATL_NO_VTABLE CDAPath2:
    public CBvrBase < IDAPath2,
                      &IID_IDAPath2>,
    public CComCoClass<CDAPath2, &CLSID_DAPath2>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAPath2);

    DECLARE_CLASSFACTORY_EX(CDAPath2Factory);

    DECLARE_REGISTRY(CLSID_DAPath2,
                     LIBID ".DAPath2.1",
                     LIBID ".DAPath2",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAPath2)
        COM_INTERFACE_ENTRY(IDAPath2)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAPath2)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRPATH2_TYPEID ; }
    const char * GetName () { return "DAPath2" ; }
    STDMETHOD(Transform) (IDATransform2 *  arg0, IDAPath2 *  * ret);
    STDMETHOD(BoundingBox) (IDALineStyle *  arg0, IDABbox2 *  * ret);
    STDMETHOD(Fill) (IDALineStyle *  arg0, IDAImage *  arg1, IDAImage *  * ret);
    STDMETHOD(Draw) (IDALineStyle *  arg0, IDAImage *  * ret);
    STDMETHOD(Close) (IDAPath2 *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAPath2, &CLSID_DAPath2>::Error(str, IID_IDAPath2,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAPath2Create(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAPath2Factory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DASound
//

class CDASoundFactory;

class ATL_NO_VTABLE CDASound:
    public CBvrBase < IDASound,
                      &IID_IDASound>,
    public CComCoClass<CDASound, &CLSID_DASound>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDASound);

    DECLARE_CLASSFACTORY_EX(CDASoundFactory);

    DECLARE_REGISTRY(CLSID_DASound,
                     LIBID ".DASound.1",
                     LIBID ".DASound",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDASound)
        COM_INTERFACE_ENTRY(IDASound)

        COM_INTERFACE_ENTRY2(IDABehavior,IDASound)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRSOUND_TYPEID ; }
    const char * GetName () { return "DASound" ; }
    STDMETHOD(PhaseAnim) (IDANumber *  arg0, IDASound *  * ret);
    STDMETHOD(Phase) (double arg0, IDASound *  * ret);
    STDMETHOD(RateAnim) (IDANumber *  arg0, IDASound *  * ret);
    STDMETHOD(Rate) (double arg0, IDASound *  * ret);
    STDMETHOD(PanAnim) (IDANumber *  arg0, IDASound *  * ret);
    STDMETHOD(Pan) (double arg0, IDASound *  * ret);
    STDMETHOD(GainAnim) (IDANumber *  arg0, IDASound *  * ret);
    STDMETHOD(Gain) (double arg0, IDASound *  * ret);
    STDMETHOD(Loop) (IDASound *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDASound, &CLSID_DASound>::Error(str, IID_IDASound,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDASoundCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDASoundFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DATransform3
//

class CDATransform3Factory;

class ATL_NO_VTABLE CDATransform3:
    public CBvrBase < IDATransform3,
                      &IID_IDATransform3>,
    public CComCoClass<CDATransform3, &CLSID_DATransform3>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDATransform3);

    DECLARE_CLASSFACTORY_EX(CDATransform3Factory);

    DECLARE_REGISTRY(CLSID_DATransform3,
                     LIBID ".DATransform3.1",
                     LIBID ".DATransform3",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDATransform3)
        COM_INTERFACE_ENTRY(IDATransform3)

        COM_INTERFACE_ENTRY2(IDABehavior,IDATransform3)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRTRANSFORM3_TYPEID ; }
    const char * GetName () { return "DATransform3" ; }
    STDMETHOD(Inverse) (IDATransform3 *  * ret);
    STDMETHOD(get_IsSingular) (IDABoolean *  * ret);
    STDMETHOD(ParallelTransform2) (IDATransform2 *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDATransform3, &CLSID_DATransform3>::Error(str, IID_IDATransform3,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDATransform3Create(IDABehavior ** bvr);

class ATL_NO_VTABLE CDATransform3Factory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAFontStyle
//

class CDAFontStyleFactory;

class ATL_NO_VTABLE CDAFontStyle:
    public CBvrBase < IDA2FontStyle,
                      &IID_IDA2FontStyle>,
    public CComCoClass<CDAFontStyle, &CLSID_DAFontStyle>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAFontStyle);

    DECLARE_CLASSFACTORY_EX(CDAFontStyleFactory);

    DECLARE_REGISTRY(CLSID_DAFontStyle,
                     LIBID ".DAFontStyle.1",
                     LIBID ".DAFontStyle",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAFontStyle)
        COM_INTERFACE_ENTRY(IDAFontStyle)
        COM_INTERFACE_ENTRY(IDA2FontStyle)

        COM_INTERFACE_ENTRY2(IDABehavior,IDA2FontStyle)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRFONTSTYLE_TYPEID ; }
    const char * GetName () { return "DAFontStyle" ; }
    STDMETHOD(Bold) (IDAFontStyle *  * ret);
    STDMETHOD(Italic) (IDAFontStyle *  * ret);
    STDMETHOD(Underline) (IDAFontStyle *  * ret);
    STDMETHOD(Strikethrough) (IDAFontStyle *  * ret);
    STDMETHOD(AntiAliasing) (double arg0, IDAFontStyle *  * ret);
    STDMETHOD(Color) (IDAColor *  arg1, IDAFontStyle *  * ret);
    STDMETHOD(FamilyAnim) (IDAString *  arg1, IDAFontStyle *  * ret);
    STDMETHOD(Family) (BSTR arg1, IDAFontStyle *  * ret);
    STDMETHOD(SizeAnim) (IDANumber *  arg1, IDAFontStyle *  * ret);
    STDMETHOD(Size) (double arg1, IDAFontStyle *  * ret);
    STDMETHOD(Weight) (double arg1, IDAFontStyle *  * ret);
    STDMETHOD(WeightAnim) (IDANumber *  arg1, IDAFontStyle *  * ret);
    STDMETHOD(TransformCharacters) (IDATransform2 *  arg1, IDAFontStyle *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAFontStyle, &CLSID_DAFontStyle>::Error(str, IID_IDA2FontStyle,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAFontStyleCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAFontStyleFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAJoinStyle
//

class CDAJoinStyleFactory;

class ATL_NO_VTABLE CDAJoinStyle:
    public CBvrBase < IDAJoinStyle,
                      &IID_IDAJoinStyle>,
    public CComCoClass<CDAJoinStyle, &CLSID_DAJoinStyle>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAJoinStyle);

    DECLARE_CLASSFACTORY_EX(CDAJoinStyleFactory);

    DECLARE_REGISTRY(CLSID_DAJoinStyle,
                     LIBID ".DAJoinStyle.1",
                     LIBID ".DAJoinStyle",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAJoinStyle)
        COM_INTERFACE_ENTRY(IDAJoinStyle)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAJoinStyle)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRJOINSTYLE_TYPEID ; }
    const char * GetName () { return "DAJoinStyle" ; }


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAJoinStyle, &CLSID_DAJoinStyle>::Error(str, IID_IDAJoinStyle,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAJoinStyleCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAJoinStyleFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DABbox3
//

class CDABbox3Factory;

class ATL_NO_VTABLE CDABbox3:
    public CBvrBase < IDABbox3,
                      &IID_IDABbox3>,
    public CComCoClass<CDABbox3, &CLSID_DABbox3>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDABbox3);

    DECLARE_CLASSFACTORY_EX(CDABbox3Factory);

    DECLARE_REGISTRY(CLSID_DABbox3,
                     LIBID ".DABbox3.1",
                     LIBID ".DABbox3",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDABbox3)
        COM_INTERFACE_ENTRY(IDABbox3)

        COM_INTERFACE_ENTRY2(IDABehavior,IDABbox3)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRBBOX3_TYPEID ; }
    const char * GetName () { return "DABbox3" ; }
    STDMETHOD(get_Min) (IDAPoint3 *  * ret);
    STDMETHOD(get_Max) (IDAPoint3 *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDABbox3, &CLSID_DABbox3>::Error(str, IID_IDABbox3,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDABbox3Create(IDABehavior ** bvr);

class ATL_NO_VTABLE CDABbox3Factory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAArray
//

class CDAArrayFactory;

class ATL_NO_VTABLE CDAArray:
    public CBvrBase < IDA3Array,
                      &IID_IDA3Array>,
    public CComCoClass<CDAArray, &CLSID_DAArray>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAArray);

    DECLARE_CLASSFACTORY_EX(CDAArrayFactory);

    DECLARE_REGISTRY(CLSID_DAArray,
                     LIBID ".DAArray.1",
                     LIBID ".DAArray",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAArray)
        COM_INTERFACE_ENTRY(IDAArray)
        COM_INTERFACE_ENTRY(IDA2Array)
        COM_INTERFACE_ENTRY(IDA3Array)

        COM_INTERFACE_ENTRY2(IDABehavior,IDA3Array)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRARRAY_TYPEID ; }
    const char * GetName () { return "DAArray" ; }
    STDMETHOD(NthAnim) (IDANumber *  arg1, IDABehavior *  * ret);
    STDMETHOD(Length) (IDANumber *  * ret);
    STDMETHOD(AddElement) (IDABehavior *  arg1, DWORD arg2, long * ret);
    STDMETHOD(RemoveElement) (long arg1);
    STDMETHOD(SetElement)(long index, IDABehavior *  arg, long flag);
    STDMETHOD(GetElement)(long index, IDABehavior **ret);

  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAArray, &CLSID_DAArray>::Error(str, IID_IDA3Array,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAArrayCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAArrayFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

class IDAHackBvr : public IDABehavior{};

//
// DABehavior
//

class CDABehaviorFactory;

class ATL_NO_VTABLE CDABehavior:
    public CBvrBase < IDAHackBvr,
                      &IID_IDABehavior>,
    public CComCoClass<CDABehavior, &CLSID_DABehavior>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDABehavior);

    DECLARE_CLASSFACTORY_EX(CDABehaviorFactory);

    DECLARE_REGISTRY(CLSID_DABehavior,
                     LIBID ".DABehavior.1",
                     LIBID ".DABehavior",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDABehavior)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAHackBvr)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRUNKNOWN_TYPEID ; }
    const char * GetName () { return "DABehavior" ; }


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDABehavior, &CLSID_DABehavior>::Error(str, IID_IDABehavior,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDABehaviorCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDABehaviorFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\primmth2.h ===
//
// DAColor
//

class CDAColorFactory;

class ATL_NO_VTABLE CDAColor:
    public CBvrBase < IDA2Color,
                      &IID_IDA2Color>,
    public CComCoClass<CDAColor, &CLSID_DAColor>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAColor);

    DECLARE_CLASSFACTORY_EX(CDAColorFactory);
    
    DECLARE_REGISTRY(CLSID_DAColor,
                     LIBID ".DAColor.1",
                     LIBID ".DAColor",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAColor)
        COM_INTERFACE_ENTRY(IDAColor)
        COM_INTERFACE_ENTRY(IDA2Color)

        COM_INTERFACE_ENTRY2(IDABehavior,IDA2Color)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRCOLOR_TYPEID ; }
    const char * GetName () { return "DAColor" ; }
    STDMETHOD(get_Red) (IDANumber *  * ret);
    STDMETHOD(get_Green) (IDANumber *  * ret);
    STDMETHOD(get_Blue) (IDANumber *  * ret);
    STDMETHOD(get_Hue) (IDANumber *  * ret);
    STDMETHOD(get_Saturation) (IDANumber *  * ret);
    STDMETHOD(get_Lightness) (IDANumber *  * ret);
    STDMETHOD(AnimateProperty) (BSTR propertyPath_0, 
                                BSTR scriptingLanguage_1, 
                                VARIANT_BOOL invokeAsMethod_2, 
                                double minUpdateInterval_3, 
                                IDA2Color * * ret_4) ;


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAColor, &CLSID_DAColor>::Error(str, IID_IDAColor,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAColorCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAColorFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAMatte
//

class CDAMatteFactory;

class ATL_NO_VTABLE CDAMatte:
    public CBvrBase < IDAMatte,
                      &IID_IDAMatte>,
    public CComCoClass<CDAMatte, &CLSID_DAMatte>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAMatte);

    DECLARE_CLASSFACTORY_EX(CDAMatteFactory);
    
    DECLARE_REGISTRY(CLSID_DAMatte,
                     LIBID ".DAMatte.1",
                     LIBID ".DAMatte",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAMatte)
        COM_INTERFACE_ENTRY(IDAMatte)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAMatte)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRMATTE_TYPEID ; }
    const char * GetName () { return "DAMatte" ; }
    STDMETHOD(Transform) (IDATransform2 *  arg0, IDAMatte *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAMatte, &CLSID_DAMatte>::Error(str, IID_IDAMatte,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAMatteCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAMatteFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DANumber
//

class CDANumberFactory;

class ATL_NO_VTABLE CDANumber:
    public CBvrBase < IDANumber,
                      &IID_IDANumber>,
    public CComCoClass<CDANumber, &CLSID_DANumber>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDANumber);

    DECLARE_CLASSFACTORY_EX(CDANumberFactory);
    
    DECLARE_REGISTRY(CLSID_DANumber,
                     LIBID ".DANumber.1",
                     LIBID ".DANumber",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDANumber)
        COM_INTERFACE_ENTRY(IDANumber)

        COM_INTERFACE_ENTRY2(IDABehavior,IDANumber)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRNUMBER_TYPEID ; }
    const char * GetName () { return "DANumber" ; }
    STDMETHOD(Extract) (double * ret);
    STDMETHOD(AnimateProperty) (BSTR arg1, BSTR arg2, VARIANT_BOOL arg3, double arg4, IDANumber *  * ret);
    STDMETHOD(ToStringAnim) (IDANumber *  arg1, IDAString *  * ret);
    STDMETHOD(ToString) (double arg1, IDAString *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDANumber, &CLSID_DANumber>::Error(str, IID_IDANumber,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDANumberCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDANumberFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAPoint3
//

class CDAPoint3Factory;

class ATL_NO_VTABLE CDAPoint3:
    public CBvrBase < IDAPoint3,
                      &IID_IDAPoint3>,
    public CComCoClass<CDAPoint3, &CLSID_DAPoint3>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAPoint3);

    DECLARE_CLASSFACTORY_EX(CDAPoint3Factory);
    
    DECLARE_REGISTRY(CLSID_DAPoint3,
                     LIBID ".DAPoint3.1",
                     LIBID ".DAPoint3",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAPoint3)
        COM_INTERFACE_ENTRY(IDAPoint3)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAPoint3)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRPOINT3_TYPEID ; }
    const char * GetName () { return "DAPoint3" ; }
    STDMETHOD(Project) (IDACamera *  arg1, IDAPoint2 *  * ret);
    STDMETHOD(get_X) (IDANumber *  * ret);
    STDMETHOD(get_Y) (IDANumber *  * ret);
    STDMETHOD(get_Z) (IDANumber *  * ret);
    STDMETHOD(get_SphericalCoordXYAngle) (IDANumber *  * ret);
    STDMETHOD(get_SphericalCoordYZAngle) (IDANumber *  * ret);
    STDMETHOD(get_SphericalCoordLength) (IDANumber *  * ret);
    STDMETHOD(Transform) (IDATransform3 *  arg0, IDAPoint3 *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAPoint3, &CLSID_DAPoint3>::Error(str, IID_IDAPoint3,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAPoint3Create(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAPoint3Factory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DATransform2
//

class CDATransform2Factory;

class ATL_NO_VTABLE CDATransform2:
    public CBvrBase < IDATransform2,
                      &IID_IDATransform2>,
    public CComCoClass<CDATransform2, &CLSID_DATransform2>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDATransform2);

    DECLARE_CLASSFACTORY_EX(CDATransform2Factory);
    
    DECLARE_REGISTRY(CLSID_DATransform2,
                     LIBID ".DATransform2.1",
                     LIBID ".DATransform2",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDATransform2)
        COM_INTERFACE_ENTRY(IDATransform2)

        COM_INTERFACE_ENTRY2(IDABehavior,IDATransform2)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRTRANSFORM2_TYPEID ; }
    const char * GetName () { return "DATransform2" ; }
    STDMETHOD(Inverse) (IDATransform2 *  * ret);
    STDMETHOD(get_IsSingular) (IDABoolean *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDATransform2, &CLSID_DATransform2>::Error(str, IID_IDATransform2,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDATransform2Create(IDABehavior ** bvr);

class ATL_NO_VTABLE CDATransform2Factory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAVector3
//

class CDAVector3Factory;

class ATL_NO_VTABLE CDAVector3:
    public CBvrBase < IDAVector3,
                      &IID_IDAVector3>,
    public CComCoClass<CDAVector3, &CLSID_DAVector3>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAVector3);

    DECLARE_CLASSFACTORY_EX(CDAVector3Factory);
    
    DECLARE_REGISTRY(CLSID_DAVector3,
                     LIBID ".DAVector3.1",
                     LIBID ".DAVector3",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAVector3)
        COM_INTERFACE_ENTRY(IDAVector3)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAVector3)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRVECTOR3_TYPEID ; }
    const char * GetName () { return "DAVector3" ; }
    STDMETHOD(get_Length) (IDANumber *  * ret);
    STDMETHOD(get_LengthSquared) (IDANumber *  * ret);
    STDMETHOD(Normalize) (IDAVector3 *  * ret);
    STDMETHOD(MulAnim) (IDANumber *  arg0, IDAVector3 *  * ret);
    STDMETHOD(Mul) (double arg0, IDAVector3 *  * ret);
    STDMETHOD(DivAnim) (IDANumber *  arg1, IDAVector3 *  * ret);
    STDMETHOD(Div) (double arg1, IDAVector3 *  * ret);
    STDMETHOD(get_X) (IDANumber *  * ret);
    STDMETHOD(get_Y) (IDANumber *  * ret);
    STDMETHOD(get_Z) (IDANumber *  * ret);
    STDMETHOD(get_SphericalCoordXYAngle) (IDANumber *  * ret);
    STDMETHOD(get_SphericalCoordYZAngle) (IDANumber *  * ret);
    STDMETHOD(get_SphericalCoordLength) (IDANumber *  * ret);
    STDMETHOD(Transform) (IDATransform3 *  arg0, IDAVector3 *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAVector3, &CLSID_DAVector3>::Error(str, IID_IDAVector3,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAVector3Create(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAVector3Factory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAEndStyle
//

class CDAEndStyleFactory;

class ATL_NO_VTABLE CDAEndStyle:
    public CBvrBase < IDAEndStyle,
                      &IID_IDAEndStyle>,
    public CComCoClass<CDAEndStyle, &CLSID_DAEndStyle>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAEndStyle);

    DECLARE_CLASSFACTORY_EX(CDAEndStyleFactory);
    
    DECLARE_REGISTRY(CLSID_DAEndStyle,
                     LIBID ".DAEndStyle.1",
                     LIBID ".DAEndStyle",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAEndStyle)
        COM_INTERFACE_ENTRY(IDAEndStyle)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAEndStyle)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRENDSTYLE_TYPEID ; }
    const char * GetName () { return "DAEndStyle" ; }


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAEndStyle, &CLSID_DAEndStyle>::Error(str, IID_IDAEndStyle,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAEndStyleCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAEndStyleFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DABbox2
//

class CDABbox2Factory;

class ATL_NO_VTABLE CDABbox2:
    public CBvrBase < IDABbox2,
                      &IID_IDABbox2>,
    public CComCoClass<CDABbox2, &CLSID_DABbox2>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDABbox2);

    DECLARE_CLASSFACTORY_EX(CDABbox2Factory);
    
    DECLARE_REGISTRY(CLSID_DABbox2,
                     LIBID ".DABbox2.1",
                     LIBID ".DABbox2",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDABbox2)
        COM_INTERFACE_ENTRY(IDABbox2)

        COM_INTERFACE_ENTRY2(IDABehavior,IDABbox2)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRBBOX2_TYPEID ; }
    const char * GetName () { return "DABbox2" ; }
    STDMETHOD(get_Min) (IDAPoint2 *  * ret);
    STDMETHOD(get_Max) (IDAPoint2 *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDABbox2, &CLSID_DABbox2>::Error(str, IID_IDABbox2,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDABbox2Create(IDABehavior ** bvr);

class ATL_NO_VTABLE CDABbox2Factory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAEvent
//

class CDAEventFactory;

class ATL_NO_VTABLE CDAEvent:
    public CBvrBase < IDA2Event,
                      &IID_IDA2Event>,
    public CComCoClass<CDAEvent, &CLSID_DAEvent>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAEvent);

    DECLARE_CLASSFACTORY_EX(CDAEventFactory);
    
    DECLARE_REGISTRY(CLSID_DAEvent,
                     LIBID ".DAEvent.1",
                     LIBID ".DAEvent",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAEvent)
        COM_INTERFACE_ENTRY(IDAEvent)
        COM_INTERFACE_ENTRY(IDA2Event)

        COM_INTERFACE_ENTRY2(IDABehavior,IDA2Event)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CREVENT_TYPEID ; }
    const char * GetName () { return "DAEvent" ; }
    STDMETHOD(Notify) (IDAUntilNotifier * arg1, IDAEvent *  * ret);
    STDMETHOD(Snapshot) (IDABehavior *  arg1, IDAEvent *  * ret);
    STDMETHOD(AttachData) (IDABehavior *  arg1, IDAEvent *  * ret);
    STDMETHOD(ScriptCallback) (BSTR arg0, BSTR arg2, IDAEvent *  * ret);
    STDMETHOD(NotifyScript) (BSTR arg1, IDAEvent *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAEvent, &CLSID_DAEvent>::Error(str, IID_IDA2Event,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAEventCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAEventFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAUserData
//

class CDAUserDataFactory;

class ATL_NO_VTABLE CDAUserData:
    public CBvrBase < IDAUserData,
                      &IID_IDAUserData>,
    public CComCoClass<CDAUserData, &CLSID_DAUserData>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAUserData);

    DECLARE_CLASSFACTORY_EX(CDAUserDataFactory);
    
    DECLARE_REGISTRY(CLSID_DAUserData,
                     LIBID ".DAUserData.1",
                     LIBID ".DAUserData",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAUserData)
        COM_INTERFACE_ENTRY(IDAUserData)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAUserData)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRUSERDATA_TYPEID ; }
    const char * GetName () { return "DAUserData" ; }
    STDMETHOD(get_Data) (IUnknown * * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAUserData, &CLSID_DAUserData>::Error(str, IID_IDAUserData,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAUserDataCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAUserDataFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\primmth1.h ===
//
// DACamera
//

class CDACameraFactory;

class ATL_NO_VTABLE CDACamera:
    public CBvrBase < IDACamera,
                      &IID_IDACamera>,
    public CComCoClass<CDACamera, &CLSID_DACamera>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDACamera);

    DECLARE_CLASSFACTORY_EX(CDACameraFactory);
    
    DECLARE_REGISTRY(CLSID_DACamera,
                     LIBID ".DACamera.1",
                     LIBID ".DACamera",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDACamera)
        COM_INTERFACE_ENTRY(IDACamera)

        COM_INTERFACE_ENTRY2(IDABehavior,IDACamera)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRCAMERA_TYPEID ; }
    const char * GetName () { return "DACamera" ; }
    STDMETHOD(Transform) (IDATransform3 *  arg0, IDACamera *  * ret);
    STDMETHOD(Depth) (double arg0, IDACamera *  * ret);
    STDMETHOD(DepthAnim) (IDANumber *  arg0, IDACamera *  * ret);
    STDMETHOD(DepthResolution) (double arg0, IDACamera *  * ret);
    STDMETHOD(DepthResolutionAnim) (IDANumber *  arg0, IDACamera *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDACamera, &CLSID_DACamera>::Error(str, IID_IDACamera,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDACameraCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDACameraFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAImage
//

class CDAImageFactory;

class ATL_NO_VTABLE CDAImage:
    public CBvrBase < IDA3Image,
                      &IID_IDA3Image>,
    public CComCoClass<CDAImage, &CLSID_DAImage>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAImage);

    DECLARE_CLASSFACTORY_EX(CDAImageFactory);
    
    DECLARE_REGISTRY(CLSID_DAImage,
                     LIBID ".DAImage.1",
                     LIBID ".DAImage",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAImage)
        COM_INTERFACE_ENTRY(IDAImage)
        COM_INTERFACE_ENTRY(IDA2Image)
        COM_INTERFACE_ENTRY(IDA3Image)

        COM_INTERFACE_ENTRY2(IDABehavior,IDA3Image)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRIMAGE_TYPEID ; }
    const char * GetName () { return "DAImage" ; }
    STDMETHOD(Pickable) (IDAPickableResult * * ret);
    STDMETHOD(PickableOccluded) (IDAPickableResult * * ret);
    STDMETHOD(ApplyBitmapEffect) (IUnknown * arg1, IDAEvent *  arg2, IDAImage *  * ret);
    STDMETHOD(AddPickData) (IUnknown * arg1, VARIANT_BOOL arg2, IDAImage *  * ret);
    STDMETHOD(get_BoundingBox) (IDABbox2 *  * ret);
    STDMETHOD(Crop) (IDAPoint2 *  arg0, IDAPoint2 *  arg1, IDAImage *  * ret);
    STDMETHOD(Transform) (IDATransform2 *  arg0, IDAImage *  * ret);
    STDMETHOD(OpacityAnim) (IDANumber *  arg0, IDAImage *  * ret);
    STDMETHOD(Opacity) (double arg0, IDAImage *  * ret);
    STDMETHOD(Undetectable) (IDAImage *  * ret);
    STDMETHOD(Tile) (IDAImage *  * ret);
    STDMETHOD(Clip) (IDAMatte *  arg0, IDAImage *  * ret);
    STDMETHOD(MapToUnitSquare) (IDAImage *  * ret);
    STDMETHOD(ClipPolygonImageEx) (long sizearg0, IDAPoint2 *  arg0[], IDAImage *  * ret);
    STDMETHOD(ClipPolygonImage) (VARIANT arg0, IDAImage *  * ret);
    STDMETHOD(RenderResolution) (long arg1, long arg2, IDAImage *  * ret);
    STDMETHOD(ImageQuality) (DWORD arg1, IDAImage *  * ret);
    STDMETHOD(ColorKey) (IDAColor *  arg1, IDAImage *  * ret);
    STDMETHOD(TransformColorRGB) (IDATransform3 * arg1, IDAImage *  * ret);

  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAImage, &CLSID_DAImage>::Error(str, IID_IDA3Image,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAImageCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAImageFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAMontage
//

class CDAMontageFactory;

class ATL_NO_VTABLE CDAMontage:
    public CBvrBase < IDAMontage,
                      &IID_IDAMontage>,
    public CComCoClass<CDAMontage, &CLSID_DAMontage>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAMontage);

    DECLARE_CLASSFACTORY_EX(CDAMontageFactory);
    
    DECLARE_REGISTRY(CLSID_DAMontage,
                     LIBID ".DAMontage.1",
                     LIBID ".DAMontage",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAMontage)
        COM_INTERFACE_ENTRY(IDAMontage)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAMontage)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRMONTAGE_TYPEID ; }
    const char * GetName () { return "DAMontage" ; }
    STDMETHOD(Render) (IDAImage *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAMontage, &CLSID_DAMontage>::Error(str, IID_IDAMontage,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAMontageCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAMontageFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAPoint2
//

class CDAPoint2Factory;

class ATL_NO_VTABLE CDAPoint2:
    public CBvrBase < IDAPoint2,
                      &IID_IDAPoint2>,
    public CComCoClass<CDAPoint2, &CLSID_DAPoint2>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAPoint2);

    DECLARE_CLASSFACTORY_EX(CDAPoint2Factory);
    
    DECLARE_REGISTRY(CLSID_DAPoint2,
                     LIBID ".DAPoint2.1",
                     LIBID ".DAPoint2",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAPoint2)
        COM_INTERFACE_ENTRY(IDAPoint2)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAPoint2)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRPOINT2_TYPEID ; }
    const char * GetName () { return "DAPoint2" ; }
    STDMETHOD(AnimateControlPosition) (BSTR arg1, BSTR arg2, VARIANT_BOOL arg3, double arg4, IDAPoint2 *  * ret);
    STDMETHOD(AnimateControlPositionPixel) (BSTR arg1, BSTR arg2, VARIANT_BOOL arg3, double arg4, IDAPoint2 *  * ret);
    STDMETHOD(get_X) (IDANumber *  * ret);
    STDMETHOD(get_Y) (IDANumber *  * ret);
    STDMETHOD(get_PolarCoordAngle) (IDANumber *  * ret);
    STDMETHOD(get_PolarCoordLength) (IDANumber *  * ret);
    STDMETHOD(Transform) (IDATransform2 *  arg0, IDAPoint2 *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAPoint2, &CLSID_DAPoint2>::Error(str, IID_IDAPoint2,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAPoint2Create(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAPoint2Factory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAString
//

class CDAStringFactory;

class ATL_NO_VTABLE CDAString:
    public CBvrBase < IDAString,
                      &IID_IDAString>,
    public CComCoClass<CDAString, &CLSID_DAString>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAString);

    DECLARE_CLASSFACTORY_EX(CDAStringFactory);
    
    DECLARE_REGISTRY(CLSID_DAString,
                     LIBID ".DAString.1",
                     LIBID ".DAString",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAString)
        COM_INTERFACE_ENTRY(IDAString)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAString)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRSTRING_TYPEID ; }
    const char * GetName () { return "DAString" ; }
    STDMETHOD(Extract) (BSTR * ret);
    STDMETHOD(AnimateProperty) (BSTR arg1, BSTR arg2, VARIANT_BOOL arg3, double arg4, IDAString *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAString, &CLSID_DAString>::Error(str, IID_IDAString,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAStringCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAStringFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAVector2
//

class CDAVector2Factory;

class ATL_NO_VTABLE CDAVector2:
    public CBvrBase < IDAVector2,
                      &IID_IDAVector2>,
    public CComCoClass<CDAVector2, &CLSID_DAVector2>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAVector2);

    DECLARE_CLASSFACTORY_EX(CDAVector2Factory);
    
    DECLARE_REGISTRY(CLSID_DAVector2,
                     LIBID ".DAVector2.1",
                     LIBID ".DAVector2",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAVector2)
        COM_INTERFACE_ENTRY(IDAVector2)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAVector2)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRVECTOR2_TYPEID ; }
    const char * GetName () { return "DAVector2" ; }
    STDMETHOD(get_Length) (IDANumber *  * ret);
    STDMETHOD(get_LengthSquared) (IDANumber *  * ret);
    STDMETHOD(Normalize) (IDAVector2 *  * ret);
    STDMETHOD(MulAnim) (IDANumber *  arg1, IDAVector2 *  * ret);
    STDMETHOD(Mul) (double arg1, IDAVector2 *  * ret);
    STDMETHOD(DivAnim) (IDANumber *  arg1, IDAVector2 *  * ret);
    STDMETHOD(Div) (double arg1, IDAVector2 *  * ret);
    STDMETHOD(get_X) (IDANumber *  * ret);
    STDMETHOD(get_Y) (IDANumber *  * ret);
    STDMETHOD(get_PolarCoordAngle) (IDANumber *  * ret);
    STDMETHOD(get_PolarCoordLength) (IDANumber *  * ret);
    STDMETHOD(Transform) (IDATransform2 *  arg0, IDAVector2 *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAVector2, &CLSID_DAVector2>::Error(str, IID_IDAVector2,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAVector2Create(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAVector2Factory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DALineStyle
//

class CDALineStyleFactory;

class ATL_NO_VTABLE CDALineStyle:
    public CBvrBase < IDA2LineStyle,
                      &IID_IDA2LineStyle>,
    public CComCoClass<CDALineStyle, &CLSID_DALineStyle>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDALineStyle);

    DECLARE_CLASSFACTORY_EX(CDALineStyleFactory);
    
    DECLARE_REGISTRY(CLSID_DALineStyle,
                     LIBID ".DALineStyle.1",
                     LIBID ".DALineStyle",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDALineStyle)
        COM_INTERFACE_ENTRY(IDALineStyle)
        COM_INTERFACE_ENTRY(IDA2LineStyle)

        COM_INTERFACE_ENTRY2(IDABehavior,IDA2LineStyle)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRLINESTYLE_TYPEID ; }
    const char * GetName () { return "DALineStyle" ; }
    STDMETHOD(End) (IDAEndStyle *  arg0, IDALineStyle *  * ret);
    STDMETHOD(Join) (IDAJoinStyle *  arg0, IDALineStyle *  * ret);
    STDMETHOD(Dash) (IDADashStyle *  arg0, IDALineStyle *  * ret);
    STDMETHOD(WidthAnim) (IDANumber *  arg0, IDALineStyle *  * ret);
    STDMETHOD(width) (double arg0, IDALineStyle *  * ret);
    STDMETHOD(AntiAliasing) (double arg0, IDALineStyle *  * ret);
    STDMETHOD(Detail) (IDALineStyle *  * ret);
    STDMETHOD(Color) (IDAColor *  arg0, IDALineStyle *  * ret);
    STDMETHOD(DashStyle) (DWORD arg1, IDALineStyle *  * ret);
    STDMETHOD(MiterLimit) (double arg1, IDALineStyle *  * ret);
    STDMETHOD(MiterLimitAnim) (IDANumber *  arg1, IDALineStyle *  * ret);
    STDMETHOD(JoinStyle) (DWORD arg1, IDALineStyle *  * ret);
    STDMETHOD(EndStyle) (DWORD arg1, IDALineStyle *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDALineStyle, &CLSID_DALineStyle>::Error(str, IID_IDA2LineStyle,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDALineStyleCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDALineStyleFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DADashStyle
//

class CDADashStyleFactory;

class ATL_NO_VTABLE CDADashStyle:
    public CBvrBase < IDADashStyle,
                      &IID_IDADashStyle>,
    public CComCoClass<CDADashStyle, &CLSID_DADashStyle>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDADashStyle);

    DECLARE_CLASSFACTORY_EX(CDADashStyleFactory);
    
    DECLARE_REGISTRY(CLSID_DADashStyle,
                     LIBID ".DADashStyle.1",
                     LIBID ".DADashStyle",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDADashStyle)
        COM_INTERFACE_ENTRY(IDADashStyle)

        COM_INTERFACE_ENTRY2(IDABehavior,IDADashStyle)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRDASHSTYLE_TYPEID ; }
    const char * GetName () { return "DADashStyle" ; }


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDADashStyle, &CLSID_DADashStyle>::Error(str, IID_IDADashStyle,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDADashStyleCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDADashStyleFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DAPair
//

class CDAPairFactory;

class ATL_NO_VTABLE CDAPair:
    public CBvrBase < IDAPair,
                      &IID_IDAPair>,
    public CComCoClass<CDAPair, &CLSID_DAPair>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDAPair);

    DECLARE_CLASSFACTORY_EX(CDAPairFactory);
    
    DECLARE_REGISTRY(CLSID_DAPair,
                     LIBID ".DAPair.1",
                     LIBID ".DAPair",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDAPair)
        COM_INTERFACE_ENTRY(IDAPair)

        COM_INTERFACE_ENTRY2(IDABehavior,IDAPair)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRPAIR_TYPEID ; }
    const char * GetName () { return "DAPair" ; }
    STDMETHOD(get_First) (IDABehavior *  * ret);
    STDMETHOD(get_Second) (IDABehavior *  * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDAPair, &CLSID_DAPair>::Error(str, IID_IDAPair,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDAPairCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDAPairFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

//
// DATuple
//

class CDATupleFactory;

class ATL_NO_VTABLE CDATuple:
    public CBvrBase < IDATuple,
                      &IID_IDATuple>,
    public CComCoClass<CDATuple, &CLSID_DATuple>
{
  public:
    DA_DECLARE_NOT_AGGREGATABLE(CDATuple);

    DECLARE_CLASSFACTORY_EX(CDATupleFactory);
    
    DECLARE_REGISTRY(CLSID_DATuple,
                     LIBID ".DATuple.1",
                     LIBID ".DATuple",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDATuple)
        COM_INTERFACE_ENTRY(IDATuple)

        COM_INTERFACE_ENTRY2(IDABehavior,IDATuple)
        COM_INTERFACE_ENTRY_CHAIN(CBvr)
    END_COM_MAP();

    CR_BVR_TYPEID GetTypeInfo () { return CRTUPLE_TYPEID ; }
    const char * GetName () { return "DATuple" ; }
    STDMETHOD(Nth) (long arg1, IDABehavior *  * ret);
    STDMETHOD(get_Length) (long * ret);


  protected:
    virtual HRESULT BvrError(LPCWSTR str, HRESULT hr)
    { return CComCoClass<CDATuple, &CLSID_DATuple>::Error(str, IID_IDATuple,hr); }
    HRESULT Error() { return CBvr::Error(); }
};

extern CBvr * CDATupleCreate(IDABehavior ** bvr);

class ATL_NO_VTABLE CDATupleFactory : public CComClassFactory
{
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\pickq.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of the PickQ class

*******************************************************************************/


#include "headers.h"
#include "view.h"
#include "pickq.h"
#include "privinc/probe.h"
#include "appelles/hacks.h"
#include "privinc/vec2i.h"

// ==============================
// PickQ implementation
// ==============================

PickQ::PickQ ()
: _heap1(NULL),
  _heap2(NULL),
  _heapSwitchTime(0.0)
{
    _heap1 = &TransientHeap("pick heap1", 10000);
    _heap2 = &TransientHeap("pick heap2", 10000);
    _heap = _heap1 ;
}

PickQ::~PickQ()
{
    Reset(0.0, TRUE);

    if (_heap1)
        DestroyTransientHeap(*_heap1);    

    if (_heap2)
        DestroyTransientHeap(*_heap2);    
}

// Keep events for DELTA time
static const Time DELTA = 0.5;

void
PickQ::Reset(Time curTime, BOOL noLeftover)
{
    Time cutOff = curTime - DELTA;

    if (noLeftover) {
        for (PickMap::iterator i = _pm.begin(); i != _pm.end(); i++) {
            delete (*i).second; // delete pick event queue
        }
        _pm.erase(_pm.begin(), _pm.end());
        
    } else {

        BEGIN_LEAK
        list<int> eIds;         // Gather empty pick id queues.
        END_LEAK

        Time maxHeapTime = 0.0;
        
        for (PickMap::iterator i = _pm.begin(); i != _pm.end(); i++) {
            PickEventQ* q = (*i).second;
            
            while (!q->empty()) {
                if (q->front()._eventTime > cutOff) {
                    maxHeapTime = MAX(maxHeapTime, q->back()._eventTime);
                    break;
                }

                q->pop_front();
            }

            // If empty, delete and save it for removal from pickmap.
            if (q->empty()) {
                delete q;
                eIds.push_front((*i).first);
            }
        }

        // Erase empty queues from pickmap
        for (list<int>::iterator j = eIds.begin(); j != eIds.end(); j++) {
            _pm.erase(*j);
        }

        if (cutOff > _heapSwitchTime) {
            _heap = (_heap == _heap1) ? _heap2 : _heap1;
            
#if _DEBUG
            /*
            if (_heapSwitchTime && maxHeapTime) {
                printf("cutoff = %15.5f, switch = %15.5f, new = %15.5f\n",
                       cutOff, _heapSwitchTime, maxHeapTime);
            }
            GetCurrentHeap().Dump();
            */
#endif      
            ResetDynamicHeap(GetCurrentHeap());
            _heapSwitchTime = maxHeapTime;
        }
    }
}

void
PickQ::Add (int eventId, PickQData & data)
{
    PickMap::iterator i = _pm.find(eventId);
    PickEventQ *q;

    if (i == _pm.end()) {
        BEGIN_LEAK
        q = new PickEventQ;
        END_LEAK
        
        _pm[eventId] = q;
    } else {
        q = (*i).second;

        // Duplicated entries, ignore.
        if (q->back()._eventTime == data._eventTime)
            return;

        // They should be sorted.
        Assert(q->back()._eventTime < data._eventTime);
    }

    q->insert(q->end(), data);
}

void
PickQ::GatherPicks(Image* image, Time time, Time lastPollTime)
{
    Reset(time, FALSE);

    DWORD x,y ;

    EventQ& eq = GetCurrentEventQ();
    
    if (eq.IsMouseInWindow(time)) {
        eq.GetMousePos(time, x, y); 
        // Turn rawMousePos into wcMousePos
        Point2Value *wcMousePos = PixelPos2wcPos((short)x,(short)y) ;

        // Don't reset
        DynamicHeapPusher dhp(GetCurrentHeap());

        PerformPicking(image, wcMousePos, true, time, lastPollTime);
    }
}

// TODO: This is temporary, we need a better approach for interpolated
// polling events like pick.
static const double EPSILON = 0.001;  // 10ms

inline BOOL FEQ(double f1, double f2)
{ return fabs(f1 - f2) <= EPSILON; }

// Check to see if the specified ID is on the pick queue.
BOOL
PickQ::CheckForPickEvent(int id, Real time, PickQData & result)
{
    PickMap::iterator i = _pm.find(id);

    if (i == _pm.end()) {
        return FALSE;
    } else {
        PickEventQ* q = (*i).second;

        if (q->empty())
            return FALSE;

        // See if time outside queue range, if so, see if it's close
        // enough to the end points to decide hit.
        
        result = q->front();
        
        if (time <= result._eventTime)
            return FEQ(time, result._eventTime);

        result = q->back();

        // See if it's the last time we poll.  If not, that means it's
        // not picked in the current frame.

        if (time >= result._eventTime) {
            if (result._eventTime == GetLastSampleTime()) {
                result._eventTime = time;
                return TRUE;
            }
            return FALSE;
        }

        Assert((time > q->front()._eventTime) &&
               (time < q->back()._eventTime));

        // Find out the range time falls on.
        
        PickEventQ::iterator last = q->begin();
        PickEventQ::iterator j = q->begin();
        
        while ((++j) != q->end()) {
            
            if (time < (*j)._eventTime) {
                Time t1 = (*last)._eventTime;
                Time t2 = (*j)._eventTime;
                
                Assert((t1 <= time) && (time <= t2));

                // The probe is true within that range if the last
                // poll time of the end == event time of the beginning. 
                
                if (t1 == (*j)._lastPollTime) {

                    // See if time point closer to end or begin
                    
                    if ((time - t1) > (t2 - time))
                        result = *last;
                    else
                        result = *j;

                    /*
                    printf("pickq entry: %20.15f, time: %20.15f\n",
                           result._eventTime, time);
                    fflush(stdout);
                    */
                    
                    result._eventTime = time;

                    return TRUE;
                }

                // Time falls into a range that probe is not true.
                // See if it's close enough to either range end.
                
                if (FEQ(time, t1)) {
                    result = (*last);
                    return TRUE;
                }

                if (FEQ(time, t2)) {
                    result = (*j);
                    return TRUE;
                }

                return FALSE;
            }

            ++last;
        }

        // Shouldn't get here...
        Assert(FALSE);

        return FALSE;
    }
}

// C Functions

BOOL CheckForPickEvent(int id, Real time, PickQData & result)
{ return GetCurrentPickQ().CheckForPickEvent(id, time, result); }

Point2Value*
PixelPos2wcPos(short x, short y)
{
    /* TODO: We need to clean up this hacky stuff. */
    Real res = ViewerResolution();
    Point2Value *topRight = PRIV_ViewerUpperRight(NULL);

    Real w = topRight->x;
    Real h = topRight->y;

    Real nx = ( Real(x) / res) - w;

    Real ny = h - ( Real(y) / res);

// XyPoint2 copies the real values...hopefully
    return XyPoint2RR(nx, ny);
}

void AddToPickQ (int id, PickQData & data)
{ GetCurrentPickQ().Add (id, data) ; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\propanim.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Animation of ActiveX control properties.

*******************************************************************************/


#include "headers.h"

#include <mshtml.h>
#include "statics.h"
#include "propanim.h"
#include "cview.h"
#include "comcb.h"

// Caller responsible for deallocating.
static char *
ConvertWideToAnsi(LPCWSTR wideStr)
{
    int len = lstrlenW(wideStr) + 1;
    char *ansiStr = new char[len * 2];
    
    if (ansiStr) {
        WideCharToMultiByte(CP_ACP, 0,
                            wideStr, -1,
                            ansiStr, len * 2,
                            NULL, NULL);
    }

    return ansiStr;
}

// TODO: Pull up into a utility library
static BSTR
makeBSTR(LPSTR ansiStr)
{

#ifdef _UNICODE
    return SysAllocString(ansiStr);
#else
    USES_CONVERSION;
    return SysAllocString(A2W(ansiStr));
#endif    
}

static void
StringFromDouble(double d, char *str, bool showFraction)
{
    if (showFraction) {
        // wsprintf doesn't support printing floating point numbers,
        // so we construct a floating point representation explicitly
        // here.
        char *sign = (d < 0) ? "-" : "";
        if (d < 0) d = -d;
    
        int integerPortion = (int)d;

        // up to 4 decimal places
        int fractionalPortion = (int)((d - integerPortion) * 10000); 

        wsprintf(str, "%s%d.%.4d", sign, integerPortion,
                 fractionalPortion);
    } else {
        wsprintf(str, "%d", (int)d);
    }
    
}

// TODO: This should really use the raw layer and not do all this
// extra COM junk

#define NULL_IF_FAILED(exp) if (FAILED(hr = exp)) return NULL;
#define HR_IF_FAILED(exp) if (FAILED(hr = exp)) return hr;
    
#define MAX_SCRIPT_LEN 512
    
class CPropAnimHook : public IDABvrHook
{
  public:

    typedef enum { POINT, STRING, NUMBER, COLOR } BehaviorType;
    typedef enum { VBSCRIPT, JSCRIPT, OTHER } ScriptingLanguageType;
    
    CPropAnimHook(LPWSTR propertyPath,
                  LPWSTR scriptingLanguage,
                  VARIANT_BOOL invokeAsMethod,
                  double minUpdateInterval,
                  BehaviorType bvrType,
                  bool convertToPixel) 
        {

        _propertyPath              = ConvertWideToAnsi(propertyPath);
        _scriptingLanguageStr      = ConvertWideToAnsi(scriptingLanguage);
        _convertToPixel            = convertToPixel;
        
        if (lstrcmp(_scriptingLanguageStr, "VBScript") == 0) {
            _scriptingLanguage = VBSCRIPT;
        } else if (lstrcmp(_scriptingLanguageStr, "JScript") == 0) {
            _scriptingLanguage = JSCRIPT;
        } else {
            _scriptingLanguage = OTHER;
        }


        _cRef              = 1;
        _invokeAsMethod    = invokeAsMethod;
        _minUpdateInterval = minUpdateInterval;
        _bvrType           = bvrType;
        _lastInvocation    = 0.0;
        _firstTimeVtblSetting = true;

        _scriptStrings[0] = _firstScriptString;
        _scriptStrings[1] = _secondScriptString;
    }

    ~CPropAnimHook() {
        delete [] _propertyPath;
        delete [] _scriptingLanguageStr;
    }

    // IUnknown methods
    STDMETHODIMP_(ULONG) AddRef() { return InterlockedIncrement(&_cRef); }
    STDMETHODIMP_(ULONG) Release() {
        ULONG ul = InterlockedDecrement(&_cRef) ;
        if (ul == 0) delete this;
        return ul;
    }
    
    STDMETHODIMP QueryInterface (REFIID riid, void **ppv) {
        if ( !ppv )
            return E_POINTER;

        *ppv = NULL;
        if (InlineIsEqualGUID(riid,IID_IUnknown)) {
            *ppv = (void *)(IUnknown *)this;
        } else if (InlineIsEqualGUID(riid,IID_IDABvrHook)) {
            *ppv = (void *)(IDABvrHook *)this;
        } else {
            return E_NOINTERFACE;
        }

        AddRef();
        return S_OK;
    }


    // IDABvrHook methods
    STDMETHODIMP Notify(LONG id,
                        VARIANT_BOOL start,
                        double startTime,
                        double gTime,
                        double lTime,
                        IDABehavior * sampleVal,
                        IDABehavior * curRunningBvr,
                        IDABehavior ** ppBvr) {

        // Just continue on with the currently sample.
        *ppBvr = NULL;

        // Not interested in bvr starting notifies
        if (!start) {

            HRESULT hr = S_OK;

            // TODO: Build up a map to allow disambiguation of
            // multiple performances of this behavior.  Otherwise,
            // we'll get the separate performances firing off each
            // others events and not interpreting the updateInterval
            // value correctly.
            
            // First determine whether we should cause an invocation
            // this time.  Second part of this will handle wraparound
            // of the timer appropriately.  That is, if the global
            // time is ever less then the time of the last invocation,
            // then we've wrapped around.
            if (gTime > _lastInvocation + _minUpdateInterval ||
                gTime < _lastInvocation) {

                _lastInvocation = gTime;

                // Check for fast path to vtbl bind to the style of an
                // element.  TODO: We should be able to do this on
                // number and string properties too.
                if (!_invokeAsMethod && _bvrType == POINT) {
                    hr = VtblBindPointProperty(sampleVal);
                } else {
                    hr = E_FAIL; // just for the logic below
                }

                // If we made it through the above successfully,
                // we're all set.  Otherwise, go through
                // script.
                if (FAILED(hr)) {

                    // Will never be more than 2 script strings (point
                    // requires two).
                    int numScriptStrings;
                    switch (_bvrType) {
                      case POINT:
                        numScriptStrings = BuildUpPointScript(sampleVal);
                        break;

                      case STRING:
                        numScriptStrings = BuildUpStringScript(sampleVal);
                        break;

                      case NUMBER:
                        numScriptStrings = BuildUpNumberScript(sampleVal);
                        break;

                      case COLOR:
                        numScriptStrings = BuildUpColorScript(sampleVal);
                        break;
                    }

                    if (numScriptStrings == 0) {
                        Assert(FALSE && "Couldn't construct script string");
                        return E_FAIL;
                    }

                    for (int i = 0; i < numScriptStrings; i++) {
                    
                        TraceTag((tagCOMCallback,
                                  "About to invoke scripting string: %s",
                                  _scriptStrings[i]));

                        BSTR bstrScriptString = makeBSTR(_scriptStrings[i]);
                        BSTR scriptingLanguageBSTR = makeBSTR(_scriptingLanguageStr);
                                              
                        CComVariant retval;
                        hr = CallScriptOnPage(bstrScriptString,
                                              scriptingLanguageBSTR,
                                              &retval);

                        SysFreeString(bstrScriptString);
                        SysFreeString(scriptingLanguageBSTR);

                    }

                }
                
            }

            return hr;
        }

        return S_OK;
    }


  protected:

    HRESULT yankCoords(IDABehavior *sampleVal,
                       double *xVal,
                       double *yVal) {

        HRESULT hr;
        
        CComPtr<IDAPoint2> ptBvr;
        CComPtr<IDANumber> ptXBvr;
        CComPtr<IDANumber> ptYBvr;
        
        HR_IF_FAILED(sampleVal->QueryInterface(IID_IDAPoint2,
                                               (void **)&ptBvr));

        HR_IF_FAILED(ptBvr->get_X(&ptXBvr));
        HR_IF_FAILED(ptBvr->get_Y(&ptYBvr));

        HR_IF_FAILED(ptXBvr->Extract(xVal));
        HR_IF_FAILED(ptYBvr->Extract(yVal));

        return hr;
    }

    HRESULT VtblBindPointProperty(IDABehavior *sampleVal) {
        
        HRESULT hr;

        // TODO: We used to cache all through the grabbing of the
        // style, and do this only once.  However, there is a bug
        // (reflected in bug 9084 in our raid db) that was caused by
        // this IDABvrHook being GC'd after the client site was set to
        // NULL.  This was causing our cached style to be released
        // after it was invalid, causing a fault.  Thus, for now, we
        // don't cache.  Should reintroduce caching with a check to
        // avoid this after the client site is set back to null.
        
        // First time through, build up and cache the
        // IHTMLStyle for the specified property.

        DAComPtr<IServiceProvider> sp;
        CComPtr<IHTMLWindow2> htmlWindow;
        CComPtr<IHTMLDocument2> htmlDoc;
        CComPtr<IHTMLElementCollection> allElements;
        CComPtr<IHTMLStyle> style;

        // Grab the collection of all elements on the page
        if (!GetCurrentServiceProvider(&sp) || !sp)
            return E_FAIL;

        HR_IF_FAILED(sp->QueryService(SID_SHTMLWindow,
                                      IID_IHTMLWindow2,
                                      (void **) &htmlWindow));
        HR_IF_FAILED(htmlWindow->get_document(&htmlDoc));
        HR_IF_FAILED(htmlDoc->get_all(&allElements));
                        
        VARIANT varName;
        varName.vt = VT_BSTR;
        varName.bstrVal = makeBSTR(_propertyPath);
        VARIANT varIndex;
        VariantInit( &varIndex );
        CComPtr<IDispatch>    disp;
        CComPtr<IHTMLElement> element;

        // Find the named item we're looking for,
        // and grab its' style.
        if (FAILED(hr = allElements->item(varName, varIndex,
                                          &disp)) ||
                
            // There's a Trident bug (43078) that has the item()
            // method called above returning S_OK even if it
            // doesn't find the item.  Therefore, check for this
            // case explicitly. 
            (disp.p == NULL)) {
                
            ::SysFreeString(varName.bstrVal);
            return hr;
                
        }

        ::SysFreeString(varName.bstrVal);
                
        HR_IF_FAILED(disp->QueryInterface(IID_IHTMLElement,
                                          (void **)&element));
                
        HR_IF_FAILED(element->get_style(&style));

        // This is where the stuff separate from the
        // cache comes in.
        double xVal, yVal;
        HR_IF_FAILED(yankCoords(sampleVal, &xVal, &yVal));

        if (_convertToPixel) {
            // Convert the x and y values, which are coming in
            // interpreted as meters, into pixel values.  Also invert
            // y, since pixel mode y is positive down.
            // Could cache this value, but it's so cheap, there's no
            // need to.
            xVal = NumToPixel(xVal);
            yVal = NumToPixelY(yVal);
        }

        // Do the x coordinate
        long newVal = (long)xVal;
        long oldVal;
        HR_IF_FAILED(style->get_pixelLeft(&oldVal));

        // Note that Trident has this weird behavior of reporting a
        // position of 0 for the initial position even when that's not
        // where it is.  Work around this by forcing the setting on
        // the first time through.
        if (newVal != oldVal || _firstTimeVtblSetting) {
            HR_IF_FAILED(style->put_pixelLeft(newVal));
        }


        // Do the y coordinate
        newVal = (long)yVal;
        HR_IF_FAILED(style->get_pixelTop(&oldVal));

        if (newVal != oldVal || _firstTimeVtblSetting) {
            HR_IF_FAILED(style->put_pixelTop(newVal));
        }

        _firstTimeVtblSetting = false;

        return hr;
                    
    }
        
    
    int BuildUpPointScript(IDABehavior *sampleVal) {
        HRESULT hr;
        double             xValue;
        double             yValue;
        char               xString[25];
        char               yString[25];

        hr = yankCoords(sampleVal, &xValue, &yValue);
        if (FAILED(hr)) {
            return 0;
        }

        // Don't want fractions on this, since it is always position. 
        StringFromDouble(xValue, xString, false);
        StringFromDouble(yValue, yString, false);

        if (_invokeAsMethod) {

            // Include fudge factor for additional characters.
            int scriptLen = lstrlen(_propertyPath) +
                            lstrlen(xString) + lstrlen(yString) + 25;

            if (scriptLen > MAX_SCRIPT_LEN) {
                RaiseException_UserError(E_INVALIDARG,
                                   IDS_ERR_SRV_SCRIPT_STRING_TOO_LONG,
                                   scriptLen);
            }
                
            // If invoking as a method, we'll just form the string
            // according to the proper language.
            switch (_scriptingLanguage) {
              case VBSCRIPT:
                wsprintf(_scriptStrings[0], "%s %s, %s",
                         _propertyPath, xString, yString);
                break;

              case JSCRIPT:
                wsprintf(_scriptStrings[0], "%s(%s, %s);",
                         _propertyPath, xString, yString);
                break;

              case OTHER:
                RaiseException_UserError(E_FAIL, IDS_ERR_SRV_BAD_SCRIPTING_LANG);
                break;
            }

            return 1;
            
        } else {

            // include fudge factor for additional characters
            int scriptLen =
                lstrlen(_propertyPath) + lstrlen(xString) + 25;
            
            if (scriptLen > MAX_SCRIPT_LEN) {
                RaiseException_UserError(E_INVALIDARG,
                                   IDS_ERR_SRV_SCRIPT_STRING_TOO_LONG,
                                   scriptLen);
            }
                
            wsprintf(_scriptStrings[0], "%s.style.left = %s%s",
                     _propertyPath, xString,
                     (_scriptingLanguage == JSCRIPT) ? ";" : "");

            wsprintf(_scriptStrings[1], "%s.style.top = %s%s",
                     _propertyPath, yString,
                     (_scriptingLanguage == JSCRIPT) ? ";" : "");

            return 2;
        }
                
    }
    
    int BuildUpStringScript(IDABehavior *sampleVal) {
        HRESULT hr;
        CComPtr<IDAString> strBvr;

        NULL_IF_FAILED(sampleVal->QueryInterface(IID_IDAString,
                                                 (void **)&strBvr));
        
        BSTR extractedStringBSTR;
        NULL_IF_FAILED(strBvr->Extract(&extractedStringBSTR));

        // Don't worry about deleting the result of extract, only
        // valid for this call.

        USES_CONVERSION;
        ConstructSinglePropertyString(W2A(extractedStringBSTR), true, false);

        ::SysFreeString(extractedStringBSTR);

        return 1;
    }

    int BuildUpNumberScript(IDABehavior *sampleVal) {
        HRESULT hr;
        CComPtr<IDANumber> numBvr;

        NULL_IF_FAILED(sampleVal->QueryInterface(IID_IDANumber,
                                                 (void **)&numBvr));
        
        double extractedNumber;
        NULL_IF_FAILED(numBvr->Extract(&extractedNumber));

        char numberString[25];
        StringFromDouble(extractedNumber, numberString, true);

        ConstructSinglePropertyString(numberString, false, false);

        return 1;
    }

    
    int BuildUpColorScript(IDABehavior *sampleVal) {
        HRESULT hr;
        CComPtr<IDAColor> colBvr;

        NULL_IF_FAILED(sampleVal->QueryInterface(IID_IDAColor,
                                                 (void **)&colBvr));
        
        CComPtr<IDANumber> rBvr;
        CComPtr<IDANumber> gBvr;
        CComPtr<IDANumber> bBvr;
        colBvr->get_Red(&rBvr);
        colBvr->get_Green(&gBvr);
        colBvr->get_Blue(&bBvr);
        
        double redNumber;
        double greenNumber;
        double blueNumber;

        NULL_IF_FAILED(rBvr->Extract(&redNumber));
        NULL_IF_FAILED(gBvr->Extract(&greenNumber));
        NULL_IF_FAILED(bBvr->Extract(&blueNumber));
        
        char buf[256];
        ZeroMemory(buf,sizeof(buf));
        wsprintf(buf,"\"#%02x%02x%02x\"",(int)(redNumber*255), (int)(greenNumber*255),(int)(blueNumber*255));

        // Don't worry about deleting the result of extract, only
        // valid for this call.

        ConstructSinglePropertyString(buf, false, true);

        return 1;
    }
    
    void
    ConstructSinglePropertyString(char *propertyValueString, bool insertQuotes, bool setColor) {

        // include fudge factor for additional characters
        int scriptLen =
            lstrlen(_propertyPath) + lstrlen(propertyValueString) + 25;
            
        if (scriptLen > MAX_SCRIPT_LEN) {
            RaiseException_UserError(E_INVALIDARG,
                               IDS_ERR_SRV_SCRIPT_STRING_TOO_LONG,
                               scriptLen);
        }

        char *qval;
        if(insertQuotes) 
            qval = "'";
        else
            qval = "";

        if (_invokeAsMethod) {

            // If invoking as a method, we'll just do
            switch (_scriptingLanguage) {
              case VBSCRIPT:
                if(setColor)
                    wsprintf(_scriptStrings[0], "%s = \"%s%s%s\"", _propertyPath, qval, propertyValueString, qval);
                else
                    wsprintf(_scriptStrings[0], "%s %s%s%s", _propertyPath, qval, propertyValueString, qval);
                break;

              case JSCRIPT:
                if(setColor)
                    wsprintf(_scriptStrings[0], "%s = \'%s%s%s\';", _propertyPath, qval, propertyValueString, qval);
                else
                    wsprintf(_scriptStrings[0], "%s(%s%s%s);", _propertyPath, qval, propertyValueString, qval);
              
                break;

              case OTHER:
                RaiseException_UserError(E_FAIL, IDS_ERR_SRV_BAD_SCRIPTING_LANG);
                break;
            }
                
        } else {

            // Setting as a property.  All scripting languages (that
            // we know of) support this syntax.
            wsprintf(_scriptStrings[0], "%s = %s%s%s%s",
                     _propertyPath, qval, propertyValueString, qval,
                     (_scriptingLanguage == JSCRIPT) ? ";" : "");

        }

    }
    
    long                   _cRef;
    char *                 _propertyPath;
    LPSTR                 _scriptingLanguageStr;
    ScriptingLanguageType  _scriptingLanguage;
    VARIANT_BOOL           _invokeAsMethod;
    double                 _minUpdateInterval;
    double                 _lastInvocation;
    BehaviorType           _bvrType;
    bool                   _firstTimeVtblSetting;
    bool                   _convertToPixel;

    char                   _firstScriptString[MAX_SCRIPT_LEN];
    char                   _secondScriptString[MAX_SCRIPT_LEN];
    char                  *_scriptStrings[2];

    // TODO: Reintroduce caching of this ONLY if we yank it after
    // SetClientSite(NULL) occurs.  That is, we can't effectively do a
    // Release on it after that happens.
//    CComPtr<IHTMLStyle>    _style;
};


HRESULT
AnimatePropertyCommonCase(CPropAnimHook::BehaviorType type,
                          IDABehavior *origBvr,
                          BSTR propertyPath,
                          BSTR scriptingLanguage,
                          bool invokeAsMethod,
                          double minUpdateInterval,
                          void **resultTypedBvr,
                          bool convertToPixel)
{
    if (!resultTypedBvr) {
        return E_POINTER;
    }

    *resultTypedBvr = NULL;
    
    // First, build up a behavior hook that will be invoked on every
    // sampling.
    DAComPtr<IDABvrHook> hook(NEW CPropAnimHook(propertyPath,
                                                scriptingLanguage,
                                                invokeAsMethod,
                                                minUpdateInterval,
                                                type,
                                                convertToPixel),
                              false);

    if (!hook) return E_OUTOFMEMORY;
    
    DAComPtr<IDABehavior> newBvr;
    
    // Then let the new behavior be the original bvr hooked.
    HRESULT hr = origBvr->Hook(hook, &newBvr);

    if (SUCCEEDED(hr)) {
        GUID iid;
        switch (type) {
          case CPropAnimHook::NUMBER:
            iid = IID_IDANumber;
            break;

          case CPropAnimHook::STRING:
            iid = IID_IDAString;
            break;
            
          case CPropAnimHook::POINT:
            iid = IID_IDAPoint2;
            break;

          case CPropAnimHook::COLOR:
            iid = IID_IDA2Color;
            break;

          default:
            Assert (!"Invalid type past to AnimatePropertyCommonCase");
        }
        
        hr = newBvr->QueryInterface(iid, resultTypedBvr);
    }

    return hr;
}

HRESULT
Point2AnimateControlPosition(IDAPoint2 *pt,
                             BSTR propertyPath,
                             BSTR scriptingLanguage,
                             bool invokeAsMethod,
                             double minUpdateInterval,
                             IDAPoint2 **newPt,
                             bool convertToPixel)
{
    return AnimatePropertyCommonCase(CPropAnimHook::POINT,
                                     pt,
                                     propertyPath,
                                     scriptingLanguage,
                                     invokeAsMethod,
                                     minUpdateInterval,
                                     (void **) newPt,
                                     convertToPixel);
}


HRESULT
NumberAnimateProperty(IDANumber *num,
                      BSTR propertyPath,
                      BSTR scriptingLanguage,
                      bool invokeAsMethod,
                      double minUpdateInterval,
                      IDANumber **newNum)
{
    return AnimatePropertyCommonCase(CPropAnimHook::NUMBER,
                                     num,
                                     propertyPath,
                                     scriptingLanguage,
                                     invokeAsMethod,
                                     minUpdateInterval,
                                     (void **) newNum,
                                     false);
}

HRESULT
StringAnimateProperty(IDAString *str,
                      BSTR propertyPath,
                      BSTR scriptingLanguage,
                      bool invokeAsMethod,
                      double minUpdateInterval,
                      IDAString **newStr)
{
    return AnimatePropertyCommonCase(CPropAnimHook::STRING,
                                     str,
                                     propertyPath,
                                     scriptingLanguage,
                                     invokeAsMethod,
                                     minUpdateInterval,
                                     (void **) newStr,
                                     false);
}

HRESULT
ColorAnimateProperty(IDA2Color *col,
                      BSTR propertyPath,
                      BSTR scriptingLanguage,
                      bool invokeAsMethod,
                      double minUpdateInterval,
                      IDA2Color **newCol)
{
    return AnimatePropertyCommonCase(CPropAnimHook::COLOR,
                                     col,
                                     propertyPath,
                                     scriptingLanguage,
                                     invokeAsMethod,
                                     minUpdateInterval,
                                     (void **) newCol,
                                     false);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\propanim.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Headers for property animation functions

*******************************************************************************/


#ifndef _PROPANIM_H
#define _PROPANIM_H

HRESULT
Point2AnimateControlPosition(IDAPoint2 *pt,
                             BSTR propertyPath,
                             BSTR scriptingLanguage,
                             bool invokeAsMethod,
                             double minUpdateInterval,
                             IDAPoint2 **newPt,
                             bool convertToPixel);

HRESULT
NumberAnimateProperty(IDANumber *num,
                      BSTR propertyPath,
                      BSTR scriptingLanguage,
                      bool invokeAsMethod,
                      double minUpdateInterval,
                      IDANumber **newNum);

HRESULT
StringAnimateProperty(IDAString *str,
                      BSTR propertyPath,
                      BSTR scriptingLanguage,
                      bool invokeAsMethod,
                      double minUpdateInterval,
                      IDAString **newStr);

HRESULT
ColorAnimateProperty(IDA2Color *col,
                      BSTR propertyPath,
                      BSTR scriptingLanguage,
                      bool invokeAsMethod,
                      double minUpdateInterval,
                      IDA2Color **newCol);



#endif /* _PROPANIM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\srvprims.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _SRVPRIMS_H
#define _SRVPRIMS_H

#include "engine.h"
#include "cbvr.h"

#pragma warning(disable:4102)  // unreferenced label

#define SET_NULL(x) {if (x) *(x) = NULL;}

#define CHECK_RETURN_NULL(x) {if (!(x)) return E_POINTER;}
#define CHECK_RETURN_SET_NULL(x) {if (!(x)) { return E_POINTER ;} else {*(x) = NULL;}}

class CRLockGrabber
{
  public:
    CRLockGrabber() { CRAcquireGCLock(); }
    ~CRLockGrabber() { CRReleaseGCLock(); }
};

#define PRECODE(x) \
    {\
        CRLockGrabber __gclg; \
        x
                                         
#define POSTCODE(b) \
      done: \
        return (b);\
    }

#define PRIMPRECODE(x) PRECODE(x)
#define PRIMPOSTCODE(x) POSTCODE(x)

#define PRIMPRECODE0(b) PRECODE(bool b = false)
#define PRIMPOSTCODE0(b) POSTCODE((b)?S_OK:Error())

#define PRIMPRECODE1(ret) \
    CHECK_RETURN_SET_NULL(ret);\
    PRECODE(0)
              
#define PRIMPOSTCODE1(ret) PRIMPOSTCODE0(*ret)

#define PRIMPRECODE2(ret1,ret2) \
    CHECK_RETURN_SET_NULL(ret1); \
    CHECK_RETURN_SET_NULL(ret2); \
    PRECODE(0)
                                                                
#define PRIMPOSTCODE2(ret1,ret2) PRIMPOSTCODE0(*ret1 && *ret2)

#endif /* _SRVPRIMS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\statics.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Methods on the statics, always available, therefore called Statics.

*******************************************************************************/


#include "headers.h"
#include "srvprims.h"
#include "results.h"
#include "comcb.h"
#include "version.h"
#include "statics.h"
#include "drawsurf.h"
#include "privinc/util.h"
#include <mshtml.h>

DeclareTag(tagStatics, "CDAStatics", "IDAStatics methods");

//+-------------------------------------------------------------------------
//
//  Method:     CDAStatics::CDAStatics
//
//  Synopsis:   Constructor
//
//  Arguments:  
//
//--------------------------------------------------------------------------

CDAStatics::CDAStatics()
: _bPixelMode(false),
  _clientSiteURL(NULL),
  _dwModBvrFlags(0)
{
    TraceTag((tagStatics, "CDAStatics::CDAStatics(%lx)", this));
}

ULONG
CDAStatics::InternalRelease()
{
    // InternalRelease doesn't return the ref count, use m_dwRef
    // probably returns the result of InterlockedDecrement
    ULONG i =
        CComObjectRootEx<CComMultiThreadModel>::InternalRelease(); 
    
    if (m_dwRef==1) {
        CRRemoveSite(this);
    }

    return i;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDAStatics::~CDAStatics
//
//  Synopsis:   Destructor
//
//  Arguments:  
//
//--------------------------------------------------------------------------

CDAStatics::~CDAStatics()
{
    TraceTag((tagStatics, "CDAStatics::~CDAStatics(%lx)", this));
    delete _clientSiteURL;
    // NEVER PUT THE REMOVE SITE CALL HERE - not MT safe
}

HRESULT
CDAStatics::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return CComCoClass<CDAStatics, &CLSID_DAStatics>::Error(str,
                                                                IID_IDAStatics,
                                                                hr);
    else
        return hr;
}

STDMETHODIMP
CDAStatics::TriggerEvent(IDAEvent *event, IDABehavior *data)
{
    TraceTag((tagCOMEntry, "CDAStatics::(%lx)", this));
    
    PRIMPRECODE0(ok);
    MAKE_BVR_TYPE_NAME(CREventPtr, crevent, event);
    CRBvrPtr crdata;

    if (data) {
        crdata = GetBvr(data);
        if (crdata == NULL) goto done;
    } else {
        crdata = NULL;
    }

    ok = CRTriggerEvent(crevent, crdata);

    PRIMPOSTCODE0(ok);
}

STDMETHODIMP
CDAStatics::ImportImage(LPOLESTR url,
                        IDAImage **ppImage)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportImage(%lx)", this));
    
    PRIMPRECODE1(ppImage);

    CRImagePtr img;
    DAComPtr<IBindHost> bh(GetBindHost(), false);
    
    DWORD id = CRImportImage(GetURLOfClientSite(),
                             url,
                             this,
                             bh,
                             false,
                             0,
                             0,
                             0,
                             NULL,
                             &img,
                             NULL,
                             NULL,
                             NULL);
    if (id)
    {
        CreateCBvr(IID_IDAImage, (CRBvrPtr) img, (void **) ppImage);
    }
        
    PRIMPOSTCODE1(ppImage);
}

STDMETHODIMP
CDAStatics::ImportImageAsync(LPOLESTR url,
                             IDAImage *pImageStandIn,
                             IDAImportationResult **ppResult)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportImageAsync(%lx)", this));
    
    PRIMPRECODE1(ppResult);

    DAComPtr<IBindHost> bh(GetBindHost(), false);
    MAKE_BVR_TYPE_NAME(CRImagePtr, standin, pImageStandIn);
    CRImagePtr pImage;
    CREventPtr pEvent;
    CRNumberPtr pProgress;
    CRNumberPtr pSize;

    DWORD id;

    id = CRImportImage(GetURLOfClientSite(),
                       url,
                       this,
                       bh,
                       false,
                       0,
                       0,
                       0,
                       standin,&pImage,
                       &pEvent,&pProgress, &pSize);

    if (id)
    {
        CDAImportationResult::Create(pImage,
                                     NULL,
                                     NULL,
                                     NULL,
                                     pEvent,
                                     pProgress,
                                     pSize,
                                     ppResult);
    }

    PRIMPOSTCODE1(ppResult);
}

STDMETHODIMP
CDAStatics::ImportImageColorKey(LPOLESTR url,
                                BYTE ckRed,
                                BYTE ckGreen,
                                BYTE ckBlue,
                                IDAImage **ppImage)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportImageColorKey(%lx)", this));
    
    PRIMPRECODE1(ppImage);

    DAComPtr<IBindHost> bh(GetBindHost(), false);
    CRImagePtr img;
    
    DWORD id;
    id = CRImportImage(GetURLOfClientSite(),
                             url,
                             this,
                             bh,
                             true,
                             ckRed,
                             ckGreen,
                             ckBlue,
                             NULL,
                             &img,
                             NULL,
                             NULL,
                             NULL);
    if(id)
    {
        CreateCBvr(IID_IDAImage, (CRBvrPtr) img, (void **) ppImage);
    }
        
    PRIMPOSTCODE1(ppImage);
}


STDMETHODIMP
CDAStatics::ImportImageAsyncColorKey(LPOLESTR url,
                                     IDAImage *pImageStandIn,
                                     BYTE ckRed,
                                     BYTE ckGreen,
                                     BYTE ckBlue,
                                     IDAImportationResult **ppResult)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportImageAsyncColorKey(%lx)", this));
    
    PRIMPRECODE1(ppResult);

    DAComPtr<IBindHost> bh(GetBindHost(), false);
    MAKE_BVR_TYPE_NAME(CRImagePtr, standin, pImageStandIn);
    CRImagePtr pImage;
    CREventPtr pEvent;
    CRNumberPtr pProgress;
    CRNumberPtr pSize;

    DWORD id;
    id = CRImportImage(GetURLOfClientSite(),
                             url,
                             this,
                             bh,
                             true, ckRed, ckGreen, ckBlue,
                             standin,&pImage,
                             &pEvent,&pProgress, &pSize);
    
    if (id)
    {
        CDAImportationResult::Create(pImage,
                                     NULL,
                                     NULL,
                                     NULL,
                                     pEvent,
                                     pProgress,
                                     pSize,
                                     ppResult);
    }

    PRIMPOSTCODE1(ppResult);
}

HRESULT
CDAStatics::DoImportMovie(LPOLESTR url,
                          IDAImportationResult **ppResult, 
                          bool stream)
{
    PRIMPRECODE1(ppResult);

    DAComPtr<IBindHost> bh(GetBindHost(), false);
    CRImagePtr pImage;
    CRSoundPtr pSound;
    CRNumberPtr pDuration;

    DWORD id;
    id = CRImportMovie(GetURLOfClientSite(),
                             url,
                             this,
                             bh,
                             stream,
                             NULL,
                             NULL,
                             &pImage,
                             &pSound,
                             &pDuration,
                             NULL,
                             NULL,
                             NULL);
    
    if (id)
    {
        CDAImportationResult::Create(pImage,
                                     pSound,
                                     NULL,
                                     pDuration,
                                     NULL,
                                     NULL,
                                     NULL,
                                     ppResult);
    }

    PRIMPOSTCODE1(ppResult);
}


STDMETHODIMP
CDAStatics::ImportMovieAsync(LPOLESTR url,
                             IDAImage   *pImageStandIn,
                             IDASound   *pSoundStandIn,
                             IDAImportationResult **ppResult)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportMovieAsync(%lx)", this));
    
    PRIMPRECODE1(ppResult);

    DAComPtr<IBindHost> bh(GetBindHost(), false);
    MAKE_BVR_TYPE_NAME(CRImagePtr, imgstandin, pImageStandIn);
    MAKE_BVR_TYPE_NAME(CRSoundPtr, sndstandin, pSoundStandIn);
    CRImagePtr pImage;
    CRSoundPtr pSnd;
    CREventPtr pEvent;
    CRNumberPtr pProgress;
    CRNumberPtr pSize;
    CRNumberPtr pDuration;

    DWORD id;
    id = CRImportMovie(GetURLOfClientSite(),
                             url,
                             this,
                             bh,
                             false,
                             imgstandin,
                             sndstandin,
                             &pImage,&pSnd,
                             &pDuration,
                             &pEvent,&pProgress, &pSize);

    if (id)
    {
        CDAImportationResult::Create(pImage,
                                     pSnd,
                                     NULL,
                                     pDuration,
                                     pEvent,
                                     pProgress,
                                     pSize,
                                     ppResult);
    }

    PRIMPOSTCODE1(ppResult);
}

HRESULT
CDAStatics::DoImportSound(LPOLESTR url,
                          IDAImportationResult **ppResult, 
                          bool stream)
{
    PRIMPRECODE1(ppResult);

    DAComPtr<IBindHost> bh(GetBindHost(), false);
    CRSoundPtr pSound;
    CRNumberPtr pDuration;

    DWORD id;

    id = CRImportSound(GetURLOfClientSite(),
                       url,
                       this,
                       bh,
                       stream,
                       NULL,
                       &pSound,
                       &pDuration,
                       NULL,
                       NULL,
                       NULL);

    if (id)
    {
        CDAImportationResult::Create(NULL,
                                     pSound,
                                     NULL,
                                     pDuration,
                                     NULL,
                                     NULL,
                                     NULL,
                                     ppResult);
    }

    PRIMPOSTCODE1(ppResult);
}


STDMETHODIMP
CDAStatics::ImportSoundAsync(LPOLESTR url,
                             IDASound   *pSoundStandIn,
                             IDAImportationResult **ppResult)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportSoundAsync(%lx)", this));
    
    PRIMPRECODE1(ppResult);

    DAComPtr<IBindHost> bh(GetBindHost(), false);
    MAKE_BVR_TYPE_NAME(CRSoundPtr, sndstandin, pSoundStandIn);
    CRSoundPtr pSnd;
    CREventPtr pEvent;
    CRNumberPtr pProgress;
    CRNumberPtr pSize;
    CRNumberPtr pDuration;

    DWORD id;

    id = CRImportSound(GetURLOfClientSite(),
                             url,
                             this,
                             bh,
                             false,
                             sndstandin,
                             &pSnd,
                             &pDuration,
                             &pEvent,
                             &pProgress,
                             &pSize);

    if (id)
    {
        CDAImportationResult::Create(NULL,
                                     pSnd,
                                     NULL,
                                     pDuration,
                                     pEvent,
                                     pProgress,
                                     pSize,
                                     ppResult);
    }

    PRIMPOSTCODE1(ppResult);
}

STDMETHODIMP
CDAStatics::ImportGeometry(LPOLESTR url,
                           IDAGeometry **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportGeometry(%lx)", this));
    
    PRIMPRECODE1(bvr);

    CRGeometryPtr geo;
    DAComPtr<IBindHost> bh(GetBindHost(), false);
    
    DWORD id;
    id = CRImportGeometry(GetURLOfClientSite(),
                                url,
                                this,
                                bh,
                                NULL,
                                &geo,
                                NULL,
                                NULL,
                                NULL);
    if (id)
    {
        CreateCBvr(IID_IDAGeometry, (CRBvrPtr) geo, (void **) bvr);
    }
        
    PRIMPOSTCODE1(bvr);
}


STDMETHODIMP
CDAStatics::ImportGeometryAsync(LPOLESTR url,
                              IDAGeometry *pGeoStandIn,
                              IDAImportationResult **ppResult)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportGeometryAsync(%lx)", this));
    
    PRIMPRECODE1(ppResult);

    DAComPtr<IBindHost> bh(GetBindHost(), false);
    MAKE_BVR_TYPE_NAME(CRGeometryPtr, geostandin, pGeoStandIn);
    CRGeometryPtr pGeometry;
    CREventPtr pEvent;
    CRNumberPtr pProgress;
    CRNumberPtr pSize;

    DWORD id;
    id = CRImportGeometry(GetURLOfClientSite(),
                          url,
                          this,
                          bh,
                          geostandin,
                          &pGeometry,
                          &pEvent,
                          &pProgress,
                          &pSize);

    if (id)
    {
        CDAImportationResult::Create(NULL,
                                     NULL,
                                     pGeometry,
                                     NULL,
                                     pEvent,
                                     pProgress,
                                     pSize,
                                     ppResult);
    }

    PRIMPOSTCODE1(ppResult);
}

STDMETHODIMP
CDAStatics::ImportDirectDrawSurface(IUnknown *dds,
                                    IDAEvent *updateEvent,
                                    IDAImage **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportDirectDrawSurface(%lx)", this));
    
    PRIMPRECODE1(bvr) ;

    CHECK_RETURN_NULL(dds);
    
    CREventPtr crevent;
    if(updateEvent) {
        crevent = (CREventPtr) ::GetBvr(updateEvent);
        if (!crevent) goto done;
    } else {
        crevent = NULL;
    }

    CRImagePtr img;

    img = CRImportDirectDrawSurface(dds, crevent);

    if (img) {
        CreateCBvr(IID_IDAImage,
                   (CRBvrPtr) img,
                   (void **) bvr) ;
    }

    PRIMPOSTCODE1(bvr) ;
}


STDMETHODIMP
CDAStatics::get_AreBlockingImportsComplete(VARIANT_BOOL *bComplete)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_AreBlockingImportsComplete(%lx)", this));
    
    CHECK_RETURN_NULL(bComplete);

    CritSectGrabber csg(_cs);

    *bComplete = _importList.size() == 0;

    return S_OK;
}

STDMETHODIMP
CDAStatics::Cond(IDABoolean *c,
                 IDABehavior *i,
                 IDABehavior *e,
                 IDABehavior **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::Cond(%lx)", this));
    
    PRIMPRECODE1(bvr) ;

    MAKE_BVR_TYPE_NAME(CRBooleanPtr, crcond, c);
    MAKE_BVR_NAME(cri, i);
    MAKE_BVR_NAME(cre, e);

    *bvr = CreateCBvr(CRCond(crcond, cri, cre));

    PRIMPOSTCODE1(bvr) ;
}

STDMETHODIMP
CDAStatics::DAArrayEx2(long size, IDABehavior *pCBvrs[], DWORD dwFlags, IDAArray **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::DAArrayEx2(%lx)", this));
    
    PRIMPRECODE1(bvr);

    CHECK_RETURN_NULL(pCBvrs);

    CreateCBvr(IID_IDAArray,
               (CRBvrPtr) ToArrayBvr(size, pCBvrs, dwFlags),
               (void **) bvr);
    
    PRIMPOSTCODE1(bvr) ;
}

STDMETHODIMP
CDAStatics::DAArray2(VARIANT pBvrs, DWORD dwFlags, IDAArray **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::DAArray2(%lx)", this));
    
    PRIMPRECODE1(bvr);
    CreateCBvr(IID_IDAArray,
               (CRBvrPtr) ::SrvArrayBvr(pBvrs,
                                        false,
                                        CRUNKNOWN_TYPEID,
                                        dwFlags),
               (void **) bvr);
    PRIMPOSTCODE1(bvr) ;
}

STDMETHODIMP
CDAStatics::DATupleEx(long size, IDABehavior *pCBvrs[], IDATuple **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::DATupleEx(%lx)", this));
    
    PRIMPRECODE1(bvr);

    CHECK_RETURN_NULL(pCBvrs);

    CRBvrPtr * arr = CBvrsToBvrs(size,pCBvrs);

    if (arr) {
        CreateCBvr(IID_IDATuple,
                   (CRBvrPtr) ::CRCreateTuple(size, arr),
                   (void **)bvr) ;
    }
    
    PRIMPOSTCODE1(bvr);
}

STDMETHODIMP
CDAStatics::DATuple(VARIANT pBvrs, IDATuple **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::DATuple(%lx)", this));
    
    PRIMPRECODE1(bvr);
    SafeArrayAccessor acc(pBvrs,GetPixelMode());

    CRBvrPtr * arr = 
        (acc.GetNumObjects()>0) ? 
        acc.ToBvrArray((CRBvrPtr *)_alloca(acc.GetNumObjects() * sizeof(CRBvrPtr)))
        : NULL;
    
    if (arr == NULL) goto done;

    if (acc.IsOK()) {
        CreateCBvr(IID_IDATuple,
                   (CRBvrPtr) CRCreateTuple(acc.GetNumObjects(), arr),
                   (void **)bvr) ;
    }
    
    PRIMPOSTCODE1(bvr);
}

STDMETHODIMP
CDAStatics::ModifiableBehavior(IDABehavior *orig, IDABehavior **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::ModifiableBehavior(%lx)", this));
    
    PRIMPRECODE1(bvr) ;

    MAKE_BVR_NAME(crbvr, orig);

    *bvr = CreateCBvr(CRModifiableBvr(crbvr, _dwModBvrFlags));

    PRIMPOSTCODE1(bvr) ;
}

// TODO: Factor out the code
STDMETHODIMP
CDAStatics::UninitializedArray(IDAArray *typeTmp, IDAArray **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::UninitializedArray(%lx)", this));
    
    PRIMPRECODE1(bvr);

    MAKE_BVR_TYPE_NAME(CRArrayPtr, crarr, typeTmp);

    CreateCBvr(IID_IDAArray,
               (CRBvrPtr) CRUninitializedArray(crarr),
               (void **)bvr);

    PRIMPOSTCODE1(bvr);
}

STDMETHODIMP
CDAStatics::UninitializedTuple(IDATuple *typeTmp, IDATuple **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::UninitializedTuple(%lx)", this));
    
    PRIMPRECODE1(bvr);

    MAKE_BVR_TYPE_NAME(CRTuplePtr, crtuple, typeTmp);

    CreateCBvr(IID_IDATuple,
               (CRBvrPtr) CRUninitializedTuple(crtuple),
               (void **)bvr);

    PRIMPOSTCODE1(bvr);
}

HRESULT
CDAStatics::MakeSplineEx(int degree,        
                         long numKnots,        
                         IDANumber *knots[],   
                         long numPts,          
                         IDABehavior *ctrlPoints[],
                         long numWts,          
                         IDANumber *weights[], 
                         IDANumber *evaluator, 
                         CR_BVR_TYPEID tid,
                         REFIID iid,
                         void **bvr)    
{   
    PRIMPRECODE1(bvr) ;
    
    if (numKnots != numPts + degree - 1) {
        return E_INVALIDARG ;             
    }                                     
    
    CRNumberPtr * knotarr;
    knotarr = (CRNumberPtr *) CBvrsToBvrs(numKnots, knots);
    if (knotarr == NULL) goto done;
        
    CRBvrPtr * ptarr;
    ptarr = CBvrsToBvrs(numPts, ctrlPoints);
    if (ptarr == NULL) goto done;
    
    CRNumberPtr * wtsarr;
    if (numWts) {
        wtsarr = (CRNumberPtr *) CBvrsToBvrs(numWts, weights);
        if (wtsarr == NULL) goto done;
    } else {
        wtsarr = NULL;
    }

    MAKE_BVR_TYPE_NAME(CRNumberPtr,eval, evaluator);
    
    CreateCBvr(iid,
               CRBSpline(degree,
                         numKnots,
                         knotarr,
                         numPts,
                         ptarr,
                         numWts,
                         wtsarr,
                         eval,
                         tid),
               bvr) ;  

    PRIMPOSTCODE1(bvr) ;        
}

#define SPLINE_FUNC_EX(METHODNAME, BVRTYPE, TYPEID, BVRIID)     \
 STDMETHODIMP                                                   \
 CDAStatics::METHODNAME(int degree,                             \
                        long numKnots,                          \
                        IDANumber *knots[],                     \
                        long numPts,                            \
                        BVRTYPE *ctrlPoints[],                  \
                        long numWts,                            \
                        IDANumber *weights[],                   \
                        IDANumber *evaluator,                   \
                        BVRTYPE **bvr)                          \
 {                                                              \
    TraceTag((tagCOMEntry, "CDAStatics::SplineCreate(%lx)", this)); \
     return MakeSplineEx(degree,                                \
                       numKnots,                                \
                       knots,                                   \
                       numPts,                                  \
                       (IDABehavior **)ctrlPoints,              \
                       numWts,                                  \
                       weights,                                 \
                       evaluator,                               \
                       TYPEID,                                  \
                       BVRIID,                                  \
                       (void **)bvr);                           \
 }

SPLINE_FUNC_EX(NumberBSplineEx, IDANumber, CRNUMBER_TYPEID, IID_IDANumber);
SPLINE_FUNC_EX(Point2BSplineEx, IDAPoint2, CRPOINT2_TYPEID, IID_IDAPoint2);
SPLINE_FUNC_EX(Point3BSplineEx, IDAPoint3, CRPOINT3_TYPEID, IID_IDAPoint3);
SPLINE_FUNC_EX(Vector2BSplineEx, IDAVector2, CRVECTOR2_TYPEID, IID_IDAVector2);
SPLINE_FUNC_EX(Vector3BSplineEx, IDAVector3, CRVECTOR3_TYPEID, IID_IDAVector3);

HRESULT
CDAStatics::MakeSpline(int degree,        
                       VARIANT knots,
                       VARIANT ctrlPoints,
                       VARIANT weights,
                       IDANumber *evaluator, 
                       CR_BVR_TYPEID tid,
                       REFIID iid,
                       void **bvr)    
{   
    PRIMPRECODE1(bvr) ; 
                                                
    SafeArrayAccessor accKnots(knots,GetPixelMode(),CRNUMBER_TYPEID);
    if (!accKnots.IsOK()) return Error();
    
    SafeArrayAccessor accPoints(ctrlPoints,GetPixelMode(),tid);
    if (!accPoints.IsOK()) return Error();

    SafeArrayAccessor accWeights(weights,GetPixelMode(),CRNUMBER_TYPEID, true);
    if (!accWeights.IsOK()) return Error();

    long numPts = accPoints.GetNumObjects();                
    long numKnots = accKnots.GetNumObjects();               
    long numWts = accWeights.GetNumObjects();               
    
    if (numKnots != numPts + degree - 1) {
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }
    
    CRNumberPtr * knotarr;
    knotarr = (CRNumberPtr *) accKnots.ToBvrArray((CRBvrPtr *)_alloca(numKnots * sizeof(CRBvrPtr)));
    if (knotarr == NULL) goto done;
    
    CRBvrPtr * ptarr;
    ptarr = accPoints.ToBvrArray((CRBvrPtr *)_alloca(numPts * sizeof(CRBvrPtr)));
    if (ptarr == NULL) goto done;
    
    CRNumberPtr * wtsarr;
    wtsarr = (CRNumberPtr *) accWeights.ToBvrArray((CRBvrPtr *)_alloca(numWts * sizeof(CRBvrPtr)));
    if (wtsarr == NULL) goto done;
    
    MAKE_BVR_TYPE_NAME(CRNumberPtr,eval, evaluator);
    
    CreateCBvr(iid,
               CRBSpline(degree,
                         numKnots,
                         knotarr,
                         numPts,
                         ptarr,
                         numWts,
                         numWts?wtsarr:NULL,
                         eval,
                         tid),
               bvr) ;  
    
    PRIMPOSTCODE1(bvr) ;        
}
        
#define SPLINE_FUNC(METHODNAME, BVRTYPE, TYPEID, BVRIID)        \
 STDMETHODIMP                                                   \
 CDAStatics::METHODNAME(int degree,                             \
                        VARIANT knots,                          \
                        VARIANT ctrlPoints,                     \
                        VARIANT weights,                        \
                        IDANumber *evaluator,                   \
                        BVRTYPE **bvr)                          \
 {                                                              \
     return MakeSpline(degree,                                  \
                       knots,                                   \
                       ctrlPoints,                              \
                       weights,                                 \
                       evaluator,                               \
                       TYPEID,                                  \
                       BVRIID,                                  \
                       (void **)bvr);                           \
 }

SPLINE_FUNC(NumberBSpline, IDANumber, CRNUMBER_TYPEID, IID_IDANumber);
SPLINE_FUNC(Point2BSpline, IDAPoint2, CRPOINT2_TYPEID, IID_IDAPoint2);
SPLINE_FUNC(Point3BSpline, IDAPoint3, CRPOINT3_TYPEID, IID_IDAPoint3);
SPLINE_FUNC(Vector2BSpline, IDAVector2, CRVECTOR2_TYPEID, IID_IDAVector2);
SPLINE_FUNC(Vector3BSpline, IDAVector3, CRVECTOR3_TYPEID, IID_IDAVector3);

bool CreatePrim0(REFIID iid, void *fp  , void **ret)
{
    PRIMPRECODE(bool ok = false) ;
    if (!ret) {
        CRSetLastError(E_POINTER, NULL);
        goto done;
    } 
    *ret = NULL;

    ok = CreateCBvr(iid, ((CRBvrPtr (STDAPICALLTYPE *)()) fp)(), ret);
    PRIMPOSTCODE(ok) ;
}

bool CreatePrim1(REFIID iid, void *fp , IDABehavior * arg1 , void **ret)
{
    PRIMPRECODE(bool ok = false) ;
    if (!ret) {
        CRSetLastError(E_POINTER, NULL);
        goto done;
    } 
    *ret = NULL;
    MAKE_BVR_NAME(arg1VAL, arg1);

    ok = CreateCBvr(iid, ((CRBvrPtr (STDAPICALLTYPE *)(CRBvrPtr)) fp)(arg1VAL), ret);
    PRIMPOSTCODE(ok) ;
}

bool CreatePrim2(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2 , void **ret)
{
    PRIMPRECODE(bool ok = false) ;
    if (!ret) {
        CRSetLastError(E_POINTER, NULL);
        goto done;
    } 
    *ret = NULL;
    MAKE_BVR_NAME(arg1VAL, arg1);
    MAKE_BVR_NAME(arg2VAL, arg2);

    ok = CreateCBvr(iid, ((CRBvrPtr (STDAPICALLTYPE *)(CRBvrPtr, CRBvrPtr)) fp)(arg1VAL, arg2VAL), ret);
    PRIMPOSTCODE(ok) ;
}

bool CreatePrim3(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2, IDABehavior * arg3 , void **ret)
{
    PRIMPRECODE(bool ok = false) ;
    if (!ret) {
        CRSetLastError(E_POINTER, NULL);
        goto done;
    } 
    *ret = NULL;
    MAKE_BVR_NAME(arg1VAL, arg1);
    MAKE_BVR_NAME(arg2VAL, arg2);
    MAKE_BVR_NAME(arg3VAL, arg3);

    ok = CreateCBvr(iid, ((CRBvrPtr (STDAPICALLTYPE *)(CRBvrPtr, CRBvrPtr, CRBvrPtr)) fp)(arg1VAL, arg2VAL, arg3VAL), ret);
    PRIMPOSTCODE(ok) ;
}

bool CreatePrim4(REFIID iid, void *fp , IDABehavior * arg1, IDABehavior * arg2, IDABehavior * arg3, IDABehavior * arg4 , void **ret)
{
    PRIMPRECODE(bool ok = false) ;
    if (!ret) {
        CRSetLastError(E_POINTER, NULL);
        goto done;
    } 
    *ret = NULL;
    MAKE_BVR_NAME(arg1VAL, arg1);
    MAKE_BVR_NAME(arg2VAL, arg2);
    MAKE_BVR_NAME(arg3VAL, arg3);
    MAKE_BVR_NAME(arg4VAL, arg4);

    ok = CreateCBvr(iid, ((CRBvrPtr (STDAPICALLTYPE *)(CRBvrPtr, CRBvrPtr, CRBvrPtr, CRBvrPtr)) fp)(arg1VAL, arg2VAL, arg3VAL, arg4VAL), ret);
    PRIMPOSTCODE(ok) ;
}

bool CreateVar(REFIID iid, CRBvrPtr var, void **ret)
{
    PRIMPRECODE(bool ok = false) ;
    if (!ret) {
        CRSetLastError(E_POINTER, NULL);
        goto done;
    } 
    *ret = NULL;
    ok = CreateCBvr(iid, var, ret);
    PRIMPOSTCODE(ok) ;
}

STDMETHODIMP
CDAStatics::Pow(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Pow(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRPow , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Abs(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Abs(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRAbs , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Sqrt(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Sqrt(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRSqrt , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Floor(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Floor(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRFloor , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Round(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Round(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRRound , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Ceiling(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Ceiling(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRCeiling , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Asin(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Asin(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRAsin , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Acos(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Acos(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRAcos , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Atan(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Atan(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRAtan , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Sin(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Sin(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRSin , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Cos(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Cos(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRCos , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Tan(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Tan(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRTan , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Exp(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Exp(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRExp , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Ln(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Ln(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRLn , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Log10(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Log10(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRLog10 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::ToDegrees(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ToDegrees(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRToDegrees , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::ToRadians(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ToRadians(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRToRadians , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Mod(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Mod(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRMod , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Atan2(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Atan2(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRAtan2 , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Add(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Add(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRAdd , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Sub(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Sub(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRSub , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Mul(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Mul(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRMul , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Div(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Div(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRDiv , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::LT(IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::LT(%lx)", this));
    return CreatePrim2(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRLT , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::LTE(IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::LTE(%lx)", this));
    return CreatePrim2(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRLTE , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::GT(IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::GT(%lx)", this));
    return CreatePrim2(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRGT , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::GTE(IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::GTE(%lx)", this));
    return CreatePrim2(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRGTE , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::EQ(IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::EQ(%lx)", this));
    return CreatePrim2(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CREQ , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::NE(IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::NE(%lx)", this));
    return CreatePrim2(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRNE , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Neg(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Neg(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRNeg , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::InterpolateAnim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::InterpolateAnim(%lx)", this));
    return CreatePrim3(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *, CRNumber *, CRNumber *)) CRInterpolate , arg0, arg1, arg2, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Interpolate(double arg0, double arg1, double arg2, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Interpolate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDANumber, (CRBvrPtr) (::CRInterpolate(/* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::SlowInSlowOutAnim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDANumber *  arg3, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SlowInSlowOutAnim(%lx)", this));
    return CreatePrim4(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *, CRNumber *, CRNumber *, CRNumber *)) CRSlowInSlowOut , arg0, arg1, arg2, arg3, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SlowInSlowOut(double arg0, double arg1, double arg2, double arg3, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SlowInSlowOut(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDANumber, (CRBvrPtr) (::CRSlowInSlowOut(/* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ arg2, /* NOELARG */ arg3)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::SoundSource(IDASound *  arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SoundSource(%lx)", this));
    return CreatePrim1(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRSound *)) CRSoundSource , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Mix(IDASound *  arg0, IDASound *  arg1, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Mix(%lx)", this));
    return CreatePrim2(IID_IDASound, (CRSound * (STDAPICALLTYPE *)(CRSound *, CRSound *)) CRMix , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::And(IDABoolean *  arg0, IDABoolean *  arg1, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::And(%lx)", this));
    return CreatePrim2(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRBoolean *, CRBoolean *)) CRAnd , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Or(IDABoolean *  arg0, IDABoolean *  arg1, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Or(%lx)", this));
    return CreatePrim2(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRBoolean *, CRBoolean *)) CROr , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Not(IDABoolean *  arg0, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Not(%lx)", this));
    return CreatePrim1(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRBoolean *)) CRNot , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Integral(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Integral(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRIntegral , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Derivative(IDANumber *  arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Derivative(%lx)", this));
    return CreatePrim1(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRNumber *)) CRDerivative , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::IntegralVector2(IDAVector2 *  arg0, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::IntegralVector2(%lx)", this));
    return CreatePrim1(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRVector2 *)) CRIntegral , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::IntegralVector3(IDAVector3 *  arg0, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::IntegralVector3(%lx)", this));
    return CreatePrim1(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRVector3 *)) CRIntegral , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::DerivativeVector2(IDAVector2 *  arg0, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DerivativeVector2(%lx)", this));
    return CreatePrim1(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRVector2 *)) CRDerivative , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::DerivativeVector3(IDAVector3 *  arg0, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DerivativeVector3(%lx)", this));
    return CreatePrim1(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRVector3 *)) CRDerivative , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::DerivativePoint2(IDAPoint2 *  arg0, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DerivativePoint2(%lx)", this));
    return CreatePrim1(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRPoint2 *)) CRDerivative , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::DerivativePoint3(IDAPoint3 *  arg0, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DerivativePoint3(%lx)", this));
    return CreatePrim1(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRPoint3 *)) CRDerivative , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::KeyState(IDANumber *  arg0, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::KeyState(%lx)", this));
    return CreatePrim1(IID_IDABoolean, (CRBoolean * (STDAPICALLTYPE *)(CRNumber *)) CRKeyState , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::KeyUp(LONG arg0, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::KeyUp(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAEvent, (CRBvrPtr) (::CRKeyUp(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::KeyDown(LONG arg0, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::KeyDown(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAEvent, (CRBvrPtr) (::CRKeyDown(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::DANumber(double arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DANumber(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDANumber, (CRBvrPtr) (::CRCreateNumber(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::DAString(BSTR arg0, IDAString *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DAString(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAString, (CRBvrPtr) (::CRCreateString(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::DABoolean(VARIANT_BOOL arg0, IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DABoolean(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDABoolean, (CRBvrPtr) (::CRCreateBoolean(/* NOELARG */ BOOLTobool(arg0))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::SeededRandom(double arg0, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SeededRandom(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDANumber, (CRBvrPtr) (::CRSeededRandom(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::get_MousePosition(IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_MousePosition(%lx)", this));
    return CreateVar(IID_IDAPoint2, (CRBvrPtr) CRMousePosition(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_LeftButtonState(IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_LeftButtonState(%lx)", this));
    return CreateVar(IID_IDABoolean, (CRBvrPtr) CRLeftButtonState(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_RightButtonState(IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_RightButtonState(%lx)", this));
    return CreateVar(IID_IDABoolean, (CRBvrPtr) CRRightButtonState(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_DATrue(IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_DATrue(%lx)", this));
    return CreateVar(IID_IDABoolean, (CRBvrPtr) CRTrue(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_DAFalse(IDABoolean *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_DAFalse(%lx)", this));
    return CreateVar(IID_IDABoolean, (CRBvrPtr) CRFalse(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_LocalTime(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_LocalTime(%lx)", this));
    return CreateVar(IID_IDANumber, (CRBvrPtr) CRLocalTime(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_GlobalTime(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_GlobalTime(%lx)", this));
    return CreateVar(IID_IDANumber, (CRBvrPtr) CRGlobalTime(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Pixel(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Pixel(%lx)", this));
    return CreateVar(IID_IDANumber, (CRBvrPtr) CRPixel(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::UserData(IUnknown * arg0, IDAUserData *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UserData(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAUserData, (CRBvrPtr) (::CRCreateUserData(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::UntilNotify(IDABehavior *  arg0, IDAEvent *  arg1, IDAUntilNotifier * arg2, IDABehavior *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UntilNotify(%lx)", this));

    PRIMPRECODE1(ret) ;
    DAComPtr<CRUntilNotifier > arg2VAL((CRUntilNotifier *) WrapCRUntilNotifier(arg2),false);
    if (!arg2VAL) return Error();

    CREvent * arg1VAL;
    arg1VAL = (CREvent *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRBvr * arg0VAL;
    arg0VAL = (CRBvr *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDABehavior, (CRBvrPtr) (::CRUntilNotify(arg0VAL, arg1VAL, /* NOELARG */ arg2VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Until(IDABehavior *  arg0, IDAEvent *  arg1, IDABehavior *  arg2, IDABehavior *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Until(%lx)", this));
    return CreatePrim3(IID_IDABehavior, (CRBvr * (STDAPICALLTYPE *)(CRBvr *, CREvent *, CRBvr *)) CRUntil , arg0, arg1, arg2, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::UntilEx(IDABehavior *  arg0, IDAEvent *  arg1, IDABehavior *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UntilEx(%lx)", this));
    return CreatePrim2(IID_IDABehavior, (CRBvr * (STDAPICALLTYPE *)(CRBvr *, CREvent *)) CRUntilEx , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Sequence(IDABehavior *  arg0, IDABehavior *  arg1, IDABehavior *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Sequence(%lx)", this));
    return CreatePrim2(IID_IDABehavior, (CRBvr * (STDAPICALLTYPE *)(CRBvr *, CRBvr *)) CRSequence , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SequenceArrayEx(long size, IDABehavior *  pCBvrs[], IDABehavior *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SequenceArrayEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CHECK_RETURN_NULL(pCBvrs);

    CRBvrPtr * arr = CBvrsToBvrs(size,pCBvrs);

    if (arr) {
        CreateCBvr(IID_IDABehavior,
                   (CRBvrPtr) ::CRSequenceArray(size, arr),
                   (void **)ret) ;
    }
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::SequenceArray(VARIANT pBvrs, IDABehavior *  * bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::SequenceArray(%lx)", this));

    PRIMPRECODE1(bvr);
    SafeArrayAccessor acc(pBvrs,GetPixelMode());

    CRBvrPtr * arr = acc.ToBvrArray((CRBvrPtr *)_alloca(acc.GetNumObjects() * sizeof(CRBvrPtr)));
    if (arr == NULL) goto done;

    if (acc.IsOK()) {
        CreateCBvr(IID_IDABehavior,
                   (CRBvrPtr) CRSequenceArray(acc.GetNumObjects(), arr),
                   (void **)bvr) ;
    }
    
    PRIMPOSTCODE1(bvr);
}

STDMETHODIMP
CDAStatics::FollowPath(IDAPath2 *  arg0, double arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FollowPath(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRPath2 * arg0VAL;
    arg0VAL = (CRPath2 *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRFollowPath(arg0VAL, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::FollowPathAngle(IDAPath2 *  arg0, double arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FollowPathAngle(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRPath2 * arg0VAL;
    arg0VAL = (CRPath2 *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRFollowPathAngle(arg0VAL, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::FollowPathAngleUpright(IDAPath2 *  arg0, double arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FollowPathAngleUpright(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRPath2 * arg0VAL;
    arg0VAL = (CRPath2 *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRFollowPathAngleUpright(arg0VAL, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::FollowPathEval(IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FollowPathEval(%lx)", this));
    return CreatePrim2(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRPath2 *, CRNumber *)) CRFollowPathEval , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::FollowPathAngleEval(IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FollowPathAngleEval(%lx)", this));
    return CreatePrim2(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRPath2 *, CRNumber *)) CRFollowPathAngleEval , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::FollowPathAngleUprightEval(IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FollowPathAngleUprightEval(%lx)", this));
    return CreatePrim2(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRPath2 *, CRNumber *)) CRFollowPathAngleUprightEval , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::FollowPathAnim(IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FollowPathAnim(%lx)", this));
    return CreatePrim2(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRPath2 *, CRNumber *)) CRFollowPath , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::FollowPathAngleAnim(IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FollowPathAngleAnim(%lx)", this));
    return CreatePrim2(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRPath2 *, CRNumber *)) CRFollowPathAngle , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::FollowPathAngleUprightAnim(IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FollowPathAngleUprightAnim(%lx)", this));
    return CreatePrim2(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRPath2 *, CRNumber *)) CRFollowPathAngleUpright , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::UntilNotifyScript(IDABehavior *  arg0, IDAEvent *  arg1, BSTR arg2, IDABehavior *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UntilNotifyScript(%lx)", this));

    PRIMPRECODE1(ret) ;
    CREvent * arg1VAL;
    arg1VAL = (CREvent *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRBvr * arg0VAL;
    arg0VAL = (CRBvr *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDABehavior, (CRBvrPtr) (::UntilNotifyScript(arg0VAL, arg1VAL, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ConcatString(IDAString *  arg0, IDAString *  arg1, IDAString *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ConcatString(%lx)", this));
    return CreatePrim2(IID_IDAString, (CRString * (STDAPICALLTYPE *)(CRString *, CRString *)) CRConcatString , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::PerspectiveCamera(double arg0, double arg1, IDACamera *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::PerspectiveCamera(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDACamera, (CRBvrPtr) (::CRPerspectiveCamera(/* NOELARG */ arg0, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::PerspectiveCameraAnim(IDANumber *  arg0, IDANumber *  arg1, IDACamera *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::PerspectiveCameraAnim(%lx)", this));
    return CreatePrim2(IID_IDACamera, (CRCamera * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRPerspectiveCameraAnim , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::ParallelCamera(double arg0, IDACamera *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ParallelCamera(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDACamera, (CRBvrPtr) (::CRParallelCamera(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ParallelCameraAnim(IDANumber *  arg0, IDACamera *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ParallelCameraAnim(%lx)", this));
    return CreatePrim1(IID_IDACamera, (CRCamera * (STDAPICALLTYPE *)(CRNumber *)) CRParallelCameraAnim , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::ColorRgbAnim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ColorRgbAnim(%lx)", this));
    return CreatePrim3(IID_IDAColor, (CRColor * (STDAPICALLTYPE *)(CRNumber *, CRNumber *, CRNumber *)) CRColorRgb , arg0, arg1, arg2, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::ColorRgb(double arg0, double arg1, double arg2, IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ColorRgb(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAColor, (CRBvrPtr) (::CRColorRgb(/* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ColorRgb255(short arg0, short arg1, short arg2, IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ColorRgb255(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAColor, (CRBvrPtr) (::CRColorRgb255(/* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ColorHsl(double arg0, double arg1, double arg2, IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ColorHsl(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAColor, (CRBvrPtr) (::CRColorHsl(/* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ColorHslAnim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ColorHslAnim(%lx)", this));
    return CreatePrim3(IID_IDAColor, (CRColor * (STDAPICALLTYPE *)(CRNumber *, CRNumber *, CRNumber *)) CRColorHsl , arg0, arg1, arg2, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Red(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Red(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRRed(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Green(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Green(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRGreen(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Blue(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Blue(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRBlue(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Cyan(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Cyan(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRCyan(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Magenta(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Magenta(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRMagenta(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Yellow(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Yellow(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRYellow(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Black(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Black(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRBlack(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_White(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_White(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRWhite(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Aqua(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Aqua(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRAqua(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Fuchsia(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Fuchsia(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRFuchsia(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Gray(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Gray(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRGray(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Lime(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Lime(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRLime(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Maroon(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Maroon(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRMaroon(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Navy(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Navy(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRNavy(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Olive(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Olive(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CROlive(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Purple(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Purple(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRPurple(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Silver(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Silver(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRSilver(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Teal(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Teal(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CRTeal(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Predicate(IDABoolean *  arg0, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Predicate(%lx)", this));
    return CreatePrim1(IID_IDAEvent, (CREvent * (STDAPICALLTYPE *)(CRBoolean *)) CRPredicate , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::NotEvent(IDAEvent *  arg0, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::NotEvent(%lx)", this));
    return CreatePrim1(IID_IDAEvent, (CREvent * (STDAPICALLTYPE *)(CREvent *)) CRNotEvent , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::AndEvent(IDAEvent *  arg0, IDAEvent *  arg1, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::AndEvent(%lx)", this));
    return CreatePrim2(IID_IDAEvent, (CREvent * (STDAPICALLTYPE *)(CREvent *, CREvent *)) CRAndEvent , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::OrEvent(IDAEvent *  arg0, IDAEvent *  arg1, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::OrEvent(%lx)", this));
    return CreatePrim2(IID_IDAEvent, (CREvent * (STDAPICALLTYPE *)(CREvent *, CREvent *)) CROrEvent , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::ThenEvent(IDAEvent *  arg0, IDAEvent *  arg1, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ThenEvent(%lx)", this));
    return CreatePrim2(IID_IDAEvent, (CREvent * (STDAPICALLTYPE *)(CREvent *, CREvent *)) CRThenEvent , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_LeftButtonDown(IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_LeftButtonDown(%lx)", this));
    return CreateVar(IID_IDAEvent, (CRBvrPtr) CRLeftButtonDown(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_LeftButtonUp(IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_LeftButtonUp(%lx)", this));
    return CreateVar(IID_IDAEvent, (CRBvrPtr) CRLeftButtonUp(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_RightButtonDown(IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_RightButtonDown(%lx)", this));
    return CreateVar(IID_IDAEvent, (CRBvrPtr) CRRightButtonDown(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_RightButtonUp(IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_RightButtonUp(%lx)", this));
    return CreateVar(IID_IDAEvent, (CRBvrPtr) CRRightButtonUp(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Always(IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Always(%lx)", this));
    return CreateVar(IID_IDAEvent, (CRBvrPtr) CRAlways(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Never(IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Never(%lx)", this));
    return CreateVar(IID_IDAEvent, (CRBvrPtr) CRNever(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::TimerAnim(IDANumber *  arg0, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::TimerAnim(%lx)", this));
    return CreatePrim1(IID_IDAEvent, (CREvent * (STDAPICALLTYPE *)(CRNumber *)) CRTimer , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Timer(double arg0, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Timer(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAEvent, (CRBvrPtr) (::CRTimer(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::AppTriggeredEvent(IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::AppTriggeredEvent(%lx)", this));
    return CreatePrim0(IID_IDAEvent, (CREvent * (STDAPICALLTYPE *)()) CRAppTriggeredEvent , (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::ScriptCallback(BSTR arg0, IDAEvent *  arg1, BSTR arg2, IDAEvent *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ScriptCallback(%lx)", this));

    PRIMPRECODE1(ret) ;
    CREvent * arg1VAL;
    arg1VAL = (CREvent *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CreateCBvr(IID_IDAEvent, (CRBvrPtr) (::ScriptCallback(/* NOELARG */ arg0, arg1VAL, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::get_EmptyGeometry(IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_EmptyGeometry(%lx)", this));
    return CreateVar(IID_IDAGeometry, (CRBvrPtr) CREmptyGeometry(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::UnionGeometry(IDAGeometry *  arg0, IDAGeometry *  arg1, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UnionGeometry(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRGeometry *, CRGeometry *)) CRUnionGeometry , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::UnionGeometryArrayEx(long sizearg0, IDAGeometry *  arg0[], IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UnionGeometryArrayEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDAGeometry, (CRBvrPtr) (::CRUnionGeometry(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::UnionGeometryArray(VARIANT arg0, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UnionGeometryArray(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRGEOMETRY_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAGeometry, (CRBvrPtr) (::CRUnionGeometry(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::get_EmptyImage(IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_EmptyImage(%lx)", this));
    return CreateVar(IID_IDAImage, (CRBvrPtr) CREmptyImage(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_DetectableEmptyImage(IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_DetectableEmptyImage(%lx)", this));
    return CreateVar(IID_IDAImage, (CRBvrPtr) CRDetectableEmptyImage(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SolidColorImage(IDAColor *  arg0, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SolidColorImage(%lx)", this));
    return CreatePrim1(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRColor *)) CRSolidColorImage , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::GradientPolygonEx(long sizearg0, IDAPoint2 *  arg0[], long sizearg1, IDAColor *  arg1[], IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::GradientPolygonEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg1VAL;
    arg1VAL = ToArrayBvr(sizearg1, (IDABehavior **) arg1);
    if (arg1VAL == NULL) return Error();
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRGradientPolygon(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::GradientPolygon(VARIANT arg0, VARIANT arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::GradientPolygon(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg1VAL;
    arg1VAL = SrvArrayBvr(arg1,GetPixelMode(),CRCOLOR_TYPEID);
    if (!arg1VAL) return Error();

    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRPOINT2_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRGradientPolygon(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::RadialGradientPolygonEx(IDAColor *  arg0,
                                    IDAColor *  arg1,
                                    long sizearg2,
                                    IDAPoint2 *  arg2[],
                                    double arg3,
                                    IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RadialGradientPolygonEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg2VAL;
    arg2VAL = ToArrayBvr(sizearg2, (IDABehavior **) arg2);
    if (arg2VAL == NULL) return Error();
    CRColor * arg1VAL;
    arg1VAL = (CRColor *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRRadialGradientPolygon(arg0VAL, arg1VAL, arg2VAL, /* NOELARG */ arg3)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::RadialGradientPolygon(IDAColor *  arg0,
                                  IDAColor *  arg1,
                                  VARIANT arg2,
                                  double arg3,
                                  IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RadialGradientPolygon(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg2VAL;
    arg2VAL = SrvArrayBvr(arg2,GetPixelMode(),CRPOINT2_TYPEID);
    if (!arg2VAL) return Error();

    CRColor * arg1VAL;
    arg1VAL = (CRColor *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRRadialGradientPolygon(arg0VAL, arg1VAL, arg2VAL, /* NOELARG */ arg3)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::RadialGradientPolygonAnimEx(IDAColor *  arg0, IDAColor *  arg1, long sizearg2, IDAPoint2 *  arg2[], IDANumber *  arg3, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RadialGradientPolygonAnimEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg3VAL;
    arg3VAL = (CRNumber *) (::GetBvr(arg3));
    if (!arg3VAL) return Error();

    CRArrayPtr arg2VAL;
    arg2VAL = ToArrayBvr(sizearg2, (IDABehavior **) arg2);
    if (arg2VAL == NULL) return Error();
    CRColor * arg1VAL;
    arg1VAL = (CRColor *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRRadialGradientPolygon(arg0VAL, arg1VAL, arg2VAL, arg3VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::RadialGradientPolygonAnim(IDAColor *  arg0, IDAColor *  arg1, VARIANT arg2, IDANumber *  arg3, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RadialGradientPolygonAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg3VAL;
    arg3VAL = (CRNumber *) (::GetBvr(arg3));
    if (!arg3VAL) return Error();

    CRArrayPtr arg2VAL;
    arg2VAL = SrvArrayBvr(arg2,GetPixelMode(),CRPOINT2_TYPEID);
    if (!arg2VAL) return Error();

    CRColor * arg1VAL;
    arg1VAL = (CRColor *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRRadialGradientPolygon(arg0VAL, arg1VAL, arg2VAL, arg3VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::GradientSquare(IDAColor *  arg0, IDAColor *  arg1, IDAColor *  arg2, IDAColor *  arg3, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::GradientSquare(%lx)", this));
    return CreatePrim4(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRColor *, CRColor *, CRColor *, CRColor *)) CRGradientSquare , arg0, arg1, arg2, arg3, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::RadialGradientSquare(IDAColor *  arg0, IDAColor *  arg1, double arg2, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RadialGradientSquare(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRColor * arg1VAL;
    arg1VAL = (CRColor *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRRadialGradientSquare(arg0VAL, arg1VAL, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::RadialGradientSquareAnim(IDAColor *  arg0, IDAColor *  arg1, IDANumber *  arg2, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RadialGradientSquareAnim(%lx)", this));
    return CreatePrim3(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRColor *, CRColor *, CRNumber *)) CRRadialGradientSquare , arg0, arg1, arg2, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::RadialGradientRegularPoly(IDAColor *  arg0, IDAColor *  arg1, double arg2, double arg3, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RadialGradientRegularPoly(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRColor * arg1VAL;
    arg1VAL = (CRColor *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRRadialGradientRegularPoly(arg0VAL, arg1VAL, /* NOELARG */ arg2, /* NOELARG */ arg3)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::RadialGradientRegularPolyAnim(IDAColor *  arg0, IDAColor *  arg1, IDANumber *  arg2, IDANumber *  arg3, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RadialGradientRegularPolyAnim(%lx)", this));
    return CreatePrim4(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRColor *, CRColor *, CRNumber *, CRNumber *)) CRRadialGradientRegularPoly , arg0, arg1, arg2, arg3, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::GradientHorizontal(IDAColor *  arg0, IDAColor *  arg1, double arg2, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::GradientHorizontal(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRColor * arg1VAL;
    arg1VAL = (CRColor *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRGradientHorizontal(arg0VAL, arg1VAL, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::GradientHorizontalAnim(IDAColor *  arg0, IDAColor *  arg1, IDANumber *  arg2, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::GradientHorizontalAnim(%lx)", this));
    return CreatePrim3(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRColor *, CRColor *, CRNumber *)) CRGradientHorizontal , arg0, arg1, arg2, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::HatchHorizontal(IDAColor *  arg0, double arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchHorizontal(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchHorizontal(arg0VAL, /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchHorizontalAnim(IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchHorizontalAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchHorizontal(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchVertical(IDAColor *  arg0, double arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchVertical(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchVertical(arg0VAL, /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchVerticalAnim(IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchVerticalAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchVertical(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchForwardDiagonal(IDAColor *  arg0, double arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchForwardDiagonal(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchForwardDiagonal(arg0VAL, /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchForwardDiagonalAnim(IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchForwardDiagonalAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchForwardDiagonal(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchBackwardDiagonal(IDAColor *  arg0, double arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchBackwardDiagonal(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchBackwardDiagonal(arg0VAL, /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchBackwardDiagonalAnim(IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchBackwardDiagonalAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchBackwardDiagonal(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchCross(IDAColor *  arg0, double arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchCross(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchCross(arg0VAL, /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchCrossAnim(IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchCrossAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchCross(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchDiagonalCross(IDAColor *  arg0, double arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchDiagonalCross(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchDiagonalCross(arg0VAL, /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::HatchDiagonalCrossAnim(IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::HatchDiagonalCrossAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRColor * arg0VAL;
    arg0VAL = (CRColor *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRHatchDiagonalCross(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Overlay(IDAImage *  arg0, IDAImage *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Overlay(%lx)", this));
    return CreatePrim2(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRImage *, CRImage *)) CROverlay , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::OverlayArrayEx(long sizearg0, IDAImage *  arg0[], IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::OverlayArrayEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CROverlay(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::OverlayArray(VARIANT arg0, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::OverlayArray(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRIMAGE_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CROverlay(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::get_AmbientLight(IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_AmbientLight(%lx)", this));
    return CreateVar(IID_IDAGeometry, (CRBvrPtr) CRAmbientLight(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_DirectionalLight(IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_DirectionalLight(%lx)", this));
    return CreateVar(IID_IDAGeometry, (CRBvrPtr) CRDirectionalLight(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_PointLight(IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_PointLight(%lx)", this));
    return CreateVar(IID_IDAGeometry, (CRBvrPtr) CRPointLight(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SpotLightAnim(IDANumber *  arg0, IDANumber *  arg1, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SpotLightAnim(%lx)", this));
    return CreatePrim2(IID_IDAGeometry, (CRGeometry * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRSpotLight , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SpotLight(IDANumber *  arg0, double arg1, IDAGeometry *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SpotLight(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAGeometry, (CRBvrPtr) (::CRSpotLight(arg0VAL, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::get_DefaultLineStyle(IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_DefaultLineStyle(%lx)", this));
    return CreateVar(IID_IDALineStyle, (CRBvrPtr) CRDefaultLineStyle(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_EmptyLineStyle(IDALineStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_EmptyLineStyle(%lx)", this));
    return CreateVar(IID_IDALineStyle, (CRBvrPtr) CREmptyLineStyle(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_JoinStyleBevel(IDAJoinStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_JoinStyleBevel(%lx)", this));
    return CreateVar(IID_IDAJoinStyle, (CRBvrPtr) CRJoinStyleBevel(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_JoinStyleRound(IDAJoinStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_JoinStyleRound(%lx)", this));
    return CreateVar(IID_IDAJoinStyle, (CRBvrPtr) CRJoinStyleRound(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_JoinStyleMiter(IDAJoinStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_JoinStyleMiter(%lx)", this));
    return CreateVar(IID_IDAJoinStyle, (CRBvrPtr) CRJoinStyleMiter(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_EndStyleFlat(IDAEndStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_EndStyleFlat(%lx)", this));
    return CreateVar(IID_IDAEndStyle, (CRBvrPtr) CREndStyleFlat(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_EndStyleSquare(IDAEndStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_EndStyleSquare(%lx)", this));
    return CreateVar(IID_IDAEndStyle, (CRBvrPtr) CREndStyleSquare(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_EndStyleRound(IDAEndStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_EndStyleRound(%lx)", this));
    return CreateVar(IID_IDAEndStyle, (CRBvrPtr) CREndStyleRound(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_DashStyleSolid(IDADashStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_DashStyleSolid(%lx)", this));
    return CreateVar(IID_IDADashStyle, (CRBvrPtr) CRDashStyleSolid(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_DashStyleDashed(IDADashStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_DashStyleDashed(%lx)", this));
    return CreateVar(IID_IDADashStyle, (CRBvrPtr) CRDashStyleDashed(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_DefaultMicrophone(IDAMicrophone *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_DefaultMicrophone(%lx)", this));
    return CreateVar(IID_IDAMicrophone, (CRBvrPtr) CRDefaultMicrophone(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_OpaqueMatte(IDAMatte *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_OpaqueMatte(%lx)", this));
    return CreateVar(IID_IDAMatte, (CRBvrPtr) CROpaqueMatte(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_ClearMatte(IDAMatte *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_ClearMatte(%lx)", this));
    return CreateVar(IID_IDAMatte, (CRBvrPtr) CRClearMatte(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::UnionMatte(IDAMatte *  arg0, IDAMatte *  arg1, IDAMatte *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UnionMatte(%lx)", this));
    return CreatePrim2(IID_IDAMatte, (CRMatte * (STDAPICALLTYPE *)(CRMatte *, CRMatte *)) CRUnionMatte , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::IntersectMatte(IDAMatte *  arg0, IDAMatte *  arg1, IDAMatte *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::IntersectMatte(%lx)", this));
    return CreatePrim2(IID_IDAMatte, (CRMatte * (STDAPICALLTYPE *)(CRMatte *, CRMatte *)) CRIntersectMatte , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::DifferenceMatte(IDAMatte *  arg0, IDAMatte *  arg1, IDAMatte *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DifferenceMatte(%lx)", this));
    return CreatePrim2(IID_IDAMatte, (CRMatte * (STDAPICALLTYPE *)(CRMatte *, CRMatte *)) CRDifferenceMatte , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::FillMatte(IDAPath2 *  arg0, IDAMatte *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FillMatte(%lx)", this));
    return CreatePrim1(IID_IDAMatte, (CRMatte * (STDAPICALLTYPE *)(CRPath2 *)) CRFillMatte , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::TextMatte(IDAString *  arg0, IDAFontStyle *  arg1, IDAMatte *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::TextMatte(%lx)", this));
    return CreatePrim2(IID_IDAMatte, (CRMatte * (STDAPICALLTYPE *)(CRString *, CRFontStyle *)) CRTextMatte , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_EmptyMontage(IDAMontage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_EmptyMontage(%lx)", this));
    return CreateVar(IID_IDAMontage, (CRBvrPtr) CREmptyMontage(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::ImageMontage(IDAImage *  arg0, double arg1, IDAMontage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImageMontage(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRImage * arg0VAL;
    arg0VAL = (CRImage *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAMontage, (CRBvrPtr) (::CRImageMontage(arg0VAL, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ImageMontageAnim(IDAImage *  arg0, IDANumber *  arg1, IDAMontage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImageMontageAnim(%lx)", this));
    return CreatePrim2(IID_IDAMontage, (CRMontage * (STDAPICALLTYPE *)(CRImage *, CRNumber *)) CRImageMontageAnim , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::UnionMontage(IDAMontage *  arg0, IDAMontage *  arg1, IDAMontage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UnionMontage(%lx)", this));
    return CreatePrim2(IID_IDAMontage, (CRMontage * (STDAPICALLTYPE *)(CRMontage *, CRMontage *)) CRUnionMontage , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Concat(IDAPath2 *  arg0, IDAPath2 *  arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Concat(%lx)", this));
    return CreatePrim2(IID_IDAPath2, (CRPath2 * (STDAPICALLTYPE *)(CRPath2 *, CRPath2 *)) CRConcat , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::ConcatArrayEx(long sizearg0, IDAPath2 *  arg0[], IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ConcatArrayEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRConcat(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ConcatArray(VARIANT arg0, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ConcatArray(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRPATH2_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRConcat(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Line(IDAPoint2 *  arg0, IDAPoint2 *  arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Line(%lx)", this));
    return CreatePrim2(IID_IDAPath2, (CRPath2 * (STDAPICALLTYPE *)(CRPoint2 *, CRPoint2 *)) CRLine , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Ray(IDAPoint2 *  arg0, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Ray(%lx)", this));
    return CreatePrim1(IID_IDAPath2, (CRPath2 * (STDAPICALLTYPE *)(CRPoint2 *)) CRRay , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::StringPathAnim(IDAString *  arg0, IDAFontStyle *  arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::StringPathAnim(%lx)", this));
    return CreatePrim2(IID_IDAPath2, (CRPath2 * (STDAPICALLTYPE *)(CRString *, CRFontStyle *)) CRStringPath , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::StringPath(BSTR arg0, IDAFontStyle *  arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::StringPath(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRFontStyle * arg1VAL;
    arg1VAL = (CRFontStyle *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRStringPath(/* NOELARG */ arg0, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::PolylineEx(long sizearg0, IDAPoint2 *  arg0[], IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::PolylineEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRPolyline(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Polyline(VARIANT arg0, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Polyline(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRPOINT2_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRPolyline(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::PolydrawPathEx(long sizearg0, IDAPoint2 *  arg0[], long sizearg1, IDANumber *  arg1[], IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::PolydrawPathEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg1VAL;
    arg1VAL = ToArrayBvr(sizearg1, (IDABehavior **) arg1);
    if (arg1VAL == NULL) return Error();
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRPolydrawPath(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::PolydrawPath(VARIANT arg0, VARIANT arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::PolydrawPath(%lx)", this));

    PRIMPRECODE1(ret);

    CRArrayPtr arg1VAL;
    void *d1 = NULL;
    unsigned int n1 = 0;
    arg1VAL = SrvArrayBvr(arg1,GetPixelMode(),CRNUMBER_TYPEID,0,ARRAYFILL_DOUBLE,&d1,&n1);
    if (!arg1VAL && !d1) return Error();

    CRArrayPtr arg0VAL;
    void *d0 = NULL;
    unsigned int n0 = 0;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRPOINT2_TYPEID,0,ARRAYFILL_DOUBLE,&d0,&n0);
    if (!arg0VAL && !d0) return Error();

    CRBvrPtr bvr = NULL;
    if (d0 && d1) {
        bvr = (CRBvrPtr) CRPolydrawPath((double*)d0,n0,(double*)d1,n1);
    } else {
        if (arg0VAL==NULL) {
            Assert(d0);
            arg0VAL = CRCreateArray(n0, (double*)d0, CRPOINT2_TYPEID);
        }

        if (arg1VAL==NULL) {
            Assert(d1);
            arg1VAL = CRCreateArray(n1, (double*)d1, CRNUMBER_TYPEID);
        }

        bvr = (CRBvrPtr) (::CRPolydrawPath(arg0VAL, arg1VAL));
    }

    if (d0) delete d0;
    if (d1) delete d1;

    if (bvr) {
        CreateCBvr(IID_IDAPath2, bvr, (void **) ret);
    } else {
        return Error();
    }

    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ArcRadians(double arg0, double arg1, double arg2, double arg3, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ArcRadians(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRArcRadians(/* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ PixelToNum(arg2), /* NOELARG */ PixelToNum(arg3))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ArcRadiansAnim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDANumber *  arg3, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ArcRadiansAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg3VAL;
    arg3VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg3));
    if (!arg3VAL) return Error();

    CRNumber * arg2VAL;
    arg2VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg2));
    if (!arg2VAL) return Error();

    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRArcRadians(arg0VAL, arg1VAL, arg2VAL, arg3VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ArcDegrees(double arg0, double arg1, double arg2, double arg3, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ArcDegrees(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRArc(/* NOELARG */ DegreesToNum(arg0), /* NOELARG */ DegreesToNum(arg1), /* NOELARG */ PixelToNum(arg2), /* NOELARG */ PixelToNum(arg3))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::PieRadians(double arg0, double arg1, double arg2, double arg3, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::PieRadians(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRPieRadians(/* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ PixelToNum(arg2), /* NOELARG */ PixelToNum(arg3))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::PieRadiansAnim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDANumber *  arg3, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::PieRadiansAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg3VAL;
    arg3VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg3));
    if (!arg3VAL) return Error();

    CRNumber * arg2VAL;
    arg2VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg2));
    if (!arg2VAL) return Error();

    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRPieRadians(arg0VAL, arg1VAL, arg2VAL, arg3VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::PieDegrees(double arg0, double arg1, double arg2, double arg3, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::PieDegrees(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRPie(/* NOELARG */ DegreesToNum(arg0), /* NOELARG */ DegreesToNum(arg1), /* NOELARG */ PixelToNum(arg2), /* NOELARG */ PixelToNum(arg3))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Oval(double arg0, double arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Oval(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CROval(/* NOELARG */ PixelToNum(arg0), /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::OvalAnim(IDANumber *  arg0, IDANumber *  arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::OvalAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CROval(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Rect(double arg0, double arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rect(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRRect(/* NOELARG */ PixelToNum(arg0), /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::RectAnim(IDANumber *  arg0, IDANumber *  arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RectAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRRect(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::RoundRect(double arg0, double arg1, double arg2, double arg3, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RoundRect(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRRoundRect(/* NOELARG */ PixelToNum(arg0), /* NOELARG */ PixelToNum(arg1), /* NOELARG */ PixelToNum(arg2), /* NOELARG */ PixelToNum(arg3))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::RoundRectAnim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDANumber *  arg3, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::RoundRectAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg3VAL;
    arg3VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg3));
    if (!arg3VAL) return Error();

    CRNumber * arg2VAL;
    arg2VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg2));
    if (!arg2VAL) return Error();

    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRRoundRect(arg0VAL, arg1VAL, arg2VAL, arg3VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::CubicBSplinePathEx(long sizearg0, IDAPoint2 *  arg0[], long sizearg1, IDANumber *  arg1[], IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::CubicBSplinePathEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg1VAL;
    arg1VAL = ToArrayBvr(sizearg1, (IDABehavior **) arg1);
    if (arg1VAL == NULL) return Error();
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRCubicBSplinePath(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::CubicBSplinePath(VARIANT arg0, VARIANT arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::CubicBSplinePath(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg1VAL;
    arg1VAL = SrvArrayBvr(arg1,GetPixelMode(),CRNUMBER_TYPEID);
    if (!arg1VAL) return Error();

    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRPOINT2_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPath2, (CRBvrPtr) (::CRCubicBSplinePath(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::TextPath(IDAString *  arg0, IDAFontStyle *  arg1, IDAPath2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::TextPath(%lx)", this));
    return CreatePrim2(IID_IDAPath2, (CRPath2 * (STDAPICALLTYPE *)(CRString *, CRFontStyle *)) CRTextPath , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Silence(IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Silence(%lx)", this));
    return CreateVar(IID_IDASound, (CRBvrPtr) CRSilence(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::MixArrayEx(long sizearg0, IDASound *  arg0[], IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::MixArrayEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDASound, (CRBvrPtr) (::CRMix(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::MixArray(VARIANT arg0, IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::MixArray(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRSOUND_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDASound, (CRBvrPtr) (::CRMix(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::get_SinSynth(IDASound *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_SinSynth(%lx)", this));
    return CreateVar(IID_IDASound, (CRBvrPtr) CRSinSynth(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_DefaultFont(IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_DefaultFont(%lx)", this));
    return CreateVar(IID_IDAFontStyle, (CRBvrPtr) CRDefaultFont(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::FontAnim(IDAString *  arg0, IDANumber *  arg1, IDAColor *  arg2, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::FontAnim(%lx)", this));
    return CreatePrim3(IID_IDAFontStyle, (CRFontStyle * (STDAPICALLTYPE *)(CRString *, CRNumber *, CRColor *)) CRFont , arg0, arg1, arg2, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Font(BSTR arg0, double arg1, IDAColor *  arg2, IDAFontStyle *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Font(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRColor * arg2VAL;
    arg2VAL = (CRColor *) (::GetBvr(arg2));
    if (!arg2VAL) return Error();

    CreateCBvr(IID_IDAFontStyle, (CRBvrPtr) (::CRFont(/* NOELARG */ arg0, /* NOELARG */ arg1, arg2VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::StringImageAnim(IDAString *  arg0, IDAFontStyle *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::StringImageAnim(%lx)", this));
    return CreatePrim2(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRString *, CRFontStyle *)) CRStringImage , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::StringImage(BSTR arg0, IDAFontStyle *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::StringImage(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRFontStyle * arg1VAL;
    arg1VAL = (CRFontStyle *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRStringImage(/* NOELARG */ arg0, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::TextImageAnim(IDAString *  arg0, IDAFontStyle *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::TextImageAnim(%lx)", this));
    return CreatePrim2(IID_IDAImage, (CRImage * (STDAPICALLTYPE *)(CRString *, CRFontStyle *)) CRTextImage , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::TextImage(BSTR arg0, IDAFontStyle *  arg1, IDAImage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::TextImage(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRFontStyle * arg1VAL;
    arg1VAL = (CRFontStyle *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CreateCBvr(IID_IDAImage, (CRBvrPtr) (::CRTextImage(/* NOELARG */ arg0, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::get_XVector2(IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_XVector2(%lx)", this));
    return CreateVar(IID_IDAVector2, (CRBvrPtr) CRXVector2(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_YVector2(IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_YVector2(%lx)", this));
    return CreateVar(IID_IDAVector2, (CRBvrPtr) CRYVector2(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_ZeroVector2(IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_ZeroVector2(%lx)", this));
    return CreateVar(IID_IDAVector2, (CRBvrPtr) CRZeroVector2(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Origin2(IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Origin2(%lx)", this));
    return CreateVar(IID_IDAPoint2, (CRBvrPtr) CROrigin2(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Vector2Anim(IDANumber *  arg0, IDANumber *  arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Vector2Anim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelYToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAVector2, (CRBvrPtr) (::CRCreateVector2(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Vector2(double arg0, double arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Vector2(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAVector2, (CRBvrPtr) (::CRCreateVector2(/* NOELARG */ PixelToNum(arg0), /* NOELARG */ PixelYToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Point2Anim(IDANumber *  arg0, IDANumber *  arg1, IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Point2Anim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelYToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPoint2, (CRBvrPtr) (::CRCreatePoint2(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Point2(double arg0, double arg1, IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Point2(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPoint2, (CRBvrPtr) (::CRCreatePoint2(/* NOELARG */ PixelToNum(arg0), /* NOELARG */ PixelYToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Vector2PolarAnim(IDANumber *  arg0, IDANumber *  arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Vector2PolarAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAVector2, (CRBvrPtr) (::CRVector2Polar(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Vector2Polar(double arg0, double arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Vector2Polar(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAVector2, (CRBvrPtr) (::CRVector2Polar(/* NOELARG */ arg0, /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Vector2PolarDegrees(double arg0, double arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Vector2PolarDegrees(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAVector2, (CRBvrPtr) (::CRVector2Polar(/* NOELARG */ DegreesToNum(arg0), /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Point2PolarAnim(IDANumber *  arg0, IDANumber *  arg1, IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Point2PolarAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPoint2, (CRBvrPtr) (::CRPoint2Polar(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Point2Polar(double arg0, double arg1, IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Point2Polar(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPoint2, (CRBvrPtr) (::CRPoint2Polar(/* NOELARG */ arg0, /* NOELARG */ PixelToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::DotVector2(IDAVector2 *  arg0, IDAVector2 *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DotVector2(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector2 *, CRVector2 *)) CRDot , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::NegVector2(IDAVector2 *  arg0, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::NegVector2(%lx)", this));
    return CreatePrim1(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRVector2 *)) CRNeg , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SubVector2(IDAVector2 *  arg0, IDAVector2 *  arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SubVector2(%lx)", this));
    return CreatePrim2(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRVector2 *, CRVector2 *)) CRSub , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::AddVector2(IDAVector2 *  arg0, IDAVector2 *  arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::AddVector2(%lx)", this));
    return CreatePrim2(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRVector2 *, CRVector2 *)) CRAdd , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::AddPoint2Vector(IDAPoint2 *  arg0, IDAVector2 *  arg1, IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::AddPoint2Vector(%lx)", this));
    return CreatePrim2(IID_IDAPoint2, (CRPoint2 * (STDAPICALLTYPE *)(CRPoint2 *, CRVector2 *)) CRAdd , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SubPoint2Vector(IDAPoint2 *  arg0, IDAVector2 *  arg1, IDAPoint2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SubPoint2Vector(%lx)", this));
    return CreatePrim2(IID_IDAPoint2, (CRPoint2 * (STDAPICALLTYPE *)(CRPoint2 *, CRVector2 *)) CRSub , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SubPoint2(IDAPoint2 *  arg0, IDAPoint2 *  arg1, IDAVector2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SubPoint2(%lx)", this));
    return CreatePrim2(IID_IDAVector2, (CRVector2 * (STDAPICALLTYPE *)(CRPoint2 *, CRPoint2 *)) CRSub , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::DistancePoint2(IDAPoint2 *  arg0, IDAPoint2 *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DistancePoint2(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint2 *, CRPoint2 *)) CRDistance , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::DistanceSquaredPoint2(IDAPoint2 *  arg0, IDAPoint2 *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DistanceSquaredPoint2(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint2 *, CRPoint2 *)) CRDistanceSquared , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_XVector3(IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_XVector3(%lx)", this));
    return CreateVar(IID_IDAVector3, (CRBvrPtr) CRXVector3(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_YVector3(IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_YVector3(%lx)", this));
    return CreateVar(IID_IDAVector3, (CRBvrPtr) CRYVector3(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_ZVector3(IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_ZVector3(%lx)", this));
    return CreateVar(IID_IDAVector3, (CRBvrPtr) CRZVector3(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_ZeroVector3(IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_ZeroVector3(%lx)", this));
    return CreateVar(IID_IDAVector3, (CRBvrPtr) CRZeroVector3(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_Origin3(IDAPoint3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_Origin3(%lx)", this));
    return CreateVar(IID_IDAPoint3, (CRBvrPtr) CROrigin3(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Vector3Anim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Vector3Anim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg2VAL;
    arg2VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg2));
    if (!arg2VAL) return Error();

    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelYToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAVector3, (CRBvrPtr) (::CRCreateVector3(arg0VAL, arg1VAL, arg2VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Vector3(double arg0, double arg1, double arg2, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Vector3(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAVector3, (CRBvrPtr) (::CRCreateVector3(/* NOELARG */ PixelToNum(arg0), /* NOELARG */ PixelYToNum(arg1), /* NOELARG */ PixelToNum(arg2))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Point3Anim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAPoint3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Point3Anim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg2VAL;
    arg2VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg2));
    if (!arg2VAL) return Error();

    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelYToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPoint3, (CRBvrPtr) (::CRCreatePoint3(arg0VAL, arg1VAL, arg2VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Point3(double arg0, double arg1, double arg2, IDAPoint3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Point3(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPoint3, (CRBvrPtr) (::CRCreatePoint3(/* NOELARG */ PixelToNum(arg0), /* NOELARG */ PixelYToNum(arg1), /* NOELARG */ PixelToNum(arg2))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Vector3SphericalAnim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Vector3SphericalAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg2VAL;
    arg2VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg2));
    if (!arg2VAL) return Error();

    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAVector3, (CRBvrPtr) (::CRVector3Spherical(arg0VAL, arg1VAL, arg2VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Vector3Spherical(double arg0, double arg1, double arg2, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Vector3Spherical(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAVector3, (CRBvrPtr) (::CRVector3Spherical(/* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ PixelToNum(arg2))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Point3SphericalAnim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAPoint3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Point3SphericalAnim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg2VAL;
    arg2VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg2));
    if (!arg2VAL) return Error();

    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) (::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAPoint3, (CRBvrPtr) (::CRPoint3Spherical(arg0VAL, arg1VAL, arg2VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Point3Spherical(double arg0, double arg1, double arg2, IDAPoint3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Point3Spherical(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDAPoint3, (CRBvrPtr) (::CRPoint3Spherical(/* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ PixelToNum(arg2))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::DotVector3(IDAVector3 *  arg0, IDAVector3 *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DotVector3(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRVector3 *, CRVector3 *)) CRDot , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::CrossVector3(IDAVector3 *  arg0, IDAVector3 *  arg1, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::CrossVector3(%lx)", this));
    return CreatePrim2(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRVector3 *, CRVector3 *)) CRCross , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::NegVector3(IDAVector3 *  arg0, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::NegVector3(%lx)", this));
    return CreatePrim1(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRVector3 *)) CRNeg , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SubVector3(IDAVector3 *  arg0, IDAVector3 *  arg1, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SubVector3(%lx)", this));
    return CreatePrim2(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRVector3 *, CRVector3 *)) CRSub , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::AddVector3(IDAVector3 *  arg0, IDAVector3 *  arg1, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::AddVector3(%lx)", this));
    return CreatePrim2(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRVector3 *, CRVector3 *)) CRAdd , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::AddPoint3Vector(IDAPoint3 *  arg0, IDAVector3 *  arg1, IDAPoint3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::AddPoint3Vector(%lx)", this));
    return CreatePrim2(IID_IDAPoint3, (CRPoint3 * (STDAPICALLTYPE *)(CRPoint3 *, CRVector3 *)) CRAdd , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SubPoint3Vector(IDAPoint3 *  arg0, IDAVector3 *  arg1, IDAPoint3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SubPoint3Vector(%lx)", this));
    return CreatePrim2(IID_IDAPoint3, (CRPoint3 * (STDAPICALLTYPE *)(CRPoint3 *, CRVector3 *)) CRSub , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::SubPoint3(IDAPoint3 *  arg0, IDAPoint3 *  arg1, IDAVector3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::SubPoint3(%lx)", this));
    return CreatePrim2(IID_IDAVector3, (CRVector3 * (STDAPICALLTYPE *)(CRPoint3 *, CRPoint3 *)) CRSub , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::DistancePoint3(IDAPoint3 *  arg0, IDAPoint3 *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DistancePoint3(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint3 *, CRPoint3 *)) CRDistance , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::DistanceSquaredPoint3(IDAPoint3 *  arg0, IDAPoint3 *  arg1, IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::DistanceSquaredPoint3(%lx)", this));
    return CreatePrim2(IID_IDANumber, (CRNumber * (STDAPICALLTYPE *)(CRPoint3 *, CRPoint3 *)) CRDistanceSquared , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_IdentityTransform3(IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_IdentityTransform3(%lx)", this));
    return CreateVar(IID_IDATransform3, (CRBvrPtr) CRIdentityTransform3(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Translate3Anim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Translate3Anim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg2VAL;
    arg2VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg2));
    if (!arg2VAL) return Error();

    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelYToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRTranslate3(arg0VAL, arg1VAL, arg2VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Translate3(double arg0, double arg1, double arg2, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Translate3(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRTranslate3(/* NOELARG */ PixelToNum(arg0), /* NOELARG */ PixelYToNum(arg1), /* NOELARG */ PixelToNum(arg2))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Translate3Rate(double arg0, double arg1, double arg2, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Translate3Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg2VAL;
    arg2VAL = (CRNumber *) RatePixelToNumBvr(arg2);
    if (!arg2VAL) return Error();

    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) RatePixelYToNumBvr(arg1);
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) RatePixelToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRTranslate3(/* NOELARG */ arg0VAL, /* NOELARG */ arg1VAL, /* NOELARG */ arg2VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Translate3Vector(IDAVector3 *  arg0, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Translate3Vector(%lx)", this));
    return CreatePrim1(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRVector3 *)) CRTranslate3 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Translate3Point(IDAPoint3 *  arg0, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Translate3Point(%lx)", this));
    return CreatePrim1(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRPoint3 *)) CRTranslate3 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Scale3Anim(IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale3Anim(%lx)", this));
    return CreatePrim3(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRNumber *, CRNumber *, CRNumber *)) CRScale3 , arg0, arg1, arg2, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Scale3(double arg0, double arg1, double arg2, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale3(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRScale3(/* NOELARG */ arg0, /* NOELARG */ arg1, /* NOELARG */ arg2)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Scale3Rate(double arg0, double arg1, double arg2, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale3Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg2VAL;
    arg2VAL = (CRNumber *) ScaleRateToNumBvr(arg2);
    if (!arg2VAL) return Error();

    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) ScaleRateToNumBvr(arg1);
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) ScaleRateToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRScale3(/* NOELARG */ arg0VAL, /* NOELARG */ arg1VAL, /* NOELARG */ arg2VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Scale3Vector(IDAVector3 *  arg0, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale3Vector(%lx)", this));
    return CreatePrim1(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRVector3 *)) CRScale3 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Scale3UniformAnim(IDANumber *  arg0, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale3UniformAnim(%lx)", this));
    return CreatePrim1(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRNumber *)) CRScale3Uniform , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Scale3Uniform(double arg0, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale3Uniform(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRScale3Uniform(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Scale3UniformRate(double arg0, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale3UniformRate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) ScaleRateToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRScale3Uniform(/* NOELARG */ arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Rotate3Anim(IDAVector3 *  arg0, IDANumber *  arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rotate3Anim(%lx)", this));
    return CreatePrim2(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRVector3 *, CRNumber *)) CRRotate3 , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Rotate3(IDAVector3 *  arg0, double arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rotate3(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRVector3 * arg0VAL;
    arg0VAL = (CRVector3 *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRRotate3(arg0VAL, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Rotate3Rate(IDAVector3 *  arg0, double arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rotate3Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) RateToNumBvr(arg1);
    if (!arg1VAL) return Error();

    CRVector3 * arg0VAL;
    arg0VAL = (CRVector3 *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRRotate3(arg0VAL, /* NOELARG */ arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Rotate3Degrees(IDAVector3 *  arg0, double arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rotate3Degrees(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRVector3 * arg0VAL;
    arg0VAL = (CRVector3 *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRRotate3(arg0VAL, /* NOELARG */ DegreesToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Rotate3RateDegrees(IDAVector3 *  arg0, double arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rotate3RateDegrees(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) RateDegreesToNumBvr(arg1);
    if (!arg1VAL) return Error();

    CRVector3 * arg0VAL;
    arg0VAL = (CRVector3 *) (::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRRotate3(arg0VAL, /* NOELARG */ arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::XShear3Anim(IDANumber *  arg0, IDANumber *  arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::XShear3Anim(%lx)", this));
    return CreatePrim2(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRXShear3 , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::XShear3(double arg0, double arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::XShear3(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRXShear3(/* NOELARG */ arg0, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::XShear3Rate(double arg0, double arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::XShear3Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) RateToNumBvr(arg1);
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) RateToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRXShear3(/* NOELARG */ arg0VAL, /* NOELARG */ arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::YShear3Anim(IDANumber *  arg0, IDANumber *  arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::YShear3Anim(%lx)", this));
    return CreatePrim2(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRYShear3 , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::YShear3(double arg0, double arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::YShear3(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRYShear3(/* NOELARG */ arg0, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::YShear3Rate(double arg0, double arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::YShear3Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) RateToNumBvr(arg1);
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) RateToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRYShear3(/* NOELARG */ arg0VAL, /* NOELARG */ arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ZShear3Anim(IDANumber *  arg0, IDANumber *  arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ZShear3Anim(%lx)", this));
    return CreatePrim2(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRZShear3 , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::ZShear3(double arg0, double arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ZShear3(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRZShear3(/* NOELARG */ arg0, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::ZShear3Rate(double arg0, double arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::ZShear3Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) RateToNumBvr(arg1);
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) RateToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRZShear3(/* NOELARG */ arg0VAL, /* NOELARG */ arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Transform4x4AnimEx(long sizearg0, IDANumber *  arg0[], IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Transform4x4AnimEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRTransform4x4(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Transform4x4Anim(VARIANT arg0, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Transform4x4Anim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRNUMBER_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRTransform4x4(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Compose3(IDATransform3 *  arg0, IDATransform3 *  arg1, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Compose3(%lx)", this));
    return CreatePrim2(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRTransform3 *, CRTransform3 *)) CRCompose3 , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Compose3ArrayEx(long sizearg0, IDATransform3 *  arg0[], IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Compose3ArrayEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRCompose3(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Compose3Array(VARIANT arg0, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Compose3Array(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRTRANSFORM3_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform3, (CRBvrPtr) (::CRCompose3(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::LookAtFrom(IDAPoint3 *  arg0, IDAPoint3 *  arg1, IDAVector3 *  arg2, IDATransform3 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::LookAtFrom(%lx)", this));
    return CreatePrim3(IID_IDATransform3, (CRTransform3 * (STDAPICALLTYPE *)(CRPoint3 *, CRPoint3 *, CRVector3 *)) CRLookAtFrom , arg0, arg1, arg2, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_IdentityTransform2(IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_IdentityTransform2(%lx)", this));
    return CreateVar(IID_IDATransform2, (CRBvrPtr) CRIdentityTransform2(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Translate2Anim(IDANumber *  arg0, IDANumber *  arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Translate2Anim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) PixelYToNumBvr(::GetBvr(arg1));
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) PixelToNumBvr(::GetBvr(arg0));
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRTranslate2(arg0VAL, arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Translate2(double arg0, double arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Translate2(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRTranslate2(/* NOELARG */ PixelToNum(arg0), /* NOELARG */ PixelYToNum(arg1))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Translate2Rate(double arg0, double arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Translate2Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) RatePixelYToNumBvr(arg1);
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) RatePixelToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRTranslate2(/* NOELARG */ arg0VAL, /* NOELARG */ arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Translate2Vector(IDAVector2 *  arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Translate2Vector(%lx)", this));
    return CreatePrim1(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRVector2 *)) CRTranslate2 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Translate2Point(IDAPoint2 *  arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Translate2Point(%lx)", this));
    return CreatePrim1(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRPoint2 *)) CRTranslate2 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Scale2Anim(IDANumber *  arg0, IDANumber *  arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale2Anim(%lx)", this));
    return CreatePrim2(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRNumber *, CRNumber *)) CRScale2 , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Scale2(double arg0, double arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale2(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRScale2(/* NOELARG */ arg0, /* NOELARG */ arg1)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Scale2Rate(double arg0, double arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale2Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg1VAL;
    arg1VAL = (CRNumber *) ScaleRateToNumBvr(arg1);
    if (!arg1VAL) return Error();

    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) ScaleRateToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRScale2(/* NOELARG */ arg0VAL, /* NOELARG */ arg1VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Scale2Vector2(IDAVector2 *  arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale2Vector2(%lx)", this));
    return CreatePrim1(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRVector2 *)) CRScale2 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Scale2Vector(IDAVector2 *  arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale2Vector(%lx)", this));
    return CreatePrim1(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRVector2 *)) CRScale2 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Scale2UniformAnim(IDANumber *  arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale2UniformAnim(%lx)", this));
    return CreatePrim1(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRNumber *)) CRScale2Uniform , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Scale2Uniform(double arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale2Uniform(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRScale2Uniform(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Scale2UniformRate(double arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Scale2UniformRate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) RateToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRScale2Uniform(/* NOELARG */ arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Rotate2Anim(IDANumber *  arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rotate2Anim(%lx)", this));
    return CreatePrim1(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRNumber *)) CRRotate2 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Rotate2(double arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rotate2(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRRotate2(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Rotate2Rate(double arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rotate2Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) RateToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRRotate2(/* NOELARG */ arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Rotate2Degrees(double arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rotate2Degrees(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRRotate2Degrees(/* NOELARG */ DegreesToNum(arg0))), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Rotate2RateDegrees(double arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Rotate2RateDegrees(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) RateDegreesToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRRotate2(/* NOELARG */ arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::XShear2Anim(IDANumber *  arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::XShear2Anim(%lx)", this));
    return CreatePrim1(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRNumber *)) CRXShear2 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::XShear2(double arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::XShear2(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRXShear2(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::XShear2Rate(double arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::XShear2Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) RateToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRXShear2(/* NOELARG */ arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::YShear2Anim(IDANumber *  arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::YShear2Anim(%lx)", this));
    return CreatePrim1(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRNumber *)) CRYShear2 , arg0, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::YShear2(double arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::YShear2(%lx)", this));

    PRIMPRECODE1(ret) ;
    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRYShear2(/* NOELARG */ arg0)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::YShear2Rate(double arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::YShear2Rate(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRNumber * arg0VAL;
    arg0VAL = (CRNumber *) RateToNumBvr(arg0);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRYShear2(/* NOELARG */ arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Transform3x2AnimEx(long sizearg0, IDANumber *  arg0[], IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Transform3x2AnimEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRTransform3x2(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Transform3x2Anim(VARIANT arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Transform3x2Anim(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    CRBvrPtr b;
    void *d = NULL;
    unsigned int n = 0;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRNUMBER_TYPEID,0,ARRAYFILL_DOUBLE,&d,&n);
    if (!arg0VAL && !d) return Error();
    if (d) {
        b = (CRBvrPtr) CRTransform3x2((double*)d, n);
        delete d;
    } else {
        b = (CRBvrPtr) (::CRTransform3x2(arg0VAL));
    }
    CreateCBvr(IID_IDATransform2, b, (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Compose2(IDATransform2 *  arg0, IDATransform2 *  arg1, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Compose2(%lx)", this));
    return CreatePrim2(IID_IDATransform2, (CRTransform2 * (STDAPICALLTYPE *)(CRTransform2 *, CRTransform2 *)) CRCompose2 , arg0, arg1, (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::Compose2ArrayEx(long sizearg0, IDATransform2 *  arg0[], IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Compose2ArrayEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRCompose2(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::Compose2Array(VARIANT arg0, IDATransform2 *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::Compose2Array(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRTRANSFORM2_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDATransform2, (CRBvrPtr) (::CRCompose2(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::get_ViewFrameRate(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_ViewFrameRate(%lx)", this));
    return CreateVar(IID_IDANumber, (CRBvrPtr) CRViewFrameRate(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::get_ViewTimeDelta(IDANumber *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_ViewTimeDelta(%lx)", this));
    return CreateVar(IID_IDANumber, (CRBvrPtr) CRViewTimeDelta(), (void **) ret)?S_OK:Error(); 

}

STDMETHODIMP
CDAStatics::UnionMontageArrayEx(long sizearg0, IDAMontage *  arg0[], IDAMontage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UnionMontageArrayEx(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = ToArrayBvr(sizearg0, (IDABehavior **) arg0);
    if (arg0VAL == NULL) return Error();
    CreateCBvr(IID_IDAMontage, (CRBvrPtr) (::CRUnionMontageArray(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::UnionMontageArray(VARIANT arg0, IDAMontage *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::UnionMontageArray(%lx)", this));

    PRIMPRECODE1(ret) ;
    CRArrayPtr arg0VAL;
    arg0VAL = SrvArrayBvr(arg0,GetPixelMode(),CRMONTAGE_TYPEID);
    if (!arg0VAL) return Error();

    CreateCBvr(IID_IDAMontage, (CRBvrPtr) (::CRUnionMontageArray(arg0VAL)), (void **) ret);
    PRIMPOSTCODE1(ret) ;
}

STDMETHODIMP
CDAStatics::get_EmptyColor(IDAColor *  * ret)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_EmptyColor(%lx)", this));
    return CreateVar(IID_IDAColor, (CRBvrPtr) CREmptyColor(), (void **) ret)?S_OK:Error(); 
}


STDMETHODIMP
CDAStatics::RadialGradientMulticolor (VARIANT  offsets,
                                      VARIANT  colors,
                                      IDAImage ** ret)
{
    PRIMPRECODE1(ret) ;

    CRArrayPtr offsetArray;
    offsetArray = SrvArrayBvr(offsets,GetPixelMode(),CRNUMBER_TYPEID);
    if (!offsetArray) return Error();
    
    CRArrayPtr clrArray;
    clrArray = SrvArrayBvr(colors,GetPixelMode(),CRCOLOR_TYPEID);
    if (!clrArray) return Error();

    CreateCBvr(IID_IDAImage,
               (CRBvrPtr) (::CRRadialGradientMulticolor( offsetArray, clrArray)),
               (void **) ret);

    PRIMPOSTCODE1(ret) ;
}


STDMETHODIMP
CDAStatics::RadialGradientMulticolorEx (
    int       nOffsets,
    IDANumber *offsets[],
    int       nColors,
    IDAColor *colors[],
    IDAImage **ret)
{
    PRIMPRECODE1(ret) ;

    if((nOffsets != nColors) || nOffsets<=0) {
        // TODO DEFINE OR RETURN CORRECT ERROR
        return E_INVALIDARG;
    }

    
    CRArrayPtr offsetsVal;
    offsetsVal = ToArrayBvr(nOffsets, (IDABehavior **) offsets);
    if (offsetsVal == NULL) return Error();

    CRArrayPtr colorsVal;
    colorsVal = ToArrayBvr(nColors, (IDABehavior **) colors);
    if (colorsVal == NULL) return Error();


    CreateCBvr(IID_IDAImage,
               (CRBvrPtr) (::CRRadialGradientMulticolor( offsetsVal, colorsVal)),
               (void **) ret);

    PRIMPOSTCODE1(ret) ;
}



STDMETHODIMP
CDAStatics::LinearGradientMulticolor (VARIANT  offsets,
                                      VARIANT  colors,
                                      IDAImage ** ret)
{
    PRIMPRECODE1(ret) ;

    CRArrayPtr offsetArray;
    offsetArray = SrvArrayBvr(offsets,GetPixelMode(),CRNUMBER_TYPEID);
    if (!offsetArray) return Error();
    
    CRArrayPtr clrArray;
    clrArray = SrvArrayBvr(colors,GetPixelMode(),CRCOLOR_TYPEID);
    if (!clrArray) return Error();

    CreateCBvr(IID_IDAImage,
               (CRBvrPtr) (::CRLinearGradientMulticolor( offsetArray, clrArray )),
               (void **) ret);

    PRIMPOSTCODE1(ret) ;
}


STDMETHODIMP
CDAStatics::LinearGradientMulticolorEx (
    int       nOffsets,
    IDANumber *offsets[],
    int       nColors,
    IDAColor *colors[],
    IDAImage **ret)
{
    PRIMPRECODE1(ret) ;

    if((nOffsets != nColors) || nOffsets<=0) {
        // TODO DEFINE OR RETURN CORRECT ERROR
        return E_INVALIDARG;
    }

    
    CRArrayPtr offsetsVal;
    offsetsVal = ToArrayBvr(nOffsets, (IDABehavior **) offsets);
    if (offsetsVal == NULL) return Error();

    CRArrayPtr colorsVal;
    colorsVal = ToArrayBvr(nColors, (IDABehavior **) colors);
    if (colorsVal == NULL) return Error();


    CreateCBvr(IID_IDAImage,
               (CRBvrPtr) (::CRLinearGradientMulticolor( offsetsVal, colorsVal )),
               (void **) ret);

    PRIMPOSTCODE1(ret) ;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDAStatics::get_VersionString
//
//  Synopsis:   Gets the current version string from src/include/version.h
//
//--------------------------------------------------------------------------

STDMETHODIMP
CDAStatics::get_VersionString(BSTR *strOut)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_VersionString(%lx)", this));
    
    CHECK_RETURN_NULL(strOut);
    
    char *v = VERSION;          // from version.h
    *strOut = A2BSTR(v);

    return (*strOut) ? S_OK : E_OUTOFMEMORY;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDAStatics::put_Site
//
//  Synopsis:   Sets the site.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CDAStatics::put_Site(IDASite * pSite)
{
    TraceTag((tagCOMEntry, "CDAStatics::put_Site(%lx)", this));
    
    TraceTag((tagStatics,
              "CDAStatics(%lx)::put_Site(%lx)",
              this, pSite));

    SetSite(pSite) ;

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDAStatics::get_Site
//
//  Synopsis:   Gets a site.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CDAStatics::get_Site(IDASite ** pSite)
{
    TraceTag((tagStatics,
              "CDAStatics(%lx)::get_Site()",
              this));

    CHECK_RETURN_SET_NULL(pSite);

    *pSite = GetSite() ;

    return S_OK;
}

STDMETHODIMP
CDAStatics::put_ClientSite(IOleClientSite * pSite)
{
    TraceTag((tagCOMEntry, "CDAStatics::put_ClientSite(%lx)", this));
    
    TraceTag((tagStatics,
              "CDAStatics(%lx)::put_ClientSite(%lx)",
              this, pSite));

    SetClientSite(pSite) ;

    return S_OK;
}

STDMETHODIMP
CDAStatics::get_ClientSite(IOleClientSite ** pSite)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_ClientSite(%lx)", this));
    
    TraceTag((tagStatics,
              "CDAStatics(%lx)::get_ClientSite()",
              this));

    CHECK_RETURN_SET_NULL(pSite);

    *pSite = GetClientSite() ;

    return S_OK;
}

STDMETHODIMP
CDAStatics::put_PixelConstructionMode(VARIANT_BOOL bMode)
{
    TraceTag((tagCOMEntry, "CDAStatics::put_PixelConstructionMode(%lx)", this));
    
    TraceTag((tagStatics,
              "CDAStatics(%lx)::put_PixelConstructionMode(%d)",
              this, bMode));

    SetPixelMode(bMode?true:false);
    
    return S_OK;
}

STDMETHODIMP
CDAStatics::get_PixelConstructionMode(VARIANT_BOOL * pbMode)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_PixelConstructionMode(%lx)", this));
    
    TraceTag((tagStatics,
              "CDAStatics(%lx)::get_PixelConstructionMode()",
              this));

    CHECK_RETURN_NULL(pbMode);

    *pbMode = GetPixelMode();

    return S_OK;
}

STDMETHODIMP
CDAStatics::NewDrawingSurface(IDADrawingSurface **pds)
{
    TraceTag((tagCOMEntry, "CDAStatics::NewDrawingSurface(%lx)", this));
    
    CHECK_RETURN_SET_NULL(pds);

    DAComObject<CDADrawingSurface> *pNew;
    DAComObject<CDADrawingSurface>::CreateInstance(&pNew);

    HRESULT hr = E_OUTOFMEMORY;
    if (pNew) {
        hr = pNew->Init(this);
        if (SUCCEEDED(hr)) {
            hr = pNew->QueryInterface(IID_IDADrawingSurface, (void **)pds);
            if (SUCCEEDED(hr))
                return S_OK;
        }
        delete pNew;
    }

    return hr;
}

IDASite *
CDAStatics::GetSite ()
{
    TraceTag((tagCOMEntry, "CDAStatics::GetSite(%lx)", this));
    
    CritSectGrabber csg(_cs);
    
    IDASite * s = _pSite;
    if (s)
        s->AddRef();
    
    return s ;
}

void
CDAStatics::SetSite (IDASite * pSite)
{
    TraceTag((tagCOMEntry, "CDAStatics::SetSite(%lx)", this));
    
    CritSectGrabber csg(_cs);
    
    _pSite = pSite;
}

IOleClientSite *
CDAStatics::GetClientSite ()
{
    TraceTag((tagCOMEntry, "CDAStatics::GetClientSite(%lx)", this));
    
    CritSectGrabber csg(_cs);
    
    IOleClientSite * p = _pOleClientSite;
    
    if (p)
        p->AddRef();
    
    return p ;
}

void
CDAStatics::SetClientSite (IOleClientSite * pClientSite)
{
    TraceTag((tagCOMEntry, "CDAStatics::SetClientSite(%lx)", this));
    
    CritSectGrabber csg(_cs);
    
    _pOleClientSite = pClientSite;
    delete _clientSiteURL;
    _clientSiteURL = NULL;
    _pBH.Release();

    // For now never use the bindhost
    // The problem is that we need to marshal the pointer since we use
    // it from another thread but this causes deadlock since the main
    // thread currently blocks waiting on the imports
    
#if 0
    if (pClientSite) {
        CComPtr<IServiceProvider> servProv;
        CComPtr<IBindHost> bh;
        if (SUCCEEDED(pClientSite->QueryInterface(IID_IServiceProvider,
                                                  (void **)&servProv)) &&
            SUCCEEDED(servProv->QueryService(SID_IBindHost,
                                             IID_IBindHost,
                                             (void**)&bh))) {
            _pBH = bh;
        }
    }
#endif
}

LPWSTR
CDAStatics::GetURLOfClientSite()
{
    CritSectGrabber csg(_cs);

    if (!_clientSiteURL) {
        
        DAComPtr<IHTMLDocument2> pHTMLDoc;
        DAComPtr<IHTMLElementCollection> pElementCollection;
        DAComPtr<IOleContainer> pRoot;
        
        // Fail gracefully if we don't have a client site, since not
        // all uses will.
        if (!_pOleClientSite)
            goto done;
    
        // However, if we do have a client site, we should be able
        // to get these other elements.  If we don't, assert.
        // (TODO: what's going to happen in IE3?)
        if (SUCCEEDED(_pOleClientSite->GetContainer(&pRoot))) {
            if (FAILED(pRoot->QueryInterface(IID_IHTMLDocument2,
                                             (void **)&pHTMLDoc)))
                goto done;
        }
        else {
            
            DAComPtr<IHTMLWindow2> htmlWindow;
            DAComPtr<IServiceProvider> sp;

            if (FAILED(_pOleClientSite->QueryInterface(IID_IServiceProvider,                                     
                                      (void **) &sp)))
                goto done;
            
            if( FAILED(sp->QueryService(SID_SHTMLWindow,
                                      IID_IHTMLWindow2,
                                      (void **) &htmlWindow)))
                goto done;

            if( FAILED(htmlWindow->get_document(&pHTMLDoc)))
                goto done;
        }      
        
        if (FAILED(pHTMLDoc->get_all(&pElementCollection)))
            goto done;
        
        {
            CComVariant baseName;
            baseName.vt = VT_BSTR;
            baseName.bstrVal = SysAllocString(L"BASE");

            DAComPtr<IDispatch> pDispatch;
            if (FAILED(pElementCollection->tags(baseName, &pDispatch)))
                goto done;
            
            pElementCollection.Release();
            
            if (FAILED(pDispatch->QueryInterface(IID_IHTMLElementCollection,
                                                 (void **)&pElementCollection)))
                goto done;
        }

        {
            BSTR tempBstr = NULL;
            CComVariant index;
            index.vt = VT_I2;
            index.iVal = 0;
            DAComPtr<IDispatch> pDispatch;

            if (FAILED(pElementCollection->item(index,
                                                index,
                                                &pDispatch)) ||
                !pDispatch)
            {
                if (FAILED(pHTMLDoc->get_URL(&tempBstr)))
                    goto done;
            }
            else
            {
                DAComPtr<IHTMLBaseElement> pBaseElement;
                if (FAILED(pDispatch->QueryInterface(IID_IHTMLBaseElement, (void **)&pBaseElement)))
                    goto done;
                
                if (FAILED(pBaseElement->get_href(&tempBstr)))
                    goto done;
            }

            _clientSiteURL = CopyString(tempBstr);
            SysFreeString(tempBstr);
        }
    }

  done:
    if (_clientSiteURL == NULL)
        _clientSiteURL = CopyString(L"");
        
    return _clientSiteURL;
} // CDAStatics::GetURLOfClientSite()

IBindHost*
CDAStatics::GetBindHost ()
{
    CritSectGrabber csg(_cs);
    
    IBindHost * sp = _pBH;

    if (sp)
        sp->AddRef();

    return sp;
}

void
CDAStatics::AddSyncImportSite(DWORD id)
{
    CritSectGrabber csg(_cs);

    _importList.push_back(id);
}

void
CDAStatics::RemoveSyncImportSite(DWORD id)
{
    CritSectGrabber csg(_cs);

    _importList.remove(id);
}

CRSTDAPICB_(void)
CDAStatics::SetStatusText(LPCWSTR sz)
{
    DAComPtr<IDASite> site(GetSite(), false);

    if (site) {
        BSTR bstr = SysAllocString(sz);
        if (bstr) {
            THR(site->SetStatusText(bstr));
            SysFreeString(bstr);
        }
    }
}

CRSTDAPICB_(void)
CDAStatics::ReportError(HRESULT hr,
                        LPCWSTR sz)
{
    DAComPtr<IDASite> site(GetSite(), false);

    if (site) {
        BSTR bstr = SysAllocString(sz);
        if (bstr) {
            THR(site->ReportError(hr,bstr));
            SysFreeString(bstr);
        }
    }
}

CRSTDAPICB_(void)
CDAStatics::ReportGC(bool b)
{
    DAComPtr<IDASite> site(GetSite(), false);

    if (site) {
        THR(site->ReportGC(b));
    }
}

CRBvrPtr
CDAStatics::PixelToNumBvr(double d)
{
    return GetPixelMode()?::PixelToNumBvr(d):(CRBvrPtr)CRCreateNumber(d);
}

/*
CRBvrPtr
CDAStatics::PixelToNumBvr(IDANumber * num)
{
    CRBvrPtr b = ::GetBvr(num);

    if (b)
        b = PixelToNumBvr(b);

    return b;
}
*/

CRBvrPtr
CDAStatics::RatePixelToNumBvr(double d)
{
    return RateToNumBvr(PixelToNumBvr(d));
}

CRBvrPtr
CDAStatics::PixelToNumBvr(CRBvrPtr b)
{
    return GetPixelMode()?::PixelToNumBvr(b):b;
}

double
CDAStatics::PixelToNum(double d)
{
    return GetPixelMode()?::PixelToNum(d):d;
}

CRBvrPtr
CDAStatics::PixelYToNumBvr(double d)
{
    return GetPixelMode()?::PixelYToNumBvr(d):(CRBvrPtr)CRCreateNumber(d);
}

/*
CRBvrPtr
CDAStatics::PixelYToNumBvr(IDANumber * num)
{
    CRBvrPtr b = ::GetBvr(num);

    if (b)
        b = PixelYToNumBvr(b);

    return b;
}
*/

CRBvrPtr
CDAStatics::RatePixelYToNumBvr(double d)
{
    return RateToNumBvr(PixelYToNumBvr(d));
}

CRBvrPtr
CDAStatics::PixelYToNumBvr(CRBvrPtr b)
{
    return GetPixelMode()?::PixelYToNumBvr(b):b;
}

double
CDAStatics::PixelYToNum(double d)
{
    return GetPixelMode()?::PixelYToNum(d):d;
}

STDMETHODIMP
CDAStaticsFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                REFIID riid,
                                void ** ppv)
{
    if (ppv)
        *ppv = NULL;
    
    DAComObject<CDAStatics>* pNew;

    DAComObject<CDAStatics>::CreateInstance(&pNew);

    if (pNew) {
        HRESULT hr = pNew->QueryInterface(riid, ppv);
            
        if (hr) {
            delete pNew;
            return hr;
        } else {
            CRAddSite(pNew);

            Assert(pNew->m_dwRef == 2);
        
            return S_OK;
        }
    }

    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\statics.h ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/

#ifndef _STATICS_H
#define _STATICS_H

#include "engine.h"
#include "cbvr.h"
#include "privinc/comutil.h"
#include "comconv.h"
#include <DXTrans.h>

//+-------------------------------------------------------------------------
//
//  Class:      CDAStatics
//
//  Synopsis:
//
//--------------------------------------------------------------------------

class ATL_NO_VTABLE CDAStaticsFactory : public CComClassFactory {
  public:
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              void ** ppvObj);
};

class ATL_NO_VTABLE CDAStatics
    : public CComObjectRootEx<CComMultiThreadModel>,
      public IObjectSafetyImpl<CDAStatics>,
      public CComCoClass<CDAStatics, &CLSID_DAStatics>,
      public IDispatchImpl<IDA3Statics,
                           &IID_IDA3Statics,
                           &LIBID_DirectAnimation>,
      public ISupportErrorInfoImpl<&IID_IDA3Statics>,
      public CRImportSite,
      public CRSite
{
  public:
#if _DEBUG
    const char * GetName() { return "CDAStatics"; }
#endif

    DA_DECLARE_NOT_AGGREGATABLE(CDAStatics);

    ULONG InternalRelease();

    DECLARE_REGISTRY(CLSID_DAStatics,
                     LIBID ".DAStatics.1",
                     LIBID ".DAStatics",
                     0,
                     THREADFLAGS_BOTH);

    DECLARE_CLASSFACTORY_EX(CDAStaticsFactory);

    BEGIN_COM_MAP(CDAStatics)
        COM_INTERFACE_ENTRY(IDA3Statics)
        COM_INTERFACE_ENTRY(IDA2Statics)
        COM_INTERFACE_ENTRY(IDAStatics)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP()

    // IDAStatics methods
    STDMETHOD(get_VersionString)(BSTR * stringOut);
    STDMETHOD(put_Site)(IDASite * pSite);
    STDMETHOD(get_Site)(IDASite ** pSite);
    STDMETHOD(put_ClientSite)(IOleClientSite * pClientSite);
    STDMETHOD(get_ClientSite)(IOleClientSite ** pClientSite);
    STDMETHOD(put_PixelConstructionMode)(VARIANT_BOOL bMode);
    STDMETHOD(get_PixelConstructionMode)(VARIANT_BOOL * bMode);

    // IDAStatics methods not automatically generated

    STDMETHOD(TriggerEvent)(IDAEvent *event,
                            IDABehavior *data);

    STDMETHOD(NewDrawingSurface)(IDADrawingSurface **pds);

    // Importation
    STDMETHOD(ImportMovie)(LPOLESTR url,
                           IDAImportationResult **ppResult)
        { return(DoImportMovie(url, ppResult, false)); }

    STDMETHOD(ImportMovieStream)(LPOLESTR url,
                           IDAImportationResult **ppResult)
        { return(DoImportMovie(url, ppResult, true)); }

    STDMETHOD(ImportMovieAsync)(LPOLESTR url,
                                IDAImage   *pImageStandIn,
                                IDASound   *pSoundStandIn,
                                IDAImportationResult **ppResult);

    STDMETHOD(ImportImage)(LPOLESTR url,
                           IDAImage **ppImage);

    STDMETHOD(ImportImageAsync)(LPOLESTR url,
                                IDAImage *pImageStandIn,
                                IDAImportationResult **ppResult);

    STDMETHOD(ImportImageColorKey)(LPOLESTR url,
                                   BYTE ckRed,
                                   BYTE ckGreen,
                                   BYTE ckBlue,
                                   IDAImage **ppImage);

    STDMETHOD(ImportImageAsyncColorKey)(LPOLESTR url,
                                        IDAImage *pImageStandIn,
                                        BYTE ckRed,
                                        BYTE ckGreen,
                                        BYTE ckBlue,
                                        IDAImportationResult **ppResult);

    STDMETHOD(ImportSoundStream)(LPOLESTR url,
                           IDAImportationResult **ppResult)
        { return(DoImportMovie(url, ppResult, true)); }

    STDMETHOD(ImportSound)(LPOLESTR url,
                           IDAImportationResult **ppResult)
        { return(DoImportSound(url, ppResult, false)); }

    STDMETHOD(ImportSoundAsync)(LPOLESTR url,
                                IDASound   *pSoundStandIn,
                                IDAImportationResult **ppResult);

    STDMETHOD(ImportGeometry)(LPOLESTR url,
                              IDAGeometry **ppGeometry);

    STDMETHOD(ImportGeometryWrapped)(LPOLESTR url,
                                     LONG wrapType,
                                     double originX,
                                     double originY,
                                     double originZ,
                                     double zAxisX,
                                     double zAxisY,
                                     double zAxisZ,
                                     double yAxisX,
                                     double yAxisY,
                                     double yAxisZ,
                                     double texOriginX,
                                     double texOriginY,
                                     double texScaleX,
                                     double texScaleY,
                                     DWORD flags,
                                     IDAGeometry **ppGeometry);

    STDMETHOD(ImportGeometryAsync)(LPOLESTR url,
                                   IDAGeometry *pGeoStandIn,
                                   IDAImportationResult **ppResult);

    STDMETHOD(ImportGeometryWrappedAsync)(LPOLESTR url,
                                          LONG wrapType,
                                          double originX,
                                          double originY,
                                          double originZ,
                                          double zAxisX,
                                          double zAxisY,
                                          double zAxisZ,
                                          double yAxisX,
                                          double yAxisY,
                                          double yAxisZ,
                                          double texOriginX,
                                          double texOriginY,
                                          double texScaleX,
                                          double texScaleY,
                                          DWORD flags,
                                          IDAGeometry *pGeoStandIn,
                                          IDAImportationResult **ppResult);

    STDMETHOD(ImportDirectDrawSurface)(IUnknown *dds,
                                       IDAEvent *updateEvent,
                                       IDAImage **bvr);

    STDMETHOD(get_AreBlockingImportsComplete)(VARIANT_BOOL *bComplete);

    STDMETHOD(Cond)(IDABoolean *c,
                    IDABehavior *i,
                    IDABehavior *e,
                    IDABehavior **pCondBvr);

    STDMETHOD(DAArrayEx)(long s, IDABehavior *pBvrs[], IDAArray **bvr)
    { return DAArrayEx2(s, pBvrs, 0, bvr); }
    STDMETHOD(DAArray)(VARIANT pBvrs, IDAArray **bvr)
    { return DAArray2(pBvrs, 0, bvr); }
    STDMETHOD(DAArrayEx2)(long s,
                          IDABehavior *pBvrs[],
                          DWORD dwFlags,
                          IDAArray **bvr);
    STDMETHOD(DAArray2)(VARIANT pBvrs,
                        DWORD dwFlags,
                        IDAArray **bvr);
    STDMETHOD(DATupleEx)(long size, IDABehavior *pBvrs[], IDATuple **bvr);
    STDMETHOD(DATuple)(VARIANT pBvrs, IDATuple **bvr);

    STDMETHOD(ModifiableBehavior)(IDABehavior *orig, IDABehavior **bvr);

    STDMETHOD(UninitializedArray)(IDAArray *typeTmp, IDAArray **bvr);

    STDMETHOD(UninitializedTuple)(IDATuple *typeTmp, IDATuple **bvr);

    STDMETHOD(NumberBSplineEx)(int degree,
                               long numKnots,
                               IDANumber *knots[],
                               long numPts,
                               IDANumber *ctrlPts[],
                               long numWts,
                               IDANumber *weights[],
                               IDANumber *evaluator,
                               IDANumber **bvr);
    STDMETHOD(NumberBSpline)(int degree,
                             VARIANT knots,
                             VARIANT ctrlPts,
                             VARIANT weights,
                             IDANumber *evaluator,
                             IDANumber **bvr);

    STDMETHOD(Point2BSplineEx)(int degree,
                               long numKnots,
                               IDANumber *knots[],
                               long numPts,
                               IDAPoint2 *ctrlPts[],
                               long numWts,
                               IDANumber *weights[],
                               IDANumber *evaluator,
                               IDAPoint2 **bvr);
    STDMETHOD(Point2BSpline)(int degree,
                             VARIANT knots,
                             VARIANT ctrlPts,
                             VARIANT weights,
                             IDANumber *evaluator,
                             IDAPoint2 **bvr);

    STDMETHOD(Point3BSplineEx)(int degree,
                               long numKnots,
                               IDANumber *knots[],
                               long numPts,
                               IDAPoint3 *ctrlPts[],
                               long numWts,
                               IDANumber *weights[],
                               IDANumber *evaluator,
                               IDAPoint3 **bvr);
    STDMETHOD(Point3BSpline)(int degree,
                             VARIANT knots,
                             VARIANT ctrlPts,
                             VARIANT weights,
                             IDANumber *evaluator,
                             IDAPoint3 **bvr);

    STDMETHOD(Vector2BSplineEx)(int degree,
                                long numKnots,
                                IDANumber *knots[],
                                long numPts,
                                IDAVector2 *ctrlPts[],
                                long numWts,
                                IDANumber *weights[],
                                IDANumber *evaluator,
                                IDAVector2 **bvr);
    STDMETHOD(Vector2BSpline)(int degree,
                              VARIANT knots,
                              VARIANT ctrlPts,
                              VARIANT weights,
                              IDANumber *evaluator,
                              IDAVector2 **bvr);

    STDMETHOD(Vector3BSplineEx)(int degree,
                                long numKnots,
                                IDANumber *knots[],
                                long numPts,
                                IDAVector3 *ctrlPts[],
                                long numWts,
                                IDANumber *weights[],
                                IDANumber *evaluator,
                                IDAVector3 **bvr);
    STDMETHOD(Vector3BSpline)(int degree,
                              VARIANT knots,
                              VARIANT ctrlPts,
                              VARIANT weights,
                              IDANumber *evaluator,
                              IDAVector3 **bvr);

    STDMETHOD(ImportDirect3DRMVisual)(IUnknown *visual,
                                      IDAGeometry **bvr);

    STDMETHOD(ImportDirect3DRMVisualWrapped)(IUnknown *visual,
                                             LONG wrapType,
                                             double originX,
                                             double originY,
                                             double originZ,
                                             double zAxisX,
                                             double zAxisY,
                                             double zAxisZ,
                                             double yAxisX,
                                             double yAxisY,
                                             double yAxisZ,
                                             double texOriginX,
                                             double texOriginY,
                                             double texScaleX,
                                             double texScaleY,
                                             DWORD flags,
                                             IDAGeometry **bvr);

    STDMETHOD(ApplyDXTransformEx)(IUnknown *theXf,
                                  LONG numInputs,
                                  IDABehavior **inputs,
                                  IDANumber *evaluator,
                                  IDADXTransformResult **ppResult);

    STDMETHOD(ApplyDXTransform)(VARIANT varXf,
                                VARIANT inputs,
                                VARIANT evaluator,
                                IDADXTransformResult **ppResult);

    STDMETHOD(ModifiableNumber)(double initVal,
                                IDANumber **ppResult);
    STDMETHOD(ModifiableString)(BSTR initVal,
                                IDAString **ppResult);

    STDMETHOD(get_ModifiableBehaviorFlags)(DWORD * pdwFlags);
    STDMETHOD(put_ModifiableBehaviorFlags)(DWORD dwFlags);

    STDMETHOD(Pow) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret);
    STDMETHOD(Abs) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Sqrt) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Floor) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Round) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Ceiling) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Asin) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Acos) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Atan) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Sin) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Cos) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Tan) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Exp) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Ln) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Log10) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(ToDegrees) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(ToRadians) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Mod) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret);
    STDMETHOD(Atan2) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret);
    STDMETHOD(Add) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret);
    STDMETHOD(Sub) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret);
    STDMETHOD(Mul) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret);
    STDMETHOD(Div) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  * ret);
    STDMETHOD(LT) (IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret);
    STDMETHOD(LTE) (IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret);
    STDMETHOD(GT) (IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret);
    STDMETHOD(GTE) (IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret);
    STDMETHOD(EQ) (IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret);
    STDMETHOD(NE) (IDANumber *  arg0, IDANumber *  arg1, IDABoolean *  * ret);
    STDMETHOD(Neg) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(InterpolateAnim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDANumber *  * ret);
    STDMETHOD(Interpolate) (double arg0, double arg1, double arg2, IDANumber *  * ret);
    STDMETHOD(SlowInSlowOutAnim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDANumber *  arg3, IDANumber *  * ret);
    STDMETHOD(SlowInSlowOut) (double arg0, double arg1, double arg2, double arg3, IDANumber *  * ret);
    STDMETHOD(SoundSource) (IDASound *  arg0, IDAGeometry *  * ret);
    STDMETHOD(Mix) (IDASound *  arg0, IDASound *  arg1, IDASound *  * ret);
    STDMETHOD(And) (IDABoolean *  arg0, IDABoolean *  arg1, IDABoolean *  * ret);
    STDMETHOD(Or) (IDABoolean *  arg0, IDABoolean *  arg1, IDABoolean *  * ret);
    STDMETHOD(Not) (IDABoolean *  arg0, IDABoolean *  * ret);
    STDMETHOD(Integral) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(Derivative) (IDANumber *  arg0, IDANumber *  * ret);
    STDMETHOD(IntegralVector2) (IDAVector2 *  arg0, IDAVector2 *  * ret);
    STDMETHOD(IntegralVector3) (IDAVector3 *  arg0, IDAVector3 *  * ret);
    STDMETHOD(DerivativeVector2) (IDAVector2 *  arg0, IDAVector2 *  * ret);
    STDMETHOD(DerivativeVector3) (IDAVector3 *  arg0, IDAVector3 *  * ret);
    STDMETHOD(DerivativePoint2) (IDAPoint2 *  arg0, IDAVector2 *  * ret);
    STDMETHOD(DerivativePoint3) (IDAPoint3 *  arg0, IDAVector3 *  * ret);
    STDMETHOD(KeyState) (IDANumber *  arg0, IDABoolean *  * ret);
    STDMETHOD(KeyUp) (LONG arg0, IDAEvent *  * ret);
    STDMETHOD(KeyDown) (LONG arg0, IDAEvent *  * ret);
    STDMETHOD(DANumber) (double arg0, IDANumber *  * ret);
    STDMETHOD(DAString) (BSTR arg0, IDAString *  * ret);
    STDMETHOD(DABoolean) (VARIANT_BOOL arg0, IDABoolean *  * ret);
    STDMETHOD(SeededRandom) (double arg0, IDANumber *  * ret);
    STDMETHOD(get_MousePosition) (IDAPoint2 *  * ret);
    STDMETHOD(get_LeftButtonState) (IDABoolean *  * ret);
    STDMETHOD(get_RightButtonState) (IDABoolean *  * ret);
    STDMETHOD(get_DATrue) (IDABoolean *  * ret);
    STDMETHOD(get_DAFalse) (IDABoolean *  * ret);
    STDMETHOD(get_LocalTime) (IDANumber *  * ret);
    STDMETHOD(get_GlobalTime) (IDANumber *  * ret);
    STDMETHOD(get_Pixel) (IDANumber *  * ret);
    STDMETHOD(UserData) (IUnknown * arg0, IDAUserData *  * ret);
    STDMETHOD(UntilNotify) (IDABehavior *  arg0, IDAEvent *  arg1, IDAUntilNotifier * arg2, IDABehavior *  * ret);
    STDMETHOD(Until) (IDABehavior *  arg0, IDAEvent *  arg1, IDABehavior *  arg2, IDABehavior *  * ret);
    STDMETHOD(UntilEx) (IDABehavior *  arg0, IDAEvent *  arg1, IDABehavior *  * ret);
    STDMETHOD(Sequence) (IDABehavior *  arg0, IDABehavior *  arg1, IDABehavior *  * ret);
    STDMETHOD(SequenceArrayEx) (long sizearg0, IDABehavior *  arg0[], IDABehavior *  * ret);
    STDMETHOD(SequenceArray) (VARIANT arg0, IDABehavior *  * ret);
    STDMETHOD(FollowPath) (IDAPath2 *  arg0, double arg1, IDATransform2 *  * ret);
    STDMETHOD(FollowPathAngle) (IDAPath2 *  arg0, double arg1, IDATransform2 *  * ret);
    STDMETHOD(FollowPathAngleUpright) (IDAPath2 *  arg0, double arg1, IDATransform2 *  * ret);
    STDMETHOD(FollowPathEval) (IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret);
    STDMETHOD(FollowPathAngleEval) (IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret);
    STDMETHOD(FollowPathAngleUprightEval) (IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret);
    STDMETHOD(FollowPathAnim) (IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret);
    STDMETHOD(FollowPathAngleAnim) (IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret);
    STDMETHOD(FollowPathAngleUprightAnim) (IDAPath2 *  arg0, IDANumber *  arg1, IDATransform2 *  * ret);
    STDMETHOD(UntilNotifyScript) (IDABehavior *  arg0, IDAEvent *  arg1, BSTR arg2, IDABehavior *  * ret);
    STDMETHOD(ConcatString) (IDAString *  arg0, IDAString *  arg1, IDAString *  * ret);
    STDMETHOD(PerspectiveCamera) (double arg0, double arg1, IDACamera *  * ret);
    STDMETHOD(PerspectiveCameraAnim) (IDANumber *  arg0, IDANumber *  arg1, IDACamera *  * ret);
    STDMETHOD(ParallelCamera) (double arg0, IDACamera *  * ret);
    STDMETHOD(ParallelCameraAnim) (IDANumber *  arg0, IDACamera *  * ret);
    STDMETHOD(ColorRgbAnim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAColor *  * ret);
    STDMETHOD(ColorRgb) (double arg0, double arg1, double arg2, IDAColor *  * ret);
    STDMETHOD(ColorRgb255) (short arg0, short arg1, short arg2, IDAColor *  * ret);
    STDMETHOD(ColorHsl) (double arg0, double arg1, double arg2, IDAColor *  * ret);
    STDMETHOD(ColorHslAnim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAColor *  * ret);
    STDMETHOD(get_Red) (IDAColor *  * ret);
    STDMETHOD(get_Green) (IDAColor *  * ret);
    STDMETHOD(get_Blue) (IDAColor *  * ret);
    STDMETHOD(get_Cyan) (IDAColor *  * ret);
    STDMETHOD(get_Magenta) (IDAColor *  * ret);
    STDMETHOD(get_Yellow) (IDAColor *  * ret);
    STDMETHOD(get_Black) (IDAColor *  * ret);
    STDMETHOD(get_White) (IDAColor *  * ret);
    STDMETHOD(get_Aqua) (IDAColor *  * ret);
    STDMETHOD(get_Fuchsia) (IDAColor *  * ret);
    STDMETHOD(get_Gray) (IDAColor *  * ret);
    STDMETHOD(get_Lime) (IDAColor *  * ret);
    STDMETHOD(get_Maroon) (IDAColor *  * ret);
    STDMETHOD(get_Navy) (IDAColor *  * ret);
    STDMETHOD(get_Olive) (IDAColor *  * ret);
    STDMETHOD(get_Purple) (IDAColor *  * ret);
    STDMETHOD(get_Silver) (IDAColor *  * ret);
    STDMETHOD(get_Teal) (IDAColor *  * ret);
    STDMETHOD(Predicate) (IDABoolean *  arg0, IDAEvent *  * ret);
    STDMETHOD(NotEvent) (IDAEvent *  arg0, IDAEvent *  * ret);
    STDMETHOD(AndEvent) (IDAEvent *  arg0, IDAEvent *  arg1, IDAEvent *  * ret);
    STDMETHOD(OrEvent) (IDAEvent *  arg0, IDAEvent *  arg1, IDAEvent *  * ret);
    STDMETHOD(ThenEvent) (IDAEvent *  arg0, IDAEvent *  arg1, IDAEvent *  * ret);
    STDMETHOD(get_LeftButtonDown) (IDAEvent *  * ret);
    STDMETHOD(get_LeftButtonUp) (IDAEvent *  * ret);
    STDMETHOD(get_RightButtonDown) (IDAEvent *  * ret);
    STDMETHOD(get_RightButtonUp) (IDAEvent *  * ret);
    STDMETHOD(get_Always) (IDAEvent *  * ret);
    STDMETHOD(get_Never) (IDAEvent *  * ret);
    STDMETHOD(TimerAnim) (IDANumber *  arg0, IDAEvent *  * ret);
    STDMETHOD(Timer) (double arg0, IDAEvent *  * ret);
    STDMETHOD(AppTriggeredEvent) (IDAEvent *  * ret);
    STDMETHOD(ScriptCallback) (BSTR arg0, IDAEvent *  arg1, BSTR arg2, IDAEvent *  * ret);
    STDMETHOD(get_EmptyGeometry) (IDAGeometry *  * ret);
    STDMETHOD(UnionGeometry) (IDAGeometry *  arg0, IDAGeometry *  arg1, IDAGeometry *  * ret);
    STDMETHOD(UnionGeometryArrayEx) (long sizearg0, IDAGeometry *  arg0[], IDAGeometry *  * ret);
    STDMETHOD(UnionGeometryArray) (VARIANT arg0, IDAGeometry *  * ret);
    STDMETHOD(get_EmptyImage) (IDAImage *  * ret);
    STDMETHOD(get_DetectableEmptyImage) (IDAImage *  * ret);
    STDMETHOD(SolidColorImage) (IDAColor *  arg0, IDAImage *  * ret);
    STDMETHOD(GradientPolygonEx) (long sizearg0, IDAPoint2 *  arg0[], long sizearg1, IDAColor *  arg1[], IDAImage *  * ret);
    STDMETHOD(GradientPolygon) (VARIANT arg0, VARIANT arg1, IDAImage *  * ret);
    STDMETHOD(RadialGradientPolygonEx) (IDAColor *  arg0, IDAColor *  arg1, long sizearg2, IDAPoint2 *  arg2[], double arg3, IDAImage *  * ret);
    STDMETHOD(RadialGradientPolygon) (IDAColor *  arg0, IDAColor *  arg1, VARIANT arg2, double arg3, IDAImage *  * ret);
    STDMETHOD(RadialGradientPolygonAnimEx) (IDAColor *  arg0, IDAColor *  arg1, long sizearg2, IDAPoint2 *  arg2[], IDANumber *  arg3, IDAImage *  * ret);
    STDMETHOD(RadialGradientPolygonAnim) (IDAColor *  arg0, IDAColor *  arg1, VARIANT arg2, IDANumber *  arg3, IDAImage *  * ret);
    STDMETHOD(GradientSquare) (IDAColor *  arg0, IDAColor *  arg1, IDAColor *  arg2, IDAColor *  arg3, IDAImage *  * ret);
    STDMETHOD(RadialGradientSquare) (IDAColor *  arg0, IDAColor *  arg1, double arg2, IDAImage *  * ret);
    STDMETHOD(RadialGradientSquareAnim) (IDAColor *  arg0, IDAColor *  arg1, IDANumber *  arg2, IDAImage *  * ret);
    STDMETHOD(RadialGradientRegularPoly) (IDAColor *  arg0, IDAColor *  arg1, double arg2, double arg3, IDAImage *  * ret);
    STDMETHOD(RadialGradientRegularPolyAnim) (IDAColor *  arg0, IDAColor *  arg1, IDANumber *  arg2, IDANumber *  arg3, IDAImage *  * ret);
    STDMETHOD(GradientHorizontal) (IDAColor *  arg0, IDAColor *  arg1, double arg2, IDAImage *  * ret);
    STDMETHOD(GradientHorizontalAnim) (IDAColor *  arg0, IDAColor *  arg1, IDANumber *  arg2, IDAImage *  * ret);
    STDMETHOD(HatchHorizontal) (IDAColor *  arg0, double arg1, IDAImage *  * ret);
    STDMETHOD(HatchHorizontalAnim) (IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret);
    STDMETHOD(HatchVertical) (IDAColor *  arg0, double arg1, IDAImage *  * ret);
    STDMETHOD(HatchVerticalAnim) (IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret);
    STDMETHOD(HatchForwardDiagonal) (IDAColor *  arg0, double arg1, IDAImage *  * ret);
    STDMETHOD(HatchForwardDiagonalAnim) (IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret);
    STDMETHOD(HatchBackwardDiagonal) (IDAColor *  arg0, double arg1, IDAImage *  * ret);
    STDMETHOD(HatchBackwardDiagonalAnim) (IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret);
    STDMETHOD(HatchCross) (IDAColor *  arg0, double arg1, IDAImage *  * ret);
    STDMETHOD(HatchCrossAnim) (IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret);
    STDMETHOD(HatchDiagonalCross) (IDAColor *  arg0, double arg1, IDAImage *  * ret);
    STDMETHOD(HatchDiagonalCrossAnim) (IDAColor *  arg0, IDANumber *  arg1, IDAImage *  * ret);
    STDMETHOD(Overlay) (IDAImage *  arg0, IDAImage *  arg1, IDAImage *  * ret);
    STDMETHOD(OverlayArrayEx) (long sizearg0, IDAImage *  arg0[], IDAImage *  * ret);
    STDMETHOD(OverlayArray) (VARIANT arg0, IDAImage *  * ret);
    STDMETHOD(get_AmbientLight) (IDAGeometry *  * ret);
    STDMETHOD(get_DirectionalLight) (IDAGeometry *  * ret);
    STDMETHOD(get_PointLight) (IDAGeometry *  * ret);
    STDMETHOD(SpotLightAnim) (IDANumber *  arg0, IDANumber *  arg1, IDAGeometry *  * ret);
    STDMETHOD(SpotLight) (IDANumber *  arg0, double arg1, IDAGeometry *  * ret);
    STDMETHOD(get_DefaultLineStyle) (IDALineStyle *  * ret);
    STDMETHOD(get_EmptyLineStyle) (IDALineStyle *  * ret);
    STDMETHOD(get_JoinStyleBevel) (IDAJoinStyle *  * ret);
    STDMETHOD(get_JoinStyleRound) (IDAJoinStyle *  * ret);
    STDMETHOD(get_JoinStyleMiter) (IDAJoinStyle *  * ret);
    STDMETHOD(get_EndStyleFlat) (IDAEndStyle *  * ret);
    STDMETHOD(get_EndStyleSquare) (IDAEndStyle *  * ret);
    STDMETHOD(get_EndStyleRound) (IDAEndStyle *  * ret);
    STDMETHOD(get_DashStyleSolid) (IDADashStyle *  * ret);
    STDMETHOD(get_DashStyleDashed) (IDADashStyle *  * ret);
    STDMETHOD(get_DefaultMicrophone) (IDAMicrophone *  * ret);
    STDMETHOD(get_OpaqueMatte) (IDAMatte *  * ret);
    STDMETHOD(get_ClearMatte) (IDAMatte *  * ret);
    STDMETHOD(UnionMatte) (IDAMatte *  arg0, IDAMatte *  arg1, IDAMatte *  * ret);
    STDMETHOD(IntersectMatte) (IDAMatte *  arg0, IDAMatte *  arg1, IDAMatte *  * ret);
    STDMETHOD(DifferenceMatte) (IDAMatte *  arg0, IDAMatte *  arg1, IDAMatte *  * ret);
    STDMETHOD(FillMatte) (IDAPath2 *  arg0, IDAMatte *  * ret);
    STDMETHOD(TextMatte) (IDAString *  arg0, IDAFontStyle *  arg1, IDAMatte *  * ret);
    STDMETHOD(get_EmptyMontage) (IDAMontage *  * ret);
    STDMETHOD(ImageMontage) (IDAImage *  arg0, double arg1, IDAMontage *  * ret);
    STDMETHOD(ImageMontageAnim) (IDAImage *  arg0, IDANumber *  arg1, IDAMontage *  * ret);
    STDMETHOD(UnionMontage) (IDAMontage *  arg0, IDAMontage *  arg1, IDAMontage *  * ret);
    STDMETHOD(Concat) (IDAPath2 *  arg0, IDAPath2 *  arg1, IDAPath2 *  * ret);
    STDMETHOD(ConcatArrayEx) (long sizearg0, IDAPath2 *  arg0[], IDAPath2 *  * ret);
    STDMETHOD(ConcatArray) (VARIANT arg0, IDAPath2 *  * ret);
    STDMETHOD(Line) (IDAPoint2 *  arg0, IDAPoint2 *  arg1, IDAPath2 *  * ret);
    STDMETHOD(Ray) (IDAPoint2 *  arg0, IDAPath2 *  * ret);
    STDMETHOD(StringPathAnim) (IDAString *  arg0, IDAFontStyle *  arg1, IDAPath2 *  * ret);
    STDMETHOD(StringPath) (BSTR arg0, IDAFontStyle *  arg1, IDAPath2 *  * ret);
    STDMETHOD(PolylineEx) (long sizearg0, IDAPoint2 *  arg0[], IDAPath2 *  * ret);
    STDMETHOD(Polyline) (VARIANT arg0, IDAPath2 *  * ret);
    STDMETHOD(PolydrawPathEx) (long sizearg0, IDAPoint2 *  arg0[], long sizearg1, IDANumber *  arg1[], IDAPath2 *  * ret);
    STDMETHOD(PolydrawPath) (VARIANT arg0, VARIANT arg1, IDAPath2 *  * ret);
    STDMETHOD(ArcRadians) (double arg0, double arg1, double arg2, double arg3, IDAPath2 *  * ret);
    STDMETHOD(ArcRadiansAnim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDANumber *  arg3, IDAPath2 *  * ret);
    STDMETHOD(ArcDegrees) (double arg0, double arg1, double arg2, double arg3, IDAPath2 *  * ret);
    STDMETHOD(PieRadians) (double arg0, double arg1, double arg2, double arg3, IDAPath2 *  * ret);
    STDMETHOD(PieRadiansAnim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDANumber *  arg3, IDAPath2 *  * ret);
    STDMETHOD(PieDegrees) (double arg0, double arg1, double arg2, double arg3, IDAPath2 *  * ret);
    STDMETHOD(Oval) (double arg0, double arg1, IDAPath2 *  * ret);
    STDMETHOD(OvalAnim) (IDANumber *  arg0, IDANumber *  arg1, IDAPath2 *  * ret);
    STDMETHOD(Rect) (double arg0, double arg1, IDAPath2 *  * ret);
    STDMETHOD(RectAnim) (IDANumber *  arg0, IDANumber *  arg1, IDAPath2 *  * ret);
    STDMETHOD(RoundRect) (double arg0, double arg1, double arg2, double arg3, IDAPath2 *  * ret);
    STDMETHOD(RoundRectAnim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDANumber *  arg3, IDAPath2 *  * ret);
    STDMETHOD(CubicBSplinePathEx) (long sizearg0, IDAPoint2 *  arg0[], long sizearg1, IDANumber *  arg1[], IDAPath2 *  * ret);
    STDMETHOD(CubicBSplinePath) (VARIANT arg0, VARIANT arg1, IDAPath2 *  * ret);
    STDMETHOD(TextPath) (IDAString *  arg0, IDAFontStyle *  arg1, IDAPath2 *  * ret);
    STDMETHOD(get_Silence) (IDASound *  * ret);
    STDMETHOD(MixArrayEx) (long sizearg0, IDASound *  arg0[], IDASound *  * ret);
    STDMETHOD(MixArray) (VARIANT arg0, IDASound *  * ret);
    STDMETHOD(get_SinSynth) (IDASound *  * ret);
    STDMETHOD(get_DefaultFont) (IDAFontStyle *  * ret);
    STDMETHOD(FontAnim) (IDAString *  arg0, IDANumber *  arg1, IDAColor *  arg2, IDAFontStyle *  * ret);
    STDMETHOD(Font) (BSTR arg0, double arg1, IDAColor *  arg2, IDAFontStyle *  * ret);
    STDMETHOD(StringImageAnim) (IDAString *  arg0, IDAFontStyle *  arg1, IDAImage *  * ret);
    STDMETHOD(StringImage) (BSTR arg0, IDAFontStyle *  arg1, IDAImage *  * ret);
    STDMETHOD(TextImageAnim) (IDAString *  arg0, IDAFontStyle *  arg1, IDAImage *  * ret);
    STDMETHOD(TextImage) (BSTR arg0, IDAFontStyle *  arg1, IDAImage *  * ret);
    STDMETHOD(get_XVector2) (IDAVector2 *  * ret);
    STDMETHOD(get_YVector2) (IDAVector2 *  * ret);
    STDMETHOD(get_ZeroVector2) (IDAVector2 *  * ret);
    STDMETHOD(get_Origin2) (IDAPoint2 *  * ret);
    STDMETHOD(Vector2Anim) (IDANumber *  arg0, IDANumber *  arg1, IDAVector2 *  * ret);
    STDMETHOD(Vector2) (double arg0, double arg1, IDAVector2 *  * ret);
    STDMETHOD(Point2Anim) (IDANumber *  arg0, IDANumber *  arg1, IDAPoint2 *  * ret);
    STDMETHOD(Point2) (double arg0, double arg1, IDAPoint2 *  * ret);
    STDMETHOD(Vector2PolarAnim) (IDANumber *  arg0, IDANumber *  arg1, IDAVector2 *  * ret);
    STDMETHOD(Vector2Polar) (double arg0, double arg1, IDAVector2 *  * ret);
    STDMETHOD(Vector2PolarDegrees) (double arg0, double arg1, IDAVector2 *  * ret);
    STDMETHOD(Point2PolarAnim) (IDANumber *  arg0, IDANumber *  arg1, IDAPoint2 *  * ret);
    STDMETHOD(Point2Polar) (double arg0, double arg1, IDAPoint2 *  * ret);
    STDMETHOD(DotVector2) (IDAVector2 *  arg0, IDAVector2 *  arg1, IDANumber *  * ret);
    STDMETHOD(NegVector2) (IDAVector2 *  arg0, IDAVector2 *  * ret);
    STDMETHOD(SubVector2) (IDAVector2 *  arg0, IDAVector2 *  arg1, IDAVector2 *  * ret);
    STDMETHOD(AddVector2) (IDAVector2 *  arg0, IDAVector2 *  arg1, IDAVector2 *  * ret);
    STDMETHOD(AddPoint2Vector) (IDAPoint2 *  arg0, IDAVector2 *  arg1, IDAPoint2 *  * ret);
    STDMETHOD(SubPoint2Vector) (IDAPoint2 *  arg0, IDAVector2 *  arg1, IDAPoint2 *  * ret);
    STDMETHOD(SubPoint2) (IDAPoint2 *  arg0, IDAPoint2 *  arg1, IDAVector2 *  * ret);
    STDMETHOD(DistancePoint2) (IDAPoint2 *  arg0, IDAPoint2 *  arg1, IDANumber *  * ret);
    STDMETHOD(DistanceSquaredPoint2) (IDAPoint2 *  arg0, IDAPoint2 *  arg1, IDANumber *  * ret);
    STDMETHOD(get_XVector3) (IDAVector3 *  * ret);
    STDMETHOD(get_YVector3) (IDAVector3 *  * ret);
    STDMETHOD(get_ZVector3) (IDAVector3 *  * ret);
    STDMETHOD(get_ZeroVector3) (IDAVector3 *  * ret);
    STDMETHOD(get_Origin3) (IDAPoint3 *  * ret);
    STDMETHOD(Vector3Anim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAVector3 *  * ret);
    STDMETHOD(Vector3) (double arg0, double arg1, double arg2, IDAVector3 *  * ret);
    STDMETHOD(Point3Anim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAPoint3 *  * ret);
    STDMETHOD(Point3) (double arg0, double arg1, double arg2, IDAPoint3 *  * ret);
    STDMETHOD(Vector3SphericalAnim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAVector3 *  * ret);
    STDMETHOD(Vector3Spherical) (double arg0, double arg1, double arg2, IDAVector3 *  * ret);
    STDMETHOD(Point3SphericalAnim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDAPoint3 *  * ret);
    STDMETHOD(Point3Spherical) (double arg0, double arg1, double arg2, IDAPoint3 *  * ret);
    STDMETHOD(DotVector3) (IDAVector3 *  arg0, IDAVector3 *  arg1, IDANumber *  * ret);
    STDMETHOD(CrossVector3) (IDAVector3 *  arg0, IDAVector3 *  arg1, IDAVector3 *  * ret);
    STDMETHOD(NegVector3) (IDAVector3 *  arg0, IDAVector3 *  * ret);
    STDMETHOD(SubVector3) (IDAVector3 *  arg0, IDAVector3 *  arg1, IDAVector3 *  * ret);
    STDMETHOD(AddVector3) (IDAVector3 *  arg0, IDAVector3 *  arg1, IDAVector3 *  * ret);
    STDMETHOD(AddPoint3Vector) (IDAPoint3 *  arg0, IDAVector3 *  arg1, IDAPoint3 *  * ret);
    STDMETHOD(SubPoint3Vector) (IDAPoint3 *  arg0, IDAVector3 *  arg1, IDAPoint3 *  * ret);
    STDMETHOD(SubPoint3) (IDAPoint3 *  arg0, IDAPoint3 *  arg1, IDAVector3 *  * ret);
    STDMETHOD(DistancePoint3) (IDAPoint3 *  arg0, IDAPoint3 *  arg1, IDANumber *  * ret);
    STDMETHOD(DistanceSquaredPoint3) (IDAPoint3 *  arg0, IDAPoint3 *  arg1, IDANumber *  * ret);
    STDMETHOD(get_IdentityTransform3) (IDATransform3 *  * ret);
    STDMETHOD(Translate3Anim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDATransform3 *  * ret);
    STDMETHOD(Translate3) (double arg0, double arg1, double arg2, IDATransform3 *  * ret);
    STDMETHOD(Translate3Rate) (double arg0, double arg1, double arg2, IDATransform3 *  * ret);
    STDMETHOD(Translate3Vector) (IDAVector3 *  arg0, IDATransform3 *  * ret);
    STDMETHOD(Translate3Point) (IDAPoint3 *  arg0, IDATransform3 *  * ret);
    STDMETHOD(Scale3Anim) (IDANumber *  arg0, IDANumber *  arg1, IDANumber *  arg2, IDATransform3 *  * ret);
    STDMETHOD(Scale3) (double arg0, double arg1, double arg2, IDATransform3 *  * ret);
    STDMETHOD(Scale3Rate) (double arg0, double arg1, double arg2, IDATransform3 *  * ret);
    STDMETHOD(Scale3Vector) (IDAVector3 *  arg0, IDATransform3 *  * ret);
    STDMETHOD(Scale3UniformAnim) (IDANumber *  arg0, IDATransform3 *  * ret);
    STDMETHOD(Scale3Uniform) (double arg0, IDATransform3 *  * ret);
    STDMETHOD(Scale3UniformRate) (double arg0, IDATransform3 *  * ret);
    STDMETHOD(Rotate3Anim) (IDAVector3 *  arg0, IDANumber *  arg1, IDATransform3 *  * ret);
    STDMETHOD(Rotate3) (IDAVector3 *  arg0, double arg1, IDATransform3 *  * ret);
    STDMETHOD(Rotate3Rate) (IDAVector3 *  arg0, double arg1, IDATransform3 *  * ret);
    STDMETHOD(Rotate3Degrees) (IDAVector3 *  arg0, double arg1, IDATransform3 *  * ret);
    STDMETHOD(Rotate3RateDegrees) (IDAVector3 *  arg0, double arg1, IDATransform3 *  * ret);
    STDMETHOD(XShear3Anim) (IDANumber *  arg0, IDANumber *  arg1, IDATransform3 *  * ret);
    STDMETHOD(XShear3) (double arg0, double arg1, IDATransform3 *  * ret);
    STDMETHOD(XShear3Rate) (double arg0, double arg1, IDATransform3 *  * ret);
    STDMETHOD(YShear3Anim) (IDANumber *  arg0, IDANumber *  arg1, IDATransform3 *  * ret);
    STDMETHOD(YShear3) (double arg0, double arg1, IDATransform3 *  * ret);
    STDMETHOD(YShear3Rate) (double arg0, double arg1, IDATransform3 *  * ret);
    STDMETHOD(ZShear3Anim) (IDANumber *  arg0, IDANumber *  arg1, IDATransform3 *  * ret);
    STDMETHOD(ZShear3) (double arg0, double arg1, IDATransform3 *  * ret);
    STDMETHOD(ZShear3Rate) (double arg0, double arg1, IDATransform3 *  * ret);
    STDMETHOD(Transform4x4AnimEx) (long sizearg0, IDANumber *  arg0[], IDATransform3 *  * ret);
    STDMETHOD(Transform4x4Anim) (VARIANT arg0, IDATransform3 *  * ret);
    STDMETHOD(Compose3) (IDATransform3 *  arg0, IDATransform3 *  arg1, IDATransform3 *  * ret);
    STDMETHOD(Compose3ArrayEx) (long sizearg0, IDATransform3 *  arg0[], IDATransform3 *  * ret);
    STDMETHOD(Compose3Array) (VARIANT arg0, IDATransform3 *  * ret);
    STDMETHOD(LookAtFrom) (IDAPoint3 *  arg0, IDAPoint3 *  arg1, IDAVector3 *  arg2, IDATransform3 *  * ret);
    STDMETHOD(get_IdentityTransform2) (IDATransform2 *  * ret);
    STDMETHOD(Translate2Anim) (IDANumber *  arg0, IDANumber *  arg1, IDATransform2 *  * ret);
    STDMETHOD(Translate2) (double arg0, double arg1, IDATransform2 *  * ret);
    STDMETHOD(Translate2Rate) (double arg0, double arg1, IDATransform2 *  * ret);
    STDMETHOD(Translate2Vector) (IDAVector2 *  arg0, IDATransform2 *  * ret);
    STDMETHOD(Translate2Point) (IDAPoint2 *  arg0, IDATransform2 *  * ret);
    STDMETHOD(Scale2Anim) (IDANumber *  arg0, IDANumber *  arg1, IDATransform2 *  * ret);
    STDMETHOD(Scale2) (double arg0, double arg1, IDATransform2 *  * ret);
    STDMETHOD(Scale2Rate) (double arg0, double arg1, IDATransform2 *  * ret);
    STDMETHOD(Scale2Vector2) (IDAVector2 *  arg0, IDATransform2 *  * ret);
    STDMETHOD(Scale2Vector) (IDAVector2 *  arg0, IDATransform2 *  * ret);
    STDMETHOD(Scale2UniformAnim) (IDANumber *  arg0, IDATransform2 *  * ret);
    STDMETHOD(Scale2Uniform) (double arg0, IDATransform2 *  * ret);
    STDMETHOD(Scale2UniformRate) (double arg0, IDATransform2 *  * ret);
    STDMETHOD(Rotate2Anim) (IDANumber *  arg0, IDATransform2 *  * ret);
    STDMETHOD(Rotate2) (double arg0, IDATransform2 *  * ret);
    STDMETHOD(Rotate2Rate) (double arg0, IDATransform2 *  * ret);
    STDMETHOD(Rotate2Degrees) (double arg0, IDATransform2 *  * ret);
    STDMETHOD(Rotate2RateDegrees) (double arg0, IDATransform2 *  * ret);
    STDMETHOD(XShear2Anim) (IDANumber *  arg0, IDATransform2 *  * ret);
    STDMETHOD(XShear2) (double arg0, IDATransform2 *  * ret);
    STDMETHOD(XShear2Rate) (double arg0, IDATransform2 *  * ret);
    STDMETHOD(YShear2Anim) (IDANumber *  arg0, IDATransform2 *  * ret);
    STDMETHOD(YShear2) (double arg0, IDATransform2 *  * ret);
    STDMETHOD(YShear2Rate) (double arg0, IDATransform2 *  * ret);
    STDMETHOD(Transform3x2AnimEx) (long sizearg0, IDANumber *  arg0[], IDATransform2 *  * ret);
    STDMETHOD(Transform3x2Anim) (VARIANT arg0, IDATransform2 *  * ret);
    STDMETHOD(Compose2) (IDATransform2 *  arg0, IDATransform2 *  arg1, IDATransform2 *  * ret);
    STDMETHOD(Compose2ArrayEx) (long sizearg0, IDATransform2 *  arg0[], IDATransform2 *  * ret);
    STDMETHOD(Compose2Array) (VARIANT arg0, IDATransform2 *  * ret);
    STDMETHOD(get_ViewFrameRate) (IDANumber *  * ret);
    STDMETHOD(get_ViewTimeDelta) (IDANumber *  * ret);
    STDMETHOD(UnionMontageArrayEx) (long sizearg0, IDAMontage *  arg0[], IDAMontage *  * ret);
    STDMETHOD(UnionMontageArray) (VARIANT arg0, IDAMontage *  * ret);
    STDMETHOD(get_EmptyColor) (IDAColor *  * ret);
    STDMETHOD(TriMesh) (int nTriangles, VARIANT positions, VARIANT normals, VARIANT UVs, VARIANT indices, IDAGeometry **ret);
    STDMETHOD(TriMeshEx) (int nTriangles,
                          int nPositions,
                          float positions[],
                          int nNormals,
                          float normals[],
                          int nUVs,
                          float UVs[],
                          int nIndices,
                          int indices[],
                          IDAGeometry **ret);
    STDMETHOD(RadialGradientMulticolor) (VARIANT  offsets,
                                         VARIANT  colors,
                                         IDAImage **result);

    STDMETHOD(RadialGradientMulticolorEx) (
                          int        nOffsets,
                          IDANumber *offsets[],
                          int        nColors,
                          IDAColor  *colors[],
                          IDAImage **result);

    STDMETHOD(LinearGradientMulticolor) (VARIANT  offsets,
                                         VARIANT  colors,
                                         IDAImage **result);

    STDMETHOD(LinearGradientMulticolorEx) (
                          int        nOffsets,
                          IDANumber *offsets[],
                          int        nColors,
                          IDAColor  *colors[],
                          IDAImage **result);

    // OBSOLETED METHODS

    STDMETHOD(Array)(VARIANT pBvrs, IDAArray **bvr)
    { return DAArray(pBvrs, bvr); }

    STDMETHOD(Tuple)(VARIANT pBvrs, IDATuple **bvr)
    { return DATuple(pBvrs, bvr); }

    // END OBSOLETED METHODS

    CDAStatics();
    ~CDAStatics();

    IDASite * GetSite ();
    IOleClientSite * GetClientSite ();
    LPWSTR GetURLOfClientSite();
    IBindHost* GetBindHost ();

    bool GetPixelMode()
    { bool b ; Lock(); b = _bPixelMode; Unlock(); return b; }
    void SetPixelMode(bool b)
    { Lock(); _bPixelMode = b; Unlock(); }

    CRBvrPtr PixelToNumBvr(double d);
//    CRBvrPtr PixelToNumBvr(IDANumber * num);
    CRBvrPtr RatePixelToNumBvr(double d);
    CRBvrPtr PixelToNumBvr(CRBvrPtr b);
    double PixelToNum(double d);

    CRBvrPtr PixelYToNumBvr(double d);
//    CRBvrPtr PixelYToNumBvr(IDANumber * num);
    CRBvrPtr RatePixelYToNumBvr(double d);
    CRBvrPtr PixelYToNumBvr(CRBvrPtr b);
    double PixelYToNum(double d);

    CRSTDAPICB_(void) SetStatusText(LPCWSTR StatusText);
    CRSTDAPICB_(void) ReportError(HRESULT hr, LPCWSTR ErrorText);
    CRSTDAPICB_(void) ReportGC(bool bStarting);

    CRSTDAPICB_(void) SetStatusText(DWORD importId,
                                    LPCWSTR StatusText){}
    CRSTDAPICB_(void) ReportError(DWORD importId,
                                  HRESULT hr,
                                  LPCWSTR ErrorText)
    { ReportError(hr, ErrorText); }

    CRSTDAPICB_(void) OnImportCreate(DWORD importId, bool async)
    { if(!async) AddSyncImportSite(importId); }
    CRSTDAPICB_(void) OnImportStart(DWORD importId) {}
    CRSTDAPICB_(void) OnImportStop(DWORD importId)
    { RemoveSyncImportSite(importId) ; }

    void AddSyncImportSite(DWORD dwId);
    void RemoveSyncImportSite(DWORD dwId);
  protected:
    HRESULT Error();

    // These all increment/decrement the reference counts
    void SetSite (IDASite * pSite);
    void SetClientSite (IOleClientSite * pSite);

    DAComPtr<IDASite>            _pSite;
    DAComPtr<IOleClientSite>     _pOleClientSite;
    DAComPtr<IBindHost>          _pBH;
    LPWSTR                       _clientSiteURL;
    bool                         _bPixelMode;
    CritSect                     _cs;
    list < DWORD >               _importList;
    DWORD                        _dwModBvrFlags;

    HRESULT MakeSplineEx(int degree,
                         long numKnots,
                         IDANumber *knots[],
                         long numPts,
                         IDABehavior *ctrlPoints[],
                         long numWts,
                         IDANumber *weights[],
                         IDANumber *evaluator,
                         CR_BVR_TYPEID tid,
                         REFIID iid,
                         void **bvr);

    HRESULT MakeSpline(int degree,
                       VARIANT knots,
                       VARIANT ctrlPoints,
                       VARIANT weights,
                       IDANumber *evaluator,
                       CR_BVR_TYPEID tid,
                       REFIID iid,
                       void **bvr);
  private:
    HRESULT DoImportSound(LPOLESTR url,
                          IDAImportationResult **ppResult, bool stream);

    HRESULT DoImportMovie(LPOLESTR url,
                          IDAImportationResult **ppResult, bool stream);

};

#endif /* _STATICS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\server.cpp ===
/*******************************************************************************

Copyright (c) 1995 Microsoft Corporation

Abstract:

    Server Implementation

*******************************************************************************/

#include "headers.h"
#include "privinc/registry.h"

// =========================================
// Initialization
// =========================================

extern int gcStat = 1;
extern BOOL jitterStat = TRUE;
extern BOOL heapSizeStat = TRUE;
extern BOOL dxStat = TRUE;
extern int engineOptimization = 0;

double minFrameDuration = 1 / 30.0;  // prefs globals
bool   spritify         = false;     

static void UpdateUserPreferences(PrivatePreferences *prefs,
                                  Bool isInitializationTime)
{
    gcStat             = prefs->_gcStat;
    jitterStat         = prefs->_jitterStat;
    heapSizeStat       = prefs->_heapSizeStat;
    dxStat             = prefs->_dxStat;
    engineOptimization = prefs->_engineOptimization;
    minFrameDuration   = prefs->_minFrameDuration;
    spritify           = (prefs->_spritify==TRUE);

    PERFPRINTF(("Max. FPS = %g", 1.0 / minFrameDuration));
    PERFPRINTF((", GC Stat %s", (gcStat ? "On" : "Off")));
    PERFPRINTF((", Jitter Stat %s", (jitterStat ? "On" : "Off")));
    PERFPRINTF((", DirectX Stat %s", (dxStat ? "On" : "Off")));
    PERFPRINTF((", Optimizations "));
    if (engineOptimization < 2) {
        PERFPRINTF((engineOptimization ? "On" : "Off"));
    } else {
        PERFPRINTF(("%d", engineOptimization));
    }

    PERFPRINTLINE(());
}

void
InitializeModule_Server()
{
    ExtendPreferenceUpdaterList (UpdateUserPreferences);

    // Preferences won't be updated until a view is constructed, so
    // explicitly grab the key preferences that we need to have before
    // the view is in place.
    IntRegistryEntry engineOptimizationEntry("Engine",
                                             PREF_ENGINE_OPTIMIZATIONS_ON,
                                             1); 
    engineOptimization = engineOptimizationEntry.GetValue();
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\statics2.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Second file with methods on statics

*******************************************************************************/


#include "headers.h"
#include "srvprims.h"
#include "results.h"
#include "comcb.h"
#include "statics.h"
#include "context.h"
#include <DXTrans.h>
#include "privinc/util.h"
#include "privinc/geomi.h"

STDMETHODIMP
CDAStatics::ImportGeometryWrapped(
    LPOLESTR url,
    LONG wrapType,
    double originX,
    double originY,
    double originZ,
    double zAxisX,
    double zAxisY,
    double zAxisZ,
    double yAxisX,
    double yAxisY,
    double yAxisZ,
    double texOriginX,
    double texOriginY,
    double texScaleX,
    double texScaleY,
    DWORD flags,
    IDAGeometry **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportGeometryWrapped(%lx)", this));

    PRIMPRECODE1(bvr);

    CRGeometryPtr geo;
    DAComPtr<IBindHost> bh(GetBindHost(), false);

    DWORD id;
    id = CRImportGeometryWrapped(GetURLOfClientSite(),
                                 url,
                                 this,
                                 bh,
                                 NULL,
                                 &geo,
                                 NULL,
                                 NULL,
                                 NULL,
                                 wrapType,
                                 originX,
                                 originY,
                                 originZ,
                                 zAxisX,
                                 zAxisY,
                                 zAxisZ,
                                 yAxisX,
                                 yAxisY,
                                 yAxisZ,
                                 texOriginX,
                                 texOriginY,
                                 texScaleX,
                                 texScaleY,
                                 flags);

    if (id)
    {
        CreateCBvr(IID_IDAGeometry, (CRBvrPtr) geo, (void **) bvr);
    }

    PRIMPOSTCODE1(bvr);
}


STDMETHODIMP
CDAStatics::ImportGeometryWrappedAsync(
    LPOLESTR url,
    LONG wrapType,
    double originX,
    double originY,
    double originZ,
    double zAxisX,
    double zAxisY,
    double zAxisZ,
    double yAxisX,
    double yAxisY,
    double yAxisZ,
    double texOriginX,
    double texOriginY,
    double texScaleX,
    double texScaleY,
    DWORD flags,
    IDAGeometry *pGeoStandIn,
    IDAImportationResult **ppResult)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportGeometryWrappedAsync(%lx)", this));

    PRIMPRECODE1(ppResult);

    DAComPtr<IBindHost> bh(GetBindHost(), false);
    MAKE_BVR_TYPE_NAME(CRGeometryPtr, geostandin, pGeoStandIn);
    CRGeometryPtr pGeometry;
    CREventPtr pEvent;
    CRNumberPtr pProgress;
    CRNumberPtr pSize;

    DWORD id;
    id = CRImportGeometryWrapped(GetURLOfClientSite(),
                                 url,
                                 this,
                                 bh,
                                 geostandin,
                                 &pGeometry,
                                 &pEvent,
                                 &pProgress,
                                 &pSize,
                                 wrapType,
                                 originX,
                                 originY,
                                 originZ,
                                 zAxisX,
                                 zAxisY,
                                 zAxisZ,
                                 yAxisX,
                                 yAxisY,
                                 yAxisZ,
                                 texOriginX,
                                 texOriginY,
                                 texScaleX,
                                 texScaleY,
                                 flags);

    if (id)
    {
        CDAImportationResult::Create(NULL,
                                     NULL,
                                     pGeometry,
                                     NULL,
                                     pEvent,
                                     pProgress,
                                     pSize,
                                     ppResult);
    }

    PRIMPOSTCODE1(ppResult);
}

STDMETHODIMP
CDAStatics::ImportDirect3DRMVisual (
    IUnknown     *visual,
    IDAGeometry **bvr)
{

    TraceTag((tagCOMEntry, "CDAStatics::ImportDirect3DRMVisual(%lx)", this));

    PRIMPRECODE1(bvr) ;

    CHECK_RETURN_NULL(visual);

    CRGeometryPtr geo;

    geo = CRImportDirect3DRMVisual (visual);

    if (geo) {
        CreateCBvr(IID_IDAGeometry,
                   (CRBvrPtr) geo,
                   (void **) bvr) ;
    }

    PRIMPOSTCODE1(bvr) ;
}


STDMETHODIMP
CDAStatics::ImportDirect3DRMVisualWrapped (
    IUnknown *visual,
    LONG wrapType,
    double originX,
    double originY,
    double originZ,
    double zAxisX,
    double zAxisY,
    double zAxisZ,
    double yAxisX,
    double yAxisY,
    double yAxisZ,
    double texOriginX,
    double texOriginY,
    double texScaleX,
    double texScaleY,
    DWORD flags,
    IDAGeometry **bvr)
{
    TraceTag((tagCOMEntry, "CDAStatics::ImportDirect3DRMVisualWrapped(%lx)", this));

    PRIMPRECODE1(bvr) ;

    CHECK_RETURN_NULL(visual);

    CRGeometryPtr geo;

    geo = CRImportDirect3DRMVisualWrapped (
        visual,
        wrapType,
        originX,
        originY,
        originZ,
        zAxisX,
        zAxisY,
        zAxisZ,
        yAxisX,
        yAxisY,
        yAxisZ,
        texOriginX,
        texOriginY,
        texScaleX,
        texScaleY,
        flags );

    if (geo) {
        CreateCBvr(IID_IDAGeometry,
                   (CRBvrPtr) geo,
                   (void **) bvr) ;
    }

    PRIMPOSTCODE1(bvr) ;
}


void
CreateTransformHelper(IUnknown *theXfAsUnknown,
                      LONG                   numInputs,
                      CRBvrPtr              *inputs,
                      CRBvrPtr               evaluator,
                      IOleClientSite        *clientSite,
                      IDADXTransformResult **ppResult)
{
    HRESULT hr;

    CRDXTransformResultPtr xfResult = CRApplyDXTransform(theXfAsUnknown,
                                                         numInputs,
                                                         inputs,
                                                         evaluator);

    if (xfResult) {

        // Set the bindhost on the transform if it'll accept it.
        DAComPtr<IDXTBindHost> bindHostObj;
        hr = theXfAsUnknown->QueryInterface(IID_IDXTBindHost,
                                            (void **)&bindHostObj);

        if (SUCCEEDED(hr) && clientSite) {

            DAComPtr<IServiceProvider> servProv;
            DAComPtr<IBindHost> bh;
            hr = clientSite->QueryInterface(IID_IServiceProvider,
                                            (void **)&servProv);
            if (SUCCEEDED(hr)) {
                hr = servProv->QueryService(SID_IBindHost,
                                            IID_IBindHost,
                                            (void**)&bh);

                if (SUCCEEDED(hr)) {
                    hr = bindHostObj->SetBindHost(bh);
                    // Harmless if this fails, just carry on.
                }
            }
        }

        DAComPtr<IDispatch> xf;
        hr = theXfAsUnknown->QueryInterface(IID_IDispatch,
                                            (void **)&xf);

        // This NULL-ing should happen automatically, but it doesn't
        // always work this way, so we do it here.
        if (FAILED(hr)) {
            xf.p = NULL;
            hr = S_OK;
        }

        hr = CDADXTransformResult::Create(xf,
                                          xfResult,
                                          ppResult);
    }
}

STDMETHODIMP
CDAStatics::ApplyDXTransformEx(IUnknown *theXfAsUnknown,
                               LONG numInputs,
                               IDABehavior **inputs,
                               IDANumber *evaluator,
                               IDADXTransformResult **ppResult)
{
    TraceTag((tagCOMEntry, "CDAStatics::ApplyDXTransformEx(%lx)", this));

    PRIMPRECODE1(ppResult);

    // Grab client site, but don't do an add'l addref, as
    // GetClientSite() already does one.
    DAComPtr<IOleClientSite> cs(GetClientSite(), false);

    CRBvrPtr *bvrArray = CBvrsToBvrs(numInputs, inputs);
    if (bvrArray == NULL) goto done;

    CRBvrPtr evalBvr;
    if (evaluator) {
        evalBvr = ::GetBvr(evaluator);
        if (evalBvr == NULL) goto done;
    } else {
        evalBvr = NULL;
    }

    CreateTransformHelper(theXfAsUnknown,
                          numInputs,
                          bvrArray,
                          evalBvr,
                          cs,
                          ppResult);

    PRIMPOSTCODE1(ppResult);
}

#define IS_VARTYPE(x,vt) ((V_VT(x) & VT_TYPEMASK) == (vt))
#define IS_VARIANT(x) IS_VARTYPE(x,VT_VARIANT)
#define GET_VT(x) (V_VT(x) & VT_TYPEMASK)

// Grabbed mostly from cbvr.cpp:SafeArrayAccessor::SafeArrayAccessor().
bool
GrabBvrFromVariant(VARIANT v, CRBvrPtr *res)
{
    CRBvrPtr evalBvr = NULL;

    HRESULT hr = S_OK;

    VARIANT *pVar;
    if (V_ISBYREF(&v) && !V_ISARRAY(&v) && IS_VARIANT(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    if (IS_VARTYPE(pVar, VT_EMPTY) ||
        IS_VARTYPE(pVar, VT_NULL)) {

        evalBvr = NULL;

    } else if (IS_VARTYPE(pVar, VT_DISPATCH)) {

        IDispatch *pdisp;

        if (V_ISBYREF(pVar)) {
            pdisp = *V_DISPATCHREF(pVar);
        } else {
            pdisp = V_DISPATCH(pVar);
        }

        DAComPtr<IDANumber> evalNum;
        hr = pdisp->QueryInterface(IID_IDANumber, (void **)&evalNum);

        if (FAILED(hr)) {
            CRSetLastError(E_INVALIDARG, NULL);
        } else {
            evalBvr = ::GetBvr(evalNum);
        }

    } else {

        CRSetLastError(E_INVALIDARG, NULL);
        evalBvr = NULL;
        hr = E_INVALIDARG;

    }

    *res = evalBvr;

    return SUCCEEDED(hr);
}

STDMETHODIMP
CDAStatics::ApplyDXTransform(VARIANT varXf,
                             VARIANT inputs,
                             VARIANT evalVariant,
                             IDADXTransformResult **ppResult)
{
    TraceTag((tagCOMEntry, "CDAStatics::ApplyDXTransform(%lx)", this));
    DAComPtr<IUnknown> punk;

    PRIMPRECODE1(ppResult);
    CComVariant var;
    
    HRESULT hr = var.ChangeType(VT_BSTR, &varXf);
    if (SUCCEEDED(hr))
    {
        CLSID   clsid;

        Assert(var.vt == VT_BSTR);

        // Extract out clsid from string and try to cocreate on it.
        hr  = CLSIDFromString(V_BSTR(&var), &clsid);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CDAStatics::ApplyDXTransform(%lx) - CLSIDFromString() failed", this));
            RaiseException_UserError(hr, IDS_ERR_EXTEND_DXTRANSFORM_CLSID_FAIL);
        }

        // cocreate on clsid
        hr = CoCreateInstance(clsid,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IUnknown,
                              (void **)&punk);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CDAStatics::ApplyDXTransform(%lx) - CoCreateInstance() failed", this));
            RaiseException_UserError(hr, IDS_ERR_EXTEND_DXTRANSFORM_FAILED_LOAD, V_BSTR(&var));
        }
    }
    else
    {
        hr = var.ChangeType(VT_UNKNOWN, &varXf);
        if (SUCCEEDED(hr))
        {
            punk = var.punkVal;
        }
        else
        {
            TraceTag((tagError, "CDAStatics::ApplyDXTransform(%lx) - invalidarg", this));
            RaiseException_UserError(E_INVALIDARG, IDS_ERR_INVALIDARG);
        }
    }
    // Use NULL for type info, since this may be a heterogenous list
    SafeArrayAccessor inputSA(inputs, false, CRUNKNOWN_TYPEID, true, true);
    if (!inputSA.IsOK()) return Error();

    CRBvrPtr *inputBvrs = inputSA.ToBvrArray((CRBvrPtr *)_alloca(inputSA.GetNumObjects() * sizeof(CRBvrPtr)));

    if (inputBvrs==NULL)
        return Error();
 
    CRBvrPtr evalBvr;

    if (GrabBvrFromVariant(evalVariant, &evalBvr)) {
        CreateTransformHelper(punk,
                              inputSA.GetNumObjects(),
                              inputBvrs,
                              evalBvr,
                              GetClientSite(),
                              ppResult);
    } else {
        return Error();
    }

    PRIMPOSTCODE1(ppResult);
}

STDMETHODIMP
CDAStatics::ModifiableNumber(double initVal,
                             IDANumber **ppResult)
{
    PRIMPRECODE1(ppResult);

    CreateCBvr(IID_IDANumber, (CRBvrPtr) CRModifiableNumber(initVal), (void **)ppResult);

    PRIMPOSTCODE1(ppResult);
}

STDMETHODIMP
CDAStatics::ModifiableString(BSTR initVal,
                             IDAString **ppResult)
{
    TraceTag((tagCOMEntry, "CDAStatics::ModifiableString(%lx)", this));

    PRIMPRECODE1(ppResult);

    CreateCBvr(IID_IDAString, (CRBvrPtr) CRModifiableString(initVal), (void **)ppResult);

    PRIMPOSTCODE1(ppResult);
}

STDMETHODIMP
CDAStatics::get_ModifiableBehaviorFlags(DWORD * pdwFlags)
{
    TraceTag((tagCOMEntry, "CDAStatics::get_ModifiableBehaviorFlags(%lx)", this));

    CHECK_RETURN_NULL(pdwFlags);

    CritSectGrabber csg(_cs);

    *pdwFlags = _dwModBvrFlags;

    return S_OK;
}

STDMETHODIMP
CDAStatics::put_ModifiableBehaviorFlags(DWORD dwFlags)
{
    TraceTag((tagCOMEntry, "CDAStatics::put_ModifiableBehaviorFlags(%lx)", this));

    CritSectGrabber csg(_cs);

    _dwModBvrFlags = dwFlags;

    return S_OK;
}



/*****************************************************************************
The TriMesh parameters are variant arrays, and should be able to accomodate
several types of elements.  'positions' should handle arrays of Point3 or
floating-point triples (either 4-byte or 8-byte floats).  Similarly, 'normals'
should handle arrays of Vector3 or float triples, and UVs should handle arrays
of Point2 or float tuples.
*****************************************************************************/

STDMETHODIMP
CDAStatics::TriMesh (
    int           nTriangles,   // Number of Triangles in Mesh
    VARIANT       positions,    // Array of Vertex Positions
    VARIANT       normals,      // Array of Vertex Normals
    VARIANT       UVs,          // Array of Vertex Surface Coordiantes
    VARIANT       indices,      // Array of Triangle Vertex Indices
    IDAGeometry **result)       // Resultant TriMesh Geometry
{
    TraceTag((tagCOMEntry, "CDAStatics::TriMesh(%lx)", this));

    PRIMPRECODE1 (result);

    bool errorflag = true;
    CRBvr *trimesh = NULL;

    // The TriMeshData object is used to hold all of the information necessary
    // to create the trimesh.

    TriMeshData tm;

    tm.numTris = nTriangles;

    // Extract the trimesh indices array.  This can either be null or an array
    // of 32-bit integers.

    SafeArrayAccessor sa_indices (indices, false, CRNUMBER_TYPEID, true);
    if (!sa_indices.IsOK()) goto cleanup;

    tm.numIndices = static_cast<int> (sa_indices.GetNumObjects());
    tm.indices    = sa_indices.ToIntArray();

    if ((tm.numIndices > 0) && !tm.indices)
    {
        DASetLastError (DISP_E_TYPEMISMATCH, IDS_ERR_GEO_TMESH_BAD_INDICES);
        goto cleanup;
    }

    // Extract the trimesh vertex positions.  These can be a variant array of
    // either floats, doubles, or Point3's.  The SrvArrayBvr() call below will
    // map doubles and floats to an array of floats, or it will return a
    // pointer to an array behavior (of Point3's).

    unsigned int count;   // Number of non-behavior elements returned.
    CRArrayPtr   bvrs;    // Array of Behaviors
    void        *floats;  // Array of Floats

    bvrs = SrvArrayBvr (positions, false, CRPOINT3_TYPEID, 0,
                        ARRAYFILL_FLOAT, &floats, &count);

    tm.vPosFloat = static_cast<float*> (floats);

    Assert (!(bvrs && tm.vPosFloat));   // Expect only one to be non-null.

    if (bvrs)
        tm.numPos = (int) ArrayExtractElements (bvrs, tm.vPosPoint3);
    else if (tm.vPosFloat)
        tm.numPos = (int) count;
    else
        goto cleanup;

    // Extract the vertex normals.  As for positions, this can be a variant
    // array of floats, doubles, or Vector3's.

    bvrs = SrvArrayBvr (normals, false, CRVECTOR3_TYPEID, 0,
                        ARRAYFILL_FLOAT, &floats, &count);

    tm.vNormFloat = static_cast<float*> (floats);

    Assert (! (bvrs && tm.vNormFloat));   // Expect only one to be non-null.

    if (bvrs)
        tm.numNorm = (int) ArrayExtractElements (bvrs, tm.vNormVector3);
    else if (tm.vPosFloat)
        tm.numNorm = (int) count;
    else
        goto cleanup;

    // Extract the vertex surface coordinates.  This variant array can be
    // floats, doubles, or Point2's.

    bvrs = SrvArrayBvr (UVs, false, CRPOINT2_TYPEID, 0,
                        ARRAYFILL_FLOAT, &floats, &count);

    tm.vUVFloat = static_cast<float*> (floats);

    Assert (! (bvrs && tm.vUVFloat));   // Expect only one to be non-null.

    if (bvrs)
        tm.numUV = (int) ArrayExtractElements (bvrs, tm.vUVPoint2);
    else if (tm.vUVFloat)
        tm.numUV = (int) count;
    else
        goto cleanup;

    // Create the resulting trimesh.

    trimesh = CRTriMesh (tm);

    if (trimesh && CreateCBvr(IID_IDAGeometry, trimesh, (void **)result))
        errorflag = false;

  cleanup:

    // All of the scalar arrays passed in were allocated with system memory
    // in the extractions above.  Now that we've created the trimesh we can
    // release the memory here.

    if (tm.vPosFloat)  delete tm.vPosFloat;
    if (tm.vNormFloat) delete tm.vNormFloat;
    if (tm.vUVFloat)   delete tm.vUVFloat;
    if (tm.indices)    delete tm.indices;

    if (errorflag) return Error();

    PRIMPOSTCODE1 (result);
}



STDMETHODIMP
CDAStatics::TriMeshEx (
    int           nTriangles,   // Number of Triangles in Mesh
    int           nPositions,   // Number of Vertex Positions
    float         positions[],  // Array  of Vertex Positions
    int           nNormals,     // Number of Vertex Normals
    float         normals[],    // Array  of Vertex Normals
    int           nUVs,         // Number of Vertex Surface Coordinates
    float         UVs[],        // Array  of Vertex Surface Coordinates
    int           nIndices,     // Number of Triangle Vertex Indices
    int           indices[],    // Array  of Triangle Vertex Indices
    IDAGeometry **result)       // Resultant TriMesh Geometry
{
    TraceTag((tagCOMEntry, "CDAStatics::TriMesh(%lx)", this));

    PRIMPRECODE1 (result);

    TriMeshData tm;

    tm.numTris    = nTriangles;
    tm.numIndices = nIndices;
    tm.indices    = indices;
    tm.numPos     = nPositions;
    tm.vPosFloat  = positions;
    tm.numNorm    = nNormals;
    tm.vNormFloat = normals;
    tm.numUV      = nUVs;
    tm.vUVFloat   = UVs;

    CreateCBvr (IID_IDAGeometry, ::CRTriMesh(tm), (void**)result);

    PRIMPOSTCODE1 (result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\results.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

*******************************************************************************/


#include "headers.h"
#include "results.h"
#include "privinc/dxxf.h"
#include "cbvr.h"
#include "srvprims.h"

#define PROP_RETURNER(classAndMethod, propType, memberName) \
  STDMETHODIMP                                      \
  classAndMethod(propType **ppResult) {             \
      CHECK_RETURN_SET_NULL(ppResult);              \
      if ((memberName).p) {                         \
          *ppResult = (memberName);                 \
          (memberName).p->AddRef();                 \
      }                                             \
      return S_OK;                                  \
  }

#define BVR_RETURNER(classAndMethod, propType, exp)             \
  STDMETHODIMP                                                  \
  classAndMethod(propType **ppResult) {                         \
      CHECK_RETURN_SET_NULL(ppResult);                          \
      CRLockGrabber __gclg;                                     \
      CRBvrPtr b = (CRBvrPtr) exp;                              \
      if (b) {                                                  \
          if (!CreateCBvr(IID_##propType,                       \
                          b,                                    \
                          (void **) ppResult))                  \
              return CRGetLastError();                          \
      }                                                         \
      return S_OK;                                              \
  }

//////////////////////////  CDAPickableResult   ////////////////

BVR_RETURNER(CDAPickableResult::get_Image, IDAImage, CRGetImage(_result));
BVR_RETURNER(CDAPickableResult::get_Geometry, IDAGeometry, CRGetGeometry(_result));
BVR_RETURNER(CDAPickableResult::get_PickEvent, IDAEvent, CRGetEvent(_result));


// Static method
bool
CDAPickableResult::Create(CRPickableResult *res,
                          IDAPickableResult **ppResult)
{
    *ppResult = NULL;
    DAComObject<CDAPickableResult> *pNew;
    DAComObject<CDAPickableResult>::CreateInstance(&pNew);

    HRESULT hr = E_OUTOFMEMORY;
    if (pNew) {
        pNew->_result = res;
        hr = pNew->QueryInterface(IID_IDAPickableResult,
                                  (void **)ppResult);
        if (FAILED(hr)) {
            delete pNew;
        }
    }

    if (FAILED(hr)) {
        CRSetLastError(hr, NULL);
        return false;
    } else {
        return true;
    } 
}

//////////////////////////  CDAImportationResult   ////////////////

BVR_RETURNER(CDAImportationResult::get_Image, IDAImage, _image)
BVR_RETURNER(CDAImportationResult::get_Sound, IDASound, _sound)
BVR_RETURNER(CDAImportationResult::get_Geometry, IDAGeometry, _geom)

BVR_RETURNER(CDAImportationResult::get_Duration, IDANumber, _duration)
BVR_RETURNER(CDAImportationResult::get_Progress, IDANumber, _progress)
BVR_RETURNER(CDAImportationResult::get_Size, IDANumber, _size)
    
BVR_RETURNER(CDAImportationResult::get_CompletionEvent,
             IDAEvent, _completionEvent)


// Static method
HRESULT
CDAImportationResult::Create(CRImage *img,
                             CRSound *snd,
                             CRGeometry *geom,
                             CRNumber *duration,
                             CREvent *event,
                             CRNumber *progress,
                             CRNumber *size,
                             IDAImportationResult **ppResult)
{
    DAComObject<CDAImportationResult> *pNew;
    DAComObject<CDAImportationResult>::CreateInstance(&pNew);

    *ppResult = NULL;
    HRESULT hr = E_OUTOFMEMORY;
    if (pNew) {
        pNew->_image = (CRBvrPtr)img;
        pNew->_sound = (CRBvrPtr)snd;
        pNew->_geom = (CRBvrPtr)geom;
        pNew->_duration = (CRBvrPtr)duration;
        pNew->_progress = (CRBvrPtr)progress;
        pNew->_size = (CRBvrPtr)size;
        pNew->_completionEvent = (CRBvrPtr)event;
        hr = pNew->QueryInterface(IID_IDAImportationResult,
                                  (void **)ppResult);
        if (FAILED(hr)) {
            delete pNew;
        }
    }

    return hr;
}

//////////////////////  CDADXTransformResult   ////////////////

PROP_RETURNER(CDADXTransformResult::get_TheTransform, IDispatch, _theTransform)

// Static method
HRESULT
CDADXTransformResult::Create(IDispatch *theXf,
                             CRDXTransformResultPtr  bvr,
                             IDADXTransformResult **ppResult)
{
    DAComObject<CDADXTransformResult> *pNew;
    DAComObject<CDADXTransformResult>::CreateInstance(&pNew);

    *ppResult = NULL;
    HRESULT hr = E_OUTOFMEMORY;
    if (pNew) {
        pNew->_theTransform = theXf;
        pNew->_xfResult = bvr;

        hr = pNew->QueryInterface(IID_IDADXTransformResult,
                                  (void **)ppResult);
    }

    if (FAILED(hr)) {
        delete pNew;
        CRSetLastError(hr, NULL);
    }

    return hr;
}

STDMETHODIMP
CDADXTransformResult::PutBvrAsProperty(BSTR property,
                                       IDABehavior *comBvr)
{
    PRIMPRECODE0(ok);

    MAKE_BVR_NAME(crbvr, comBvr);

    ok = CRSetBvrAsProperty(_xfResult,
                            property,
                            crbvr);

    PRIMPOSTCODE0(ok);
}

BVR_RETURNER(CDADXTransformResult::get_OutputBvr,
             IDABehavior,
             CRGetOutputBvr(_xfResult))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\results.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Declaration of Importation and Pickable result interfaces.

*******************************************************************************/


#ifndef _RESULTS_H
#define _RESULTS_H

#include <dxtrans.h>
#include <comconv.h>

class
__declspec(uuid("BCBB1F74-E384-11d0-9B99-00C04FC2F51D")) 
ATL_NO_VTABLE CDAPickableResult
    : public CComObjectRootEx<CComMultiThreadModel>,
      public CComCoClass<CDAPickableResult, &__uuidof(CDAPickableResult)>,
      public IDispatchImpl<IDAPickableResult, &IID_IDAPickableResult, &LIBID_DirectAnimation>,
      public IObjectSafetyImpl<CDAPickableResult>,
      public ISupportErrorInfoImpl<&IID_IDAPickableResult>
{
  public:
#if _DEBUG
    const char * GetName() { return "CDAPickableResult"; }
#endif
    BEGIN_COM_MAP(CDAPickableResult)
        COM_INTERFACE_ENTRY(IDAPickableResult)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP()
        
    STDMETHOD(get_Image)(IDAImage **ppImg);
    STDMETHOD(get_Geometry)(IDAGeometry **ppGeo);
    STDMETHOD(get_PickEvent)(IDAEvent **ppPickEvent);

    static bool Create(CRPickableResult *res,
                       IDAPickableResult **result);
  protected:
    CRPtr<CRPickableResult> _result;
};



class
__declspec(uuid("BCBB1F75-E384-11d0-9B99-00C04FC2F51D")) 
ATL_NO_VTABLE CDAImportationResult
    : public CComObjectRootEx<CComMultiThreadModel>,
      public CComCoClass<CDAImportationResult, &__uuidof(CDAImportationResult)>,
      public IDispatchImpl<IDAImportationResult, &IID_IDAImportationResult, &LIBID_DirectAnimation>,
      public IObjectSafetyImpl<CDAImportationResult>,
      public ISupportErrorInfoImpl<&IID_IDAImportationResult>
{
  public:
#if _DEBUG
    const char * GetName() { return "CDAImportationResult"; }
#endif
    BEGIN_COM_MAP(CDAImportationResult)
        COM_INTERFACE_ENTRY(IDAImportationResult)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP()
        
    STDMETHOD(get_Image)(IDAImage **ppImg);
    STDMETHOD(get_Sound)(IDASound **ppSnd);
    STDMETHOD(get_Geometry)(IDAGeometry **ppGeo);
    STDMETHOD(get_Duration)(IDANumber **ppDuration);
    STDMETHOD(get_Progress)(IDANumber **ppProgress);
    STDMETHOD(get_Size)(IDANumber **ppSize);
    STDMETHOD(get_CompletionEvent)(IDAEvent **ppCompletionEvent);

    static HRESULT Create(CRImage             *img,
                          CRSound             *snd,
                          CRGeometry          *geom,
                          CRNumber            *duration,
                          CREvent             *event,
                          CRNumber            *progress,
                          CRNumber            *size,
                          IDAImportationResult **result);

  protected:
    CRPtr<CRBvr>    _image;
    CRPtr<CRBvr>    _sound;
    CRPtr<CRBvr>    _geom;
    CRPtr<CRBvr>    _duration;
    CRPtr<CRBvr>    _progress;
    CRPtr<CRBvr>    _size;
    CRPtr<CRBvr>    _completionEvent;
};



class
__declspec(uuid("5E3BF06E-4B11-11d1-9BC8-00C04FC2F51D"))
ATL_NO_VTABLE CDADXTransformResult
    : public CComObjectRootEx<CComMultiThreadModel>,
      public CComCoClass<CDADXTransformResult, &__uuidof(CDADXTransformResult)>,
      public IDispatchImpl<IDADXTransformResult, &IID_IDADXTransformResult, &LIBID_DirectAnimation>,
      public IObjectSafetyImpl<CDADXTransformResult>,
      public ISupportErrorInfoImpl<&IID_IDADXTransformResult>
{
  public:
#if _DEBUG
    const char * GetName() { return "CDADXTransformResult"; }
#endif
    BEGIN_COM_MAP(CDADXTransformResult)
        COM_INTERFACE_ENTRY(IDADXTransformResult)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP()
        
    STDMETHOD(get_OutputBvr)(IDABehavior **ppOutputBvr);
    STDMETHOD(get_TheTransform)(IDispatch **ppTransform);

    STDMETHOD(PutBvrAsProperty)(BSTR property,
                                IDABehavior *bvr);

    static HRESULT Create(IDispatch             *theXf,
                          CRDXTransformResultPtr bvr,
                          IDADXTransformResult **ppResult);

    HRESULT Error()
    { return CRGetLastError(); }
  protected:
    CRPtr<CRDXTransformResult>    _xfResult;
    CComPtr<IDispatch>            _theTransform;
};


#endif /* _RESULTS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\view.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of views.
    TODO: This file needs to be broken up and lots of code factoring.

*******************************************************************************/


#include "headers.h"
#include <ocmm.h>
#include "context.h"
#include "view.h"
#include "privinc/resource.h"
#include "backend/values.h"
#include "backend/timetran.h"
#include "backend/gc.h"
#include "privinc/probe.h"
#include "privinc/snddev.h"
#include "privinc/backend.h"
#include "privinc/util.h"
#include "backend/bvr.h"
#include "backend/perf.h"
#include "backend/jaxaimpl.h"
#include "backend/sprite.h"
#include "privinc/debug.h"
#include "privinc/dddevice.h"
#include "privinc/opt.h"
#include "include/appelles/hacks.h"
#include "privinc/vec2i.h"
#include "privinc/spriteThread.h"
#include "backend/sndbvr.h"

#if DEVELOPER_DEBUG
extern "C" CRSTDAPI_(DWORD) GetTotalMemory();
#endif

extern bool spritify;
extern bool bShowFPS;           // flag for showing the frame rate.

#if PRODUCT_PROF
#include "../../../tools/x86/icecap/icapexp.h"
#endif /* PRODUCT_PROF */

#define BOGUS_SOUND_CLASS "DANIMHiddenSoundWindowClass"

#ifdef _DEBUG
extern "C" void PrintObj(GCBase* b);

DeclareTag(tagIndicateRBConst, "Optimizations", "ack if view is const");
DeclareTag(tagDisableRBConst, "Optimizations", "disable checking rbconst");
DeclareTag(tagDisableDirtyRects, "Optimizations", "disable dirty rects");
DeclareTag(tagDisableRendering, "Optimizations", "disable rendering");

void PrintRect(RECT & r,char * str = "")
{
    char buf[2048];
    sprintf (buf,
             "%s: left - %d, top - %d, right - %d, bottom - %d\n",
             str,
             r.left,r.top,r.right,r.bottom);

    printf (buf);
    OutputDebugString(buf);
}
#endif /* _DEBUG */

#if PERFORMANCE_REPORTING
static DWORD g_dllStartTime = 0;
static DWORD g_prevAvailMemory = 0;
#endif

// Couldn't use template because only differ in return type...
inline Image *ValImage(AxAValue v)
{
    Assert(dynamic_cast<Image *>(v) != NULL);

    return ((Image*) v);
}


inline Sound *ValSound(AxAValue v)
{
    Assert(dynamic_cast<Sound *>(v) != NULL);

    return ((Sound*) v);
}

const DWORD ReportThreshold = 10 ;

#if _DEBUGMEM
_CrtMemState diff, oldState, newState;
#endif


// =========================================================
// View Implementation
// =========================================================

View::View ()
:
#if PERFORMANCE_REPORTING
  _sampleTime(0),
  _pickTime(0),
  _gcTime(0),
  _numSamples(0),
  _renderTime(0),
  _viewStartTime(GetTickCount()),
#endif
  _FPSNumSamples(0),
  _FPSLastReportTime(0),
  _FPS(0),
  _numFrames(0),
  _lastRenderingTime(0),
  _lastReportTime(0),
  _renderTimeIdx(0),
  _totalTime(0),
  _sndPerf(NULL),
  _imgPerf(NULL),
  _sndVal(NULL),
  _imgVal(NULL),
  _imgForQueryHitPt(NULL),
  _firstRendering(true),
  _lastSampleTime(0.0),
  _lastSystemTime(0),
  _currentSystemTime(0),
  _currentSampleTime(0.0),
  _someEventHappened(false),
  _isRBConst(false),
  _toPaint(3),
  _repaintCalled(false),
  _bogusSoundHwnd(NULL),
  _imageDev(NULL),
  _soundDev(NULL),
  _devInited(FALSE),
  _runId(0),
  _pickEvents(0),
  _sampleHeap(NULL),
  _renderHeap(NULL),
  _queryHitPointHeap(NULL),
  _rbHeap(NULL),
  _isStarted(false),
  _soundSprite(NULL),
  _rmSound(NULL),
  _spriteThread(NULL),
  _importEvent(true, true),
  _lastRBId(0),
  _lastSampleId(PERF_CREATION_INITIAL_LAST_SAMPLE_ID),
  _sndList(NULL),
  _sampleId(-1),
  _dirtyRectsDisabled(false),
  _lastCondsCheckTime(0),
  _modelStartTime(0),
  _emptyImageSoFar(true),
  _firstSample(true)
{
    _targetPackage.Reset();
    _oldTargetPackage.Reset();

#ifdef _DEBUG
    bool trackit = false;

    if (trackit) {
#if _DEBUGMEM
        _CrtMemCheckpoint(&oldState);
#endif
    }
#endif

    // We're not in the view set yet, this can make _genList
    // inconsistent, that is, a GC can come in and remove DXBaseObject
    // w/o letting this view know as it's not in the set and will not
    // get iterated.

    //PopulateDXBaseObjects();
}


View::~View ()
{
    Stop();

#ifdef _DEBUG
    bool trackit = false;

    if (trackit) {
        //GarbageCollect(true, true);
        Sleep(1000);                // wait for GC to finish
#if _DEBUGMEM
        _CrtMemCheckpoint(&newState);
        _CrtMemDifference(&diff, &oldState, &newState);
        _CrtMemDumpStatistics(&diff);
        _CrtMemDumpAllObjectsSince(&oldState);
#endif
    }
#endif
}

HWND
View::CreateViewWindow()
{
    {
        WNDCLASS wndclass;

        memset(&wndclass, 0, sizeof(WNDCLASS));
        wndclass.style          = 0;
        wndclass.lpfnWndProc    = DefWindowProc;
        wndclass.hInstance      = hInst;
        wndclass.hCursor        = NULL;
        wndclass.hbrBackground  = NULL;
        wndclass.lpszClassName  = BOGUS_SOUND_CLASS;

        RegisterClass(&wndclass) ;
    }

    return ::CreateWindow (BOGUS_SOUND_CLASS,
                           "danim hidden sound window",
                           0,0,0,0,0,NULL,NULL,hInst,NULL);
}


void
View::CreateDevices(bool needSoundDevice, bool needImageDevice)
{
    if (!_devInited) {

        // If we don't need a sound, simply don't create the sound
        // device.

        if(needSoundDevice && IsWindowless()) {
            // for version 2 replace CreateViewWindow with GetDesktopWindow()

            _bogusSoundHwnd = CreateViewWindow();  // window to make dsound happy
            _soundDev = CreateSoundDevice(_bogusSoundHwnd, 0.0);
        }

        if (needImageDevice) {
            _imageDev = CreateImageDisplayDevice();
        }

        if(needSoundDevice && !IsWindowless()) {
            // make sure they are not lying to us w/a null hwnd!
            if(!_targetPackage.GetHWND())
                RaiseException_UserError(E_INVALIDARG, IDS_ERR_SRV_INVALID_DEVICE);

            _soundDev = CreateSoundDevice(_targetPackage.GetHWND(), 0.0);
        }

        _devInited = TRUE ;
    }
}


void
View::DestroyDevices()
{
    if (_imageDev) {
        DestroyImageDisplayDevice(_imageDev);
        _imageDev = NULL ;
    }

    if (_soundDev) {
        DestroySoundDirectDev(_soundDev);
        _soundDev = NULL ;
    }

    if (_bogusSoundHwnd) {
        DestroyWindow(_bogusSoundHwnd) ;
        _bogusSoundHwnd = NULL ;
    }

    _targetPackage.Reset();
    _oldTargetPackage.Reset();

    _devInited = FALSE ;
}

void
View::SetTargetOnDevices()
{
    if(!_doTargetUpdate) return;

    Assert( _imageDev );

    // Is the current target different from the old target ?
    if( _oldTargetPackage.IsValid() &&
        _imageDev->TargetsDiffer(_targetPackage, _oldTargetPackage) ) {

        TraceTag((tagWarning,
                  "View::SetTargetOnDevices() recreating "
                  "viewport due to target type change (type or surface depth changed)"));

        DestroyImageDisplayDevice(_imageDev);
        _imageDev = CreateImageDisplayDevice();
        _oldTargetPackage.Copy( _targetPackage );
    }


    HDC parentDC = _targetPackage.GetParentHDC();
    bool reinterpCoords = false;
    if( parentDC ) {
        Assert( _targetPackage.IsDdsurf() );
        reinterpCoords = true;
    }


    if( _targetPackage._IsValid_RawViewportRect() ) {

        RECT rcDeviceBounds = _targetPackage._GetRawViewportRect();
        if( reinterpCoords ) {
            _targetPackage.SetAlreadyOffset();
            ::LPtoDP(parentDC, (POINT *) &rcDeviceBounds, 2);
        }
        _targetPackage.SetViewportRect( rcDeviceBounds );
    }

    if( _targetPackage._IsValid_RawClipRect() ) {

        RECT rcDeviceClipBnds = _targetPackage._GetRawClipRect();
        if( reinterpCoords ) {
            ::LPtoDP(parentDC, (POINT *) &rcDeviceClipBnds, 2);
        }
        _targetPackage.SetClipRect( rcDeviceClipBnds );
    }


    bool success = false;
    {
        targetPackage_t _tPackageCopy;
        _tPackageCopy.Copy(_targetPackage);

        success = _imageDev->SetTargetPackage( &_tPackageCopy );
    }

    if (success) {
        _doTargetUpdate = false;
        _oldTargetPackage.Copy( _targetPackage );
    }
}

void
View::RenderSound(AxAValue snd)
{
#if 0
#if _DEBUGMEM
    _CrtMemCheckpoint(&oldState);
#endif
#endif

#if PERFORMANCE_REPORTING
    DWORD startTime = GetPerfTickCount();
#endif

    if (_soundDev && _sndVal) {
        if(_soundDev->AudioDead())
            return;  // don't do anything, stub audio out

        __try {
            DisplaySound(ValSound(snd), _soundDev);
            _sndList->Update(_soundDev);
        }
        __except( HANDLE_ANY_DA_EXCEPTION )  {
            _soundDev->SetAudioDead();

            TraceTag((tagError, "RenderSound - continue without sound."));
        }
    }

#if PERFORMANCE_REPORTING
    DWORD renderTime = GetPerfTickCount() - startTime;
    Assert(GetPerfTickCount() >= startTime);

    _renderTime += renderTime;

    _totalTime += renderTime;
#endif

#if 0
#if _DEBUGMEM
    _CrtMemCheckpoint(&newState);
    _CrtMemDifference(&diff, &oldState, &newState);
    _CrtMemDumpStatistics(&diff);
    _CrtMemDumpAllObjectsSince(&oldState);
#endif
#endif
}

void
View::RenderImage(AxAValue img)
{

    HRESULT hr;

#if _DEBUG
    if (IsTagEnabled(tagDisableRendering))
        return;
#endif

    _imageDev->ResetContext();
    RenderImageOnDevice(_imageDev, ValImage(img), _dirtyRectState);

#if _DEBUG
    static bool showit = false;
    if (showit && _targetPackage.IsDdsurf()) {
        showme2(_targetPackage.GetIDDSurface());
    }
#endif

}

void
View::DisableDirtyRects()
{
    // Turn off dirty rects by clearing them and computing the merged
    // boxes of the cleared state (which will be accessed by
    // GetInvalidatedRects).
    _dirtyRectsDisabled = true;
    _dirtyRectState.Clear();
    _dirtyRectState.ComputeMergedBoxes();
}

void
View::DoPicking(AxAValue v, Time time)
{
#if PERFORMANCE_REPORTING
    DWORD pickTime = GetPerfTickCount();
#endif

#if _DEBUG
    if (IsTagEnabled(tagPickOptOff) || (_pickEvents > 0))
#else
    if (_pickEvents > 0)
#endif
        _pickq.GatherPicks(ValImage(v), time, _lastSampleTime);

#if PERFORMANCE_REPORTING
    _pickTime  += GetPerfTickCount() - pickTime;
#endif
}

#if PERFORMANCE_REPORTING
extern int gcStat;
extern BOOL jitterStat;
extern BOOL heapSizeStat;
extern BOOL dxStat;

static void
PrintMeasure(DWORD lastMeaTime, DWORD& startGCTime, double& gTime)
{
    double tmp = Tick2Sec(GetPerfTickCount() - lastMeaTime);
    gTime += tmp;

    PerfPrintLine ("%g s", tmp);

    startGCTime = GetPerfTickCount();
}


static void
AfterGCPrint(char* msg, DWORD& lastMeaTime, DWORD& gcTicks, DWORD startGCTime)
{
    gcTicks += GetPerfTickCount() - startGCTime;

    if (gcStat)
        GCPrintStat(GetCurrentGCList(), GetCurrentGCRoots());

    PerfPrintLine(msg);

    lastMeaTime = GetPerfTickCount();
}

#endif /* PERFORMANCE_REPORTING */

void
View::RunBvrs(Time startGlobalTime, TimeXform tt)
{
    // Need to protect the perform call

    GC_CREATE_BEGIN;

    GCRoots globalRoots = GetCurrentGCRoots();

    RunList::iterator i;

    TimeXform gtt = NULL;

    if ((tt==NULL) && !_toRunBvrs.empty()) {
        tt = ShiftTimeXform(startGlobalTime);
    }

    while (!_toRunBvrs.empty()) {
        i = _toRunBvrs.begin();
        DWORD id = (*i).first;
        Bvr b = (*i).second.first;
        bool continueTimeline = (*i).second.second;

        Assert(b);

        _toRunBvrs.erase(i);

        Perf perf;

        if (continueTimeline) {
            if (gtt==NULL) {
                gtt = ShiftTimeXform(_modelStartTime);
            }
            perf = ::Perform(b, PerfParam(_modelStartTime, gtt));
        } else {
            perf = ::Perform(b, PerfParam(startGlobalTime, tt));
        }
        GCAddToRoots(perf, globalRoots);
        GCRemoveFromRoots(b, globalRoots);
        _runningBvrs[id] = perf;
    }

    Assert(_toRunBvrs.size() == 0);

    GC_CREATE_END;
}

static void
GCAddPerfListToRoots(list<Perf>& lst, GCRoots roots)
{
    for (list<Perf>::iterator j = lst.begin();
         j != lst.end(); j++) {
        GCAddToRoots(*j, roots);
    }
}

void
View::Start(Bvr img, Bvr snd, Time startTime)
{
    _sndList = NEW SoundInstanceList();
    ClearPerfTimeXformCache();

    // Should never have imports pending

    Assert (!ImportsPending());

#if 0
#if _DEBUGMEM
        _CrtMemCheckpoint(&oldState);
#endif
#endif /* 0 */

    DynamicHeapPusher dhp(GetSystemHeap());

    _isStarted = true;
    _emptyImageSoFar = true;
    _firstSample = true;

    _modelStartTime = startTime;

    Assert ((_sampleHeap==NULL) && (_renderHeap==NULL));
    _sampleHeap = &TransientHeap("Sample Heap", 2000);
    _renderHeap = &TransientHeap("Render Heap", 2000);
    _queryHitPointHeap = &TransientHeap("QueryHitPoint Heap", 200);
    _rbHeap = &TransientHeap("RB Heap", 2000);

    // Only need to create a sound device
    bool needSoundDevice;
    if (!snd) {
        needSoundDevice = false;
    } else {
        ConstParam cp;
        Sound *constSound = SAFE_CAST(Sound *, snd->GetConst(cp));
        needSoundDevice = (!constSound || constSound != silence);
    }

    CreateDevices (needSoundDevice, img != NULL) ;

    if (img) {
        SetTargetOnDevices() ;
    }

    GCRoots globalRoots = GetCurrentGCRoots() ;

    // Need to protect everything including TimeXform

#if PERFORMANCE_REPORTING
    double evaluationTime = 0.0;
    DWORD gcTicks = 0;
    DWORD lastMeaTime = GetPerfTickCount();
    DWORD startGCTime = GetPerfTickCount();
#endif

#if PERFORMANCE_REPORTING
    AfterGCPrint("*** Performing...", lastMeaTime, gcTicks, startGCTime);

    _lastReportTime = GetPerfTickCount();
#endif

    GC_CREATE_BEGIN;

    TimeXform tt = ShiftTimeXform(startTime);

    RunBvrs(startTime, tt);

    if (img) {
        // Push the pre-rendering performances on the roots
        _imgPerf = ::Perform(img, PerfParam(startTime, tt));
        GCAddToRoots(_imgPerf, globalRoots);
    }

    if (snd) {

        if(spritify)  { // new retained mode code
            /*
              SpriteCtx *sCtx = NewSoundCtx(_soundDev);

              Assert(!_soundSprite); // verify _soundSprite, _rmSound not in use
              Assert(!_rmSound);
              _rmSound = snd->Spritify(PerfParam(startTime, tt), sCtx, &_soundSprite);
              Assert(_rmSound);

              sCtx->Release();


              // setup the spriteThread (XXX Need to find a good place for this)
              _spriteThread = NEW SpriteThread(_soundDev, _rmSound);
            */
            //GCAddToRoots(_rmSound, globalRoots);
        } else {
            _sndPerf = ::Perform(snd, PerfParam(startTime, tt));
            GCAddToRoots(_sndPerf, globalRoots);
        }
    }

    GC_CREATE_END;

#if PERFORMANCE_REPORTING
    PrintMeasure(lastMeaTime, startGCTime, evaluationTime);
#endif

#if PERFORMANCE_REPORTING
    AfterGCPrint("*** Total GC Time...", lastMeaTime, gcTicks, startGCTime);
    double tmp = Tick2Sec(gcTicks);

    PerfPrintLine ("%g s", tmp);
#endif

    {
        // force a dynamic constant calculation on first frame, can't
        // do it here as some of the imports may not be ready.
        _someEventHappened = true;

        /*
        DynamicHeapPusher h(GetGCHeap());

        _lastRBId = NewSampleId();
        Param p(startTime);
        RBConstParam pp(_lastRBId, p, &_events);

        if (_imgPerf->GetRBConst(pp))
            _isRBConst = TRUE;

        GCAddPerfListToRoots(_events, globalRoots);

        TraceTag((tagDCFoldTrace,
                  "View::Start %d events to watch", _events.size()));
                  */
    }

    ClearPerfTimeXformCache();

    GarbageCollect();

    _currentSampleTime = startTime;
    _lastSystemTime = _FPSLastReportTime = GetPerfTickCount();
}

void
ClearPerfList(list<Perf>& lst, GCRoots roots)
{
    for (list<Perf>::iterator j = lst.begin(); j != lst.end(); j++) {
        GCRemoveFromRoots(*j, roots);
    }

    lst.erase(lst.begin(), lst.end());
}

#define DELETENULL(p)      delete p; p = NULL;

template<class T>
inline void RemoveFromRootsNULL(T& x, GCRoots roots)
{
    if (x) {
        GCRemoveFromRoots(x, roots);
        x = NULL;
    }
}


void
View::Stop()
{
    DynamicHeapPusher dhp(GetSystemHeap());

    // Remove the list of imports pending

    ClearImportList();

    GCRoots roots = GetCurrentGCRoots();

    for (RunningList::iterator i = _runningBvrs.begin();
         i != _runningBvrs.end(); i++) {
        GCRemoveFromRoots((*i).second, roots);
    }

    _runningBvrs.erase(_runningBvrs.begin(), _runningBvrs.end());

    RemoveFromRootsNULL(_imgPerf, roots); // XXX are these order critical?

    if (spritify) {
        //RemoveFromRootsNULL(_rmSound, roots);
    } else
        RemoveFromRootsNULL(_sndPerf, roots);

    RemoveFromRootsNULL(_imgVal, roots);
    RemoveFromRootsNULL(_sndVal, roots);
    RemoveFromRootsNULL(_imgForQueryHitPt, roots);

    ClearPerfList(_events, roots);
    ClearPerfList(_changeables, roots);
    ClearPerfList(_conditionals, roots);

    delete _sndList;
    _sndList = NULL;

    // GarbageCollect(true);       // force GC

#if _DEBUG
    // Somehow suspend in the debugger doesn't work, this
    // instrumentation code is there for possible manual suspension..
    bool debug = false;

    while (debug) {
        Sleep(1000);
    }
#endif

    DestroyDevices();

    DELETENULL(_sampleHeap);
    DELETENULL(_renderHeap);
    DELETENULL(_queryHitPointHeap);
    DELETENULL(_rbHeap);

    GarbageCollect(true);       // force GC (try to do this AFTER dest dev)

    _isStarted = false;

#if 0
#if _DEBUGMEM
        _CrtMemCheckpoint(&newState);
        _CrtMemDifference(&diff, &oldState, &newState);
        _CrtMemDumpStatistics(&diff);
        _CrtMemDumpAllObjectsSince(&oldState);
#endif
#endif
}


void
View::Pause()
{
    if (IsStarted())
    {
        Assert(_sndList);
        //Assert(_soundDev);  // Assert seems unnecessary.

        _sndList->Pause();
        _sndList->Update(_soundDev); // force an update to propagate the pause
    }
}


void
View::Resume()
{
    if (IsStarted())
    {
        Assert(_sndList);
        _sndList->Resume();
    }
}


DWORD View::AddBvrToRun(Bvr bvrToRun, bool continueTimeline)
{
    DynamicHeapPusher dhp(GetSystemHeap());
// Remove since causes other problems
//    CatchWin32FaultCleanup cwfc;

    Assert(bvrToRun);

    GCRoots globalRoots = GetCurrentGCRoots() ;

    ++_runId;

    if (_toRunBvrs[_runId].first)
        GCRemoveFromRoots(_toRunBvrs[_runId].first, globalRoots);

    _toRunBvrs[_runId].first = bvrToRun;
    _toRunBvrs[_runId].second = continueTimeline;


    GC_CREATE_BEGIN;
    GCAddToRoots(bvrToRun, globalRoots);
    GC_CREATE_END;

    return _runId;
}

void View::RemoveRunningBvr(DWORD id)
{
    GCRoots globalRoots = GetCurrentGCRoots();

    RunList::iterator r = _toRunBvrs.find(id);

    if (r != _toRunBvrs.end()) {
        GC_CREATE_BEGIN;
        GCRemoveFromRoots((*r).second.first, globalRoots);
        GC_CREATE_END;
        _toRunBvrs.erase(r);
        return;
    }

    RunningList::iterator n = _runningBvrs.find(id);

    if (n != _runningBvrs.end()) {
        GC_CREATE_BEGIN;
        GCRemoveFromRoots((*n).second, globalRoots);
        GC_CREATE_END;
        _runningBvrs.erase(n);
        return;
    }

    RaiseException_UserError(E_INVALIDARG,
                       IDS_ERR_SRV_INVALID_RUNBVRID,
                       id);
}

void
View::SetInvalid (LONG left, LONG top, LONG right, LONG bottom)
{
    RECT r = {left, top, right, bottom};
    _targetPackage.SetRawInvalidRect( r );
    _doTargetUpdate = true;
}


void View::Repaint()
{
    _dirtyRectState.Clear();

    // Set this up so that the next Tick() will return that rendering
    // is required.
    _repaintCalled = true;
}


// Query against the current established sample by calling
// PerformPicking.
//
// TODO: Lots of optimizations possible here, since
// picking may be invoked twice, once during sampling, and once here
// during QueryHitPoint.  The thing to do is to stash off the results
// of one or the other, and cache the point for which those results
// were generated.  This, in conjunction with a serial number for each
// sampleval, will let us share the results between the two different
// pick traversals if the point is the same.
Image *View::QueryHitPointWcPt(LPCRECT prcBounds,
                               POINT ptLoc,
                               Point2Value& wcPt)
{
    if (_imgForQueryHitPt) {

        // Convert into coords relative to the bounds.  They come in
        // relative to the container.
        int localX = ptLoc.x - prcBounds->left;
        int localY = ptLoc.y - prcBounds->top;

        // Turn rawMousePos into wcMousePos.  Can't use
        // PixelPos2wcPos, because it looks for a "current" device, of
        // which there are none.  Use prcBounds instead to figure it
        // out.
        int centerXOffset =
            (prcBounds->right - prcBounds->left) / 2;

        int centerYOffset =
            (prcBounds->bottom - prcBounds->top) / 2;

        int centeredX = localX - centerXOffset;
        int centeredY = centerYOffset - localY; // flip orientation

        //  Convert to meters
        wcPt.x = (double) centeredX / ViewerResolution();
        wcPt.y = (double) centeredY / ViewerResolution();

        return ValImage(_imgForQueryHitPt);
    }

    return NULL;
}

#if DEVELOPER_DEBUG
extern bool GCIsInRoots(GCBase *ptr, GCRoots r);
#endif DEVELOPER_DEBUG

bool View::QueryHitPoint(DWORD dwAspect,
                         LPCRECT prcBounds,
                         POINT ptLoc,
                         LONG lCloseHint)
{
    Point2Value wcPt;
    Image *img = QueryHitPointWcPt(prcBounds, ptLoc, wcPt);

    if (img) {

        Assert(GCIsInRoots(img, GetCurrentGCRoots()));

        // Use special transient heap for stuff allocated during
        // QueryHitPoint.  Free data from call to call, since it's no
        // longer needed.  Note that if we ever optimize as described
        // above, this will need to be reevaluated.
        GetQueryHitPointHeap().Reset();
        DynamicHeapPusher dhp(GetQueryHitPointHeap());

        bool bRet;

        GC_CREATE_BEGIN;
        bRet = PerformPicking(img, &wcPt, false, 0, 0);
        GC_CREATE_END;

        return bRet;
    }

    return false;
}

LONG View::QueryHitPointEx(LONG s,
                           DWORD_PTR *userIds,
                           double *points,
                           LPCRECT prcBounds,
                           POINT ptLoc)
{
    Point2Value wcPt;
    Image *img = QueryHitPointWcPt(prcBounds, ptLoc, wcPt);

    if (img) {
        Assert(GCIsInRoots(img, GetCurrentGCRoots()));

        GetQueryHitPointHeap().Reset();
        DynamicHeapPusher dhp(GetQueryHitPointHeap());

        LONG actualHits = 0;

        GC_CREATE_BEGIN;
        PerformPicking(img,
                       &wcPt,
                       false,
                       _currentSampleTime,
                       _lastSystemTime,
                       s,
                       userIds,
                       points,
                       &actualHits);

        GC_CREATE_END;

        return actualHits;
    }

    return 0;
}

DeclareTag(tagGetInvalidatedRects, "Optimizations", "GetInvalidatedRects trace");

LONG View::GetInvalidatedRects(DWORD flags,
                               LONG  size,
                               RECT *pRects)
{
    vector<Bbox2> *pBoxes;
    int boxCount = _dirtyRectState.GetMergedBoxes(&pBoxes);

    if (pRects && boxCount>0 && (GetImageDev() != NULL)) {

        int toFill = size < boxCount ? size : boxCount;

        DirectDrawImageDevice *imgDev;

        imgDev = GetImageDev()->GetImageRenderer();

        int w = GetImageDev()->Width();
        int h = GetImageDev()->Height();

        // Note that these may extend outside of the target, but they
        // *do* represent the pixel values of the image itself.

        TraceTag((tagGetInvalidatedRects,
                  "Filling %d rects of %d",
                  toFill, boxCount));

        for (int i = 0; i < boxCount; i++) {

            Bbox2 box = (*pBoxes)[i];

            RECT r;
            // Compare contents...
            if (box == UniverseBbox2) {

                SetRect(&r, 0, 0, w, h);

            } else {

                imgDev->DoDestRectScale(&r,
                                        imgDev->GetResolution(),
                                        box,
                                        NULL);

                if (r.top < 0)
                    r.top = 0;
                if (r.left < 0)
                    r.left = 0;

                if (r.bottom > h)
                    r.bottom = h;
                if (r.right > w)
                    r.right = w;

            }

            if (i < toFill)
            {
                CopyRect(&pRects[i], &r);
            }
            else
            {
                // We ran out of boxes to fill - union the current box
                // into the previous one
                UnionRect(&pRects[toFill - 1], &pRects[toFill - 1], &r);
            }

            TraceTag((tagGetInvalidatedRects,
                      "Rect %d: (%d,%d) -> (%d,%d)",
                      i,
                      r.left, r.top,
                      r.right, r.bottom));

        }

    }

    return boxCount;
}

#ifdef _DEBUG
// For use with QuickWatch during debugging.
int PerfPrint(Perf p)
{
    cout << p;
    cout.flush();
    return 1;
}
#endif

#if DEVELOPER_DEBUG
#define GET_SIZE(var, heap)                  \
        size_t var = heap.BytesUsed();
#endif

DeclareTag(tagPerfStats, "Performance", "Disable Performance Stats");

// don't ifdef ReportPerformance() audio timetransform inferencing needs it!
void View::ReportPerformance()
{
    DWORD totalTicks = GetPerfTickCount() - _lastReportTime;

    Real avgFrameLength, avg, avgVar, minVar, maxVar;
    GetRenderingTimeStats(&avg, &avgFrameLength, &avgVar, &maxVar, &minVar);
    //_framePeriod = avgFrameLength;
    _framePeriod = avg; // used in LeafSound::Render()

#if _DEBUG
    if (IsTagEnabled(tagPerfStats)) return;
#endif

#if !_DEBUG && !PERFORMANCE_REPORTING
    if(bShowFPS && (totalTicks > ReportThreshold * perfFrequency)) {
        char buf[256];
        _snprintf(buf,
                  ARRAY_SIZE(buf),
                  "DA(%p,%d) %4.3g fps \n",
                  this,
                  _targetPackage.GetTargetType(),
                  ((double) _numFrames * perfFrequency) /
                  ((double) totalTicks));
        OutputDebugString(buf);

        _numFrames=0;
        _lastReportTime = GetPerfTickCount () ;
    }

#endif


#if PERFORMANCE_REPORTING
    if (totalTicks > ReportThreshold * perfFrequency) {

        PerfPrintLine();

        ULONG ddrawRender = _timers.ddrawTimer.Ticks();
        ULONG gdiRender = _timers.gdiTimer.Ticks();
        ULONG dx2dRender = _timers.dx2dTimer.Ticks();
        ULONG alphaRender = _timers.alphaTimer.Ticks();
        ULONG d3dRender = _timers.d3dTimer.Ticks();
        ULONG dsoundRender = _timers.dsoundTimer.Ticks();
        ULONG dxxfRender = _timers.dxxformTimer.Ticks();

        ULONG renderTime_NonDA =
            ddrawRender +
            gdiRender +
            dx2dRender +
            alphaRender +
            d3dRender +
            dsoundRender +
            dxxfRender;

        ULONG renderTime_DA = _renderTime - renderTime_NonDA;

        PerfPrintf("DA(%lx,%d) %4.3g fps %4.3g ticks/s %4.3gs ",
                   this,
                   _targetPackage.GetTargetType(),
                   ((double) _numFrames * perfFrequency) /
                   ((double) totalTicks),
                   ((double) _numSamples * perfFrequency) /
                   ((double) totalTicks),
                   (double) _totalTime / (double) perfFrequency);
        PerfPrintf("%4.3g%% sample  ",
                   100 * ((double) _sampleTime) / ((double) _totalTime));
        PerfPrintf("%5.3g%% DA render  ",
                   100 * ((double) renderTime_DA) / ((double) _totalTime));
        PerfPrintf("%5.3g%% non-DA render  ",
                   100 * ((double) renderTime_NonDA) / ((double) _totalTime));
        PerfPrintf("%5.3g%% pick  ",
                   100 * ((double)_pickTime) / ((double) _totalTime));
        PerfPrintf("%5.3g%% GC",
                   100 * ((double) _gcTime) / ((double) _totalTime));
        PerfPrintLine();

        if(dxStat) {
            PerfPrintf("-- nonDA Render: ");

            double dblTotal = (double)(renderTime_NonDA);

            if (dblTotal > 0)
            {
                PerfPrintf("%5.3g%% ddraw  ",
                           100 * ((double) ddrawRender) / dblTotal);

                PerfPrintf("%5.3g%% gdi  ",
                           100 * ((double) gdiRender) / dblTotal);

                PerfPrintf("%5.3g%% dx2d  ",
                           100 * ((double) dx2dRender) / dblTotal);

                PerfPrintf("%5.3g%% alpha  ",
                           100 * ((double) alphaRender) / dblTotal);

                PerfPrintf("%5.3g%% d3d  ",
                           100 * ((double) d3dRender) / dblTotal);

                PerfPrintf("%5.3g%% dxtrans ",
                           100 * ((double) dxxfRender) / dblTotal);

                PerfPrintf("%5.3g%% dSound  ",
                           100 * ((double) dsoundRender) / dblTotal);

                PerfPrintf("%5.3g%% custom  ",
                           100 * ((double) _timers.customTimer.Ticks()) / dblTotal);

                PerfPrintLine();
            }
        }

#if DEVELOPER_DEBUG

        if (heapSizeStat) {
            GET_SIZE(size1, (*_sampleHeap));
            GET_SIZE(size2, GetGCHeap());
            GET_SIZE(size3, GetSystemHeap());
            GET_SIZE(size4, (*_renderHeap));
            PerfPrintf("      Sample, Val GC, System, Render, Total sizes in KB:");
            PerfPrintLine("%d, %d, %d, %d = %d",
                          size1/1024,
                          size2/1024,
                          size3/1024,
                          size4/1024,
                          (size1+size2+size3+size4)/1024);

            PerfPrintLine("      Total Memory used by DA - %d Kb",
                          GetTotalMemory() / 1024);
        }

#endif /* _DEBUG */

        MEMORYSTATUS memstat;
        GlobalMemoryStatus(&memstat);
        DWORD availPhysK = memstat.dwAvailPhys / 1024;
        DWORD availPageK = memstat.dwAvailPageFile / 1024;
        DWORD sum = (memstat.dwAvailPhys + memstat.dwAvailPageFile) / 1024;
        PerfPrintf("      Mem Avail: %dK Phys + \t%dK Page =\t%dK\tDelta %dK",
                   availPhysK,
                   availPageK,
                   sum,
                   sum - g_prevAvailMemory);
        PerfPrintLine();

        // Note that this is a global, which is what we want.  If we
        // put it on the view, then we get a weird result each time we
        // switch views.  This needs to be consistent across views.
        // (I'm not worried about the possibility of multiple views
        // hitting this next instruction outside of a crit sect.  The
        // result will be harmless.)
        g_prevAvailMemory = sum;

        DWORD currTime = GetTickCount();
        DWORD dllTime = (currTime - g_dllStartTime) / 1000;
        DWORD viewTime = (currTime - _viewStartTime) / 1000;

        DWORD dllHours = dllTime / 3600;
        DWORD dllMins = dllTime / 60 - dllHours * 60;
        DWORD dllSecs = dllTime - dllHours * 3600 - dllMins * 60;

        DWORD viewHours = viewTime / 3600;
        DWORD viewMins = viewTime / 60 - viewHours * 60;
        DWORD viewSecs = viewTime - viewHours * 3600 - viewMins * 60;

        PerfPrintf("      DLL Running: %d:%02d:%02d, View Running: %d:%02d:%02d",
                   dllHours, dllMins, dllSecs,
                   viewHours, viewMins, viewSecs);
        PerfPrintLine();

        if (gcStat)
            GCPrintStat(GetCurrentGCList(), GetCurrentGCRoots());

        _lastReportTime = GetPerfTickCount () ;
        _gcTime = _totalTime = _sampleTime = _renderTime = _pickTime = 0 ;
        _numFrames = _numSamples = 0 ;

        ResetJitterMeasurements();

        //
        // Reset rendering timers
        //
        _timers.ddrawTimer.Reset();
        _timers.d3dTimer.Reset();
        _timers.dsoundTimer.Reset();
        _timers.dxxformTimer.Reset();
        _timers.customTimer.Reset();
        _timers.alphaTimer.Reset();
        _timers.gdiTimer.Reset();
        _timers.dx2dTimer.Reset();
    }
#endif /* PERFORMANCE_REPORTING */
}

void
View::EventHappened()
{
    _someEventHappened = true;
}


bool
View::Sample(Time time, bool paused)
{
#if DEVELOPER_DEBUG
    int listsize;
#endif

    if (_currentSampleTime > time && paused == false)
        {
        TraceTag((tagError, "tick backward! %5.3f %5.3f",
                  _currentSampleTime, time));

        // Workaround for IHammer controls

        if (time == 0)
        {
            time = _currentSampleTime;
        }
        else
        {
            // So the IHammer control would work
            if ((_currentSampleTime - time) > 1.0) {
                DASetLastError(E_INVALIDARG, 0);
                return false;
            }

            TraceTag((tagError, "close enough, continue"));
        }
    }

    ReportPerformance();

    _FPSNumSamples++;

#if PERFORMANCE_REPORTING
    _numSamples++;

    DWORD startSampleTime = GetPerfTickCount();
#endif

// Remove since causes other problems
//    CatchWin32FaultCleanup cwfc ;
    DynamicHeapPusher dph(*_sampleHeap);

    _currentSystemTime = GetPerfTickCount();

    if( GetImageDev() ) {
        DirectDrawViewport *vprt = GetImageDev();
        if( vprt->ICantGoOn() ) {
            Assert(_imageDev == GetImageDev());
            DestroyImageDisplayDevice(_imageDev);
            _imageDev = NULL;
            _imageDev = CreateImageDisplayDevice();
            _doTargetUpdate = true;
            _oldTargetPackage.Copy( _targetPackage );

            // do this before sample because sample sometimes
            // needs a device
            SetTargetOnDevices();

            // force repaint (clear dirty rects)
            Repaint();
        }
    }

    GCRoots roots = GetCurrentGCRoots();

    RemoveFromRootsNULL(_sndVal, roots);
    RemoveFromRootsNULL(_imgVal, roots);
    RemoveFromRootsNULL(_imgForQueryHitPt, roots);

    _lastSampleTime = _currentSampleTime;
    _currentSampleTime = time;

    ResetDynamicHeap(*_sampleHeap);
    _eventq.Prune (_lastSampleTime) ;
    _eventq.SizeChanged(FALSE) ;

    ClearPerfTimeXformCache();

#if PERFORMANCE_REPORTING
    DWORD startGCTime = GetPerfTickCount();
#endif

    GarbageCollect();

#if PERFORMANCE_REPORTING
    _gcTime += GetPerfTickCount() - startGCTime;

    DWORD sampleTime = GetPerfTickCount();
#endif

    Image *rewrittenImage = NULL;

    RunBvrs(time, NULL);

    GC_CREATE_BEGIN;

    // needs to be here, since the event check may sample the sound
    // through tuple/array.
    if(!paused)
        _sndList->Reset(time);

    Param p(time);

    _sampleId = p._id;

    // Sample events

    bool eventThatHappenedWasFromChangeable = false;

#if DEVELOPER_DEBUG
    listsize = _events.size();
#endif

    list<Perf>::iterator j;
    for (j = _events.begin(); j != _events.end(); j++) {

        (*j)->Sample(p);

        if (_someEventHappened) {
            TraceTag((tagIndicateRBConst,
                      "View::Sample[%g] event happened 0x%x",
                      time, *j));
            break;
        }
    }

    // Make sure the size is unaltered during the sampling of the
    // events otherwise the stl data structure could be changed during
    // the iterations

    Assert(listsize == _events.size());

    // Sample switchers for switches on this view.
    CheckChangeablesParam ccp(p);
    bool gotOne = false;

#if DEVELOPER_DEBUG
    listsize = _changeables.size();
#endif

    // Always go through all the changeables, since they have to
    // update their state.  Not a big perf loss, since most frames
    // nothing will change anyhow and we'll always have to go
    // through them all.
    for (j = _changeables.begin(); j != _changeables.end(); j++) {

        bool result = (*j)->CheckChangeables(ccp);

        if (result) {
            gotOne = true;

            TraceTag((tagIndicateRBConst,
                      "View::Sample[%g] switcher switched 0x%x",
                      time, *j));
        }
    }

    // Make sure the size is unaltered during the sampling of the
    // events otherwise the stl data structure could be changed during
    // the iterations

    Assert(listsize == _changeables.size());

    // Now, with the RBId set to hit the cache, go through all the
    // conditionals.  Note we only sample the conditions here,
    // which have already been cached, so we're ok setting the
    // RBId.
    if (!gotOne) {
        p._cid = _lastRBId;
    }

#if DEVELOPER_DEBUG
    listsize = _conditionals.size();
#endif

#if DO_CONDS_CHECK
        for (j = _conditionals.begin(); j != _conditionals.end(); j++) {

            bool result = (*j)->CheckChangeables(ccp);

            if (result) {
                gotOne = true;
                TraceTag((tagIndicateRBConst,
                          "View::Sample[%g] conditional transition 0x%x",
                          time, *j));
            }
        }
#endif

    // Make sure the size is unaltered during the sampling of the
    // events otherwise the stl data structure could be changed during
    // the iterations

    Assert(listsize == _conditionals.size());

    // Set back, we'll determine later if the main sampling should
    // have this turned on.
    p._cid = 0;

    if (gotOne) {
        if (!_someEventHappened) {
            EventHappened();
            eventThatHappenedWasFromChangeable = true;
        }
    }

    // Only allow the cache to be used when no events occurred.
    if (!_someEventHappened)
        p._cid = _lastRBId;

    if(spritify) {
        Assert(_rmSound);
        _rmSound->Sample(p);
    }
    else {
        if (_sndPerf && !paused) {
            _sndVal = _sndPerf->Sample(p);
            GCAddToRoots(_sndVal, roots);
            RenderSound(_sndVal);
        }
    }

    {
        // We need to make a copy since elements can be removed while
        // we sample
        // We also are in the GC lock so we do not need to worry about
        // the behaviors having been removed from the roots

        Assert(IsGCLockAcquired(GetCurrentThreadId()));

        RunningList runningBvrsCopy = _runningBvrs;

        // Sample "started" behaviors from the jaxa interface for
        // events.
        for (RunningList::iterator i = runningBvrsCopy.begin();
             i != runningBvrsCopy.end(); i++) {
            i->second->Sample(p);
        }
    }

    if (_imgPerf) {
        _imgForQueryHitPt = _imgVal = _imgPerf->Sample(p);
        GCAddToRoots(_imgVal, roots);
        GCAddToRoots(_imgForQueryHitPt, roots);
    }

    _lastSystemTime = _currentSystemTime;

#if PRODUCT_PROF
//        if (_firstRendering) {
//            cout << "Turning on IceCAP profiling." << endl;
//            cout.flush();
//            StartCAPAll();
//        }
#endif

    // Render several frames after event happens.  Can't just
    // render once coz value at event time is not the switched
    // value in general.
    if (_someEventHappened) {

        TraceTag((tagIndicateRBConst,
                  "View::(0x%x) change happened %g", this, time));

        //ResetDynamicHeap(*_rbHeap);
        //DynamicHeapPusher h(*_rbHeap);
        //REVERT-RB:
        DynamicHeap *heap = &GetGCHeap();

        DynamicHeapPusher h(*heap);

        ClearPerfList(_events, roots);
        ClearPerfList(_changeables, roots);
        ClearPerfList(_conditionals, roots);

        _lastRBId = NewSampleId();
        RBConstParam pp(_lastRBId, p, _events, _changeables, _conditionals);

        //bool doRB = false;

#if _DEBUG
        if (!IsTagEnabled(tagDisableRBConst)) {
#endif

            if (_imgPerf && //doRB &&
                GetCurrentView().GetPreferences()._dynamicConstancyAnalysisOn) {
                _isRBConst = _imgPerf->GetRBConst(pp) != NULL;
            }

#if _DEBUG
        }
#endif

        GCAddPerfListToRoots(_events, roots);
        GCAddPerfListToRoots(_changeables, roots);
        GCAddPerfListToRoots(_conditionals, roots);

        if (_isRBConst) {

            TraceTag((tagIndicateRBConst,
                      "View 0x%x is temporal constant at [%g]",
                      this, time));

            // Events from changeables only need to repaint once.  We
            // need to repaint more times for Until based events so
            // everything catches up.
            if (eventThatHappenedWasFromChangeable) {
                _toPaint = 1;
            } else {
                _toPaint = 3;
            }
        }

    }

#if _DEBUG
    if (IsTagEnabled(tagDisableDirtyRects)) {
        DisableDirtyRects();
    }
#endif

    // Don't bother doing dirty rectangles if we don't need to paint
    // anyhow.
    if (PERVIEW_DRECTS_ON && !_dirtyRectsDisabled && _imgVal &&
        (!_isRBConst || _toPaint > 0)) {

        // Only do dirty rects if we're a) windowed, or b) have a
        // non-volatile rendering surface (meaning that DA's the only
        // guy writing to that surface, other than through established
        // mechanisms like RePaint()).

        // TODO: Improve for the windowless case, where dirty rects
        // can make sense.

        if (!IsWindowless() ||
            !GetCurrentView().GetPreferences()._volatileRenderingSurface) {

            Assert(_imgVal->GetTypeInfo() == ImageType);
            Image *img = SAFE_CAST(Image *, _imgVal);

            rewrittenImage =
                _dirtyRectState.Process(img,
                                        _lastSampleId,
                                        GetImageDev()->GetTargetBbox());


            GCAddToRoots(rewrittenImage, roots);

            // Stash away the last sample
            _lastSampleId = p._id;

        }
    }

#if PERFORMANCE_REPORTING
    _sampleTime +=  GetPerfTickCount() - sampleTime;
#endif

    // Be sure to pick on the original image, not the "rewritten" one,
    // since that would ignore stuff that's not changing.
    if (_imgVal) {
        DoPicking(_imgVal, time);
    }

    GC_CREATE_END;

    if (_imgVal && rewrittenImage) {
        // Replace "actual" image with rewritten one.
        GCRemoveFromRoots(_imgVal, roots);
        _imgVal = rewrittenImage;
    }

    bool needToRender = false;

#if _DEBUG
    if (IsTagEnabled(tagEngNoSRender)) {
        needToRender = true;
    } else
#endif
        if (_repaintCalled || _isRBConst || rewrittenImage == emptyImage) {

            if (_repaintCalled) {

                // If repaint's been called, we need to paint twice.
                // Painting just once doesn't seem to clear everything
                // out.  We can afford the extra paint because it's
                // typically just on invalidations from window system
                // events.
                if (_toPaint < 2) {
                    _toPaint = 2;
                }
                _repaintCalled = false;

            }

            // TODO: should decrement _toPaint in Sample,
            // then we don't need this.
            _emptyImageSoFar &= (_imgVal == emptyImage);

            if (!_emptyImageSoFar && (_toPaint > 0)) {
                needToRender = true;
            }

            // We need to render at least once because of 38383
            if (_firstSample) {
                // but we don't want to mess with the original logic
                // so we only do it for emptyImage
                if (_emptyImageSoFar) {
                    needToRender = true;
                }
                // reset, don't do this again
                _firstSample = false;
            }
        } else {
            //Assert(_imgPerf->GetRBConst(NewSampleId()) == NULL);

            needToRender = true;
        }

    ClearPerfTimeXformCache();

#if PERFORMANCE_REPORTING
    _totalTime += GetPerfTickCount() - startSampleTime;
#endif

    // Reset for next time.
    _someEventHappened = false;

    return needToRender;
}

void View::RenderSound()
{
// Remove since causes other problems
//    CatchWin32FaultCleanup cwfc ;
    DynamicHeapPusher dph(*_sampleHeap);

    GC_CREATE_BEGIN;
    RenderSound(_sndVal);
    GC_CREATE_END;
}

void View::RenderImage()
{
    if (!_imgVal)
        return;

    #if 0
    {
        //
        // Checks for image device creation/destruction leaks
        //
        static int i = 0;
        i++;

        if(i > 3) {
            DynamicHeapPusher dph(*_sampleHeap);

            while(1) {

                _CrtMemCheckpoint(&oldState);

                if(! GetImageDev() ) {
                    _imageDev = CreateDdRlDisplayDevice();
                }

                SetTargetOnDevices();

                delete GetImageDev();
                _imageDev = NULL;

                _CrtMemCheckpoint(&newState);
                _CrtMemDifference(&diff, &oldState, &newState);
                _CrtMemDumpStatistics(&diff);
                _CrtMemDumpAllObjectsSince(&oldState);
            }
        }
    }
    #endif


#if 0
#if _DEBUGMEM
        _CrtMemCheckpoint(&oldState);
#endif
#endif

#if PERFORMANCE_REPORTING
    DWORD startTime = GetPerfTickCount();
#endif

// Remove since causes other problems
//    CatchWin32FaultCleanup cwfc ;
    DynamicHeapPusher dph(*_renderHeap);

    #if 0
    // Device creation/destruction leak detection
    if(! GetImageDev() ) {
        _imageDev = CreateDdRlDisplayDevice();
        _doTargetUpdate = true;
    }
    #endif

    SetTargetOnDevices();

    GC_CREATE_BEGIN;
    RenderImage(_imgVal);
    GC_CREATE_END;

    // If we think we needed to paint, then decrement this counter,
    // since we just did paint.
    if (_toPaint > 0) {
        _toPaint--;
    }

    _numFrames++;

    SubmitNewRenderingTime();

    // Only do this after the first frame.
    if (_firstRendering) {

#if PRODUCT_PROF
//            StopCAPAll();
//            cout << "Turning off IceCAP profiling." << endl;
#endif

        PERFPRINTLINE(("First Rendering(thread:%x): %g s",
                       GetCurrentThreadId(),
                       ((double) (GetPerfTickCount() - startTime)) /
                       (double) perfFrequency));

        _firstRendering = FALSE;

    }

#if PERFORMANCE_REPORTING
    DWORD renderTime = GetPerfTickCount() - startTime;

    Assert(GetPerfTickCount() >= startTime);

    _renderTime += renderTime;
    _totalTime += renderTime;
#endif

    #if 0
    // Device creation/destruction leak detection
    delete GetImageDev();
    _imageDev = NULL;
    #endif

    ResetDynamicHeap(*_renderHeap);

#if 0
#if _DEBUGMEM
    _CrtMemCheckpoint(&newState);
    _CrtMemDifference(&diff, &oldState, &newState);
    _CrtMemDumpStatistics(&diff);
    _CrtMemDumpAllObjectsSince(&oldState);
#endif
#endif

}

void
View::SubmitNewRenderingTime()
{
    DWORD timer = GetPerfTickCount();

    // 0 indicates first rendering, just skip
    if (_lastRenderingTime != 0) {
        _renderTimes[_renderTimeIdx++] = timer - _lastRenderingTime;
    }

    _lastRenderingTime = timer;

    if (_renderTimeIdx >= MAX_RENDER_TIMES) {
        DebugCode(cout << "Went beyond " << MAX_RENDER_TIMES << " renderings.\n");
        _renderTimeIdx = 0;
    }
}


void
View::GetRenderingTimeStats(Real *avg,
                            Real *avgFrameLength,
                            Real *avgVariance,
                            Real *maxVariance,
                            Real *minVariance)
{
    if (_renderTimeIdx == 0) {
        // If no renderings happened.
        *avg = 0;
        *avgFrameLength = 0;
        *avgVariance = 0;
        *maxVariance = 0;
        *minVariance = 0;
        return;
    }

    DWORD total = 0;
    for (int i = 0; i < _renderTimeIdx; i++) {
        DWORD v = _renderTimes[i];
        total += v;
    }

    DWORD avgTicks = total / _renderTimeIdx;

    *avg = (Real)avgTicks / perfFrequency;
    if(*avg)
        *avgFrameLength = 1.0 / *avg;

    DWORD dev = 0;
    long minTicksDiff = 1 << 16;
    long maxTicksDiff = 0;

    for (i = 0; i < _renderTimeIdx; i++) {
        DWORD v = _renderTimes[i];
        long diff = v - avgTicks;
        if (diff < 0) diff = -diff;
        dev += diff;

        if (diff < minTicksDiff) minTicksDiff = diff;
        if (diff > maxTicksDiff) maxTicksDiff = diff;

    }

    dev /= _renderTimeIdx;

    *avgVariance = (Real)dev / perfFrequency;
    *minVariance = (Real)minTicksDiff / perfFrequency;
    *maxVariance = (Real)maxTicksDiff / perfFrequency;
}


#if PERFORMANCE_REPORTING
void
View::ResetJitterMeasurements()
{
    _renderTimeIdx = 0;
}
#endif  // PERFORMANCE_REPORTING

HWND
View::GetWindow()
{
    return (_targetPackage.IsHWND())?
        _targetPackage.GetHWND() :
        NULL;
}

bool
View::SetWindow(HWND hwnd)
{
    if ( _targetPackage.IsHWND() &&
         _targetPackage.GetHWND() == hwnd ) return true;

    _targetPackage.SetHWND(hwnd);
    _doTargetUpdate = true;

    return true;
}

IDirectDrawSurface *
View::GetDDSurf()
{
    return (_targetPackage.IsDdsurf())?
        _targetPackage.GetIDDSurface() :
        NULL;
}

bool
View::SetDDSurf(
    IDirectDrawSurface *ddsurf,
    HDC parentDC)
{
    _targetPackage.SetIDDSurface(ddsurf, parentDC);
    _doTargetUpdate = true;

    return true;
}

HDC
View::GetHDC()
{
    return (_targetPackage.IsHDC())?
        _targetPackage.GetHDC() :
        NULL;
}

bool
View::SetHDC(HDC hdc)
{
    bool ret = false;

    DAComPtr<IServiceProvider> sp;
    DAComPtr<IDirectDraw3> ddraw3;
    DAComPtr<IDirectDrawSurface> dds;
    if(hdc && GetCurrentServiceProvider( &sp )
         && sp
         && SUCCEEDED(sp->QueryService(SID_SDirectDraw3,
                                       IID_IDirectDraw3,
                                       (void**)&ddraw3))
         && SUCCEEDED(ddraw3->GetSurfaceFromDC(hdc, &dds))
         && SetDDSurf(dds, hdc) ) {

        SetCompositeDirectlyToTarget(true);

        ret = true;

    }
    else
    {
        _targetPackage.SetHDC(hdc);
        _doTargetUpdate = true;
        ret = true;
    }

    return ret;
}

double
View::GetFrameRate()
{
    DWORD totalTicks = GetPerfTickCount() - _FPSLastReportTime;

    if (totalTicks > perfFrequency) {
        _FPS = ((double) _FPSNumSamples * perfFrequency) / (double) totalTicks;
        _FPSNumSamples = 0;
        _FPSLastReportTime = GetPerfTickCount();
    }

    return _FPS;
}

double
View::GetTimeDelta()
{
    return _currentSampleTime - _lastSampleTime;
}

PerfTimeXformImpl *
View::GetPerfTimeXformFromCache(Perf p)
{
    PerfTTMap::iterator i = _ttCache.find(p);

    return (i!=_ttCache.end()) ? (*i).second : NULL;
}

void
View::SetPerfTimeXformCache(Perf p, PerfTimeXformImpl *tt)
{
    Assert(_ttCache.find(p)==_ttCache.end());

    _ttCache[p] = tt;
}

void
View::ClearPerfTimeXformCache()
{
    _ttCache.erase(_ttCache.begin(), _ttCache.end());
}

// =========================================
// Thread specific calls
// =========================================

static DWORD viewTlsIndex = 0xFFFFFFFF;

CRViewPtr IntGetCurrentView()
{ return (CRViewPtr) TlsGetValue(viewTlsIndex); }

void IntSetCurrentView(CRViewPtr v)
{ TlsSetValue(viewTlsIndex, v); }

CRView &
GetCurrentView()
{
    CRViewPtr v = IntGetCurrentView();

    if (v == NULL)
        RaiseException_InternalError("Tried to get View with no view set") ;

    return *v ;
}

CRViewPtr
SetCurrentView(CRViewPtr v)
{
    CRViewPtr oldview = IntGetCurrentView() ;

    IntSetCurrentView(v);

    return oldview;
}

PerfTimeXformImpl *
ViewGetPerfTimeXformFromCache(Perf p)
{
    CRViewPtr v = IntGetCurrentView();

    if (v == NULL)
        return NULL;

    return v->GetPerfTimeXformFromCache(p);
}

void
ViewSetPerfTimeXformCache(Perf p, PerfTimeXformImpl *tt)
{
    CRViewPtr v = IntGetCurrentView();

    if (v != NULL) {
        v->SetPerfTimeXformCache(p, tt);
    }
}

void
ViewClearPerfTimeXformCache()
{ GetCurrentView().ClearPerfTimeXformCache(); }

// =========================================
// Initialization
// =========================================


void
InitializeModule_View()
{
    viewTlsIndex = TlsAlloc();
    Assert((viewTlsIndex != 0xFFFFFFFF) &&
           "TlsAlloc() failed");

#if PERFORMANCE_REPORTING
    g_dllStartTime = GetTickCount();
#endif

}

void
DeinitializeModule_View(bool bShutdown)
{
    if (viewTlsIndex != 0xFFFFFFFF)
        TlsFree(viewTlsIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\exc\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

// Disable warning for exception unwind
#pragma warning(disable:4530)

#include "include/headers.h"
#include <dartapi.h>
#include "privinc/mutex.h"
#include "privinc/comutil.h"
#include "privinc/server.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\view.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Viewer interface

*******************************************************************************/


#ifndef _DAVIEW_H
#define _DAVIEW_H

#include "context.h"
#include "eventq.h"
#include "pickq.h"
#include "privinc/imgdev.h"
#include "privinc/soundi.h"
#include "backend/perf.h"
#include "backend/bvr.h"
#include "privinc/drect.h"
#include "privinc/htimer.h"
#include "privinc/privpref.h"
#include "privinc/comutil.h"
#include <dxtrans.h>

class SpriteThread;
class SoundInstanceList;
class PerfTimeXformImpl;

class View : public AxAThrowingAllocatorClass
{
  public:
    View();
    ~View () ;

    void CreateDevices (bool needSoundDevice, bool needImageDevice) ;
    void DestroyDevices () ;
    void SetTargetOnDevices () ;

    void RenderImage(AxAValue v);
    void RenderSound(AxAValue v);

    void DoPicking(AxAValue v, Time time) ;

    bool Sample(Time time, bool paused);
    void RenderImage();
    void RenderSound();

    void Start(Bvr img, Bvr snd, Time startTime);
    void Stop();
    void Pause();
    void Resume();

    DWORD AddBvrToRun(Bvr bvr, bool continueTimeline = false);
    void RemoveRunningBvr(DWORD id);

    void RunBvrs(Time startGlobalTime, TimeXform tt);

    Bvr Snapshot(Bvr bvr, Time t);

    HWND GetWindow ();
    bool SetWindow (HWND hwnd);
    IDirectDrawSurface * GetDDSurf();
    bool SetDDSurf(IDirectDrawSurface *ddsurf, HDC parentDC=NULL);
    HDC GetHDC();
    bool SetHDC(HDC hdc);

    void SetCompositeDirectlyToTarget(bool b) {
        _targetPackage.SetComposeToTarget( b );
        _doTargetUpdate = true;
    }
    
    bool GetCompositeDirectlyToTarget() {
        return _targetPackage.GetComposeToTarget();
    }

    void SetViewport (LONG left, LONG top, LONG right, LONG bottom) {
        RECT r = {left, top, right, bottom};
        _targetPackage.SetRawViewportRect( r );
        _doTargetUpdate = true;
    }

    void SetClipRect (LONG left, LONG top, LONG right, LONG bottom) {
        RECT r = {left, top, right, bottom};
        _targetPackage.SetRawClipRect( r );
        _doTargetUpdate = true;
    }

    void SetInvalid (LONG left, LONG top, LONG right, LONG bottom);
    bool IsStarted () { return _isStarted; }
    bool IsDevInited () { return _devInited ; }
    bool IsWindowless () {
//        Assert(_targetPackage._targetType != target_invalid);
        return _targetPackage.GetTargetType() != target_hwnd ;
    }
    
    bool IsTargetPackageValid() { return(_targetPackage.IsValid()); }

    // This adds an incomplete import to the list of imports needed
    // for the current model to be ready

    void AddIncompleteImport(Bvr b) {
        CritSectGrabber csg(_importCS);

        // If the event is currently set then we need to reset it
        if (_pendingImports.size() == 0)
            _importEvent.Reset();

        _pendingImports.insert(b);
    }

    void RemoveIncompleteImport(Bvr b) {
        CritSectGrabber csg(_importCS);

        _pendingImports.erase(b);

        // If there are no more imports set the event
        if (_pendingImports.size() == 0)
            _importEvent.Signal();
    }

    void ClearImportList() {
        CritSectGrabber csg(_importCS);
        _pendingImports.clear();

        // Set the event since there are no more imports

        _importEvent.Signal();
    }

    bool ImportsPending() {
        CritSectGrabber csg(_importCS);
        return (_pendingImports.size() > 0);
    }

    void WaitForImports() {
        _importEvent.Wait();
    }

    void DisableDirtyRects();

    DirectDrawViewport * GetImageDev () { return _imageDev ; }
    MetaSoundDevice * GetSoundDev () { return _soundDev ; }
    PickQ & GetPickQ () { return _pickq ; }
    EventQ & GetEventQ () { return _eventq ; }
    Time GetLastSampleTime() { return _lastSampleTime; }
    DWORD GetLastSystemTime() { return _lastSystemTime; }
    DWORD GetCurrentSystemTime() { return _currentSystemTime; }
    Time GetLocalTime();
    DynamicHeap & GetSampleHeap () { return *_sampleHeap ; }
    DynamicHeap & GetRBHeap () { return *_rbHeap ; }
    DynamicHeap & GetRenderHeap () { return *_renderHeap ; }
    DynamicHeap & GetQueryHitPointHeap () { return *_queryHitPointHeap ; }

    void Repaint();

    void EventHappened();

    void AddPickEvent() { InterlockedIncrement(&_pickEvents); }
    void DecPickEvent() { InterlockedDecrement(&_pickEvents); }

    double GetFramePeriod() { return _framePeriod; }

    double GetFrameRate();
    double GetTimeDelta();

#if PERFORMANCE_REPORTING
    GlobalTimers & GetTimers() { return _timers; }
#endif  // PERFORMANCE_REPORTING

    bool QueryHitPoint(DWORD dwAspect,
                       LPCRECT prcBounds,
                       POINT ptLoc,
                       LONG lCloseHint);

    LONG QueryHitPointEx(LONG s,
                         DWORD_PTR *userIds,
                         double *points,
                         LPCRECT prcBounds,
                         POINT ptLoc);

    LONG GetInvalidatedRects(DWORD flags,
                             LONG  size,
                             RECT *pRects);

    SoundInstanceList *GetSoundInstanceList() {
        return _sndList;
    }

    unsigned int GetSampleID() { return _sampleId; }
    
    PerfTimeXformImpl *GetPerfTimeXformFromCache(Perf);
    void SetPerfTimeXformCache(Perf, PerfTimeXformImpl *);
    void ClearPerfTimeXformCache();
    
  protected:
    targetPackage_t _targetPackage;  // rendering target info
    targetPackage_t _oldTargetPackage;  // last target package
    bool _doTargetUpdate;
    HWND _bogusSoundHwnd ;
    bool _devInited ;

    Image *QueryHitPointWcPt(LPCRECT prcBounds,
                             POINT ptLoc,
                             Point2Value& wcPt);

    DynamicHeap *_sampleHeap ;
    DynamicHeap *_renderHeap ;
    DynamicHeap *_queryHitPointHeap ;
    DynamicHeap *_rbHeap;

    Perf _sndPerf, _imgPerf;
    AxAValue _sndVal, _imgVal, _imgForQueryHitPt;

    typedef map< DWORD, std::pair<Bvr, bool>, less<DWORD> > RunList;
    typedef map< DWORD, Perf, less<DWORD> > RunningList;
    
    RunList _toRunBvrs;
    RunningList _runningBvrs;
    DWORD _runId;

    long _pickEvents;
    PickQ _pickq ;
    EventQ _eventq ;
    Time _lastSampleTime;
    Time _currentSampleTime;
    DWORD _lastSystemTime;
    DWORD _currentSystemTime;

    DirectDrawViewport * _imageDev;
    MetaSoundDevice * _soundDev;

    int   _toPaint;               // number of frames to render

    bool  _firstRendering;
    bool  _someEventHappened;
    bool  _isRBConst;
    bool  _repaintCalled;

    int            _lastSampleId;
    DirtyRectState _dirtyRectState;
    bool           _dirtyRectsDisabled;

    bool  _isStarted;

    // TODO: should decrement _toPaint in Sample, then we don't need this.
    bool  _emptyImageSoFar;
    bool  _firstSample;

#if PERFORMANCE_REPORTING
    void  ResetJitterMeasurements();
#endif  // PERFORMANCE_REPORTING

    void  SubmitNewRenderingTime();
    void StartPerf(Bvr img, Bvr snd, Time time);
    void PreRender();

#define MAX_RENDER_TIMES 1000

    void ReportPerformance();
    void  GetRenderingTimeStats(Real *avg,
                                Real *avgFrameLength,
                                Real *avgVariance,
                                Real *maxVariance,
                                Real *minVariance);
#if PERFORMANCE_REPORTING


    GlobalTimers _timers;
    DWORD _sampleTime;
    DWORD _pickTime;
    DWORD _gcTime;
    DWORD _numSamples;          // Count samples in reporting period
    DWORD _renderTime;
    DWORD _viewStartTime;

#endif  // PERFORMANCE_REPORTING

    DWORD _FPSNumSamples;       // for FrameRate Behavior
    DWORD _FPSLastReportTime;
    double _FPS;
    
    DWORD _numFrames;
    DWORD _lastRenderingTime;
    DWORD _totalTime;
    DWORD _renderTimes[MAX_RENDER_TIMES];
    int   _renderTimeIdx;
    DWORD _lastReportTime;
    double _framePeriod;     // length of time in seconds frame took to render
    HWND CreateViewWindow() ;

    // Retained mode sound
    SpriteNode   *_soundSprite;
    RMImpl       *_rmSound;
    SpriteThread *_spriteThread;

    SoundInstanceList *_sndList;

    CritSect  _importCS;
    set <Bvr> _pendingImports;
    Win32Event _importEvent;

    list<Perf> _events;
    list<Perf> _changeables;
    list<Perf> _conditionals;
    
    unsigned int _lastRBId;
    unsigned int _sampleId;

    typedef map<Perf, PerfTimeXformImpl *, less<Perf> > PerfTTMap;
    PerfTTMap _ttCache;

    double _lastCondsCheckTime;
    double _modelStartTime;
};


class CRView : public View
{
  public:
    CRView();
    ~CRView();

    ULONG AddRef() { return InterlockedIncrement(&_cRef); }
    ULONG Release();

    bool Tick(double simTime);

    void StartModel(Bvr pImage,
                    Bvr pSound,
                    double startTime,
                    DWORD dwFlags,
                    bool & bPending);
    void StopModel();
    void PauseModel();
    void ResumeModel();
    bool Paused() { return _bPaused; }

    void SetSite(CRViewSitePtr pViewSite) { _pViewSite = pViewSite; }
    CRViewSitePtr GetSite() { return _pViewSite; }
    void SetServiceProvider(IServiceProvider * pServiceProvider)
    { _pServiceProvider = pServiceProvider; }
    IServiceProvider * GetServiceProvider() { return _pServiceProvider; }

    bool PutPreference(LPCWSTR prefName, VARIANT v) {
        USES_CONVERSION;
        return SUCCEEDED(_privPrefs.PutPreference(W2A(prefName), v));
    }

    bool GetPreference(LPCWSTR prefName, VARIANT *pV) {
        USES_CONVERSION;
        return SUCCEEDED(_privPrefs.GetPreference(W2A(prefName), pV));
    }

    void Propagate() {
        _privPrefs.Propagate();
    }

    PrivatePreferences& GetPreferences() {
        return _privPrefs;
    }
    
    void                SetStatusText(char * szStatus);

    double              GetCurrentSimulationTime() { return _currentTime; }

    double              GetCurrentGlobalTime()
    { return _localHiresTimer->GetTime(); }

    CritSect &          GetCritSect() { return _crit; }

    bool                GetRenderLock() { return _bRenderLock; }
    void                SetRenderLock(bool b) { _bRenderLock = b; }

#if _DEBUG
    long                GetRefCount() { return _cRef; }
#endif
  protected:
    bool                  _firstRender;
    HiresTimer *          _localHiresTimer;
    DAComPtr<CRViewSite>  _pViewSite;
    DAComPtr<IServiceProvider> _pServiceProvider;
    PrivatePreferences    _privPrefs;
    CritSect              _crit;
    double                _currentTime;
    DWORD                 _ticksAtStart;
    bool                  _bRenderLock;
    bool                  _bPaused;
    long                  _cRef;
};

EventQ & GetCurrentEventQ() ;
PickQ & GetCurrentPickQ() ;
CRView * IntGetCurrentView();
CRView & GetCurrentView() ;
CRView * SetCurrentView(CRView * v) ;

#if _DEBUG
struct DisablePopups
{
    DisablePopups(bool bDisable = true) : _bDisable(bDisable)
    { if (_bDisable) _bPrev = DISABLE_ASSERT_POPUPS(true); }
    ~DisablePopups()
    { if (_bDisable) DISABLE_ASSERT_POPUPS(_bPrev); }

    BOOL _bDisable;
    BOOL _bPrev;
};
#endif

struct ViewPusher
{
    ViewPusher (CRView * cv,
                bool bNeedLock = false,
                bool bNeedRenderLock = false)
    : _cv(*cv),
      _bNeedRenderLock(bNeedRenderLock),
      _bNeedLock(bNeedLock),
      _bWasLocked(false)
    {
        Assert (cv);
        
        _prevView = SetCurrentView(cv);
        if (_bNeedLock) _cv.GetCritSect().Grab();

        if (_bNeedRenderLock) {
            _bWasLocked = _cv.GetRenderLock();
            // XXX tmp for workaround      Assert (!_bWasLocked);
            if (!_bWasLocked) _cv.SetRenderLock(true);
        }
    }
    ~ViewPusher()
    {
        if (_bNeedRenderLock) {
            if (!_bWasLocked) _cv.SetRenderLock(false);
        }
        if (_bNeedLock) _cv.GetCritSect().Release();
        SetCurrentView(_prevView);
    }

    bool WasLocked() { return _bWasLocked; }
    void CheckLock() {
        if (_bNeedRenderLock && _bWasLocked)
            RaiseException_UserError(DAERR_VIEW_LOCKED, IDS_ERR_SRV_RENDER_NOT_REENTRANT);
    }
  protected:
    CRView & _cv;
    CRView * _prevView;
    bool _bNeedLock;
    bool _bNeedRenderLock;
    bool _bWasLocked;
#ifdef _DEBUG
    DisablePopups _popup;
#endif
} ;


#endif /* _DAVIEW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\constant.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    This file contains constant values, which are useful for passing value
pointers to general API entry points.

    IMPORTANT:  These values must not be used for static initialization.  Since
static initialization order is undefined, the following values may not yet have
been set when referenced by other static initializers.  Hence, you can only
assume that these values are valid at run-time.  For static initialization,
use instead the real-valued internal constructors (e.g. new Bbox2(a,b,c,d)).

*******************************************************************************/

#include "headers.h"
#include "appelles/common.h"

    // Actual Value Storage

Real val_zero   = 0;
Real val_one    = 1;
Real val_negOne = -1;

    // Pointers to the Values

AxANumber *zero;
AxANumber *one;
AxANumber *negOne;

AxABoolean *truePtr;
AxABoolean *falsePtr;

void
InitializeModule_Constant()
{
    zero   = RealToNumber (val_zero);
    one    = RealToNumber (val_one);
    negOne = RealToNumber (val_negOne);

    truePtr  = BOOLToAxABoolean (true);
    falsePtr = BOOLToAxABoolean (false);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\server\noexc\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

// Disable warning for exception unwind
#pragma warning(disable:4530)

#include "include/headers.h"
#include <danim.h>
#include <dartapi.h>
#include "privinc/mutex.h"
#include "privinc/comutil.h"
#include "privinc/server.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\d3dutil.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

This file contains utility functions for Direct3D.
*******************************************************************************/

#include "headers.h"

#include "d3drmdef.h"

#ifdef BUILD_USING_CRRM
#include <crrm.h>
#endif

#include "privinc/registry.h"
#include "privinc/ddutil.h"
#include "privinc/d3dutil.h"
#include "privinc/debug.h"
#include "privinc/hresinfo.h"
#include "privinc/xformi.h"
#include "privinc/colori.h"
#include "privinc/vec3i.h"


DeclareTag (tag3DForceDX3, "3D", "Force use of DX3 RM");

static CritSect *D3DUtilCritSect = NULL; // D3D Critical Section
HINSTANCE  hInstD3D = NULL;              // D3D Instance

#ifdef BUILD_USING_CRRM
HINSTANCE  hInstCRRM = NULL;             // CRRM Instance
#endif

Prefs3D    g_prefs3D;                    // 3D Preferences
bool       ntsp3;                        // Running NT Service Pack 3

static HRESULT WINAPI enumFunc
    (GUID*, char*, char*, D3DDEVICEDESC*, D3DDEVICEDESC*, void*);

static void UpdateUserPreferences (PrivatePreferences*, Bool);

static void ReleaseD3DRM1 (void);
static void ReleaseD3DRM3 (void);

    // The D3D device descriptor list contains the chosen software and hardware
    // rendering devices corresponding to specific DirectDraw objects.

static class D3DDeviceNode *D3DDeviceList = NULL;

class D3DDeviceNode
{
  public:

    D3DDeviceNode (IDirectDraw *ddraw) : _ddraw(ddraw)
    {
        _devs = NEW ChosenD3DDevices;
        _next = D3DDeviceList;
        D3DDeviceList = this;

        _devs->software.guid = GUID_NULL;
        _devs->hardware.guid = GUID_NULL;

        // Enumerate the 3D rendering devices using the DX5 enumeration
        // function if possible (this will include MMX renderers).  If not
        // at DX5+, then use the base 3D device enumeration.  Note that we
        // query for the D3D interface first, and then query for the D3D2
        // interface from that -- since we're using DDrawEx, we can't
        // immediately query for D3D2.

        IDirect3D  *d3d1;
        IDirect3D2 *d3d2;

        TD3D (ddraw->QueryInterface (IID_IDirect3D, (void**)&d3d1));

        if (SUCCEEDED (d3d1->QueryInterface (IID_IDirect3D2, (void**)&d3d2)))
        {   TD3D (d3d2->EnumDevices (enumFunc, _devs));
            d3d2->Release();
        }
        else
        {   TD3D (d3d1->EnumDevices (enumFunc, _devs));
        }

        d3d1->Release();
    }

    ~D3DDeviceNode () { delete _devs; }

    IDirectDraw      *_ddraw;   // DirectDraw Object
    ChosenD3DDevices *_devs;    // Chosen D3D Device Info
    D3DDeviceNode    *_next;    // Next Node
};



/*****************************************************************************
3D Modules Initialization and De-Initialization
*****************************************************************************/

extern void InitDDRender     (void);
extern void ShutdownDDRender (void);

void InitializeModule_3D (void)
{
    D3DUtilCritSect = NEW CritSect;
    ExtendPreferenceUpdaterList (UpdateUserPreferences);

    InitDDRender();
}

void DeinitializeModule_3D (bool shutdown)
{
    ShutdownDDRender();

    if (!shutdown)
    {   ReleaseD3DRM3 ();    // Release global shared D3D objects.
        ReleaseD3DRM1 ();
    }

    if (hInstD3D) FreeLibrary (hInstD3D);

#ifdef BUILD_USING_CRRM
    if (hInstCRRM) FreeLibrary (hInstCRRM);
#endif

    // Free up the list of chosen D3D devices.

    while (D3DDeviceList)
    {   D3DDeviceNode *ptr = D3DDeviceList;
        D3DDeviceList = ptr->_next;
        delete ptr;
    }

    delete D3DUtilCritSect;
}



/*****************************************************************************
This procedure snapshots the user preferences from the registry and stores the
values in the global 3D preferences structure.
*****************************************************************************/

static void UpdateUserPreferences (
    PrivatePreferences *prefs,
    Bool                isInitializationTime)
{
    g_prefs3D.lightColorMode =
        prefs->_rgbMode ? D3DCOLOR_RGB : D3DCOLOR_MONO;

    switch (prefs->_fillMode)
    {   default:
        case 0:  g_prefs3D.fillMode = D3DRMFILL_SOLID;      break;
        case 1:  g_prefs3D.fillMode = D3DRMFILL_WIREFRAME;  break;
        case 2:  g_prefs3D.fillMode = D3DRMFILL_POINTS;     break;
    }

    switch (prefs->_shadeMode)
    {   default:
        case 0:  g_prefs3D.shadeMode = D3DRMSHADE_FLAT;     break;
        case 1:  g_prefs3D.shadeMode = D3DRMSHADE_GOURAUD;  break;
        case 2:  g_prefs3D.shadeMode = D3DRMSHADE_PHONG;    break;
    }

    g_prefs3D.texturingQuality =
        prefs->_texturingQuality ? D3DRMTEXTURE_LINEAR : D3DRMTEXTURE_NEAREST;

    g_prefs3D.qualityFlags =
        g_prefs3D.fillMode | g_prefs3D.shadeMode | D3DRMLIGHT_ON;

    g_prefs3D.useMMX = prefs->_useMMX;

    g_prefs3D.dithering      = (prefs->_dithering != 0);
    g_prefs3D.texmapPerspect = (prefs->_texmapPerspect != 0);
    g_prefs3D.texmapping     = (prefs->_texmapping != 0);
    g_prefs3D.useHW          = (prefs->_useHW != 0);
    g_prefs3D.worldLighting  = (prefs->_worldLighting != 0);
}



/*****************************************************************************
This function returns a pointer to the main D3D retained-mode object.
*****************************************************************************/

static IDirect3DRM *d3drm1 = 0;   // Local Static Handle To Main D3DRM Object

static void LoadD3DRM1 (void)
{
    CritSectGrabber csg(*D3DUtilCritSect);

    // Catch the case where another thread loaded D3DRM while this thread was
    // blocked & waiting.

    if (d3drm1) return;

    if (!hInstD3D)
    {
        hInstD3D = LoadLibrary ("d3drm.dll");

        if (!hInstD3D)
        {   Assert(!"LoadLibrary of d3drm.dll failed");
            RaiseException_ResourceError (IDS_ERR_GEO_CREATE_D3DRM);
        }
    }

    FARPROC fptr = GetProcAddress (hInstD3D, "Direct3DRMCreate");

    if (!fptr)
    {   Assert( ! "GetProcAddress of Direct3DRMCreate failed");
        RaiseException_ResourceError (IDS_ERR_GEO_CREATE_D3DRM);
    }

    typedef HRESULT (WINAPI *D3DRMCreatorFunc)(IDirect3DRM* FAR *lplpD3D);

    D3DRMCreatorFunc creatorFunc = (D3DRMCreatorFunc)(fptr);
    HRESULT result = (*creatorFunc)(&d3drm1);

    if (result != D3DRM_OK)
        RaiseException_ResourceError (IDS_ERR_GEO_CREATE_D3DRM);

    // @@@ SRH DX3
    // Determine if we're running NT SP3 by looking at the version of
    // DirectX that we're running.

    ntsp3 = sysInfo.IsNT() && (sysInfo.VersionD3D() == 3) && !GetD3DRM3();

    TraceTag
        ((tagGRenderObj, "First call to GetD3DRM1 returns %x", d3drm1));

    // Now force the loading of the IDirect3DRM3 object if present.  This will
    // ensure that we're in right-hand mode if we're on RM6+.

    if (GetD3DRM3())
    {   TraceTag ((tagGRenderObj, "IDirect3DRM3 present"));
    }
}

/****************************************************************************/

static void ReleaseD3DRM1 (void)
{
    if (d3drm1)
    {   d3drm1->Release();
        d3drm1 = 0;
    }
}

/****************************************************************************/

#ifdef BUILD_USING_CRRM
IDirect3DRM3* GetD3DRM3 (void);
#endif

IDirect3DRM* GetD3DRM1 (void)
{
#ifdef BUILD_USING_CRRM
    if (!d3drm1) 
        d3drm1 = (IDirect3DRM*)GetD3DRM3();
#endif
    if (!d3drm1) LoadD3DRM1();

    return d3drm1;
}



/*****************************************************************************
This method returns the main RM6 interface.
*****************************************************************************/

static IDirect3DRM3 *d3drm3 = 0;         // Local Static Handle to D3DRM3
static bool d3drm3_initialized = false;  // Initialization Flag

void LoadD3DRM3 (void)
{
    #if _DEBUG
    {
        if (IsTagEnabled (tag3DForceDX3))
        {   d3drm3 = 0;
            d3drm3_initialized = true;
            return;
        }
    }
    #endif

    CritSectGrabber csg(*D3DUtilCritSect);

    // Catch the case where another thread loaded D3DRM3 while this thread was
    // blocked & waiting.

    if (d3drm3_initialized) return;

#ifdef BUILD_USING_CRRM
    if (!hInstCRRM)
    {
        hInstCRRM = LoadLibrary ("crrm.dll");

        if (!hInstCRRM)
        {   Assert(!"LoadLibrary of crrm.dll failed");
            RaiseException_ResourceError (IDS_ERR_GEO_CREATE_D3DRM);
        }
    }

    HRESULT result =
        CoCreateInstance(CLSID_CCrRM, NULL, CLSCTX_INPROC_SERVER,
                         IID_IDirect3DRM3, (LPVOID*)&d3drm3);
#else
    HRESULT result =
        GetD3DRM1()->QueryInterface (IID_IDirect3DRM3, (void**)&d3drm3);
#endif

    if (FAILED(result))
        d3drm3 = 0;
    else
    {
        // Set up D3DRM3 to be native right-handed.  This should never fail, so the
        // code will just assume it works.  We could fall back to RM1 in this
        // case, but that's just as bad an arbitrary failure as a handedness
        // problem.

        result = d3drm3->SetOptions (D3DRMOPTIONS_RIGHTHANDED);

        AssertStr (SUCCEEDED(result), "Right-handed mode failed.");
    }

    d3drm3_initialized = true;
}

/****************************************************************************/

static void ReleaseD3DRM3 (void)
{
    if (d3drm3)
    {   d3drm3 -> Release();
        d3drm3 = 0;
        d3drm3_initialized = false;
    }
}

/****************************************************************************/

IDirect3DRM3* GetD3DRM3 (void)
{
    if (!d3drm3_initialized) LoadD3DRM3();
    return d3drm3;
}




/*****************************************************************************
This procedure loads an Appelles transform into the D3DMATRIX4D.  D3D matrices
have their translation components in row 4, while Appelles matrices have their
translation components in column 4.
*****************************************************************************/

void LoadD3DMatrix (D3DRMMATRIX4D &d3dmat, Transform3 *xform)
{
    const Apu4x4Matrix *const M = &xform->Matrix();

    d3dmat[0][0] = D3DVAL (M->m[0][0]);
    d3dmat[0][1] = D3DVAL (M->m[1][0]);
    d3dmat[0][2] = D3DVAL (M->m[2][0]);
    d3dmat[0][3] = D3DVAL (M->m[3][0]);

    d3dmat[1][0] = D3DVAL (M->m[0][1]);
    d3dmat[1][1] = D3DVAL (M->m[1][1]);
    d3dmat[1][2] = D3DVAL (M->m[2][1]);
    d3dmat[1][3] = D3DVAL (M->m[3][1]);

    d3dmat[2][0] = D3DVAL (M->m[0][2]);
    d3dmat[2][1] = D3DVAL (M->m[1][2]);
    d3dmat[2][2] = D3DVAL (M->m[2][2]);
    d3dmat[2][3] = D3DVAL (M->m[3][2]);

    d3dmat[3][0] = D3DVAL (M->m[0][3]);
    d3dmat[3][1] = D3DVAL (M->m[1][3]);
    d3dmat[3][2] = D3DVAL (M->m[2][3]);
    d3dmat[3][3] = D3DVAL (M->m[3][3]);
}



/*****************************************************************************
This function returns a Transform3* from a D3D matrix.  The D3D matrix is in
the transpose form compared to the Transform3 matrices.  In other words, the
translation components are in the bottom row.
*****************************************************************************/

Transform3 *GetTransform3 (D3DRMMATRIX4D &d3dmat)
{
    return Transform3Matrix16
           (    d3dmat[0][0], d3dmat[1][0], d3dmat[2][0], d3dmat[3][0],
                d3dmat[0][1], d3dmat[1][1], d3dmat[2][1], d3dmat[3][1],
                d3dmat[0][2], d3dmat[1][2], d3dmat[2][2], d3dmat[3][2],
                d3dmat[0][3], d3dmat[1][3], d3dmat[2][3], d3dmat[3][3]
           );
}



/*****************************************************************************
This helper function returns the D3D color from a Color *value and an opacity.
*****************************************************************************/

    static inline int cval8bit (Real number) {
        return int (255 * CLAMP (number, 0, 1));
    }

D3DCOLOR GetD3DColor (Color *color, Real alpha)
{
    // D3D color components must lie in the range from 0 to 255.
    // Unfortunately, these colors are clamped to this range here rather than
    // in rendering since they are packed into a single 32-bit value, so we
    // can't support things like super lights or dark lights, even though D3D
    // IM supports it.

    return RGBA_MAKE
    (   cval8bit (color->red),
        cval8bit (color->green),
        cval8bit (color->blue),
        cval8bit (alpha)
    );
}



/*****************************************************************************
Conversion between D3D/D3DRM and DA Math Primitives
*****************************************************************************/

void LoadD3DVec (D3DVECTOR &d3dvec, Vector3Value &V)
{
    d3dvec.x = V.x;
    d3dvec.y = V.y;
    d3dvec.z = V.z;
}

void LoadD3DVec (D3DVECTOR &d3dvec, Point3Value &P)
{
    d3dvec.x = P.x;
    d3dvec.y = P.y;
    d3dvec.z = P.z;
}

void LoadD3DRMRay (D3DRMRAY &d3dray, Ray3 &ray)
{
    LoadD3DVec (d3dray.dvDir, ray.Direction());
    LoadD3DVec (d3dray.dvPos, ray.Origin());
}



/*****************************************************************************
This function is called by the Direct3D device-enumeration callback.  It
examines each device in turn to find the best matching hardware or software
device.
*****************************************************************************/

static HRESULT WINAPI enumFunc (
    GUID          *guid,      // This Device's GUID
    char          *dev_desc,  // Device Description String
    char          *dev_name,  // Device Name String
    D3DDEVICEDESC *hwDesc,    // HW Device Description
    D3DDEVICEDESC *swDesc,    // SW Device Description
    void          *context)   // Private enumArgs Struct Above
{

    // Use MMX device in preference to RGB device
    // the "special chrome" MMX device = standard MMX device now

    if (!(g_prefs3D.useMMX) && (*guid == IID_IDirect3DMMXDevice))
    {   TraceTag ((tag3DDevSelect, "Skipping MMX rendering device."));
        return D3DENUMRET_OK;
    }

    // Skip the reference rasterizer; it's only useful for visual validation
    // of 3D rendering devices (and it's slow).

    if (*guid == IID_IDirect3DRefDevice)
    {   TraceTag ((tag3DDevSelect, "Skipping reference rasterizer."));
        return D3DENUMRET_OK;
    }

    ChosenD3DDevices *chosenDevs = (ChosenD3DDevices*) context;

    // Determine if this is a hardware device by looking at the color model
    // field of the hardware driver description.  If the color model is 0
    // (invalid), then it's a software driver.

    bool hardware = (hwDesc->dcmColorModel != 0);

    D3DDeviceInfo *chosen;
    D3DDEVICEDESC *devdesc;

    if (hardware)
    {   chosen  = &chosenDevs->hardware;
        devdesc = hwDesc;
    }
    else
    {   chosen  = &chosenDevs->software;
        devdesc = swDesc;
    }

    #if _DEBUG
    if (IsTagEnabled(tag3DDevSelect))
    {
        char buff[2000];

        TraceTag ((tag3DDevSelect,
            "3D %s Device Description:", hardware ? "Hardware" : "Software"));

        wsprintf
        (   buff,
            "    %s (%s)\n"
            "    Flags %x, Color Model %d%s\n"
            "    DevCaps %x:\n",
            dev_desc, dev_name,
            devdesc->dwFlags,
            devdesc->dcmColorModel,
                (devdesc->dcmColorModel == D3DCOLOR_MONO) ? " (mono)" :
                (devdesc->dcmColorModel == D3DCOLOR_RGB)  ? " (rgb)"  : "",
            devdesc->dwDevCaps
        );

        OutputDebugString (buff);

        static struct { DWORD val; char *expl; } devcaptable[] =
        {
            { D3DDEVCAPS_FLOATTLVERTEX,
              "FLOATTLVERTEX: Accepts floating point" },

            { D3DDEVCAPS_SORTINCREASINGZ,
              "SORTINCREASINGZ: Needs data sorted for increasing Z" },

            { D3DDEVCAPS_SORTDECREASINGZ,
              "SORTDECREASINGZ: Needs data sorted for decreasing Z" },

            { D3DDEVCAPS_SORTEXACT,
              "SORTEXACT: Needs data sorted exactly" },

            { D3DDEVCAPS_EXECUTESYSTEMMEMORY,
              "EXECUTESYSTEMMEMORY: Can use execute buffers from system memory" },

            { D3DDEVCAPS_EXECUTEVIDEOMEMORY,
              "EXECUTEVIDEOMEMORY: Can use execute buffers from video memory" },

            { D3DDEVCAPS_TLVERTEXSYSTEMMEMORY,
              "TLVERTEXSYSTEMMEMORY: Can use TL buffers from system memory" },

            { D3DDEVCAPS_TLVERTEXVIDEOMEMORY,
              "TLVERTEXVIDEOMEMORY: Can use TL buffers from video memory" },

            { D3DDEVCAPS_TEXTURESYSTEMMEMORY,
              "TEXTURESYSTEMMEMORY: Can texture from system memory" },

            { D3DDEVCAPS_TEXTUREVIDEOMEMORY,
              "TEXTUREVIDEOMEMORY: Can texture from device memory" },

            { D3DDEVCAPS_DRAWPRIMTLVERTEX,
              "DRAWPRIMTLVERTEX: Can draw TLVERTEX primitives" },

            { D3DDEVCAPS_CANRENDERAFTERFLIP,
              "CANRENDERAFTERFLIP: Can render without waiting for flip to complete" },

            { D3DDEVCAPS_TEXTURENONLOCALVIDMEM,
              "TEXTURENONLOCALVIDMEM: Device can texture from nonlocal video memory" },

            { 0, 0 }
        };

        unsigned int i;
        for (i=0;  devcaptable[i].val;  ++i)
        {
            if (devdesc->dwDevCaps & devcaptable[i].val)
            {
                wsprintf (buff, "        %s\n", devcaptable[i].expl);
                OutputDebugString (buff);
            }
        }

        wsprintf
        (   buff,
            "    TransformCaps %x, Clipping %d\n"
            "    Lighting: Caps %x, Model %x, NumLights %d\n"
            "    Line Caps: Misc %x, Raster %x, Zcmp %x, SrcBlend %x\n"
            "               DestBlend %x, AlphaCmp %x, Shade %x, Texture %x\n"
            "               TexFilter %x, TexBlend %x, TexAddr %x\n"
            "               Stipple Width %x, Stipple Height %x\n"
            "    Tri  Caps: Misc %x, Raster %x, Zcmp %x, SrcBlend %x\n"
            "               DestBlend %x, AlphaCmp %x, Shade %x, Texture %x\n"
            "               TexFilter %x, TexBlend %x, TexAddr %x\n"
            "               Stipple Width %x, Stipple Height %x\n"
            "    Render Depth %x, Zbuffer Depth %x\n"
            "    Max Buffer Size %d, Max Vertex Count %d\n",
            devdesc->dtcTransformCaps.dwCaps,
            devdesc->bClipping,
            devdesc->dlcLightingCaps.dwCaps,
            devdesc->dlcLightingCaps.dwLightingModel,
            devdesc->dlcLightingCaps.dwNumLights,
            devdesc->dpcLineCaps.dwMiscCaps,
            devdesc->dpcLineCaps.dwRasterCaps,
            devdesc->dpcLineCaps.dwZCmpCaps,
            devdesc->dpcLineCaps.dwSrcBlendCaps,
            devdesc->dpcLineCaps.dwDestBlendCaps,
            devdesc->dpcLineCaps.dwAlphaCmpCaps,
            devdesc->dpcLineCaps.dwShadeCaps,
            devdesc->dpcLineCaps.dwTextureCaps,
            devdesc->dpcLineCaps.dwTextureFilterCaps,
            devdesc->dpcLineCaps.dwTextureBlendCaps,
            devdesc->dpcLineCaps.dwTextureAddressCaps,
            devdesc->dpcLineCaps.dwStippleWidth,
            devdesc->dpcLineCaps.dwStippleHeight,
            devdesc->dpcTriCaps.dwMiscCaps,
            devdesc->dpcTriCaps.dwRasterCaps,
            devdesc->dpcTriCaps.dwZCmpCaps,
            devdesc->dpcTriCaps.dwSrcBlendCaps,
            devdesc->dpcTriCaps.dwDestBlendCaps,
            devdesc->dpcTriCaps.dwAlphaCmpCaps,
            devdesc->dpcTriCaps.dwShadeCaps,
            devdesc->dpcTriCaps.dwTextureCaps,
            devdesc->dpcTriCaps.dwTextureFilterCaps,
            devdesc->dpcTriCaps.dwTextureBlendCaps,
            devdesc->dpcTriCaps.dwTextureAddressCaps,
            devdesc->dpcTriCaps.dwStippleWidth,
            devdesc->dpcTriCaps.dwStippleHeight,
            devdesc->dwDeviceRenderBitDepth,
            devdesc->dwDeviceZBufferBitDepth,
            devdesc->dwMaxBufferSize,
            devdesc->dwMaxVertexCount
        );

        OutputDebugString (buff);
    }
    #endif

    // If we've already chosen the MMX device, then we don't want to choose any
    // other device over it.

    if (chosen->guid == IID_IDirect3DMMXDevice)
    {   TraceTag ((tag3DDevSelect,
            "Skipping - already have an MMX device for software rendering."));
        return D3DENUMRET_OK;
    }

    // Skip this device if it's a software renderer that doesn't support the
    // requested lighting color model.

    if (!(devdesc->dcmColorModel & g_prefs3D.lightColorMode))
    {   TraceTag ((tag3DDevSelect, "Skipping - color model %x unsupported.",
            g_prefs3D.lightColorMode));
        return D3DENUMRET_OK;
    }

    // Ensure that this device supports all lights we care about, and doesn't
    // place restrictions on the number of lights.

    if (!(devdesc->dwFlags & D3DDD_LIGHTINGCAPS))
    {   TraceTag ((tag3DDevSelect, "No lighting information available."));
    }
    else
    {
        if (devdesc->dlcLightingCaps.dwNumLights)
        {   TraceTag ((tag3DDevSelect,
                "Skipping - Limited to %d lights maximum.",
                devdesc->dlcLightingCaps.dwNumLights));
            return D3DENUMRET_OK;
        }

        const DWORD lightTypes =
            D3DLIGHTCAPS_DIRECTIONAL | D3DLIGHTCAPS_POINT | D3DLIGHTCAPS_SPOT;

        if (lightTypes != (devdesc->dlcLightingCaps.dwCaps & lightTypes))
        {   TraceTag ((tag3DDevSelect,
                "Skipping - does not support all light types."));
            return D3DENUMRET_OK;
        }
    }

    // Ensure that the device supports texmapping.

    if (!devdesc->dpcTriCaps.dwTextureCaps)
    {   TraceTag ((tag3DDevSelect,
            "Skipping - doesn't support texture-mapping."));
        return D3DENUMRET_OK;
    }

    // Ensure that the device supports the required cull modes.  If we're on
    // RM3 (DX6), then we need clockwise culling since we'll be using
    // RM's right-hand mode.

    DWORD cullmodes;

    if (GetD3DRM3())
        cullmodes = D3DPMISCCAPS_CULLCCW | D3DPMISCCAPS_CULLCW;
    else
        cullmodes = D3DPMISCCAPS_CULLCCW;

    if (!(devdesc->dpcTriCaps.dwMiscCaps & cullmodes))
    {   TraceTag ((tag3DDevSelect,
            "Skipping - doesn't support required culling orders."));
        return D3DENUMRET_OK;
    }

    // This device passes all tests; choose it.

    TraceTag ((tag3DDevSelect, "Choosing this device"));

    chosen->desc = *devdesc;
    chosen->guid = *guid;

    return D3DENUMRET_OK;
}



/*****************************************************************************
This function launches the Direct3D device enumeration sequence to find the
preferred matching 3D rendering device for both software & hardware rendering.
*****************************************************************************/

ChosenD3DDevices* SelectD3DDevices (IDirectDraw *ddraw)
{
    CritSectGrabber csg (*D3DUtilCritSect);

    Assert (ddraw);

    // First see if we've already selected D3D devices for this particular
    // DDraw object.  If so, just return the cached information.

    D3DDeviceNode *ptr = D3DDeviceList;

    TraceTag ((tag3DDevSelect,
        "Querying chosen 3D devices for DDraw object %x", ddraw));

    DebugCode (int count=0;)

    while (ptr && (ptr->_ddraw != ddraw))
    {   DebugCode (++count;)
        ptr = ptr->_next;
    }

    if (ptr)
    {   TraceTag ((tag3DDevSelect,
            "Found existing info (node %d)", 1-count));
        return ptr->_devs;
    }

    // DDraw object not present in list, so create a NEW node and return the
    // devices' description.

    TraceTag ((tag3DDevSelect, "%d nodes examined, DDraw %x not encountered",
               count, ddraw));

    D3DDeviceNode *newnode = NEW D3DDeviceNode (ddraw);

    return newnode->_devs;   // Return the winning GUID.
}



/*****************************************************************************
*****************************************************************************/

RMTextureWrap::RMTextureWrap(void)
{
    _wrapObj = NULL;
}

RMTextureWrap::RMTextureWrap(TextureWrapInfo *info,Bbox3* bbox)
{
    _wrapObj = NULL;
    Init(info,bbox);
}

RMTextureWrap::~RMTextureWrap(void)
{
    if (_wrapObj) {
        _wrapObj->Release();
    }
}

void RMTextureWrap::Init(TextureWrapInfo *info,Bbox3* bbox)
{
    if (_wrapObj) {
        _wrapObj->Release();
        _wrapObj = NULL;
    }

    _wrapU = info->wrapU;
    _wrapV = info->wrapV;

    if (info->relative && bbox && bbox->Finite()) {
        info->origin = *(bbox->Center());
        Real boxSizeX = fabs(bbox->max.x - bbox->min.x);
        Real boxSizeY = fabs(bbox->max.y - bbox->min.y);
        switch ((D3DRMWRAPTYPE) info->type) {
        case D3DRMWRAP_FLAT :
        case D3DRMWRAP_SHEET :
        case D3DRMWRAP_BOX :
            if (boxSizeX > 0.0) {
                info->texScale.x /= boxSizeX;
            }
            // fall-through
        case D3DRMWRAP_CYLINDER :
            if (boxSizeY > 0.0) {
                info->texScale.y /= boxSizeY;
            }
            break;
        default:
            break;
        }
    }
    HRESULT hr = AD3D(GetD3DRM3()->CreateWrap(
            (D3DRMWRAPTYPE) info->type, NULL,
            info->origin.x,info->origin.y,info->origin.z,
            info->z.x,info->z.y,info->z.z,
            info->y.x,info->y.y,info->y.z,
            info->texOrigin.x,info->texOrigin.y,
            info->texScale.x,info->texScale.y,
            &_wrapObj));

    if (FAILED(hr)) {
        TraceTag((tagError, "Cannot create D3DRMWrap object"));
        _wrapObj = NULL;
    }
}

HRESULT RMTextureWrap::Apply(IDirect3DRMVisual *vis)
{
    HRESULT hr = E_FAIL;

    if (_wrapObj && vis) {
        hr = RD3D(_wrapObj->Apply(vis));
    }

    return hr;
}

HRESULT RMTextureWrap::ApplyToFrame(
    IDirect3DRMFrame3   *pFrame)
{
    HRESULT hres;
    DWORD   dwI;
    DWORD   dwNumVisuals;
    IUnknown **ppIUnk;

    if (!_wrapObj) {
        return E_FAIL;
    }

    // Iterate over all visuals setting the texture topology
    hres = RD3D(pFrame->GetVisuals(&dwNumVisuals,NULL));
    if (FAILED(hres))
    {
        return (hres);
    }
    ppIUnk = new LPUNKNOWN[dwNumVisuals];
    if (!ppIUnk)
    {
        return E_OUTOFMEMORY;
    }
    hres = RD3D(pFrame->GetVisuals(&dwNumVisuals,ppIUnk));
    if (FAILED(hres))
    {
        return (hres);
    }
    for (dwI = 0; dwI < dwNumVisuals; dwI++)
    {
        LPDIRECT3DRMVISUAL pVis;
        LPDIRECT3DRMMESHBUILDER3 pMB;

        if (SUCCEEDED(ppIUnk[dwI]->QueryInterface(IID_IDirect3DRMMeshBuilder3, (LPVOID*)&pMB)))
        {
            RD3D(_wrapObj->Apply(pMB));
            pMB->Release();
        }
        ppIUnk[dwI]->Release();
    }
    delete[] ppIUnk;

    // Recurse over child frames
    LPDIRECT3DRMFRAMEARRAY pFrameArray;

    hres = RD3D(pFrame->GetChildren(&pFrameArray));
    if (FAILED(hres))
    {
        return (hres);
    }
    for (dwI = 0; dwI < pFrameArray->GetSize(); dwI++)
    {
        IDirect3DRMFrame  *pFrameTmp;
        IDirect3DRMFrame3 *pFrame;

        hres = RD3D(pFrameArray->GetElement(dwI, &pFrameTmp));
        if (FAILED(hres))
        {
            pFrameArray->Release();
            return (hres);
        }
        hres = pFrameTmp->QueryInterface(IID_IDirect3DRMFrame3,(LPVOID *) &pFrame);
        if (FAILED(hres))
        {
            pFrameTmp->Release();
            pFrameArray->Release();
            return (hres);
        }
        hres = ApplyToFrame(pFrame);
        if (FAILED(hres))
        {
            pFrame->Release();
            pFrameTmp->Release();
            pFrameArray->Release();
            return (hres);
        }
        pFrame->Release();
    }
    pFrameArray->Release();

    return (S_OK);
}

bool RMTextureWrap::WrapU(void)
{
    return _wrapU;
}

bool RMTextureWrap::WrapV(void)
{
    return _wrapV;
}


HRESULT SetRMFrame3TextureTopology(
    IDirect3DRMFrame3 *pFrame,
    bool wrapU,
    bool wrapV)
{
    HRESULT hres;
    DWORD   dwI;
    DWORD   dwNumVisuals;
    IUnknown **ppIUnk;

    // Iterate over all visuals setting the texture topology
    hres = RD3D(pFrame->GetVisuals(&dwNumVisuals,NULL));
    if (FAILED(hres))
    {
        return (hres);
    }
    ppIUnk = new LPUNKNOWN[dwNumVisuals];
    if (!ppIUnk)
    {
        return E_OUTOFMEMORY;
    }
    hres = RD3D(pFrame->GetVisuals(&dwNumVisuals,ppIUnk));
    if (FAILED(hres))
    {
        return (hres);
    }
    for (dwI = 0; dwI < dwNumVisuals; dwI++)
    {
        LPDIRECT3DRMVISUAL pVis;
        LPDIRECT3DRMMESHBUILDER3 pMB;

        if (SUCCEEDED(ppIUnk[dwI]->QueryInterface(IID_IDirect3DRMMeshBuilder3, (LPVOID*)&pMB)))
        {
            RD3D(pMB->SetTextureTopology((BOOL) wrapU, (BOOL) wrapV));
            pMB->Release();
        }
        ppIUnk[dwI]->Release();
    }
    delete[] ppIUnk;

    // Recurse over child frames
    LPDIRECT3DRMFRAMEARRAY pFrameArray;

    hres = RD3D(pFrame->GetChildren(&pFrameArray));
    if (FAILED(hres))
    {
        return (hres);
    }
    for (dwI = 0; dwI < pFrameArray->GetSize(); dwI++)
    {
        IDirect3DRMFrame  *pFrameTmp;
        IDirect3DRMFrame3 *pFrame;

        hres = RD3D(pFrameArray->GetElement(dwI, &pFrameTmp));
        if (FAILED(hres))
        {
            pFrameArray->Release();
            return (hres);
        }
        hres = pFrameTmp->QueryInterface(IID_IDirect3DRMFrame3,(LPVOID *) &pFrame);
        if (FAILED(hres))
        {
            pFrameTmp->Release();
            pFrameArray->Release();
            return (hres);
        }
        hres = SetRMFrame3TextureTopology(pFrame,wrapU,wrapV);
        if (FAILED(hres))
        {
            pFrame->Release();
            pFrameTmp->Release();
            pFrameArray->Release();
            return (hres);
        }
        pFrame->Release();
    }
    pFrameArray->Release();

    return (S_OK);
}


//----------------------------------------------------------------------------
//                        D E B U G   F U N C T I O N S
//----------------------------------------------------------------------------
#if _DEBUG

/*****************************************************************************
Debugging function to dump information about a D3D mesh object.
*****************************************************************************/

void dumpmesh (IDirect3DRMMesh *mesh)
{
    char buff[1024];

    unsigned int ngroups = mesh->GetGroupCount();

    sprintf (buff, "Dumping info for mesh %p\n    %u groups\n", mesh, ngroups);
    OutputDebugString (buff);

    unsigned int i;

    for (i=0;  i < ngroups;  ++i)
    {
        unsigned int nfaces;   // Number of Faces
        unsigned int nverts;   // Number of Vertices
        unsigned int vpface;   // Number of Vertices Per Face
        DWORD junk;

        if (SUCCEEDED (mesh->GetGroup (i, &nverts,&nfaces,&vpface, &junk, 0)))
        {
            sprintf (buff,
                "    Group %u:  %u vertices, %u faces, %u verts per face\n",
                i, nverts, nfaces, vpface);
            OutputDebugString (buff);
        }
    }
}



void
IndentStr(char *str, int indent)
{
    for (int i = 0; i < indent; i++) {
        OutputDebugString(" ");
    }
    OutputDebugString(str);
}



void
dumpbuilderhelper(IUnknown *unk, int indent)
{
    char buf[256];
    IDirect3DRMMeshBuilder3 *mb;
    HRESULT hr =
        unk->QueryInterface(IID_IDirect3DRMMeshBuilder3,
                            (void **)&mb);

    if (FAILED(hr)) {
        IndentStr("Not a meshbuilder", indent);
        return;
    }

    IDXBaseObject *baseObj;
    TD3D(mb->QueryInterface(IID_IDXBaseObject, (void **)&baseObj));

    ULONG genId;
    TD3D(baseObj->GetGenerationId(&genId));
    baseObj->Release();

    sprintf(buf, "Meshbuilder %p, unk %p, generation id %d\n",
        mb, unk, genId);
    IndentStr(buf, indent);

    ULONG faces = mb->GetFaceCount();
    sprintf(buf, "%d faces\n", faces);
    IndentStr(buf, indent);

    D3DRMBOX rmbox;
    mb->GetBox (&rmbox);
    sprintf (buf, "       bbox {%g,%g,%g} x {%g,%g,%g}\n",
        rmbox.min.x, rmbox.min.y, rmbox.min.z,
        rmbox.max.x, rmbox.max.y, rmbox.max.z);
    IndentStr (buf, indent);

    DWORD nverts;

    if (SUCCEEDED(mb->GetVertices (0, &nverts, 0)))
    {
        sprintf (buf, "%d vertices\n", nverts);
        IndentStr (buf, indent);

        D3DVECTOR *verts = NEW D3DVECTOR[nverts];

        if (SUCCEEDED (mb->GetVertices (0, &nverts, verts)))
        {
            Bbox3 bbox;
            int i;

            for (i=0;  i < nverts;  ++i)
                bbox.Augment (verts[i].x, verts[i].y, verts[i].z);

            sprintf (buf, "actual bbox {%g,%g,%g} x {%g,%g,%g}\n",
                bbox.min.x, bbox.min.y, bbox.min.z,
                bbox.max.x, bbox.max.y, bbox.max.z);
            IndentStr (buf, indent);
        }

        delete verts;
    }

    ULONG submeshCount;
    TD3D(mb->GetSubMeshes(&submeshCount, NULL));

    sprintf(buf, "%d submeshes\n", submeshCount);
    IndentStr(buf, indent);

    IUnknown *submeshes[50];
    TD3D(mb->GetSubMeshes(&submeshCount, submeshes));

    for (int i = 0; i < submeshCount; i++) {
        sprintf(buf, "submesh %d, unk is %p\n",
                i, submeshes[i]);
        IndentStr(buf, indent);
    }

    OutputDebugString("\n");

    for (i = 0; i < submeshCount; i++) {
        dumpbuilderhelper(submeshes[i], indent + 4);
        submeshes[i]->Release();
    }

    mb->Release();
}

void dumpbuilder(IUnknown *unk)
{
    dumpbuilderhelper(unk, 0);
}



/*****************************************************************************
This debug-only function gets the DDraw surface associated with a given RM
texture.
*****************************************************************************/

IDirectDrawSurface* getTextureSurface (IUnknown *unknown)
{
    IDirect3DRMTexture3 *texture;

    if (FAILED(unknown->QueryInterface(IID_IDirect3DRMTexture3, (void**)&texture)))
    {   OutputDebugString ("Object is not an IDirect3DRMTexture3.\n");
        return 0;
    }

    IDirectDrawSurface  *surface;

    if (FAILED(texture->GetSurface(0, &surface)))
    {   OutputDebugString
            ("Couldn't get surface (texture created some other way).\n");
        texture->Release();
        return 0;
    }

    texture->Release();
    return surface;
}



/*****************************************************************************
This debug-only routine dumps info about the surface associated with an RM
texture.
*****************************************************************************/

void texsurfinfo (IUnknown *unknown)
{
    IDirectDrawSurface *surface = getTextureSurface (unknown);

    void surfinfo (IDirectDrawSurface*);

    if (surface)
    {   surfinfo (surface);
        surface->Release();
    }
}



/*****************************************************************************
This debug-only routine blits the texture image to the screen for examination.
*****************************************************************************/

void showtexture (IUnknown *unknown)
{
    IDirectDrawSurface *surface = getTextureSurface (unknown);

    if (surface)
    {   showme2(surface);
        surface->Release();
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\dastream.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include <urlmon.h>
#include <wininet.h>
#include "privinc/debug.h"
#include "privinc/dastream.h"
#include "privinc/urlbuf.h"
#include "privinc/util.h"
#include "privinc/except.h"
#include "privinc/resource.h"
#include "privinc/server.h"
#include "privinc/mutex.h"

DeclareTag(tagDAStream, "DAStream", "Errors");

//
// OLE Stream
//

ULONG
daolestream::read (void *pv, ULONG cb)
{
    Assert (_stream.p);

    if (!_stream) {
        TraceTag((tagDAStream, "daolestream::read Uninitialized stream"));
        RaiseException_InternalErrorCode (E_INVALIDARG,"Tried to read from uninitialized stream");
    }

    ULONG cbRead = 0;

    // A failed error code could mean EOF
    _stream->Read(pv,cb,&cbRead);

    return cbRead;
}

ULONG
daolestream::write (void *pv, ULONG cb, bool bWriteAll)
{
    Assert (_stream.p);

    if (!_stream) {
        TraceTag((tagDAStream, "daolestream::write Uninitialized stream"));
        RaiseException_InternalErrorCode (E_INVALIDARG,
                            "Tried to write to uninitialized stream");
    }

    ULONG ret = 0;
    char * curpv = (char *)pv;

    do {
        ULONG cbWritten = 0;
        HRESULT hr;

        if ((hr = THR(_stream->Write(&curpv[ret],cb - ret,&cbWritten)) != S_OK))
            RaiseException_InternalErrorCode (hr,
                                    "Failed to write to stream");

        ret += cbWritten;
    } while (bWriteAll && ret < cb) ;

    return ret;
}

ULONG
daolestream::seek (LONG offset, DASEEK origin)
{
    Assert (_stream.p);

    if (!_stream) {
        TraceTag((tagDAStream, "daolestream::seek: Uninitialized stream"));
        RaiseException_InternalErrorCode (E_INVALIDARG,
                                "Tried to seek in uninitialized stream");
    }

    STREAM_SEEK fdir;
    ULARGE_INTEGER retpos;

    TraceTag((tagNetIO, "urlbuf::seekoff"));

    switch (origin) {
      case DASEEK_SET:
        fdir = STREAM_SEEK_SET;
        break;
      case DASEEK_CUR:
        fdir = STREAM_SEEK_CUR;
        break;
      case DASEEK_END:
        fdir = STREAM_SEEK_END;
        break;
      default:
        TraceTag((tagDAStream, "daolestream::seek: Invalid origin"));
        RaiseException_InternalErrorCode (E_INVALIDARG,
                                "Tried to seek with invalid origin");
    }

    HRESULT hr;
    LARGE_INTEGER lioffset;
    lioffset.QuadPart = offset;
    if ((hr = THR(_stream->Seek (lioffset,
                                 fdir,
                                 &retpos)) != S_OK))
        RaiseException_InternalErrorCode (hr,
                                "Failed to seek in stream");

    return(retpos.LowPart);
}

//
// Win32 Stream
//

ULONG
dawin32stream::read (void *pv, ULONG cb)
{
    Assert (_handle);

    if (!_handle) {
        TraceTag((tagDAStream, "dawin32stream::read Uninitialized stream"));
        RaiseException_InternalErrorCode (E_INVALIDARG,
                                "Tried to read from uninitialized stream");
    }

    DWORD cbRead;

    if (!ReadFile(_handle,pv,cb,&cbRead,NULL)) {
        TraceTag((tagDAStream, "dawin32stream::read: Read failed 0x%lX",GetLastError()));
        RaiseException_InternalErrorCode (GetLastError(),
                                "Failed to read from stream");
    }

    return cbRead;
}

ULONG
dawin32stream::write (void *pv, ULONG cb, bool bWriteAll)
{
    Assert (_handle);

    if (!_handle) {
        TraceTag((tagDAStream, "dawin32stream::write Uninitialized stream"));
        RaiseException_InternalErrorCode (E_INVALIDARG,
                                "Tried to write to uninitialized stream");
    }

    DWORD ret = 0;
    char * curpv = (char *)pv;

    do {
        DWORD cbWritten = 0;
        if (!WriteFile(_handle,&curpv[ret],cb - ret,&cbWritten,NULL)) {
            TraceTag((tagDAStream, "dawin32stream::write: Write failed 0x%lx",GetLastError()));
            RaiseException_InternalErrorCode (GetLastError(),
                                    "Failed to write to stream");
        }

        ret += cbWritten;
    } while (bWriteAll && ret < cb) ;

    return ret;
}

ULONG
dawin32stream::seek (LONG offset, DASEEK origin)
{
    Assert (_handle);

    if (!_handle) {
        TraceTag((tagDAStream, "dawin32stream::seek: Uninitialized stream"));
        RaiseException_InternalErrorCode (E_INVALIDARG,
                                "Tried to seek in uninitialized stream");
    }

    DWORD fdir;
    DWORD retpos;

    TraceTag((tagNetIO, "urlbuf::seekoff"));

    switch (origin) {
      case DASEEK_SET:
        fdir = FILE_BEGIN;
        break;
      case DASEEK_CUR:
        fdir = FILE_CURRENT;
        break;
      case DASEEK_END:
        fdir = FILE_END;
        break;
      default:
        TraceTag((tagDAStream, "dawin32stream::seek: Invalid origin"));
        RaiseException_InternalErrorCode (E_INVALIDARG,
                                "Tried to seek with invalid origin");
    }

    retpos = SetFilePointer(_handle,
                            offset,
                            NULL,
                            fdir);

    //if (retpos = 0xffffffff) {
    if (retpos == 0xffffffff) {
        TraceTag((tagDAStream, "dawin32stream::seek: Seek failed 0x%lx",GetLastError()));
        RaiseException_InternalErrorCode (GetLastError(),
                                "Failed to seek in stream");
    }

    return(retpos);
}

//
// dastrstream
//

ULONG
dastrstream::read (void *pv, ULONG cb)
{
    ULONG cbLeft = _size - _curpos;

    if (cb > cbLeft) cb = cbLeft;

    memcpy(pv,&_pdata[_curpos],cb);
    _curpos += cb;

    return cb;
}

ULONG
dastrstream::write (void *pv, ULONG cb, bool bWriteAll)
{
    ULONG cbLeft = _size - _curpos;

    if (cb > cbLeft) cb = cbLeft;

    memcpy(&_pdata[_curpos],pv,cb);
    _curpos += cb;

    return cb;
}

ULONG
dastrstream::seek (LONG offset, DASEEK origin)
{
    DWORD startpos;
    DWORD retpos;

    TraceTag((tagNetIO, "urlbuf::seekoff"));

    switch (origin) {
      case DASEEK_SET:
        startpos = 0;
        break;
      case DASEEK_CUR:
        startpos = _curpos;
        break;
      case DASEEK_END:
        startpos = _size;
        break;
      default:
        TraceTag((tagDAStream, "dastrstream::seek: Invalid origin"));
        RaiseException_InternalErrorCode (E_INVALIDARG,"Tried to seek with invalid origin");
    }

    retpos = startpos + offset;
    if (retpos > _size) {
        TraceTag((tagDAStream,
                  "dastrstream::seek: Seek failed - invalid position %ld",
                  retpos));
        RaiseException_InternalErrorCode (E_INVALIDARG,"Failed to seek in stream");
    }

    _curpos = retpos;

    return retpos;
}

void
dastrstream::init(void * pv, ULONG cb)
{
    _pdata = THROWING_ARRAY_ALLOCATOR(char,cb);

    if (pv) memcpy(_pdata,pv,cb);
    _curpos = 0;
    _size = cb;
}

//
// dafstream
//

void
dafstream::open(char *file, int mode)
{
    close();

    _mode = mode;

    DWORD dwAccess = 0;
    DWORD dwShare = 0;
    DWORD dwCreate = 0;

    if (mode & damode_read) dwAccess |= GENERIC_READ;
    if (mode & damode_write) dwAccess |= GENERIC_WRITE;

    if (mode & damode_nocreate)
        dwCreate = OPEN_EXISTING;
    else if (mode & damode_noreplace)
        dwCreate = CREATE_NEW;
    else if (mode & damode_trunc)
        dwCreate = CREATE_ALWAYS;
    else if (mode & damode_write)
        dwCreate = OPEN_ALWAYS;
    else
        dwCreate = OPEN_EXISTING;

    if (!(mode & damode_noshare)) dwShare |= (FILE_SHARE_READ | FILE_SHARE_WRITE);

    HANDLE h = CreateFile(file,dwAccess,dwShare,NULL,
                          dwCreate,FILE_ATTRIBUTE_NORMAL,NULL);

    if (h == INVALID_HANDLE_VALUE)
        RaiseException_UserError (GetLastError(),
                            IDS_ERR_OPEN_FILE_FAILED,
                            file);

    SetHandle(h);
}

void
dafstream::close()
{
    HANDLE h = GetHandle();

    if (h) {
        CloseHandle(h);
        SetHandle(NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\crc.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

Routines for calculating Cyclic-Redundancy Codes (CRC).  These are useful for
quickly comparing blocks of data to see if they differ.  CRC's are guaranteed
to be identical for identical blocks, but may also yield identical values for
different blocks (though unlikely).
*******************************************************************************/

#include "headers.h"



#if _DEBUG

// Right now this stuff is only used for debugging purposes.

#include "privinc/util.h"



int CRC32Table [256] =
{
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
    0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
    0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
    0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
    0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
    0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,

    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
    0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
    0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
    0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
    0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
    0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
    0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,

    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
    0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
    0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
    0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
    0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
    0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,

    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
    0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
    0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
    0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
    0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
    0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};



/*****************************************************************************
This routine takes a buffer and calculates the new or running 32-bit CRC code.
*****************************************************************************/

unsigned int crc32 (void *buffer, size_t length, unsigned int curr_val)
{
    // The incoming CRC value is inverted to handle intermediate values that
    // have been inverted before return.  Ultimately, the final is inverted
    // as the final step, though I'm not sure why.  I do it here to be faithful
    // to other CRC implementations (in case it matters).

    unsigned int  crc = ~curr_val;
    char         *ptr = (char*) buffer;

    while (length--)
    {   crc = ((crc >> 8) & 0xffffff) ^ CRC32Table [(crc ^ *ptr) & 0xff];
        ++ptr;
    }

    return ~crc;
}


#endif    // Debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\ddsurf.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

     DDSurface implementation.  A utility class to wrap and provide
     functionality for DirectDraw surfaces.

*******************************************************************************/


#include "headers.h"

#include "ddraw.h"
#include "privinc/ddsurf.h"
#include "privinc/viewport.h"




GenericSurface::GenericSurface() :
     _ref(1) // start with a ref of 1
{
}


RECT *GDISurface::GetSurfRect(void)
{
    _surfRect.left = 0;
    _surfRect.top = 0;

    HBITMAP hBitmap = (HBITMAP) GetCurrentObject(_targetDC,OBJ_BITMAP);
    SIZE    dimension;
    if (GetBitmapDimensionEx(hBitmap,&dimension)) {
        _surfRect.right = dimension.cx;
        _surfRect.bottom = dimension.cy;
    } else {
        Assert(FALSE && "GDISurface::GetSurfRect() cannot get the bitmap's dimensions");
        _surfRect.right = 0;
        _surfRect.bottom = 0;
    }

    return &_surfRect;
}


DDSurface::DDSurface(
    IDDrawSurface *surface,
    const Bbox2 &box,
    RECT *rect,
    Real res,
    DWORD colorKey,
    bool colorKeyIsValid,
    bool isWrapper,
    bool isTexture
    DEBUG_ARG1(char *explanation))
{
    _Init(surface, box, rect,
          res, colorKey, colorKeyIsValid,
          isWrapper, isTexture);

    #if _DEBUG
    //
    // DEBUG ONLY CODE
    //

    _explanation = explanation;
    Assert(_explanation);

    DDSURFACEDESC desc;  desc.dwSize=sizeof(desc);
    desc.dwFlags = DDSD_PITCH;
    _ddrval = IDDSurface()->GetSurfaceDesc(&desc);
    if(!_isWrapper) {

        bool dontCreateOne = true;
        DirectDrawViewport *vp = GetCurrentViewport( dontCreateOne );

        //Assert((vp != NULL) || IsInitializing());

        if (vp)
        {
#ifdef _DEBUGSURFACE
            vp ->Tracker()->NewSurface(this);
#endif /* _DEBUGSURFACE */
            
            TraceTag((tagViewportMemory,
                      " ------>>>DDSurface: %x created %s memory surf=%x for %x. size=(%d,%d,  %d)",
                      this,
                      IsSystemMemory() ? "system" : "video",
                      _ddsurf.p,
                      _explanation,
                      Width(), Height(),
                      desc.lPitch * Height()));
        }
    }
    #endif // _DEBUG
}

    

// called on construction
void DDSurface::_Init(
    IDDrawSurface *surface,
    const Bbox2 &box,
    RECT *rect,
    Real res,
    DWORD colorKey,
    bool colorKeyIsValid,
    bool isWrapper,
    bool isTexture)
{
    _capsReady = false;
    _res = res;

    SetSurfaceType(GenericSurface::ddrawSurface);

    SetSurfacePtr(surface);

    SetConvertedSurface(NULL);
    SetZBuffer(NULL);

    _dc = NULL;
    _dcRef = 0;
    _isWrapper = isWrapper;
    _associatedGeomDev = NULL;
    _isTextureSurf = isTexture;

    if(box != NullBbox2) {
        _bbox.min = box.min;
        _bbox.max = box.max;
    } else {
        _bbox.min.Set(0,0);
        _bbox.max.Set(0,0);
    }

    SetSurfRect(rect);
    SetInterestingSurfRect(rect);

    _colorKey = colorKey;
    _colorKeyIsValid = colorKeyIsValid;

/*
    // TODO ...the below code show be used instead of above code.

    if(colorKeyIsValid) {
        SetColorKey(colorKey);
    }
*/
    _timeStamp = -HUGE_VAL;
}


void DDSurface::_UpdateSurfCaps(void)
{
    Assert(IDDSurface());
    //
    // Get surface caps
    //
    DDSCAPS ddscaps = { 0 };
    _ddrval = IDDSurface()->GetCaps(&ddscaps);
    IfDDErrorInternal(_ddrval, "Couldn't get caps on surface");
    _systemMemorySurface = ddscaps.dwCaps & DDSCAPS_SYSTEMMEMORY ? true : false;
    _isZBufferSurface = ddscaps.dwCaps & DDSCAPS_ZBUFFER ? true : false;

    //
    // Get surface desc
    //

    DDSURFACEDESC desc;
    desc.dwSize = sizeof(desc);
    desc.dwFlags = 0;
    _ddrval = IDDSurface()->GetSurfaceDesc(&desc);
    IfDDErrorInternal(_ddrval, "Couldn't get the surface description");
    Assert((desc.dwFlags & (DDSD_HEIGHT|DDSD_WIDTH)) == (DDSD_HEIGHT|DDSD_WIDTH));
    if ((desc.dwFlags & (DDSD_HEIGHT|DDSD_WIDTH)) == (DDSD_HEIGHT|DDSD_WIDTH))
    {   
        RECT r;  
        SetRect( &r, 0, 0, desc.dwWidth, desc.dwHeight );
        SetSurfRect(&r);

        Bbox2 destBox;
        RectToBbox(desc.dwWidth, desc.dwHeight,destBox,Resolution());
        SetBbox(destBox);

    }
    
    ZeroMemory(&_pixelFormat, sizeof(_pixelFormat));
    _pixelFormat.dwSize = sizeof(_pixelFormat);
    
    if (desc.dwFlags & DDSD_PIXELFORMAT) {
        _pixelFormat = desc.ddpfPixelFormat;
    }
    else {
        _ddrval = IDDSurface()->GetPixelFormat(&_pixelFormat);
    }
    
    _capsReady = true;
}

void DDSurface::_MakeSureIDXSurface(IDXSurfaceFactory *sf)
{
    if( !_IDXSurface ) {
        // do the creation.
        HRESULT hr;

        Assert( GetPixelFormat().dwRGBBitCount == 32 );
        
        hr = CreateFromDDSurface(sf, this, &DDPF_PMARGB32, &_IDXSurface);

        if( FAILED(hr) ) {
            // Since we failed the first attempt try again but without a pixel format.
            hr = CreateFromDDSurface(sf, this, NULL, &_IDXSurface);
        }
        
        if( FAILED(hr) ) {
            RaiseException_InternalError("Create IDXSurface from DDSurface failed");
        }
    }
    Assert( _IDXSurface );
}

DDSurface::~DDSurface()
{
    Assert((_dcRef == 0) && "Bad ref on DDSurface destruction");

    if(!_isWrapper)
        DestroyGeomDevice();

    Assert(_ddsurf.p);

    if(!_isWrapper)
        _ddsurf->SetClipper (NULL);

    // purposely NOT releaseing videoReader because movieImage owns it
    // and is responsible for detroying it.
    
    TraceTag((tagViewportMemory,
              " <<<-----DDSurface: %x destroyed %s memory %ssurf=%x",
              this,
              IsSystemMemory() ? "system" : "video",
              IsZBuffer() ? "zbuffer " : "",
              _ddsurf.p));

    #if _DEBUGSURFACE
    if( !_isWrapper ) {
        DirectDrawViewport *vp = GetCurrentViewport();

        Assert((vp != NULL) || IsInitializing());
        
        if (vp)
            vp->Tracker()->DeleteSurface(this);
    }
    #endif
}


HDC DDSurface::GetDC(char *errStr)
{
    Assert(_ddsurf.p);
    if(_dcRef <= 0) {
        _ddrval = _ddsurf->GetDC(&_dc);
        if( _ddrval == DDERR_SURFACELOST ) {
            _ddrval = _ddsurf->Restore();
            if( SUCCEEDED( _ddrval ) ) // try again
                _ddrval = _ddsurf->GetDC(&_dc);         
        }
        IfDDErrorInternal(_ddrval, errStr);
    }
        
    _dcRef++;
    return _dc;
}

void DDSurface::ReleaseDC(char *errStr)
{
                       
    Assert( (_dcRef > 0) && "Bad _dcRef in DDSurface class");

    _dcRef--;
    _ddrval = DD_OK;
        
    Assert(_ddsurf.p);
    if(_dcRef <= 0) {
        _ddrval = _ddsurf->ReleaseDC(_dc);
        if( _ddrval == DDERR_SURFACELOST ) {
            _ddrval = _ddsurf->Restore();
        }
        _dc = NULL;
    }
        
    IfDDErrorInternal(_ddrval, errStr);
}
    
void DDSurface::_hack_ReleaseDCIfYouHaveOne()
{
    if( _dc ) {
        Assert(_dcRef>0);
        _ddrval = _ddsurf->ReleaseDC(_dc);
        _dc = NULL;
        _dcRef = 0;
    }
}
    
HRESULT DDSurface::SetZBuffer(DDSurface *zb)
{
    _zbuffer = zb;
    if(zb) {
        Assert(zb->Width() == Width()  && "DDSurface::SetZBuffer: diff width");
        Assert(zb->Height() == Height()&& "DDSurface::SetZBuffer: diff height");
        Assert(zb->IsZBuffer() && "SetZBuffer: surface must be zuffer");
        _ddrval = IDDSurface()->AddAttachedSurface( zb->IDDSurface() );
    }
    return _ddrval;
}

void DDSurface::DestroyGeomDevice()
{                       
    TraceTag((tagViewportMemory,
              "DDSurf %x: destroying geomDevice %x",
              this, GeomDevice()));
    delete GeomDevice();
    SetGeomDevice( NULL );
}
        
void DDSurface::UnionInterestingRect(RECT *rect)
{
    // make sure we're in the surface's bounds
    RECT intRect;
    IntersectRect(&intRect, &_surfRect, rect);
    
    // now union that rect with the current interesting rect
    UnionRect( &_interestingRect, &_interestingRect, &intRect );
}    


HRGN DDSurface::GetClipRgn()
{
    //
    // Look in the surface for a current clipper
    //
    LPDIRECTDRAWCLIPPER currClipp;
    HRESULT hr = IDDSurface()->GetClipper( &currClipp );
    if( FAILED(hr) ) {
        return NULL;
    }

    Assert( currClipp );
    
    //
    // Now grab the rectangle...
    //
    DWORD sz=0;
    currClipp->GetClipList(NULL, NULL, &sz);
    Assert(sz != 0);
        
    char *foo = THROWING_ARRAY_ALLOCATOR(char, sizeof(RGNDATA) + sz);
    RGNDATA *lpClipList = (RGNDATA *) ( &foo[0] );
    hr = currClipp->GetClipList(NULL, lpClipList, &sz);
    if(hr != DD_OK) return NULL;

    HRGN rgn = ExtCreateRegion(NULL, sz, lpClipList);
    delete foo;
    return rgn;
}

void DDSurface::SetBboxFromSurfaceDimensions(
    const Real res,
    const bool center)
{
    Assert( center == true );
    RectToBbox(Width(), Height(), _bbox, Resolution());
}

// DX3 ddraw's SetColorKey contains an uninitialized stack var which
// causes the surface to be randomly trashed if you try to disable
// colorkeying using SetColorKey(..,NULL)  (manbug 7462)
// Soln is to pre-init some stack space to 0, skip ddrawex's SetColorKey
// and call ddraw's SetColorKey directly to avoid any extra fns ddrawex might call
// which would mess up our freshly-zeroed stack.   (see qbug 32172)

void ZeroJunkStackSpace() {
    DWORD junk[32];

    ZeroMemory(junk,sizeof(junk));
}

void DDSurface::UnSetColorKey()
{
    HRESULT hr;

    _colorKeyIsValid = FALSE;

   if(sysInfo.VersionDDraw() <= 3) {
       IDirectDrawSurface *pDDS = this->IDDSurface();
       ZeroJunkStackSpace();
       hr = pDDS->SetColorKey(DDCKEY_SRCBLT, NULL);
   } else hr=_ddsurf->SetColorKey(DDCKEY_SRCBLT, NULL);

    if (FAILED(hr)) {
        Assert(!"UnSetting color key on ddsurf failed");
    }
}

void DDSurface::SetColorKey(DWORD key)
{
    Assert( _capsReady );

    // FIRST: take out alpha if it exists!  This is a color key.
    // color keys' alpha is always 0
    key = key & ~GetPixelFormat().dwRGBAlphaBitMask;
    
    DWORD oldCK = _colorKey;
    bool oldValid = _colorKeyIsValid;

    _colorKey = key;
    _colorKeyIsValid = TRUE;
        
    // Set on the ddraw surface itself, but only if we didn't last
    // set it to the same thing.

    if ((!oldValid || oldCK != _colorKey) &&
        _surfaceType == ddrawSurface && _ddsurf.p) {
            
        DDCOLORKEY ckey;

        ckey.dwColorSpaceLowValue = _colorKey;
        ckey.dwColorSpaceHighValue = _colorKey;

        HRESULT hr;

        THR( hr = _ddsurf->SetColorKey(DDCKEY_SRCBLT, &ckey) );
    }
}

HRESULT CreateFromDDSurface(
    IDXSurfaceFactory *sf,
    DDSurface *dds,
    const GUID *pFormatID,
    IDXSurface **outDXSurf )
{
    return sf->CreateFromDDSurface(
        dds->IDDSurface_IUnk(),
        pFormatID,
        0,
        NULL,
        IID_IDXSurface,
        (void **)outDXSurf);
}    

HRESULT DDSurface::MirrorUpDown(void)
{
    // take any clippers off of the surface
    LPDIRECTDRAWCLIPPER pClipper = NULL;
    if (IDDSurface()->GetClipper(&pClipper) == S_OK) {
        IDDSurface()->SetClipper(NULL);
    }

    // mirror the surface upside-down
    DDBLTFX bltfx;
    ZeroMemory(&bltfx, sizeof(DDBLTFX));
    bltfx.dwSize = sizeof(bltfx);
    bltfx.dwDDFX = DDBLTFX_MIRRORUPDOWN;
    HRESULT hr = Blt(NULL,this,NULL,DDBLT_WAIT | DDBLT_DDFX,&bltfx);
    Assert(SUCCEEDED(hr));

    // put clipper back, if we took it off
    if (pClipper) {
        IDDSurface()->SetClipper(pClipper);
        pClipper->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\helpdm.cpp ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\ddutil.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All Rights Reserved.

    Routines for loading bitmap and palettes from resources
*******************************************************************************/

#include "headers.h"

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <windowsx.h>
#include <ddraw.h>
#include <privinc/ddutil.h>

#include "appelles/common.h"
#include "privinc/error.h"
#include "privinc/hresinfo.h"
#include "privinc/util.h"
#include "privinc/ddsurf.h"


/*****************************************************************************
Draw a bitmap into a DirectDrawSurface.
*****************************************************************************/

HRESULT DDCopyBitmap (
    IDDrawSurface *pdds,     // Destination DirectDraw Surface
    HBITMAP        hbm,      // Source Bitmap
    int            x,
    int            y,
    int            dx,       // Destination Width;  If Zero use Bitmap Width
    int            dy)       // Destination Height; If Zero use Bitmap Height
{
    HDC           hdcImage;
    HDC           hdc;
    BITMAP        bm;
    DDSURFACEDESC ddsd;
    HRESULT       hr;

    if (hbm == NULL || pdds == NULL)
        return E_FAIL;

    //
    // make sure this surface is restored.
    //
    pdds->Restore();

    //
    //  select bitmap into a memoryDC so we can use it.
    //
    hdcImage = CreateCompatibleDC(NULL);
    SelectObject(hdcImage, hbm);

    //
    // get size of the bitmap
    //
    GetObject(hbm, sizeof(bm), &bm);    // get size of bitmap
    dx = dx == 0 ? bm.bmWidth  : dx;    // use the passed size, unless zero
    dy = dy == 0 ? bm.bmHeight : dy;

    //
    // get size of surface.
    //
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_HEIGHT | DDSD_WIDTH;
    pdds->GetSurfaceDesc(&ddsd);

    if ((hr = pdds->GetDC(&hdc)) == DD_OK)
    {
        StretchBlt (hdc, 0, 0, ddsd.dwWidth, ddsd.dwHeight,
                    hdcImage, x, y, dx, dy, SRCCOPY);
        pdds->ReleaseDC(hdc);
    }

    DeleteDC(hdcImage);

    return hr;
}



/*****************************************************************************
Convert a RGB color to a pysical color.

We do this by leting GDI SetPixel() do the color matching, then we lock the
memory and see what it got mapped to.
*****************************************************************************/

DWORD DDColorMatch (IDDrawSurface *pdds, COLORREF rgb)
{
    COLORREF rgbT;
    HDC hdc;
    DWORD dw = CLR_INVALID;
    DDSURFACEDESC ddsd;
    HRESULT hres;

    //
    //  use GDI SetPixel to color match for us
    //
    if (rgb != CLR_INVALID && pdds->GetDC(&hdc) == DD_OK)
    {
        rgbT = GetPixel(hdc, 0, 0);             // save current pixel value
        SetPixel(hdc, 0, 0, rgb);               // set our value
        pdds->ReleaseDC(hdc);
    }

    //
    // now lock the surface so we can read back the converted color
    //
    ddsd.dwSize = sizeof(ddsd);
    while ((hres = pdds->Lock(NULL, &ddsd, 0, NULL)) == DDERR_WASSTILLDRAWING)
        ;

    if (hres == DD_OK)
    {
        DWORD mask;
        dw = *(DWORD *)ddsd.lpSurface;                     // get DWORD

        if(ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8) {
            mask = 0xff;
        } else {
            mask = ddsd.ddpfPixelFormat.dwRBitMask |
                   ddsd.ddpfPixelFormat.dwGBitMask |
                     ddsd.ddpfPixelFormat.dwBBitMask |
                     ddsd.ddpfPixelFormat.dwRGBAlphaBitMask;
        }

        pdds->Unlock(NULL);
        #if _DEBUG
        if( !((ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8) ||
              (ddsd.ddpfPixelFormat.dwRGBBitCount == 16) ||
              (ddsd.ddpfPixelFormat.dwRGBBitCount == 24) ||
              (ddsd.ddpfPixelFormat.dwRGBBitCount == 32))
           )
        {
            Assert(FALSE && "unsupported bit depth in DDColorMatch");
        }
        #endif

        dw = dw & mask; // mask it to bpp
    }

    //
    //  now put the color that was there back.
    //
    if (rgb != CLR_INVALID && pdds->GetDC(&hdc) == DD_OK)
    {
        SetPixel(hdc, 0, 0, rgbT);
        pdds->ReleaseDC(hdc);
    }

    return dw;
}



/*****************************************************************************
Print out the information associated with a given HRESULT.
*****************************************************************************/

void reallyPrintDDError (HRESULT ddrval
    #if DEVELOPER_DEBUG
        , char const *filename,
        int lineNum
    #endif
    )
{
    #if DEVELOPER_DEBUG
        HresultInfo *info = GetHresultInfo (ddrval);

        if (info && info->hresult) {
            char str[1024];
            sprintf(str, "DirectAnimation DDRAW Err: %s (%x) in %s (line %d)\n",
                    info->hresult_str, ddrval, filename, lineNum);
            printf("%s",str);

            OutputDebugString(str);
        }
    #endif
}



/*****************************************************************************
Given the number of bits per pixel, return the DirectDraw DDBD_ value.
*****************************************************************************/

int BPPtoDDBD (int bitsPerPixel)
{
    switch (bitsPerPixel)
    {   case  1: return DDBD_1;
        case  2: return DDBD_2;
        case  4: return DDBD_4;
        case  8: return DDBD_8;
        case 16: return DDBD_16;
        case 24: return DDBD_24;
        case 32: return DDBD_32;
        default: return 0;
    }
}

void GetSurfaceSize(IDDrawSurface *surf,
                    LONG *width,
                    LONG *height)
{
    Assert(surf && "null surface in GetSurfaceSize");
    DDSURFACEDESC ddsd;
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_HEIGHT | DDSD_WIDTH;
    if( surf->GetSurfaceDesc(&ddsd) != DD_OK ) {
        RaiseException_InternalError("GetSurfaceDesc failed in GetSurfaceSize");
    }
    *width = ddsd.dwWidth;
    *height = ddsd.dwHeight;
}



IDirectDrawSurface *DDSurf2to1(IDirectDrawSurface2 *dds2)
{
    IDirectDrawSurface *dds1 = NULL;
    HRESULT hr = dds2->QueryInterface(IID_IDirectDrawSurface, (void **) &dds1);
    IfDDErrorInternal(hr, "Can't QI for IDirectDrawSurface from IDirectDrawSurface2");

    return dds1;
}

IDirectDrawSurface2 *DDSurf1to2(IDirectDrawSurface *dds1)
{
    IDirectDrawSurface2 *dds2 = NULL;
    HRESULT hr = dds1->QueryInterface(IID_IDirectDrawSurface2, (void **) &dds2);
    IfDDErrorInternal(hr, "Can't QI for IDirectDrawSurface2 from IDirectDrawSurface");

    return dds2;
}

//////////////////////// Depth Converters ///////////////////////


DWORD GetDDUpperLeftPixel(LPDDRAWSURFACE surf)
{
    DWORD pixel;
    DDSURFACEDESC ddsd;
    ddsd.dwSize = sizeof(ddsd);
    HRESULT _ddrval = surf->Lock(NULL, &ddsd, 0, NULL);
    IfDDErrorInternal(_ddrval, "Couldn't lock surf in GetDDPixel");

    switch (ddsd.ddpfPixelFormat.dwRGBBitCount) {
      case 8:
        pixel = *((BYTE *)ddsd.lpSurface);
        break;
      case 16:
        pixel = *((WORD *)ddsd.lpSurface);
        break;
      case 24:
        {
            BYTE *surfPtr = ((BYTE *)ddsd.lpSurface);
            BYTE byte1 = *surfPtr++;
            BYTE byte2 = *surfPtr++;
            BYTE byte3 = *surfPtr;
            pixel = byte1 << 16 | byte2 << 8 | byte3;
        }
        break;
      case 32:
        pixel = *((DWORD *)ddsd.lpSurface);
        break;
    }
    surf->Unlock(ddsd.lpSurface);
    return pixel;
}


void
SetDDUpperLeftPixel(LPDDRAWSURFACE surf, DWORD pixel)
{
    DDSURFACEDESC ddsd;
    ddsd.dwSize = sizeof(ddsd);
    HRESULT _ddrval = surf->Lock(NULL, &ddsd, 0, NULL);
    IfDDErrorInternal(_ddrval, "Couldn't lock surf16 in conv16to32");

    switch (ddsd.ddpfPixelFormat.dwRGBBitCount) {
      case 8:
        *((BYTE *)ddsd.lpSurface) = (BYTE)(pixel);
        break;
      case 16:
        *((WORD *)ddsd.lpSurface) = (WORD)(pixel);
        break;
      case 24:
        {
            // Write 3 bytes in for the 24bit case
            BYTE *surfPtr = ((BYTE *)ddsd.lpSurface);
            *surfPtr++ = (BYTE)(pixel >> 16);
            *surfPtr++ = (BYTE)(pixel >> 8);
            *surfPtr = (BYTE)(pixel);
        }
        break;
      case 32:
        *((DWORD *)ddsd.lpSurface) = (DWORD)(pixel);
        break;
    }

    surf->Unlock(ddsd.lpSurface);
}


static void
SetAlphaBitsOn32BitSurface(IDirectDrawSurface *surf,
                           int width,
                           int height)
{
    // Treat RGBQUAD as a DWORD, since comparisons between DWORDS are
    // legal, but comparisons between RGBQUADS are not.  Only do it if
    // we know these are the same size.
    Assert(sizeof(RGBQUAD) == sizeof(DWORD));

    HRESULT hr;

    // Lock ddsurface
    DDSURFACEDESC desc;
    desc.dwSize = sizeof(DDSURFACEDESC);
    hr = surf->Lock(NULL,
                    &desc,
                    DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR,
                    NULL);

    IfDDErrorInternal(hr,
                      "Can't Get ddsurf lock for SetAlphaBitsOn32BitSurface");

    void *srcp = desc.lpSurface; // needed for unlock

    if (desc.ddpfPixelFormat.dwRGBBitCount == 32) {
        long pitch = desc.lPitch;

        // First pixel is the color key.  Stash it off.
        DWORD colorKeyVal = *(DWORD *)srcp;

        // Go through each pixel
        for(int i=0; i<height; i++) {
            DWORD *src =  (DWORD *) ((unsigned char *)srcp + (pitch * i));
            DWORD *last = src + width;
            while (src < last) {
                // Set the alpha byte to 0xff for the non-colorkey pixels.
                if (*src != colorKeyVal) {
                    ((RGBQUAD *)src)->rgbReserved  = 0xff;
                }
                src++;
            }
        }
    }

    hr = surf->Unlock(srcp);
    IfDDErrorInternal(hr,
                      "ddsurf unlock failed in SetAlphaBitsOn32BitSurface");
}

void
PixelFormatConvert(IDirectDrawSurface *srcSurf,
                   IDirectDrawSurface *dstSurf,
                   LONG width,
                   LONG height,
                   DWORD *sourceColorKey, // NULL if no color key
                   bool writeAlphaChannel)
{
    HDC srcDC = NULL;
    HDC dstDC = NULL;
    HRESULT hr;

    // Stash the color key off in the upper left hand pixel.  This
    // does alter the source image, but may be the only way to figure
    // out what the color key is in the converted image.  Other way
    // would be to search for the color key, but that would be quite
    // expensive.

    if (sourceColorKey) {
        SetDDUpperLeftPixel(srcSurf,
                            *sourceColorKey);
    }

    hr = srcSurf->GetDC(&srcDC);
    IfDDErrorInternal(hr, "Couldn't grab DC on srcSurf");

    hr = dstSurf->GetDC(&dstDC);
    IfDDErrorInternal(hr, "Couldn't grab DC on dstSurf");

    int ret;
    TIME_GDI(ret= BitBlt(dstDC, 0, 0, width, height,
                         srcDC,  0, 0,
                         SRCCOPY));

    Assert(ret && "BitBlt failed");

    if (dstDC) dstSurf->ReleaseDC(dstDC);
    if (srcDC) srcSurf->ReleaseDC(srcDC);

    if (writeAlphaChannel) {
        // This will be a no-op on non-32 bit surfaces.
        SetAlphaBitsOn32BitSurface(dstSurf, width, height);
    }

    if (sourceColorKey) {
        DWORD pix = GetDDUpperLeftPixel(dstSurf);
        DDCOLORKEY ck;
        ck.dwColorSpaceLowValue = pix;
        ck.dwColorSpaceHighValue = pix;
        hr = dstSurf->SetColorKey(DDCKEY_SRCBLT, &ck);
        if (FAILED(hr)) {
            Assert("Setting color key on dstSurf failed");
            return;
        }
    }

    // TODO: What about palettes on 8-bit surfaces???
}


/*****************************************************************************
Hacked workaround for Permedia cards, which have a primary pixel format
with alpha per pixel.  If we're in 16-bit, then we need to set the alpha
bits to opaque before using the surface as a texture.  For some reason,
an analogous hack for 32-bit surfaces has no effect on Permedia hardware
rendering, so we rely on hardware being disabled for such a scenario.
*****************************************************************************/

void SetSurfaceAlphaBitsToOpaque(IDirectDrawSurface *imsurf,
                                 DWORD colorKey,
                                 bool keyIsValid)
{
    DDSURFACEDESC surfdesc;
    surfdesc.dwSize = sizeof(surfdesc);

    DWORD descflags = DDSD_PIXELFORMAT | DDSD_WIDTH | DDSD_HEIGHT | DDSD_PITCH;
    surfdesc.dwFlags = descflags;

    if (  SUCCEEDED (imsurf->GetSurfaceDesc(&surfdesc))
       && ((surfdesc.dwFlags & descflags) == descflags)
       && (surfdesc.ddpfPixelFormat.dwRGBBitCount == 16)
       && !((surfdesc.ddpfPixelFormat.dwRBitMask |
             surfdesc.ddpfPixelFormat.dwGBitMask |
             surfdesc.ddpfPixelFormat.dwBBitMask) & 0x8000)
       && SUCCEEDED (imsurf->Lock (NULL,&surfdesc,
                                   DDLOCK_NOSYSLOCK|DDLOCK_SURFACEMEMORYPTR,
                                   NULL))
       )
    {
        char *line = (char*) surfdesc.lpSurface;
        unsigned int linesrem = surfdesc.dwHeight;

        WORD rgbMask = surfdesc.ddpfPixelFormat.dwRBitMask
                     | surfdesc.ddpfPixelFormat.dwGBitMask
                     | surfdesc.ddpfPixelFormat.dwBBitMask;

        WORD alphaMask = surfdesc.ddpfPixelFormat.dwRGBAlphaBitMask;

        if (keyIsValid)
        {
            // If we're color-keying the texture, then we need to set the alpha
            // to transparent for all pixels whose color matches the color key.
            // If the color does *not* match the key, then we just set the
            // alpha bits to opaque.

            while (linesrem--)
            {
                WORD *ptr = (WORD*) line;
                unsigned int linepixels = surfdesc.dwWidth;

                while (linepixels--)
                {
                    if ((*ptr & rgbMask) == colorKey)
                        *ptr &= rgbMask;
                    else
                        *ptr |= alphaMask;
                    ++ptr;
                }
                line += surfdesc.lPitch;
            }
        }
        else
        {
            // This surface has no color keyed transparency, so we just set the
            // alpha bits to fully opaque.

            while (linesrem--)
            {
                WORD *ptr = (WORD*) line;
                unsigned int linepixels = surfdesc.dwWidth;

                while (linepixels--)
                    *ptr++ |= alphaMask;

                line += surfdesc.lPitch;
            }
        }

        imsurf->Unlock (NULL);
    }
}




// this function is used for caching alpha.  the problem is some
// primitives are not alpha aware and leave the alpha byte untouched,
// while dx2d IS alpha aware and write the proper values into the
// alpha byte.  When we use dx2d to do an alpha aware compose of this
// surface to some other surface (A blend) we want the dx2d prims to
// show up properly (with aa and stuff) AND the non-alpha-aware prims
// to show up fully opaque also.
// So we need a way to make the non-alpha-aware prims visible while
// preserving the dx2d drawn pixels.  We decided to fill the surface
// with a color key that looks something like  0x01xxxxxxx.
// If the color key exists in that form on the surface, the alpha byte
// is set to 0.  If the pixel is NOT the color key AND has a 0x01 in
// the alpha byte we consider that pixel to be a non-alpha aware
// pixel.
// the only problem is we run the risk of making a legit dx2d partly
// transparent pixel (1 out of 256) fully opaque.  which looks weird.
void SetSurfaceAlphaBitsToOpaque(IDirectDrawSurface *imsurf,
                                 DWORD fullClrKey)
{
    DDSURFACEDESC surfdesc;
    surfdesc.dwSize = sizeof(surfdesc);

    DWORD descflags =
        DDSD_PIXELFORMAT |
        DDSD_WIDTH | DDSD_HEIGHT |
        DDSD_PITCH | DDSD_LPSURFACE;
    surfdesc.dwFlags = descflags;

    HRESULT hr = imsurf->Lock(NULL,&surfdesc,DDLOCK_SURFACEMEMORYPTR,NULL);
    if( SUCCEEDED ( hr ) ) 
    {
        char *line = (char*) surfdesc.lpSurface;
        unsigned int linesrem = surfdesc.dwHeight;

        DWORD rgbMask = surfdesc.ddpfPixelFormat.dwRBitMask
                     | surfdesc.ddpfPixelFormat.dwGBitMask
                     | surfdesc.ddpfPixelFormat.dwBBitMask;

        DWORD alphaMask = 0xff000000;

        // this is the key to differentiate between those pixels
        // written by dx2d and those written by non-alpha aware prims
        DWORD alphaKey = fullClrKey & alphaMask;

        {
            // If we're color-keying the texture, then we need to set the alpha
            // to transparent for all pixels whose color matches the color key.
            // If the color does *not* match the key, then we just set the
            // alpha bits to opaque.

            while (linesrem--)
            {
                DWORD *ptr = (DWORD*) line;
                unsigned int linepixels = surfdesc.dwWidth;

                while (linepixels--)
                {
                    if ((*ptr) == fullClrKey)
                        *ptr &= rgbMask;  // make fully transparent
                    else if( !((*ptr) & alphaMask) ) //|| ((*ptr) & alphaKey) )
                        *ptr |= alphaMask; // make fully opaque
                    ++ptr;
                }
                line += surfdesc.lPitch;
            }
        }
        imsurf->Unlock (NULL);
    }
}



// ===========================================================================
// ====================  D E B U G   F U N C T I O N S  ======================
// ===========================================================================

#if _DEBUG

/*****************************************************************************
This function computes the total and color-only CRC's for a given palette.
*****************************************************************************/

void PalCRCs (
    PALETTEENTRY  entries[],   // Palette Entries
    unsigned int &crc_total,   // CRC of all of Palette
    unsigned int &crc_color)   // CRC of Color Fields
{
    crc_color = 0;

    for (int i=0;  i < 256;  ++i)
        crc_color = crc32 (&entries[i], 3, crc_color);

    crc_total = crc32 (entries, 256 * sizeof(entries[0]));
}



/*****************************************************************************
Dump information about the given palette to the output debug stream.
*****************************************************************************/

void dumppalentries (PALETTEENTRY entries[])
{
    char buffer[128];

    strcpy (buffer, "    Palette Entries:");
    char *buffend = buffer + strlen(buffer);
    unsigned int entry = 0;
    unsigned int col = 99;

    while (entry < 256)
    {
        if (col >= 8)
        {   strcpy (buffend, "\n");
            OutputDebugString (buffer);
            sprintf (buffer, "    %02x:", entry);
            buffend = buffer + strlen(buffer);
            col = 0;
        }

        sprintf (buffend, " %02x%02x%02x%02x",
            entries[entry].peRed, entries[entry].peGreen,
            entries[entry].peBlue, entries[entry].peFlags);

        ++col;
        ++entry;
        buffend += strlen(buffend);
    }

    strcat (buffer, "\n");
    OutputDebugString (buffer);

    unsigned int crcTotal, crcColor;

    PalCRCs (entries, crcTotal, crcColor);

    sprintf (buffer, "    palette crc %08x (color %08x)\n", crcTotal, crcColor);
    OutputDebugString (buffer);
}



/*****************************************************************************
Dump information about the given palette to the output debug stream.
*****************************************************************************/

void dumpddpal (LPDIRECTDRAWPALETTE palette)
{
    char buffer[128];
    PALETTEENTRY entries[256];
    HRESULT hres = palette->GetEntries (0, 0, 256, entries);

    if (FAILED (hres))
    {   sprintf (buffer, "    GetEntries on palette failed %x\n", hres);
        OutputDebugString (buffer);
        return;
    }

    dumppalentries (entries);
}



/*****************************************************************************
This function is intended to be called directly from the debugger to print out
information about a given DDraw surface.
*****************************************************************************/

void surfinfo (IDDrawSurface *surf)
{
    char buffer[128];

    OutputDebugString ("\n");

    sprintf (buffer, "Info Dump of Surface %p\n", surf);
    OutputDebugString (buffer);

    DDSURFACEDESC desc;
    HRESULT hres;

    desc.dwSize = sizeof(desc);
    desc.dwFlags = 0;

    if (FAILED (surf->GetSurfaceDesc(&desc)))
        return;

    if (desc.dwFlags & DDSD_CAPS)
    {
        static struct { DWORD value; char *string; } capsTable[] =
        {
            { DDSCAPS_ALPHA,              " alpha"              },
            { DDSCAPS_BACKBUFFER,         " backbuffer"         },
            { DDSCAPS_COMPLEX,            " complex"            },
            { DDSCAPS_FLIP,               " flip"               },
            { DDSCAPS_FRONTBUFFER,        " frontbuffer"        },
            { DDSCAPS_OFFSCREENPLAIN,     " offscreenplain"     },
            { DDSCAPS_OVERLAY,            " overlay"            },
            { DDSCAPS_PALETTE,            " palette"            },
            { DDSCAPS_PRIMARYSURFACE,     " primarysurface"     },
            { DDSCAPS_SYSTEMMEMORY,       " systemmemory"       },
            { DDSCAPS_TEXTURE,            " texture"            },
            { DDSCAPS_3DDEVICE,           " 3ddevice"           },
            { DDSCAPS_VIDEOMEMORY,        " videomemory"        },
            { DDSCAPS_VISIBLE,            " visible"            },
            { DDSCAPS_WRITEONLY,          " writeonly"          },
            { DDSCAPS_ZBUFFER,            " zbuffer"            },
            { DDSCAPS_OWNDC,              " owndc"              },
            { DDSCAPS_LIVEVIDEO,          " livevideo"          },
            { DDSCAPS_HWCODEC,            " hwcodec"            },
            { DDSCAPS_MODEX,              " modex"              },
            { DDSCAPS_MIPMAP,             " mipmap"             },
            { DDSCAPS_ALLOCONLOAD,        " alloconload"        },
            { 0, 0 }
        };

        sprintf (buffer, "DDSCAPS[%08x]:", desc.ddsCaps.dwCaps);

        for (int i=0;  capsTable[i].value;  ++i)
        {   if (desc.ddsCaps.dwCaps & capsTable[i].value)
                strcat (buffer, capsTable[i].string);
        }

        strcat (buffer, "\n");

        OutputDebugString (buffer);
    }

    if ((desc.dwFlags & (DDSD_HEIGHT|DDSD_WIDTH)) == (DDSD_HEIGHT|DDSD_WIDTH))
    {   sprintf (buffer, "Size %d x %d\n", desc.dwWidth, desc.dwHeight);
        OutputDebugString (buffer);
    }

    if (desc.dwFlags & DDSD_ALPHABITDEPTH)
    {   sprintf (buffer, "AlphaBitDepth %d\n", desc.dwAlphaBitDepth);
        OutputDebugString (buffer);
    }

    bool palettized = false;

    if (desc.dwFlags & DDSD_PIXELFORMAT)
    {
        DDPIXELFORMAT pf = desc.ddpfPixelFormat;

        sprintf (buffer, "Pixel Format: flags %08x", pf.dwFlags);

        if (pf.dwFlags & DDPF_FOURCC)
        {   int cc = pf.dwFourCC;
            strcat (buffer, ", fourCC ");
            char *end = buffer + strlen(buffer);
            *end++ = (cc >> 24) & 0xFF;
            *end++ = (cc >> 16) & 0xFF;
            *end++ = (cc >>  8) & 0xFF;
            *end++ = cc & 0xFF;
            *end = 0;
        }

        if (pf.dwFlags & DDPF_RGB)
        {   sprintf (buffer+strlen(buffer), ", %d-bit RGB (%x %x %x)",
                pf.dwRGBBitCount, pf.dwRBitMask, pf.dwGBitMask, pf.dwBBitMask);
            pf.dwFlags &= ~DDPF_RGB;   // Clear This Bit

            sprintf (buffer+strlen(buffer), ", alpha %x", pf.dwRGBAlphaBitMask);
        }

        if (pf.dwFlags & DDPF_PALETTEINDEXED8)
        {   strcat (buffer, ", 8-bit palettized");
            pf.dwFlags &= ~DDPF_PALETTEINDEXED8;   // Clear This Bit
            palettized = true;
        }

        // If any flags left that we haven't reported on, print them.

        if (pf.dwFlags)
        {   sprintf (buffer+strlen(buffer),
                " (unknown flags: %08x)", pf.dwFlags);
        }

        strcat (buffer, "\n");
        OutputDebugString (buffer);
    }

    if (desc.dwFlags & DDSD_ZBUFFERBITDEPTH)
    {   sprintf (buffer, "ZBuffer Depth %d\n", desc.dwZBufferBitDepth);
        OutputDebugString (buffer);
    }

    // If the surface is palettized, dump the palette.

    if (palettized)
    {
        LPDIRECTDRAWPALETTE ddpal;
        hres = surf->GetPalette(&ddpal);

        if (SUCCEEDED (hres))
            dumpddpal (ddpal);
        else
        {
            OutputDebugString ("    GetPalette() returned error ");
            switch (hres)
            {
                case DDERR_NOEXCLUSIVEMODE:
                    OutputDebugString ("NOEXCLUSIVEMODE\n"); break;

                case DDERR_NOPALETTEATTACHED:
                    OutputDebugString ("NOPALETTEATTACHED\n"); break;

                case DDERR_SURFACELOST:
                    OutputDebugString ("SURFACELOST\n"); break;

                default:
                {   sprintf (buffer, "%x\n", hres);
                    OutputDebugString (buffer);
                    break;
                }
            }
        }
    }

    // Dump the description of an attached Z buffer surface if present.

    DDSCAPS zbuffcaps = { DDSCAPS_ZBUFFER };
    IDirectDrawSurface *zsurf = NULL;

    hres = surf->GetAttachedSurface (&zbuffcaps, &zsurf);

    if (SUCCEEDED(hres) && zsurf)
    {   sprintf (buffer, "Attached ZBuffer Surface %p\n", zsurf);
        OutputDebugString (buffer);
        surfinfo (zsurf);
    }

    // Dump some clipper info
    
    LPDIRECTDRAWCLIPPER lpClip = NULL;
    hres = surf->GetClipper( &lpClip );
    if( SUCCEEDED(hres) )
    {   sprintf (buffer, "Clipper: Has a clipper attached %p\n", lpClip);
        OutputDebugString (buffer);
        //
        // Now grab the rectangle...
        //
        DWORD sz=0;
        lpClip->GetClipList(NULL, NULL, &sz);
        Assert(sz != 0);
        
        char *foo = THROWING_ARRAY_ALLOCATOR(char, sizeof(RGNDATA) + sz);
        RGNDATA *lpClipList = (RGNDATA *) ( &foo[0] );
        hres = lpClip->GetClipList(NULL, lpClipList, &sz);
        if(hres == DD_OK) {
            HRGN rgn = ExtCreateRegion(NULL, sz, lpClipList);
            RECT rect;
            GetRgnBox(rgn,&rect);
            char buf[256];
            wsprintf(buf,"Clipper: (%d,%d,%d,%d) \n", rect.left, rect.top, rect.right, rect.bottom);
            OutputDebugString(buf);
        }
        delete foo;
    } else if( hres == DDERR_NOCLIPPERATTACHED )
    {   sprintf (buffer, "Clipper: No clipper attached\n");
        OutputDebugString (buffer);
    } else
    {   OutputDebugString("Clipper: hresult = ");
        hresult(hres);
    }
    RELEASE( lpClip );


    // Dump Owning direct draw object
    IUnknown *lpUnk;
    DDObjFromSurface( surf, &lpUnk, true );
    RELEASE(lpUnk);    
}

void DDObjFromSurface(
    IDirectDrawSurface *lpdds,
    IUnknown **lplpDD,
    bool doTrace,
    bool forceTrace)
{
    //
    // assert that the directdraw object on the surface is
    // the same as the ddraw object is the same
    //

    IDirectDrawSurface2 *dds2 = NULL;
    dds2 = DDSurf1to2(lpdds);

    IDirectDraw *lpDD = NULL;
    HRESULT hr = dds2->GetDDInterface((void **) &lpDD);
    Assert( SUCCEEDED( hr ) );

    Assert( lplpDD );
    lpDD->QueryInterface(IID_IUnknown, (void **)lplpDD);
    Assert( *lplpDD );

    if( doTrace ) {
        if( forceTrace ) {
            TraceTag((tagError,
                      "for ddraw surface %x the underlying ddraw obj is: %x",
                      lpdds, *lplpDD));
        } else {
            TraceTag((tagDirectDrawObject,
                      "for ddraw surface %x the underlying ddraw obj is: %x",
                      lpdds, *lplpDD));
        }
    }
    
    // release the GetDDInterface reference
    RELEASE( lpDD );
    
    // release extra surface
    RELEASE( dds2 );
}    

#define WIDTH(rect) ((rect)->right - (rect)->left)
#define HEIGHT(rect) ((rect)->bottom - (rect)->top)

void showme(DDSurface *surf)
{
    showme2( surf->IDDSurface() );
}

void showme2(IDirectDrawSurface *surf)
{
    HDC srcDC;
    HRESULT hr = surf->GetDC(&srcDC);
    HDC destDC = GetDC(NULL);

    DDSURFACEDESC ddsd;
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_HEIGHT | DDSD_WIDTH;
    hr = surf->GetSurfaceDesc(&ddsd);

    RECT dr, sr;
    SetRect( &sr, 0,0, ddsd.dwWidth, ddsd.dwHeight);
    SetRect( &dr, 0,0, ddsd.dwWidth, ddsd.dwHeight);
    
    StretchBlt(destDC,
               dr.left,
               dr.top,
               dr.right - dr.left,
               dr.bottom - dr.top,
               srcDC,
               sr.left,
               sr.top,
               sr.right - sr.left,
               sr.bottom - sr.top,
               SRCCOPY);

    hr = surf->ReleaseDC(srcDC);
    
    ReleaseDC( NULL, destDC );    
}



void showmerect(IDirectDrawSurface *surf,
                RECT *r,
                POINT offset)
{
    HDC srcDC;
    HRESULT hr = surf->GetDC(&srcDC);
    HDC destDC = GetDC(NULL);

    RECT dr, sr;
    dr = sr = *r;
    OffsetRect( &dr, offset.x, offset.y );
    
    StretchBlt(destDC,
               dr.left,
               dr.top,
               dr.right - dr.left,
               dr.bottom - dr.top,
               srcDC,
               sr.left,
               sr.top,
               sr.right - sr.left,
               sr.bottom - sr.top,
               SRCCOPY);

    hr = surf->ReleaseDC(srcDC);
    
    ReleaseDC( NULL, destDC );    
}


//--------------------------------------------------
// Given a surface and an x,y pair, finds the 
// corresponding pixel.
// Be careful, this is a debug function so it
// doesn't even pretend to make sure you're not
// asking for a pixel in Tacoma...
//--------------------------------------------------

DWORD GetPixelXY(LPDDRAWSURFACE surf, int x, int y)
{
    DWORD pixel;
    DDSURFACEDESC ddsd;
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_PITCH | DDSD_LPSURFACE;

    HRESULT _ddrval = surf->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
    IfDDErrorInternal(_ddrval, "Couldn't lock surf in GetDDPixel");

    // rows
    BYTE *p = (BYTE *)ddsd.lpSurface + ddsd.lPitch * y;

    // columns
    switch (ddsd.ddpfPixelFormat.dwRGBBitCount) {
      case 8:
        pixel = *(p + x);
        break;
      case 16:
        pixel = *((WORD *)p + x);
        break;
      case 24:
        {
            BYTE *surfPtr = ((BYTE *)p + (3*x));
            BYTE byte1 = *surfPtr++;
            BYTE byte2 = *surfPtr++;
            BYTE byte3 = *surfPtr;
            pixel = byte1 << 16 | byte2 << 8 | byte3;
        }
        break;
      case 32:
        pixel = *((DWORD *)p + x);
        break;
    }
    surf->Unlock(ddsd.lpSurface);
    return pixel;
}


#endif  // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\debug.cpp ===
////////////////////////////////////////////////////////////////
//
// File: debug.cpp
//
// Support for internal debugging
//
// Microsoft Corporation Copyright (c) 1995-96
//
////////////////////////////////////////////////////////////////

    // Define & register the trace tags.
#include "headers.h"

#if _DEBUG

#include "appelles/common.h"
#include <stdio.h>
#include <windows.h>

#define DEFINE_TAGS 1
#include "privinc/debug.h"
#include "backend/bvr.h"

typedef void (*PrintFunc)(char*);

static PrintFunc fp = NULL;

extern HINSTANCE hInst;

extern void
SetDebugPrintFunc(PrintFunc f)
{
    fp = f;
}

// Use this function as you would use printf(char *format, ...).
// This results in the information being printed to the
// debugger.
void
DebugPrint(char *format, ...)
{
    char tmp[1024];
    va_list marker;
    va_start(marker, format);
    wvsprintf(tmp, format, marker);

    // Win32 call to output the string to the "debugger" window.
    if (fp)
        (*fp)(tmp);
    else
        OutputDebugStr(tmp);
}

#if _USE_PRINT
/*
 * Package debug output as C++ output stream.
 * To do this we need to define a unbuffered stream buffer
 * that dumps its characters to the debug console.
 *
 * cdebug is the externed global for the resulting ostream
 */
class DebugStreambuf : public streambuf
{
 public:
    DebugStreambuf();
    virtual int overflow(int);
    virtual int underflow();
};

DebugStreambuf::DebugStreambuf()
{
    unbuffered(1);
}

int
DebugStreambuf::overflow(int c)
{
    char buf[2] = {(CHAR)c, 0};

    if (fp)
        (*fp)(buf);
    else
        OutputDebugStr(buf);

    return 0;
}

int
DebugStreambuf::underflow()
{
    return EOF;
}

static DebugStreambuf debugstreambuf;
extern ostream cdebug(&debugstreambuf);

const int MAXSIZE = 32000;
const int LINESIZE = 80;
static char printObjBuf[MAXSIZE];

extern "C" void DumpDebugBuffer(int n)
{
    // Debug output seems to have a line size limit, so chop them
    // off into smaller lines.
    int i = n, j = 0;
    char linebuf[LINESIZE + 2];
    linebuf[LINESIZE] = '\n';
    linebuf[LINESIZE+1] = 0;

    while (i > 0) {
        if (i > LINESIZE) 
            strncpy(linebuf, &printObjBuf[j], LINESIZE);
        else {
            strncpy(linebuf, &printObjBuf[j], i);
            linebuf[i] = '\n';
            linebuf[i+1] = 0;
        }
        i -= LINESIZE;
        j += LINESIZE;
        OutputDebugStr(linebuf);
    } 
}

extern "C" void PrintObj(GCBase* b)
{
    TCHAR szResultLine[MAX_PATH];

    TCHAR szTmpPath[MAX_PATH];
    TCHAR szTmpInFile[MAX_PATH], szTmpOutFile[MAX_PATH];
    TCHAR szCmd[MAX_PATH];

    TCHAR szModulePath[MAX_PATH];

    ofstream outFile;

    ostrstream ost(printObjBuf, MAXSIZE);
    b->Print(ost);
    ost << endl << ends;

    int n = strlen(ost.str());
    if (n < LINESIZE)
        OutputDebugStr(ost.str());
    else {
        DumpDebugBuffer(n);
    }

#ifdef UNTILWORKING
    if ( GetTempPath( MAX_PATH, szTmpPath ) == 0 )
    {
        TraceTag(( tagError, _T("Could not create temporary file for pretty printing purposes")));
        return;
    }

    strcpy( szTmpInFile, szTmpPath );
    strcat( szTmpInFile, _T("EXPRESSION") );

    strcpy( szTmpOutFile, szTmpPath );
    strcat( szTmpOutFile, _T("EXPRESSION.OUT") );

    // Send results to temporary file
    outFile.open( szTmpInFile );
    outFile << ost.str();
    outFile.close();

    GetModuleFileName( hInst, szModulePath, sizeof(szModulePath) );

    // Put a terminating NULL at the first blackslash
    TCHAR *psz = szModulePath+strlen(szModulePath)-1;
    while ( psz != szModulePath )
    {
        if ( *psz == '\\' )
        {
            *psz = 0;
            break;
        }
        --psz;
    }

    strcpy( szCmd, _T("PERL.EXE "));
    strcat( szCmd, szModulePath );
    strcat( szCmd, _T("\\..\\..\\tools\\x86\\utils\\ppfactor.pl "));
    strcat( szCmd, szTmpInFile );
    strcat( szCmd, _T(" > ") );
    strcat( szCmd, szTmpOutFile );

    // For now comment out since it brings up dialogs all over the place
    //    in Win98
//    system( szCmd );

    FILE *fp;
    
    if ( (fp = fopen( szTmpOutFile, "r" )) == NULL )
    {
        TraceTag(( tagError, _T("Could not open pretty printing temporary result file")));
        return;
    }

    while ( !feof( fp ) )
    {
        _fgetts( szResultLine, sizeof(szResultLine), fp );
        OutputDebugStr( szResultLine );
    }

    fclose( fp );
#endif
}
#endif


// Strictly for debugging... don't count on the results
extern "C" int DumpRefCount(IUnknown *obj)
{
    int refCountOnAdd = obj->AddRef();
    int refCountOnRelease = obj->Release();

    return refCountOnRelease;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\helpm.cpp ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\except.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

   Define the exception hierarchy to use for C++ exception
   handling in Appelles.

--*/

#include "headers.h"
#include "appelles/common.h"
#include "privinc/except.h"
#include "privinc/server.h"
#include "privinc/resource.h"
#include "privinc/debug.h"
#include <stdarg.h>


// Simply proxy to emit a trace tag and allow for a place to set a
// breakpoint. 
inline void RaiseExceptionProxy(DWORD code,
                                DWORD flags,
                                DWORD numArgs,
                                DWORD *lpArgs)
{
#if DEVELOPER_DEBUG
    if(DAGetLastError() != S_OK) {
#if _DEBUG
        TraceTag((tagError, 
                  "DA Error: %hr, %ls",
                  DAGetLastError(),
                  DAGetLastErrorString()));
#else
        char buf[1024];
        wsprintf(buf, 
                 "DA Error: %lx, %ls\n", 
                 DAGetLastError(),
                 DAGetLastErrorString());
        OutputDebugString(buf);
#endif
    }
#endif
    RaiseException(code, flags, numArgs, (DWORD_PTR*)lpArgs);
}
    


/////////////////////////////////////////////////////////////////////////////
// Exception helper: called from withing the except clause
// for example:  __except( _HandleAnyDaException(...) )
// IT'S IMPORTANT THAT THIS FUNCTION BE STACK NEUTRAL SO IT ALWAYS
// SUCCEEDS WITHOUT RAISING AN EXCEPTION!!  <ESPECIALLY A STACK FAULT>
/////////////////////////////////////////////////////////////////////////////
DWORD _HandleAnyDaException( DWORD code )
{
  // Usually out of mem means somethings NULL, however 
  // creating a critical section can raise the STATUS_NO_MEMORY exception
  // which we handle here and make it look like an out of mem exception
  if( code == STATUS_NO_MEMORY ) code = EXCEPTION_DANIM_OUTOFMEMORY;

    if( ( code >= _EXC_CODES_BASE) &&
        ( code <= _EXC_CODES_END) ) {
        return EXCEPTION_EXECUTE_HANDLER;
    } else {
        return EXCEPTION_CONTINUE_SEARCH;
    }
}


// forward decl: Internal use in this file only.
void vDASetLastError(HRESULT reason, int resid, va_list args);


/////////////////////////////////////////////////////////////////////////////
////// RaiseException_XXXXX  routines
/////////////////////////////////////////////////////////////////////////////

// Internal
void _RaiseException_InternalError(DEBUGARG(char *m))
{
    DASetLastError(E_UNEXPECTED, IDS_ERR_INTERNAL_ERROR DEBUGARG1(m));
    RaiseExceptionProxy(EXCEPTION_DANIM_INTERNAL, EXCEPTION_NONCONTINUABLE ,0,0);
}

void _RaiseException_InternalErrorCode(HRESULT code DEBUGARG1(char *m))
{
    DASetLastError(code, IDS_ERR_INTERNAL_ERROR DEBUGARG1(m));
    RaiseExceptionProxy(EXCEPTION_DANIM_INTERNAL, EXCEPTION_NONCONTINUABLE ,0,0);
}

// User
void RaiseException_UserError()
{
    // TODO: invalid arg ??  not sure this is the right error
    // Assume it is already set
//    DASetLastError(E_FAIL, IDS_ERR_INVALIDARG); 
    RaiseExceptionProxy(EXCEPTION_DANIM_USER, EXCEPTION_NONCONTINUABLE ,0,0);
}
void RaiseException_UserError(HRESULT result, int resid, ...)
{
    va_list args;
    va_start(args, resid) ;
    vDASetLastError(result, resid, args);
    RaiseExceptionProxy(EXCEPTION_DANIM_USER, EXCEPTION_NONCONTINUABLE ,0,0);
}

// Resource
void RaiseException_ResourceError()
{
    DASetLastError(E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY);
    RaiseExceptionProxy(EXCEPTION_DANIM_RESOURCE, EXCEPTION_NONCONTINUABLE ,0,0);
}
void RaiseException_ResourceError(char *m)
{
    DASetLastError(E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY, m);
    RaiseExceptionProxy(EXCEPTION_DANIM_RESOURCE, EXCEPTION_NONCONTINUABLE ,0,0);
}
void RaiseException_ResourceError(int resid, ...)
{ 
    va_list args;
    va_start(args, resid) ;
    vDASetLastError(E_OUTOFMEMORY, resid, args);
    RaiseExceptionProxy(EXCEPTION_DANIM_RESOURCE, EXCEPTION_NONCONTINUABLE ,0,0);
}

// Surface Cache
void RaiseException_SurfaceCacheError(char *m)
{
    DASetLastError(S_OK, IDS_ERR_OUT_OF_MEMORY, m);
    RaiseExceptionProxy(EXCEPTION_DANIM_RESOURCE, EXCEPTION_NONCONTINUABLE ,0,0);
}

// Hardware
void RaiseException_StackFault()
{
    DASetLastError(E_FAIL, IDS_ERR_STACK_FAULT);
    RaiseExceptionProxy(EXCEPTION_DANIM_STACK_FAULT, EXCEPTION_NONCONTINUABLE ,0,0);
}
void RaiseException_DivideByZero()
{
    DASetLastError(E_FAIL, IDS_ERR_DIVIDE_BY_ZERO);
    RaiseExceptionProxy(EXCEPTION_DANIM_DIVIDE_BY_ZERO, EXCEPTION_NONCONTINUABLE ,0,0);
}

// Memory
void _RaiseException_OutOfMemory(DEBUGARG2(char *msg, int size))
{
    #if _DEBUG
    DASetLastError(E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY_DBG, size, msg);
    #else
    DASetLastError(E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY);
    #endif
    RaiseExceptionProxy(EXCEPTION_DANIM_OUTOFMEMORY, EXCEPTION_NONCONTINUABLE ,0,0);
}

////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////

/////////////////// Handle All This Stuff ////////////////////////

// Throws an out of memory exception if the ptr is NULL, else returns
// ptr. 
void *
ThrowIfFailed(void *ptr)
{
    if (ptr == NULL) {
#if _MEMORY_TRACKING
        OutputDebugString("\nDirectAnimation: Out Of Memory\n");
        F3DebugBreak();
#endif
        RaiseException_OutOfMemory("In THROWING_ALLOCATOR", 0);
    }

    return ptr;
}

#if _DEBUGMEM
void *
AxAThrowingAllocatorClass::operator new(size_t s,
                                        int block,
                                        char *filename,
                                        int line)
{
    void *result = (void *)new(block, filename, line) char[s];
    TraceTag((tagGCDebug,
              "AxAThrowingAllocatorClass::operator new %s:Line(%d) Addr: %lx size= %d.\n",
              filename, line, result, s));
    return ThrowIfFailed(result);
}
#endif

void *
AxAThrowingAllocatorClass::operator new(size_t s)
{
    return (void *)THROWING_ARRAY_ALLOCATOR(char, s);
}

void *
AxAThrowingAllocatorClass::operator new(size_t s, void *ptr)
{
    return ptr;
}

//////////////////////////////////////////////////////////////////

// Use 0xffffffff since it is the error return value as well
static DWORD errorTlsIndex = 0xFFFFFFFF;

class DAErrorInfo
{
  public:
    DAErrorInfo() : _reason(S_OK), _msg(NULL) {}
    // No destructor since we never free the class

    void Free() { delete _msg; _msg = NULL; }
    void Clear() { Free(); _reason = S_OK; }
    void Set(HRESULT reason, LPCWSTR msg);
    
    HRESULT GetReason() { return _reason; }
    LPCWSTR GetMsg() { return _msg; }
  protected:
    HRESULT _reason;
    LPWSTR _msg;
};

void
DAErrorInfo::Set(HRESULT reason, LPCWSTR msg)
{
    // Set the reason
    
    _reason = reason;

    // Free any associated memory
    
    Free();
    
    // Try to store the new message - if it fails indicate out of
    // memory if the reason was S_OK
    
    if (msg) {
        _msg = CopyString(msg);
        if (!_msg) {
            if (_reason == S_OK)
                _reason = E_OUTOFMEMORY;
            
            Assert (!"Out of memory in SetError");
        }
    }
}
    

DAErrorInfo *
TLSGetErrorValue()
{
    // Grab what is stored in TLS at this index.
    DAErrorInfo * result = (DAErrorInfo *) TlsGetValue(errorTlsIndex);

    // If null, then we haven't created the memory for this thread yet
    // or we failed sometime earlier
    
    if (result == NULL) {
        Assert((GetLastError() == NO_ERROR) && "Error in TlsGetValue()");
        result = NEW DAErrorInfo;
        Assert (result);
        TlsSetValue(errorTlsIndex, result);
    }

    return result;
}

void
TLSSetError(HRESULT reason, LPCWSTR msg)
{
    // Get the error info object for this thread
    DAErrorInfo* ei = TLSGetErrorValue();

    // If it fails then we had a memory failure and just skip the rest
    
    if (ei)
        ei->Set(reason, msg);
}

void
DASetLastError(HRESULT reason, int resid, ...)
{
    va_list args;
    va_start(args, resid) ;
        
    vDASetLastError (reason, resid, args) ;
}

void
vDASetLastError(HRESULT reason, int resid, va_list args)
{
#if 0
    LPVOID  lpv;
    HGLOBAL hgbl;
    HRSRC   hrsrc;

    hrsrc = FindResource(hInst,
                         MAKEINTRESOURCE(resid),
                         RT_STRING);
    Assert (hrsrc) ;

    DWORD d = GetLastError () ;
    
    if (!hrsrc) return ;
    
    hgbl = LoadResource(hInst, hrsrc);
    Assert (hgbl) ;

    lpv = LockResource(hgbl);
    Assert (lpv) ;

    vSetError((char *)lpv, args) ;
    
#ifndef _MAC
    //  Win95 is said to need this
    FreeResource(hgbl);
#endif
#else
    if (resid) {
        char buf[1024];
        LoadString (hInst, resid, buf, sizeof(buf));
        
        char * hTmpMem = NULL ;
        
        if (!FormatMessage (FORMAT_MESSAGE_FROM_STRING |
                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            (LPVOID)buf,
                            0,
                            0,
                            (char *)&hTmpMem,
                            0,
                            &args)) {
            
            Assert(!"Failed to format error message.");
            TLSSetError(reason, NULL);
        } else {
            USES_CONVERSION;
            TLSSetError(reason, A2W(hTmpMem));
            LocalFree ((HLOCAL) hTmpMem);
        }
    } else {
        TLSSetError(reason, NULL);
    }
#endif
}

void
DASetLastError(HRESULT reason, LPCWSTR msg)
{ TLSSetError(reason, msg); }

HRESULT
DAGetLastError()
{
    // Get the error info object for this thread
    DAErrorInfo* ei = TLSGetErrorValue();

    // If errorinfo is null then there was a memory failure
    
    if (ei)
        return ei->GetReason();
    else
        return E_OUTOFMEMORY;
}

LPCWSTR
DAGetLastErrorString()
{
    // Get the error info object for this thread
    DAErrorInfo* ei = TLSGetErrorValue();

    // If errorinfo is null then there was a memory failure
    
    if (ei)
        return ei->GetMsg();
    else
        return NULL;
}

void
DAClearLastError()
{
    // Get the error info object for this thread
    DAErrorInfo* ei = TLSGetErrorValue();

    // If it fails then we had a memory failure and just skip the rest
    
    if (ei)
        ei->Clear();
}

//////////////////////////////////////////////////////////////////

void
InitializeModule_Except()
{
    errorTlsIndex = TlsAlloc();
    // If result is 0xFFFFFFFF, allocation failed.
    Assert(errorTlsIndex != 0xFFFFFFFF);
}

void
DeinitializeModule_Except(bool bShutdown)
{
    if (errorTlsIndex != 0xFFFFFFFF)
        TlsFree(errorTlsIndex);
}

void
DeinitializeThread_Except()
{
    // Grab what is stored in TLS at this index.
    DAErrorInfo * result = (DAErrorInfo *) TlsGetValue(errorTlsIndex);

    if (result)
    {
        delete result;
        TlsSetValue(errorTlsIndex, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "privinc/server.h"


#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\helps.cpp ===
/**********************************************************************
helps  Generic sound helper functions
**********************************************************************/
#include "headers.h"
#include "privinc/util.h"
#include "privinc/helps.h"
#include <float.h>              // DBL_MAX
#include <math.h>               // log10 and pow

unsigned int
SecondsToBytes(Real seconds, int sampleRate,
               int numChannels, int bytesPerSample)
{
    return (unsigned int)(seconds * sampleRate * numChannels * bytesPerSample);
}

Real
FramesToSeconds(int frames, int sampleRate)
{
    return (float)frames / (float)(sampleRate);
}

Real
BytesToSeconds(unsigned int bytes, int sampleRate,
               int numChannels, int bytesPerSample)
{
    return (float)bytes / (float)(sampleRate * numChannels * bytesPerSample);
}

unsigned int
BytesToFrames(unsigned int bytes, int numChannels, int bytesPerSample)
{
    return bytes / (numChannels * bytesPerSample);
}

unsigned int
SamplesToBytes(unsigned int samples, int numChannels, int bytesPerSample)
{
    return samples * numChannels * bytesPerSample;
}

unsigned int
FramesToBytes(unsigned int frames, int numChannels, int bytesPerSample)
{
    return frames * numChannels * bytesPerSample;
}


void
Pan::SetLinear(double linearPan)
{
    _direction   = (linearPan >= 0) ? 1 : -1;
    _dBmagnitude = LinearTodB(1.0 - fabs(linearPan));
}

void
PanGainToLRGain(double pan, double gain, double& lgain, double& rgain)
{
    // this implements the balance pan
    // GR
    //         ---
    //        /
    //       /
    //      /

    // GL
    //      ---
    //         \
    //          \
    //           \
        
    lgain = gain;
    rgain = gain;

    if (pan>0.0) {
        lgain = gain * (1 - pan);
    } else if (pan<0.0) {
        rgain = gain * (1 + pan);
    }
}

void
SetPanGain(double lgain, double rgain, Pan& pan, double& gainDb)
{
    double gain = MAX(lgain, rgain);

    pan.SetLinear((rgain - lgain) / gain);

    gainDb = LinearTodB(gain);
}

/**********************************************************************
Takes an input range of 0 to 1 and converts it to a log range of 
0 to -BigNumber

20 * log base 10 is the standard decibel power conversion equation.
**********************************************************************/
double LinearTodB(double linear) {
    double result;

    if(linear <= 0.0)
        result = -DBL_MAX; // Largest negative is the best we can do
    else
        result = 20.0 * log10(linear);

    return(result);
}

double DBToLinear(double db)
{
    return pow(10, db/20.0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\geometry.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Geometric Utility Functions

*******************************************************************************/

#include "headers.h"

#include "privinc/vec3i.h"
#include "privinc/d3dutil.h"
#include "privinc/xformi.h"



/*****************************************************************************
This function, given three triangle vertices and a point P guaranteed to be
inside the triangle, returns the barycentric coordinates of that point with
respect to the vertices.
*****************************************************************************/

void GetContainedBarycentricCoords (
    Point3Value vertices[3],     // Triangle Vertices Containing P
    Point3Value P,               // Point P Inside Triangle
    Real   barycoords[3])   // Output Barycentric Coordinates
{
    //     V2 ---------------------- V1     S = V1 - V0
    //      \ ~-_              _.-~  /      T = V2 - V0
    //      _\   -_        _.-~     /_      U = P  - V0
    //      T \    -_  _.-~        / S
    //         \     ~P           /
    //          \     ^ _        /
    //           \    | U       /
    //            \    |       /
    //             \   |      /
    //              \  |     /
    //               \  |   /
    //                \ |  /
    //                 \| /
    //                  \/
    //                  V0

    Vector3Value S (vertices[1].x - vertices[0].x,      // S = V1 - V0
                    vertices[1].y - vertices[0].y,
                    vertices[1].z - vertices[0].z);

    Vector3Value T (vertices[2].x - vertices[0].x,      // T = V2 - V0
                    vertices[2].y - vertices[0].y,
                    vertices[2].z - vertices[0].z);

    // Compute the normal vector of the triangle.  The largest component of the
    // normal vector indicates most dominant normal axis.  Dropping this
    // coordinate gives us the projection to the most parallel base plane (XY,
    // YZ, or ZX), which reduces this from a 3D problem to a 2D problem.  Note
    // that the resulting barycentric coordinates will still be the same, and
    // because we are dropping the dominant normal coordinate, we won't get a
    // degenerate 2D projection unless the starting triangle was also
    // degenerate.

    Vector3Value N;
    Cross (N, S, T);
    N.x = fabs (N.x);
    N.y = fabs (N.y);
    N.z = fabs (N.z);

    int dominant_axis;    // 0:X, 1:Y, 2:Z

    if (N.x < N.y)
        dominant_axis = (N.y < N.z) ? 2 : 1;
    else
        dominant_axis = (N.x < N.z) ? 2 : 0;

    Vector2Value U;

    // Set vector U to be the 2D vector from V0 to P.  Alter 3D vectors S and
    // T to be the corresponding 2D projections, with components X and Y
    // containing the 2D coordinates.

    if (dominant_axis == 0)
    {   U.Set (P.z - vertices[0].z, P.y - vertices[0].y);
        S.x = S.z;
        T.x = T.z;
    }
    else if (dominant_axis == 1)
    {   U.Set (P.x - vertices[0].x, P.z - vertices[0].z);
        S.y = S.z;
        T.y = T.z;
    }
    else  // (dominant_axis == 2)
    {   U.Set (P.x - vertices[0].x, P.y - vertices[0].y);
    }

    // Solve for the barycentric coordinates by using the ratio of
    // subtriangles.  Referring to the above diagram, the barycentric
    // coordinate corresponding to V0 is the ratio of the area of triangle
    // <P,V1,V2> over the area of the whole triangle <V0,V1,V2>.  The area of a
    // triangle is half the magnitude of the cross-product of two of its side
    // vectors.  The barycentric coordinate for V0 is derived from the
    // knowledge that P lies inside the triangle, so we can exploit the fact
    // that for all such points, the sum of the barycentric coordinates is one.

    Real triArea  =  (S.x * T.y) - (S.y * T.x);
    barycoords[1] = ((U.x * T.y) - (U.y * T.x)) / triArea;
    barycoords[2] = ((S.x * U.y) - (S.y * U.x)) / triArea;
    barycoords[0] = 1 - barycoords[1] - barycoords[2];

    // Assert that the barycentric coordinates are within range for a point
    // inside the triangle (all bc coords in [0,1]).

    //Assert ((-0.01 < barycoords[0]) && (barycoords[0] < 1.01)
    //     && (-0.01 < barycoords[1]) && (barycoords[1] < 1.01));
}




/*****************************************************************************
This routine starts with a facet defined by a triangle fan about the first
vertex, and a point P on the face.  It determines which triangle in the face
contains the point P, and returns the three vertex positions and vertex
surface coordinates in the triPos[] and triUV[] arguments, respectively.  It
also returns the triangle number (starting with 1) of the hit triangle.  Thus,
the triangle vertices are V0, Vi, Vi+1
*****************************************************************************/

int GetFacetTriangle (
    Point3Value   P,           // Point In Facet
    unsigned int  N,           // Number of Facet Vertices
    D3DRMVERTEX  *fVerts,      // Facet Vertices
    Point3Value   triPos[3],
    Point2Value  *triUV)    // Containing-Triangle Surface Coordinates
{
    unsigned int i = 2;            // Current Triangle Last Vertex

    // V0 is the pivot vertex of the trianle fan.

    Point3Value V0
        (fVerts[0].position.x, fVerts[0].position.y, fVerts[0].position.z);

    // Test each triangle unless there's only one triangle in the fan,
    // or unless the given point is the same as the pivot vertex.
    
    if ((N > 3) && ((P.x != V0.x) || (P.y != V0.y) || (P.z != V0.z)))
    {
        // V is the unit vector from the pivot vertex to the point P.

        Vector3Value V (P.x - V0.x, P.y - V0.y, P.z - V0.z);

        V.Normalize ();

        Vector3Value A                     // Vector A is the first side of
        (   fVerts[1].position.x - V0.x,   // the triangle we're currently
            fVerts[1].position.y - V0.y,   // testing to see if it contains P.
            fVerts[1].position.z - V0.z
        );

        A.Normalize();

        // Test each triangle in the fan to find one that contains the point P.

        for (i=2;  i < N;  ++i)
        {
            Vector3Value B                    // Vector B is the second side of
            (   fVerts[i].position.x - V0.x,  // the triangle we're currently
                fVerts[i].position.y - V0.y,  // testing for containment of P.
                fVerts[i].position.z - V0.z
            );

            B.Normalize();

            // @@@SRH
            // The "volatile" keyword below is a workaround for a VC 4.x
            // compiler bug.  When we're on VC 5.0, remove this and verify for
            // both debug and release builds.

                     Real cosThetaAB = Dot (A, B);
                     Real cosThetaAV = Dot (A, V);
            volatile Real cosThetaVB = Dot (V, B);

            //   V0 +-------------> A   If the cosine of theta1 is greater
            //      \~~--..__           than the cosine of theta2, then
            //       \       ~~> V      the angle V(i-1),V0,P is more
            //        \                 acute than the angle V(i-1),V0,Vi,
            //         \                so P must lie within the sector of
            //          B               this triangle.

            if ((cosThetaAV >= cosThetaAB) && (cosThetaVB >= cosThetaAB))
                break;

            A = B;   // The current triangle second side now becomes the first
                     // side of the next triangle.
        }
    }

    // Ensure that the intersect point lies inside some triangle in the fan.
    // Note that the following should really be an assert, but Dx2 on NT has
    // broken picking.  So if this condition is true, then things have gone
    // very wrong -- just return the pivot vertex.

    if (i >= N)
    {
        triPos[0].Set (V0.x, V0.y, V0.z);

        triPos[1].Set
            (fVerts[1].position.x, fVerts[1].position.y, fVerts[1].position.z);

        triPos[2].Set
            (fVerts[2].position.x, fVerts[2].position.y, fVerts[2].position.z);

        if (triUV)
        {   triUV[0].Set (fVerts[0].tu, fVerts[0].tv);
            triUV[1].Set (fVerts[1].tu, fVerts[1].tv);
            triUV[2].Set (fVerts[2].tu, fVerts[2].tv);
        }

        return 1;
    }

    // Fill in the vertex positions of the containing triangle.

    triPos[0].Set
      (V0.x, V0.y, V0.z);

    triPos[1].Set
      (fVerts[i-1].position.x, fVerts[i-1].position.y, fVerts[i-1].position.z);

    triPos[2].Set
      (fVerts[i].position.x,   fVerts[i].position.y,   fVerts[i].position.z);

    
    if(triUV) {
        // Fill in the vertex surface coordinates of the containing triangle.
        
        triUV[0].Set (fVerts[ 0 ].tu, fVerts[ 0 ].tv);
        triUV[1].Set (fVerts[i-1].tu, fVerts[i-1].tv);
        triUV[2].Set (fVerts[ i ].tu, fVerts[ i ].tv);
    }

    return i-1;  //  triangle index
}


void GetTriFanBaryCoords(
    Point3Value   P,           // Point In Facet
    unsigned int  N,           // Number of Facet Vertices
    D3DRMVERTEX  *fVerts,      // Facet Vertices
    Real          barycoords[3],
    int          *index)
{
    Point3Value triPos[3];
    *index = GetFacetTriangle(P, N, fVerts, triPos, NULL);
    GetContainedBarycentricCoords(triPos, P, barycoords);
}



/*****************************************************************************
This routine gets the texture-map intersection point given the geometry winner
data structure.
*****************************************************************************/

Point2Value *GetTexmapPoint (HitInfo &hit)
{
    unsigned int vCount;      // Vertex Count
    unsigned int fCount;      // Face Count
    unsigned int vPerFace;    // Vertices Per Face
    DWORD        fDataSize;   // Size of Face Data Buffer

    // First Query to see how large the face data array will be.

    TD3D (hit.mesh->GetGroup
        (hit.group, &vCount, &fCount, &vPerFace, &fDataSize, 0));

    // Fill in the face data array.

    unsigned int *fData = NEW unsigned int [fDataSize];

    TD3D (hit.mesh->GetGroup (hit.group, 0,0,0, &fDataSize, fData));

    // Seek to the beginning of the hit face data.  If the number of vertices
    // per face is zero, then the faces have a varying number of vertices, and
    // each face's vertex list is preceded by the vertex count.  If the number
    // of vertices per face is non-zero, then all faces have that many vertices.

    int fstart = 0;
    int faceNumVerts = 0;

    if (vPerFace != 0)
    {   fstart = vPerFace * hit.face;
        faceNumVerts = vPerFace;
    }
    else
    {   unsigned int faceNum = 0;
        while (faceNum < hit.face)
        {   fstart += fData[fstart] + 1;
            ++ faceNum;
        }
        faceNumVerts = fData[fstart++];
    }

    Assert ((3 <= faceNumVerts) && (faceNumVerts <= (int(fDataSize)-fstart)));

    D3DRMVERTEX *fVerts = NEW D3DRMVERTEX [faceNumVerts];

    int i;
    for (i=0;  i < faceNumVerts;  ++i)
        TD3D (hit.mesh->GetVertices (hit.group, fData[fstart+i], 1, fVerts+i));

    delete [] fData;

    // Convert the intersection point from world coordinates to the primitive
    // model coordinates (where the native vertex information lies).

    Point3Value intersect (hit.wcoord.x, hit.wcoord.y, hit.wcoord.z);

    Transform3 *inv = hit.lcToWc->Inverse();

    if (!inv) return origin2;
    
    intersect.Transform (inv);

    Point3Value triVerts [3];
    Point2Value triUVs   [3];

    GetFacetTriangle (intersect, faceNumVerts, fVerts, triVerts, triUVs);

    delete [] fVerts;

    Real bc[3];    // Barycentric Coordinates of Intersection Point

    GetContainedBarycentricCoords (triVerts, intersect, bc);

    return NEW Point2Value
    (   (bc[0] * triUVs[0].x) + (bc[1] * triUVs[1].x) + (bc[2] * triUVs[2].x),
        (bc[0] * triUVs[0].y) + (bc[1] * triUVs[1].y) + (bc[2] * triUVs[2].y)
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\helpq.cpp ===
/**********************************************************************
Copyright (c) 1997 Microsoft Corporation

helpq.cpp:

    Quart filter graph support
**********************************************************************/
#include "headers.h"
#include "ddraw.h" // DDPIXELFORMAT
#include "privinc/helpq.h"
#include "privinc/util.h"  // saturate
#include "privinc/resource.h"
#include "privinc/viewport.h" // GetDirectDraw
#include "privinc/dddevice.h" // DirectDrawImageDevice

#define USE_AMMSF_NOSTALL

Mutex avModeMutex;

QuartzRenderer::QuartzRenderer() : _MIDIgraph(NULL), _audioControl(NULL),
     _mediaControl(NULL), _mediaPosition(NULL), _mediaEvent(NULL)
{
    _rate0paused = FALSE;
    _playing     = FALSE;
}


void 
QuartzRenderer::Open(char *fileName)
{
    HRESULT hr;

    if(!_MIDIgraph) {
        // create instance of the quartz graph
        if(FAILED(hr = CoCreateInstance(CLSID_FilterGraph, NULL,
                              CLSCTX_INPROC_SERVER, IID_IGraphBuilder,
                              (void **)&_MIDIgraph)))
            RaiseException_InternalError("Failed to CoCreateInstance quartz\n");

        // get the event notification handle so we can wait for completion
        if(FAILED(hr = _MIDIgraph->QueryInterface(IID_IMediaEventEx,
                                              (void **)&_mediaEvent)))
            RaiseException_InternalError("Failed QueryInterface(_MIDIgraph)\n");
        if(FAILED(hr = _mediaEvent->SetNotifyFlags(1)))
            RaiseException_InternalError("Failed SetNotifyFlags\n");
        _mediaEvent->GetEventHandle((OAEVENT *)&_oaEvent);


        // ask the graph to render our file
        WCHAR path[MAX_PATH];  // unicode path
        MultiByteToWideChar(CP_ACP, 0, fileName, -1,
                            path, sizeof(path)/sizeof(path[0]));

        if(FAILED(hr = _MIDIgraph->RenderFile(path, NULL))) {
            RaiseException_UserError(hr, IDS_ERR_FILE_NOT_FOUND, fileName);
        }


        // get the BasicAudio interface so we can control this thing!
        if(FAILED(hr = _MIDIgraph->QueryInterface(IID_IBasicAudio,
                                              (void**)&_audioControl)))
            RaiseException_InternalError("BasicAudio QueryInterface Failed\n");


        // get the filtergraph control interface
        if(FAILED(hr = _MIDIgraph->QueryInterface(IID_IMediaControl,
                                              (void**)&_mediaControl)))
            RaiseException_InternalError("mediaControl QueryInterface Failed\n");


        // get the filtergraph media position interface
        if(FAILED(hr = _MIDIgraph->QueryInterface(IID_IMediaPosition,
                                             (void**)&_mediaPosition)))
            RaiseException_InternalError("mediaPosition QueryInterface Failed\n");
    }

    _rate0paused = FALSE;
    _playing     = FALSE;
}


void
QuartzRenderer::CleanUp()
{
    if(_audioControl)   _audioControl->Release();
    if(_mediaControl)   _mediaControl->Release();
    if(_mediaPosition)  _mediaPosition->Release();
    if(_MIDIgraph)      _MIDIgraph->Release();
    if(_mediaEvent)     _mediaEvent->Release();
}


double
QuartzRenderer::GetLength()
{
    REFTIME length; // XXX this is a double?
    HRESULT hr;

    Assert(_mediaPosition);
    if(FAILED(hr = _mediaPosition->get_Duration(&length)))
        RaiseException_InternalError("mediaPosition get_duration Failed\n");

    return(length);
}


void
QuartzRenderer::Play()
{
    HRESULT hr;

    Assert(_mediaControl);
    if(FAILED(hr = _mediaControl->Pause()))
        RaiseException_InternalError("quartz pause Failed\n");

    if(FAILED(hr = _mediaControl->Run()))
        RaiseException_InternalError("quartz run Failed\n");

    _rate0paused = FALSE;
    _playing     = TRUE;
}


void
QuartzRenderer::Position(double seconds)
{
    HRESULT hr;

    Assert(_mediaPosition);
    if(FAILED(hr = _mediaPosition->put_CurrentPosition(seconds)))
        RaiseException_InternalError("quartz put_CurrentPosition Failed\n");
}


void
QuartzRenderer::Stop()
{
    HRESULT hr;

    if (_mediaControl) {
            if(FAILED(hr = _mediaControl->Stop()))
                    RaiseException_InternalError("quartz stop Failed\n");
        }

    _rate0paused = FALSE;
    _playing     = FALSE;
}


void
QuartzRenderer::Pause()
{
    HRESULT hr;

    if (_mediaControl) {
                if(FAILED(hr = _mediaControl->Pause()))
                        RaiseException_InternalError("quartz pause Failed\n");
        }

    // we don't change the pause state here, only for rate zero pause!
}


void
QuartzRenderer::SetRate(double rate)
{
    HRESULT hr;

    //NOTE: the MIDI renderer becomes confused on extreemely lorates under 0.1
    if(rate < 0.1) {
        Assert(_mediaControl);
        if(FAILED(hr = _mediaControl->Pause())) // pause the graph
            RaiseException_InternalError("quartz pause Failed\n");
       _rate0paused = TRUE;
    }
    else { // normal case
        if(_playing && _rate0paused) {
            Assert(_mediaControl);
            if(FAILED(hr = _mediaControl->Run())) // unpause the graph
                RaiseException_InternalError("quartz run Failed\n");

            _rate0paused = FALSE;
        }

        double quartzRate = fsaturate(0.1, 3.0, rate);
        Assert(_mediaPosition);
        _mediaPosition->put_Rate(quartzRate);
    }
}


void
QuartzRenderer::SetGain(double dBgain)
{
    HRESULT hr;

    Assert(_audioControl);
    double suggestedGain = dBToQuartzdB(dBgain);
    int gain = saturate(-10000, 0, suggestedGain);
    if(FAILED(hr = _audioControl->put_Volume(gain)))
        RaiseException_InternalError("quartz put_Volume Failed\n");
}


void
QuartzRenderer::SetPan(double pan, int direction)
{
    HRESULT hr;

    Assert(_audioControl);

    double qPan = direction * dBToQuartzdB(-1.0 * pan);
    qPan = fsaturate(-10000, 10000, qPan);
    if(FAILED(hr = 
        _audioControl->put_Balance(qPan)))
        RaiseException_InternalError("quartz put_Balance Failed\n");
}


bool 
QuartzRenderer::QueryDone()
{
    bool done = false;

    if(!_rate0paused) {
        Assert(_oaEvent);

#ifdef NEWFANGLED_UNPROVEN
        Assert(_mediaEvent);

        while(WaitForSingleObject(_oaEvent, 0) == WAIT_OBJECT_0) {
            long event, param1, param2;
            while(SUCCEEDED(_mediaEvent->GetEvent(
                &event, &param1, &param2, 0))) {
                _mediaEvent->FreeEventParams(event, param1, param2);
                if(event == EC_COMPLETE) 
                    done = true;
            }
        }
#else
        if(WaitForSingleObject(_oaEvent, 0) == WAIT_OBJECT_0)
            done = true;
#endif
    }

    return(done);
}


QuartzMediaStream::QuartzMediaStream() : 
    _multiMediaStream(NULL), _clockAdjust(NULL)
{
    HRESULT hr;

    // create instance of the quartz graph
    if(FAILED(hr = CoCreateInstance(CLSID_AMMultiMediaStream, NULL, 
                     CLSCTX_INPROC_SERVER, IID_IAMMultiMediaStream, 
                     (void **)&_multiMediaStream)))
        RaiseException_InternalError("Failed to CoCreateInstance amStream\n");
    TraceTag((tagAMStreamLeak, "leak MULTIMEDIASTREAM %d created", 
        _multiMediaStream));

    if(FAILED(hr = _multiMediaStream->QueryInterface(IID_IAMClockAdjust, 
                                                    (void **)&_clockAdjust))) {

        TraceTag((tagError, "Old amstream w/o ClockAdjust interface detected %hr", hr));

        // no longer an error (for now we tolerate old amstreams!
        //RaiseException_InternalError("Failed to QueryInterface clockAdjust\n");
    }
    TraceTag((tagAMStreamLeak, "leak CLOCKADJUST %d created", _clockAdjust));

    if(FAILED(hr = _multiMediaStream->Initialize(STREAMTYPE_READ, 0, NULL)))
        RaiseException_InternalError("Failed to initialize amStream\n");


#ifdef PROGRESSIVE_DOWNLOAD
    // things for progressive download
    //IGraphBuilder *graphBuilder;
    //IMediaSeeking *seeking;
    //_multiMediaStream->GetFilterGraph(graphBuilder);
    //hr =_graphBuilder->QueryInterface(IID_IMediaSeeking, (void **)&seeking); 
    //graphBuilder->Release();

    // determine how much has been downloaded to calculate statistics for 
    // progressive download
    //seeking->GetAvailable(&ealiest, &latest);
#endif
}


bool
QuartzReader::QueryPlaying()
{
    HRESULT hr;
    STREAM_STATE streamState;

    if(FAILED(hr = _multiMediaStream->GetState(&streamState)))
        RaiseException_InternalError("Failed to GetState amStream\n");

    bool playing = (streamState == STREAMSTATE_RUN);
    return(playing);
}


bool
QuartzReader::Stall()
{
    bool value = _stall;
    _stall = false;        // reset the value

    return(value);
}


void
QuartzReader::SetStall()
{
    bool setValue = true;
#if _DEBUG
        if(IsTagEnabled(tagMovieStall)) 
            setValue = _stall;
#endif /* _DEBUG */
    _stall = setValue;
}

void
QuartzAVstream::InitializeStream()
{
    if (!QuartzVideoReader::IsInitialized()) {
        VideoInitReader(GetCurrentViewport()->GetTargetPixelFormat());
    }
}

bool
QuartzAVstream::SafeToContinue()
{
    // check to see if either A or V time is 0 and the other is above threashold
    const double threashold = 0.5;
    bool safe = true;
    double videoSeconds = AVquartzVideoReader::GetSecondsRead();
    double audioSeconds = AVquartzAudioReader::GetSecondsRead();

    if( ((videoSeconds==0) || (audioSeconds==0)) &&
        ((videoSeconds>threashold) || (audioSeconds>threashold)))
        safe = false;

    return(safe);
}


int
QuartzAVstream::ReadFrames(int numSamples, unsigned char *buffer, bool blocking)
{
    MutexGrabber mg(_avMutex, TRUE); // Grab mutex
    int framesRead = 
        AVquartzAudioReader::ReadFrames(numSamples, buffer, blocking);

    // XXX maybe CleanUp is too severe... Possibly only release the samples
    //     in a dissable call?
    if(QuartzAudioReader::Stall())      // check for stall
        QuartzVideoReader::Disable();   // perform lockout 

    return(framesRead);
} // end mutex context


HRESULT
QuartzAVstream::GetFrame(double time, IDirectDrawSurface **ppSurface)
{
    MutexGrabber mg(_avMutex, TRUE); // Grab mutex
    HRESULT hr = AVquartzVideoReader::GetFrame(time, ppSurface);

    // XXX maybe CleanUp is too severe... Possibly only release the samples
    //     in a dissable call?
    if(QuartzVideoReader::Stall())      // check for stall
        QuartzAudioReader::Disable();   // perform lockout 

    return(hr);
} // end mutex context


int
AVquartzAudioReader::ReadFrames(int numSamples, unsigned char *buffer, 
    bool blocking)
{
    int framesRead = -1;

    if(_initialized) { // for AV mode fallback dectection!
        framesRead = 
            QuartzAudioReader::ReadFrames(numSamples, buffer, blocking);
        double secondsRead = pcm.FramesToSeconds(framesRead);
        AddReadTime(secondsRead);
    }
    else {
        TraceTag((tagAVmodeDebug, "AVquartzAudioReader::ReadFrames() FALLBACK"));
        // this stream must have been dissabled
        // XXX throw something
        //     so something upwind of us can fallback and create a vstream...
        //     (maybe AVstream needs a clone call?)
        //
        // XXX or maybe returning -1 is enough?
    }

    return(framesRead);
}


HRESULT 
AVquartzVideoReader::GetFrame(double time, IDirectDrawSurface **ppSurface)
{
    HRESULT hr = 0;

    hr = QuartzVideoReader::GetFrame(time, ppSurface);

    AddReadTime(0.3); // we don't know how far dshow skipped
                          // guess we have to compare time stamps
    return(hr);
}


void
QuartzMediaStream::CleanUp()
{
    if(_multiMediaStream) {
        int result =_multiMediaStream->Release();
        TraceTag((tagAMStreamLeak, "leak MULTIMEDIASTREAM %d released (%d)", 
            _multiMediaStream, result));
        _multiMediaStream = NULL;
    }

    if(_clockAdjust) {
        int result = _clockAdjust->Release();
        TraceTag((tagAMStreamLeak, "leak CLOCKADJUST %d released (%d)", 
            _clockAdjust, result));
        //Assert(!result);
        _clockAdjust = NULL;
    }
}


// default to non-seekable == self clocking
void
QuartzVideoStream::Initialize(char *url, DDSurface *surface, bool seekable)
{
    HRESULT hr;
    char string[200];

    Assert(QuartzMediaStream::_multiMediaStream);

    GetDirectDraw(&_ddraw, NULL, NULL);
    TraceTag((tagAMStreamLeak, "leak DDRAW %d create", _ddraw));

    DWORD flags = NULL;
#ifdef USE_AMMSF_NOSTALL
    if(!seekable)
        flags |= AMMSF_NOSTALL;
#endif
    if(FAILED(hr = QuartzMediaStream::_multiMediaStream->AddMediaStream(_ddraw,
                 &MSPID_PrimaryVideo, flags, NULL))) {
        CleanUp();
        RaiseException_InternalError("Failed to AddMediaStream amStream\n");
    }

    flags = seekable ? AMMSF_NOCLOCK : NULL;
    if(FAILED(hr = 
        QuartzMediaStream::_multiMediaStream->OpenFile(GetQURL(), flags))) {

        TraceTag((tagError, "Quartz Failed to OpenFile <%s> %hr\n", url, hr));
        CleanUp();
        RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE, url);
    }

    if(!VideoSetupReader(QuartzMediaStream::_multiMediaStream, 
        QuartzMediaStream::_clockAdjust, surface, seekable)) {
        // video stream not there
    }
}


QuartzVideoReader::QuartzVideoReader(char *url, StreamType streamType) :
    QuartzReader(url, streamType), _ddrawStream(NULL),
    _async(false), _seekable(false), _ddrawSample(NULL),
    _ddrawSurface(NULL), _height(NULL), _width(NULL), _hrCompStatus(NULL),
    _curSampleStart(0), _curSampleEnd(0), _curSampleValid(false), _surface(NULL)
{
}


void
QuartzVideoReader::VideoInitReader(DDPIXELFORMAT pixelFormat)
{
    HRESULT     hr;

    if(!_ddrawStream) // this is a hacky check to fix the audio initialize case
                      // if only audio is used in an import...
        return;  

    IDDrawSurface *ddSurface = NULL; // the actual ddSurface from the wrapper
    if(_surface)
        ddSurface = _surface->IDDSurface(); // extract actual surf from wrapper

    _initialized = true;
    _deleteable  = false;


    { // set the desired pixel format
        DDSURFACEDESC ddsc;
        ddsc.dwSize = sizeof(DDSURFACEDESC);

        // get the movie's native format
        if(FAILED(hr = _ddrawStream->GetFormat(&ddsc, NULL, NULL, NULL))) {
            CleanUp();
            RaiseException_InternalError("Failed to GetFormat\n");
        }

        // Set the format and system memory
        ddsc.dwFlags = DDSD_PIXELFORMAT;
        ddsc.ddpfPixelFormat = pixelFormat;

        if(FAILED(hr = _ddrawStream->SetFormat(&ddsc, NULL))) {
            CleanUp();
            RaiseException_InternalError("Failed to SetFormat\n");
        }

    }

    // setup pcm
#ifdef XXX  // might have to add quartz timing to pcm?
    if(FAILED(hr = _audioStream->GetFormat(&waveFormat))) {
        CleanUp();
        RaiseException_InternalError("Failed to GetFormat\n");
    }
    pcm.SetPCMformat(waveFormat);        // configure our PCM info
    pcm.SetNumberSeconds(GetDuration()); // length, too!
#endif

#ifdef USE_QUARTZ_EVENTS
    _event = CreateEvent(FALSE, NULL, NULL, FALSE);
#endif USE_QUARTZ_EVENTS

#if _DEBUG
    if(ddSurface)
        TraceTag((tagAVmodeDebug, "creating sample with surf=%x", ddSurface));
    else
        TraceTag((tagAVmodeDebug, "creating sample without surface"));
#endif

    if(FAILED(hr =
            _ddrawStream->CreateSample(ddSurface, NULL, 0, &_ddrawSample))) {
        CleanUp();
        RaiseException_InternalError("Failed to CreateSample\n");
    }
    TraceTag((tagAMStreamLeak, "leak DDRAWSAMPLE %d created", _ddrawSample));

    if(FAILED(hr = _ddrawSample->GetSurface(&_ddrawSurface, NULL))) {
        CleanUp();
        RaiseException_InternalError("Failed to GetSurface\n");
    }
    TraceTag((tagAMStreamLeak, "leak DDRAWSURFACE %d created", _ddrawSurface));

    if(FAILED(hr = _multiMediaStream->SetState(STREAMSTATE_RUN))) {
        CleanUp();
        RaiseException_InternalError("Failed to SetState\n");
    }

        // XXX why is this call being made?  Is it prefetch?  Do we need it?
#ifdef TEST_GOING_AWAY
    if(_async)
        _ddrawSample->Update(SSUPDATE_ASYNC | SSUPDATE_CONTINUOUS,
            NULL, NULL, 0);
#endif
}


// cache intensions which will actually be late bound by VideoInitReader
// called by QuartzVideoReader::GetFrames()'s first use
// fails if video not on the stream
bool
QuartzVideoReader::VideoSetupReader(IAMMultiMediaStream *multiMediaStream,
    IAMClockAdjust *clockAdjust, DDSurface *surface, bool seekMode)
{
    HRESULT hr;
    bool status = true;

    _deleteable = false;

    if(surface) {
        Assert(!_surface); // this should be the first and only time through

        _surface = surface; // keep ptr so we can release the wrapper in cleanup
    }

    _multiMediaStream = multiMediaStream;  // we don't only, are only sharing
    _clockAdjust      = clockAdjust;

    { // determine _async and _seekable
        DWORD       dwStreamFlags;
        STREAM_TYPE streamType;

        if(FAILED(hr = _multiMediaStream->GetInformation(&dwStreamFlags,
                                                         &streamType))) {
            CleanUp();
            RaiseException_InternalError("Failed to GetInformation\n");
        }


        _async = (dwStreamFlags & (MMSSF_HASCLOCK | MMSSF_ASYNCHRONOUS)) ==
                        (MMSSF_HASCLOCK | MMSSF_ASYNCHRONOUS);

        _seekable = (dwStreamFlags & MMSSF_SUPPORTSEEK) ? true : false;
    }

    if(FAILED(hr =
        _multiMediaStream->GetMediaStream(MSPID_PrimaryVideo, &_mediaStream))) {
        CleanUp();
        RaiseException_InternalError("Failed to GetMediaStream\n");
    }
    TraceTag((tagAMStreamLeak, "leak MEDIASTREAM %d create", _mediaStream));

    if(FAILED(hr = _mediaStream->QueryInterface(IID_IDirectDrawMediaStream,
                                                (void**)&_ddrawStream))) {
        CleanUp();
        RaiseException_InternalError("Failed to GetMediaStream\n");
    }
    TraceTag((tagAMStreamLeak, "leak DDRAWSTREAM %d created", _ddrawStream));
   

    { // determine video dimensions
        DDSURFACEDESC ddsc;
        ddsc.dwSize = sizeof(DDSURFACEDESC);

        if(FAILED(hr = _ddrawStream->GetFormat(&ddsc, NULL, NULL, NULL))) {
            status = false;
        }
        else {
            _height = ddsc.dwHeight;
            _width  = ddsc.dwWidth;
        }
    }

    return(status);
}


void 
QuartzVideoReader::Seek(double time)
{
    if (!AlreadySeekedInSameTick()) {
        LONGLONG quartzTime = pcm.SecondsToQuartzTime(time);

        if (_multiMediaStream) {
            _multiMediaStream->Seek(quartzTime);
        }
    }
}


void
QuartzReader::CleanUp()
{
    if(_mediaStream) {
        int result = _mediaStream->Release();
        TraceTag((tagAMStreamLeak, "leak MEDIASTREAM %d released (%d)", 
            _mediaStream, result));
        _mediaStream = NULL;
    }

    if(_url) {
        delete(_url);
        _url = NULL;
    }

    if(_qURL) {
        delete[] _qURL;
        _qURL = NULL;
    }
}


void
QuartzVideoReader::CleanUp() 
{ // mutex scope
    //MutexGrabber mg(_readerMutex, TRUE); // Grab mutex

    //TraceTag((tagError, "QuartzVideoReader::CleanUp()  this=%x", this));

    if(_ddrawStream) {
        int result = _ddrawStream->Release();
        TraceTag((tagAMStreamLeak, "leak DDRAWSTREAM %d released (%d)", 
            _ddrawStream, result));
        _ddrawStream = NULL;
    }

    if(_ddrawSample) {
        // Stop any pending operation
        HRESULT hr = _ddrawSample->CompletionStatus(
                 COMPSTAT_WAIT | COMPSTAT_ABORT, INFINITE); 
        int result = _ddrawSample->Release();
        TraceTag((tagAMStreamLeak, "leak DDRAWSAMPLE %d released (%d)", 
            _ddrawSample, result));
        _ddrawSample = NULL;
    }

    if(_ddrawSurface) {
        int result = _ddrawSurface->Release();
        TraceTag((tagAMStreamLeak, "leak DDRAWSURFACE %d released (%d)", 
            _ddrawSurface, result));
        _ddrawSurface = NULL;
    }

    _surface.Release();

    _initialized = false;  // this to keep us safe if attempted to use
    _deleteable  = true;   // this is to allow potential avstream to be deleted
} // end mutex scope


void
QuartzVideoReader::Disable() 
{ // mutex scope

    // basically we can't just call CleanUp because the _ddrawSurface is
    // still in use...  (_initialized should save us from improper use!)

    if(_ddrawSample) {
        // Stop any pending operation
        HRESULT hr = _ddrawSample->CompletionStatus(
                 COMPSTAT_WAIT | COMPSTAT_ABORT, INFINITE); 
        int result =_ddrawSample->Release();
        TraceTag((tagAMStreamLeak, "leak DDRAWSAMPLE %d released (%d)", 
            _ddrawSample, result));
        _ddrawSample = NULL;
    }

    // NOTE: we are NOT _deleteable!
    _initialized = false;  // this to keep us safe if attempted to use
} // end mutex scope


void
QuartzVideoStream::CleanUp()
{
    QuartzVideoReader::CleanUp();
    QuartzMediaStream::CleanUp();

    if(_ddraw) {
        int result = _ddraw->Release();
        TraceTag((tagAMStreamLeak, "leak DDRAW %d released (%d)", _ddraw, result));
        _ddraw = NULL;
    }
}


void QuartzVideoReader::UpdateTimes(bool bJustSeeked, STREAM_TIME SeekTime)
{
    if(_hrCompStatus != S_OK && _hrCompStatus != MS_S_NOUPDATE) {
        _curSampleEnd = -1;    // BUGBUG -- What the heck am I thinking?
    } else {
        STREAM_TIME NewStartTime, NewEndTime;
        _ddrawSample->GetSampleTimes(&NewStartTime, &NewEndTime, 0);
        if (NewStartTime > SeekTime) {
            if (bJustSeeked) {
                NewStartTime = SeekTime;
            } else {
                if (NewStartTime > _curSampleEnd+1)
                    NewStartTime = _curSampleEnd+1;
            }
        }
        _curSampleStart = NewStartTime;
        _curSampleEnd   = NewEndTime;
        _curSampleValid = true;
    }
}


// XXX convert to PCM?
#define STREAM_TIME_TO_SECONDS(x) ((x) * 0.0000001)
#define SECONDS_TO_STREAM_TIME(x) ((x) * 10000000.0)


HRESULT 
QuartzVideoReader::GetFrame(double time, IDirectDrawSurface **ppSurface)
{
    if(!_initialized)
        VideoInitReader(GetCurrentViewport()->GetTargetPixelFormat());

    *ppSurface = NULL;

    STREAM_TIME SeekTime = SECONDS_TO_STREAM_TIME(time);

    // XXX I think this terminates previous pending renders...
    if(_async) {
        _hrCompStatus = _ddrawSample->CompletionStatus(COMPSTAT_NOUPDATEOK |
                                                     COMPSTAT_WAIT, INFINITE);
        UpdateTimes(false, SeekTime);
    }

    if(_async) {  // we are asynchronous (the hard way, no seeking!)
        if(!_curSampleValid || (_curSampleEnd < SeekTime)) {
            // determine what time AMstream thinks it is
            STREAM_TIME amstreamTime;
            HRESULT hr = _multiMediaStream->GetTime(&amstreamTime);
            STREAM_TIME delta = SeekTime - amstreamTime;

            TraceTag((tagAVmodeDebug, "GetFrame time %g", time));

#if DEBUG_ONLY_CODE
            char string[100];
#include <mmsystem.h>
            sprintf(string, "GetFrame time: d:%f==(%10d-%10d) %10d", 
                (double)(delta/10000.0), SeekTime, amstreamTime,
                 timeGetTime());
            TraceTag((tagAVmodeDebug, string));
#endif

            // tell AMstream what time we think it is
            if(_clockAdjust) // might be unavailable on old amstreams...
                _clockAdjust->SetClockDelta(delta); // cause them to sync up

            // AV clocked mode...
            _hrCompStatus = _ddrawSample->Update(SSUPDATE_ASYNC, NULL, NULL, 0);

            // if we wait 0 we can determine if the data was available
            // XXX err, no, can't wait 0, lets wait a reasonable worst case time
            // Well what we really want is for amstream to tell us if they 
            // have the data to decode, then we will wait, or if they don't
            // have the data we will use the cached image
            // XXX I should colour the cached image in debug mode!
            _hrCompStatus = _ddrawSample->CompletionStatus(COMPSTAT_WAIT, 300);

            switch(_hrCompStatus) {
                case 0: break;      // all is well

                case MS_S_PENDING: 
                case MS_S_NOUPDATE: 
                    TraceTag((tagAVmodeDebug, 
                        "QuartzAudioReader Completion Status:%s",
                        (hr==MS_S_PENDING)?"PENDING":"NOUPDATE"));
                    // Stop the pending operation
                    hr = _ddrawSample->CompletionStatus(
                             COMPSTAT_WAIT|COMPSTAT_ABORT, INFINITE); 

                    // video can still stall on audio...
                    SetStall(); // inform the reader that we stalled
                    TraceTag((tagAVmodeDebug, 
                        "QuartzVideoReader::GetFrame() STALLED"));
                break;

                case MS_S_ENDOFSTREAM: 
                    // _completed = true;
                break;

                default:
                    Assert(0);      // we don't anticipate this case!
                break;
            }

            UpdateTimes(false, SeekTime);
        }
    } 
    else { // !_asynch
        // XXX need some code to decide what to do if !_seekable...
        for(int count = 0; count < 10; count++) {
            // is the requested time within the current sample?
            if( _curSampleValid              &&
               (_curSampleStart <= SeekTime) &&
               ((_curSampleEnd >= SeekTime)||
               (_hrCompStatus == MS_S_ENDOFSTREAM)
               )) {
                TraceTag((tagAVmodeDebug, "GetFrame within existing frame"));
                break;
            }

            // are we beyond where we want to be?
            bool bJustSeeked = false;
            if( (!_curSampleValid) || (_hrCompStatus == MS_S_ENDOFSTREAM) ||
               (_curSampleStart > SeekTime) ||
               ((_curSampleEnd + (SECONDS_TO_STREAM_TIME(1)/4)) < SeekTime)){
                _hrCompStatus = _multiMediaStream->Seek(SeekTime);
                TraceTag((tagAVmodeDebug, "GetFrame seeking %d", SeekTime));

                if(FAILED(_hrCompStatus))
                    break;
                bJustSeeked = true;
            }
            _hrCompStatus = _ddrawSample->Update(0, NULL, NULL, 0);
            TraceTag((tagAVmodeDebug, "GetFrame updated %d", SeekTime));
            UpdateTimes(bJustSeeked, SeekTime);

            if(bJustSeeked)
                break;
        }

#if _DEBUG
    { // draw on the movie if we are not asynch
        HDC hdcSurface;
        // RECT rectangle = {1, 1, 10, 10};

        if(SUCCEEDED(_ddrawSurface->GetDC(&hdcSurface))) {
            //DrawRect(dc, &rectangle, 255, 0, 255, 0, 0, 0);
            TextOut(hdcSurface, 20, 20, "Synchronous seek mode", 19);
            _ddrawSurface->ReleaseDC(hdcSurface); // ALWAYS to bypass NT4.0 DDraw bug
        }

    }
#endif

    }

    if(SUCCEEDED(_hrCompStatus))
        *ppSurface = _ddrawSurface;

    return((_hrCompStatus == MS_S_NOUPDATE) ? S_OK : _hrCompStatus);
}


QuartzAudioReader::QuartzAudioReader(char *url, StreamType streamType) : 
    QuartzReader(url, streamType), 
    _audioStream(NULL), _audioSample(NULL), _audioData(NULL), _completed(false)
{
}


void
QuartzAudioReader::CleanUp()
{ // mutex scope
    MutexGrabber mg(_readerMutex, TRUE); // Grab mutex

    if(_audioData)   {
        int result = _audioData->Release();
        TraceTag((tagAMStreamLeak, "leak AUDIODATA %d released (%d)", 
            _audioData, result));
        _audioData = NULL;
    }

    if(_audioSample) {
        // Stop any pending operation
        HRESULT hr = _audioSample->CompletionStatus(
                 COMPSTAT_WAIT | COMPSTAT_ABORT, INFINITE); 
        int result = _audioSample->Release();
        TraceTag((tagAMStreamLeak, "leak AUDIOSAMPLE %d released (%d)", 
            _audioSample, result));
        _audioSample = NULL;
    }

    if(_audioStream) {
        int result =_audioStream->Release();
        TraceTag((tagAMStreamLeak, "leak AUDIOSTREAM %d released (%d)", 
            _audioStream, result));
        _audioStream = NULL;
    }

    _initialized = false;
    _deleteable  = true;

} // end mutex scope


void
QuartzAudioReader::Disable()
{ // mutex scope
    MutexGrabber mg(_readerMutex, TRUE); // Grab mutex

    // release the sample so that video may continue
    if(_audioSample) {
        // Stop any pending operation
        HRESULT hr = _audioSample->CompletionStatus(
                 COMPSTAT_WAIT | COMPSTAT_ABORT, INFINITE); 
        int result =_audioSample->Release();
        TraceTag((tagAMStreamLeak, "leak AUDIOSAMPLE %d released (%d)", 
            _audioSample, result));
        _audioSample = NULL;
    }

    _initialized = false;
    // NOTE: We are NOT deleteable.  We may still be held by a bufferElement!
} // end mutex scope


QuartzReader::QuartzReader(char *url, StreamType streamType) : 
    _streamType(streamType), _multiMediaStream(NULL), 
    _mediaStream(NULL), _deleteable(true), _initialized(false),
    _secondsRead(0.0), _stall(false), _clockAdjust(NULL), 
    _url(NULL), _qURL(NULL), _nextFrame(0)
{
    _url = CopyString(url);

    int numChars = strlen(url) + 1;
    _qURL = NEW WCHAR[numChars];
    MultiByteToWideChar(CP_ACP, 0, url, -1, _qURL, numChars);
}


double
QuartzReader::GetDuration()
{
    STREAM_TIME qTime;
    HRESULT hr;
    double seconds;

    Assert(_multiMediaStream);

    // Not all files will give us valid duration!
    if(FAILED(hr = _multiMediaStream->GetDuration(&qTime)))
        RaiseException_InternalError("Failed to GetDuration\n");
    // else if(hr==VFW_S_ESTIMATED) // some durations are estimated!

    if(hr != 1)
        seconds = pcm.QuartzTimeToSeconds(qTime);
    else
        seconds = HUGE_VAL;  // XXX what else can we do, say its unknown?

    return(seconds);
}

bool
QuartzAudioReader::AudioInitReader(IAMMultiMediaStream *multiMediaStream,
    IAMClockAdjust *clockAdjust)
{
    HRESULT hr;
    WAVEFORMATEX waveFormat;
    bool status = true;

    _deleteable  = false; // set this first

    _multiMediaStream = multiMediaStream;  // we don't only, are only sharing
    _clockAdjust      = clockAdjust;

    if(FAILED(hr = 
        _multiMediaStream->GetMediaStream(MSPID_PrimaryAudio, &_mediaStream)))
        RaiseException_InternalError("Failed to GetMediaStream\n");
    TraceTag((tagAMStreamLeak, "leak MEDIASTREAM %d create", _mediaStream));

    if(FAILED(hr = _mediaStream->QueryInterface(IID_IAudioMediaStream,
                                                (void**)&_audioStream)))
        RaiseException_InternalError("Failed to GetMediaStream\n");
    TraceTag((tagAMStreamLeak, "leak AUDIOSTREAM %d created", _audioStream));

    if(FAILED(hr = _audioStream->GetFormat(&waveFormat)))
        status = false;
    else {
        pcm.SetPCMformat(waveFormat);        // configure our PCM info
        pcm.SetNumberSeconds(GetDuration()); // length, too!

        if(FAILED(hr = CoCreateInstance(CLSID_AMAudioData, NULL, 
            CLSCTX_INPROC_SERVER, IID_IAudioData, (void **)&_audioData)))
            RaiseException_InternalError("Failed CoCreateInstance CLSID_AMAudioData\n");
        TraceTag((tagAMStreamLeak, "leak AUDIODATA %d created", _audioData));

        if(FAILED(hr = _audioData->SetFormat(&waveFormat)))
            RaiseException_InternalError("Failed to SetFormat\n");

        #ifdef USE_QUARTZ_EVENTS
        _event = CreateEvent(FALSE, NULL, NULL, FALSE);
        #endif USE_QUARTZ_EVENTS

        if(FAILED(hr = _audioStream->CreateSample(_audioData, 0, &_audioSample)))
            RaiseException_InternalError("Failed to CreateSample\n");
        TraceTag((tagAMStreamLeak, "leak AUDIOSAMPLE %d created", _audioSample));

        _initialized = true; // set this last
    }

    return(status);
}


// open an amstream shared for audio and video!
QuartzAVstream::QuartzAVstream(char *url) :
    AVquartzVideoReader(url, AVSTREAM), 
    AVquartzAudioReader(url, AVSTREAM), QuartzMediaStream(),
    _tickID(0), _seeked(0), _audioValid(true), _videoValid(true)
{
    MutexGrabber mg(_avMutex, TRUE); // Grab mutex
    HRESULT       hr;
    char          string[200];
    IDirectDraw  *ddraw = NULL;

    GetDirectDraw(&ddraw, NULL, NULL);

    Assert(QuartzMediaStream::_multiMediaStream);  // should be setup by base class initializer


    DWORD flags = AMMSF_STOPIFNOSAMPLES;
#ifdef USE_AMMSF_NOSTALL
    flags |= AMMSF_NOSTALL;
#endif
    // seems that we need to add video before audio for amstream to work!
    if(FAILED(hr = QuartzMediaStream::_multiMediaStream->AddMediaStream(ddraw,
                 &MSPID_PrimaryVideo, flags, NULL))) {
        CleanUp();
        RaiseException_InternalError("Failed to AddMediaStream amStream\n");
    }

    if(FAILED(hr = QuartzMediaStream::_multiMediaStream->AddMediaStream(NULL, 
                 &MSPID_PrimaryAudio, AMMSF_STOPIFNOSAMPLES, NULL))) {
        CleanUp();
        RaiseException_InternalError("Failed to AddMediaStream amStream\n");
    }

    // open it in clocked mode
    if(FAILED(hr = QuartzMediaStream::_multiMediaStream->OpenFile(
        AVquartzAudioReader::GetQURL(), NULL))) {
        TraceTag((tagError, "Quartz Failed to OpenFile <%s> %hr", url, hr));
        CleanUp();
        RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE, url);
    }

    if(!AudioInitReader(QuartzMediaStream::_multiMediaStream,
        QuartzMediaStream::_clockAdjust))
        _audioValid = false; // indicate audio steam not present
    if(!VideoSetupReader(QuartzMediaStream::_multiMediaStream, 
        QuartzMediaStream::_clockAdjust, NULL, false)) { // no seek, unknown surf
        _videoValid = false; // indicate video stream isn't there
    }

} // end mutex scope

bool
QuartzAVstream::AlreadySeekedInSameTick()
{
    MutexGrabber mg(_avMutex, TRUE); // Grab mutex

    bool result;
    
    if ((_seeked==0) || (_seeked != _tickID)) {
        _seeked = _tickID;
        result = false;
    } else {
        // multiple seek case, ignore
        result = true;
    }

    return result;
}

void
QuartzAVstream::SetTickID(DWORD id)
{
    MutexGrabber mg(_avMutex, TRUE); // Grab mutex

    _tickID = id;
}

void
QuartzAVstream::Release()
{
    bool terminate = false;

    { // mutex scope
    MutexGrabber mg(_avMutex, TRUE); // Grab mutex

    // determine if both audio and video are gone so we can destroy the object
    bool audioDeleteable = QuartzAudioReader::IsDeleteable();
    bool videoDeleteable = QuartzVideoReader::IsDeleteable();

    if(audioDeleteable && videoDeleteable)
       terminate = true;
    } // end mutex scope

    if(terminate) {
        TraceTag((tagAVmodeDebug, 
            "QuartzAVstream: Audio and Video Released; GOODBYE!"));
        QuartzAVstream::CleanUp(); // wash up
        delete this;               // then say GoodBye!
    }
}


void
QuartzAudioStream::Release()
{
    QuartzAudioStream::CleanUp(); // wash up
    delete this;                  // then say GoodBye!
}


void
QuartzVideoStream::Release()
{
    QuartzVideoStream::CleanUp(); // wash up
    delete this;                  // then say GoodBye!
}


void
QuartzReader::Release()
{
}


void
QuartzVideoReader::Release()
{
    QuartzVideoReader::CleanUp();
}


void
QuartzAudioReader::Release()
{
    QuartzAudioReader::CleanUp();
}


// open an amstream exclusively for audio!
QuartzAudioStream::QuartzAudioStream(char *url) : 
    QuartzAudioReader(url, ASTREAM), QuartzMediaStream()
{
    HRESULT hr;
    char string[200];

    Assert(QuartzMediaStream::_multiMediaStream);  // should be setup by base class initializer

    if(FAILED(hr = QuartzMediaStream::_multiMediaStream->AddMediaStream(NULL, 
                                                     &MSPID_PrimaryAudio, 
                                                     0, NULL))) {
        CleanUp();
        RaiseException_InternalError("Failed to AddMediaStream amStream\n");
        }

    if(FAILED(hr = QuartzMediaStream::_multiMediaStream->OpenFile(GetQURL(), 
                                        AMMSF_RUN | AMMSF_NOCLOCK))) {
        TraceTag((tagError, "Quartz Failed to OpenFile <%s> %hr\n", url, hr));
        CleanUp();
        RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE, url);
    }

    if(!AudioInitReader(QuartzMediaStream::_multiMediaStream,
        QuartzMediaStream::_clockAdjust)) {
        TraceTag((tagError, 
            "QuartzAudioStream: Audio stream failed to init"));
        CleanUp();
        RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE, url);
    }
}


void
QuartzAudioStream::CleanUp()
{
    QuartzAudioReader::CleanUp();
    QuartzMediaStream::CleanUp();
}


void
QuartzAVstream::CleanUp()
{
    QuartzAudioReader::CleanUp();
    QuartzVideoReader::CleanUp();
    QuartzMediaStream::CleanUp();
}


QuartzAudioStream::~QuartzAudioStream()
{
    CleanUp();
}


int
QuartzAudioStream::ReadFrames(int numSamples, unsigned char *buffer, 
    bool blocking_is_ignored)
{
    // NOTE: we are forcing blocking to true ignoring the blocking parameter!
    return(QuartzAudioReader::ReadFrames(numSamples, buffer, true));
}


void
QuartzAudioReader::SeekFrames(long frames)
{
    if (!AlreadySeekedInSameTick()) {
        LONGLONG quartzTime = pcm.FramesToQuartzTime(frames);

        _multiMediaStream->Seek(quartzTime);
        _nextFrame = frames + 1;
    }
}


int
QuartzAudioReader::ReadFrames(int samplesRequested, unsigned char *buffer,
    bool blocking)
{
    HRESULT hr, hr2;
    DWORD bytesRead;
    int framesRead = 0;
    long bytesRequested;

    Assert(_audioData); 
    Assert(_audioStream);
    Assert(_initialized);

    if(bytesRequested = pcm.FramesToBytes(samplesRequested)) {
        // setup a new audioSample each time to change ptr, size
        if(FAILED(hr = _audioData->SetBuffer(bytesRequested, buffer, 0)))
            RaiseException_InternalError("Failed to init\n");

        DWORD flags = blocking ? 0 : SSUPDATE_ASYNC;
        if(FAILED(hr = _audioSample->Update(flags, NULL, NULL, 0))) {
            if(hr != MS_E_BUSY) 
                RaiseException_InternalError("Failed to update\n");
        }

        // block for completion!
        //HANDLE         _event;
        //hr = WaitForSingleObject(_event, 500);  // for testing

        // XXX tune timeout!!
        hr = _audioSample->CompletionStatus(COMPSTAT_WAIT, 300); 
        // XXX maybe we should stop the pending update if we time out?
        switch(hr) {
            case 0: break;      // all is well

            case MS_S_PENDING: 
            case MS_S_NOUPDATE: 
                TraceTag((tagAVmodeDebug, 
                    "QuartzAudioReader Completion Status:%s",
                    (hr==MS_S_PENDING)?"PENDING":"NOUPDATE"));
                // Stop the pending operation
                hr = _audioSample->CompletionStatus(
                         COMPSTAT_WAIT|COMPSTAT_ABORT, INFINITE); 
                SetStall(); // inform the reader that we stalled
                TraceTag((tagAVmodeDebug, 
                    "QuartzAudioReader::ReadFrames() STALLED"));
            break;

            case MS_S_ENDOFSTREAM: 
                _completed = true; break;

            default:
                Assert(0);      // we don't anticipate this case!
            break;
        }

        _audioData->GetInfo(NULL, NULL, &bytesRead);
        framesRead = pcm.BytesToFrames(bytesRead);
        _nextFrame+= framesRead;
    }
    
    return(framesRead);
}


/**********************************************************************
Pan is not setup to be multiplicative as of now.  It directly maps to 
log units (dB).  This is OK since pan is not exposed.  We mainly use it
to assign sounds to channels within the implementation.

Pan ranges from -10000 to 10000, where -10000 is left, 10000 is right.
dsound actualy doesn't implement a true pan, more of a 'balance control'
is provided.  A true pan would equalize the total energy of the system
between the two channels as the pan==center of energy moves. Therefore
a value of zero gives both channels full on.
**********************************************************************/
int QuartzRenderer::dBToQuartzdB(double dB)
{
    // The units for DSound (and DShow) are 1/100 ths of a decibel. 
    return (int)fsaturate(-10000.0, 10000.0, dB * 100.0);
}


bool QuartzAVmodeSupport()
{
    // XXX Hmm.  How am I going to check for a current AMStream?
    // guess I can try QIing for clockAdjust...

    static int result = -1;  // default to not initialized

    if(result == -1) {
        HRESULT hr;
        IAMMultiMediaStream *multiMediaStream = NULL;
        IAMClockAdjust      *clockAdjust      = NULL;
        result = 1; // be optimistic

        // do the check
        if(FAILED(hr = CoCreateInstance(CLSID_AMMultiMediaStream, NULL, 
                         CLSCTX_INPROC_SERVER, IID_IAMMultiMediaStream, 
                         (void **)&multiMediaStream)))
            result = 0;
        TraceTag((tagAMStreamLeak, "leak MULTIMEDIASTREAM %d created", multiMediaStream));

        if(result) {
            if(FAILED(hr = multiMediaStream->QueryInterface(IID_IAMClockAdjust, 
                                            (void **)&clockAdjust))) 
                result = 0;
            TraceTag((tagAMStreamLeak, "leak CLOCKADJUST %d created", clockAdjust));
        }

        if(clockAdjust) {
            int result = clockAdjust->Release();
            TraceTag((tagAMStreamLeak, "leak CLOCKADJUST %d released (%d)", 
                clockAdjust, result));
        }

        if(multiMediaStream) {
            int result = multiMediaStream->Release();
            TraceTag((tagAMStreamLeak, "leak MULTIMEDIASTREAM %d released (%d)", 
                multiMediaStream, result));
        }
    }

    return(result==1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\helpds.cpp ===
#include "headers.h"
#include "appelles/common.h"
#include <wtypes.h>
#include <dsound.h>
#include <stdio.h>
#include <math.h>
#include "privinc/helpds.h"
#include "privinc/util.h"
#include "privinc/debug.h"
#include "privinc/registry.h"
#include "privinc/miscpref.h"
#include "privinc/pcm.h"
#include "privinc/hresinfo.h"

// definition of DSbuffer static members
int DSbuffer::_minDSfreq =    100; // these values come from dsound docs
int DSbuffer::_maxDSfreq = 100000;
int DSbuffer::_minDSpan  = -10000;
int DSbuffer::_maxDSpan  =  10000;
int DSbuffer::_minDSgain = -10000;
int DSbuffer::_maxDSgain =      0;

extern miscPrefType miscPrefs; // the structure setup in miscpref.cpp

void
DSbuffer::setPtr(int bytePosition)
{
    TraceTag((tagSoundDSound, "::setPtr %d", bytePosition));
    TDSOUND(_dsBuffer->SetCurrentPosition(bytePosition)); 
}


void
DSstaticBuffer::setPtr(int bytePosition)
{
    TraceTag((tagSoundDSound, "DSstaticBuffer(%#lx)::setPtr %d",
              _dsBuffer,
              bytePosition));
    
    // There appears to be a bug in dsound where if we do not stop the
    // sound before moving it sometimes will fail to play the sound.
    // We are not exactly sure about the failure but this seems to
    // make everything happy.
    
    TDSOUND(THR(_dsBuffer->Stop()));
    TDSOUND(THR(_dsBuffer->SetCurrentPosition(bytePosition))); 

    // one shot sounds will stop after the sound is played to the end
    if(playing && !_paused) {
        TraceTag((tagSoundDSound,
                  "DSstaticBuffer(%#lx)::setPtr PLAY",
                  _dsBuffer));

        TDSOUND(THR(_dsBuffer->Play(NULL, NULL, (_loopMode)?DSBPLAY_LOOPING:0)));
    }
    // XXX dsound really needs to give us a play at location...
}

/* dsound helper routines which should be in the dsoundbuffer base class    */
/* XXX: eventualy this stuff should be inherited into the other ds classes! */

// clone the buffer
DSstaticBuffer::DSstaticBuffer(DirectSoundProxy *dsProxy, 
                               IDirectSoundBuffer *donorBuffer)
: _dsProxy(NULL)
{
    TDSOUND(dsProxy->DuplicateSoundBuffer(donorBuffer, &_dsBuffer));

#if _DEBUG
    if(IsTagEnabled(tagSoundStats)) {
        printBufferCapabilities();        // What buffer did we get?
        printDScapabilities(dsProxy);     // What hw look like?
    }
#endif /* _DEBUG */

    duplicate = TRUE;           // gluh, gluh, we're a clone
}


// create new buffer, and copy samples to it
DSstaticBuffer::DSstaticBuffer(DirectSoundProxy *dsProxy, 
                               PCM *newPCM, unsigned char *samples)
: _dsProxy(NULL)
{
    Assert(newPCM->GetNumberBytes());
    pcm.SetPCMformat(newPCM); // setup our pcm format 

    CreateDirectSoundBuffer(dsProxy, false); // create secondary buffer

    // copy the snd's buffer to the dsBuffer (+ orig buffer freed)
    CopyToDSbuffer(samples, false, pcm.GetNumberBytes());

    _dsProxy = dsProxy;
}


/* 
Determine the best we can the 'best possible' primary buffer settings

XXX: Much of this code can not be realy tested w/o weird audio boards...
     S'pose we could simulate conditions...
*/
extern "C"
void
DSbufferCapabilities(DirectSoundProxy *dsProxy, int *channels, 
int *sampleBytes,  int *sampleRate)
{
    DSCAPS hwCapabilities;
    hwCapabilities.dwSize = sizeof(DSCAPS); // XXX why should this be needed?
    int frameRate = miscPrefs._frameRate;   // determine the desired frame rate

    TDSOUND(dsProxy->GetCaps((LPDSCAPS)&hwCapabilities));

    // try to get as close to cannonical rate (16bit 22050Hz Stereo unless
    // over-ridden using registry) as we can

    // determine if the HW supports stereo sound
    if(hwCapabilities.dwFlags & DSCAPS_PRIMARYSTEREO)
        *channels = 2; // stereo is supported
    else if(hwCapabilities.dwFlags & DSCAPS_PRIMARYMONO)
        *channels = 1; // only mono is supported
    else
        RaiseException_InternalError("No Stereo or Mono Audio support!\n"); 

    // determine if the HW supports 16 bit samples
    if(hwCapabilities.dwFlags & DSCAPS_PRIMARY16BIT)
        *sampleBytes = 2; // 16 bit samples are supported
    else if(hwCapabilities.dwFlags & DSCAPS_PRIMARY8BIT)
        *sampleBytes = 1; // 8 bit samples are supported
    else
        RaiseException_InternalError("No 16 or 8 bit sample Audio support!\n"); 


    // detemine if the desired frame rate is supported 
    if( (hwCapabilities.dwMinSecondarySampleRate <= frameRate) &&
        (hwCapabilities.dwMaxSecondarySampleRate >= frameRate))
        *sampleRate = frameRate; // samplerate supported
    else { // use the max supported rate!
        *sampleRate = hwCapabilities.dwMaxSecondarySampleRate;

        // XXX hack code to work around dsound bug on SB16
        if(hwCapabilities.dwMaxSecondarySampleRate==0)
            *sampleRate = frameRate;  // try forceing desired rate

        // lets detect the err
#if _DEBUG
       if(hwCapabilities.dwMaxSecondarySampleRate==0) {
           TraceTag((tagSoundErrors, "DSOUND BUG: dwMAXSecondarySampleRate==0"));
       }
#endif
    }
}


DSprimaryBuffer::DSprimaryBuffer(HWND hwnd, DirectSoundProxy *dsProxy) :
 DSbuffer()
{
    int probeChannels;
    int probeSampleBytes;
    int probeSampleRate;

    // Set Co-op level to priority so we may set the primary buffer format
    // attempt to determine best HW settings
    DSbufferCapabilities(dsProxy, &probeChannels, &probeSampleBytes,
        &probeSampleRate);

#if _DEBUG
    if(IsTagEnabled(tagSoundStats)) {
        char string[100];

        sprintf(string, "Primary buffer: %dHz %dbit %s\n", probeSampleRate,
            probeSampleBytes*8, (probeChannels==1)?"MONO":"STEREO"); 
        TraceTag((tagSoundStats, string));
    }


#endif /* _DEBUG */

    pcm.SetPCMformat(probeSampleBytes, probeChannels, probeSampleRate);
    pcm.SetNumberBytes(0); // Zero for the primary buffer

    TDSOUND(dsProxy->SetCooperativeLevel(hwnd, DSSCL_PRIORITY)); 

    // create primary buffer; thereby setting the output format!
    CreateDirectSoundBuffer(dsProxy, true);  // create primary buffer

    // play the primary buffer so they will not stop DMA during idle times
    // XXX Note: we might want to be more lazy about this...
    
    TDSOUND(_dsBuffer->Play(NULL, NULL, DSBPLAY_LOOPING)); // Must loop primary
}


void DSbuffer::initialize()  
{
    int frameRate   = miscPrefs._frameRate;   // determine desired frame rate
    int sampleBytes = miscPrefs._sampleBytes; // determine desired format

    // set the format sampleBytes, MONO, frameRate
    pcm.SetPCMformat(sampleBytes, 1, frameRate);

    playing             =                FALSE;
    _paused             =                FALSE;

    _currentAttenuation =                    0;
    _currentFrequency   =   pcm.GetFrameRate();
    _currentPan         =                    0;

    // setup buffer stats
    _firstStat          =                 TRUE;  // haven't collected stats yet
    _bytesConsumed      =                    0;

    _dsBuffer           =                 NULL;

    _allocated          =                 FALSE;
    duplicate           =                 FALSE;
    _loopMode           =                    0;
    _flushing           =                    0;

    tail                =                    0;

    outputFrequency     =                    0;

    _lastHead           =                    0;
    _firstStat          =                 FALSE;
}


void DSbuffer::SetGain(double dB_attenuation)
{
    int dsAttenuation = // convert to dSound 1/100th dB integer format
        saturate(_minDSgain, _maxDSgain, dBToDSounddB(dB_attenuation)); 

    TraceTag((tagSoundDSound, "::SetGain %d", dsAttenuation));

    // dd format is less granular than the internal fp examine dd for change
    if(_currentAttenuation!=dsAttenuation) {
        TDSOUND(_dsBuffer->SetVolume(dsAttenuation));
        _currentAttenuation = dsAttenuation;  // cache the devidedependent value
    }
}


void DSbuffer::SetPan(double dB_pan, int direction)
{
    int dsPan = direction * dBToDSounddB(-1.0 * dB_pan);

    TraceTag((tagSoundDSound, "::SetPan %d", dsPan));

    // dd format is less granular than the internal fp examine dd for change
    if(_currentPan != dsPan) {
        TDSOUND(_dsBuffer->SetPan(dsPan));
        _currentPan = dsPan;
    }
}


void DSbuffer::setPitchShift(int frequency)
{
// NOTE: This is the only post-init location where _paused is modified!!

    if(_currentFrequency != frequency) {
        if(frequency == 0) {
            TraceTag((tagSoundDSound, "::setPitchShift STOP (paused)"));
            TDSOUND(_dsBuffer->Stop());
            _paused = TRUE;
        }
        else {
            int freq = saturate(_minDSfreq, _maxDSfreq, frequency);
            TDSOUND(_dsBuffer->SetFrequency(freq));

            TraceTag((tagSoundDSound, "::setPitchShift freq=%d", freq));

            if(_paused) {
                TraceTag((tagSoundDSound, "::setPitchShift PLAY (resume)"));
                TDSOUND(_dsBuffer->Play( // resume the buffer
                    NULL, NULL, (_loopMode)?DSBPLAY_LOOPING:0));
                _paused = FALSE;
            }
        }

        _currentFrequency = frequency;
    }
}


void DSbuffer::play(int loop)
{
    if(!_paused) {
        TraceTag((tagSoundDSound, "::play PLAY"));
        TDSOUND(_dsBuffer->Play(NULL, NULL, (loop)?DSBPLAY_LOOPING:0));
    } else
        TraceTag((tagSoundDSound, "::play NOP (paused)!!!"));

    _loopMode = loop;
    _flushing =    0;       // reset flushing mode
     playing  = TRUE;
}


void DSbuffer::stop()
{
    if(_dsBuffer) {
        TraceTag((tagSoundDSound, "::stop STOP"));
        TDSOUND(_dsBuffer->Stop());
    }
    
    playing = FALSE;
}


int DSbuffer::isPlaying()
{
    // XXX this shouldn't side efect _playing!
    bool deadBuffer = false;
    DWORD status;

    TDSOUND(_dsBuffer->GetStatus(&status));

    if(status & DSBSTATUS_BUFFERLOST)
        RaiseException_InternalErrorCode(status, "Status: dsound bufferlost");

    if(!(status & DSBSTATUS_PLAYING))
        deadBuffer = TRUE;  // the buffer stopped

    TraceTag((tagSoundDSound, "::isPlaying %d", !deadBuffer));

    return(!deadBuffer);
}


int DSbuffer::bytesFree()
{
    DWORD head, head2;
    int bytesFree;

    TDSOUND(_dsBuffer->GetCurrentPosition(&head, &head2));

    bytesFree= head - tail;
    bytesFree+= (bytesFree<0)?pcm.GetNumberBytes():0;

    // XXX this is a terrible hack!
    if(!playing)
        bytesFree= (pcm.GetNumberBytes()/2) & 0xFFFFFFF8;

    return(bytesFree);
}


void DSbuffer::updateStats()
{
    // this needs to be polled to keep track of buffer statistics
    // should probably be called on every streaming write!
    
    // NOTE: This code assumes that it is called often enough that the buffer
    //       could not have 'wraped' since we last called it!

    DWORD currentHead, head2;
    int bytesConsumed;

    // get head position
    TDSOUND(_dsBuffer->GetCurrentPosition(&currentHead, &head2)); 

    // mutexed since can be called/polled from synth thread and sampling loop!
    { // mutex scope
        MutexGrabber mg(_byteCountLock, TRUE); // Grab mutex

        if(!_firstStat) {  // only can compute distance if we have a previous val!
            bytesConsumed   = currentHead - _lastHead;
            bytesConsumed  += (bytesConsumed<0)?pcm.GetNumberBytes():0;
            _bytesConsumed += bytesConsumed;  // track the total
        }
        else {
            _firstStat = FALSE;
        }

        _lastHead = currentHead; // save this value for next time
        // release mutex as we go out of scope
    }
}


Real DSbuffer::getMediaTime()
{
    LONGLONG bytesConsumed;

    { // mutex scope
        MutexGrabber mg(_byteCountLock, TRUE); // Grab mutex

        updateStats(); // freshen up the values!
        bytesConsumed = _bytesConsumed;
    } // release mutex as we go out of scope

    return(pcm.BytesToSeconds(bytesConsumed));  // return the mediaTime
}


// XXX note blocking, high, low-watermarks not implemented!
void
DSbuffer::writeBytes(void *buffer, int numBytesToXfer)
{
    CopyToDSbuffer((void *)buffer, tail, numBytesToXfer);
    tail = (tail + numBytesToXfer)%pcm.GetNumberBytes();
}


void
DSbuffer::writeSilentBytes(int numBytesToFill)
{
    // unsigned 8bit pcpcm!
    FillDSbuffer(tail, numBytesToFill, (pcm.GetSampleByteWidth()==1)?0x80:0x00);
    tail = (tail + numBytesToFill)%pcm.GetNumberBytes();
}


DSbuffer::~DSbuffer()
{
    if(_dsBuffer) {
        TDSOUND(_dsBuffer->Stop());  // always make sure they are stopped!
        int status = _dsBuffer->Release();
    }
}


/**********************************************************************
Create a stopped, cleared==silent dsound streaming secondary buffer of 
the desired rate and format.
**********************************************************************/
DSstreamingBuffer::DSstreamingBuffer(DirectSoundProxy *dsProxy, PCM *newPCM)
{
    // conservatively sz buffer due to jitter
    pcm.SetPCMformat(newPCM);
    pcm.SetNumberFrames(pcm.SecondsToFrames(0.5)); 

    tail = 0;  // XXX we should really servo the initial tail!

    _currentFrequency =  pcm.GetFrameRate(); // setup initial _currentFrequency

    // create secondary streaming buffer (must call after PCM setup!)
    CreateDirectSoundBuffer(dsProxy, false);  // create secondary buffer

    // silence buffer keeping in mind unsigned 8bit pcpcm!
    // XXX move this to a method soon!
    ClearDSbuffer(pcm.GetNumberBytes(), (pcm.GetSampleByteWidth()==1)?0x80:0x0); 
}


#ifdef _DEBUG
void 
DSbuffer::printBufferCapabilities()
{
    DSBCAPS bufferCapabilities;

    bufferCapabilities.dwSize = sizeof(DSBCAPS);

    TDSOUND(_dsBuffer->GetCaps((LPDSBCAPS)&bufferCapabilities));

    // XXX explore the bufferCapabilities structure
    printf("xfer-rate= %d, cpu=%d%, size:%d bytes, location: %s\n",
        bufferCapabilities.dwUnlockTransferRate,
        bufferCapabilities.dwPlayCpuOverhead,
        bufferCapabilities.dwBufferBytes,
        (bufferCapabilities.dwFlags & DSBCAPS_LOCHARDWARE)?
            "HW Buffer":"Main memory");
}

// XXX this method should be moved to the dsound device!
void 
printDScapabilities(DirectSoundProxy *dsProxy)
{
    DSCAPS dsc;

    dsc.dwSize = sizeof(dsc);
    dsProxy->GetCaps(&dsc);

    printf("free hw memory= %dkb, free hw buffers= %d\n",
        (dsc.dwFreeHwMemBytes+512)/1024, dsc.dwFreeHwMixingAllBuffers);
}
#endif


void
DSbuffer::CreateDirectSoundBuffer(DirectSoundProxy *dsProxy, bool primary)
{
    DSBUFFERDESC        dsbdesc;

    // Set up DSBUFFERDESC structure.
    memset(&dsbdesc, 0, sizeof(DSBUFFERDESC)); // Zero it out.
    dsbdesc.dwSize = sizeof(DSBUFFERDESC);

    dsbdesc.dwFlags = (primary) ? 
        DSBCAPS_PRIMARYBUFFER :  // primary buffer (no other flags)
        (
        // get pan, vol, freq controls explicitly DSBCAPS_CTRLDEFAULT was remove
        DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY
        | DSBCAPS_STATIC        //  downloadable buffers
        | DSBCAPS_LOCSOFTWARE   //  XXX for PDC, BLOCK HW BUFFERS! :(
                                //  (buffer dup. fails weirdly on AWE32)
        | DSBCAPS_GLOBALFOCUS   //  global focus requires DSound >= 3!
        );

    dsbdesc.dwBufferBytes =  pcm.GetNumberBytes();

    dsbdesc.lpwfxFormat = NULL; // must be null for primary buffers
    int result;

    if(primary) { // open up a primary buffer so we may set the format
        WAVEFORMATEX        pcmwf;

        // try to create buffer
        TDSOUND(dsProxy->CreateSoundBuffer(&dsbdesc, &_dsBuffer, NULL));

        // Setup format structure
        // XXX really should provide this capability in PCM class!
        memset(&pcmwf, 0, sizeof(PCMWAVEFORMAT));
        pcmwf.wFormatTag     = WAVE_FORMAT_PCM;
        pcmwf.nChannels      = (WORD)pcm.GetNumberChannels();
        pcmwf.nSamplesPerSec = pcm.GetFrameRate(); //they realy mean frames!
        pcmwf.nBlockAlign    = pcm.FramesToBytes(1);
        pcmwf.nAvgBytesPerSec= pcm.SecondsToBytes(1.0);
        pcmwf.wBitsPerSample = pcm.GetSampleByteWidth() * 8;

        TDSOUND(_dsBuffer->SetFormat(&pcmwf)); // set primary buffer format
    }
    else { // secondary buffer
        PCMWAVEFORMAT pcmwf;

        Assert(dsbdesc.dwBufferBytes);

        // Set up wave format structure.
        dsbdesc.lpwfxFormat = (LPWAVEFORMATEX)&pcmwf;
        memset(&pcmwf, 0, sizeof(PCMWAVEFORMAT));
        pcmwf.wf.wFormatTag     = WAVE_FORMAT_PCM;
        pcmwf.wf.nChannels      = (WORD)pcm.GetNumberChannels();
        pcmwf.wf.nSamplesPerSec = pcm.GetFrameRate(); // they realy mean frames!
        pcmwf.wf.nBlockAlign    = pcm.FramesToBytes(1);
        pcmwf.wf.nAvgBytesPerSec= pcm.SecondsToBytes(1.0);
        pcmwf.wBitsPerSample    = pcm.GetSampleByteWidth() * 8;

        // Create buffer.
        TDSOUND(dsProxy->CreateSoundBuffer(&dsbdesc, &_dsBuffer, NULL));
        
#if _DEBUG
        if(IsTagEnabled(tagSoundStats)) {
            printBufferCapabilities(); // What buffer did we get?
            printDScapabilities(dsProxy); // What hw look like?
        }
#endif /* _DEBUG */

    }
}


void
DSbuffer::ClearDSbuffer(int numBytes, char value)
{
    LPVOID  ptr1, ptr2;
    DWORD   bytes1, bytes2;

    // Obtain write ptr (beggining of buffer, whole buffer)
    TDSOUND(_dsBuffer->Lock(0, numBytes, &ptr1, &bytes1, &ptr2, &bytes2, NULL));
    
    memset((void *)ptr1, value, bytes1);     // clear 
    if(ptr2)
        memset((void *)ptr2, value, bytes2); // clear crumb

    TDSOUND(_dsBuffer->Unlock(ptr1, bytes1, ptr2, bytes2));
}


void
DSbuffer::CopyToDSbuffer(void *samples, int tail, int numBytes)
{
    LPVOID  ptr1, ptr2;
    DWORD   bytes1, bytes2;

    // Obtain write ptr (beggining of buffer, whole buffer)
    TDSOUND(_dsBuffer->Lock(tail, numBytes, &ptr1, &bytes1, &ptr2, &bytes2, 0));
    //XXX realy should catch err and try to restore the stolen buffer+retry

    memcpy((void *)ptr1, samples, bytes1);                    // copy samples
    if(ptr2)
        memcpy((void *)ptr2, (char *)samples+bytes1, bytes2); // copy crumb

    TDSOUND(_dsBuffer->Unlock(ptr1, bytes1, ptr2, bytes2));
}


void
DSbuffer::FillDSbuffer(int tail, int numBytes, char value)
{
    void   *ptr1, *ptr2;
    DWORD   bytes1, bytes2;

    // Obtain write ptr (beggining of buffer, whole buffer)
    TDSOUND(_dsBuffer->Lock(tail, numBytes, &ptr1, &bytes1,
                                   &ptr2, &bytes2, NULL));
    //XXX should catch err and try to restore the stolen buffer and retry...
    
    memset(ptr1, value, bytes1);

    if(ptr2)
        memset(ptr2, value, bytes2);  // fill crumb

    TDSOUND(_dsBuffer->Unlock(ptr1, bytes1, ptr2, bytes2));
}


/**********************************************************************
Pan is not setup to be multiplicative as of now.  It directly maps to 
log units (dB).  This is OK since pan is not exposed.  We mainly use it
to assign sounds to channels within the implementation.

Pan ranges from -10000 to 10000, where -10000 is left, 10000 is right.
dsound actualy doesn't implement a true pan, more of a 'balance control'
is provided.  A true pan would equalize the total energy of the system
between the two channels as the pan==center of energy moves. Therefore
a value of zero gives both channels full on.
**********************************************************************/
int DSbuffer::dBToDSounddB(double dB)
{
    // The units for DSound (and DShow) are 1/100 ths of a decibel. 
    int result = fsaturate(_minDSgain, -1.0 *_minDSgain, dB * 100.0);
    return(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\helpaa.cpp ===
/**********************************************************************
Audio Active helper functions
**********************************************************************/
#include "headers.h"
#include "appelles/common.h"
#include <wtypes.h>
#include <msimusic.h>
#include <stdio.h>
#include "privinc/debug.h"
#include "privinc/helpaa.h"
#include "privinc/except.h"
#include "privinc/resource.h"

AAengine::AAengine()
{
    _simpleInit      = NULL;  // null out all function pointers!
    _loadSectionFile = NULL;
    _setAAdebug      = NULL;
    _panic           = NULL;

    LoadDLL();    // cause the msimusic dll to be loaded and fn ptrs to be set
    SimpleInit(); // instantiate the engine
    _realTime = _engine->GetRealTime();  // handle to realTime object

#ifdef MESSWITHCLOCK
    _clock = realTime->GetClock();
    if(!_clock)
        RaiseException_InternalError("GetClock: Unknown Err");
#endif /* MESSWITHCLOCK */

    _currentRate = 0.0;
    _paused = TRUE;     // make sure we play it the first time
}


AAengine::~AAengine()
{
    int tmp;

    // stop the engine immediately (stops playing at next measure by default)
    if(_engine) {
        _engine->Stop(AAF_IMMEDIATE);
        _engine->Release(); // this releases all personalities, and styles
    }

    if(_realTime)
        tmp = _realTime->Release();

#ifdef DEALWITHCLOCK
    if(_clock)
        tmp = _clock->Release();     // release Clock
#endif /* DEALWITHCLOCK */

    if(_aaLibrary)
        FreeLibrary(_aaLibrary);     // decrement the msimusic.dll refcount
}


void AAengine::LoadDLL()
{
    // NOTE: This code contains munged C++ dll entrypoints!

    _aaLibrary = LoadLibrary("msimusic.dll");
    if(_aaLibrary == NULL)
        RaiseException_InternalError("Failed to LoadLibrary msimusic.dll\n");

    // load suceeded: set function pointers
    _simpleInit = 
        (SimpleInitFn)GetProcAddress(_aaLibrary, "_MusicEngineSimpleInit@12");
    if(!_simpleInit) 
        RaiseException_InternalError("Failed to find MusicEngineSimpleInit\n");
 
    _loadSectionFile = 
        (LoadSectionFn)GetProcAddress(_aaLibrary, "_LoadSectionFile@12");
    if(!_loadSectionFile) 
        RaiseException_InternalError("Failed to find LoadSectionFile\n");

    _setAAdebug = (SetAAdebugFn)GetProcAddress(_aaLibrary, "_SetAADebug@4");
    if(!_setAAdebug) 
        RaiseException_InternalError("Failed to find SetAADebug\n");
 
    _panic = (PanicFn)GetProcAddress(_aaLibrary, "_Panic@4");
    if(!_panic) 
        RaiseException_InternalError("Failed to find Panic\n");
 
}


void AAengine::SetGain(double gain)
{
    setAArelVolume(_realTime, gain);
}


void AAengine::SetRate(double rate)
{
    if(rate!=_currentRate) {
        if(rate==0.0) {
            // stop the sound
            Pause(); // stop realTime
            _paused = TRUE;
        }
        else {
            setAArelTempo(_realTime, rate);

            if(_paused) {
                // start it playing
                Resume(); // start realTime
                _paused = FALSE;
            }
        }
    _currentRate = rate;
    }
}


void
AAengine::Stop()
{
    stopAAengine(_engine, AAF_IMMEDIATE); // stop the engine
}


void
AAengine::Pause()
{
    // send an all notes off to all channels!
    Assert(_panic && "_panic not set; loadLibrary must have failed");
    switch(int status = _panic(_engine)) {
        case S_OK: TraceTag((tagSoundMIDI, "AMI Panic OK\n")); break;
        case E_INVALIDARG: RaiseException_InternalError("AMIPanic bad engine pointer\n");
        default: RaiseException_InternalError("AMI Panic Failed.\n");
    }

    // XXX Panic doesn't seem to be working so we will drop volume instead?
    // XXX Nah, lets manualy try sending all notes off???

    // stop the realTime object effectively pausing the engine
    switch(int status = _realTime->Stop()) {
        case S_OK: TraceTag((tagSoundMIDI, "_realTime->Stop OK\n")); break;
        default: RaiseException_InternalError("_realTime->Stop Failed.\n");
    }
}


void
AAengine::Resume()
{
    switch(int status = _realTime->Start()) {
        case S_OK: TraceTag((tagSoundMIDI, "_realTime->Play OK\n")); break;
        default: RaiseException_InternalError("_realTime->Play Failed.\n");
    }
}


void
AAengine::RegisterSink(IAANotifySink *sink)
{
registerAAsink(_engine, sink);
}


void 
AAengine::LoadSectionFile(char *fileName, IAASection **section)
{
    Assert(_loadSectionFile && 
           "_loadSectionFile not set; loadLibrary must have failed");

    switch(_loadSectionFile(_engine, fileName, section)) {
        case  S_OK:
            TraceTag((tagSoundMIDI, "LoadSectionFile: OK!"));
        break;

        // XXX NOTE: we get these on bad tempo'd MIDI files, too...
        case  E_OUTOFMEMORY:
            TraceTag((tagSoundMIDI,
                      "LoadSectionFile: out of memory > %s", fileName));
            RaiseException_InternalError(IDS_ERR_OUT_OF_MEMORY);
    
        case  E_INVALIDARG:
            TraceTag((tagSoundMIDI,
                      "LoadSectionFile: invalid argument > %s", fileName));
            RaiseException_InternalError(IDS_ERR_INVALIDARG);
    
        case  E_FAIL:
            TraceTag((tagSoundMIDI,
                      "LoadSectionFile: failed to load > %s", fileName));
            RaiseException_UserError(E_FAIL, IDS_ERR_SND_LOADSECTION_FAIL,fileName);
    
        default:
            TraceTag((tagSoundMIDI,
                      "LoadSectionFile: could not load section file > %s", fileName));
            RaiseException_UserError(E_FAIL, IDS_ERR_SND_LOADSECTION_FAIL,fileName);
    }
}


void 
AAengine::PlaySection(IAASection *section)
{
playAAsection(_engine, section);
}


void
AAengine::SimpleInit()
{
    int status;

    Assert(_simpleInit && "_simpleInit not set; loadLibrary must have failed");

    _engine = NULL; // they require the ptr to be initialized to zero!
    switch(status = _simpleInit(&_engine, NULL, NULL)) {
        case S_OK: TraceTag((tagSoundMIDI, "AAsimpleInit OK\n")); break;
        case E_OUTOFMEMORY: RaiseException_OutOfMemory
            ("MusicEngineSimpleInit: out of memory", 0); 
            //XXX we don't know sz of request so we return 0...
        case E_INVALIDARG:  RaiseException_InternalError
            ("MusicEngineSimpleInit: invalid arg");
        default: RaiseException_InternalError("AAsimpleInit Failed.  No MIDI\n");
        }

    Assert(_setAAdebug && "_setAAdebug not set; loadLibrary must have failed");
#if _DEBUG
    _setAAdebug(5);  // 3 send all error and warning messages to stdout
                     // 5 informational messages included
#else    
    _setAAdebug(0);  // no err messages sent to stdout (debug output window)
#endif /* _DEBUG */
}


extern "C" void 
stopAAengine(IAAEngine *engine, AAFlags mode)
{
    switch(engine->Stop(mode)) {
    case S_OK: TraceTag((tagSoundMIDI, "AA enine->Stop OK\n")); break;
    default:            RaiseException_InternalError
        ("AA engine->Stop(): Unknown Err");
    }
}


extern "C" void 
registerAAsink(IAAEngine *engine, IAANotifySink *sink)
{
    switch(engine->SetNotifySink(sink)) { // register notify sink
    case S_OK: TraceTag((tagSoundMIDI, "AA enine->SetNotifySink OK\n")); break;
    default:            RaiseException_InternalError
        ("AA engine->Stop(): Unknown Err");
    }
}


void playAAsection(IAAEngine *engine, IAASection *section)
{
    HRESULT err = engine->PlaySection(section, AAF_IMMEDIATE, 0);

    switch(err) {
        case  S_OK: TraceTag((tagSoundMIDI, "Play OK")); break;
        case  E_NOTIMPL: TraceTag((tagSoundErrors,
                            "Play E_NOTIMPL (audioActive is whacked!"));
        break;

        case  E_POINTER:
            TraceTag((tagSoundErrors, "Play: invalid section"));
            RaiseException_UserError("Play: invalid section");
        break;

        case  E_INVALIDARG:
            TraceTag((tagSoundErrors, "Play: invalid argument"));
            RaiseException_UserError(E_INVALIDARG,IDS_ERR_INVALIDARG);
        break;

        case  E_FAIL:
            TraceTag((tagSoundErrors, "Play: failed, section already playing"));
            RaiseException_UserError("Play: failed, section already playing");
        break;

        default:
            TraceTag((tagSoundErrors, "Play: Unknown Err (0x%0X)", err));
            RaiseException_UserError("Play: Unknown Err");
    }
}


// Move to a helper helper?
int clamp(int min, int max, int value)
{
int answer;

if(value>max)
    answer = max;
else if(value<min)
    answer = min;
else
    answer = value;

return(answer);
}


void setAArelVolume(IAARealTime *realTime, double volume)
{
int _volume = (int)(100.0*volume);

// XXX These values must be saturated to 0 - 200!
realTime->SetRelVolume(clamp(0, 200, _volume));

// XXX add fancy err checks!
}


void setAArelTempo(IAARealTime *realTime, double rate)
{
int _rate = (int)(100.0*rate);

// XXX These values must be saturated to 0 - 200!
realTime->SetRelTempo(clamp(0, 200, _rate));

// XXX add fancy err checks!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\htimer.cpp ===
/**********************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    This module contains the member functions for the HiresTimer class
    which manages the vaguaries of the systems PerformanceCounter!

    Test: Create empty file headers.h in \tmp.
    cl /Yd /Zi -D_TIMERTEST_ -I.. -I\tmp htimer.cpp

**********************************************************************/

#include <headers.h>

#ifdef _TIMERTEST_
#include <windows.h>
#include <stdio.h>
#define Assert(s)
#endif
#include "privinc/htimer.h"


class HiresTimerImpl : public HiresTimer {
  public:

    HiresTimerImpl();

    virtual double GetTime();
    virtual double GetFrequency();
    
    BOOL Supported() { return _supported; }
    
    void SetInitialTime(LONG hi, DWORD lo);
    void Reset();

  private:
    double UnmungeTime(LARGE_INTEGER newTime, LARGE_INTEGER initialTime,
       double frequency);

    LARGE_INTEGER _initialTime;
    double        _clockFrequency;      // in ticks per second
    BOOL _supported;
};


HiresTimerImpl::HiresTimerImpl()
{
// XXX LARGE_INTERGER: Ughh.  Cant we operate on long longs here?
    LARGE_INTEGER tmpTime;
    LARGE_INTEGER zeroTime = { 0, 0 };

    BOOL _supported = QueryPerformanceFrequency(&tmpTime);

    Assert(_supported && "Doesn't have hires timer, using GetTickCount");
    
    _clockFrequency   = UnmungeTime(tmpTime, zeroTime, 1.0);

    QueryPerformanceCounter(&_initialTime);  // to cut largeTime to 32bit!
}


void
HiresTimerImpl::Reset()
{ 
    LARGE_INTEGER tmpTime;

    QueryPerformanceCounter(&tmpTime);
    _initialTime.HighPart = tmpTime.HighPart;
    _initialTime.LowPart  = tmpTime.LowPart;
}


double
HiresTimerImpl::GetTime()
{
    double result;
    LARGE_INTEGER tmpTime;

    QueryPerformanceCounter(&tmpTime);
    result = UnmungeTime(tmpTime, _initialTime, _clockFrequency);

    return(result);
}


double
HiresTimerImpl::GetFrequency()
{
    return(_clockFrequency);
}


double
HiresTimerImpl::UnmungeTime(LARGE_INTEGER newTime,
                            LARGE_INTEGER initialTime,
                            double frequency)
{
    double whole;

    if (newTime.HighPart == initialTime.HighPart) {
        
        Assert(newTime.LowPart >= initialTime.LowPart);

        return (newTime.LowPart - initialTime.LowPart) / frequency;

    } else if (newTime.LowPart < initialTime.LowPart) {
        
        // Borrow one from the High Part.
        // Assuming unsigned long 32 bits.

        Assert(sizeof(unsigned long) == 4);

        // The compiler needs to do this first, otherwise possible
        // overflow. 
        unsigned long forceSubtract =
            0xFFFFFFFF - initialTime.LowPart;
        newTime.LowPart = 
            forceSubtract + newTime.LowPart + 1;
        newTime.HighPart =
            newTime.HighPart - initialTime.HighPart - 1;
    } else {
        newTime.LowPart = newTime.LowPart - initialTime.LowPart;
        newTime.HighPart -= initialTime.HighPart;
    }

    whole = newTime.LowPart + newTime.HighPart * 4294967296.0;

    return whole/frequency;
}


void
HiresTimerImpl::SetInitialTime(LONG hi, DWORD lo)
{
    _initialTime.HighPart = hi;
    _initialTime.LowPart = lo;
}


class LoresTimer : public HiresTimer {
  public:

    LoresTimer() : _lastTick(0), _curTime(0.0) { GetTime(); }

    void Reset() { _curTime = 0; }

    virtual double GetTime() {
        if (_curTime == 0.0 && _lastTick == 0) {
            _lastTick = GetTickCount () ;
        } else {
            DWORD curtick = GetTickCount () ;

            if (curtick >= _lastTick) {
                _curTime += ((double) (curtick - _lastTick)) / 1000 ;
            } else {
                _curTime +=
                    ((double) (curtick + (0xffffffff - _lastTick))) / 1000 ;
            }

            _lastTick = curtick ;
        }

        return _curTime;
    }
    
    // Don't know what to return.
    virtual double GetFrequency() { return 1.0; }

  private:
    DWORD _lastTick;
    double _curTime;
};


HiresTimer& CreateHiresTimer()
{
    HiresTimerImpl* timer = NEW HiresTimerImpl();

    if (timer->Supported())
        return *timer;
    else {
        delete timer;
        return *(NEW LoresTimer());
    }
}


void
TimeStamp::Reset()
{
    _timeStamp = GetCurrentTime();
}


double 
TimeStamp::GetTimeStamp() 
{
    Assert(_timeStamp != -1.0);
    return(_timeStamp);
}


double 
TimeStamp::GetAge() 
{
    Assert(_timeStamp != -1.0);
    return(GetCurrentTime() - _timeStamp);
}


#ifdef _TIMERTEST_
void test(HiresTimerImpl& timer)
{
    printf("%15.5f\n", timer.GetTime());
    Sleep(1000);
    printf("%15.5f\n", timer.GetTime());
}


void main()
{
    HiresTimerImpl timer;

    printf("frequency = %15.5f\n", timer.GetFrequency());

    test(timer);

    timer.SetInitialTime(1, 0xFFFFFFFF);

    test(timer);

    timer.Reset();

    test(timer);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\imgutil.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File:       imgutil.cpp
 *  Content:    Routines for loading image bitmaps
 *
 ***************************************************************************/
#include "headers.h"
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <string.h>
#include "privinc/urlbuf.h"
#include "privinc/except.h"
#include "privinc/resource.h"
#include "privinc/ddutil.h"
#include "privinc/debug.h"
#include "privinc/bbox2i.h"
#include "include/appelles/hacks.h"

#define IMGTYPE_UNKNOWN 0
#define IMGTYPE_BMP     1
#define IMGTYPE_GIF     2
#define IMGTYPE_JPEG    3

extern HBITMAP *LoadGifImage(LPCSTR szFileName,
                             IStream *stream,
                             int dx, int dy,
                             COLORREF **colorKeys, 
                             int *numGifs,
                             int **delays,
                             int *loop); // in loadgif.cpp

///////////////////////////////////////////////////////////////////////////
// Attempt to determine, from the supplied filename, what type of
// bitmap a file contains.
//
int _GetImageType(LPCSTR szFileName) {
  LPSTR pExt;
  int len;
  int result;

  result = IMGTYPE_UNKNOWN;

  if ((NULL == szFileName) || (0 == (len = lstrlen(szFileName)))) return result;

  pExt = StrRChrA(szFileName,NULL,'.');
  if (NULL == pExt) return result;

// Compare against known extensions that we don't punt to the plugin
// decoders 
//
  if (!lstrcmpi(pExt,".bmp")) result = IMGTYPE_BMP;
  else if (!lstrcmpi(pExt,".gif"))  result = IMGTYPE_GIF;
  else if (!lstrcmpi(pExt,".giff")) result = IMGTYPE_GIF;
  else if (!lstrcmpi(pExt,".jpg")) result = IMGTYPE_JPEG;
  else if (!lstrcmpi(pExt,".jpeg")) result = IMGTYPE_JPEG;

  return result;
}

///////////////////////////////////////////////////////////////////////////
HBITMAP * 
UtilLoadImage(LPCSTR szFileName,
              IStream * pstream,
              int dx,int dy,
              COLORREF **colorKeys, 
              int *numBitmaps,
              int **delays,
              int *loop){

    *numBitmaps = 1;
    *colorKeys = NULL;      
    HBITMAP bitmap = NULL;
    HBITMAP *bitmapArray = NULL;
    
    switch (_GetImageType(szFileName)) {
        
      case IMGTYPE_BMP:
        {

        bitmap = (HBITMAP) LoadImage(NULL,
                                     szFileName,
                                     IMAGE_BITMAP,
                                     dx, dy,
                                     LR_LOADFROMFILE|LR_CREATEDIBSECTION);
        }
        break;
        
      case IMGTYPE_GIF:
        // changes numBitmaps if needed
        {
            if(pstream) {
                
                /*  
                #if _DEBUGMEM                 
                static _CrtMemState diff, oldState, newState;
                _CrtMemCheckpoint(&oldState);
                #endif
                */

                bitmapArray = LoadGifImage(szFileName,
                                           pstream,                                           
                                           dx,dy,
                                           colorKeys,
                                           numBitmaps,
                                           delays,
                                           loop);

                /*
                #if _DEBUGMEM
                _CrtMemCheckpoint(&newState);
                _CrtMemDifference(&diff, &oldState, &newState);
                _CrtMemDumpStatistics(&diff);
                _CrtMemDumpAllObjectsSince(&oldState);                
                TraceTag((tagImport,
                  "%x and %x, are normal return arrays and not leaks",
                  delays,
                  bitmapArray));
                #endif
                */
            }
            break;
        }
      
      case IMGTYPE_JPEG:
      case IMGTYPE_UNKNOWN:
      default:
        break;
    }
    
    if((bitmapArray == NULL) && (bitmap == NULL))
        return NULL;

    //XXXX HACKHACKHACK return -1 to disable plugins
    if (bitmap == (HBITMAP)-1)
        return (HBITMAP*)-1;

    if((bitmapArray == NULL) && (bitmap != NULL)) {
        bitmapArray = (HBITMAP *)AllocateFromStore(sizeof(HBITMAP));
        bitmapArray[0] = bitmap;
    }
    
    return bitmapArray;
}


// Convert a DA Point to a discrete integer based point assuming that
// we have an image centered about the DA origin, and that the pixel
// width and height are as given.
void CenteredImagePoint2ToPOINT(Point2Value	*point, // in
                                LONG		 width, // in
                                LONG		 height, // in
                                POINT		*pPOINT) // out
{
    pPOINT->x = LONG(point->x * ViewerResolution()) + width / 2;
    pPOINT->y = height - (LONG(point->y * ViewerResolution()) + height / 2);
}


// Given a GDI point (pPOINT) on a width x height bitmap that is
// assumed to have referenceImg mapped to it, find the corresponding
// DA point (point2) on the reference image.  Note that the aspect
// ratio between the image and the width x height might be different
// and need to be compensated for.

void CenteredImagePOINTToPoint2(POINT		*pPOINT, // in
                                LONG		 width, // in
                                LONG		 height, // in
                                Image		*referenceImg, // in
                                Point2Value	*pPoint2) // out
{
    // GDI coord is positive down...
    Real pctFromTop = (Real)(pPOINT->y) / (Real)height;
    Real pctFromLeft = (Real)(pPOINT->x) / (Real)width;

    Bbox2 dstBox = referenceImg->BoundingBox();

    Real dstWidth = dstBox.Width();
    Real dstHeight = dstBox.Height();

    // Go from left (min)
    pPoint2->x = dstBox.min.x + pctFromLeft * dstWidth;

    // Go from top (max)
    pPoint2->y = dstBox.max.y - pctFromTop * dstHeight;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\hresinfo.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    This file contains a function that converts HRESULT values into an English
string (no localization).
*******************************************************************************/

#include "headers.h"
#include "privinc/hresinfo.h"
#include <dsound.h>
#include <dxterror.h>


/*****************************************************************************
Return the string describing the facility portion of the HRESULT.
*****************************************************************************/

static const char *FacilityString (HRESULT hresult)
{
    int code     = HRESULT_CODE (hresult);
    int facility = HRESULT_FACILITY (hresult);

    switch (facility)
    {
        case FACILITY_NULL:     return "None";
        case FACILITY_WINDOWS:  return "Windows";
        case FACILITY_WIN32:    return "Win32";
        case FACILITY_INTERNET: return "Internet";
        case FACILITY_ITF:      return "Interface";
        case FACILITY_STORAGE:  return "Storage";
        case FACILITY_RPC:      return "RPC";
        case FACILITY_CONTROL:  return "Control";
        case FACILITY_DISPATCH: return "Dispatch";

        case _FACDS:            return "DirectSound";

        // Direct3D uses the DirectDraw facility code; catch it here.

        case _FACDD:
            return ((700 <= code) && (code < 800))? "Direct3D" : "DirectDraw";
    }

    return "Unknown";
}



/*****************************************************************************
This routine checks the HRESULT return code from D3D functions.
*****************************************************************************/

HRESULT CheckReturnImpl
    #if _DEBUG
        (HRESULT hResult, char *file, int line, bool except)
    #else
        (HRESULT hResult, bool except)
    #endif
{
    Assert (FAILED(hResult));

    char buf[1024];

    int code = HRESULT_CODE(hResult);        // Error Code ID

    #if !_DEBUG
        buf[0] = 0;     // String is not used when not in dev debug.
    #else
    {
        HresultInfo *info = GetHresultInfo (hResult);

        if(info) {
            sprintf(buf, "%s[%d]:\n    %s, HRESULT %s\n    \"%s\"",
                file, line, FacilityString(hResult), 
                info->hresult_str, info->explanation);
        }
        else {
            sprintf(buf, "%s[%d]:\n    %s, HRESULT %08x",
                file, line, FacilityString(hResult), hResult);
        }
    }
    #endif

    if (except)
    {   RaiseException_InternalErrorCode (hResult, buf);
    }
    else
    {   AssertStr (0, buf);
    }

    return hResult;
}


#if DEVELOPER_DEBUG 

    // This is the lookup table for error strings.  The table is terminated
    // with a zero code (which means all OK).

HresultInfo errtable[] =
{
    /*************************/
    /*** DirectDraw Errors ***/
    /*************************/

    {DDERR_ALREADYINITIALIZED, "DDERR_ALREADYINITIALIZED",
        "This object is already initialized"},

    {DDERR_CANNOTATTACHSURFACE, "DDERR_CANNOTATTACHSURFACE",
        "This surface can not be attached to the requested surface"},

    {DDERR_CANNOTDETACHSURFACE, "DDERR_CANNOTDETACHSURFACE",
        "This surface can not be detached from the requested surface"},

    {DDERR_CURRENTLYNOTAVAIL, "DDERR_CURRENTLYNOTAVAIL",
        "Support is currently not available"},

    {DDERR_EXCEPTION, "DDERR_EXCEPTION",
        "An exception was encountered while performing the requested "
        "operation"},

    {DDERR_GENERIC, "DDERR_GENERIC",
        "Generic failure"},

    {DDERR_HEIGHTALIGN, "DDERR_HEIGHTALIGN",
        "Height of rectangle provided is not a multiple of required "
        "alignment"},

    {DDERR_INCOMPATIBLEPRIMARY, "DDERR_INCOMPATIBLEPRIMARY",
        "Unable to match primary surface creation request with existing "
        "primary surface"},

    {DDERR_INVALIDCAPS, "DDERR_INVALIDCAPS",
        "One or more of the caps bits passed to the callback are incorrect"},

    {DDERR_INVALIDCLIPLIST, "DDERR_INVALIDCLIPLIST",
        "DirectDraw does not support provided Cliplist"},

    {DDERR_INVALIDMODE, "DDERR_INVALIDMODE",
        "DirectDraw does not support the requested mode"},

    {DDERR_INVALIDOBJECT, "DDERR_INVALIDOBJECT",
        "DirectDraw received a pointer that was an invalid DIRECTDRAW object"},

    {DDERR_INVALIDPARAMS, "DDERR_INVALIDPARAMS",
        "One or more of the parameters passed to the callback function "
        "are incorrect"},

    {DDERR_INVALIDPIXELFORMAT, "DDERR_INVALIDPIXELFORMAT",
        "Pixel format was invalid as specified"},

    {DDERR_INVALIDRECT, "DDERR_INVALIDRECT",
        "Rectangle provided was invalid"},

    {DDERR_LOCKEDSURFACES, "DDERR_LOCKEDSURFACES",
        "Operation could not be carried out because one or more surfaces "
        "are locked"},

    {DDERR_NO3D, "DDERR_NO3D",
        "There is no 3D present"},

    {DDERR_NOALPHAHW, "DDERR_NOALPHAHW",
        "Operation could not be carried out because there is no alpha "
        "accleration hardware present or available"},

    {DDERR_NOCLIPLIST, "DDERR_NOCLIPLIST",
        "No clip list available"},

    {DDERR_NOCOLORCONVHW, "DDERR_NOCOLORCONVHW",
        "Operation could not be carried out because there is no color "
        "conversion hardware present or available"},

    {DDERR_NOCOOPERATIVELEVELSET, "DDERR_NOCOOPERATIVELEVELSET",
        "Create function called without DirectDraw object method "
        "SetCooperativeLevel being called"},

    {DDERR_NOCOLORKEY, "DDERR_NOCOLORKEY",
        "Surface doesn't currently have a color key"},

    {DDERR_NOCOLORKEYHW, "DDERR_NOCOLORKEYHW",
        "Operation could not be carried out because there is no "
        "hardware support of the destination color key"},

    {DDERR_NODIRECTDRAWSUPPORT, "DDERR_NODIRECTDRAWSUPPORT",
        "No DirectDraw support possible with current display driver"},

    {DDERR_NOEXCLUSIVEMODE, "DDERR_NOEXCLUSIVEMODE",
        "Operation requires the application to have exclusive mode "
        "but the application does not have exclusive mode"},

    {DDERR_NOFLIPHW, "DDERR_NOFLIPHW",
        "Flipping visible surfaces is not supported"},

    {DDERR_NOGDI, "DDERR_NOGDI",
        "There is no GDI present"},

    {DDERR_NOMIRRORHW, "DDERR_NOMIRRORHW",
        "Operation could not be carried out because there is "
        "no hardware present or available"},

    {DDERR_NOTFOUND, "DDERR_NOTFOUND",
        "Requested item was not found"},

    {DDERR_NOOVERLAYHW, "DDERR_NOOVERLAYHW",
        "Operation could not be carried out because there is "
        "no overlay hardware present or available"},

    {DDERR_NORASTEROPHW, "DDERR_NORASTEROPHW",
        "Operation could not be carried out because there is "
        "no appropriate raster op hardware present or available"},

    {DDERR_NOROTATIONHW, "DDERR_NOROTATIONHW",
        "Operation could not be carried out because there is "
        "no rotation hardware present or available"},

    {DDERR_NOSTRETCHHW, "DDERR_NOSTRETCHHW",
        "Operation could not be carried out because there is "
        "no hardware support for stretching"},

    {DDERR_NOT4BITCOLOR, "DDERR_NOT4BITCOLOR",
        "DirectDrawSurface is not in 4 bit color palette and "
        "the requested operation requires 4 bit color palette"},

    {DDERR_NOT4BITCOLORINDEX, "DDERR_NOT4BITCOLORINDEX",
        "DirectDrawSurface is not in 4 bit color index palette "
        "and the requested operation requires 4 bit color index palette"},

    {DDERR_NOT8BITCOLOR, "DDERR_NOT8BITCOLOR",
        "DirectDraw Surface is not in 8 bit color mode "
        "and the requested operation requires 8 bit color"},

    {DDERR_NOTEXTUREHW, "DDERR_NOTEXTUREHW",
        "Operation could not be carried out because there is "
        "no texture mapping hardware present or available"},

    {DDERR_NOVSYNCHW, "DDERR_NOVSYNCHW",
        "Operation could not be carried out because there is "
        "no hardware support for vertical blank synchronized operations"},

    {DDERR_NOZBUFFERHW, "DDERR_NOZBUFFERHW",
        "Operation could not be carried out because there is "
        "no hardware support for zbuffer blting"},

    {DDERR_NOZOVERLAYHW, "DDERR_NOZOVERLAYHW",
        "Overlay surfaces could not be z layered based on their "
        "BltOrder because the hardware does not support z layering of overlays"},

    {DDERR_OUTOFCAPS, "DDERR_OUTOFCAPS",
        "The hardware needed for the requested operation has "
        "already been allocated"},

    {DDERR_OUTOFMEMORY, "DDERR_OUTOFMEMORY",
        "DirectDraw does not have enough memory to perform the operation"},

    {DDERR_OUTOFVIDEOMEMORY, "DDERR_OUTOFVIDEOMEMORY",
        "DirectDraw does not have enough memory to perform the operation"},

    {DDERR_OVERLAYCANTCLIP, "DDERR_OVERLAYCANTCLIP",
        "hardware does not support clipped overlays"},

    {DDERR_OVERLAYCOLORKEYONLYONEACTIVE, "DDERR_OVERLAYCOLORKEYONLYONEACTIVE",
        "Can only have ony color key active at one time for overlays"},

    {DDERR_PALETTEBUSY, "DDERR_PALETTEBUSY",
        "Access to this palette is being refused because the palette "
        "is already locked by another thread"},

    {DDERR_COLORKEYNOTSET, "DDERR_COLORKEYNOTSET",
        "No src color key specified for this operation"},

    {DDERR_SURFACEALREADYATTACHED, "DDERR_SURFACEALREADYATTACHED",
        "This surface is already attached to the surface it is "
        "being attached to"},

    {DDERR_SURFACEALREADYDEPENDENT, "DDERR_SURFACEALREADYDEPENDENT",
        "This surface is already a dependency of the surface it "
        "is being made a dependency of"},

    {DDERR_SURFACEBUSY, "DDERR_SURFACEBUSY",
        "Access to this surface is being refused because the surface "
        "is already locked by another thread"},

    {DDERR_SURFACEISOBSCURED, "DDERR_SURFACEISOBSCURED",
        "Access to Surface refused because Surface is obscured"},

    {DDERR_SURFACELOST, "DDERR_SURFACELOST",
        "The DIRECTDRAWSURFACE object representing this surface "
        "should have Restore called on it.  Access to this surface is "
        "being refused because the surface is gone"},

    {DDERR_SURFACENOTATTACHED, "DDERR_SURFACENOTATTACHED",
        "The requested surface is not attached"},

    {DDERR_TOOBIGHEIGHT, "DDERR_TOOBIGHEIGHT",
        "Height requested by DirectDraw is too large"},

    {DDERR_TOOBIGSIZE, "DDERR_TOOBIGSIZE",
        "Size requested by DirectDraw is too large.  The individual height "
        "and width are OK"},

    {DDERR_TOOBIGWIDTH, "DDERR_TOOBIGWIDTH",
        "Width requested by DirectDraw is too large"},

    {DDERR_UNSUPPORTED, "DDERR_UNSUPPORTED",
        "Action not supported"},

    {DDERR_UNSUPPORTEDFORMAT, "DDERR_UNSUPPORTEDFORMAT",
        "FOURCC format requested is unsupported by DirectDraw"},

    {DDERR_UNSUPPORTEDMASK, "DDERR_UNSUPPORTEDMASK",
        "Bitmask in the pixel format requested is unsupported by DirectDraw"},

    {DDERR_VERTICALBLANKINPROGRESS, "DDERR_VERTICALBLANKINPROGRESS",
        "vertical blank is in progress"},

    {DDERR_WASSTILLDRAWING, "DDERR_WASSTILLDRAWING",
        "Informs DirectDraw that the previous Blt which is "
        "transfering information to or from this Surface is incomplete"},

    {DDERR_XALIGN, "DDERR_XALIGN",
        "Rectangle provided was not horizontally aligned on required boundary"},

    {DDERR_INVALIDDIRECTDRAWGUID, "DDERR_INVALIDDIRECTDRAWGUID",
        "The GUID passed to DirectDrawCreate is not a valid DirectDraw driver "
        "identifier"},

    {DDERR_DIRECTDRAWALREADYCREATED, "DDERR_DIRECTDRAWALREADYCREATED",
        "A DirectDraw object representing this driver has already been "
        "created for this process"},

    {DDERR_NODIRECTDRAWHW, "DDERR_NODIRECTDRAWHW",
        "A hardware only DirectDraw object creation was attempted "
        "but the driver did not support any hardware"},

    {DDERR_PRIMARYSURFACEALREADYEXISTS, "DDERR_PRIMARYSURFACEALREADYEXISTS",
        "This process already has created a primary surface"},

    {DDERR_NOEMULATION, "DDERR_NOEMULATION",
        "Software emulation not available"},

    {DDERR_REGIONTOOSMALL, "DDERR_REGIONTOOSMALL",
        "Region passed to Clipper::GetClipList is too small"},

    {DDERR_CLIPPERISUSINGHWND, "DDERR_CLIPPERISUSINGHWND",
        "An attempt was made to set a clip list for a clipper objec that is "
        "already monitoring an hwnd"},

    {DDERR_NOCLIPPERATTACHED, "DDERR_NOCLIPPERATTACHED",
        "No clipper object attached to surface object"},

    {DDERR_NOHWND, "DDERR_NOHWND",
        "Clipper notification requires an HWND or no HWND has previously "
        "been set as the CooperativeLevel HWND"},

    {DDERR_HWNDSUBCLASSED, "DDERR_HWNDSUBCLASSED",
        "HWND used by DirectDraw CooperativeLevel has been subclassed, "
        "this prevents DirectDraw from restoring state"},

    {DDERR_HWNDALREADYSET, "DDERR_HWNDALREADYSET",
        "The CooperativeLevel HWND has already been set.  It can not be "
        "reset while the process has surfaces or palettes created"},

    {DDERR_NOPALETTEATTACHED, "DDERR_NOPALETTEATTACHED",
        "No palette object attached to this surface"},

    {DDERR_NOPALETTEHW, "DDERR_NOPALETTEHW",
        "No hardware support for 16 or 256 color palettes"},

    {DDERR_BLTFASTCANTCLIP, "DDERR_BLTFASTCANTCLIP",
        "If a clipper object is attached to the source surface passed "
        "into a BltFast call"},

    {DDERR_NOBLTHW, "DDERR_NOBLTHW",
        "No blitter hardware"},

    {DDERR_NODDROPSHW, "DDERR_NODDROPSHW",
        "No DirectDraw ROP hardware"},

    {DDERR_OVERLAYNOTVISIBLE, "DDERR_OVERLAYNOTVISIBLE",
        "GetOverlayPosition called on a hidden overlay"},

    {DDERR_NOOVERLAYDEST, "DDERR_NOOVERLAYDEST",
        "GetOverlayPosition called on a overlay that "
        "UpdateOverlay has never been called on to establish a destination"},

    {DDERR_INVALIDPOSITION, "DDERR_INVALIDPOSITION",
        "The position of the overlay on the destination is "
        "no longer legal for that destination"},

    {DDERR_NOTAOVERLAYSURFACE, "DDERR_NOTAOVERLAYSURFACE",
        "Overlay member called for a non-overlay surface"},

    {DDERR_EXCLUSIVEMODEALREADYSET, "DDERR_EXCLUSIVEMODEALREADYSET",
        "An attempt was made to set the cooperative level when it was "
        "already set to exclusive"},

    {DDERR_NOTFLIPPABLE, "DDERR_NOTFLIPPABLE",
        "An attempt has been made to flip a surface that is not flippable"},

    {DDERR_CANTDUPLICATE, "DDERR_CANTDUPLICATE",
        "Can't duplicate primary & 3D surfaces, or surfaces that are "
        "implicitly created"},

    {DDERR_NOTLOCKED, "DDERR_NOTLOCKED",
        "Surface was not locked.  An attempt to unlock a surface that was "
        "not locked at all, or by this process, has been attempted"},

    {DDERR_CANTCREATEDC, "DDERR_CANTCREATEDC",
        "Windows can not create any more DCs"},

    {DDERR_NODC, "DDERR_NODC",
        "No DC was ever created for this surface"},

    {DDERR_WRONGMODE, "DDERR_WRONGMODE",
        "This surface can not be restored because it was created in a "
        "different mode"},

    {DDERR_IMPLICITLYCREATED, "DDERR_IMPLICITLYCREATED",
        "This surface can not be restored because it is an implicitly "
        "created surface"},

    {DDERR_NOTPALETTIZED, "DDERR_NOTPALETTIZED",
        "The surface being used is not a palette-based surface"},

    {DDERR_UNSUPPORTEDMODE, "DDERR_UNSUPPORTEDMODE",
        "The display is currently in an unsupported mode"},


    /******************/
    /*** D3D Errors ***/
    /******************/


    {D3DERR_BADMAJORVERSION, "D3DERR_BADMAJORVERSION",
        "Bad major version"},

    {D3DERR_BADMINORVERSION, "D3DERR_BADMINORVERSION",
        "Bad minor version"},

    {D3DERR_DEVICEAGGREGATED, "D3DERR_DEVICEAGGREGATED",
        "SetRenderTarget attempted on a device "
        "that was QI'd off the render target"},

    {D3DERR_EXECUTE_CREATE_FAILED, "D3DERR_EXECUTE_CREATE_FAILED",
        "Execute buffer create failed"},

    {D3DERR_EXECUTE_DESTROY_FAILED, "D3DERR_EXECUTE_DESTROY_FAILED",
        "Execute buffer destroy failed"},

    {D3DERR_EXECUTE_LOCK_FAILED, "D3DERR_EXECUTE_LOCK_FAILED",
        "Execute buffer lock failed"},

    {D3DERR_EXECUTE_UNLOCK_FAILED, "D3DERR_EXECUTE_UNLOCK_FAILED",
        "Execute buffer unlock failed"},

    {D3DERR_EXECUTE_LOCKED, "D3DERR_EXECUTE_LOCKED",
        "Execute buffer locked"},

    {D3DERR_EXECUTE_NOT_LOCKED, "D3DERR_EXECUTE_NOT_LOCKED",
        "Execute buffer not locked"},

    {D3DERR_EXECUTE_FAILED, "D3DERR_EXECUTE_FAILED",
        "Execute buffer execute failed"},

    {D3DERR_EXECUTE_CLIPPED_FAILED, "D3DERR_EXECUTE_CLIPPED_FAILED",
        "Execute buffer execute clipped failed"},

    {D3DERR_TEXTURE_NO_SUPPORT, "D3DERR_TEXTURE_NO_SUPPORT",
        "Texture not supported"},

    {D3DERR_TEXTURE_CREATE_FAILED, "D3DERR_TEXTURE_CREATE_FAILED",
        "Texture create failed"},

    {D3DERR_TEXTURE_DESTROY_FAILED, "D3DERR_TEXTURE_DESTROY_FAILED",
        "Texture destroy failed"},

    {D3DERR_TEXTURE_LOCK_FAILED, "D3DERR_TEXTURE_LOCK_FAILED",
        "Texture lock failed"},

    {D3DERR_TEXTURE_UNLOCK_FAILED, "D3DERR_TEXTURE_UNLOCK_FAILED",
        "Texture unlock failed"},

    {D3DERR_TEXTURE_LOAD_FAILED, "D3DERR_TEXTURE_LOAD_FAILED",
        "Texture load failed"},

    {D3DERR_TEXTURE_SWAP_FAILED, "D3DERR_TEXTURE_SWAP_FAILED",
        "Texture swap failed"},

    {D3DERR_TEXTURE_LOCKED, "D3DERR_TEXTURE_LOCKED",
        "Texture locked"},

    {D3DERR_TEXTURE_NOT_LOCKED, "D3DERR_TEXTURE_NOT_LOCKED",
        "Texture not locked"},

    {D3DERR_TEXTURE_GETSURF_FAILED, "D3DERR_TEXTURE_GETSURF_FAILED",
        "Texture get surface failed"},

    {D3DERR_MATRIX_CREATE_FAILED, "D3DERR_MATRIX_CREATE_FAILED",
        "Matrix create failed"},

    {D3DERR_MATRIX_DESTROY_FAILED, "D3DERR_MATRIX_DESTROY_FAILED",
        "Matrix destroy failedj"},

    {D3DERR_MATRIX_SETDATA_FAILED, "D3DERR_MATRIX_SETDATA_FAILED",
        "Matrix set data failed"},

    {D3DERR_MATRIX_GETDATA_FAILED, "D3DERR_MATRIX_GETDATA_FAILED",
        "Matrix get data failed"},

    {D3DERR_SETVIEWPORTDATA_FAILED, "D3DERR_SETVIEWPORTDATA_FAILED",
        "Set viewport data failed"},

    {D3DERR_INVALIDCURRENTVIEWPORT, "D3DERR_INVALIDCURRENTVIEWPORT", 
        "Current viewport is invalid"},

    {D3DERR_INVALIDPRIMITIVETYPE, "D3DERR_INVALIDPRIMITIVETYPE",
        "Primitive type is invalid"},

    {D3DERR_INVALIDVERTEXTYPE, "D3DERR_INVALIDVERTEXTYPE",
        "Vertex type is invalid"},

    {D3DERR_TEXTURE_BADSIZE, "D3DERR_TEXTURE_BADSIZE",
        "Texture has bad size"},

    {D3DERR_MATERIAL_CREATE_FAILED, "D3DERR_MATERIAL_CREATE_FAILED",
        "Material create failed"},

    {D3DERR_MATERIAL_DESTROY_FAILED, "D3DERR_MATERIAL_DESTROY_FAILED",
        "Material destroy failed"},

    {D3DERR_MATERIAL_SETDATA_FAILED, "D3DERR_MATERIAL_SETDATA_FAILED",
        "Material set data failed"},

    {D3DERR_MATERIAL_GETDATA_FAILED, "D3DERR_MATERIAL_GETDATA_FAILED",
        "Material get data failed"},

    {D3DERR_INVALIDPALETTE, "D3DERR_INVALIDPALETTE",
        "Color palette is bad"},

    {D3DERR_ZBUFF_NEEDS_SYSTEMMEMORY, "D3DERR_ZBUFF_NEEDS_SYSTEMMEMORY",
        "ZBuffer needs system memory"},

    {D3DERR_ZBUFF_NEEDS_VIDEOMEMORY, "D3DERR_ZBUFF_NEEDS_VIDEOMEMORY",
        "ZBuffer needs video memory"},

    {D3DERR_SURFACENOTINVIDMEM, "D3DERR_SURFACENOTINVIDMEM",
        "Surface is not in video memory"},

    {D3DERR_LIGHT_SET_FAILED, "D3DERR_LIGHT_SET_FAILED",
        "Light set failed"},

    {D3DERR_LIGHTHASVIEWPORT, "D3DERR_LIGHTHASVIEWPORT",
        ""},

    {D3DERR_LIGHTNOTINTHISVIEWPORT, "D3DERR_LIGHTNOTINTHISVIEWPORT",
        ""},

    {D3DERR_SCENE_IN_SCENE, "D3DERR_SCENE_IN_SCENE",
        "Scene in scene"},

    {D3DERR_SCENE_NOT_IN_SCENE, "D3DERR_SCENE_NOT_IN_SCENE",
        "Scene not in scene"},

    {D3DERR_SCENE_BEGIN_FAILED, "D3DERR_SCENE_BEGIN_FAILED",
        "Scene begin failed"},

    {D3DERR_SCENE_END_FAILED, "D3DERR_SCENE_END_FAILED",
        "Scene end failed"},

    {D3DERR_INBEGIN, "D3DERR_INBEGIN",
        ""},

    {D3DERR_NOTINBEGIN, "D3DERR_NOTINBEGIN",
        ""},

    {D3DERR_NOVIEWPORTS, "D3DERR_NOVIEWPORTS",
        ""},

    {D3DERR_VIEWPORTDATANOTSET, "D3DERR_VIEWPORTDATANOTSET",
        ""},

    {D3DERR_VIEWPORTHASNODEVICE, "D3DERR_VIEWPORTHASNODEVICE",
        ""},


    /*************************************/
    /*** Direct3D Retained-Mode Errors ***/
    /*************************************/

    {D3DRMERR_BADOBJECT, "D3DRMERR_BADOBJECT",
        "Object expected in argument"},

    {D3DRMERR_BADTYPE, "D3DRMERR_BADTYPE",
        "Bad argument type passed"},

    {D3DRMERR_BADALLOC, "D3DRMERR_BADALLOC",
        "Out of memory"},

    {D3DRMERR_FACEUSED, "D3DRMERR_FACEUSED",
        "Face already used in a mesh"},

    {D3DRMERR_NOTFOUND, "D3DRMERR_NOTFOUND",
        "Object not found in specified place"},

    {D3DRMERR_NOTDONEYET, "D3DRMERR_NOTDONEYET",
        "Unimplemented"},

    {D3DRMERR_FILENOTFOUND, "D3DRMERR_FILENOTFOUND",
        "File cannot be opened"},

    {D3DRMERR_BADFILE, "D3DRMERR_BADFILE",
        "Data file is corrupt or has incorrect format"},

    {D3DRMERR_BADDEVICE, "D3DRMERR_BADDEVICE",
        "Device is not compatible with renderer"},

    {D3DRMERR_BADVALUE, "D3DRMERR_BADVALUE",
        "Bad argument value passed"},

    {D3DRMERR_BADMAJORVERSION, "D3DRMERR_BADMAJORVERSION",
        "Bad DLL major version"},

    {D3DRMERR_BADMINORVERSION, "D3DRMERR_BADMINORVERSION",
        "Bad DLL minor version"},

    {D3DRMERR_UNABLETOEXECUTE, "D3DRMERR_UNABLETOEXECUTE",
        "Unable to carry out procedure"},

    {D3DRMERR_LIBRARYNOTFOUND, "D3DRMERR_LIBRARYNOTFOUND",
        "Library not found"},

    {D3DRMERR_INVALIDLIBRARY, "D3DRMERR_INVALIDLIBRARY",
        "Invalid library"},

    {D3DRMERR_PENDING, "D3DRMERR_PENDING",
        "Data required to supply the requested information "
        "has not finished loading"},

    {D3DRMERR_NOTENOUGHDATA, "D3DRMERR_NOTENOUGHDATA",
        "Not enough data has been loaded to perform the requested operation"},

    {D3DRMERR_REQUESTTOOLARGE, "D3DRMERR_REQUESTTOOLARGE",
        "An attempt was made to set a level of detail in a progressive mesh "
        "greater than the maximum available"},

    {D3DRMERR_REQUESTTOOSMALL, "D3DRMERR_REQUESTTOOSMALL",
        "An attempt was made to set the minimum rendering detail of a "
        "progressive mesh smaller than the detail in the base mesh "
        "(the minimum for rendering)"},

    {D3DRMERR_CONNECTIONLOST, "D3DRMERR_CONNECTIONLOST",
        "Data connection was lost during a load, clone, or duplicate"},

    {D3DRMERR_LOADABORTED, "D3DRMERR_LOADABORTED",
        "Load aborted"},

    {D3DRMERR_NOINTERNET, "D3DRMERR_NOINTERNET",
        "Not Internet"},

    {D3DRMERR_BADCACHEFILE, "D3DRMERR_BADCACHEFILE",
        "Bad cache file"},

    {D3DRMERR_BOXNOTSET, "D3DRMERR_BOXNOTSET",
        "An attempt was made to access a bounding box when no bounging box "
        "was set on the frame" },

    {D3DRMERR_BADPMDATA, "D3DRMERR_BADPMDATA",
        "The data in the .x file is corrupted or of an incorrect format.  "
        "The conversion to a progressive mesh succeeded but produced an "
        "invalid progressive mesh in the .x file" },

    {D3DRMERR_CLIENTNOTREGISTERED, "D3DRMERR_CLIENTNOTREGISTERED",
        "Client not registered"},

    {D3DRMERR_NOTCREATEDFROMDDS, "D3DRMERR_NOTCREATEDFROMDDS",
        "Not created from DDS"},

    {D3DRMERR_NOSUCHKEY, "D3DRMERR_NOSUCHKEY",
        "No such key"},

    {D3DRMERR_INCOMPATABLEKEY, "D3DRMERR_INCOMPATABLEKEY",
        "Incompatable key"},

    {D3DRMERR_ELEMENTINUSE, "D3DRMERR_ELEMENTINUSE",
        "Element in use"},


    /***************************/
    /*** Direct Sound Errors ***/
    /***************************/

    {DSERR_ALLOCATED, "DSERR_ALLOCATED",
        "resources already being used"},

    {DSERR_CONTROLUNAVAIL, "DSERR_CONTROLUNAVAIL",
        "control (vol,pan,etc.) requested by the caller not available"},

    {DSERR_INVALIDPARAM, "DSERR_INVALIDPARAM",
        "invalid parameter was passed to the returning function"},

    {DSERR_INVALIDCALL, "DSERR_INVALIDCALL",
        "call not valid for current state of object"},

    {DSERR_GENERIC, "DSERR_GENERIC",
        "undetermined error occured inside DSound subsystem"},

    {DSERR_PRIOLEVELNEEDED, "DSERR_PRIOLEVELNEEDED",
        "invalid priority level"},

    {DSERR_OUTOFMEMORY, "DSERR_OUTOFMEMORY",
        "Out of memory"},

    {DSERR_BADFORMAT, "DSERR_BADFORMAT",
        "PCM format not supported"},

    {DSERR_UNSUPPORTED, "DSERR_UNSUPPORTED",
        "The function called is not supported at this time"},

    {DSERR_NODRIVER, "DSERR_NODRIVER",
        "No sound driver is available for use"},

    {DSERR_NOINTERFACE, "DSERR_NODRIVER",
        "Requested COM interface not available"},

    {DSERR_ALREADYINITIALIZED, "DSERR_ALREADYINITIALIZED",
        "object already initialized"},

    {DSERR_NOAGGREGATION, "DSERR_NOAGGREGATION",
        "object does not support aggregation"},

    {DSERR_BUFFERLOST, "DSERR_BUFFERLOST",
        "buffer memory lost, must be restored"},

    {DSERR_OTHERAPPHASPRIO, "DSERR_OTHERAPPHASPRIO",
        "Another app has higher priority level causing failure"},

    {DSERR_UNINITIALIZED, "DSERR_UNINITIALIZED",
        "Direct Sound Object uninitialized"},

    
    /************************************/
    /*** DX2D/DXTRANSFORMS error msgs ***/
    /************************************/

    {DXTERR_UNINITIALIZED, "DXTERR_UNINITIALIZED",
     "The object (transform, surface, etc.) has not been properly initialized"},

    {DXTERR_ALREADY_INITIALIZED, "DXTERR_ALREADY_INITIALIZED",
     "The object (surface) has already been properly initialized"},

    {DXTERR_UNSUPPORTED_FORMAT, "DXTERR_UNSUPPORTED_FORMAT",
     "The caller has specified an unsupported format"},

    {DXTERR_COPYRIGHT_IS_INVALID, "DXTERR_COPYRIGHT_IS_INVALID",
     "The caller has specified an unsupported format"},

    {DXTERR_INVALID_BOUNDS, "DXTERR_INVALID_BOUNDS",
     "The caller has specified invalid bounds for this operation"},

    {DXTERR_INVALID_FLAGS, "DXTERR_INVALID_FLAGS",
     "The caller has specified invalid flags for this operation"},

    {DXT_S_HITOUTPUT, "DXT_S_HITOUTPUT",
     "The specified point intersects the generated output"},

    /************************************/
    /*** Miscellaneous Windows Errors ***/
    /************************************/

    {ERROR_INVALID_PARAMETER, "ERROR_INVALID_PARAMETER",
     "Invalid parameter" },

    {ERROR_NOT_ENOUGH_MEMORY, "ERROR_NOT_ENOUGH_MEMORY",
     "Insufficient memory available" },

    {ERROR_OUTOFMEMORY, "ERROR_OUTOFMEMORY", "Out of memory" },

    {E_NOINTERFACE, "E_NOINTERFACE", "No such interface supported" },

    {E_POINTER, "E_POINTER", "Invalid pointer" },

    {CLASS_E_CLASSNOTAVAILABLE, "CLASS_E_CLASSNOTAVAILABLE",
        "ClassFactory cannot supply requested class" },

    {0,0,0}
};



/*****************************************************************************
This function takes a return code and returns the corresponding error string.
*****************************************************************************/

HresultInfo *GetHresultInfo (HRESULT hresult)
{
    // Scan through the entries until we either hit the zero code, or until
    // we get a match.

    HresultInfo *hresinfo = errtable;

    while ((hresinfo->hresult != hresult) && (hresinfo->hresult != 0))
        ++ hresinfo;

    return (hresinfo->hresult) ? hresinfo : NULL;
}



/*****************************************************************************
This debugger-callable function dumps out information for a given HRESULT
value.
*****************************************************************************/

void hresult (HRESULT hresult)
{
    if (0 == hresult)
    {   OutputDebugString ("HRESULT 0x0 = NO_ERROR\n");
        return;
    }

    char outbuff[240];

    sprintf (outbuff, "HRESULT %08x [Facility 0x%x, Code 0x%x (%d)]\n",
        hresult, HRESULT_FACILITY(hresult),
        HRESULT_CODE(hresult), HRESULT_CODE(hresult));

    OutputDebugString (outbuff);

    // Find the matching hresinfo entry.

    HresultInfo *hresinfo = GetHresultInfo(hresult);

    if (hresinfo)
    {
        sprintf (outbuff, "    %s: %s\n    %s\n",
            FacilityString(hresult), hresinfo->hresult_str,
            hresinfo->explanation);
    }
    else
    {   sprintf (outbuff, "    Facility %s\n", FacilityString(hresult));
    }

    OutputDebugString (outbuff);
}


#endif /* DEVELOPER_DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\makefile.inc ===
!include $(ROOT)\src\make\make1.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\loadgif.cpp ===
#include "headers.h"

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <privinc/debug.h>
#include <privinc/ddutil.h>

/*-- 
Structs from IE img.hxx 
--*/

enum
{
    gifNoneSpecified =  0, // no disposal method specified
    gifNoDispose =      1, // do not dispose, leave the bits there
    gifRestoreBkgnd =   2, // replace the image with the background color
    gifRestorePrev =    3  // replace the image with the previous pixels
};

typedef struct _GCEDATA // data from GIF Graphic control extension
{
    unsigned int uiDelayTime;           // frame duration, initialy 1/100ths seconds
                                    // converted to milliseconds
    unsigned int uiDisposalMethod;      // 0 - none specified.
                                    // 1 - do not dispose - leave bits in place.
                                    // 2 - replace with background color.
                                    // 3 - restore previous bits
                                    // >3 - not yet defined
    BOOL                  fTransparent;         // TRUE is ucTransIndex describes transparent color
    unsigned char ucTransIndex;         // transparent index

} GCEDATA; 

typedef struct _GIFFRAME
{
    struct _GIFFRAME    *pgfNext;
    GCEDATA                             gced;           // animation parameters for frame.
    int                                 top;            // bounds relative to the GIF logical screen 
    int                                 left;
    int                                 width;
    int                                 height;
    unsigned char               *ppixels;       // pointer to image pixel data
    int                                 cColors;        // number of entries in pcolors
    PALETTEENTRY                *pcolors;
    PBITMAPINFO                 pbmi;
    HRGN                                hrgnVis;                // region describing currently visible portion of the frame
    int                                 iRgnKind;               // region type for hrgnVis
} GIFFRAME, *PGIFFRAME;

typedef struct {
    BOOL        fAnimating;                 // TRUE if animation is (still) running
    DWORD       dwLoopIter;                 // current iteration of looped animation, not actually used for Netscape compliance reasons
    _GIFFRAME * pgfDraw;                    // last frame we need to draw
    DWORD       dwNextTimeMS;               // Time to display pgfDraw->pgfNext, or next iteration
} GIFANIMATIONSTATE, *PGIFANIMATIONSTATE;

#define dwGIFVerUnknown     ((DWORD)0)   // unknown version of GIF file
#define dwGIFVer87a         ((DWORD)87)  // GIF87a file format
#define dwGIFVer89a        ((DWORD)89)  // GIF89a file format.

typedef struct _GIFANIMDATA
{
    BOOL                        fAnimated;                      // TRUE if cFrames and pgf define a GIF animation
    BOOL                        fLooped;                        // TRUE if we've seen a Netscape loop block
    BOOL                        fHasTransparency;       // TRUE if a frame is transparent, or if a frame does
                                        // not cover the entire logical screen.
    BOOL            fNoBWMapping;       // TRUE if we saw more than two colors in anywhere in the file.
    DWORD           dwGIFVer;           // GIF Version <see defines above> we need to special case 87a backgrounds
    unsigned short      cLoops;                         // A la Netscape, we will treat this as 
                                        // "loop forever" if it is zero.
    PGIFFRAME           pgf;                            // animation frame entries
    PALETTEENTRY        *pcolorsGlobal;         // GIF global colors - NULL after GIF prepared for screen
    PGIFFRAME       pgfLastProg;        // remember the last frame to be drawn during decoding
    DWORD           dwLastProgTimeMS;   // time at which pgfLastProg was displayed.

} GIFANIMDATA, *PGIFANIMDATA;

/** End Structs **/
 
#define MAXCOLORMAPSIZE     256

#define TRUE    1
#define FALSE   0

#define CM_RED      0
#define CM_GREEN    1
#define CM_BLUE     2

#define MAX_LWZ_BITS        12

#define INTERLACE       0x40
#define LOCALCOLORMAP   0x80
#define BitSet(byte, bit)   (((byte) & (bit)) == (bit))

#define LM_to_uint(a,b)         ((((unsigned int) b)<<8)|((unsigned int)a))

#define dwIndefiniteGIFThreshold 300    // 300 seconds == 5 minutes
                                        // If the GIF runs longer than
                                        // this, we will assume the author
                                        // intended an indefinite run.
#define dwMaxGIFBits 13107200           // keep corrupted GIFs from causing
                                        // us to allocate _too_ big a buffer.
                                        // This one is 1280 X 1024 X 10.

typedef struct _GIFSCREEN
{
        unsigned long Width;
        unsigned long Height;
        unsigned char ColorMap[3][MAXCOLORMAPSIZE];
        unsigned long BitPixel;
        unsigned long ColorResolution;
        unsigned long Background;
        unsigned long AspectRatio;
}
GIFSCREEN;

typedef struct _GIF89
{
        long transparent;
        long delayTime;
        long inputFlag;
        long disposal;
}
GIF89;

#define MAX_STACK_SIZE  ((1 << (MAX_LWZ_BITS)) * 2)
#define MAX_TABLE_SIZE  (1 << MAX_LWZ_BITS)
typedef struct _GIFINFO
{
    IStream *stream;
    GIF89 Gif89;
    long lGifLoc;
    long ZeroDataBlock;

/*
 **  Pulled out of nextCode
 */
    long curbit, lastbit, get_done;
    long last_byte;
    long return_clear;
/*
 **  Out of nextLWZ
 */
    unsigned short *pstack, *sp;
    long stacksize;
    long code_size, set_code_size;
    long max_code, max_code_size;
    long clear_code, end_code;

/*
 *   Were statics in procedures
 */
    unsigned char buf[280];
    unsigned short *table[2];
    long tablesize;
    long firstcode, oldcode;

} GIFINFO,*PGIFINFO;

/*
 DirectAnimation wrapper class for GIF info
*/
class CImgGif
{
   // Class methods
   public:
      CImgGif();
      ~CImgGif();

      unsigned char * ReadGIFMaster();
      BOOL Read(unsigned char *buffer, long len);
      long ReadColorMap(long number, unsigned char buffer[3][MAXCOLORMAPSIZE]);
      long DoExtension(long label);
      long GetDataBlock(unsigned char *buf);
      unsigned char * ReadImage(long len, long height, BOOL fInterlace, BOOL fGIFFrame);
      long readLWZ();
      long nextLWZ();
      long nextCode(long code_size);
      BOOL initLWZ(long input_code_size);
      unsigned short *  growStack();
      BOOL growTables();
      BITMAPINFO * FinishDithering();

   // Data members
   public:
      LPCSTR              _szFileName;
      BOOL                _fInterleaved;
      BOOL                _fInvalidateAll;
      int                 _yLogRow;
      GIFINFO             _gifinfo;
      GIFANIMATIONSTATE   _gas;
      GIFANIMDATA         _gad;
      PALETTEENTRY        _ape[256];
      int                 _xWidth;
      int                 _yHeight;
      LONG                _lTrans;
      BYTE *              _pbBits;

} GIFIMAGE;


CImgGif::CImgGif() {
   _gifinfo.pstack = NULL;
   _gifinfo.table[0] = NULL;
   _gifinfo.table[1] = NULL;
}

CImgGif::~CImgGif() {
   free(_gifinfo.pstack);
   free(_gifinfo.table[0]);
   free(_gifinfo.table[1]);
   PGIFFRAME nextPgf, curPgf;
   curPgf = _gad.pgf;
   while(curPgf != NULL) {
      nextPgf = curPgf->pgfNext;
      free(curPgf->ppixels);
      free(curPgf->pcolors);
      free(curPgf->pbmi);
      free(curPgf);
      curPgf = nextPgf;
   }
}

static int GetColorMode() { return 0; };

#ifndef DEBUG
#pragma optimize("t",on)
#endif

BOOL CImgGif::Read(unsigned char *buffer, long len)
{
   DWORD lenout;
   /* read len characters into buffer */
   _gifinfo.stream->Read(buffer,len,&lenout);

   return (lenout == len);
}

long CImgGif::ReadColorMap(long number, unsigned char buffer[3][MAXCOLORMAPSIZE])
{
        long i;
        unsigned char rgb[3];

        for (i = 0; i < number; ++i)
        {
                if (!Read(rgb, sizeof(rgb)))
                {
                        TraceTag((tagImageDecode, "bad gif colormap."));
                        RaiseException_UserError(E_FAIL, IDS_ERR_DECODER_FAILED,_szFileName);
                        //return (TRUE);
                }
                buffer[CM_RED][i] = rgb[0];
                buffer[CM_GREEN][i] = rgb[1];
                buffer[CM_BLUE][i] = rgb[2];
        }
        return FALSE;
}

long
CImgGif::GetDataBlock(unsigned char *buf)
{
   unsigned char count;

   count = 0;
   if (!Read(&count, 1))
   {
          return -1;
   }
   _gifinfo.ZeroDataBlock = count == 0;

   if ((count != 0) && (!Read(buf, count)))
   {
          return -1;
   }

   return ((long) count);
}

#define MIN_CODE_BITS 5
#define MIN_STACK_SIZE 64
#define MINIMUM_CODE_SIZE 2

BOOL CImgGif::initLWZ(long input_code_size)
{
   if(input_code_size < MINIMUM_CODE_SIZE)
     return FALSE;

   _gifinfo.set_code_size = input_code_size;
   _gifinfo.code_size = _gifinfo.set_code_size + 1;
   _gifinfo.clear_code = 1 << _gifinfo.set_code_size;
   _gifinfo.end_code = _gifinfo.clear_code + 1;
   _gifinfo.max_code_size = 2 * _gifinfo.clear_code;
   _gifinfo.max_code = _gifinfo.clear_code + 2;

   _gifinfo.curbit = _gifinfo.lastbit = 0;
   _gifinfo.last_byte = 2;
   _gifinfo.get_done = FALSE;

   _gifinfo.return_clear = TRUE;
    
    if(input_code_size >= MIN_CODE_BITS)
        _gifinfo.stacksize = ((1 << (input_code_size)) * 2);
    else
        _gifinfo.stacksize = MIN_STACK_SIZE;

        if ( _gifinfo.pstack != NULL )
                free( _gifinfo.pstack );
        if ( _gifinfo.table[0] != NULL  )
                free( _gifinfo.table[0] );
        if ( _gifinfo.table[1] != NULL  )
                free( _gifinfo.table[1] );

 
    _gifinfo.table[0] = 0;
    _gifinfo.table[1] = 0;
    _gifinfo.pstack = 0;

    _gifinfo.pstack = (unsigned short *) malloc((_gifinfo.stacksize)*sizeof(unsigned short));
    if(_gifinfo.pstack == 0){
        goto ErrorExit;
    }    
    _gifinfo.sp = _gifinfo.pstack;

    // Initialize the two tables.
    _gifinfo.tablesize = (_gifinfo.max_code_size);

    _gifinfo.table[0] = (unsigned short *) malloc((_gifinfo.tablesize)*sizeof(unsigned short));
    _gifinfo.table[1] = (unsigned short *) malloc((_gifinfo.tablesize)*sizeof(unsigned short));
    if((_gifinfo.table[0] == 0) || (_gifinfo.table[1] == 0)){
        goto ErrorExit;
    }

    return TRUE;

   ErrorExit:
    if(_gifinfo.pstack){
        free(_gifinfo.pstack);
        _gifinfo.pstack = 0;
    }

    if(_gifinfo.table[0]){
        free(_gifinfo.table[0]);
        _gifinfo.table[0] = 0;
    }

    if(_gifinfo.table[1]){
        free(_gifinfo.table[1]);
        _gifinfo.table[1] = 0;
    }

    return FALSE;
}

long CImgGif::nextCode(long code_size)
{
   static const long maskTbl[16] =
   {
          0x0000, 0x0001, 0x0003, 0x0007,
          0x000f, 0x001f, 0x003f, 0x007f,
          0x00ff, 0x01ff, 0x03ff, 0x07ff,
          0x0fff, 0x1fff, 0x3fff, 0x7fff,
   };
   long i, j, ret, end;
   unsigned char *buf = &_gifinfo.buf[0];

   if (_gifinfo.return_clear)
   {
          _gifinfo.return_clear = FALSE;
          return _gifinfo.clear_code;
   }

   end = _gifinfo.curbit + code_size;

   if (end >= _gifinfo.lastbit)
   {
          long count;

          if (_gifinfo.get_done)
          {
                  return -1;
          }
          buf[0] = buf[_gifinfo.last_byte - 2];
          buf[1] = buf[_gifinfo.last_byte - 1];

          if ((count = GetDataBlock(&buf[2])) == 0)
                  _gifinfo.get_done = TRUE;
          if (count < 0)
          {
                  return -1;
          }
          _gifinfo.last_byte = 2 + count;
          _gifinfo.curbit = (_gifinfo.curbit - _gifinfo.lastbit) + 16;
          _gifinfo.lastbit = (2 + count) * 8;

          end = _gifinfo.curbit + code_size;

   // Okay, bug 30784 time. It's possible that we only got 1
   // measly byte in the last data block. Rare, but it does happen.
   // In that case, the additional byte may still not supply us with
   // enough bits for the next code, so, as Mars Needs Women, IE
   // Needs Data.
   if ( end >= _gifinfo.lastbit && !_gifinfo.get_done )
   {
      // protect ourselve from the ( theoretically impossible )
      // case where between the last data block, the 2 bytes from
      // the block preceding that, and the potential 0xFF bytes in
      // the next block, we overflow the buffer.
      // Since count should always be 1,
      Assert ( count == 1 );
      // there should be enough room in the buffer, so long as someone
      // doesn't shrink it.
      if ( count + 0x101 >= sizeof( _gifinfo.buf ) )
      {
          Assert ( FALSE ); // 
          return -1;
      }

              if ((count = GetDataBlock(&buf[2 + count])) == 0)
                      _gifinfo.get_done = TRUE;
              if (count < 0)
              {
                      return -1;
              }
              _gifinfo.last_byte += count;
              _gifinfo.lastbit = _gifinfo.last_byte * 8;

              end = _gifinfo.curbit + code_size;
   }
   }

   j = end / 8;
   i = _gifinfo.curbit / 8;

   if (i == j)
          ret = buf[i];
   else if (i + 1 == j)
          ret = buf[i] | (((long) buf[i + 1]) << 8);
   else
          ret = buf[i] | (((long) buf[i + 1]) << 8) | (((long) buf[i + 2]) << 16);

   ret = (ret >> (_gifinfo.curbit % 8)) & maskTbl[code_size];

   _gifinfo.curbit += code_size;

        return ret;
}

// Grows the stack and returns the top of the stack.
unsigned short *
CImgGif::growStack()
{
    long index;
    unsigned short *lp;
    
        if (_gifinfo.stacksize >= MAX_STACK_SIZE) return 0;

    index = (_gifinfo.sp - _gifinfo.pstack);
    lp = (unsigned short *)realloc(_gifinfo.pstack, (_gifinfo.stacksize)*2*sizeof(unsigned short));
    if(lp == 0)
        return 0;
        
    _gifinfo.pstack = lp;
    _gifinfo.sp = &(_gifinfo.pstack[index]);
    _gifinfo.stacksize = (_gifinfo.stacksize)*2;
    lp = &(_gifinfo.pstack[_gifinfo.stacksize]);
    return lp;
}

BOOL
CImgGif::growTables()
{
    unsigned short *lp;

    lp = (unsigned short *) realloc(_gifinfo.table[0], (_gifinfo.max_code_size)*sizeof(unsigned short));
    if(lp == 0){
        return FALSE; 
    }
    _gifinfo.table[0] = lp;
    
    lp = (unsigned short *) realloc(_gifinfo.table[1], (_gifinfo.max_code_size)*sizeof(unsigned short));
    if(lp == 0){
        return FALSE; 
    }
    _gifinfo.table[1] = lp;

    return TRUE;

}

inline
long CImgGif::readLWZ()
{
   return((_gifinfo.sp > _gifinfo.pstack) ? *--(_gifinfo.sp) : nextLWZ());
}

#define CODE_MASK 0xffff
long CImgGif::nextLWZ()
{
        long code, incode;
        unsigned short usi;
        unsigned short *table0 = _gifinfo.table[0];
        unsigned short *table1 = _gifinfo.table[1];
        unsigned short *pstacktop = &(_gifinfo.pstack[_gifinfo.stacksize]);

        while ((code = nextCode(_gifinfo.code_size)) >= 0)
        {
                if (code == _gifinfo.clear_code)
                {
                        /* corrupt GIFs can make this happen */
                        if (_gifinfo.clear_code >= (1 << MAX_LWZ_BITS))
                        {
                                return -2;
                        }

                
                        _gifinfo.code_size = _gifinfo.set_code_size + 1;
                        _gifinfo.max_code_size = 2 * _gifinfo.clear_code;
                        _gifinfo.max_code = _gifinfo.clear_code + 2;

            if(!growTables())
                return -2;
                        
            table0 = _gifinfo.table[0];
            table1 = _gifinfo.table[1];

                        _gifinfo.tablesize = _gifinfo.max_code_size;


                        for (usi = 0; usi < _gifinfo.clear_code; ++usi)
                        {
                                table1[usi] = usi;
                        }
                        memset(table0,0,sizeof(unsigned short )*(_gifinfo.tablesize));
                        memset(&table1[_gifinfo.clear_code],0,sizeof(unsigned short)*((_gifinfo.tablesize)-_gifinfo.clear_code));
                        _gifinfo.sp = _gifinfo.pstack;
                        do
                        {
                                _gifinfo.firstcode = _gifinfo.oldcode = nextCode(_gifinfo.code_size);
                        }
                        while (_gifinfo.firstcode == _gifinfo.clear_code);

                        return _gifinfo.firstcode;
                }
                if (code == _gifinfo.end_code)
                {
                        long count;
                        unsigned char buf[260];

                        if (_gifinfo.ZeroDataBlock)
                        {
                                return -2;
                        }

                        while ((count = GetDataBlock(buf)) > 0)
                                ;

                        if (count != 0)
                        return -2;
                }

                incode = code;

                if (code >= _gifinfo.max_code)
                {
            if (_gifinfo.sp >= pstacktop){
                pstacktop = growStack();
                if(pstacktop == 0)
                    return -2;
                        }
                        *(_gifinfo.sp)++ = (unsigned short)((CODE_MASK ) & (_gifinfo.firstcode));
                        code = _gifinfo.oldcode;
                }

#if FEATURE_FAST
                // BUGBUG (andyp) easy speedup here for ie3.1 (too late for ie3.0):
                //
                // 1. move growStack code out of loop (use max 12-bit/4k slop).
                // 2. do "sp = _gifinfo.sp" so it will get enreg'ed.
                // 3. un-inline growStack (and growTables).
                // 4. change short's to int's (benefits win32) (esp. table1 & table2)
                // (n.b. int not long, so we'll keep win3.1 perf)
                // 5. change long's to int's (benefits win16) (esp. code).
                //
                // together these will make the loop very tight w/ everything kept
                // enregistered and no 66 overrides.
                //
                // one caveat is that on average this loop iterates 4x so it's
                // not clear how much the speedup will really gain us until we
                // look at the outer loop as well.
#endif
                while (code >= _gifinfo.clear_code)
                {
                        if (_gifinfo.sp >= pstacktop){
                pstacktop = growStack();
                if(pstacktop == 0)
                    return -2;
                        }
                        *(_gifinfo.sp)++ = table1[code];
                        if (code == (long)(table0[code]))
                        {
                                return (code);
                        }
                        code = (long)(table0[code]);
                }

        if (_gifinfo.sp >= pstacktop){
            pstacktop = growStack();
            if(pstacktop == 0)
                return -2;
        }
                _gifinfo.firstcode = (long)table1[code];
        *(_gifinfo.sp)++ = table1[code];

                if ((code = _gifinfo.max_code) < (1 << MAX_LWZ_BITS))
                {
                        table0[code] = (_gifinfo.oldcode) & CODE_MASK;
                        table1[code] = (_gifinfo.firstcode) & CODE_MASK;
                        ++_gifinfo.max_code;
                        if ((_gifinfo.max_code >= _gifinfo.max_code_size) && (_gifinfo.max_code_size < ((1 << MAX_LWZ_BITS))))
                        {
                                _gifinfo.max_code_size *= 2;
                                ++_gifinfo.code_size;
                                if(!growTables())
                                    return -2;
       
                table0 = _gifinfo.table[0];
                table1 = _gifinfo.table[1];

                // Tables have been reallocated to the correct size but initialization
                // still remains to be done. This initialization is different from
                // the first time initialization of these tables.
                memset(&(table0[_gifinfo.tablesize]),0,
                        sizeof(unsigned short )*(_gifinfo.max_code_size - _gifinfo.tablesize));

                memset(&(table1[_gifinfo.tablesize]),0,
                        sizeof(unsigned short )*(_gifinfo.max_code_size - _gifinfo.tablesize));

                _gifinfo.tablesize = (_gifinfo.max_code_size);


                        }
                }

                _gifinfo.oldcode = incode;

                if (_gifinfo.sp > _gifinfo.pstack)
                        return ((long)(*--(_gifinfo.sp)));
        }
        return code;
}

#ifndef DEBUG
// Return to default optimization flags
#pragma optimize("",on)
#endif

unsigned char *
CImgGif::ReadImage(long len, long height, BOOL fInterlace, BOOL fGIFFrame)
{
    unsigned char *dp, c;
    long v;
    long xpos = 0, ypos = 0, pass = 0;
    unsigned char *image;
    long padlen = ((len + 3) / 4) * 4;
    DWORD cbImage = 0;
    char buf[256]; // need a buffer to read trailing blocks ( up to terminator ) into
    //ULONG ulCoversImg = IMGBITS_PARTIAL;

    /*
       **  Initialize the Compression routines
     */
    if (!Read(&c, 1))
    {
        return (NULL);
    }

    /*
       **  If this is an "uninteresting picture" ignore it.
     */

     cbImage = padlen * height * sizeof(char);

     if (   cbImage > dwMaxGIFBits
        ||  (image = (unsigned char *) calloc(1, cbImage)) == NULL)
    {
         TraceTag((tagImageDecode, "Cannot allocate space for gif image data\n"));
         RaiseException_UserError(E_FAIL, IDS_ERR_OUT_OF_MEMORY);
        //return (NULL);
    }

        if (c == 1)
        {
                // Netscape seems to field these bogus GIFs by filling treating them
                // as transparent. While not the optimal way to simulate this effect,
                // we'll fake it by pushing the initial code size up to a safe value,
                // consuming the input, and returning a buffer full of the transparent
                // color or zero, if no transparency is indicated.
                if (initLWZ(MINIMUM_CODE_SIZE))
                        while (readLWZ() >= 0);
                else {
          TraceTag((tagImageDecode, "GIF: failed LZW decode.\n"));
          RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_szFileName);
        }

                if (_gifinfo.Gif89.transparent != -1)
                        FillMemory(image, cbImage, _gifinfo.Gif89.transparent);
                else // fall back on the background color 
                        FillMemory(image, cbImage, 0);
                
                return image;
        }
        else if (initLWZ(c) == FALSE)
        {
                free(image);
        TraceTag((tagImageDecode, "GIF: failed LZW decode.\n"));
        RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_szFileName);
        return NULL;
        }

    if (!fGIFFrame)
        _pbBits = image;

    if (fInterlace)
    {
        long i;
        long pass = 0, step = 8;

        if (!fGIFFrame && (height > 4))
            _fInterleaved = TRUE;

        for (i = 0; i < height; i++)
        {
//              message("readimage, logical=%d, offset=%d\n", i, padlen * ((height-1) - ypos));
            dp = &image[padlen * ((height-1) - ypos)];
            for (xpos = 0; xpos < len; xpos++)
            {
                if ((v = readLWZ()) < 0)
                    goto abort;

                *dp++ = (unsigned char) v;
            }
            ypos += step;
            while (ypos >= height)
            {
                if (pass++ > 0)
                    step /= 2;
                ypos = step / 2;
                /*if (!fGIFFrame && pass == 1)
                {
                    ulCoversImg = IMGBITS_TOTAL;
                }*/
            }
            if (!fGIFFrame)
            {
                _yLogRow = i;

                /*if ((i & PROG_INTERVAL) == 0)
                {
                    // Post ProgDraw (IE code has delay-logic)
                    OnProg(FALSE, ulCoversImg);
                }*/
            }
        }

        /*if (!fGIFFrame)
        {
            OnProg(TRUE, ulCoversImg);
        }*/

        if (!fGIFFrame && height <= 4)
        {
            _yLogRow = height-1;
        }
    }
    else
    {

        if (!fGIFFrame) 
            _yLogRow = -1;

        for (ypos = height-1; ypos >= 0; ypos--)
        {
            dp = &image[padlen * ypos];
            for (xpos = 0; xpos < len; xpos++)
            {
                if ((v = readLWZ()) < 0)
                    goto abort;

                *dp++ = (unsigned char) v;
            }
            if (!fGIFFrame)
            {
                _yLogRow++;
//                  message("readimage, logical=%d, offset=%d\n", _yLogRow, padlen * ypos);
                /*if ((_yLogRow & PROG_INTERVAL) == 0)
                {
                    // Post ProgDraw (IE code has delay-logic)
                    OnProg(FALSE, ulCoversImg);
                }*/
            }
        }

        /*if (!fGIFFrame)
        {
            OnProg(TRUE, ulCoversImg);
        }*/
    }

    // consume blocks up to image block terminator so we can proceed to the next image
    while (GetDataBlock((unsigned char *) buf) > 0)
                                ;
    return (image);

abort:
    /*if (!fGIFFrame)
        OnProg(TRUE, ulCoversImg);*/
    return NULL;
}

long CImgGif::DoExtension(long label)
{
    unsigned char buf[256];
    int count;

    switch (label)
    {
        case 0x01:              /* Plain Text Extension */
            break;
        case 0xff:              /* Application Extension */
            // Is it the Netscape looping extension
            count = GetDataBlock((unsigned char *) buf);
            if (count >= 11)
            {
                char *szNSExt = "NETSCAPE2.0";

                if ( memcmp( buf, szNSExt, strlen( szNSExt ) ) == 0 )
                { // if it has their signature, get the data subblock with the iter count
                    count = GetDataBlock((unsigned char *) buf);
                    if ( count >= 3 )
                    {
                        _gad.fLooped = TRUE;
                        _gad.cLoops = (buf[2] << 8) | buf[1];
                    }
                }
            }
            while (GetDataBlock((unsigned char *) buf) > 0)
                ;
            return FALSE;
            break;
        case 0xfe:              /* Comment Extension */
            while (GetDataBlock((unsigned char *) buf) > 0)
            {
                TraceTag((tagImageDecode, "GIF comment: %s\n", buf));                
            }
            return FALSE;
        case 0xf9:              /* Graphic Control Extension */
            count = GetDataBlock((unsigned char *) buf);
            if (count >= 3)
            {
                _gifinfo.Gif89.disposal = (buf[0] >> 2) & 0x7;
                _gifinfo.Gif89.inputFlag = (buf[0] >> 1) & 0x1;
                _gifinfo.Gif89.delayTime = LM_to_uint(buf[1], buf[2]);
                if ((buf[0] & 0x1) != 0)
                    _gifinfo.Gif89.transparent = buf[3];
                else
                    _gifinfo.Gif89.transparent = -1;
            }
            while (GetDataBlock((unsigned char *) buf) > 0)
                ;
            return FALSE;
        default:
            break;
    }

    while (GetDataBlock((unsigned char *) buf) > 0)
        ;

    return FALSE;
}

BOOL IsGifHdr(BYTE * pb)
{
    return(pb[0] == 'G' && pb[1] == 'I' && pb[2] == 'F'
        && pb[3] == '8' && (pb[4] == '7' || pb[4] == '9') && pb[5] == 'a');
}


PBITMAPINFO x_8BPIBitmap(int xsize, int ysize)
{
        PBITMAPINFO pbmi;

        if (GetColorMode() == 8)
        {
                pbmi = (PBITMAPINFO) calloc(1, sizeof(BITMAPINFOHEADER) + 256 * sizeof(WORD));
                if (!pbmi)
                {
                        return NULL;
                }
                pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                pbmi->bmiHeader.biWidth = xsize;
                pbmi->bmiHeader.biHeight = ysize;
                pbmi->bmiHeader.biPlanes = 1;
                pbmi->bmiHeader.biBitCount = 8;
                pbmi->bmiHeader.biCompression = BI_RGB;         /* no compression */
                pbmi->bmiHeader.biSizeImage = 0;                        /* not needed when not compressed */
                pbmi->bmiHeader.biXPelsPerMeter = 0;
                pbmi->bmiHeader.biYPelsPerMeter = 0;
                pbmi->bmiHeader.biClrUsed = 256;
                pbmi->bmiHeader.biClrImportant = 0;
        }
        else
        {
                pbmi = (PBITMAPINFO) calloc(1, sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));
                if (!pbmi)
                {
                        return NULL;
                }
                pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                pbmi->bmiHeader.biWidth = xsize;
                pbmi->bmiHeader.biHeight = ysize;
                pbmi->bmiHeader.biPlanes = 1;
                pbmi->bmiHeader.biBitCount = 8;
                pbmi->bmiHeader.biCompression = BI_RGB;         /* no compression */
                pbmi->bmiHeader.biSizeImage = 0;                        /* not needed when not compressed */
                pbmi->bmiHeader.biXPelsPerMeter = 0;
                pbmi->bmiHeader.biYPelsPerMeter = 0;
                pbmi->bmiHeader.biClrUsed = 256;
                pbmi->bmiHeader.biClrImportant = 0;
        }
        return pbmi;
}

/*
    For color images.
        This routine should only be used when drawing to an 8 bit palette screen.
        It always creates a DIB in DIB_PAL_COLORS format.
*/
PBITMAPINFO BIT_Make_DIB_PAL_Header(int xsize, int ysize)
{
        int i;
        PBITMAPINFO pbmi;
        WORD *pw;

        pbmi = x_8BPIBitmap(xsize, ysize);
        if (!pbmi)
        {
                return NULL;
        }

        pw = (WORD *) pbmi->bmiColors;

        for (i = 0; i < 256; i++)
        {
                pw[i] = (WORD)i;
        }

        return pbmi;
}

/*
    For color images.
        This routine is used when drawing to the nonpalette screens.  It always creates
        DIBs in DIB_RGB_COLORS format.
        If there is a transparent color, it is modified in the palette to be the
        background color for the window.
*/
PBITMAPINFO BIT_Make_DIB_RGB_Header_Screen(int xsize, int ysize,
                                           int cEntries, PALETTEENTRY * rgpe, int transparent)
{
        int i;
        PBITMAPINFO pbmi;

        pbmi = x_8BPIBitmap(xsize, ysize);
        if (!pbmi)
        {
                return NULL;
        }

        for (i = 0; i < cEntries; i++)
        {
                pbmi->bmiColors[i].rgbRed = rgpe[i].peRed;
                pbmi->bmiColors[i].rgbGreen = rgpe[i].peGreen;
                pbmi->bmiColors[i].rgbBlue = rgpe[i].peBlue;
                pbmi->bmiColors[i].rgbReserved = 0;
        }

/*
        if (transparent != -1)
        {
                COLORREF color;

                color = PREF_GetBackgroundColor();
                pbmi->bmiColors[transparent].rgbRed     = GetRValue(color);
                pbmi->bmiColors[transparent].rgbGreen   = GetGValue(color);
                pbmi->bmiColors[transparent].rgbBlue    = GetBValue(color);
        }
*/
        return pbmi;
}

unsigned char *
CImgGif::ReadGIFMaster()
{
        unsigned char buf[16];
        unsigned char c;
        unsigned char localColorMap[3][MAXCOLORMAPSIZE];
        long useGlobalColormap;
        long imageCount = 0;
        long imageNumber = 1;
        unsigned char *image = NULL;
        unsigned long i;
        GIFSCREEN GifScreen;
        long bitPixel;
        PGIFFRAME pgfLast = NULL;
        PGIFFRAME pgfNew;

        _gifinfo.ZeroDataBlock = 0;

        /*
         * Initialize GIF89 extensions
         */
        _gifinfo.Gif89.transparent = -1;
        _gifinfo.Gif89.delayTime = 5;
        _gifinfo.Gif89.inputFlag = -1;
        _gifinfo.Gif89.disposal = 0;
        _gifinfo.lGifLoc = 0;

        // initialize our animation fields
        _gad.fAnimated = FALSE;          // set to TRUE if we see more than one image
        _gad.fLooped = FALSE;                    // TRUE if we've seen a Netscape loop block
        _gad.fHasTransparency = FALSE; // until proven otherwise
    _gad.fNoBWMapping = FALSE;
    _gad.dwGIFVer = dwGIFVerUnknown;
        _gad.cLoops = 0;                
        _gad.pgf = NULL;
        _gad.pcolorsGlobal = NULL;

        if (!Read(buf, 6))
        {
      TraceTag((tagImageDecode, "GIF: error reading magic number\n"));
      RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_szFileName);
                //goto exitPoint;
        }

    if (!IsGifHdr(buf)) {
      TraceTag((tagImageDecode, "GIF: Malformed header\n"));
      RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_szFileName);
      //goto exitPoint;
    }

    _gad.dwGIFVer = (buf[4] == '7') ? dwGIFVer87a : dwGIFVer89a;

        if (!Read(buf, 7))
        {
      TraceTag((tagImageDecode, "GIF: failed to read screen descriptor\n"));
      RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_szFileName);
                //goto exitPoint;
        }

        GifScreen.Width = LM_to_uint(buf[0], buf[1]);
        GifScreen.Height = LM_to_uint(buf[2], buf[3]);
        GifScreen.BitPixel = 2 << (buf[4] & 0x07);
        GifScreen.ColorResolution = (((buf[4] & 0x70) >> 3) + 1);
        GifScreen.Background = buf[5];
        GifScreen.AspectRatio = buf[6];

        if (BitSet(buf[4], LOCALCOLORMAP))
        {                                                       /* Global Colormap */
                int scale = 65536 / MAXCOLORMAPSIZE;

                if (ReadColorMap(GifScreen.BitPixel, GifScreen.ColorMap))
                {
            TraceTag((tagImageDecode, "error reading global colormap\n"));
            RaiseException_UserError(E_FAIL, IDS_ERR_DECODER_FAILED,_szFileName);
                        //goto exitPoint;
                }
                for (i = 0; i < GifScreen.BitPixel; i++)
                {
                        int tmp;

                        tmp = (BYTE) (GifScreen.ColorMap[0][i]);
                        _ape[i].peRed = (BYTE) (GifScreen.ColorMap[0][i]);
                        _ape[i].peGreen = (BYTE) (GifScreen.ColorMap[1][i]);
                        _ape[i].peBlue = (BYTE) (GifScreen.ColorMap[2][i]);
                        _ape[i].peFlags = (BYTE) 0;
                }
                for (i = GifScreen.BitPixel; i < MAXCOLORMAPSIZE; i++)
                {
                        _ape[i].peRed = (BYTE) 0;
                        _ape[i].peGreen = (BYTE) 0;
                        _ape[i].peBlue = (BYTE) 0;
                        _ape[i].peFlags = (BYTE) 0;
                }
        }

        if (GifScreen.AspectRatio != 0 && GifScreen.AspectRatio != 49)
        {
                float r;
                r = ((float) (GifScreen.AspectRatio) + (float) 15.0) / (float) 64.0;
        TraceTag((tagImageDecode, "Warning: non-square pixels!\n"));
        }

        for (;; ) // our appetite now knows no bounds save termination or error
        {
                if (!Read(&c, 1))
                {
            TraceTag((tagImageDecode, "EOF / read error on image data\n"));
            RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_szFileName);
                        //goto exitPoint;
                }

                if (c == ';')
                {                                               /* GIF terminator */
                        if (imageCount < imageNumber)
                        {
                TraceTag((tagImageDecode, "No images found in file\n"));
                RaiseException_UserError(E_FAIL, IDS_ERR_DECODER_FAILED,_szFileName);
                                //goto exitPoint;
                        }
                        break;
                }

                if (c == '!')
                {                                               /* Extension */
                        if (!Read(&c, 1))
                        {
                TraceTag((tagImageDecode, "EOF / read error on extension function code\n"));
                RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_szFileName);
                                //goto exitPoint;
                        }
                        DoExtension(c);
                        continue;
                }

                if (c != ',')
                {                                               /* Not a valid start character */
                        break;
                }

                ++imageCount;

                if (!Read(buf, 9))
                {
             TraceTag((tagImageDecode, "couldn't read left/top/width/height\n"));
             RaiseException_UserError(E_FAIL, IDS_ERR_DECODER_FAILED,_szFileName);
                        //goto exitPoint;
                }

                useGlobalColormap = !BitSet(buf[8], LOCALCOLORMAP);

                bitPixel = 1 << ((buf[8] & 0x07) + 1);

                /*
                 * We only want to set width and height for the imageNumber
                 * we are requesting.
                 */
                if (imageCount == imageNumber)
                {
            // Replicate some of Netscape's special cases:
            // Don't use the logical screen if it's a GIF87a and the topLeft of the first image is at the origin.
            // Don't use the logical screen if the first image spills out of the logical screen.
            // These are artifacts of primitive authoring tools falling into the hands of hapless users.
            RECT    rectImage;  // rect defining bounds of GIF
            RECT    rectLS;     // rect defining bounds of GIF logical screen.
            RECT    rectSect;   // intersection of image an logical screen
            BOOL    fNoSpill;   // True if the image doesn't spill out of the logical screen
            BOOL    fGoofy87a;  // TRUE if its one of the 87a pathologies that Netscape special cases

            rectImage.left = LM_to_uint(buf[0], buf[1]);
            rectImage.top = LM_to_uint(buf[2], buf[3]);
            rectImage.right = rectImage.left + LM_to_uint(buf[4], buf[5]);
            rectImage.bottom = rectImage.top + LM_to_uint(buf[6], buf[7]);
            rectLS.left = rectLS.top = 0;
            rectLS.right = GifScreen.Width;
            rectLS.bottom = GifScreen.Height;
            IntersectRect( &rectSect, &rectImage, &rectLS );
            fNoSpill = EqualRect( &rectImage, &rectSect );
            fGoofy87a = FALSE;
            if (_gad.dwGIFVer == dwGIFVer87a)
            {
                // netscape ignores the logical screen if the image is flush against
                // either the upper left or lower right corner
                fGoofy87a = (rectImage.top == 0 && rectImage.left == 0) ||
                            (rectImage.bottom == rectLS.bottom &&
                             rectImage.right == rectLS.right);
            }   

            if (!fGoofy87a && fNoSpill)
            {
                            _xWidth = GifScreen.Width;  
                            _yHeight = GifScreen.Height;
            }
            else
            {
                // Something is amiss. Fall back to the image's dimensions.

                // If the sizes match, but the image is offset, or we're ignoring
                // the logical screen cuz it's a goofy 87a, then pull it back to 
                // to the origin
                if ((LM_to_uint(buf[4], buf[5]) == GifScreen.Width &&
                      LM_to_uint(buf[6], buf[7]) == GifScreen.Height) ||
                     fGoofy87a)
                {
                    buf[0] = buf[1] = 0; // left corner to zero
                    buf[2] = buf[3] = 0; // top to zero.
                }

                            _xWidth = LM_to_uint(buf[4], buf[5]);
                            _yHeight = LM_to_uint(buf[6], buf[7]);
            }

                        _lTrans = _gifinfo.Gif89.transparent;

            // Post WHKNOWN
            //OnSize(_xWidth, _yHeight, _lTrans);
                }

                if (!useGlobalColormap)
                {
                        if (ReadColorMap(bitPixel, localColorMap))
                        {
            TraceTag((tagImageDecode, "error reading local colormap\n"));
            RaiseException_UserError(E_FAIL, IDS_ERR_DECODER_FAILED,_szFileName);
                                //goto exitPoint;
                        }
                }

                // We allocate a frame record for each imag in the GIF stream, including
                // the first/primary image.
                pgfNew = (PGIFFRAME) calloc(1, sizeof(GIFFRAME));

                if ( pgfNew == NULL )
                {
            TraceTag((tagImageDecode, "not enough memory for GIF frame\n"));
            RaiseException_UserError(E_FAIL, IDS_ERR_OUT_OF_MEMORY);
                        //goto exitPoint;
                }

                if ( _gifinfo.Gif89.delayTime != -1 )
                {
                        // we have a fresh control extension for this block

            // convert to milliseconds
                        pgfNew->gced.uiDelayTime = _gifinfo.Gif89.delayTime * 10;


                        //REVIEW(seanf): crude hack to cope with 'degenerate animations' whose timing is set to some
                        //                               small value becaue of the delays imposed by Netscape's animation process
                        if ( pgfNew->gced.uiDelayTime <= 50 ) // assume these small values imply Netscape encoding delay
                                pgfNew->gced.uiDelayTime = 100;   // pick a larger value s.t. the frame will be visible
                        pgfNew->gced.uiDisposalMethod =  _gifinfo.Gif89.disposal;
                        pgfNew->gced.fTransparent = _gifinfo.Gif89.transparent != -1;
                        pgfNew->gced.ucTransIndex = (unsigned char)_gifinfo.Gif89.transparent;

                }
                else
                {   // fake one up s.t. GIFs that rely solely on Netscape's delay to time their animations will play
                    // The spec says that the scope of one of these blocks is the image after the block.
            // Netscape says 'until further notice'. So we play it their way up to a point. We
            // propagate the disposal method and transparency. Since Netscape doesn't honor the timing
            // we use our default timing for these images.
            pgfNew->gced.uiDelayTime = 100;
                        pgfNew->gced.uiDisposalMethod =  _gifinfo.Gif89.disposal;
                        pgfNew->gced.fTransparent = _gifinfo.Gif89.transparent != -1;
                        pgfNew->gced.ucTransIndex = (unsigned char)_gifinfo.Gif89.transparent;
                }

                pgfNew->top = LM_to_uint(buf[2], buf[3]);               // bounds relative to the GIF logical screen 
                pgfNew->left = LM_to_uint(buf[0], buf[1]);
                pgfNew->width = LM_to_uint(buf[4], buf[5]);
                pgfNew->height = LM_to_uint(buf[6], buf[7]);

                // Images that are offset, or do not cover the full logical screen are 'transparent' in the
                // sense that they require us to matte the frame onto the background.

        if (!_gad.fHasTransparency && (pgfNew->gced.fTransparent ||
                                       pgfNew->top != 0 ||
                                       pgfNew->left != 0 ||
                                       (UINT)pgfNew->width != (UINT)GifScreen.Width ||
                                       (UINT)pgfNew->height != (UINT)GifScreen.Height))
        {
            _gad.fHasTransparency = TRUE;
            //if (_lTrans == -1)
            //    OnTrans(0);
        }

                // We don't need to allocate a handle for the simple region case.
        // FrancisH says Windows is too much of a cheapskate to allow us the simplicity
        // of allocating the region once and modifying as needed. Well, okay, he didn't
        // put it that way...
                pgfNew->hrgnVis = NULL;
                pgfNew->iRgnKind = NULLREGION;

                if (!useGlobalColormap)
                {
            // remember that we saw a local color table and only map two-color images
            // if we have a homogenous color environment
            _gad.fNoBWMapping = _gad.fNoBWMapping || bitPixel > 2;

            // CALLOC will set unused colors to <0,0,0,0>
                        pgfNew->pcolors = (PALETTEENTRY *) calloc(MAXCOLORMAPSIZE, sizeof(PALETTEENTRY));
                        if ( pgfNew->pcolors == NULL )
                        {
                                DeleteRgn( pgfNew->hrgnVis );
                                free( pgfNew );

                TraceTag((tagImageDecode, "not enough memory for GIF frame colors\n"));
                RaiseException_UserError(E_FAIL, IDS_ERR_OUT_OF_MEMORY);
                                //goto exitPoint;
                        }
                        else
                        {
                                for (i = 0; i < (ULONG)bitPixel; ++i)
                                {
                                        pgfNew->pcolors[i].peRed = localColorMap[CM_RED][i];
                                        pgfNew->pcolors[i].peGreen = localColorMap[CM_GREEN][i];
                                        pgfNew->pcolors[i].peBlue = localColorMap[CM_BLUE][i];
                                }
                                pgfNew->cColors = bitPixel;
                        }
                }
                else
                {
                        if ( _gad.pcolorsGlobal == NULL )
                        { // Whoa! Somebody's interested in the global color table
              // CALLOC will set unused colors to <0,0,0,0>
                            _gad.pcolorsGlobal = (PALETTEENTRY *) calloc(MAXCOLORMAPSIZE, sizeof(PALETTEENTRY));
                                _gad.fNoBWMapping = _gad.fNoBWMapping || GifScreen.BitPixel > 2;
                if ( _gad.pcolorsGlobal != NULL )
                                {
                                        CopyMemory(_gad.pcolorsGlobal, _ape,
                                                                GifScreen.BitPixel * sizeof(PALETTEENTRY) );
                                }
                                else
                                {
                                        DeleteRgn( pgfNew->hrgnVis );
                                        free( pgfNew );
                    TraceTag((tagImageDecode, "not enough memory for GIF frame colors\n"));
                    RaiseException_UserError(E_FAIL, IDS_ERR_OUT_OF_MEMORY);
                                        //goto exitPoint;
                                }
                        }
                        pgfNew->cColors = GifScreen.BitPixel;
                        pgfNew->pcolors = _gad.pcolorsGlobal;
                }

                // Get this in here so that GifStrectchDIBits can use it during progressive
                // rendering.
                if ( _gad.pgf == NULL )
                        _gad.pgf = pgfNew;

        pgfNew->ppixels = ReadImage(LM_to_uint(buf[4], buf[5]), // width
                                    LM_to_uint(buf[6], buf[7]), // height
                                    BitSet(buf[8], INTERLACE),
                                    imageCount != imageNumber);

                if ( pgfNew->ppixels != NULL )
                {
                        // Oh JOY of JOYS! We got the pixels!
                        if (pgfLast != NULL)
            {
                int transparent = (pgfNew->gced.fTransparent) ? (int) pgfNew->gced.ucTransIndex : -1;

                            _gad.fAnimated = TRUE; // say multi-image == animated

                if (GetColorMode() == 8) // palettized, use DIB_PAL_COLORS
                {   // This will also dither the bits to the screen palette

                    pgfNew->pbmi = BIT_Make_DIB_PAL_Header(pgfNew->width, pgfNew->height);
                    //if (x_Dither(pgfNew->ppixels, pgfNew->pcolors, pgfNew->width, pgfNew->height, transparent))
                    //    goto exitPoint;
                }
                else // give it an RGB header
                {
                    pgfNew->pbmi = BIT_Make_DIB_RGB_Header_Screen(
                        pgfNew->width,
                        pgfNew->height,
                        pgfNew->cColors, pgfNew->pcolors,
                        transparent);
                }

                // Okay, so we've done any mapping on the GIFFRAME, so there's
                // no need to keep the pcolors around.  Let's go can clear out
                // the pcolors.
                // REVIEW(seanf): This assumes a common palette is used by all
                // clients of the image
                if ( pgfNew->pcolors != NULL && pgfNew->pcolors != _gad.pcolorsGlobal )
                    free( pgfNew->pcolors );
                pgfNew->pcolors = NULL;

                pgfLast->pgfNext = pgfNew;

                // Do something to here to get the new frame on the screen.

                _fInvalidateAll = TRUE;
                //super::OnProg(FALSE, IMGBITS_TOTAL);
            }
                        else
                        { // first frame
                                _gad.pgf = pgfNew;

                _gad.pgfLastProg = pgfNew;
                _gad.dwLastProgTimeMS = 0;
                // set up a temporary animation state for use in progressive draw
                _gas.fAnimating = TRUE; 
                _gas.dwLoopIter = 0;
                _gas.pgfDraw = pgfNew;

                                if ( imageCount == imageNumber )
                                        image = pgfNew->ppixels;
                        }
                        pgfLast = pgfNew;
                }

                // make the _gifinfo.Gif89.delayTime stale, so we know if we got a new
                // GCE for the next image
                _gifinfo.Gif89.delayTime = -1;

        }

        if ( imageCount > imageNumber )
                _gad.fAnimated = TRUE; // say multi-image == animated

#ifdef FEATURE_GIF_ANIMATION_LONG_LOOP_GOES_INFINITE
    // RAID #23709 - If an animation is sufficiently long, we treat it as indefinite...
    // Indefinite stays indefinite.
    // 5/29/96 - JCordell sez we shouldn't introduce this gratuitous NS incompatibility.
    //           We'll keep it around inside this ifdef in case we decide we want it.
    if ( _gad.fLooped &&
        (_gad.dwLoopDurMS * _gad.cLoops) / 1000 > dwIndefiniteGIFThreshold ) // if longer than five minutes
        _gad.cLoops = 0; // set to indefinite looping.
#endif // FEATURE_GIF_ANIMATION_LONG_LOOP_GOES_INFINITE

//exitPoint:
        return image;
}

BITMAPINFO *
CImgGif::FinishDithering()
{
    BITMAPINFO * pbmi;
    
    if (GetColorMode() == 8)
    {
        pbmi = BIT_Make_DIB_PAL_Header(_gad.pgf->width, _gad.pgf->height);
    }
    else
    {
        pbmi = BIT_Make_DIB_RGB_Header_Screen(_gad.pgf->width, _gad.pgf->height,
               _gad.pgf->cColors, _gad.pgf->pcolors, _lTrans);
    }

    return pbmi;
}


HBITMAP* LoadGifImage( LPCSTR szFileName,
                       IStream *stream,                       
                       int dx, int dy,
                       COLORREF **colorKeys,
                       int *numBitmaps,
                       int **delays,
                       int *loop)
{
   /* 
      The odd approach here lets us keep the original IE GIF code unchanged while removing
      DA specific inserts (except error reporting). The progressive rendering and palette 
      dithering found in the IE code is also not supported yet.
   */
   CImgGif gifimage;
   gifimage._szFileName = szFileName;
   gifimage._gifinfo.stream = stream;
   BYTE *pbBits = gifimage.ReadGIFMaster();

   if (pbBits) {
      gifimage._pbBits = pbBits;
      gifimage._gad.pgf->pbmi = gifimage.FinishDithering(); 
   }

   /*
      Extract information from GIF decoder, and format it into an array of bitmaps.
   */
   *delays = NULL;
   vector<HBITMAP> vhbmp;
   vector<COLORREF> vcolorKey;
   vector<int> vdelay;
   LPVOID  image = NULL;
   LPVOID  lastBits = pbBits;
   LPVOID  bitsBeforeLastBits = NULL;
   HBITMAP *hImage = NULL;
   PBITMAPINFO pbmi = NULL;
   HBITMAP hbm;
   PGIFFRAME pgf = gifimage._gad.pgf;
   bool fUseOffset = false; 
   bool fFirstFrame = true;
   long pgfWidth,pgfHeight,     // animation frame dims
        fullWidth,fullHeight,   // main frame dims
        fullPad, pgfPad,        // row padding vals
        fullSize, pgfSize;

   // TODO: Dither global palette to display palette

   fullWidth = gifimage._xWidth;
   fullHeight = gifimage._yHeight;
   fullPad = (((fullWidth + 3) / 4) * 4) - fullWidth;  
   fullSize = (fullPad+fullWidth)*fullHeight; 
    
   while(1) {     
      pbmi = pgf->pbmi;
      Assert(pbmi);

      // TODO: It would be nice to pass local palettes up so they could
      // be mapped to system palettes.       

      // Check to see if frame is offset from logical frame      
      if(pgf->top != 0 ||
         pgf->left != 0 || 
         pgf->width != fullWidth ||
         pgf->height != fullHeight) 
      {
         fUseOffset = true;    
         pgfWidth = pbmi->bmiHeader.biWidth;    
         pgfHeight = pbmi->bmiHeader.biHeight;  
         pbmi->bmiHeader.biWidth = fullWidth;      
         pbmi->bmiHeader.biHeight = fullHeight; 
         pgfPad = (((pgfWidth + 3) / 4) * 4) - pgfWidth; 
         pgfSize = (pgfPad+pgfWidth)*pgfHeight;
      }

      hbm = CreateDIBSection(NULL, pbmi, DIB_RGB_COLORS, (LPVOID *) &image, NULL, 0);        
      if(!hbm) RaiseException_UserError(E_FAIL, IDS_ERR_OUT_OF_MEMORY);
       
      // Correctly composite bitmaps based on disposal method specified        
      unsigned int disp = pgf->gced.uiDisposalMethod;
      // If the frame is offset, fill it with          
      if( (disp == gifRestorePrev) && (bitsBeforeLastBits != NULL) )
         memcpy(image, bitsBeforeLastBits, fullSize);
      else if( (disp == gifRestoreBkgnd) || (disp == gifRestorePrev) || fFirstFrame ) // fill with bgColor      
         memset(image, pgf->gced.ucTransIndex, fullSize);           
      else // fill with last frames data                                              
         memcpy(image, lastBits, fullSize);      
         
      
      // For offset gifs allocate an image the size of the first frame 
      // and then fill in the bits at the offset location.        
      if(fUseOffset) {         
         for(int i=0; i<pgfHeight; i++) {               
            BYTE *dst, *src;                     
            // the destination is the address of the image data plus the frame and row offset. 
            int topOffset = fullHeight - pgfHeight - pgf->top;
            dst = (BYTE*)image +                                  
                  ( ((topOffset + i) *(fullPad+fullWidth)) + pgf->left );
            // copy from the frame's nth row
            src = pgf->ppixels + i*(pgfPad+pgfWidth);                
            for(int j=0; j<pgfWidth; j++) {     
                // copy the frame row data, excluding transparent bytes    
                if(src[j] != pgf->gced.ucTransIndex)
                    dst[j] = src[j];
            }
         }
      }     
      else {
         // Overwritten accumulated bits with current bits. If the 
         // new image contains transparency we need to take it into 
         // account. Since this is slower, special case it.
         if(pgf->gced.fTransparent) {            
            for(int i=0; i<((fullPad+fullWidth)*fullHeight); i++) {        
                if(pgf->ppixels[i] != pgf->gced.ucTransIndex)
                    ((BYTE*)image)[i] = ((BYTE*)pgf->ppixels)[i];
            }
         }
         else // Otherwise, just copy over the offset window's bytes
            memcpy(image, pgf->ppixels, (fullPad+fullWidth)*fullHeight);  
      }

      /* 
          If we got a transparent color extension, convert it to a COLORREF
      */
      COLORREF colorKey = -1;
      if (pgf->gced.fTransparent) {      
          int transparent = pgf->gced.ucTransIndex;
          colorKey = RGB(pgf->pbmi->bmiColors[transparent].rgbRed,
                         pgf->pbmi->bmiColors[transparent].rgbGreen,
                         pgf->pbmi->bmiColors[transparent].rgbBlue);
      }

      vcolorKey.push_back(colorKey);
      vhbmp.push_back(hbm);
      
      /* 
         The delay times are frame specific and can be different, these
         should be propagated as an array to the sampling code.  
      */      
      vdelay.push_back(pgf->gced.uiDelayTime);      

      bitsBeforeLastBits = lastBits;        
      lastBits = image;
      fUseOffset = false;
      if(pgf->pgfNext == NULL) break;
      pgf = pgf->pgfNext;
      fFirstFrame = FALSE;      
   } 
 
   
   // The number of times to loop are also propagated.  Note we add one because 
   // all other GIF decoders appear to treat the loop as the number of times to 
   // loop AFTER the first run through the frames.
   *loop = gifimage._gad.cLoops;
   *numBitmaps = vhbmp.size();

   // Since the vector will go out of scope, move contents over to heap
   // Allocations below assume current heap is GC heap.
   Assert(&GetHeapOnTopOfStack() == &GetGCHeap());
   hImage  = (HBITMAP *)AllocateFromStore(vhbmp.size() * sizeof(HBITMAP));
   *delays = (int*)AllocateFromStore(vhbmp.size() * sizeof(int));
   *colorKeys = (COLORREF*)AllocateFromStore(vcolorKey.size() * sizeof(COLORREF));

   for(int i=0; i < vhbmp.size(); i++) {
      hImage[i] = vhbmp[i];
      (*colorKeys)[i] = vcolorKey[i];
      (*delays)[i] = vdelay[i];
   }
          
   return hImage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\init.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    General initialization for appel.dll.
*******************************************************************************/

#include "headers.h"
#include "privinc/registry.h"

// Macro refers to a function of the name InitializeModule_Name,
// assumed to be defined, and then calls it.  If it's not defined,
// we'll get a link time error.
#define INITIALIZE_MODULE(ModuleName)           \
  extern void InitializeModule_##ModuleName();  \
  InitializeModule_##ModuleName();

#define DEINITIALIZE_MODULE(ModuleName,bShutdown)               \
  extern void DeinitializeModule_##ModuleName(bool);            \
  DeinitializeModule_##ModuleName(bShutdown);

#define INITIALIZE_THREAD(ModuleName)           \
  extern void InitializeThread_##ModuleName();  \
  InitializeThread_##ModuleName();

#define DEINITIALIZE_THREAD(ModuleName)               \
  extern void DeinitializeThread_##ModuleName();  \
  DeinitializeThread_##ModuleName();

int
InitializeAllAppelModules()
{
    // Place module initializations in whatever order is required for
    // proper initialization.

    // Initialize ATL first
    INITIALIZE_MODULE(ATL);

    // Registry initialization must come early, as it defines the
    // preference list that is extended by other initialization.
    INITIALIZE_MODULE(Registry);

    // Moving storage up towards front -- needed for transient heaps.
    INITIALIZE_MODULE(Storage);

    // Initialize IPC stuff
    // !!! No threads can be created before this !!!
    INITIALIZE_MODULE(IPC);

    // Push the init heap
    DynamicHeapPusher dhp(GetInitHeap()) ;

    // GC needs to be before backend
    INITIALIZE_MODULE(Gc);
    INITIALIZE_MODULE(GcThread);

    // Needs to go before Backend
    INITIALIZE_MODULE(Values);

    // Needs to go before DirectX modules
    INITIALIZE_MODULE(MiscPref);

    INITIALIZE_MODULE(Constant);

    INITIALIZE_MODULE(Bvr);
    INITIALIZE_MODULE(Bbox2);
    INITIALIZE_MODULE(Bbox3);
    INITIALIZE_MODULE(Color);
    INITIALIZE_MODULE(Vec2);
    INITIALIZE_MODULE(Vec3);
    INITIALIZE_MODULE(Xform2);
    INITIALIZE_MODULE(Xform3);

    INITIALIZE_MODULE(bground);
    INITIALIZE_MODULE(Camera);
    INITIALIZE_MODULE(Control);
    INITIALIZE_MODULE(3D);
    INITIALIZE_MODULE(dsdev);
    INITIALIZE_MODULE(Viewport);
    // CRView must be after viewport because of dummy device
    INITIALIZE_MODULE(CRView);
    INITIALIZE_MODULE(Except);
    INITIALIZE_MODULE(Geom);
    INITIALIZE_MODULE(Image);
    INITIALIZE_MODULE(Import);
    INITIALIZE_MODULE(Light);
    INITIALIZE_MODULE(LineStyle);
    INITIALIZE_MODULE(Matte);
    INITIALIZE_MODULE(Mic);
    INITIALIZE_MODULE(Montage);

#if ONLY_IF_DOING_EXTRUSION
    INITIALIZE_MODULE(Path2);
#endif 
    
#if INCLUDE_VRML
    INITIALIZE_MODULE(ReadVrml);
#endif
    
    INITIALIZE_MODULE(SinSynth);
    INITIALIZE_MODULE(Sound);
    INITIALIZE_MODULE(Text);
    INITIALIZE_MODULE(Util);

    // FontStyle must be *after* Text, since it depends on
    // serifProportional being initialized.
    INITIALIZE_MODULE(FontStyle);

    INITIALIZE_MODULE(APIBasic);
    INITIALIZE_MODULE(API);
    INITIALIZE_MODULE(APIMisc);
    INITIALIZE_MODULE(APIBvr);
    INITIALIZE_MODULE(PickEvent);
    INITIALIZE_MODULE(View);
    INITIALIZE_MODULE(CBvr);
    INITIALIZE_MODULE(COMConv);
    INITIALIZE_MODULE(PlugImg);
    INITIALIZE_MODULE(Server);

    // This needs to be last
    INITIALIZE_MODULE(Context);

    return 0;
}

void
DeinitializeAllAppelModules(bool bShutdown)
{
    {
        DynamicHeapPusher dhp(GetInitHeap()) ;
        
        DEINITIALIZE_MODULE(IPC,      bShutdown);

        DEINITIALIZE_MODULE(3D,       bShutdown);
        // CRView must be before viewport because of dummy device
        DEINITIALIZE_MODULE(CRView,   bShutdown);
        DEINITIALIZE_MODULE(Viewport, bShutdown);
        DEINITIALIZE_MODULE(Registry, bShutdown);
        DEINITIALIZE_MODULE(dsdev,    bShutdown);
        DEINITIALIZE_MODULE(PlugImg,  bShutdown);
        DEINITIALIZE_MODULE(CBvr,     bShutdown);
        DEINITIALIZE_MODULE(Import,   bShutdown);
        DEINITIALIZE_MODULE(Image,    bShutdown);
        DEINITIALIZE_MODULE(Context,  bShutdown);
        DEINITIALIZE_MODULE(Gc,       bShutdown);
        DEINITIALIZE_MODULE(GcThread, bShutdown);
        DEINITIALIZE_MODULE(Control,  bShutdown);
        DEINITIALIZE_MODULE(bground,  bShutdown);
        DEINITIALIZE_MODULE(Bvr,      bShutdown);
        DEINITIALIZE_MODULE(View,     bShutdown);
        DEINITIALIZE_MODULE(Util,     bShutdown);
        DEINITIALIZE_MODULE(Except,   bShutdown);
        DEINITIALIZE_MODULE(BvrTI,    bShutdown);
        DEINITIALIZE_MODULE(APIMisc,  bShutdown);
        DEINITIALIZE_MODULE(APIBasic, bShutdown);
        
#if ONLY_IF_DOING_EXTRUSION
        DEINITIALIZE_MODULE(Path2,    bShutdown);
#endif
        
    }
    
    // This must be last to ensure that no one needs the memory
    // stored in the system heap
    DEINITIALIZE_MODULE (Storage,bShutdown);

    // Make this last since it depends on no other system resources
    DEINITIALIZE_MODULE (ATL,bShutdown);
}


void
InitializeAllAppelThreads()
{
}

void
DeinitializeAllAppelThreads()
{
    DEINITIALIZE_THREAD(Storage);
    DEINITIALIZE_THREAD(Except);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\ipc.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "privinc/ipc.h"

#pragma warning(disable:4200)  

DeclareTag(tagIPCEntry, "IPC", "Entry/Exit");
DeclareTag(tagIPC, "IPC", "General Msgs");

UINT DAMessageId;
static DWORD DAThreadTlsIndex = 0xFFFFFFFF;
static CritSect * threadCS = NULL;

typedef list <DAThread *> DAThreadList;
static DAThreadList * threadList = NULL;

#define DATHREAD_CLASS "ThreadClass"

bool
DAIPCWorker::AttachToThread()
{
    DetachFromThread();
    
    _hwnd = ::CreateWindow (DATHREAD_CLASS, 
                            "",
                            0, 0, 0, 0, 0, NULL, NULL, hInst, NULL);

    if (!_hwnd)
        return false;

    // Store the object in the user data area of the window
    
    SetWindowLongPtr (_hwnd, GWLP_USERDATA, (LONG_PTR) this) ;

    _dwThreadId = GetCurrentThreadId();

#if DEVELOPER_DEBUG
    char buf[1024];

    wsprintf(buf,
             "IPCWorker(%s): Attaching to thread - threadid -  %#lx, hwnd - %#lx\n",
             GetName(),
             _dwThreadId,
             _hwnd);
    
    OutputDebugString(buf);
#endif

    return true;
}

void
DAIPCWorker::DetachFromThread()
{
    // Cleanup by removing everything associated with the hwnd
    if (_hwnd) {
#if DEVELOPER_DEBUG
        char buf[1024];
        
        wsprintf(buf,
                 "IPCWorker(%s): Detaching from thread - threadid -  %#lx, hwnd - %#lx\n",
                 GetName(),
                 _dwThreadId,
                 _hwnd);
        
        OutputDebugString(buf);
#endif
        SetWindowLongPtr (_hwnd, GWLP_USERDATA, NULL) ;
        DestroyWindow(_hwnd);
        _hwnd = NULL;
        _dwThreadId = 0;
    }
}

bool
DAIPCWorker::SendMsg(DWORD dwMsg,
                     DWORD dwTimeout,
                     DWORD dwNum,
                     va_list args)
{
    bool ret;
    
    // Create the packet to send
    DAIPCPacket * packet = MakePacket(dwMsg,
                                      dwTimeout != 0,
                                      dwNum,
                                      args);
    
    if (packet) {
        ret = SendPacket(*packet, dwTimeout);
    } else {
        ret = false;
    }
    
    if (packet)
        packet->Release();

    return ret;
}


DAIPCWorker::DAIPCPacket *
DAIPCWorker::MakePacket(DWORD dwMsg,
                        bool bSync,
                        DWORD dwNum,
                        va_list args)
{
    // Create the packet to send
    DAIPCWorker::DAIPCPacket * packet = new (dwNum) DAIPCWorker::DAIPCPacket;

    if (packet == NULL)
        return NULL;
    
    // Setup the basic information
    if (!packet->Init(dwMsg, bSync)) {
        delete packet;
        return NULL;
    }
        
    // Get the arguments
    
    DWORD_PTR * p = packet->GetParams();
    
    for (int i = 0; i < dwNum; i++)
        p[i] = va_arg(args, DWORD_PTR);
    
    return packet;
}

bool
DAIPCWorker::SendPacket(DAIPCPacket & p, DWORD dwTimeout)
{
    // Create the message to send
    
    // If we are calling from the same thread and we are synchronous
    // then we need to call directly otherwise just queue the message
    if (_dwThreadId == GetCurrentThreadId() && p.IsSync()) {
        LRESULT r;
        IPCProc(_hwnd, DAMessageId, (WPARAM) &p, 0, r);
        return true;
    } else {
        // Add a reference for the posted message queue
        p.AddRef();

        // Post the message to the window
        if (!PostMessage(_hwnd, DAMessageId, (WPARAM) &p, 0)) {
            // If we failed to post the message then we need to
            // release the packet since the receiver will not do it
            
            p.Release();
            return false;
        }

        if (p.IsSync()) {
            // Need to wait for the message to be processed
            // TODO: Should add a reasonable timeout
            // TODO: Should add some diagnostics to detect deadlock

            // TODO: We should wait for a smaller period of time and
            // poll to see if the thread has terminated or we can do a
            // waitformultipleobjects on the thread handle
            WaitForSingleObject(p.GetSync(), dwTimeout);
        }
    }
    
    return true;
}

bool
DAIPCWorker::IPCProc (HWND hwnd,
                      UINT msg,
                      WPARAM wParam,
                      LPARAM lParam,
                      LRESULT & res)
{
    res = 0;

    if (msg != DAMessageId)
        return true;

    DAIPCPacket * p = (DAIPCPacket *)wParam;
    
    ProcessMsg(p->GetMsg(),
               p->GetNumParam(),
               p->GetParams());

    if (p->IsSync())
        SetEvent(p->GetSync());

    p->Release();
    
    return false;
}

LRESULT CALLBACK
DAIPCWorker::WindowProc (HWND   hwnd,
                         UINT   msg,
                         WPARAM wParam,
                         LPARAM lParam)
{
    TraceTag((tagIPCEntry,
              "WindowProc: 0x%lx, 0x%lx, 0x%lx, 0x%lx",
              hwnd, msg, wParam, lParam));
    
    // Get the worker data associated with the window
    DAIPCWorker * t = (DAIPCWorker *) GetWindowLongPtr (hwnd, GWLP_USERDATA) ;

    LRESULT res;
    
    // Callthe IPCProc and if it returns true call the default winproc
    if (!t || t->IPCProc(hwnd, msg, wParam, lParam, res))
        res = DefWindowProc (hwnd, msg, wParam, lParam);

    return res;
}

//
// DAThread
//

DAThread::DAThread()
: _dwThreadId(0),
  _hThread(NULL),
  _hMsgQEvent(NULL),
  _bDoingWork(false)
{
    if (threadList) {
        // Add ourselves to the list of threads
        
        CritSectGrabber csg(*threadCS);
        threadList->push_back(this);
    }
}

DAThread::~DAThread()
{
    // Ensure the thread is stopped
    Stop();

    if (threadList) {
        CritSectGrabber csg(*threadCS);
        threadList->remove(this);
    }
}

bool
DAThread::Start()
{
    if (IsStarted())
        return true;
    
    if (!AddRefDLL())
        return false;

    // Create necessary events first
    
    _hMsgQEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
        
    if (_hMsgQEvent != NULL) {
    
        // Create the thread
        
        _hThread = CreateThread(NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)DAWorker,
                                this,
                                0,
                                (LPDWORD)&_dwThreadId);
    
        if (_hThread != NULL) {
            // wait until the message queue has been created
            DWORD dwRes ;
    
            {
                // make the expected event be first so we can check it
                // below
                // TODO: We may want to add a timeout here to ensure
                // we did not lock up for some reason
                
                HANDLE h[] = { _hMsgQEvent,_hThread } ;
                dwRes = WaitForMultipleObjects(2,h,FALSE,INFINITE) ;
            }
    
            CloseHandle(_hMsgQEvent);
            _hMsgQEvent = NULL;
            // Check the result to see if the event was signalled or the
            // thread exited unexpectedly
    
            // The expected event is the first in the array above
            // Return true indicating everything is going fine
            if (dwRes == WAIT_OBJECT_0) {
                return true;
            }

            // Fall through if we failed
            TraceTag((tagError,
                      "GarbageCollector::StartThread: Thread terminated unexpectedly"));
        } else {
            TraceTag((tagError,
                      "DAThread:Start: Failed to create thread"));
        }
    } else {
        TraceTag((tagError,
                  "DAThread:Start: Failed to create terminate event"));
    }
        
    ReleaseDLL();
    
    Kill();

    return false;
}

bool
DAThread::Terminate(bool bKill)
{
    bool ret = true;
    
    // See if the thread is alive
    
    if (_dwThreadId) {
        if (bKill) {
            if (_dwThreadId != GetCurrentThreadId())
                ::TerminateThread(_hThread, 0);
        } else {
            // Send terminate message to ensure the thread wakes up
            
            SendAsyncMsg(DAT_TERMINATE);
        }
        
        _dwThreadId = 0;

        Assert (_hThread);
        CloseHandle(_hThread);
        _hThread = NULL;
    }

    if (_hMsgQEvent) {
        CloseHandle(_hMsgQEvent);
        _hMsgQEvent = NULL;
    }

    return ret;
}

int
DAThread::workerRoutine()
{
    if (!InitThread()) {
        DeinitThread();
        return -1;
    }

    MSG msg;
    while (GetMessage(&msg, NULL, NULL, NULL)) {
        if (msg.message == DAMessageId &&
            ((DAIPCPacket *)msg.wParam)->GetMsg() == DAT_TERMINATE)
            break;

        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    if (!DeinitThread())
        return -1;

    return 0;
}

bool
DAThread::InitThread()
{
    if (!AttachToThread())
        return false;
    
    {
        MSG msg;
        
        // force message queue to be created
        PeekMessage(&msg, NULL, NULL, NULL, PM_NOREMOVE);
    }

    // set event that indicates thread's msg queue created
    SetEvent(_hMsgQEvent); 

    if (!TlsSetValue(DAThreadTlsIndex, this))
        return false;

    // CoInitialize so we can call COM stuff

    // this doesn't exist on ie3.02 platfroms.
    //CoInitializeEx(NULL, COINIT_MULTITHREADED);
    CoInitialize(NULL);

    return true;
}

bool
DAThread::DeinitThread()
{
    DetachFromThread();
    
    // Clean up COM
    CoUninitialize();
    
    FreeLibraryAndExitThread(hInst, 0);
    
    return true;
}

bool
DAThread::AddRefDLL()
{
    bool bRet = false;

    char buf[MAX_PATH + 1];
    
    if (GetModuleFileName(hInst, buf, ARRAY_SIZE(buf)) == 0)
    {
        TraceTag((tagError,
                  "DAThread::AddRefDLL: Failed to getmodulefilename - %hr", GetLastError()));
        goto done;
    }
    
    HINSTANCE new_hinst;
    
    new_hinst = LoadLibrary(buf);
    
    if (new_hinst == NULL)
    {
        TraceTag((tagError,
                  "DAThread::AddRefDLL: Failed to LoadLibrary(%s) - %hr",
                  buf,
                  GetLastError()));
        goto done;
    }
    
    Assert(new_hinst == hInst);

    bRet = true;
  done:
    return bRet;
}

void
DAThread::ReleaseDLL()
{
    FreeLibrary(hInst);
}

//
// General IPC stuff
//

DAThread *
GetCurrentDAThread()
{
    return (DAThread *) TlsGetValue(DAThreadTlsIndex);
}

static void RegisterWindowClass ()
{
    WNDCLASS windowclass;

    memset (&windowclass, 0, sizeof(windowclass));

    windowclass.style         = 0;
    windowclass.lpfnWndProc   = DAIPCWorker::WindowProc;
    windowclass.hInstance     = hInst;
    windowclass.hCursor       = NULL;
    windowclass.hbrBackground = NULL;
    windowclass.lpszClassName = DATHREAD_CLASS;

    RegisterClass (&windowclass);
}

// =========================================
// Initialization
// =========================================
void
InitializeModule_IPC()
{
    RegisterWindowClass();
    DAMessageId = RegisterWindowMessage(_T("IPCMessage"));

    DAThreadTlsIndex = TlsAlloc();

    // If result is 0xFFFFFFFF, allocation failed.
    Assert(DAThreadTlsIndex != 0xFFFFFFFF);

    threadCS = THROWING_ALLOCATOR(CritSect);
    threadList = THROWING_ALLOCATOR(DAThreadList);
}

void
DeinitializeModule_IPC(bool bShutdown)
{
    // Iterate through the list and stop all the threads - but do not
    // destroy them

    if (threadList) {
        for (DAThreadList::iterator i = threadList->begin();
             i != threadList->end();
             i++) {
            (*i)->Terminate(bShutdown);
        }
    }

    // We need to set the threadList and threadCS to NULL to ensure
    // that when the thread objects are destroyed later on during
    // deinitialization they do not try to access the no longer
    // valid list
    
    delete threadList;
    threadList = NULL;

    delete threadCS;
    threadCS = NULL;

    if (DAThreadTlsIndex != 0xFFFFFFFF)
        TlsFree(DAThreadTlsIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\loadjpeg.cpp ===
//////////////////////////////////////////////////////////////////////////
// Copyright 1996 Microsoft Corporation
// All Rights Reserved.
//
// LoadJPEG.CPP
//
// Load a JPEG image from a file and create a DIBSECTION bitmap
// Uses code from the Independent JPEG group's JPEG decompression library
//

#include "headers.h"
#include <memory.h>
#include <string.h>
#include <jpeglib.h>
#include "privinc/dastream.h"

// Error handling code for IJG's decompressor
#include <setjmp.h>

/////////////////////////////////////////////////////////////////////////
struct my_error_mgr {
  struct jpeg_error_mgr pub;
  jmp_buf setjmp_buffer;
};

typedef struct my_error_mgr * my_error_ptr;

////////////////////////////////////////////////////////////////////////
METHODDEF void my_error_exit ( j_common_ptr cinfo) {
  my_error_ptr myerr = (my_error_ptr) cinfo->err;

/* Return control to the setjmp point */
  longjmp(myerr->setjmp_buffer, 1);
}

//////////////////////////////////////////////////////////////////////////
HBITMAP _jpeg_create_bitmap(j_decompress_ptr cinfo) {
  int bytes_per_line;
  LPBYTE  image    = NULL;
  LPBITMAPINFO pBi = NULL;
  HBITMAP hImage   = NULL;
  LPBYTE pBuffer;

// Set up windows bitmap info header
//
  pBi = (LPBITMAPINFO) ThrowIfFailed(malloc(sizeof(BITMAPINFOHEADER) + (256 * sizeof(RGBQUAD))));
  if (NULL == pBi) return NULL; // couldn't allocate bitmap info structure

  pBi->bmiHeader.biSize     = sizeof(BITMAPINFOHEADER);
  pBi->bmiHeader.biWidth    =   cinfo->output_width;
  pBi->bmiHeader.biHeight   = - (int) cinfo->output_height;
  pBi->bmiHeader.biPlanes   = 1;
  pBi->bmiHeader.biBitCount = 8;
  pBi->bmiHeader.biCompression   = BI_RGB;
  pBi->bmiHeader.biSizeImage     = 0;
  pBi->bmiHeader.biXPelsPerMeter = 0;
  pBi->bmiHeader.biYPelsPerMeter = 0;
  pBi->bmiHeader.biClrUsed       = 0;   // maximum # of colors
  pBi->bmiHeader.biClrImportant  = 0;   // all colors are important

// If the decompressor has quantized the color to 8-bit for us.
//
  if (cinfo->quantize_colors) {

    int byteperpix = 1; //cinfo->output_components;

// Set up palette for new image

    int i;   // Loop Counter

    switch (cinfo->jpeg_color_space) {

        case JCS_GRAYSCALE:
            for (i=0;  i < 256;  ++i) {
                pBi->bmiColors[i].rgbRed   =
                pBi->bmiColors[i].rgbGreen =
                pBi->bmiColors[i].rgbBlue  = cinfo->colormap[0][i];
                pBi->bmiColors[i].rgbReserved = 0;
            }
            break;

        case JCS_YCbCr:
            // YUV entries are already converted to RGB.
            // ** FALL THROUGH **

        case JCS_RGB:
            for (i=0;  i < 256;  ++i) {
                pBi->bmiColors[i].rgbRed   = cinfo->colormap[2][i];
                pBi->bmiColors[i].rgbGreen = cinfo->colormap[1][i];
                pBi->bmiColors[i].rgbBlue  = cinfo->colormap[0][i];
                pBi->bmiColors[i].rgbReserved = 0;
            }
            break;

        case JCS_YCCK:
            // YUV entries are already converted to RGB.
            // ** FALL THROUGH **

        case JCS_CMYK:
            // For CMYK, the CMY channels have already been converted to RGB,
            // and the K channel has been inverted.  The CMY entries have been
            // scaled to the range [0,255], covering the spectrum in [K,255].
            // For example, C' = K + (C/255)(255-K).

            for (i=0;  i < 256;  ++i) {
                unsigned int C = 255 - cinfo->colormap[0][i];
                unsigned int M = 255 - cinfo->colormap[1][i];
                unsigned int Y = 255 - cinfo->colormap[2][i];
                unsigned int K = 255 - cinfo->colormap[3][i];

                pBi->bmiColors[i].rgbRed   = (BYTE)(255 - (K+C-((C*K)/255)));
                pBi->bmiColors[i].rgbGreen = (BYTE)(255 - (K+M-((M*K)/255)));
                pBi->bmiColors[i].rgbBlue  = (BYTE)(255 - (K+Y-((Y*K)/255)));
                pBi->bmiColors[i].rgbReserved = 0;
            }
            break;

        default:
            // If the colorspace is unknown or unhandled, then leave the
            // color lookup table as-is.

            Assert (!"Unknown or unhandled JPEG colorspace.");
            break;
    }

    bytes_per_line = (cinfo->output_width + 3) & -4; // even # of DWORDs

// Else, if the compressor has not quantized color (and we're either a
// grey scale or a 24bpp image)
//
  } else {

// Make sure it's a format we can handle. (BUGBUG - For now, we only handle
// 24bpp color)
//
    int byteperpix = cinfo->out_color_components;
    if (byteperpix != 3) goto jpeg_error;

    pBi->bmiHeader.biBitCount = byteperpix * 8;

    bytes_per_line = ((cinfo->output_width * byteperpix) + 3) & -4;

  }

// Create our DIBSECTION bitmap...
//
  hImage = CreateDIBSection(NULL,pBi,DIB_RGB_COLORS,(LPVOID *) &image,NULL,0);
  if (NULL == hImage) goto jpeg_error;

// Read the image data
//
  pBuffer = image;

  while (cinfo->output_scanline < cinfo->output_height) {
    jpeg_read_scanlines(cinfo, &pBuffer, 1);
    pBuffer += bytes_per_line;
  }

  free (pBi);
  return hImage;

jpeg_error:
  if (pBi) free (pBi);
  if (hImage) DeleteObject(hImage);

  return NULL;
}

///////////////////////////////////////////////////////////////////////////
HBITMAP LoadJPEGImage(LPCSTR filename,int dx,int dy) {
  FILE* infile;    /* source file */
  struct jpeg_decompress_struct cinfo; //the IJG jpeg structure
  struct my_error_mgr jerr;

  dx; dy; // just for reference
  // disable our jpeg decoder
  if (1) return NULL;

  if ((infile = fopen(filename, "rb")) == NULL) return NULL;

// Step 1: allocate and initialize JPEG decompression object
// We set up the normal JPEG error routines, then override error_exit.
//
  cinfo.err = jpeg_std_error(&jerr.pub);
  jerr.pub.error_exit = my_error_exit;

// Establish the setjmp return context for my_error_exit to use.
// If we get here, the JPEG code has signaled an error.
// We need to clean up the JPEG object, close the input file, and return.
//
  if (setjmp(jerr.setjmp_buffer)) {
    jpeg_destroy_decompress(&cinfo);
    fclose(infile);
    return (HBITMAP)NULL;
  }

// Now we can initialize the JPEG decompression object.
//
  jpeg_create_decompress(&cinfo);

/* Step 2: specify data source (eg, a file) */

  jpeg_stdio_src(&cinfo, infile);

/* Step 3: read file parameters with jpeg_read_header() */

  (void) jpeg_read_header(&cinfo, TRUE);
/* We can ignore the return value from jpeg_read_header since
 *   (a) suspension is not possible with the stdio data source, and
 *   (b) we passed TRUE to reject a tables-only JPEG file as an error.
 * See libjpeg.doc for more info.
*/

/* Step 4: set parameters for decompression */
  if(cinfo.out_color_space == JCS_GRAYSCALE)
  {
    cinfo.quantize_colors = TRUE;
  }
  else
  {
// Bugbug - this limits us to 8-bit color for now!
//
    cinfo.quantize_colors = TRUE;
  }

/* In this example, we don't need to change any of the defaults set by
 * jpeg_read_header(), so we do nothing here.
*/

  /* Step 5: Start decompressor */

  (void) jpeg_start_decompress(&cinfo);
  /* We can ignore the return value since suspension is not possible
   * with the stdio data source.
   */


  /* Step 6: while (scan lines remain to be read) */
  /*           jpeg_read_scanlines(...); */
   HBITMAP hImage = _jpeg_create_bitmap(&cinfo);

  /* Step 7: Finish decompression */
 
  (void) jpeg_finish_decompress(&cinfo);

  /* Step 8: Release JPEG decompression object */
  jpeg_destroy_decompress(&cinfo);

  /* After finish_decompress, we can close the input file.
   * Here we postpone it until after no more JPEG errors are possible,
   * so as to simplify the setjmp error logic above.  (Actually, I don't
   * think that jpeg_destroy can do an error exit, but why assume anything...)
   */
  fclose(infile);

  return hImage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\mutex.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of the classes that simplify mutex programming.

--*/

#include "headers.h"
#include <windows.h>
#include "privinc/mutex.h"

////////////////////////  Mutexes  //////////////////////////////

Mutex::Mutex()
{
    HANDLE m = CreateMutex(NULL,  // default security
                           FALSE, // don't initially assume ownership
                           NULL); // no name

    if (m == NULL) {
        RaiseException_InternalError("Mutex creation failed");
    }

    // Stash in new object as a void*.  NOTE: This cast is only valid
    // if HANDLE is the same size as a void *, that is, HANDLE is
    // presumed to be a pointer (which it is in Win32).  We do this
    // cast so that mutex.h doesn't need to mention HANDLE in its
    // declarations, otherwise we would have to #include <windows.h>
    // there.
    Assert((sizeof(void *) == sizeof(HANDLE)) && "HANDLE and void * are not the same size");

    mutex = (void *)m;
}

Mutex::~Mutex()
{
    if (!CloseHandle((HANDLE)mutex)) {
        RaiseException_InternalError("Mutex destruction failed");
    }
}

void
Mutex::Grab()
{
    // Wait potentially forever for the mutex to be available, and
    // then grab it.  TODO:  May be overly naive.  May need to add a
    // timeout, or some indication of the conditions under which this
    // function returns.
    if (WaitForSingleObject((HANDLE)mutex, INFINITE) == WAIT_FAILED) {
        RaiseException_InternalError("Attempt to grab mutex failed.");
    }
}

void
Mutex::Release()
{
    if (!ReleaseMutex((HANDLE)mutex)) {
        RaiseException_InternalError(
          "Mutex release failed.  Releasing thread doesn't own the mutex");
    }
}

////// Mutex Grabber //////

MutexGrabber::MutexGrabber(Mutex& m, Bool grabIt)
: mutex(m), grabbed(grabIt)
{
    if (grabIt) mutex.Grab();
}

MutexGrabber::~MutexGrabber()
{
    if (grabbed) mutex.Release();
}

////////////////////////  CritSect  //////////////////////////////

CritSect::CritSect()
{
    InitializeCriticalSection(&_cs) ;
}

CritSect::~CritSect()
{
    DeleteCriticalSection(&_cs) ;
}

void
CritSect::Grab()
{
    EnterCriticalSection(&_cs) ;
}

void
CritSect::Release()
{
    LeaveCriticalSection(&_cs) ;
}

////// CritSect Grabber //////

CritSectGrabber::CritSectGrabber(CritSect& cs, Bool grabIt)
: _cs(cs), grabbed(grabIt)
{
    if (grabIt) _cs.Grab();
}

CritSectGrabber::~CritSectGrabber()
{
    if (grabbed) _cs.Release();
}

/////////////////////////  Semaphores  //////////////////////

Semaphore::Semaphore(int initialCount, int maxCount)
{
    HANDLE s = CreateSemaphore(NULL,  // default security
                               initialCount,
                               maxCount,
                               NULL); // no name

    if (s == NULL) {
        RaiseException_InternalError("Semaphore creation failed");
    }

    // Stash in new object as a void*.  NOTE: This cast is only valid
    // if HANDLE is the same size as a void *, that is, HANDLE is
    // presumed to be a pointer (which it is in Win32).  We do this
    // cast so that mutex.h doesn't need to mention HANDLE in its
    // declarations, otherwise we would have to #include <windows.h>
    // there.
    Assert((sizeof(void *) == sizeof(HANDLE)) && "HANDLE and void * are not the same size");

    _semaphore = (void *)s;

#if _DEBUG
    _count = initialCount;
    _maxCount = maxCount;
#endif
    
}

Semaphore::~Semaphore()
{
    if (!CloseHandle((HANDLE)_semaphore)) {
        RaiseException_InternalError("Semaphore destruction failed");
    }
}

void
Semaphore::Decrement(int times)
{
    // Wait potentially forever for the semaphore to be available, and
    // then grab it.  TODO:  May be overly naive.  May need to add a
    // timeout, or some indication of the conditions under which this
    // function returns.

    // Note that we go through this loop 'times' times, as specified
    // by the call to Decrement().
    for (int i = 0; i < times; i++) {
        if (WaitForSingleObject((HANDLE)_semaphore, INFINITE) ==
            WAIT_FAILED) {
            RaiseException_InternalError("Attempt to grab Semaphore failed.");
        }
    }

#if _DEBUG
    _count--;
#endif    

}

int
Semaphore::Increment(int times)
{
    // Release with count increment specified in 'times'.
    LONG previousCount;
    if (!ReleaseSemaphore((HANDLE)_semaphore, times, &previousCount)) {
        RaiseException_InternalError("Semaphore release failed");
    }

#if _DEBUG
    _count += times;
    Assert(_count <= _maxCount);
//    Assert(_count == previousCount + times);
#endif

    return previousCount + times;
}

Win32Event::Win32Event(bool bManualReset,bool bInitState)
: _bManual(bManualReset)
{
    _hEvent = CreateEvent(NULL,
                          bManualReset,
                          bInitState,
                          NULL);

    if (_hEvent == NULL)
        RaiseException_InternalError("Could not create event");
}

Win32Event::~Win32Event()
{
    if (_hEvent && !CloseHandle(_hEvent))
        RaiseException_InternalError("Could not close event");
}

void
Win32Event::Wait()
{
    if (WaitForSingleObject(_hEvent, INFINITE) == WAIT_FAILED)
        RaiseException_InternalError("Attempt to wait on event failed.");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\path.cpp ===
/*******************************************************************************

Copyright (c) 1996 Microsoft Corporation

Abstract:

    Static tree path class

    We need to form addresses based on ID'd nodes in the performance tree.
    "C" wrappers are provided so methods may be accessed from ML.

    NOTE:  This is a brute force first pass implementation
*******************************************************************************/

#include "headers.h"
#include "privinc/soundi.h"
#include "privinc/storeobj.h"
#include "privinc/path.h"
#include "privinc/debug.h"
#ifndef _NO_CRT
#include <iostream>
#endif

typedef vector<int> PathType;
typedef vector<AVPath> PathListType;

class AVPathImpl : public StoreObj
{
  public:

    AVPathImpl() {
        path = NEW PathType();
        GetHeapOnTopOfStack().RegisterDynamicDeleter
            (NEW DynamicPtrDeleter<PathType>(path));
    }
    
    bool ContainsNode(int value);

    // This won't be called if it's allocated on the transient heap.
    // XXX ? ~AVPathImpl() { delete path; }

    void Push(int node) { path->push_back(node); }

    void Pop() { path->pop_back(); }

    // Our path is usually different at the end, so this is more
    // efficient than == which uses begin() & end().
    int Equal(AVPath otherPath) {
        //return (*path) == otherPath->GetAddr();
        PathType& x = *path;
        PathType& y = otherPath->GetAddr();
        return
            x.size() == y.size() && std::equal(x.rbegin(), x.rend(), y.rbegin());
    }

    int ContainsPostfix(AVPath postfix);
    
    // Don't know why this does work
    /*
    void Copy(AVPath srcPath)
    {
        copy(srcPath->GetAddr().begin(),
             srcPath->GetAddr().end(),
             path.begin());
    }
    */

#if _USE_PRINT
    void Print();
    void Print(char *);
#endif
    PathType& GetAddr() { return *path; }

 private:
    PathType *path;
};

int
AVPathImpl::ContainsPostfix(AVPath postfix)
{
    PathType& pv = postfix->GetAddr();

    int pathSize = path->size();
    int postfixSize = pv.size();

    if (postfixSize > pathSize)
        return FALSE;

    for (int i=0; i<postfixSize; i++)
        if (pv[i] != (*path)[(pathSize - postfixSize) + i])
            return FALSE;

    return TRUE;
}


bool
AVPathImpl::ContainsNode(int value)
{
    return(std::find(path->begin(), path->end(), value) != path->end());
}


#if _USE_PRINT
void
AVPathImpl::Print()
{
    std::ostream_iterator<int> out(std::cout, ":");

    std::cout << "path:(";
    std::copy(path->begin(), path->end(), out);
    std::cout << ")\n";
}


void
AVPathImpl::Print(char *string)
{
    char num[20];
    PathType::iterator i;

    string[0] = 0;
    for(i= path->begin(); i != path->end(); i++) {
        itoa(*i, num, 10);
        lstrcat(string, num);
        lstrcat(string, ",");
    }
}
#endif

AVPath AVPathCreate() { return NEW AVPathImpl; }
void AVPathDelete(AVPath p) { delete p; }
void AVPathPush(int i, AVPath p) { p->Push(i); }
void AVPathPop(AVPath p) { p->Pop(); }
int AVPathEqual(AVPath a, AVPath b) { return a->Equal(b); }
#if _USE_PRINT
void AVPathPrint(AVPath p) { p ->Print(); }
void AVPathPrintString(AVPath p, char *string) { p ->Print(string); }
#endif
int AVPathContainsPostfix(AVPath p, AVPath postfix)
{ return p->ContainsPostfix(postfix); }
bool AVPathContains(AVPath p, int value) { return p->ContainsNode(value); }

static char sbuffer[1024];

#if _USE_PRINT
char* AVPathPrintString2(AVPath p)
{
    AVPathPrintString(p, sbuffer);

    return sbuffer;
}
#endif

AVPath AVPathCopy(AVPath src)
{
    AVPath p = NEW AVPathImpl;

    PathType::iterator i1 = src->GetAddr().begin();

    while (i1 != (src->GetAddr().end()))
    {
        int i = *i1;

        AVPathPush(i, p);

        i1++;
    }

    /* p->Copy(src); */

    return p;
}


AVPath AVPathCopyFromLast(AVPath src, int start)
{
    AVPath path= NEW AVPathImpl;

    PathType sp= src->GetAddr();

    for(int i= sp.size() - 1; i > 0; i--) {
        if(sp[i]==start)
            break;
    }

    Assert(i >= 0);

    for(int n= i; n<sp.size(); n++)
        AVPathPush(sp[n], path);

    return path;
}


class AVPathListImpl : public AxAThrowingAllocatorClass
{
  public:
    AVPathListImpl() {
        plist = NEW PathListType();
    }

    ~AVPathListImpl() { delete plist; }

    void Push(AVPath p) { plist->push_back(p); }

    int IsEmpty() { return plist->empty(); }

    int Find(AVPath);

  private:
    PathListType* plist;
};

int
AVPathListImpl::Find(AVPath p)
{

#if _DEBUG
#if _USE_PRINT
    // Check to avoid AVPathPrintString call
    if (IsTagEnabled(tagSoundPath)) {
        TraceTag((tagSoundPath, "AVPathListImpl::Find finding <%s>",
                  AVPathPrintString2(p)));
    }
#endif
#endif

    for(PathListType::iterator i = plist->begin();
        i != plist->end(); i++)
    {

#if _DEBUG
#if _USE_PRINT
        // Check to avoid AVPathPrintString call
        if (IsTagEnabled(tagSoundPath)) {
            TraceTag((tagSoundPath, "AVPathListImpl::Find comparing <%s>",
                      AVPathPrintString2(*i)));
        }
#endif
#endif

        if (AVPathEqual(*i, p))
            return 1;
    }

    return 0;
}

AVPathList AVPathListCreate()
{
    BEGIN_LEAK
    AVPathList result = NEW AVPathListImpl;
    END_LEAK

    return result;
}

void AVPathListDelete(AVPathList plst) { delete plst; }
void AVPathListPush(AVPath p, AVPathList plst) { plst->Push(p); }
int AVPathListFind(AVPath p, AVPathList plst) { return plst->Find(p); }

static AVPathList emptyPathList = NULL;

AVPathList AVEmptyPathList() { return emptyPathList; }

int AVPathListIsEmpty(AVPathList plst) { return plst->IsEmpty(); }

void
InitializeModule_Path()
{
    emptyPathList = AVPathListCreate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\privpref.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    General implementation of user preference management

*******************************************************************************/


#include "headers.h"
#include "privinc/comutil.h"
#include "privinc/privpref.h"
#include "privinc/registry.h"

bool bShowFPS;  // flag for showing the frame rate.


PrivatePreferences::PrivatePreferences()
{
    // Load up the 3D preferences from the registry.
    IntRegistryEntry lightColorMode ("3D", PREF_3D_RGB_LIGHTING,    1);
    IntRegistryEntry fillMode       ("3D", PREF_3D_FILL_MODE,       0);
    IntRegistryEntry shadeMode      ("3D", PREF_3D_SHADE_MODE,      1);
    IntRegistryEntry dithering      ("3D", PREF_3D_DITHER_ENABLE,   1);
    IntRegistryEntry perspCorr      ("3D", PREF_3D_PERSP_CORRECT,   1);
    IntRegistryEntry texmapping     ("3D", PREF_3D_TEXTURE_ENABLE,  1);
    IntRegistryEntry texquality     ("3D", PREF_3D_TEXTURE_QUALITY, 0);
    IntRegistryEntry useHW          ("3D", PREF_3D_USEHW,           1);
    IntRegistryEntry useMMX         ("3D", PREF_3D_USEMMX,          0x2);

    IntRegistryEntry worldLighting  ("3D", PREF_3D_WORLDLIGHTING,   0);

    // 2D Preferences
    IntRegistryEntry colorKeyR_ModeEntry("2D", PREF_2D_COLOR_KEY_RED, 1);
    IntRegistryEntry colorKeyG_ModeEntry("2D", PREF_2D_COLOR_KEY_GREEN, 254);
    IntRegistryEntry colorKeyB_ModeEntry("2D", PREF_2D_COLOR_KEY_BLUE, 245);

    // Engine preferences
    IntRegistryEntry maxFPS("Engine", PREF_ENGINE_MAX_FPS, 30);
    IntRegistryEntry perfReporting("Engine", "Enable Performance Reporting", 0);
    IntRegistryEntry engineOptimizationEntry("Engine",
                                             PREF_ENGINE_OPTIMIZATIONS_ON,
                                             1);
    IntRegistryEntry engineRetainedMode("Engine", PREF_ENGINE_RETAINEDMODE, 0);

    // Statistics...
    IntRegistryEntry gcStatEntry("Engine", "GC Stat", 1);
    IntRegistryEntry jitterStatEntry("Engine", "Jitter Stat", 1);
    IntRegistryEntry heapSizeStatEntry("Engine", "Heap Size Stat", 1);
    IntRegistryEntry dxStatEntry("Engine", "DirectX Stat", 1);

    // Overrid preference.  If 1, the preferences that come from the
    // application are ignored, and the ones from the registry always
    // win.
    IntRegistryEntry overrideAppPrefs("Engine",
                                      PREF_ENGINE_OVERRIDE_APP_PREFS,
                                      0);

    _overrideMode = (overrideAppPrefs.GetValue() != 0);

    // 3D Preferences
    _rgbMode = (lightColorMode.GetValue() != 0);

    _fillMode = fillMode.GetValue();
    _shadeMode = shadeMode.GetValue();

    _dithering      = (dithering.GetValue() != 0);
    _texmapPerspect = (perspCorr.GetValue() != 0);
    _texmapping     = (texmapping.GetValue() != 0);

    _texturingQuality = texquality.GetValue();

    _useHW  = useHW.GetValue();
    _useMMX = useMMX.GetValue();

    _worldLighting = worldLighting.GetValue();

    // 2D Preferences
    _clrKeyR = colorKeyR_ModeEntry.GetValue();
    _clrKeyG = colorKeyG_ModeEntry.GetValue();
    _clrKeyB = colorKeyB_ModeEntry.GetValue();


    // Engine preferences
    _gcStat = gcStatEntry.GetValue();
    _jitterStat = jitterStatEntry.GetValue() != 0;
    _heapSizeStat = heapSizeStatEntry.GetValue() != 0;
    _dxStat = dxStatEntry.GetValue() != 0;
    _engineOptimization = engineOptimizationEntry.GetValue();

    if (maxFPS.GetValue())
        _minFrameDuration = 1 / (double) maxFPS.GetValue();
    else
        _minFrameDuration = 0.0;

    #if !_DEBUG
        if(perfReporting.GetValue())
            bShowFPS = true;    // we want to show the FPS...
    #endif

    _spritify = engineRetainedMode.GetValue();

    // Non-registry preferences.

    _dirtyRectsOn = true;
    _BitmapCachingOn = true;
    _dynamicConstancyAnalysisOn = true;
    _volatileRenderingSurface = true;
}

HRESULT
GetVariantBool(VARIANT& v, Bool *b)
{
    VARIANT *pVar;

    if (V_ISBYREF(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    CComVariant vnew;

    if (FAILED(vnew.ChangeType(VT_BOOL, pVar)))
        return DISP_E_TYPEMISMATCH;

    *b = V_BOOL(&vnew);
    return S_OK;
}

HRESULT
GetVariantInt(VARIANT& v, int *i)
{
    VARIANT *pVar;

    if (V_ISBYREF(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    CComVariant vnew;

    if (FAILED(vnew.ChangeType(VT_I4, pVar)))
        return DISP_E_TYPEMISMATCH;

    *i = V_I4(&vnew);
    return S_OK;
}

HRESULT
GetVariantDouble(VARIANT& v, double *dbl)
{
    VARIANT *pVar;

    if (V_ISBYREF(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    CComVariant vnew;

    if (FAILED(vnew.ChangeType(VT_R8, pVar)))
        return DISP_E_TYPEMISMATCH;

    *dbl = V_R8(&vnew);
    return S_OK;
}

HRESULT
PrivatePreferences::DoPreference(char *prefName,
                                 Bool puttingPref,
                                 VARIANT *pV)
{
    HRESULT hr = S_OK;
    Bool b;
    double dbl;
    int i;

    if (!puttingPref) {
        VariantClear(pV);
    }

    INT_ENTRY(PREF_2D_COLOR_KEY_BLUE,  _clrKeyB);
    INT_ENTRY(PREF_2D_COLOR_KEY_GREEN, _clrKeyG);
    INT_ENTRY(PREF_2D_COLOR_KEY_RED,   _clrKeyR);

    INT_ENTRY  (PREF_3D_FILL_MODE,       _fillMode);
    INT_ENTRY  (PREF_3D_TEXTURE_QUALITY, _texturingQuality);
    INT_ENTRY  (PREF_3D_SHADE_MODE,      _shadeMode);
    BOOL_ENTRY (PREF_3D_RGB_LIGHTING,    _rgbMode);
    BOOL_ENTRY (PREF_3D_DITHER_ENABLE,   _dithering);
    BOOL_ENTRY (PREF_3D_PERSP_CORRECT,   _texmapPerspect);
    INT_ENTRY  (PREF_3D_USEMMX,          _useMMX);

    BOOL_ENTRY(PREF_ENGINE_OPTIMIZATIONS_ON, _engineOptimization);

    if (0 == lstrcmp(prefName, "Max FPS")) {

        if (puttingPref) {
            EXTRACT_DOUBLE(*pV, &dbl);
            _minFrameDuration = (dbl == 0.0 ? 0.0 : 1.0 / dbl);
        } else {
            b = (_minFrameDuration == 0.0 ? 0.0 : 1.0 / _minFrameDuration);
            INJECT_DOUBLE(b, pV);
        }

        return S_OK;
    }

    // Only allow getting of the Override property and the 3D hw usage
    // property...
    if (!puttingPref) {
        BOOL_ENTRY(PREF_ENGINE_OVERRIDE_APP_PREFS, _overrideMode);
    }

    BOOL_ENTRY(PREF_3D_USEHW, _useHW);
    BOOL_ENTRY("UseVideoMemory", _useHW);
    BOOL_ENTRY("DirtyRectsOptimization", _dirtyRectsOn);

    BOOL_ENTRY("BitmapCachingOptimization", _BitmapCachingOn);
    
    BOOL_ENTRY("EnableDynamicConstancyAnalysis", _dynamicConstancyAnalysisOn);

    BOOL_ENTRY("VolatileRenderingSurface", _volatileRenderingSurface);

    // If we get here, we've hit an invalid entry.
    DASetLastError(E_INVALIDARG, IDS_ERR_INVALIDARG);
    return E_INVALIDARG;
}

HRESULT
PrivatePreferences::PutPreference(char *prefName, VARIANT v)
{
    // If we are in the mode where we always override the application's
    // preferences, just return immediately without doing the set.
    if (_overrideMode) {
        return S_OK;
    } else {
        // Actually do the work.
        return DoPreference(prefName, TRUE, &v);
    }
}
HRESULT
PrivatePreferences::GetPreference(char *prefName, VARIANT *pV)
{
    return DoPreference(prefName, FALSE, pV);
}


void
PrivatePreferences::Propagate()
{
    UpdateAllUserPreferences(this, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\stlsubst.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

  Provide a specific set of helper functions for void* containers.
  Avoids STL template code bloat.  Rule is that individual functions
  that are large in size should have helper functions here, so they're
  not expanded at every use.

*******************************************************************************/

#include "headers.h"
#include "privinc/stlsubst.h"

// Push onto the end of vectors
void
VectorPushBackPtr(vector<void*>& vec, void *newElt)
{
    vec.push_back(newElt);
}

// Push onto stacks.
void
StackVectorPushPtr(stack<void* >& vec,
                   void *newElt)
{
    vec.push(newElt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\sndfile.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Generic file read interface for all sound file types and compression
    schemes.

    XXX Initialy only .wav is supported
        We can only read files
        And the code isn't setup for multiple formats

--*/

#include "headers.h"
#include <windows.h>
#include <string.h>
#include <mbstring.h>
#include <urlmon.h>
#include "privinc/debug.h"
#include "privinc/sndfile.h"
#include "privinc/except.h"
#include "privinc/resource.h"


SndFile *CreateSoundFile(char *fn)
{
// determine what kind of sound file we are dealing with using
// file extension or magic

// return that kind of sound file reading object
return NEW WaveSoundFile(fn);
}


WaveSoundFile::WaveSoundFile(char *fn)
{
    char        string[1024];
    MMIOINFO    mmioInfo;
    int         err;
    int         iSize;
    WAVEFORMAT *pfmt = 0;

    // copy fileName
    _fileName = (char *)ThrowIfFailed(malloc(strlen(fn)+1));
    lstrcpy(_fileName, fn);

    // open the file   //XXX we realy need to know the mode R|W
    memset(&mmioInfo, 0, sizeof(MMIOINFO)); // these things are horrible!
    _fileHandle = mmioOpen((char *)_fileName, &mmioInfo,
                           MMIO_READ | MMIO_ALLOCBUF);
    if(!_fileHandle) {
         err = mmioInfo.wErrorRet;
         switch(err) {
             case MMIOERR_FILENOTFOUND:
             case MMIOERR_PATHNOTFOUND:
                 RaiseException_UserError(E_FAIL, IDS_ERR_FILE_NOT_FOUND,_fileName);

             case MMIOERR_OUTOFMEMORY: 
                 RaiseException_OutOfMemory("mmio: out of memory", 0);
                 
             case MMIOERR_ACCESSDENIED:
                 RaiseException_UserError(E_FAIL, IDS_ERR_ACCESS_DENIED, string);

             case MMIOERR_INVALIDFILE:
                 RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_fileName);

             case MMIOERR_NETWORKERROR:     
                 RaiseException_InternalError("mmio: Network Error");

             case MMIOERR_SHARINGVIOLATION:
                 RaiseException_UserError(E_FAIL, IDS_ERR_SHARING_VIOLATION, string);

             case MMIOERR_TOOMANYOPENFILES: 
                 RaiseException_InternalError("mmio: Too many open files");
             default: 
                 RaiseException_InternalError("mmio: Unknown Error");
         }
    }

    // read the header
    char errbuff[1024];

    // Check whether it's a RIFF WAVE file.
    MMCKINFO ckFile;
    ckFile.fccType = mmioFOURCC('W','A','V','E');

    if (mmioDescend(_fileHandle, &ckFile, NULL, MMIO_FINDRIFF) != 0) {
        TraceTag((tagSoundErrors, _fileName));
        RaiseException_UserError(E_FAIL, IDS_ERR_SND_WRONG_FILETYPE, _fileName);
    }

    // Find the 'fmt ' chunk.
    MMCKINFO ckChunk;
    ckChunk.ckid = mmioFOURCC('f','m','t',' ');
    if (mmioDescend(_fileHandle, &ckChunk, &ckFile, MMIO_FINDCHUNK) != 0) {
        wsprintf(errbuff, "WavSoundClass mmioDescend failed, no fmt chunk");
        TraceTag((tagSoundErrors, errbuff));
        RaiseException_InternalError(errbuff);
    }

    // Allocate some memory for the fmt chunk.
    iSize = ckChunk.cksize;
    pfmt = (WAVEFORMAT*) malloc(iSize);
    if (!pfmt) {
        wsprintf(errbuff,
        "WavSoundClass malloc failed, couldn't allocate WAVEFORMAT");
        TraceTag((tagSoundErrors, errbuff));
#if _MEMORY_TRACKING
        OutputDebugString("\nDirectAnimation: Out Of Memory\n");
        F3DebugBreak();
#endif
        RaiseException_InternalError(errbuff);
    }

    // Read the fmt chunk.
    if (mmioRead(_fileHandle, (char*)pfmt, iSize) != iSize) {
        wsprintf(errbuff,
        "WavSoundClass mmioRead failed, couldn't read fmt chunk");
        TraceTag((tagSoundErrors, errbuff));
        RaiseException_InternalError(errbuff);
    }

    // record the format info
    _fileNumChannels    = pfmt->nChannels;
    _fileSampleRate     = pfmt->nSamplesPerSec;
    _fileBytesPerSample = pfmt->nBlockAlign/pfmt->nChannels;


    mmioAscend(_fileHandle, &ckChunk, 0); // Get out of the fmt chunk.

    // Find the 'data' chunk.
    ckChunk.ckid = mmioFOURCC('d','a','t','a');
    if (mmioDescend(_fileHandle, &ckChunk, &ckFile, MMIO_FINDCHUNK) != 0) {
        wsprintf(errbuff, "WavSoundClass mmioDescend failed, no data chunk");
        TraceTag((tagSoundErrors, errbuff));
        RaiseException_InternalError(errbuff);
    }

    // gather data chunk statistics
    _fileNumSampleBytes = ckChunk.cksize;
    _fileNumFrames      = ckChunk.cksize/_fileNumChannels/_fileBytesPerSample;
    _fileLengthSeconds  = _fileNumFrames/_fileSampleRate;

    // determine location of the data block
    _dataBlockLocation = mmioSeek(_fileHandle, 0, SEEK_CUR);
    if(_dataBlockLocation == -1) {
        wsprintf(errbuff, "WavSoundClass mmioSeek failed");
        TraceTag((tagSoundErrors, errbuff));
        RaiseException_InternalError(errbuff);
    }

    // compute the location of the end of data block
    _eoDataBlockLocation = _dataBlockLocation + _fileNumSampleBytes;
}


WaveSoundFile::~WaveSoundFile()
{
// XXX flush the file if it is open

// close the file if it is open
if(_fileHandle)
    mmioClose(_fileHandle, 0);
}


void
WaveSoundFile::SeekFrames(long frameOffset, int whence)
{
    long byteLocation;  // location we are going to compute then seek to
    long relativeBytes = frameOffset * _fileNumChannels * _fileBytesPerSample;
    long startLocation; // location offset from
    char string[1024];


    switch(whence) {
        case SEEK_SET: startLocation = _dataBlockLocation;   break;
        case SEEK_CUR: startLocation =
                           mmioSeek(_fileHandle, 0, SEEK_CUR); break;
        case SEEK_END: startLocation = _eoDataBlockLocation; break;

        default: 
            RaiseException_InternalError("SeekFrames: unknown relative parameter\n");
    }
    byteLocation = startLocation + relativeBytes;
    if(mmioSeek(_fileHandle, byteLocation, SEEK_SET)==-1) {
        wsprintf(string, "mmioSeek failed");
        TraceTag((tagSoundErrors, string));
        RaiseException_InternalError(string);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\storeobj.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of objects that allocate off of dynamically scoped
    storage heaps.

--*/

#include "headers.h"
#include <malloc.h>
#include "backend/gci.h"
#include "appelles/common.h"
#include "privinc/debug.h"
#include "privinc/opt.h"

#include <stdio.h>
#include <windows.h> // Needed for va_start, why?

#include "privinc/except.h"

DeclareTag(tagGCStoreObj, "GC", "GC StoreObj trace");


////// Implementation of public interface //////

#if _DEBUGMEM
#ifdef new
#define _STOREOBJ_NEWREDEF
#undef new
#endif

void *
StoreObj::operator new(size_t size, int block, char * szFileName, int nLine)
{
    DynamicHeap *heap;
    
    StoreObj *p = (StoreObj*) AllocateFromStoreFn(size,
                                                  szFileName,
                                                  nLine,
                                                  &heap);

    if (heap == &GetGCHeap()) {
        GCAddToAllocated(p);

        TraceTag((tagGCStoreObj, "StoreObj::operator new %s:Line(%d) Addr: %lx size= %d.\n", szFileName, nLine, p, size));
    }

    return p;
}

#ifdef STOREOBJ_NEWREDEF
#undef STOREOBJ_NEWREDEF
#define new new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif

#else

void *
StoreObj::operator new(size_t size)
{
    DynamicHeap *heap;
    
    StoreObj *p = (StoreObj*) AllocateFromStoreFn(size, &heap);

    if (heap == &GetGCHeap()) GCAddToAllocated(p);

    return p;
}
#endif  // _DEBUGMEM

void
StoreObj::operator delete(void *ptr)
{
    // If the GCFREEING flag is not set, probably there is an
    // exception in the constructor, and we're unwinding.
    // So we need to remove it from the GC allocated list.
    if (&GetHeapOnTopOfStack() == &GetGCHeap()) {
        if (((GCBase*)(ptr))->GetType() != GCBase::GCFREEING)
            GCRemoveFromAllocated((GCBase*) ptr);
    }

    //Assert(GetHeapOnTopOfStack().ValidateMemory(ptr));
    
    TraceTag((tagGCStoreObj, "StoreObj::operator delete Addr: %lx.\n", ptr));
    
    DeallocateFromStore(ptr);
}

// Allocate memory from the current store.
#if _DEBUGMEM
void *
AllocateFromStoreFn(size_t size, char * szFileName, int nLine,
                    DynamicHeap **ppHeap)
{
    DynamicHeap &heap = GetHeapOnTopOfStack();

    if (ppHeap) {
        *ppHeap = &heap;
    }
    
    return heap.Allocate(size, szFileName, nLine);
}
#else
void *
AllocateFromStoreFn(size_t size, DynamicHeap **ppHeap)
{
    DynamicHeap &heap = GetHeapOnTopOfStack();

    if (ppHeap) {
        *ppHeap = &heap;
    }
    
    return heap.Allocate(size);
}
#endif  // _DEBUGMEM

#if _DEBUGMEM
void *StoreAllocateFn(DynamicHeap& heap, size_t size, char * szFileName, int nLine)
{
    return heap.Allocate(size, szFileName, nLine);
}
#else
void *StoreAllocateFn(DynamicHeap& heap, size_t size)
{
    return heap.Allocate(size);
}
#endif // _DEBUGMEM

// Deallocate memory that was allocated on the current store.  Results
// are undefined if the memory was allocated on a different store.
void
DeallocateFromStore(void *ptr)
{
    // Here, we assume that this pointer was allocated on the same
    // heap that it's being freed on.  We don't know this, for sure,
    // though.
    GetHeapOnTopOfStack().Deallocate(ptr);
}

void StoreDeallocate(DynamicHeap& heap, void *ptr)
{
    heap.Deallocate(ptr);
}

Real *
RealToRealPtr(Real val)
{
    // Copy the value to the store on the top of the heap stack, and
    // return a pointer to that place.
    Real *place = (Real *)AllocateFromStore(sizeof(Real));
    *place = val;
    return place;
}

AxAValue
AxAValueObj::Cache(AxAValue obj, CacheParam &p)
{
    Image *origImage = NULL;
    
    if (obj->GetTypeInfo() == ImageType) {
        origImage = SAFE_CAST(Image *, obj);
        Image *cache = origImage->GetCachedImage();

        if (cache) return cache;
    }

    AxAValue c = obj->_Cache(p);

    if (origImage) {
        Image *newImage = SAFE_CAST(Image *, c);
        origImage->SetCachedImage(newImage);
    }
    
    return c;
}


AxAValue
AxAValueObj::_Cache(CacheParam &p)
{ 
    if (p._pCacheToReuse) {
        *p._pCacheToReuse = NULL;
    }
    return this;
}


AxAValue
AxAValueObj::RewriteOptimization(RewriteOptimizationParam &param)
{
    return this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\storage.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Implements dynamically scoped storage, and the stack of these guys.

*******************************************************************************/

#include "headers.h"
#include "privinc/storeobj.h"
#include "privinc/mutex.h"
#include "privinc/debug.h"
#include "privinc/stlsubst.h"
#include "privinc/except.h"
#include "privinc/tls.h"

#if DEVELOPER_DEBUG
class TransientHeapImpl;
typedef list<TransientHeapImpl *> DynamicHeapList;
DynamicHeapList * g_heapList = NULL;
CritSect * g_heapListCS = NULL;
#endif

// Make the global systemHeap initially be NULL.
DynamicHeap *systemHeap = NULL;
DynamicHeap& GetSystemHeap() { return *systemHeap; }

DynamicHeap *initHeap = NULL;
DynamicHeap& GetInitHeap() { return *initHeap; }

// Base-class virtual destructor doesn't do anything.
DynamicHeap::~DynamicHeap()
{
}

///////////////// Transient Heap /////////////////////////
//
//  This class of Dynamic Heap allocates memory out of a set of fixed
// size memory chunks, and, if the chunks run out, a new one is
// allocated.  Individually allocated memory is never explicitly
// deallocated.  Rather, the Reset() method resets the pointer to
// start allocating from the first chunk again.  This is used
// primarily in per-frame generation, where memory used for one frame
// isn't accessed on subsequent frames.
//
//////////////////////////////////////////////////////////

class MemoryChunk : public AxAThrowingAllocatorClass {
  public:

    // Allocate the memory chunk with the specified size.
    MemoryChunk(size_t size, HANDLE heap);

    // Destroy the chunk simply by freeing the associated memory.
    ~MemoryChunk() {
        HeapFree(_heap, HEAP_NO_SERIALIZE, _block);       
    }

    // Allocate approp num of bytes from chunk, or return NULL if not
    // available. 
    void *Allocate(size_t bytesToAlloc);

    // Reset the pointers from which allocation occurs.  Clear if
    // appropriate.
    void Reset(Bool clear) {

        _currPtr = _block;
        _bytesLeft = _size;

#if DEVELOPER_DEBUG
        // If debugging, set the entire memory chunk to an easily
        // recognized value.  This also ensures that code is unable to
        // usefully access memory that's already been "freed"
        if (clear) {
            memset(_block, 0xCC, _size);
        }

        // used to tell Purify to color memory properly
        PurifyMarkAsUninitialized(_block,_size);
#endif DEBUG

    }

#if DEVELOPER_DEBUG
    void Dump() const {
        TraceTag((tagTransientHeapLifetime,
          "Chunk @ 0x%x, CurrPtr @ 0x%x, %d/%d (%5.1f%%) bytes used",
                     _block, _currPtr, _size - _bytesLeft, _size,
                     ((Real)(_size - _bytesLeft)) * 100 / ((Real)_size)));
    }
#endif
#if DEVELOPER_DEBUG
    bool ValidateMemory(void * ptr) {
        return ((ptr >= _block) && (ptr < _currPtr));
    }
#endif

  protected:
    char        *_block;
    char        *_currPtr;
    size_t       _bytesLeft;
    const size_t _size;
    HANDLE       _heap;
};

// Allocate the memory chunk with the specified size.
MemoryChunk::MemoryChunk(size_t size, HANDLE heap) : _size(size), _heap(heap)
{
    _block = (char *)HeapAlloc(_heap, HEAP_NO_SERIALIZE, _size);
    if (!_block)
    {
        RaiseException_OutOfMemory("MemoryChunk::MemoryChunk()", _size);
    }
#if _DEBUG
    // used to tell Purify to color memory properly
    PurifyMarkAsUninitialized(_block,_size);
#endif

    _currPtr = _block;
    _bytesLeft = _size;
}

// Allocate approp num of bytes from chunk, or return NULL if not
// available. 
void *
MemoryChunk::Allocate(size_t bytesToAlloc) {

    void *returnVal = NULL;

    // Adjust the bytesToAlloc to be 8 byte aligned so that we do not
    // lose performance or cause problems for system components
    
    bytesToAlloc = (bytesToAlloc + 0x7) & ~0x7;
    
    // If there's enough space, adjust the values and return the
    // current pointer, else return NULL.
    if (bytesToAlloc <= _bytesLeft) {
        returnVal = _currPtr;
        _currPtr += bytesToAlloc;
        _bytesLeft -= bytesToAlloc;
#if _DEBUG
        // used to tell Purify to color memory properly
        PurifyMarkAsInitialized(_currPtr,bytesToAlloc);
#endif
    }

    return returnVal;
}

static void DoDeleters(set<DynamicHeap::DynamicDeleter*>& deleters)
{
    // Free the deleters
    for (set<DynamicHeap::DynamicDeleter*>::iterator s = deleters.begin();
         s != deleters.end(); s++) {
        (*s)->DoTheDeletion();
        delete (*s);
    }

    deleters.erase(deleters.begin(), deleters.end());
}


class TransientHeapImpl : public DynamicHeap {
  public:
    TransientHeapImpl(char *name, size_t initialSize, Real growthRate);
    ~TransientHeapImpl();
#if _DEBUGMEM
    void *Allocate(size_t size, char * szFileName, int nLine) { return Allocate(size); }
#endif
    void *Allocate(size_t size);
    void Deallocate(void *ptr);
    void Reset(Bool);
    void RegisterDynamicDeleter(DynamicDeleter *deleter);

    void UnregisterDynamicDeleter(DynamicDeleter* deleter);
        
    size_t PtrSize(void *ptr) { return 0; }

    bool IsTransientHeap() { return true; }

#if DEVELOPER_DEBUG
    void  Dump() const;
    char *Name() const { return _name; }
    size_t BytesUsed() { return _totalAlloc; }
    bool  ValidateMemory(void *ptr);
#endif

  protected:
    char                   *_name;
    Real                    _growthRate;
    size_t                  _sizeOfLast;
    int                     _maxChunkIndex;

#if DEVELOPER_DEBUG
    size_t                  _totalAlloc;
#endif

    vector<MemoryChunk*>    _chunks;
    MemoryChunk            *_currentChunk;
    int                     _currentChunkIndex;
    HANDLE                  _heap; // to alloc chunks onto.

    set<DynamicDeleter* > deleters;
};

TransientHeapImpl::TransientHeapImpl(char *n,
                                     size_t size,
                                     Real growthR)
: _name(NULL),
  _maxChunkIndex(0),
  _growthRate(growthR),
  _sizeOfLast(size),
  _heap(NULL)
{
    _name = CopyString(n);

    // Create the heap that the memory will be allocated from
    _heap = HeapCreate(HEAP_NO_SERIALIZE, 0, 0);

    if (_heap == NULL ||
        _name == NULL)
    {
        RaiseException_OutOfMemory ("Could not allocate heap", sizeof(_heap)) ;
    }
    
    // Create the first memory chunk, and add it to the chunks list.
    VECTOR_PUSH_BACK_PTR(_chunks, NEW MemoryChunk(size, _heap));

    _currentChunk = _chunks[0];
    _currentChunkIndex = 0;

#if DEVELOPER_DEBUG    
    _totalAlloc = size;

    {
        CritSectGrabber _csg(*g_heapListCS);
        g_heapList->push_back(this);
    }
#endif    
}

TransientHeapImpl::~TransientHeapImpl()
{
#if DEVELOPER_DEBUG
    {
        CritSectGrabber _csg(*g_heapListCS);
        g_heapList->remove(this);
    }
#endif

    TraceTag((tagTransientHeapLifetime, "Dumping, then deleting %s", _name));

#if DEVELOPER_DEBUG
    Dump();
#endif

    DoDeleters(deleters);

    for (int i = 0; i < _maxChunkIndex + 1; i++) {
        delete _chunks[i];
    }

    delete [] _name;

    if (_heap)
    {
        Assert(HeapValidate(_heap, NULL, NULL));

        if (HeapValidate(_heap, NULL, NULL)) {
            HeapDestroy(_heap);
        }

        _heap = NULL;
    }
}

#if DEVELOPER_DEBUG
bool
TransientHeapImpl::ValidateMemory(void *ptr)
{
    vector<MemoryChunk*>::iterator beginning = _chunks.begin();
    vector<MemoryChunk*>::iterator ending =
        beginning + _currentChunkIndex + 1;

    // Iterate through the chunks, calling Reset() on each.
    vector<MemoryChunk*>::iterator i;
    for (i = beginning; i < ending; i++) {
        if ((*i)->ValidateMemory(ptr))
            return TRUE;
    }

    return FALSE;
}
#endif

void *
TransientHeapImpl::Allocate(size_t size)
{
    void *returnVal = _currentChunk->Allocate(size);

    // If successful, just return result
    if (returnVal != NULL) {
        return returnVal;
    }

    // See if there is a next chunk to move to...

    if (_currentChunkIndex == _maxChunkIndex) {

        // ...need to create a new chunk

        // Figure out its size
        size_t newSize = (size_t)(_sizeOfLast * _growthRate);
        if (newSize < size) {
            newSize = size;
        }

        // Allocate a new chunk with the new size.
        VECTOR_PUSH_BACK_PTR(_chunks, NEW MemoryChunk(newSize, _heap));

        // update counters, etc.
        _maxChunkIndex++;
        _sizeOfLast = newSize;

#if DEVELOPER_DEBUG
        _totalAlloc += newSize;
#endif
        
    }

    // Move to the next chunk (may be newly created)
    _currentChunkIndex++;
    _currentChunk = _chunks[_currentChunkIndex];

    // Recursively call this method, and try again on the new
    // chunk we're on.
    return Allocate(size);
}

void
TransientHeapImpl::Deallocate(void *ptr)
{
    Assert (ValidateMemory(ptr));

    // De-allocating from a TransientHeap doesn't really make sense.
    // Don't do anything.
}

void
TransientHeapImpl::Reset(Bool clear)
{
    // Do the deletions first and then reset the chunks
    DoDeleters(deleters);

    // Stash off this value so that it needn't be computed, including
    // call to begin(), on every time through the loop.
    vector<MemoryChunk*>::iterator beginning = _chunks.begin();
    vector<MemoryChunk*>::iterator ending =
        beginning + _currentChunkIndex + 1;

    // Iterate through the chunks, calling Reset() on each.
    vector<MemoryChunk*>::iterator i;
    for (i = beginning; i < ending; i++) {
        (*i)->Reset(clear);
    }

    // Start again at the first chunk.
    _currentChunkIndex = 0;
    _currentChunk = _chunks[0];
}

void
TransientHeapImpl::RegisterDynamicDeleter(DynamicDeleter *deleter)
{
    // Just push it onto the vector.  This will be called and deleted
    // when reset is invoked.
    deleters.insert(deleter);
}

void
TransientHeapImpl::UnregisterDynamicDeleter(DynamicDeleter *deleter)
{
    deleters.erase(deleter);
}

#if DEVELOPER_DEBUG

void
TransientHeapImpl::Dump() const
{
    TraceTag((tagTransientHeapLifetime,
              "%s\tNum Chunks %d\tCurrent Chunk Index %d\tGrowth Rate %8.5f\tLast Size %d",
               _name,
               _maxChunkIndex + 1,
               _currentChunkIndex,
               _growthRate,
               _sizeOfLast));

    // Just use array indexing here rather than iterators, as its
    // easier to write, and performance isn't important here.
    for (int i = 0; i < _maxChunkIndex + 1; i++) {
        TraceTag((tagTransientHeapLifetime, "Chunk %d: ", i));
        _chunks[i]->Dump();
    }

    TraceTag((tagTransientHeapLifetime, "\n"));

}

#endif

DynamicHeap&
TransientHeap(char *name, size_t initial_size, Real growthRate)
{
    return *NEW TransientHeapImpl(name, initial_size, growthRate);
}

void
DestroyTransientHeap(DynamicHeap& heap)
{
    delete &heap;
}

///////
/////// Win32 Heap
///////

class Win32Heap : public DynamicHeap
{
  public:
    Win32Heap(char *name,
              DWORD fOptions,
              DWORD dwInitialSize,
              DWORD dwMaxSize) ;
    ~Win32Heap() ;

#if _DEBUGMEM
    void *Allocate(size_t size, char * szFileName, int nLine) {
        void *result;

        result = _malloc_dbg(size, _NORMAL_BLOCK, szFileName, nLine);

        return result;
    }
#endif
    
    void *Allocate(size_t size) ;

    void Deallocate(void *ptr) {
        free(ptr);
    }

    void Reset(Bool) ;

    // Win32 heap is never reset, so we never will call the deleter,
    // so we just delete it right away.
    void  RegisterDynamicDeleter(DynamicDeleter* deleter) {
        delete deleter;
    }

    void UnregisterDynamicDeleter(DynamicDeleter* deleter) { }
        
    size_t PtrSize(void *ptr) { return _msize(ptr); }

    bool IsTransientHeap() { return false; }

#if DEVELOPER_DEBUG
    virtual bool ValidateMemory(void *ptr) {
        // TODO:
        return false;
    }
        
    void Dump() const {
        TraceTag((tagTransientHeapLifetime, "Win32 Heap"));
    }

    char *Name() const { return _name; }

    size_t BytesUsed() {
        CritSectGrabber csg(_debugcs);
        return _totalAlloc;
    }
#endif
    
  protected:
    char * _name ;
    HANDLE _heap ;
    DWORD _fOptions ;
    DWORD _dwInitialSize ;
    DWORD _dwMaxSize ;

#if DEVELOPER_DEBUG
    size_t _totalAlloc;
    CritSect _debugcs;
#endif    
};

Win32Heap::Win32Heap(char *name,
                     DWORD fOptions,
                     DWORD dwInitialSize,
                     DWORD dwMaxSize)
: _fOptions(fOptions),
  _dwInitialSize(dwInitialSize),
  _dwMaxSize(dwMaxSize),
#if DEVELOPER_DEBUG
  _totalAlloc(0),
#endif
  _heap(NULL),
  _name(NULL)
{
    TraceTag((tagTransientHeapLifetime, "Creating win32 heap store"));

    _name = new char[lstrlen(name) + 1];
    lstrcpy(_name, name);
}

Win32Heap::~Win32Heap()
{
    delete [] _name;
}

void *
Win32Heap::Allocate(size_t size)
{
    void *result = malloc(size);
    if (!result)
    {
        RaiseException_OutOfMemory("Win32Heap::Allocate() - out of memory", size);
    }

#if DEVELOPER_DEBUG
    CritSectGrabber csg(_debugcs);
    // Use the size returned from the heap since it is can be greater
    // than the size we asked for
    _totalAlloc += _msize(result);
#endif

    return result;
}

void
Win32Heap::Reset(Bool clear)
{
    Assert(false && "Cannot reset Win32 Heaps");
}

DynamicHeap&
CreateWin32Heap(char *name,
                DWORD fOptions,
                DWORD dwInitialSize,
                DWORD dwMaxSize)
{
    return * NEW Win32Heap (name,
                            fOptions,
                            dwInitialSize,
                            dwMaxSize) ;
}

void DestroyWin32Heap(DynamicHeap& heap)
{ delete &heap ; }


///////
/////// Heap Stack implementation
///////

// Create a new stack and store it into the TLS location given by
// incoming index.
LPVOID
CreateNewStructureForThread(DWORD tlsIndex)
{
    ThreadLocalStructure *tlstruct = NEW ThreadLocalStructure(); 

    // TODO:  Need to have a means of intercepting threads when they
    // are about to terminate, in order to free up any storage
    // associated with them in TLS.

    TraceTag((tagTransientHeapLifetime,
              "Created New Struct for Thread %u at 0x%x",
               GetCurrentThreadId(),
               tlstruct));

    // Set the TLS data to the new stack.
    LPVOID result = (LPVOID)tlstruct;
    BOOL ok = TlsSetValue(tlsIndex, result);
    Assert((ok == TRUE) && "Error in TlsSetValue");

    return result;
}

// Will be initialized in initialization function below.
DWORD localStructureTlsIndex = 0xFFFFFFFF;

inline stack<DynamicHeap* > *
GetThreadLocalStack()
{
    return &(GetThreadLocalStructure()->_stackOfHeaps);
}


DynamicHeap&
GetHeapOnTopOfStack()
{
#ifdef _DEBUG
    int sz = GetThreadLocalStack()->size();
    Assert (sz > 0  && "GetHeapOnTopOfStack: empty heap stack on this thread (there should be a dynamicHeap on here)!") ;
#endif
    return *GetThreadLocalStack()->top();
}

void
PushDynamicHeap(DynamicHeap& heap)
{
    TraceTag((tagTransientHeapDynamic, "Pushing %s", heap.Name()));
    STACK_VECTOR_PUSH_PTR(*GetThreadLocalStack(), &heap);
}

void
PopDynamicHeap()
{
    TraceTag((tagTransientHeapDynamic, "Popping %s",
              GetHeapOnTopOfStack().Name()));
    GetThreadLocalStack()->pop();
}

void
ResetDynamicHeap(DynamicHeap& heap)
{
    // Always TRUE, no clear code would be generated in debug mode.
    heap.Reset(TRUE);
}

StoreObj::StoreObj()
{
    // Can't do it here because this is not called only at new.
#if 0
    if (&GetHeapOnTopOfStack() == &GetGCHeap())
        GCAddToAllocated(this);
#endif
    
    SetType(STOREOBJTYPE);
}

#if DEVELOPER_DEBUG
size_t
DynamicHeapBytesUsed()
{
    size_t size = 0;
    
    CritSectGrabber _csg(*g_heapListCS);

    for (DynamicHeapList::iterator i = g_heapList->begin();
         i != g_heapList->end();
         i++)
    {
        size += (*i)->BytesUsed();
    }

    return size;
}

bool
OnAnyTransientHeap(void *ptr)
{
    CritSectGrabber _csg(*g_heapListCS);

    for (DynamicHeapList::iterator i = g_heapList->begin();
         i != g_heapList->end();
         i++)
    {
        if ((*i)->ValidateMemory(ptr))
            return true;
    }

    return false;
}
#endif

void
InitializeModule_Storage()
{
    localStructureTlsIndex = TlsAlloc();

    // If result is 0xFFFFFFFF, allocation failed.
    Assert(localStructureTlsIndex != 0xFFFFFFFF);

#if DEVELOPER_DEBUG
    g_heapList = NEW DynamicHeapList;
    g_heapListCS = NEW CritSect;
#endif

    // Create the system heap
    systemHeap = NEW Win32Heap("System Heap",0,0,0) ;

    initHeap = NEW TransientHeapImpl("Init Heap", 1000, 1.5) ;
}

void
DeinitializeModule_Storage(bool bShutdown)
{
    if (systemHeap) {
        delete systemHeap;
        systemHeap = NULL;
    }

    if (initHeap) {
        delete initHeap;
        initHeap = NULL;
    }

    if (localStructureTlsIndex != 0xFFFFFFFF)
        TlsFree(localStructureTlsIndex);

#if DEVELOPER_DEBUG
    delete g_heapList;
    g_heapList = NULL;
    
    delete g_heapListCS;
    g_heapListCS = NULL;
#endif
}

void
DeinitializeThread_Storage()
{
    // Grab what is stored in TLS at this index.
    ThreadLocalStructure * result = (ThreadLocalStructure *) TlsGetValue(localStructureTlsIndex);

    if (result)
    {
        delete result;
        TlsSetValue(localStructureTlsIndex, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\timer.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    This module contains the member functions for the Timer class, in addition
    to 'double RealTime()', which returns the current timestamp as a real-
    valued number of seconds since the Dawn of Unix (around 1970).  See
    timer.h for a description of the Timer class.

--*/


#include "headers.h"
#include <sys/types.h>
#include <sys/timeb.h>
#include "timer.h"



/*****************************************************************************
This function returns the current time as seconds elapsed since the magic
date (from the ftime function).
*****************************************************************************/

double RealTime (void)
{
    struct timeb t;
    ftime (&t);
    return double(t.time) + (double(t.millitm)/1000);
}



/*****************************************************************************
This function constructs a timer variable.  Note that a side effect of the
timer construction is that timer is created running.  This can be useful if
you want to calculate the total time in a function, for example.
*****************************************************************************/

Timer::Timer (void)
{
    this->total = 0;
    this->tstart = RealTime();
}



/*****************************************************************************
This function resets the timer to 0, non-running.
*****************************************************************************/

void Timer::reset (void)
{
    total = 0;
    tstart = -1;
}



/*****************************************************************************
This function starts the timer running again.  If the timer was already
running, it resets the current start time (but not the elapsed time).
*****************************************************************************/

void Timer::start (void)
{
    tstart = RealTime();
}



/*****************************************************************************
This function resets the timer and then starts it running again.
*****************************************************************************/

void Timer::restart (void)
{
    reset();
    start();
}



/*****************************************************************************
This function stops the timer and adds the current lap time to the elapsed
time.  If the timer is not running, this has no effect.
*****************************************************************************/

void Timer::stop (void)
{
    if (tstart > 0)
    {   total += RealTime() - tstart;
        tstart = -1;
    }
}



/*****************************************************************************
This function read the current total elapsed time of the timer.  It has no
effect on the run state of the timer.
*****************************************************************************/

double Timer::read (void)
{
    if (tstart <= 0)
            return total;
    else
            return total + (RealTime() - tstart);
}



/*****************************************************************************
This function read the current lap time.  It has no effect on the run state
of the timer.
*****************************************************************************/

double Timer::read_lap (void)
{
    return (tstart <= 0) ? 0 : (RealTime() - tstart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\timer.h ===
#ifndef _TIMER_H
#define _TIMER_H

/*++

Copyright (c) 1995-96 Microsoft Corporation

Module Name:
    timer.h

Abstract:
    See below.

Revision:
    $Header: /appelles/src/utils/timer.h 2     5/08/95 11:07a Stevehol $

--*/

/*******************************************************************************

        ``For time is the longest distance between two places.''
                    Tennessee Williams, in The Glass Menagerie, sc. 7.

DESCRIPTION

    The timer class models a stopwatch with lap times.  The timer is started
    on construction in case the programmer wants to get the time since
    creation (possibly useful for block/function lifespan.   The timer units
    are seconds.  The following operations are supported:


FUNCTIONS

    reset:     Resets the elapsed time to zero and sets the timer to
               non-running.

    restart:   Resets the elapsed time and starts the timer running.

    start:     Starts the timer running.  This begins a new lap if the timer
               is not currently running.  If the timer is already running, it
               resets the start of the current lap.

    stop:      This stops the timer.  Note that it does not reset the elapsed
               time to zero (you need to use reset or restart to do this).

    read:      Reads the current elapsed time, including the current lap.
               This does not affect the run-state of the timer.

    read_lap:  Reads the elapsed time since the last timer start.


EXAMPLES

    To find the amount of time spent in a block:

        {
            Timer timer;
            ...
            printf ("Time in block: %lf\n", timer.read());
        }

    To find time across a function call inside a loop:

        Timer timer;

        for (...)
        {
            ...
            timer.start();
            function ();
            timer.stop();
        }

        printf ("Total time in function: %lf\n", timer.read();

*******************************************************************************/

class Timer
{
    public:

    void   reset    (void);   // Resets timer to not-running, Zero.
    void   start    (void);   // Starts the timer running again.
    void   restart  (void);   // Resets timer and then starts it running.
    void   stop     (void);   // Stops the timer.
    double read     (void);   // Current Total Seconds Elapsed
    double read_lap (void);   // Current Seconds in Lap

    Timer ();

    private:

    double total;        // Elapsed Time of Previous Laps
    double tstart;       // Current Start Time
};


double RealTime (void);  // Returns the Timestamp as Seconds (to 4 dec places)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\registry.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    For storing and retrieving user preferences to and from the Registry

*******************************************************************************/

#include "headers.h"
#include "privinc/registry.h"

static const char *axaRegistryPreferencePrefix =
  "Software\\Microsoft\\DirectAnimation";

RegistryEntry::RegistryEntry() {}

RegistryEntry::RegistryEntry(char *subdir, char *item) :
       _subdirectory(subdir), _item(item)
{
    // Just stash off info, don't actually open anything yet.
}

void
RegistryEntry::SetEntry(char *subdirectory, char *item)
{
    _subdirectory = subdirectory;
    _item = item;
}

bool
RegistryEntry::Open(HKEY *phk)
{
    DWORD dwErrorCode;

    char key[1024];
    wsprintf(key, "%s\\%s", axaRegistryPreferencePrefix, _subdirectory);
    
    dwErrorCode = RegOpenKeyEx(HKEY_CURRENT_USER,
                               key,
                               0,
                               KEY_ALL_ACCESS,
                               phk);

    if (dwErrorCode != ERROR_SUCCESS) {
        dwErrorCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                   key,
                                   0,
                                   KEY_ALL_ACCESS,
                                   phk);
    }
    
    return (dwErrorCode == ERROR_SUCCESS);
}

void
RegistryEntry::Close(HKEY hk)
{
    DWORD dwErrorCode;

    dwErrorCode = RegCloseKey(hk);
    
    if (dwErrorCode != ERROR_SUCCESS) {
        TraceTag((tagError,
                  "Error closing registry key %s\\%s, %hr",
                  axaRegistryPreferencePrefix,
                  _subdirectory,
                  dwErrorCode));
        
        RaiseException_UserError(E_FAIL, IDS_ERR_REGISTRY_ERROR);
    }
}

////////////////  Integer Registry Entry   ///////////////////

IntRegistryEntry::IntRegistryEntry() {}

IntRegistryEntry::IntRegistryEntry(char *subdir, char *item,
                                   int initialValue)
    : RegistryEntry(subdir, item), _defaultVal(initialValue)
{
}

void
IntRegistryEntry::SetEntry(char *subdirectory, char *item)
{
    RegistryEntry::SetEntry(subdirectory, item);
}


int
IntRegistryEntry::GetValue()
{
    HKEY  hk;
    DWORD type;
    DWORD data;
    DWORD buffSize = sizeof(data);
    
    if (!Open(&hk))
        return _defaultVal;
    
    LONG lRes = RegQueryValueEx(hk,
                                _item,
                                NULL,
                                &type,
                                (LPBYTE)&data,
                                &buffSize);

    Close(hk);

    if (lRes != ERROR_SUCCESS) {

        return _defaultVal;
        
    } else {

        Assert(lRes == ERROR_SUCCESS);
        Assert(buffSize == sizeof(data));

        //Assert(type = REG_DWORD);
        Assert(type == REG_DWORD);

        return (int)(data);
    }
    
}


///////////////////////  Preference Updater Functions //////////

static vector<UpdaterFuncType> *updaterFunctions = NULL;

void
ExtendPreferenceUpdaterList(UpdaterFuncType updaterFunc)
{
    updaterFunctions->push_back(updaterFunc);
}

void
UpdateAllUserPreferences(PrivatePreferences *prefs, Bool isInitializationTime)
{
    vector<UpdaterFuncType>::iterator i;

    for (i = updaterFunctions->begin(); i != updaterFunctions->end(); i++) {
        (*i)(prefs, isInitializationTime);
    }
}

void
InitializeModule_Registry()
{
    updaterFunctions = new vector<UpdaterFuncType>;
}

void
DeinitializeModule_Registry(bool bShutdown)
{
    delete updaterFunctions;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\urlbuf.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include <urlmon.h>
#include <wininet.h>
#include "privinc/debug.h"
#include "privinc/urlbuf.h"
#include "privinc/util.h"
#include "privinc/except.h"
#include "privinc/resource.h"
#include "privinc/server.h"
#include "privinc/mutex.h"

daurlstream::daurlstream(const char * url)
{
    TraceTag((tagNetIO, "daurlstream::daurlstream"));

    HRESULT hr ;

    hr = THR(URLOpenBlockingStream(NULL,
                                   url,
                                   &_stream,0,bsc._pbsc));
    if (hr != S_OK)
        RaiseException_UserError (STG_E_FILENOTFOUND,
                            IDS_ERR_FILE_NOT_FOUND,
                            url) ;
}

INetTempFile::INetTempFile ()
: _url(NULL),
  _tmpfilename(NULL)
{
    TraceTag((tagNetIO, "INetTempFile::INetTempFile"));
}

INetTempFile::INetTempFile (LPCSTR szURL)
: _url(NULL),
  _tmpfilename(NULL)
{
    TraceTag((tagNetIO, "INetTempFile::INetTempFile(%s)", szURL));

    if (!Open(szURL)) {
        RaiseException_UserError (STG_E_FILENOTFOUND,
                            IDS_ERR_FILE_NOT_FOUND,
                            szURL) ;
    }
}

BOOL
INetTempFile::Open (LPCSTR szURL)
{
    BOOL        fRet = TRUE;

    TraceTag((tagNetIO, "INetTempFile::Open(%s)", szURL));

    Close () ;

    if (!szURL)
        return (FALSE) ;

    int len = lstrlen(szURL) ;

    _url = THROWING_ARRAY_ALLOCATOR(char, len+1);
    lstrcpy (_url, szURL) ;

    char    szOutPath[MAX_PATH];
    HRESULT hr;
    CBSCWrapper bsc;

    szOutPath[0] = 0;

    // TODO: Use the current container but it dies with the
    // current async scheme

    hr = THR(URLDownloadToCacheFile(NULL,
                                    _url,
                                    szOutPath,
                                    MAX_PATH,
                                    NULL,
                                    bsc._pbsc));

    if (hr) {

        TraceTag((tagError, "URLDownloadToCacheFile(%s):0x%X", _url, hr));
        TraceTag((tagError, "-- szOutPath = %s", szOutPath));

        goto Error;
    }
    
    _tmpfilename = THROWING_ARRAY_ALLOCATOR(char, lstrlen(szOutPath) + 1);      

    lstrcpy (_tmpfilename, szOutPath);

    TraceTag((tagNetIO, "-- _tmpfilename=%s", _tmpfilename));

  Cleanup:

    return fRet;

  Error:
    delete _url ;
    _url = NULL ;

    fRet = FALSE;

    goto Cleanup;
}

void INetTempFile::Close ()
{
    if (_url) {
        TraceTag((tagNetIO, "INetTempFile::Close(%s)", _url));

        if (_tmpfilename != _url)
        {
            delete _tmpfilename ;
            _tmpfilename = NULL ;
        }

        delete _url ;

        // This indicates we are closed
        _url = NULL ;
    }
}

INetTempFile::~INetTempFile ()
{
    TraceTag((tagNetIO, "INetTempFile::~INetTempFile"));

    Close () ;
}



//+-------------------------------------------------------------------------
//
//  CDXMBindStatusCallback implementation
//
//  Generic implementation of IBindStatusCallback.  This is the root
//  class.
//
//--------------------------------------------------------------------------

CDXMBindStatusCallback::CDXMBindStatusCallback(void)
{
    m_pbinding = NULL;
    m_cRef =  1;
}


CDXMBindStatusCallback::~CDXMBindStatusCallback(void)
{
    if (m_pbinding)
        m_pbinding->Release();
}


STDMETHODIMP
CDXMBindStatusCallback::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *) (IBindStatusCallback *) this;
    }
    else if (IsEqualIID(riid, IID_IBindStatusCallback))
    {
        *ppv = (IBindStatusCallback *) this;
    }
    else if (IsEqualIID(riid, IID_IAuthenticate))
    {
        TraceTag((tagNetIO, "CDXMBindStatusCallback::QI for IAuthenticate"));
        *ppv = (IAuthenticate *) this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG)
CDXMBindStatusCallback::AddRef(void)
{
    return m_cRef++;
}


STDMETHODIMP_(ULONG)
CDXMBindStatusCallback::Release(void)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


STDMETHODIMP
CDXMBindStatusCallback::OnStartBinding(DWORD dwReserved, IBinding* pbinding)
{
    TraceTag((tagNetIO, "CDXMBindStatusCallback::OnStartBinding"));

    if (m_pbinding != NULL)
    {
        m_pbinding->Release();
    }

    m_pbinding = pbinding;
    if (m_pbinding != NULL)
    {
        m_pbinding->AddRef();
    }

    return S_OK;
}


STDMETHODIMP
CDXMBindStatusCallback::GetPriority(LONG* pnPriority)
{
    TraceTag((tagNetIO, "CDXMBindStatusCallback::GetPriority"));
        return S_OK;
}


STDMETHODIMP
CDXMBindStatusCallback::OnLowResource(DWORD dwReserved)
{
    TraceTag((tagNetIO, "CDXMBindStatusCallback::OnLowResource"));
    return S_OK;
}


STDMETHODIMP
CDXMBindStatusCallback::OnProgress(
        ULONG ulProgress,
        ULONG ulProgressMax,
        ULONG ulStatusCode,
        LPCWSTR szStatusText)
{
    TraceTag((tagNetIO, "CDXMBindStatusCallback::OnProgress"));
    TraceTag((tagNetIO, "-- ulProg    = %d", ulProgress));
    TraceTag((tagNetIO, "-- ulProgMax = %d", ulProgressMax));
    TraceTag((tagNetIO, "-- ulStatus  = %d", ulStatusCode));
    TraceTag((tagNetIO, "-- szStatus  = %ls", szStatusText));

    return S_OK;
}


STDMETHODIMP
CDXMBindStatusCallback::OnStopBinding(HRESULT hrStatus, LPCWSTR szError)
{
    TraceTag((tagNetIO, "CDXMBindStatusCallback::OnStopBinding hrStatus: %lx", hrStatus));

    if (m_pbinding)
    {
        m_pbinding->Release();
        m_pbinding = NULL;
    }

    return S_OK;
}


STDMETHODIMP
CDXMBindStatusCallback::GetBindInfo(DWORD * pgrfBINDF, BINDINFO * pbindInfo)
{
    TraceTag((tagNetIO, "CDXMBindStatusCallback::GetBindInfo"));

    return S_OK;
}


STDMETHODIMP
CDXMBindStatusCallback::OnDataAvailable(
        DWORD grfBSCF,
        DWORD dwSize,
        FORMATETC * pfmtetc,
        STGMEDIUM * pstgmed)
{
    TraceTag((tagNetIO, "CDXMBindStatusCallback::OnDataAvailable"));

    return S_OK;
}


STDMETHODIMP
CDXMBindStatusCallback::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    TraceTag((tagNetIO, "CDXMBindStatusCallback::OnObjectAvailable"));

    return S_OK;
}


STDMETHODIMP
CDXMBindStatusCallback::Authenticate(
        HWND * phwnd,
        LPWSTR * pwszUser,
        LPWSTR * pwszPassword)
{
    TraceTag((tagNetIO, "CDXMBindStatusCallback::Authenticate"));

    if ((phwnd == NULL) || (pwszUser == NULL) || (pwszPassword == NULL))
    {
        return E_INVALIDARG;
    }

    *phwnd = GetDesktopWindow();
    *pwszUser = NULL;
    *pwszPassword = NULL;

    TraceTag((
            tagNetIO,
            "-- hwnd=%lx, user=%ls, password=%ls",
            *phwnd,
            *pwszUser,
            *pwszPassword));

    return S_OK;
}


CBSCWrapper::CBSCWrapper(void)
{
    _pbsc = new CDXMBindStatusCallback;
}


CBSCWrapper::~CBSCWrapper(void)
{
    _pbsc->Release();
}

URLRelToAbsConverter::URLRelToAbsConverter(LPSTR baseURL,
                                           LPSTR relURL)
{
    DWORD len = INTERNET_MAX_URL_LENGTH ;

    if (!InternetCombineUrlA (baseURL, relURL, _url, &len, ICU_NO_ENCODE)) {
        // If we cannot determine if the path is absolute then assume
        // it is absolute
        lstrcpyn (_url, relURL, INTERNET_MAX_URL_LENGTH) ;
    }

    _url[INTERNET_MAX_URL_LENGTH] = '\0';
}

URLCanonicalize::URLCanonicalize(LPSTR path)
{
    DWORD len = INTERNET_MAX_URL_LENGTH ;

    if (!InternetCanonicalizeUrlA (path, _url, &len, ICU_NO_ENCODE)) {
        // If we cannot determine if the path is absolute then assume
        // it is absolute
        lstrcpyn (_url, path, INTERNET_MAX_URL_LENGTH) ;
    }

    _url[INTERNET_MAX_URL_LENGTH] = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\project.inc ===
# project.inc - project specific settings

APPEL_INC_DIRS=$(SDKDIR) $(TOOLSINCLUDE) $(ATLINCLUDE) $(SRCROOT)\appel\include $(SRCROOT)\appel $(SRCROOT)\include
_USERCFLAGS=$(_USERCFLAGS) /DNDEBUG /DOS_WIN_NT_3_5 /DNOMINMAX
!if "$(_DEBUG)" == "1"
_USERCFLAGS=$(_USERCFLAGS) /GR
!endif

_NO_INCREMENTAL_LINK=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\util.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Simple utility functions.
*******************************************************************************/

#include "headers.h"
#include "privinc/util.h"
#include <sys/types.h>
#include <sys/timeb.h>
#include <eh.h>
#include "privinc/except.h"
#include "../backend/perf.h"  // for Param
#include "../backend/timetran.h"

RawString
CopyWideString(WideString bstr)
{
    long len = lstrlenW(bstr);
    // I am not sure why the buffer has to be 2 times the size
    // required but I think the conversion function must copy the
    // string first and then convert it inplace.
    RawString buf = (RawString) AllocateFromStore((len + 1) * 2 * sizeof(char)) ;
    // Need to pass in len + 1 to get the terminator
    AtlW2AHelper(buf,bstr,len + 1);
    return buf ;
}

WideString
CopyRawString(RawString str)
{
    long len = lstrlen(str);
    WideString buf = (WideString) AllocateFromStore((len + 1) * sizeof(WCHAR)) ;
    // Need to pass in len + 1 to get the terminator
    AtlA2WHelper(buf,str,len + 1);
    return buf ;
}

bool IntersectHorzRightRay(Point2Value *rayToRight, Point2Value *a, Point2Value *b)
{
    Real sx = b->x - a->x;
    Real sy = b->y - a->y;

    Real x = a->x + (sx * (rayToRight->y - a->y) / sy);

    return (x > rayToRight->x);
}



/*****************************************************************************
Given N, this function returns the smallest 2^P such that 2^P >= N.  For
example, if given 27, this function returns 32.
*****************************************************************************/

int CeilingPowerOf2 (int num)
{
    int value = 1;

    while (value && (value < num))
        value <<= 1;

    return value;
}


/*****************************************************************************
Get the current system time as a double.
*****************************************************************************/

double GetCurrTime (void)
{
    FILETIME ft;
    GetSystemTimeAsFileTime(&ft);

    ULARGE_INTEGER li100nano; // 10E-7 period
    li100nano.LowPart = ft.dwLowDateTime;
    li100nano.HighPart = ft.dwHighDateTime;

    // Convert to 1 mS period
    ULARGE_INTEGER li1mill ;

    li1mill.QuadPart = li100nano.QuadPart / 10000; // 10E-3 period

    double dlow = (double) li1mill.LowPart ;

    // Multiply by 2^32
    double dhigh = ((double) li1mill.HighPart) * 4294967296.0;

    double d1mill = dlow + dhigh;

    // Convert from 10E-3 to 1.
    return d1mill / 1000.0;
}


#if 0  /* Not required by 3D device enumeration now */
/*****************************************************************************
Indicate whether the current processor supports MMX instructions.
*****************************************************************************/

#ifndef _M_IX86

    bool MMX_Able (void) { return false; }

#else

    // Disable the warning about illegal instruction size

    #pragma warning(disable:4409)
    int IsMMX (void)
    {
        int result = 0;

        __asm xor eax,eax          ; Save everything
        __asm pushad

        __asm mov eax,1            ; Execute a CPUID instruction.
        __asm __emit 0x0F;
        __asm __emit 0xA2;

        __asm test edx,00800000h   ; Test the MMX support bit (23)

        __asm popad                ; Restore everything

        __asm setnz result         ; Set low byte to 00 (no-MMX) or 01 (MMX)

        return result;
    }
    #pragma warning(default:4409)

    static bool MMX_Able_NonNT (SYSTEM_INFO &si)
    {
        return (si.dwProcessorType == PROCESSOR_INTEL_PENTIUM) && IsMMX();
    }

    static bool MMX_Able_NT (SYSTEM_INFO &si)
    {
        bool result = false;

        if (  (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
           || (si.wProcessorLevel >= 5))
        {
            __try
            {
                // Emits an emms instruction.  This file needs to compile for
                // non-Pentium processors, so we can't use inline asm since we're
                // in the wrong processor mode.

                __asm __emit 0xf;
                __asm __emit 0x77;
                result = true;
            }
            __except ( EXCEPTION( STATUS_ILLEGAL_INSTRUCTION ) )
            {
            }
        }

        return result;
    }

    bool MMX_Able (void)
    {
        static bool initialized = false;
        static bool result = false;

        if (!initialized)
        {
            SYSTEM_INFO si;
            GetSystemInfo (&si);

            result = sysInfo.IsNT() ? MMX_Able_NT(si) : MMX_Able_NonNT(si);

            initialized = true;
        }

        return result;
    }

#endif
#endif /* 0 */


/*****************************************************************************
Compare two RECT structures (windows RECTangle)
*****************************************************************************/

int operator== (RECT &r1, RECT &r2)
{
    return (r1.left   == r2.left)
        && (r1.top    == r2.top)
        && (r1.right  == r2.right)
        && (r1.bottom == r2.bottom);
}



/*****************************************************************************
Given an IEEE floating point number, decremement/increment the mantissa by the
given amount.  Note that due to the nature of IEEE floating point numbers, an
underflow/overflow will properly adjust the exponent.
*****************************************************************************/

float MantissaDecrement (float n, int decrement)
{   *(int*)(&n) -= decrement;
    return n;
}

float MantissaIncrement (float n, int increment)
{   *(int*)(&n) += increment;
    return n;
}



DWORD
GetPerfTickCount()
{
    LARGE_INTEGER lpc;
    BOOL result = QueryPerformanceCounter(&lpc);
    return lpc.LowPart;
}

#if PERFORMANCE_REPORTING

/**************  Performance Timer  ***************/

PerformanceTimer::PerformanceTimer()
{
    _totalTicks = 0;
    _localStart = 0;
    _isStarted = false;
}

void
PerformanceTimer::Start()
{
    CritSectGrabber grab(_criticalSection);

    if (_isStarted) {
        #if _DEBUG
        if(GetCurrentThreadId() == _threadStartedOn) {
            TraceTag((tagWarning, "Timer already started on this thread"));
        }
        #endif

        // Ignore starts on other thread if we're already started.
        return;
    }

    _isStarted = true;
    _threadStartedOn = GetCurrentThreadId();
    _localStart = GetPerfTickCount();

#if _DEBUG    
    static PerformanceTimer *stopOnThisOne = NULL;

    if (stopOnThisOne == this) {
        int breakHere = 0;
    }
#endif
    
}



/*****************************************************************************
The stop function takes an HRESULT (default value 0), which it returns after
the timer has stopped.  This is useful for timing statements.
*****************************************************************************/

HRESULT
PerformanceTimer::Stop (HRESULT result)
{
    CritSectGrabber grab(_criticalSection);

    // Only honor request if we are on the thread we were started on.
    if (_isStarted && (GetCurrentThreadId() == _threadStartedOn)) {
        _totalTicks += (GetPerfTickCount() - _localStart);
        _isStarted = false;
    }

    return result;
}

void
PerformanceTimer::Reset()
{
    CritSectGrabber grab(_criticalSection);

    _totalTicks = 0;
}

double
PerformanceTimer::GetTime()
{
    CritSectGrabber grab(_criticalSection);

    if (_isStarted) {
        // Make sure this is being called from a thread other than
        // what it is started on, else this is a logic error.
        #if _DEBUG
        if(GetCurrentThreadId() != _threadStartedOn) {
            TraceTag((tagWarning, "Getting time on the same thread that a started timer is on"));
        }
        #endif
        
        return 0.0;
    }

    return (double)(_totalTicks) / (double)(perfFrequency);
}

DWORD
PerformanceTimer::Ticks()
{
    CritSectGrabber grab(_criticalSection);

    if (_isStarted) {
        // Make sure this is being called from a thread other than
        // what it is started on, else this is a logic error.
        #if _DEBUG
        if(GetCurrentThreadId() != _threadStartedOn) {
            TraceTag((tagWarning, "Getting ticks on the same thread that a started timer is on"));
        }
        //Assert(GetCurrentThreadId() != _threadStartedOn && "Getting ticks on the same thread that a started timer is on");
        #endif
        

        return 0;
    }

    return _totalTicks;
}
#endif

#if PERFORMANCE_REPORTING

void
vPerfPrintf(char *format, va_list args)
{
    Assert (format);

    char buf[4096];

#if 0
    wvsprintf(buf,format,args);
#else
    vsprintf(buf,format,args);
#endif

    OutputDebugString(buf);
    //DebugCode(printf(buf););
}



void
PerfPrintf(char *format, ...)
{
    va_list args;

    va_start(args, format) ;

    vPerfPrintf(format,args);
}

void
PerfPrintLine(char *format, ...)
{
    va_list args;
    va_start(args, format) ;
    if (format) {
        vPerfPrintf(format,args);
    }

    vPerfPrintf("\n",args);

    va_end(args);

    //DebugCode(fflush(stdout););
}

#endif

DWORD perfFrequency = 0;

static DWORD srvutilTlsIndex = 0xFFFFFFFF;

LPVOID
GetSrvUtilData()
{
    return TlsGetValue(srvutilTlsIndex);
}

void
SetSrvUtilData(LPVOID lpv)
{
    BOOL ok = TlsSetValue(srvutilTlsIndex, lpv);
    Assert(ok && "Error in TlsSetValue");
}

void Win32Translator (unsigned int u, EXCEPTION_POINTERS * pExp)
{
    // WARNING: Do not do too much here since we may not have much stack

    switch (pExp->ExceptionRecord->ExceptionCode) {
      case EXCEPTION_FLT_DIVIDE_BY_ZERO:
      case EXCEPTION_INT_DIVIDE_BY_ZERO:
        RaiseException_DivideByZero () ;
        break ;
      case EXCEPTION_STACK_OVERFLOW:
        RaiseException_StackFault ();
        break ;
    }
}

void CatchWin32Faults (BOOL b)
{
    if (b) {
        _se_translator_function prev = _set_se_translator (Win32Translator) ;

        if (prev != Win32Translator) {
            SetSrvUtilData (prev) ;
        }
    } else {
        _se_translator_function cur = _set_se_translator (Win32Translator) ;

        if (cur == Win32Translator) {
            _set_se_translator ((_se_translator_function) GetSrvUtilData ()) ;
        }
    }
}

void
InitializeModule_Util()
{
    LARGE_INTEGER lpc;
    QueryPerformanceFrequency(&lpc);
    perfFrequency = lpc.LowPart;

    srvutilTlsIndex = TlsAlloc();
    Assert((srvutilTlsIndex != 0xFFFFFFFF) &&
           "TlsAlloc() failed");
}

void
DeinitializeModule_Util(bool bShutdown)
{
    if (srvutilTlsIndex != 0xFFFFFFFF)
        TlsFree(srvutilTlsIndex);
}


bool 
isNear(double value, double test, double epsilon)
{
    return((fabs(value - test)) < epsilon);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\geom\fullattr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Master, coalesced attributer class for Geometry

*******************************************************************************/

#include "headers.h"

#include "fullattr.h"

#include "privinc/dispdevi.h"
#include "privinc/geomi.h"
#include "privinc/xformi.h"

#include "privinc/colori.h"
#include "privinc/ddrender.h"
#include "privinc/lighti.h"
#include "privinc/soundi.h"
#include "privinc/probe.h"
#include "privinc/opt.h"


    // Function Declarations

Geometry *applyTexture (Image *texture, Geometry*, bool oldStyle);



FullAttrStateGeom::FullAttrStateGeom()
{
    _validAttrs = 0;
    _mostRecent = 0;
}


#if _USE_PRINT
ostream&
FullAttrStateGeom::Print(ostream& os)
{
    return os << "FullAttrGeom(" << _geometry << ")";
}
#endif

#define COPY_IF_SET(flag, member) \
  if (src->IsAttrSet(flag)) member = src->member;

void
FullAttrStateGeom::CopyStateFrom(FullAttrStateGeom *src)
{
    COPY_IF_SET(FA_DIFFUSE, _diffuseColor);
    COPY_IF_SET(FA_BLEND,   _blend);
    COPY_IF_SET(FA_XFORM,   _xform);
    COPY_IF_SET(FA_TEXTURE, _textureBundle);
    COPY_IF_SET(FA_OPACITY, _opacity);

    DWORD otherMatProps =
        FA_AMBIENT | FA_EMISSIVE | FA_SPECULAR | FA_SPECULAR_EXP;

    // Trivially reject entire batches
    if (src->IsAttrSet(otherMatProps)) {
        COPY_IF_SET(FA_AMBIENT, _ambientColor);
        COPY_IF_SET(FA_EMISSIVE, _emissiveColor);
        COPY_IF_SET(FA_SPECULAR, _specularColor);
        COPY_IF_SET(FA_SPECULAR_EXP, _specularExpPower);
    }

    DWORD rareProps =
        FA_LIGHTCOLOR | FA_LIGHTRANGE | FA_LIGHTATTEN | FA_UNDETECTABLE;

    // Trivially reject entire batches
    if (src->IsAttrSet(rareProps)) {
        COPY_IF_SET(FA_LIGHTCOLOR, _lightColor);
        COPY_IF_SET(FA_LIGHTRANGE, _lightRange);
        COPY_IF_SET(FA_UNDETECTABLE, _undetectable);

        if (src->IsAttrSet(FA_LIGHTATTEN)) {
            _atten0 = src->_atten0;
            _atten1 = src->_atten1;
            _atten2 = src->_atten2;
        }
    }

    _flags = src->GetFlags();
    _geometry = src->_geometry;
    _mostRecent = src->_mostRecent;
    _validAttrs = src->_validAttrs;
}

void
FullAttrStateGeom::SetGeometry(Geometry *geo)
{
    _geometry = geo;
    _flags = geo->GetFlags();
}

void
FullAttrStateGeom::Render(GenericDevice& genDev)
{
    GeomRenderer& dev = SAFE_CAST(GeomRenderer&, genDev);

    if (!dev.IsShadowing()) {
        if (IsAttrSet(FA_OPACITY) && (_opacity < (1./255.))) {
            // Just skip rendering entirely, object is effectively
            // completely transparent.
            return;
        }
    }

    // Push all necessary state
    if (IsAttrSet(FA_AMBIENT)) { dev.PushAmbient(_ambientColor); }
    if (IsAttrSet(FA_EMISSIVE)) { dev.PushEmissive(_emissiveColor); }
    if (IsAttrSet(FA_SPECULAR)) { dev.PushSpecular(_specularColor); }
    if (IsAttrSet(FA_SPECULAR_EXP)) { dev.PushSpecularExp(_specularExpPower); }
    if (IsAttrSet(FA_BLEND)) { dev.PushTexDiffBlend(_blend); }

    Transform3 *xformSave;
    if (IsAttrSet(FA_XFORM)) {
        xformSave = dev.GetTransform();
        dev.SetTransform(TimesXformXform(xformSave, _xform));
    }

    // GeomRenderer.GetOpacity may return -1 if no opacity is currently active.

    Real opacitySave;

    if (IsAttrSet(FA_OPACITY)) {
        opacitySave = dev.GetOpacity();

        if (opacitySave < 0)
            dev.SetOpacity (_opacity);
        else
            dev.SetOpacity (opacitySave * _opacity);
    }

    bool doBoth = IsAttrSet(FA_BLEND) && _blend;

    bool pushedDiffuse = false;
    bool pushedTexture = false;

    if (_mostRecent == FA_DIFFUSE ||
        (doBoth && (IsAttrSet(FA_DIFFUSE)))) {

        Assert(IsAttrSet(FA_DIFFUSE));
        dev.PushDiffuse(_diffuseColor);
        pushedDiffuse = true;
    }

    if (_mostRecent == FA_TEXTURE ||
        (doBoth && (IsAttrSet(FA_TEXTURE)))) {

        Assert(IsAttrSet(FA_TEXTURE));

        void *texToUse = _textureBundle._nativeRMTexture ?
                             _textureBundle._rmTexture._voidTex :
                             _textureBundle._daTexture._d3dRMTexture;

        dev.PushTexture(texToUse);
        pushedTexture = true;
    }

    // Render
    _geometry->Render(dev);

    // Pop all pushed state

    if (pushedDiffuse) { dev.PopDiffuse(); }
    if (pushedTexture) { dev.PopTexture(); }

    if (IsAttrSet(FA_OPACITY)) { dev.SetOpacity(opacitySave); }
    if (IsAttrSet(FA_XFORM)) { dev.SetTransform(xformSave); }
    if (IsAttrSet(FA_BLEND)) { dev.PopTexDiffBlend(); }
    if (IsAttrSet(FA_SPECULAR_EXP)) { dev.PopSpecularExp(); }
    if (IsAttrSet(FA_SPECULAR)) { dev.PopSpecular(); }
    if (IsAttrSet(FA_EMISSIVE)) { dev.PopEmissive(); }
    if (IsAttrSet(FA_AMBIENT)) { dev.PopAmbient(); }
}


void
FullAttrStateGeom::CollectSounds(SoundTraversalContext &ctx)
{
    Transform3 *xformSave;
    bool isSet = IsAttrSet(FA_XFORM);

    if (isSet) {
        xformSave = ctx.getTransform();
        ctx.setTransform (TimesXformXform(xformSave, _xform));
    }

    _geometry->CollectSounds(ctx);

    if (isSet) {
        ctx.setTransform(xformSave);
    }
}

void
FullAttrStateGeom::CollectLights(LightContext &ctx)
{
    Transform3 *xformSave;
    bool isXfSet = IsAttrSet(FA_XFORM);
    bool isAttenSet = IsAttrSet(FA_LIGHTATTEN);
    bool isColSet = IsAttrSet(FA_LIGHTCOLOR);
    bool isRangeSet = IsAttrSet(FA_LIGHTRANGE);

    if (isXfSet) {
        xformSave = ctx.GetTransform();
        ctx.SetTransform(TimesXformXform(xformSave, _xform));
    }

    if (isAttenSet) { ctx.PushAttenuation(_atten0, _atten1, _atten2); }
    if (isColSet) { ctx.PushColor(_lightColor); }
    if (isRangeSet) { ctx.PushRange(_lightRange); }

    _geometry->CollectLights(ctx);

    if (isRangeSet) { ctx.PopRange(); }
    if (isColSet) { ctx.PopColor(); }
    if (isAttenSet) { ctx.PopAttenuation(); }
    if (isXfSet) { ctx.SetTransform(xformSave); }
}


void
FullAttrStateGeom::CollectTextures(GeomRenderer &device)
{

    // Only need to do anything if we're texturing with a non-native
    // RM texture.

    // If we are not texturing, then we need to process what's below
    // us.

    if (IsAttrSet(FA_TEXTURE) && !_textureBundle._nativeRMTexture) {
        DATextureBundle &dat = _textureBundle._daTexture;
        dat._d3dRMTexture =
            device.DeriveTextureHandle (dat._texture, false, dat._oldStyle);
    } else {
        _geometry->CollectTextures(device);
    }
}

void
FullAttrStateGeom::RayIntersect(RayIntersectCtx &context)
{
    if (IsAttrSet(FA_UNDETECTABLE) && _undetectable) {
        return;
    }

    bool isDATexture =
        IsAttrSet(FA_TEXTURE) && (!_textureBundle._nativeRMTexture);

    bool isXfSet = IsAttrSet(FA_XFORM);

    if (isDATexture) {
        context.SetTexmap(_textureBundle._daTexture._texture,
            _textureBundle._daTexture._oldStyle);
    }

    Transform3 *xformSave;
    if (isXfSet) {
        xformSave = context.GetLcToWc();
        context.SetLcToWc(TimesXformXform(xformSave, _xform));
    }

    _geometry->RayIntersect(context);

    if (isXfSet) { context.SetLcToWc(xformSave); }
    if (isDATexture) { context.EndTexmap(); }
}


Bbox3 *
FullAttrStateGeom::BoundingVol()
{
    Bbox3 *underlying = _geometry->BoundingVol();
    Bbox3 *result;

    if (IsAttrSet(FA_XFORM)) {
        result = TransformBbox3(_xform, underlying);
    } else {
        result = underlying;
    }

    return result;
}

// Forward decl.
Geometry *applyTextureImage(Image *texture, Geometry *geo);

AxAValue
FullAttrStateGeom::_Cache(CacheParam &p)
{
    // Cache the native DA image.
    if (IsAttrSet(FA_TEXTURE) && !_textureBundle._nativeRMTexture) {

        AxAValue result;

        // Always pre-calc the RM texture for the cache.
        CacheParam txtrParam = p;
        txtrParam._isTexture = true;

        Image *image = _textureBundle._daTexture._texture;

        Image *newImage =
            SAFE_CAST(Image *, AxAValueObj::Cache(image, txtrParam));

        if (newImage == image) {

            // Cache is identical to the original image.  It's
            // possible that the system attempted to cache it as a
            // bitmap and failed.  However, in this context, we know
            // we're going to be used as a texture, so bypass the
            // "Cache" method (which looks up its results) and go
            // straight to the raw _Cache method to compute again
            // (this time it will try as a texture)

            if (!(image->GetFlags() & IMGFLAG_CONTAINS_GRADIENT)) {
                
                // HACK!! Disallow caching of gradients for use as
                // textures.  Currently messed up (bug 28131).
                
                newImage =
                    SAFE_CAST(Image *, image->_Cache(txtrParam));

                // We stash it away even though it may be invalid for
                // certain other uses.  For instance, when an image
                // is used as a texture and as a regular image, we
                // probably don't want to hit the texture cache for
                // the regular image usage.  We'll live with that
                // restriction for now.
                image->SetCachedImage(newImage);

            }
        }
        
        if (newImage != image) {

            // Just texture "this" with the new image.  Since textures
            // override, this will result in creating a new
            // FullAttrStateGeom and replacing the existing texture
            // ("image") with this one, and we'll lose our reference
            // to "image".

            return applyTexture
                (newImage, this, _textureBundle._daTexture._oldStyle);

        }

        // Note we don't proceed down the geometry.  That's on the
        // assumption that it's not yet interesting to actually cache
        // geometry other than the texture, and that any texture below
        // would be ignored, since we're applying an outer texture
        // here.

    }

    return this;
}


void
FullAttrStateGeom::DoKids(GCFuncObj proc)
{
    (*proc)(_geometry);
    if (IsAttrSet(FA_AMBIENT)) (*proc)(_ambientColor);
    if (IsAttrSet(FA_DIFFUSE)) (*proc)(_diffuseColor);
    if (IsAttrSet(FA_EMISSIVE)) (*proc)(_emissiveColor);
    if (IsAttrSet(FA_SPECULAR)) (*proc)(_specularColor);
    if (IsAttrSet(FA_XFORM)) (*proc)(_xform);
    if (IsAttrSet(FA_LIGHTCOLOR)) (*proc)(_lightColor);

    if (IsAttrSet(FA_TEXTURE)) {
        if (!_textureBundle._nativeRMTexture) {
            (*proc)(_textureBundle._daTexture._texture);
        } else {
            (*proc)(_textureBundle._rmTexture._gcUnk);
        }
    }
}



////////////////////   C O N S T R U C T O R S   /////////////////////////


FullAttrStateGeom *
CombineState(Geometry *geo)
{
    FullAttrStateGeom *f = NEW FullAttrStateGeom;

    if (geo->GetValTypeId() == FULLATTRGEOM_VTYPEID) {

        // If the geometry we're attributing is a FullAttrStateGeom
        // itself, then we just copy over its state, and lose our
        // reference to the original one.
        FullAttrStateGeom *old =
            SAFE_CAST(FullAttrStateGeom *, geo);
        f->CopyStateFrom(old);

    } else {

        // Otherwise, we just have the new one's geometry point to the
        // old geometry, and thus keep a reference to the old
        // geometry.
        f->SetGeometry(geo);
    }

    return f;
}

Geometry *
UndetectableGeometry(Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    f->SetAttr(FA_UNDETECTABLE);
    f->_undetectable = true;
    return f;
}

Geometry *applyDiffuseColor(Color *color, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    f->SetAttr(FA_DIFFUSE);
    f->SetMostRecent(FA_DIFFUSE); // for blend
    f->_diffuseColor = color;
    return f;
}


Geometry *applyEmissiveColor(Color *color, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    f->SetAttr(FA_EMISSIVE);
    f->_emissiveColor = color;
    return f;
}

Geometry *applyAmbientColor(Color *color, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    f->SetAttr(FA_AMBIENT);
    f->_ambientColor = color;
    return f;
}

Geometry *applySpecularColor(Color *color, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    f->SetAttr(FA_SPECULAR);
    f->_specularColor = color;
    return f;
}

Geometry *applySpecularExponent(AxANumber *power, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    f->SetAttr(FA_SPECULAR_EXP);
    f->_specularExpPower = NumberToReal(power);
    return f;
}

Geometry *BlendTextureDiffuse (Geometry *geo, AxABoolean *blended)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    f->SetAttr(FA_BLEND);
    f->_blend = blended->GetBool();
    return f;
}

Geometry *applyTexture (Image *texture, Geometry *geo, bool oldStyle)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);

    // Don't worry about releasing a current texture if one is
    // there... nothing is being held onto.

    f->SetAttr(FA_TEXTURE);
    f->SetMostRecent(FA_TEXTURE); // for blend
    f->_textureBundle._nativeRMTexture = false;
    f->_textureBundle._daTexture._texture = texture;
    f->_textureBundle._daTexture._d3dRMTexture = NULL;
    f->_textureBundle._daTexture._oldStyle = oldStyle;

    return f;
}

Geometry *applyTextureMap(Image *texture, Geometry *geo)
{
    return applyTexture (texture, geo, true);
}

Geometry *applyTextureImage(Image *texture, Geometry *geo)
{
    return applyTexture(texture, geo, false);
}

Geometry *applyTransform(Transform3 *xform, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    Transform3 *newXf;
    if (f->IsAttrSet(FA_XFORM)) {
        newXf = TimesXformXform(xform, f->_xform);
    } else {
        newXf = xform;
    }

    f->SetAttr(FA_XFORM);
    f->_xform = newXf;

    return f;
}

Geometry *applyOpacityLevel(AxANumber *opac, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    Real o = NumberToReal(opac);
    Real newOpac;
    if (f->IsAttrSet(FA_OPACITY)) {
        // Multiply the opacity in to combine
        newOpac = f->_opacity * o;
    } else {
        newOpac = o;
    }

    f->SetAttr(FA_OPACITY);
    f->_opacity = o;

    return f;
}

Geometry *applyLightColor(Color *color, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    f->SetAttr(FA_LIGHTCOLOR);
    f->_lightColor = color;
    return f;
}

Geometry *applyLightRange(Real range, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);
    f->SetAttr(FA_LIGHTRANGE);
    f->_lightRange = range;
    return f;
}

Geometry *applyLightRange(AxANumber *range, Geometry *geometry)
{
    return applyLightRange(NumberToReal(range), geometry);
}

Geometry *applyLightAttenuation(Real A0, Real A1, Real A2, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    // If all attenuation parameters are zero, then do not attenuate.
    if ((A0==0) && (A1==0) && (A2==0))
        A0 = 1;

    FullAttrStateGeom *f = CombineState(geo);
    f->SetAttr(FA_LIGHTATTEN);
    f->_atten0 = A0;
    f->_atten1 = A1;
    f->_atten2 = A2;
    return f;
}

Geometry *applyLightAttenuation(AxANumber *A0,
                                AxANumber *A1,
                                AxANumber *A2,
                                Geometry *geo)
{
    return applyLightAttenuation(NumberToReal(A0),
                                 NumberToReal(A1),
                                 NumberToReal(A2),
                                 geo);
}

/////////////   D E B U G G I N G   F A C I L I T I E S   /////////////////

#if _DEBUG

void
PrintAttrStateColor(char *descrip, Color *col)
{
    char buf[256];
    sprintf(buf, "%s: %8.5f %8.5f %8.5f\n",
            descrip, col->red, col->green, col->blue);
    OutputDebugString(buf);
}

void
PrintAttrStateNum(char *descrip, Real num)
{
    char buf[256];
    sprintf(buf, "%s: %8.5f\n", descrip, num);
    OutputDebugString(buf);
}

void
PrintAttrState(FullAttrStateGeom *g)
{
    char buf[256];
    sprintf(buf, "Size of FullAttrStateGeom is %d bytes\n",
            sizeof(FullAttrStateGeom));
    OutputDebugString(buf);

    if (g->IsAttrSet(FA_AMBIENT))
        PrintAttrStateColor("Ambient", g->_ambientColor);

    if (g->IsAttrSet(FA_DIFFUSE))
        PrintAttrStateColor("Diffuse", g->_diffuseColor);

    if (g->IsAttrSet(FA_EMISSIVE))
        PrintAttrStateColor("Emissive", g->_emissiveColor);

    if (g->IsAttrSet(FA_SPECULAR))
        PrintAttrStateColor("Specular", g->_specularColor);

    if (g->IsAttrSet(FA_SPECULAR_EXP))
        PrintAttrStateNum("Specular Exp", g->_specularExpPower);

    if (g->IsAttrSet(FA_OPACITY))
        PrintAttrStateNum("Opacity", g->_opacity);

    if (g->IsAttrSet(FA_BLEND))
        PrintAttrStateNum("Blend", g->_blend ? 1 : 0);

    if (g->IsAttrSet(FA_XFORM))
        PrintAttrStateNum("Xform Present", 1);

    if (g->IsAttrSet(FA_TEXTURE))
        PrintAttrStateNum("Texture Present", 1);

    if (g->IsAttrSet(FA_LIGHTCOLOR))
        PrintAttrStateColor("Light Color", g->_lightColor);

    if (g->IsAttrSet(FA_LIGHTATTEN)) {
        PrintAttrStateNum("Atten0", g->_atten0);
        PrintAttrStateNum("Atten1", g->_atten1);
        PrintAttrStateNum("Atten2", g->_atten2);
    }

    if (g->IsAttrSet(FA_LIGHTRANGE))
        PrintAttrStateNum("Light Range", g->_lightRange);

    if (g->IsAttrSet(FA_UNDETECTABLE))
        PrintAttrStateNum("Undetectable", g->_undetectable);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\geom\billboard.cpp ===
/*******************************************************************************
Copyright (c) 1998 Microsoft Corporation.  All rights reserved.

    Billboard geometries face the camera on rendering or picking, aligned with
    either the camera up vector or with an optionally-supplied axis of
    rotation.

*******************************************************************************/

#include "headers.h"
#include "appelles/geom.h"
#include "privinc/geomi.h"
#include "privinc/xformi.h"
#include "privinc/camerai.h"
#include "privinc/lighti.h"
#include "privinc/ddrender.h"



class BillboardGeo : public Geometry
{
  public:

    BillboardGeo (Geometry *geo, Vector3Value *axis);

    void Render (GenericDevice &gendev);

    void CollectLights   (LightContext &context);
    void CollectSounds   (SoundTraversalContext &context);
    void CollectTextures (GeomRenderer &device);

    void RayIntersect (RayIntersectCtx &context);

    Bbox3* BoundingVol (void);

    void DoKids (GCFuncObj proc);

    #if _USE_PRINT
        virtual ostream& Print (ostream& os);
    #endif

  private:

    Transform3* BBTransform (Camera*, Transform3*);

    // These members define the billboard.

    Geometry       *_geometry;        // Geometry to Billboard
    Vector3Value    _axis;            // Rotation Axis
    bool            _constrained;     // Constrained to Rotation Axis?
};



/*****************************************************************************
The constructor for the billboard geometry transform
*****************************************************************************/

BillboardGeo::BillboardGeo (Geometry *geo, Vector3Value *axis)
    : _geometry (geo),
      _axis     (*axis)
{
    Real axisLenSq = _axis.LengthSquared();

    if (axisLenSq == 0)
    {
        _constrained = false;
    }
    else
    {
        // If a billboard axis is supplied, normalize it.

        _constrained = true;
        _axis /= sqrt(axisLenSq);
    }
}



/*****************************************************************************
Mark value object members currently in use.
*****************************************************************************/

void BillboardGeo::DoKids (GCFuncObj proc)
{
    (*proc)(_geometry);
}



/*****************************************************************************
This method prints out the text description of the billboard geometry.
*****************************************************************************/

#if _USE_PRINT
ostream& BillboardGeo::Print (ostream &os)
{
    return os << "BillboardGeo("
              << _geometry
              << ",{"
              << _axis.x << ","
              << _axis.y << ","
              << _axis.z
              << "})";
}
#endif



/*****************************************************************************
Visually render the billboard geometry.
*****************************************************************************/

void BillboardGeo::Render (GenericDevice &gendev)
{
    GeomRenderer &renderer = SAFE_CAST (GeomRenderer&, gendev);

    Transform3 *xform = renderer.GetTransform();
    Transform3 *bbxform = BBTransform (renderer.CurrentCamera(), xform);

    // Replace the modeling transform with the billboard transform, render,
    // and then restor the modeling transform.

    renderer.SetTransform (bbxform);
    _geometry->Render (renderer);
    renderer.SetTransform (xform);
}



/*****************************************************************************
Collect the lights contained in the billboard geometry.
*****************************************************************************/

void BillboardGeo::CollectLights (LightContext &context)
{
    GeomRenderer *renderer = context.Renderer();
    Transform3   *xform = context.GetTransform();

    // Update the billboard transform.  If the light context doesn't know about
    // a geometry renderer (and hence doesn't know about the camera), pass NULL
    // in for the camera.

    Transform3 *bbxform;

    if (renderer)
        bbxform = BBTransform (renderer->CurrentCamera(), xform);
    else
        bbxform = BBTransform (NULL, xform);

    // Set the new billboard transform, continue light collection, and restore
    // the initial transform.

    context.SetTransform (bbxform);
    _geometry->CollectLights (context);
    context.SetTransform (xform);
}



/*****************************************************************************
This method collects the sounds in the billboarded geometry.  Since we don't
know the camera at the CollectSounds traversal, this essentially no-ops the
billboard transform.
*****************************************************************************/

void BillboardGeo::CollectSounds (SoundTraversalContext &context)
{
    _geometry->CollectSounds (context);
}



/*****************************************************************************
Collect all 3D texture maps from the contained geometry.
*****************************************************************************/

void BillboardGeo::CollectTextures (GeomRenderer &device)
{
    // Billboarding does not affect what texture maps we contain; just descend.

    _geometry->CollectTextures (device);
}



/*****************************************************************************
Perform ray-intersection test on the billboarded geometry.  We can fetch both
the camera and the model transform from the context parameter.
*****************************************************************************/

void BillboardGeo::RayIntersect (RayIntersectCtx &context)
{
    Transform3 *xform = context.GetLcToWc();
    Transform3 *bbxform = BBTransform (context.GetCamera(), xform);

    context.SetLcToWc (bbxform);         // Set Billboard Transform
    _geometry->RayIntersect (context);
    context.SetLcToWc (xform);           // Restore Model Transform
}



/*****************************************************************************
This method function returns the bounding box of the billboard geometry.
Since we don't know the camera at this time, we calculate the worst-case
bounding box, which is encloses the spherical space swept out by all possible
orientations of the billboard geometry.
*****************************************************************************/

Bbox3* BillboardGeo::BoundingVol (void)
{
    // The sphere that encloses all possible orientations of the billboard
    // geometry is centered at the model coordinate origin (since that's what
    // the billboard pivots around), and is swept out by the farthest corner
    // of the bounding box.  Iterate through the three dimensions, picking the
    // farthest point for each one, and construct the vector to that farthest
    // corner.

    Bbox3 *bbox = _geometry->BoundingVol();

    Vector3Value v;   // Vector to Farthest BBox Corner
    Real A, B;   // Work Variables

    A = fabs (bbox->min.x);
    B = fabs (bbox->max.x);
    v.x = MAX (A,B);

    A = fabs (bbox->min.y);
    B = fabs (bbox->max.y);
    v.y = MAX (A,B);

    A = fabs (bbox->min.z);
    B = fabs (bbox->max.z);
    v.z = MAX (A,B);

    Real radius = v.Length();

    return NEW Bbox3 (-radius, -radius, -radius, radius, radius, radius);
}



/*****************************************************************************
This method updates the billboard transform based on the current modeling
transform and the current position/orientation of the camera.
*****************************************************************************/

Transform3* BillboardGeo::BBTransform (Camera *camera, Transform3 *modelXform)
{
    Assert (modelXform);

    if (!camera)
    {
        // If we don't have a camera available, then we can't compute the true
        // billboard transform.  In this case, make the billboard transform the
        // same as the modeling transform.

        return modelXform;
    }

    // Extract the transform basic components from the camera.

    const Apu4x4Matrix &xfmatrix = modelXform->Matrix();

    Point3Value  origin = xfmatrix.Origin();
    Vector3Value Bx     = xfmatrix.BasisX();
    Vector3Value By     = xfmatrix.BasisY();
    Vector3Value Bz     = xfmatrix.BasisZ();

    // Save the basis vector lengths to preserve them.

    Real Sx = Bx.Length();
    Real Sy = By.Length();
    Real Sz = Bz.Length();

    // Set the billboard basis Z to point toward the camera with unit
    // length.

    Bz = camera->WCProjPoint() - origin;

    // If the camera is located at the model xform origin, then we don't have
    // a viewing axis, so just return the unmodified model xform.

    if (Bz.LengthSquared() == 0.)
        return modelXform;

    Bz.Normalize();

    if (_constrained)
    {
        // If the billboard is constrained to a rotation axis, we need to
        // map the basis Y vector to this axis and adjust the direction
        // vector (Bz) to be perpendicular to it.  Note that _axis is
        // already normalized.

        Bx = Cross (_axis, Bz);

        // If the viewing axis and billboard axis are parallel, then there's
        // no particular billboard rotation that is better than any other;
        // just return the model xform in this case.

        if (Bx.LengthSquared() == 0.)
            return modelXform;

        Bx.Normalize();

        By = _axis;

        Bz = Cross (Bx, By);
    }
    else
    {
        // If the billboard is unconstrained by a rotation axis, rotate
        // around the direction vector to match the billboard up vector
        // with the camera's up vector.

        Vector3Value Cy = camera->Basis()->Matrix().BasisY();

        Bx = Cross (Cy, Bz);

        // If the model up vector is parallel to the viewing axis, then just
        // return the model xform.

        if (Bx.LengthSquared() == 0.)
            return modelXform;

        Bx.Normalize();

        By = Cross (Bz, Bx);
    }

    // Restore original model transform scale factors.

    Bx *= Sx;
    By *= Sy;
    Bz *= Sz;

    return TransformBasis (&origin, &Bx, &By, &Bz);
}



/*****************************************************************************
This is the procedural entry point for creating a billboarded geometry.  The
axis specifies the axis of rotation as the geometry aims toward the camera.
If the axis is the zero vector, then the geometry swivels freely and aligns
with the camera's up vector.
*****************************************************************************/

Geometry* Billboard (Geometry *geo, Vector3Value *axis)
{
    return NEW BillboardGeo (geo, axis);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\geom\fullattr.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Master, coalesced attributer class for Geometry

*******************************************************************************/


#ifndef _FULLATTR_H
#define _FULLATTR_H

const int FA_AMBIENT            (1L << 0);
const int FA_DIFFUSE            (1L << 1);
const int FA_SPECULAR           (1L << 2);
const int FA_SPECULAR_EXP       (1L << 3);
const int FA_EMISSIVE           (1L << 4);
const int FA_OPACITY            (1L << 5);
const int FA_BLEND              (1L << 6);
const int FA_XFORM              (1L << 7);
const int FA_TEXTURE            (1L << 8);
const int FA_LIGHTATTEN         (1L << 9);
const int FA_LIGHTCOLOR         (1L << 10);
const int FA_LIGHTRANGE         (1L << 11);
const int FA_UNDETECTABLE       (1L << 12);


class DATextureBundle {
  public:
    Image      *_texture;
    void       *_d3dRMTexture;
    bool        _oldStyle;      // True for 4.01 Texturing
};

class RMTextureBundle {
  public:
    bool   _isRMTexture3;
    union {
        IDirect3DRMTexture  *_texture1;
        IDirect3DRMTexture3 *_texture3;
    };
    void       *_voidTex;
    GCIUnknown *_gcUnk;
};

class TextureBundle {
  public:
    bool _nativeRMTexture;
    union {
        DATextureBundle _daTexture;
        RMTextureBundle _rmTexture;
    };
};

class FullAttrStateGeom : public Geometry {
  public:
    FullAttrStateGeom();

    inline bool IsAttrSet(DWORD attr) {
        return (_validAttrs & attr) ? true : false;
    }

    inline void SetAttr(DWORD attr) { _validAttrs |= attr; } 
    inline void SetMostRecent(DWORD mostRecent) { _mostRecent = mostRecent; }
    inline void AppendFlag(DWORD dw) { _flags |= dw; }
    
    void CopyStateFrom(FullAttrStateGeom *src);
    void SetGeometry(Geometry *g);

    /////  Geometry-class methods
    
    void Render(GenericDevice& device);

    void CollectSounds(SoundTraversalContext &context);

    void CollectLights(LightContext &context);

    void  CollectTextures(GeomRenderer &device);

    void RayIntersect(RayIntersectCtx &context);

    Bbox3 *BoundingVol();

    AxAValue _Cache(CacheParam &p);

    void DoKids(GCFuncObj proc);

    #if _USE_PRINT
        ostream& Print(ostream& os);
    #endif

    VALTYPEID GetValTypeId() { return FULLATTRGEOM_VTYPEID; }


    /////****  Attributes are publically available  ****/////

    ///// Underlying geometry
    Geometry      *_geometry;
    
    ///// Material properties
    Color         *_ambientColor;
    Color         *_diffuseColor;
    Color         *_emissiveColor;
    Color         *_specularColor;
    
    Real           _specularExpPower;
    Real           _opacity;     
    bool           _blend;

    ///// Spatial transform
    Transform3    *_xform;

    ///// Texture properties
    TextureBundle  _textureBundle;

    ///// Light properties
    Real           _atten0, _atten1, _atten2;
    Color         *_lightColor;
    Real           _lightRange;

    ///// Misc
    bool           _undetectable;

  protected:
    DWORD          _validAttrs;
    DWORD          _mostRecent;
};


FullAttrStateGeom *CombineState(Geometry *geo);

#endif /* _FULLATTR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\utils\_netio.h ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Private header for netio

--*/

#ifndef __NETIOPRIV_H
#define __NETIOPRIV_H

#define AVR_PREFIX "AVR"

extern HINSTANCE hInst;

class CNetIO;

HRESULT     CreateNetIO(HAVRCONTEXT hcontext, CNetIO ** ppNetIO);
HRESULT     AddNetIOToList(CNetIO * pNetIO);
CNetIO *    FindNetIO(HAVRCONTEXT hcontext);


class CNetIO
{
  public:
    CNetIO(HAVRCONTEXT hcontext);
    ~CNetIO(void);

    HAVRCONTEXT     GetContext(void) { return m_hcontext; }
    LPOLESTR        GetRootPath(void) { return m_szRootPath; }
    char *          GetLocalPath(void) { return m_szLocalPath; }
    char *          GetLocalHyperlinkPath(void) { return m_szLocalHyperlinkPath; }
    HRESULT         GetRootMoniker(IMoniker ** ppmk);
    HRESULT         SetRootPath(LPOLESTR szRoot);
    void            ReleasePathStrings(void);
    void            CreateTempFileName(LPSTR pszName, LPSTR pszTempName);
    BOOL            CopyFileToTemp(LPSTR szInName, LPSTR szOutName);
    BOOL            MakeMonikerAndContext(
                            LPSTR szName,
                            IMoniker ** ppmk,
                            IBindCtx ** ppbc);

  private:
    HAVRCONTEXT     m_hcontext;
    LPOLESTR        m_szRootPath;
    char *          m_szLocalPath;
    char *          m_szLocalHyperlinkPath;
};


struct SNetIOList
{
    CNetIO *        pNetIO;
    SNetIOList *    pNext;
};


struct TEMPFILEINFO
{
  LPSTR         pszName;
  HANDLE        hFile;
  DWORD         cbSize;
  IMoniker *    pmk;
  IBindCtx *    pbc;
  IBindStatusCallback *pbsc;
  unsigned      fDone : 1;
  unsigned      fError : 1;

  TEMPFILEINFO() { memset(this, 0, sizeof(TEMPFILEINFO)); }
};


class CBscTempFile : public CBindStatusCallback
{
  public:
    // IBindStatusCallback methods overrides
    STDMETHOD(OnStopBinding)(HRESULT hrResult, LPCWSTR szError);
    STDMETHOD(GetBindInfo)(DWORD * pgrfBINDF, BINDINFO * pbindInfo);
    STDMETHOD(OnDataAvailable)(
                DWORD grfBSCF,
                DWORD dwSize,
                FORMATETC *pfmtetc,
                STGMEDIUM* pstgmed);

    // constructors/destructors
    CBscTempFile(TEMPFILEINFO * pFi);
    ~CBscTempFile(void);

    // data members
    DWORD           m_cbOld;
    TEMPFILEINFO *  m_pfi;
};


#endif  // __NETIOPRIV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\geom\gattr.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Implementation of geometry attributers.  Here we express how to process
geometry attributers in graphics contexts.

*******************************************************************************/
#include "headers.h"

#include "privinc/dispdevi.h"
#include "privinc/geomi.h"
#include "privinc/xformi.h"

#include "privinc/colori.h"
#include "privinc/ddrender.h"
#include "privinc/lighti.h"
#include "privinc/soundi.h"
#include "privinc/probe.h"
#include "privinc/opt.h"


/*****************************************************************************
 Implementation of default methods for attributed geometry.
*****************************************************************************/

AttributedGeom::AttributedGeom (Geometry *geometry) :
    _geometry(geometry)
{
    Assert(_geometry && "Constructing AttributedGeom with null geometry.");
    _flags = _geometry->GetFlags();
}

void AttributedGeom::Render (GenericDevice& device)
{
    Render3D (SAFE_CAST(GeomRenderer&,device));
}

void AttributedGeom::Render3D (GeomRenderer& gdev)
{
    _geometry->Render(gdev);    // Just descend by default.
}

void AttributedGeom::CollectSounds (SoundTraversalContext &context)
{
    _geometry->CollectSounds (context);
}

void AttributedGeom::CollectLights (LightContext &context)
{
    _geometry->CollectLights (context);
}

void AttributedGeom::RayIntersect (RayIntersectCtx &context)
{
    _geometry->RayIntersect (context);
}

Bbox3 *AttributedGeom::BoundingVol (void)
{
    return _geometry->BoundingVol();
}

AxAValue
AttributedGeom::_Cache(CacheParam &p)
{
    _geometry =
        SAFE_CAST(Geometry *, AxAValueObj::Cache(_geometry, p));

    return this;
}


/*****************************************************************************
The clipped geometry subjected to a clip against a plane.
*****************************************************************************/

class ClippedGeom : public AttributedGeom
{
  public:

    ClippedGeom (Point3Value *planePt, Vector3Value *planeVec, Geometry *geometry)
        : AttributedGeom(geometry), _plane(*planeVec, *planePt) {}

    void Render3D (GeomRenderer &ddrenderer)
    {
        Bbox3 *boundingVol = _geometry->BoundingVol();
        if (boundingVol->Clip(_plane) != CLIPCODE_OUT) {
            Plane3 *xformedPlane = NEW Plane3(_plane);
            *xformedPlane *= ddrenderer.GetTransform();
            DWORD planeID;
            HRESULT hr = ddrenderer.SetClipPlane(xformedPlane,&planeID);
            _geometry->Render(ddrenderer);
            if (SUCCEEDED(hr)) {
                ddrenderer.ClearClipPlane(planeID);
            }
        }
    }

    #if _USE_PRINT
    virtual ostream& Print (ostream& os) {
        return os << "ClippedGeom(" << _plane << ","
                  << _geometry << ")";
    }
    #endif

  protected:

    Plane3 _plane;
};


Geometry *applyModelClip(Point3Value *planePt, Vector3Value *planeVec,
                         Geometry *geometry)
{
    if (!geometry) {
        return emptyGeometry;
    }

    if (planePt && planeVec) {
        return NEW ClippedGeom(planePt,planeVec,geometry);
    } else {
        return geometry;
    }
}


/*****************************************************************************
Attributor that allows lighting to be set on or off
*****************************************************************************/

class LightingGeom : public AttributedGeom
{
  public:

    LightingGeom (bool lighting, Geometry *geometry)
        : AttributedGeom(geometry), _doLighting(lighting) {}

    void Render3D (GeomRenderer &ddrenderer)
    {
        ddrenderer.PushLighting(_doLighting);
        _geometry->Render(ddrenderer);
        ddrenderer.PopLighting();
    }

    #if _USE_PRINT
        virtual ostream& Print (ostream& os) {
            return os << "LightingGeom(" << _doLighting << ","
                      << _geometry << ")";
        }
    #endif

  protected:

    bool _doLighting;
};


Geometry *applyLighting (AxABoolean *lighting, Geometry *geo)
{
    if (!geo) {
        return emptyGeometry;
    }

    if (lighting) {
        return NEW LightingGeom(lighting->GetBool(),geo);
    } else {
        return geo;
    }
}



/*****************************************************************************
The overriding-opacity attribute controls whether opacity overrides or
multiplies with opacities contained in X files and other imported geometry.
*****************************************************************************/

class OverridingOpacityGeom : public AttributedGeom
{
  public:

    OverridingOpacityGeom (Geometry *geometry, bool override)
        : AttributedGeom(geometry), _override(override) {}

    void Render3D (GeomRenderer &ddrenderer)
    {
        ddrenderer.PushOverridingOpacity (_override);
        _geometry->Render(ddrenderer);
        ddrenderer.PopOverridingOpacity();
    }

    #if _USE_PRINT
        virtual ostream& Print (ostream& os) {
            return os << "OverridingOpacityGeom(" << _override << ","
                      << _geometry << ")";
        }
    #endif

  protected:

    bool _override;
};

Geometry* OverridingOpacity (Geometry *geo, bool override)
{
    if (!geo || (geo == emptyGeometry))
        return emptyGeometry;

    return NEW OverridingOpacityGeom (geo, override);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\geom\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "privinc/server.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\geom\geom.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Basic geometry functionality.

*******************************************************************************/

#include "headers.h"
#include <stdio.h>

#include "appelles/common.h"

#include "privinc/geomi.h"
#include "privinc/dispdevi.h"
#include "privinc/vecutil.h"
#include "privinc/bbox3i.h"
#include "privinc/vec2i.h"
#include "privinc/lighti.h"
#include "privinc/soundi.h"
#include "privinc/probe.h"
#include "privinc/except.h"
#include "privinc/debug.h"
#include "privinc/opt.h"



Geometry *emptyGeometry = NULL;



/*****************************************************************************
*****************************************************************************/

Geometry::Geometry (void)
    : _flags(0),
      _creationID (PERF_CREATION_ID_BUILT_EACH_FRAME)
{
}



/*****************************************************************************
When performing the RayIntersect method on bounded geometry, continue
interogating the contained geometry only if the ray intersects the bounding
volume of the geometry, and the intersection point is closer than the current
winning pick point.
*****************************************************************************/

bool
TrivialReject(Bbox3 *bvol, RayIntersectCtx &ctx)
{
    // If we're looking for a submesh, and already got it, no need to
    // go on, so reject.
    if (ctx.GotTheSubmesh()) {
        return true;
    }

    // If looking for a submesh, ignore the bbox, since the lc points
    // aren't accurate here.
    if (ctx.LookingForSubmesh()) {
        return false;
    }

    Bbox3  *wcBbox = TransformBbox3 (ctx.GetLcToWc(), bvol);
    Point3Value *hit = wcBbox->Intersection (ctx.WCPickRay());

    DebugCode
    (
        if (IsTagEnabled (tagPick3Bbox))
        {
            if (!hit)
                TraceTag ((tagPick3Bbox, "Ray missed bbox %x.", bvol));
            else if (ctx.CloserThanCurrentHit(*hit))
                TraceTag ((tagPick3Bbox, "Ray hit bbox %x (closer).", bvol));
            else
                TraceTag ((tagPick3Bbox, "Ray hit bbox %x (farther).", bvol));
        }
    )

    // Return true if we can trivially reject the intersection based on
    // the bounding volume
    return !(hit && ctx.CloserThanCurrentHit(*hit));
}


/*==========================================================================*/

Bbox3 *GeomBoundingBox (Geometry *geo)
{
    return geo->BoundingVol();
}

/*==========================================================================*/
// Binary Geometry Aggregation

class AggregateGeom : public Geometry
{
  public:

    AggregateGeom (Geometry *g1, Geometry *g2);

    void Render(GenericDevice& _dev) {
        // Just render one followed by the other
        _geo1->Render(_dev);
        _geo2->Render(_dev);
    }

    void CollectSounds (SoundTraversalContext &context) {
        // Just render one followed by the other (pushing down the
        // transform)
        _geo1->CollectSounds(context);
        _geo2->CollectSounds(context);
    }

    void CollectLights (LightContext &context)
    {
        _geo1->CollectLights (context);
        _geo2->CollectLights (context);
    }

    void CollectTextures(GeomRenderer &device) {
        _geo1->CollectTextures (device);
        _geo2->CollectTextures (device);
    }

    void RayIntersect (RayIntersectCtx &context) {
        if (!TrivialReject(_bvol, context)) {
            _geo1->RayIntersect(context);

            if (!context.GotTheSubmesh()) {
                _geo2->RayIntersect(context);
            }
        }
    }

    #if _USE_PRINT
        ostream& Print(ostream& os) {
            return os << "union(" << _geo1 << "," << _geo2 << ")";
        }
    #endif

    Bbox3 *BoundingVol (void)
    {
        return _bvol;
    }
    
    AxAValue _Cache(CacheParam &p) {

        CacheParam newParam = p;
        newParam._pCacheToReuse = NULL;

        // Just go through and cache the individual geoms
        _geo1 =  SAFE_CAST(Geometry *, AxAValueObj::Cache(_geo1, newParam));
        _geo2 =  SAFE_CAST(Geometry *, AxAValueObj::Cache(_geo2, newParam));

        return this;
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_geo1);
        (*proc)(_geo2);
        (*proc)(_bvol);
    }

    VALTYPEID GetValTypeId() { return AGGREGATEGEOM_VTYPEID; }

  protected:
    Geometry *_geo1, *_geo2;
    Bbox3    *_bvol;
};


AggregateGeom::AggregateGeom (Geometry *g1, Geometry *g2)
    : _geo1(g1), _geo2(g2)
{
    _flags = g1->GetFlags() | g2->GetFlags();
    _bvol = Union (*_geo1->BoundingVol(), *_geo2->BoundingVol());
}



Geometry *PlusGeomGeom (Geometry *geom1, Geometry *geom2)
{
    if (geom1 == emptyGeometry) {
        return geom2;
    } else if (geom2 == emptyGeometry) {
        return geom1;
    } else {
        return NEW AggregateGeom (geom1, geom2);
    }
}

/*==========================================================================*/
// Multiple Aggregrate Geometry
class MultiAggregateGeom : public Geometry
{
  public:
    MultiAggregateGeom() {
        _numGeos = 0;
        _geometries = NULL;
        _bvol = NULL;
    }

    void Init(AxAArray *geos);
    ~MultiAggregateGeom();

    virtual void     Render (GenericDevice& dev);
            void     CollectSounds (SoundTraversalContext &context);
            void     CollectLights (LightContext &context);
            void     CollectTextures(GeomRenderer &device);
    void     RayIntersect (RayIntersectCtx &context);

    #if _USE_PRINT
        ostream& Print (ostream& os);
    #endif

    Bbox3 *BoundingVol() {
        return _bvol;
    }

    AxAValue _Cache(CacheParam &p);

    virtual void DoKids(GCFuncObj proc) {
        for (int i=0; i<_numGeos; i++) {
            (*proc)(_geometries[i]);
        }
        (*proc)(_bvol);
    }

    VALTYPEID GetValTypeId() { return MULTIAGGREGATEGEOM_VTYPEID; }

  protected:
    int        _numGeos;
    Geometry **_geometries;
    Bbox3     *_bvol;
};

void
MultiAggregateGeom::Init(AxAArray *geos)
{
    _numGeos = geos->Length();
    Assert((_numGeos > 2) && "Multi-aggregate should have more than 2 geometries");

    _geometries = (Geometry **)AllocateFromStore(_numGeos * sizeof(Geometry*));

    _bvol = NEW Bbox3;

    for (int i = 0; i < _numGeos; i++) {
        Geometry *g = SAFE_CAST(Geometry *, (*geos)[i]);

        _geometries[i] = g;

        _bvol->Augment(*g->BoundingVol());

        // Accumulate geometry flags.  Note that the _flags member has been
        // initialized to zero in the Geometry class constructor.

        _flags |= g->GetFlags();
    }
}

MultiAggregateGeom::~MultiAggregateGeom()
{
    DeallocateFromStore(_geometries);
}

void
MultiAggregateGeom::Render(GenericDevice& _device)
{
    Geometry **geo = _geometries;   // Geometry Traversal Pointer

    for (int i = 0; i < _numGeos; i++, geo++) { // call render on each geometry
        (*geo)->Render(_device);
    }
}

void MultiAggregateGeom::CollectSounds (SoundTraversalContext &context)
{
    Geometry **geo;    // Geometry Traversal Pointer
    int       count;  // Iteration Counter

    for (geo=_geometries, count=_numGeos;  count--;  ++geo)
        (*geo)->CollectSounds (context);
}



/*****************************************************************************
This function collects the lights from the geometries in a MultiAggregateGeom.
Ordering is unimportant, we just need to get all lights from each component
geometry.  Here we just traverse the geometries, collecting lights as we go.
*****************************************************************************/

void MultiAggregateGeom::CollectLights (LightContext &context)
{
    Geometry **geo;    // Geometry Traversal Pointer
    int       count;  // Iteration Counter

    for (geo=_geometries, count=_numGeos;  count--;  ++geo)
        (*geo)->CollectLights (context);
}


void MultiAggregateGeom::CollectTextures(GeomRenderer &device)
{
    Geometry **geo;    // Geometry Traversal Pointer
    int       count;  // Iteration Counter

    for (geo=_geometries, count=_numGeos;  count--;  ++geo)
        (*geo)->CollectTextures (device);
}


AxAValue
MultiAggregateGeom::_Cache(CacheParam &p)
{
    Geometry **geo;    // Geometry Traversal Pointer
    int       count;  // Iteration Counter

    CacheParam newParam = p;
    newParam._pCacheToReuse = NULL;

    // Just go through and cache the individual geoms
    for (geo=_geometries, count=_numGeos;  count--;  ++geo) {
        (*geo) =
            SAFE_CAST(Geometry *, AxAValueObj::Cache((*geo), newParam));
    }

    return this;
}

void MultiAggregateGeom::RayIntersect (RayIntersectCtx &context)
{
    if (!TrivialReject(_bvol, context)) {

        Geometry **geo;    // Geometry Traversal Pointer
        int       count;  // Iteration Counter

        for (geo=_geometries, count=_numGeos;
             count-- && !context.GotTheSubmesh();
             ++geo) {

            (*geo)->RayIntersect (context);

        }

    }
}



#if _USE_PRINT
ostream&
MultiAggregateGeom::Print(ostream& os)
{
    os << "MultiGeometry(" << _numGeos ;

    for (int i = 0; i < _numGeos; i++) {
        os << "," << _geometries[i] << ")";
    }

    return os;
}
#endif


Geometry *
UnionArray(AxAArray *geos)
{
    geos = PackArray(geos);

    int numGeos = geos->Length();

    switch (numGeos) {
      case 0:
        return emptyGeometry;

      case 1:
        return SAFE_CAST(Geometry *, (*geos)[0]);

      case 2:
        return PlusGeomGeom(SAFE_CAST(Geometry *, (*geos)[0]),
                            SAFE_CAST(Geometry *, (*geos)[1]));

      default:
        {
            MultiAggregateGeom *mag = NEW MultiAggregateGeom();
            mag->Init(geos);
            return mag;
        }
    }
}



#if _USE_PRINT
ostream&
operator<<(ostream& os, Geometry *geo)
{
    return geo->Print(os);
}
#endif



/*==========================================================================*/
// Primitives And Constants

//// The "empty" geometry...

class EmptyGeom : public Geometry {
  public:
    virtual void  Render (GenericDevice& dev)  {}
            void  CollectSounds (SoundTraversalContext &context)  {}
            void  CollectLights (LightContext &context)  {}
            void  RayIntersect (RayIntersectCtx &context) {}
            void  CollectTextures(GeomRenderer &device) {}

    // Bounding volume of the empty geometry is the null bbox.

    Bbox3 *BoundingVol() { return nullBbox3; }

    #if _USE_PRINT
        ostream& Print(ostream& os) { return os << "emptyGeometry"; }
    #endif

    VALTYPEID GetValTypeId() { return EMPTYGEOM_VTYPEID; }
};



/*****************************************************************************
The geometry extended attributer understand the following:

    "OpacityOverrides" <bool>   // Opacity overrides rather than multiplies
                                // with opacities in imported geometry.

*****************************************************************************/

AxAValue
Geometry::ExtendedAttrib(char *attrib, VARIANT& val)
{
    // Unless we get something we understand, the result is the unmodified geo.

    Geometry *result = this;

    CComVariant variant;

    if (  (0 == lstrcmp (attrib, "OpacityOverrides"))
       && (SUCCEEDED (variant.ChangeType (VT_BOOL, &val)))
       )
    {
        result = OverridingOpacity (this, variant.boolVal != 0);
    } else if (  (0 == lstrcmp (attrib, "AlphaShadows"))
       && (SUCCEEDED (variant.ChangeType (VT_BOOL, &val)))
       )
    {
        result = AlphaShadows (this, variant.boolVal != 0);
    }

    return result;
}



/*****************************************************************************
Initialization for Geometry Objects
*****************************************************************************/

void
InitializeModule_Geom()
{
    // The single "empty geometry" is just an instantiation of the
    // above class.
    emptyGeometry = NEW EmptyGeom;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\geom\light.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation
*******************************************************************************/

#include "headers.h"

#include "appelles/light.h"

#include "privinc/colori.h"
#include "privinc/lighti.h"
#include "privinc/xformi.h"
#include "privinc/ddrender.h"



    /**  Canonical Lights -- initialized at bottom  **/

Geometry *ambientLight     = NULL;
Geometry *directionalLight = NULL;
Geometry *pointLight       = NULL;


/*****************************************************************************
This is the constructor for the light context.  It initializes the state
maintenance and sets all attributes to their default values.
*****************************************************************************/

LightContext::LightContext (GeomRenderer *rdev)
{
    Initialize (rdev, NULL, NULL);
}

LightContext::LightContext (LightCallback *callback, void *callback_data)
{
    Initialize (NULL, callback, callback_data);
}

void LightContext::Initialize (
    GeomRenderer  *rdev,
    LightCallback *callback,
    void          *callback_data)
{
    _rdev = rdev;
    _callback = callback;
    _callback_data = callback_data;

    // Set defaults for all attributes.

    _transform = identityTransform3;

    _color = white;
    _range = 0;     // infinite

    _atten0 = 1;
    _atten1 = 0;
    _atten2 = 0;

    _depthColor = 0;
    _depthRange = 0;
    _depthAtten = 0;
}



/*****************************************************************************
Methods for setting & querying the light transform.
*****************************************************************************/

void LightContext::SetTransform (Transform3 *transform)
{   _transform = transform;
}

Transform3 *LightContext::GetTransform (void)
{   return _transform;
}



/*****************************************************************************
Methods for manipulating the light color.
*****************************************************************************/

void LightContext::PushColor (Color *color)
{   if (_depthColor++ == 0) _color = color;
}

void LightContext::PopColor (void)
{   if (--_depthColor == 0) _color = white;
}

Color* LightContext::GetColor (void) { return _color; }



/*****************************************************************************
Methods for manipulating the light range.
*****************************************************************************/

void LightContext::PushRange (Real range)
{   if (_depthRange++ == 0) _range = range;
}

void LightContext::PopRange (void)
{   if (--_depthRange == 0) _range = 0;
}

Real LightContext::GetRange (void) { return _range; }



/*****************************************************************************
Methods for setting & querying the light attenuation.
*****************************************************************************/

void LightContext::PushAttenuation (Real a0, Real a1, Real a2)
{
    if (_depthAtten++ == 0)
    {   _atten0 = a0;
        _atten1 = a1;
        _atten2 = a2;
    }
}

void LightContext::PopAttenuation (void)
{
    if (--_depthAtten == 0)
    {   _atten0 = 1;
        _atten1 = 0;
        _atten2 = 0;
    }
}

void LightContext::GetAttenuation (Real &a0, Real &a1, Real &a2)
{   a0 = _atten0;
    a1 = _atten1;
    a2 = _atten2;
}



/*****************************************************************************
This subroutine adds a light to the given context.
*****************************************************************************/

void LightContext::AddLight (Light &light)
{
    Assert (_rdev || _callback);

    if (_rdev)
        _rdev->AddLight (*this, light);
    else
        (*_callback) (*this, light, _callback_data);
}



/*****************************************************************************
This subroutine prints out the given light object to the given ostream.
*****************************************************************************/

#if _USE_PRINT
ostream& Light::Print (ostream &os) 
{
    switch (_type)
    {
        case Ltype_Ambient:     return os << "ambientLight";
        case Ltype_Directional: return os << "directionalLight";
        case Ltype_Point:       return os << "pointLight";

        case Ltype_Spot:
            return os <<"spotLight("
                      <<_fullcone <<","
                      <<_cutoff   <<")";

        default:
            return os << "<UNDEFINED LIGHT>";
    }
}
#endif



/*****************************************************************************
Spotlights have a position and direction.  In addition, the contribution of
illumination falls off as the illuminated point moves from the spotlight axis.
*****************************************************************************/

Geometry *SpotLight (Real fullcone, Real cutoff)
{
    return NEW Light (Ltype_Spot, fullcone, cutoff);
}

Geometry *SpotLight (AxANumber *fullcone, AxANumber *cutoff)
{
    return SpotLight (NumberToReal(fullcone), NumberToReal(cutoff));
}

/*****************************************************************************
This routine initializes the static light values in this module.
*****************************************************************************/

void InitializeModule_Light (void)
{
    ambientLight     = NEW Light (Ltype_Ambient);
    directionalLight = NEW Light (Ltype_Directional);
    pointLight       = NEW Light (Ltype_Point);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\geom\pickgeom.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Support for pickable geometries.

*******************************************************************************/


#include "headers.h"
#include "appelles/gattr.h"
#include "privinc/geomi.h"
#include "privinc/probe.h"

class PickableGeom : public AttributedGeom {
  public:

    PickableGeom(Geometry *geom, int id, bool uType = false,
                 GCIUnknown *u = NULL)
    : AttributedGeom(geom), _eventId(id), _hasData(uType), _long(u) {}

    virtual void DoKids(GCFuncObj proc) {
        AttributedGeom::DoKids(proc);
        (*proc)(_long);
    }
    
#if _USE_PRINT
    // Print a representation to a stream.
    ostream& Print(ostream& os) {
        return os << "PickableGeometry(" << _geometry << ")";
    }
#endif

    void  RayIntersect(RayIntersectCtx& ctx) {
        // Tell the context that this pickable image is a candidate for
        // picking, perform the pick on the underlying geometry, then
        // remove this pickable as a candidate by popping it off of the
        // stack. 
        ctx.PushPickableAsCandidate(_eventId, _hasData, _long);
        _geometry->RayIntersect(ctx);
        ctx.PopPickableAsCandidate();
    }

  protected:
    int      _eventId;
    bool _hasData;
    GCIUnknown *_long;
};

// Note that this is called with a pick event ID generated through
// CAML. 
Geometry *PRIVPickableGeometry(Geometry *geo,
                               AxANumber *id,
                               AxABoolean *ignoresOcclusion)
{
    return NEW PickableGeom(geo, (int)NumberToReal(id));
}

AxAValue PRIVPickableGeomWithData(AxAValue geo,
                                  int id,
                                  GCIUnknown *data,
                                  bool)
{
    return NEW PickableGeom(SAFE_CAST(Geometry*,geo), id, true, data);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\geom\rmvisgeo.cpp ===
/*******************************************************************************
Copyright (c) 1996-1998 Microsoft Corporation.  All rights reserved.

    Building a geometry out of a D3D retained mode visual.
*******************************************************************************/

#include "headers.h"
#include <d3drmdef.h>
#include "privinc/rmvisgeo.h"
#include "privinc/geomi.h"
#include "privinc/bbox3i.h"
#include "privinc/xformi.h"
#include "privinc/ddrender.h"
#include "privinc/debug.h"
#include "privinc/d3dutil.h"
#include "privinc/comutil.h"
#include "privinc/importgeo.h"
#include <dxtrans.h>

static Color colorNone (-1, -1, -1);



/*****************************************************************************
Methods for MeshInfo, which instruments a D3DRM mesh for DA attribute
management.
*****************************************************************************/

MeshInfo::MeshInfo ()
    : _mesh (NULL),
      _opacityBugWorkaroundID (-1),
      _defaultAttrs (NULL),
      _optionalBuilder (NULL)
{
}



void MeshInfo::SetMesh (IDirect3DRMMesh* mesh)
{
    Assert (mesh);
    AssertStr ((_mesh == NULL), "Illegal attempt to reset MeshInfo object.");

    _mesh = mesh;
    _mesh->AddRef();

    _numGroups = _mesh->GetGroupCount();

    _defaultAttrs = NEW AttrState [_numGroups];

    if (!_defaultAttrs)
        RaiseException_ResourceError ("Couldn't create D3DRM mesh attribute info");

    // Fill in the default values.

    int group;
    for (group=0;  group < _numGroups;  ++group)
    {
        D3DCOLOR color = _mesh->GetGroupColor(group);
        _defaultAttrs[group].diffuse.SetD3D (color);
        _defaultAttrs[group].opacity = RGBA_GETALPHA(color) / 255.0;

        TD3D (_mesh->GetGroupTexture (group, &_defaultAttrs[group].texture));

        // NOTE:  In some cases, the material returned may be null, without
        // a D3D error.  In these cases we just fill in the blanks with the
        // standard DA default material values.

        DAComPtr<IDirect3DRMMaterial> mat;
        TD3D (_mesh->GetGroupMaterial (group, &mat));

        D3DVALUE Er=0,Eg=0,Eb=0, Sr=0,Sg=0,Sb=0;

        if (mat.p)
        {   TD3D (mat->GetEmissive(&Er,&Eg,&Eb));
            TD3D (mat->GetSpecular(&Sr,&Sg,&Sb));
        }

        _defaultAttrs[group].emissive.SetRGB (Er,Eg,Eb);
        _defaultAttrs[group].specular.SetRGB (Sr,Sg,Sb);

        // For some reason, GetPower can return zero (which is an invalid
        // D3DRM value).  Interpret this value as the DA default of 1.

        Real specexp = mat.p ? mat->GetPower() : 1;
        _defaultAttrs[group].specularExp = (specexp < 1) ? 1 : specexp;
    }

    _overrideAttrs.emissive    = colorNone;
    _overrideAttrs.diffuse     = colorNone;
    _overrideAttrs.specular    = colorNone;
    _overrideAttrs.specularExp = -1;
    _overrideAttrs.opacity     = 1;
    _overrideAttrs.texture     = NULL;
    _overrideAttrs.shadowMode  = false;
}



/*****************************************************************************
This method returns the bounding box of the underlying mesh.  If the bbox
fetch fails, this returns the null bbox.
*****************************************************************************/

Bbox3 MeshInfo::GetBox (void)
{
    Assert (_mesh);

    D3DRMBOX rmbox;

    if (SUCCEEDED(AD3D(_mesh->GetBox(&rmbox))))
        return Bbox3 (rmbox);
    else
        return *nullBbox3;
}




/*****************************************************************************
Override the mesh attributes with the given attributes.
*****************************************************************************/

void MeshInfo::SetMaterialProperties (
    Color *emissive,
    Color *diffuse,
    Color *specular,
    Real   specularExp,
    Real   opacity,
    IDirect3DRMTexture *texture,
    bool   shadowMode,
    int    renderDevID)
{
    AssertStr (_mesh, "SetMaterialProperties on null MeshInfo.");

    int group;  // Group Index

    // Override textures if we're changing shadow modes, or if we're specifying
    // a different texture override.

    if (  (shadowMode != _overrideAttrs.shadowMode)
       || (texture != _overrideAttrs.texture))
    {
        for (group=0;  group < _numGroups;  ++group)
        {
            // Override the textures if we're in shadow mode (overriding to
            // null), or if the texture is not null.

            if (shadowMode || texture)
                TD3D (_mesh->SetGroupTexture (group, texture));
            else
                TD3D (_mesh->SetGroupTexture
                    (group, _defaultAttrs[group].texture));

            // @@@ SRH DX3
            // This is a workaround for a bug in NT SP3 (DX3) which causes a
            // crash in D3DRM when you set a new texture on a given mesh.  It
            // forces RM to take a different (working) code path.

            if (ntsp3)
            {   D3DRMVERTEX v;
                _mesh->GetVertices (0,0,1, &v);
                _mesh->SetVertices (0,0,1, &v);
            }
        }

        _overrideAttrs.texture = texture;
    }

    // Handle the diffuse/opacity bundle.  We only need to set properties on
    // the mesh if one of the overrides have changed.  If we're doing the
    // initial render, we artificially lower the opacity to work around a D3DRM
    // bug which "sticks" opacity to one if that's the first value used.

    if ((_opacityBugWorkaroundID != renderDevID) && (opacity >= 1.0))
    {   opacity = 0.95;
        _opacityBugWorkaroundID = renderDevID;
    }

    if (  (_overrideAttrs.opacity != opacity)
       || (_overrideAttrs.diffuse != (diffuse ? *diffuse : colorNone))
       )
    {
        Color Cd;   // Diffuse Color
        Real  Co;   // Opacity

        if (diffuse) Cd = *diffuse;

        for (group=0;  group < _numGroups;  ++group)
        {
            if (!diffuse) Cd = _defaultAttrs[group].diffuse;
            Co = opacity * _defaultAttrs[group].opacity;

            TD3D (_mesh->SetGroupColor (group, GetD3DColor(&Cd,Co)));
        }

        _overrideAttrs.opacity = opacity;
        _overrideAttrs.diffuse = (diffuse ? *diffuse : colorNone);
    }

    if (  (_overrideAttrs.emissive != (emissive ? *emissive : colorNone))
       || (_overrideAttrs.specular != (specular ? *specular : colorNone))
       || (_overrideAttrs.specularExp != specularExp)
       )
    {
        DAComPtr<IDirect3DRMMaterial> mat;

        TD3D (GetD3DRM1()->CreateMaterial (D3DVAL(1), &mat));

        for (group=0;  group < _numGroups;  ++group)
        {
            D3DVALUE R,G,B;

            if (emissive)
            {   R = D3DVAL (emissive->red);
                G = D3DVAL (emissive->green);
                B = D3DVAL (emissive->blue);
            }
            else
            {   R = D3DVAL (_defaultAttrs[group].emissive.red);
                G = D3DVAL (_defaultAttrs[group].emissive.green);
                B = D3DVAL (_defaultAttrs[group].emissive.blue);
            }

            TD3D (mat->SetEmissive(R,G,B));

            if (specular)
            {   R = D3DVAL (specular->red);
                G = D3DVAL (specular->green);
                B = D3DVAL (specular->blue);
            }
            else
            {   R = D3DVAL (_defaultAttrs[group].specular.red);
                G = D3DVAL (_defaultAttrs[group].specular.green);
                B = D3DVAL (_defaultAttrs[group].specular.blue);
            }

            TD3D (mat->SetSpecular(R,G,B));

            Assert ((specularExp == -1) || (specularExp >= 1));

            if (specularExp == -1)
                TD3D (mat->SetPower(D3DVAL(_defaultAttrs[group].specularExp)));
            else
                TD3D (mat->SetPower(D3DVAL(specularExp)));

            TD3D (_mesh->SetGroupMaterial (group, mat.p));
        }

        _overrideAttrs.emissive = emissive ? *emissive : colorNone;
        _overrideAttrs.specular = specular ? *specular : colorNone;
        _overrideAttrs.specularExp = specularExp;
    }

    _overrideAttrs.shadowMode = shadowMode;
}



/*****************************************************************************
The CleanUp routine handles the freeing of all memory and system objects.
Note that this method should be safe to call multiple times.
*****************************************************************************/

void MeshInfo::CleanUp (void)
{
    TraceTag ((tagGCMedia, "Cleanup: MeshInfo %08x", this));

    if (_mesh)
    {   _mesh->Release();
        _mesh = 0;
    }

    // Clean up default attributes

    if (_defaultAttrs)
    {
        int group;
        for (group=0;  group < _numGroups;  ++group)
        {
            IDirect3DRMTexture *tex = _defaultAttrs[group].texture;
            if (tex) tex->Release();
        }

        delete [] _defaultAttrs;

        _defaultAttrs = NULL;
    }

    if (_optionalBuilder)
    {   _optionalBuilder->Release();
        _optionalBuilder = NULL;
    }
}



LPDIRECT3DRMMESHBUILDER MeshInfo::GetMeshBuilder()
{
    Assert(_mesh);

    if (!_optionalBuilder) {

        TD3D(GetD3DRM1()->CreateMeshBuilder(&_optionalBuilder));
        TD3D(_optionalBuilder->AddMesh(_mesh));
    }

    return _optionalBuilder;
}



/*****************************************************************************
*****************************************************************************/

RMVisualGeo::RMVisualGeo (void)
{
    RMVisGeoDeleter *deleter = NEW RMVisGeoDeleter (this);

    GetHeapOnTopOfStack().RegisterDynamicDeleter (deleter);
}



/*****************************************************************************
This method handles all of the non-render modes, and gets the reference to
the actual geometry renderer.
*****************************************************************************/

void RMVisualGeo::Render (GenericDevice &device)
{
    Render (SAFE_CAST (GeomRenderer&, device));
}


// When picking, submit the visual to the ray-intersection contxt.

// POSSIBLE BUG: If there are multiple instances of this geometry,
// this submesh traversal doesn't distinguish them.  Could be a
// problem for multiple instancing!!  Possible fix: begin second
// traversal from just above the DXTransform, rather than from the
// top, to avoid these other instances.

void RMVisualGeo::RayIntersect (RayIntersectCtx &context)
{
    float tu, tv;
    Geometry *pickedSubGeo = context.GetPickedSubGeo(&tu, &tv);

    if (pickedSubGeo == this) {

        // In this case, we're picking back to the hit submesh of a
        // geometry dxtransform.  In this case, we can't know the
        // model coordinate hit point on the input (because the xform
        // is arbitrary), nor is the face index or hit visual
        // important.  And, for hit info,
        context.SubmitWinner(-1, *origin3, tu, tv, -1, NULL);

    } else if (!pickedSubGeo) {

        context.Pick(Visual());

    } else {

        // pickedSubGeo is non-NULL, but points to a different
        // geometry.  In this case, we don't want to do anything.
    }
}



/*****************************************************************************
Methods for RM1MeshGeo objects
*****************************************************************************/

RM1MeshGeo::RM1MeshGeo (
    IDirect3DRMMesh *mesh,
    bool             trackGenIDs)
    : _baseObj (NULL)
{
    _meshInfo.SetMesh (mesh);

    _bbox = _meshInfo.GetBox ();

    TraceTag ((tagGCMedia, "New RMMeshGeo %08x, mesh %08x", this, mesh));
}



/*****************************************************************************
The CleanUp method releases any resources by the RM1MeshGeo.
*****************************************************************************/

void RM1MeshGeo::CleanUp (void)
{
    TraceTag ((tagGCMedia, "CleanUp: RM1MeshGeo %08x", this));

    // Note that the eager cleanup below assumes that meshInfo.CleanUp() may
    // be invoked multiple times.

    _meshInfo.CleanUp();
}



/*****************************************************************************
This method renders the RM mesh, handling DXTransform meshes if necessary.
*****************************************************************************/

void RM1MeshGeo::Render(GeomRenderer &gdev)
{
    Assert (!_meshInfo.IsEmpty());

    gdev.Render(this);
}



void RM1MeshGeo::SetMaterialProperties (
    Color *emissive,
    Color *diffuse,
    Color *specular,
    Real   specularExp,
    Real   opacity,
    IDirect3DRMTexture *texture,
    bool   shadowMode,
    int    renderDevID)
{
    Assert (!_meshInfo.IsEmpty());

    _meshInfo.SetMaterialProperties
    (   emissive, diffuse, specular, specularExp,
        opacity, texture, shadowMode, renderDevID
    );
}



void RM1MeshGeo::SetD3DQuality (D3DRMRENDERQUALITY qual)
{
    Assert (!_meshInfo.IsEmpty());

    TD3D(_meshInfo.GetMesh()->SetGroupQuality(-1, qual));
}



void RM1MeshGeo::SetD3DMapping (D3DRMMAPPING m)
{
    Assert (!_meshInfo.IsEmpty());

    TD3D(_meshInfo.GetMesh()->SetGroupMapping(-1, m));
}



/*****************************************************************************
Handle cases where the underlying mesh geometry changes (e.g. via dynamic
trimeshes).
*****************************************************************************/

void RM1MeshGeo::MeshGeometryChanged (void)
{
    Assert (!_meshInfo.IsEmpty());

    // Reset the bounding box by fetching it again from the underlying mesh
    // object.

    _bbox = _meshInfo.GetBox ();
}



/*****************************************************************************
RM1FrameGeo Methods
*****************************************************************************/

RM1FrameGeo::RM1FrameGeo (
    IDirect3DRMFrame         *frame,
    vector<IDirect3DRMMesh*> *internalMeshes,
    Bbox3                    *bbox)
{
    TraceTag ((tagGCMedia, "New RMFrameGeo %08x, frame %08x", this, frame));

    _frame =  frame;
    _frame -> AddRef();

    _bbox = *bbox;

    _numMeshes = internalMeshes->size();
    _meshes = (MeshInfo **)AllocateFromStore(_numMeshes * sizeof(MeshInfo *));

    MeshInfo **info = _meshes;
    vector<IDirect3DRMMesh*>::iterator i;
    for (i = internalMeshes->begin(); i != internalMeshes->end(); i++) {
        *info = NEW MeshInfo;
        (*info)->SetMesh(*i);
        info++;
    }

    Assert(info == _meshes + _numMeshes);
}



/*****************************************************************************
The cleanup method is called either from the object destructor or directly to
release all resources held by the object.  Note that this method is safe for
multiple calls.
*****************************************************************************/

void RM1FrameGeo::CleanUp (void)
{
    // Note that the MeshInfo structures are GC objects, so we don't need to
    // (shouldn't) explicitly delete each of them here.

    if (_meshes)
    {   DeallocateFromStore (_meshes);
        _meshes = NULL;
    }

    if (_frame)
    {   _frame->Release();
        _frame = NULL;
    }

    TraceTag ((tagGCMedia, "CleanUp: RMFrameGeo %08x", this));
}



void RM1FrameGeo::SetMaterialProperties (
    Color *emissive,
    Color *diffuse,
    Color *specular,
    Real   specularExp,
    Real   opacity,
    IDirect3DRMTexture *texture,
    bool   shadowMode,
    int    renderDevID)
{
    Assert (_meshes);

    MeshInfo **m = _meshes;
    for (int i = 0; i < _numMeshes; i++) {
        (*m++) -> SetMaterialProperties
            (emissive, diffuse, specular, specularExp,
             opacity, texture, shadowMode, renderDevID);
    }
}



void RM1FrameGeo::SetD3DQuality (D3DRMRENDERQUALITY qual)
{
    Assert (_meshes);

    MeshInfo **m = _meshes;
    for (int i = 0; i < _numMeshes; i++) {
        TD3D((*m++)->GetMesh()->SetGroupQuality(-1, qual));
    }
}



void RM1FrameGeo::SetD3DMapping (D3DRMMAPPING mp)
{
    Assert (_meshes);

    MeshInfo **m = _meshes;
    for (int i = 0; i < _numMeshes; i++) {
        TD3D((*m++)->GetMesh()->SetGroupMapping(-1, mp));
    }
}



void RM1FrameGeo::DoKids (GCFuncObj proc)
{
    RM1VisualGeo::DoKids(proc);

    // Ensure that we only mark submeshes if we haven't already been cleaned
    // up.

    if (_meshes)
    {
        for (int i=0; i<_numMeshes; i++)
            (*proc) (_meshes[i]);
    }
}



/*****************************************************************************
The RM3MBuilderGeo represents a D3DRM MeshBuilder3 object.
*****************************************************************************/

RM3MBuilderGeo::RM3MBuilderGeo (
    IDirect3DRMMeshBuilder3 *mbuilder,
    bool                     trackGenIDs)
    :
    _mbuilder (mbuilder),
    _baseObj (NULL)
{
    Assert (_mbuilder);

    _mbuilder->AddRef();

    SetBbox();

    TraceTag ((tagGCMedia, "New RM3MBuilderGeo %x, mb %x", this, mbuilder));
}

RM3MBuilderGeo::RM3MBuilderGeo (IDirect3DRMMesh *mesh)
    : _mbuilder(NULL), _baseObj(NULL), _bbox(*nullBbox3)
{
    Assert (mesh);

    // Create the meshbuilder that will house the given mesh.

    TD3D (GetD3DRM3()->CreateMeshBuilder (&_mbuilder));

    // Add the given mesh to the newly-created meshbuilder.

    TD3D (_mbuilder->AddMesh (mesh));

    SetBbox();
}



/*****************************************************************************
This method resets the meshbuilder to the contents of the given mesh.
*****************************************************************************/

void RM3MBuilderGeo::Reset (IDirect3DRMMesh *mesh)
{
    Assert (_mbuilder);

    // Empty the previous contents.

    TD3D (_mbuilder->Empty(0));

    // Reset to contain the given mesh, and fetch new bounding box.

    TD3D (_mbuilder->AddMesh (mesh));
    SetBbox();
}



/*****************************************************************************
This method examines the D3D bounding box of the meshbuilder and caches the
value as a DA 2D bbox.
*****************************************************************************/

void RM3MBuilderGeo::SetBbox (void)
{
    Assert (_mbuilder);

    D3DRMBOX rmbox;

    if (SUCCEEDED (AD3D (_mbuilder->GetBox (&rmbox))))
        _bbox = rmbox;
    else
        _bbox = *nullBbox3;
}



/*****************************************************************************
The CleanUp routine for RM3MBuilderGeo is called from the d'tor, or directly.
Note that this method is safe across multiple invocations.
*****************************************************************************/

void RM3MBuilderGeo::CleanUp (void)
{
    if (_mbuilder)
    {   _mbuilder->Release();
        _mbuilder = NULL;
    }

    TraceTag ((tagGCMedia, "CleanUp: RM3MBuilderGeo %x", this));
}



/*****************************************************************************
The Render method for RM3MBuilderGeo also handles DXTransform'ed mbuilders.
*****************************************************************************/

void RM3MBuilderGeo::Render (GeomRenderer &geomRenderer)
{
    Assert (_mbuilder);
    geomRenderer.Render (this);
}



/*****************************************************************************
Wraps a RM3MBuilderGeo with texture coordinates
*****************************************************************************/

void RM3MBuilderGeo::TextureWrap (TextureWrapInfo *info)
{
    Assert (info);
    Assert (_mbuilder);

    RMTextureWrap wrap(info,&_bbox);
    wrap.Apply(_mbuilder);
    TD3D(_mbuilder->SetTextureTopology((BOOL) wrap.WrapU(), (BOOL) wrap.WrapV()));
}



/*****************************************************************************
This method optimizes the RM meshbuilder.
*****************************************************************************/

void RM3MBuilderGeo::Optimize (void)
{
    Assert (_mbuilder);
    TD3D (_mbuilder->Optimize(0));
}



/*****************************************************************************
The constructor for the RM3FrameGeo object needs to get the hierarchical
bounding box of the entire frame.
*****************************************************************************/

RM3FrameGeo::RM3FrameGeo (IDirect3DRMFrame3 *frame)
    : _frame(frame)
{
    _frame->AddRef();

    // Get the bounding box of the frame hierarchy.  Frame3::GetHierarchyBox()
    // returns the bounding box of all contained visuals without factoring in
    // the transform on that frame.  Thus, we need to create a dummy frame to
    // contain the frame we're interested in, and GetHierarchyBox off the
    // containing frame.  If any of this fails, we leave the _bbox member as
    // nullBbox3.

    D3DRMBOX box;
    IDirect3DRMFrame3 *container_frame;

    if (  SUCCEEDED(AD3D(GetD3DRM3()->CreateFrame (0, &container_frame)))
       && SUCCEEDED(AD3D(container_frame->AddVisual(_frame)))
       && SUCCEEDED(AD3D(container_frame->GetHierarchyBox(&box)))
       )
    {
        _bbox = box;

        AD3D(container_frame->DeleteVisual(_frame));
        container_frame->Release();
    }
    else
    {
        _bbox = *nullBbox3;
        AssertStr (0,"GetHierarchyBox failed on Frame3 Object.");
    }
}



/*****************************************************************************
The cleanup method for the RM3FrameGeo object needs only to release the
frame interface.  This method is safe across multiple invocations.
*****************************************************************************/

void RM3FrameGeo::CleanUp (void)
{
    if (_frame)
    {   _frame->Release();
        _frame = NULL;
    }
}



/*****************************************************************************
Wraps a RM3FrameGeo with texture coordinates
*****************************************************************************/

void RM3FrameGeo::TextureWrap (TextureWrapInfo *info)
{
    Assert (info);

    RMTextureWrap wrap(info,&_bbox);
    //  wrap.Apply(_frame);
    wrap.ApplyToFrame(_frame);
    //  TD3D(_frame->SetTextureTopology((BOOL) wrap.WrapU(), (BOOL) wrap.WrapV()));
    SetRMFrame3TextureTopology(_frame,wrap.WrapU(),wrap.WrapV());
}



/*****************************************************************************
                        RM3 Progressive Mesh Geometry
*****************************************************************************/

RM3PMeshGeo::RM3PMeshGeo (IDirect3DRMProgressiveMesh *pmesh)
    : _pmesh (pmesh)
{
    Assert (_pmesh);

    _pmesh->AddRef();

    // The bounding box returned for the pmesh will be the maximal bounding box
    // for all possible refinements of the pmesh.

    D3DRMBOX rmbox;

    if (SUCCEEDED (AD3D(_pmesh->GetBox(&rmbox))))
    {   _bbox = rmbox;
    }
    else
    {   _bbox = *nullBbox3;
    }
}



/*****************************************************************************
The cleanup method releases the pmesh reference made in the constructor.
This method is safe across multiple invocations.
*****************************************************************************/

void RM3PMeshGeo::CleanUp (void)
{
    if (_pmesh)
    {   _pmesh->Release();
        _pmesh = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\geom\soundgeo.cpp ===
/*++
********************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Support for Geometry *constructed from sound.

********************************************************************************
--*/

#include "headers.h"
#include <privinc/soundi.h>
#include <privinc/geomi.h>
#include <privinc/mici.h>
#include <appelles/vec3.h>
#include <privinc/lighti.h>
#include <privinc/snddev.h>
#include <math.h>


class SoundGeometry : public Geometry {
  public:
    SoundGeometry(Sound *snd) : _sound(snd) {}

    void Render (GenericDevice& dev) { _sound->Render(dev); }

    void CollectLights (LightContext &context) {}
    void CollectSounds (SoundTraversalContext &context)
        { context.addSound (context.getTransform(), _sound); }
    void CollectTextures(GeomRenderer &device) {}

    // Rays don't intersect sound geometries.
    void RayIntersect(RayIntersectCtx& ctx) {}

    // Bounding volume of a sound is the null bbox.
    Bbox3 *BoundingVol() { return nullBbox3; }

#if _USE_PRINT
    ostream& Print(ostream& os)
        { return os << "SoundSource(" << _sound << ")"; }
#endif

    virtual void DoKids(GCFuncObj proc) { (*proc)(_sound); }

    VALTYPEID GetValTypeId() { return SOUNDGEOM_VTYPEID; }

  protected:
    Sound *_sound;
};


Geometry *SoundSource(Sound *snd)
{
    if (snd == silence) {
        return emptyGeometry;
    } else {
        return NEW SoundGeometry(snd);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\geom\shadow.cpp ===
/*******************************************************************************
Copyright (c) 1997-1998 Microsoft Corporation.  All rights reserved.

    This code implements 3D rendered shadows.

*******************************************************************************/

#include "headers.h"

#include "appelles/gattr.h"
#include "privinc/geomi.h"
#include "privinc/xformi.h"
#include "privinc/lighti.h"
#include "privinc/ddrender.h"
#include "privinc/d3dutil.h"



/*****************************************************************************
This class implements a shadow geometry.
*****************************************************************************/

class ShadowGeom : public AttributedGeom
{
  public:

    ShadowGeom (Geometry      *geoToShadow,
                Geometry      *geoContainingLights,
                Point3Value   *planePoint,
                Vector3Value  *planeNormal)
           : AttributedGeom (geoToShadow),
             _shadowPlane (*planeNormal,*planePoint),
             _geoContainingLights (geoContainingLights)
    {
        // ensure that shadow plane normal isn't zero-length

        if (_shadowPlane.Normal().LengthSquared() == 0.0) {
            Vector3Value defaultNormal(0.0,1.0,0.0);
            Plane3 newPlane(defaultNormal,*planePoint);
            _shadowPlane = newPlane;
        }
    }

    void Render3D(GeomRenderer &ddrenderer)
    {
        Point3Value geoCenter = *((_geometry->BoundingVol())->Center());

        // is object on correct side of shadow plane?
        if (geoCenter.Clip(_shadowPlane) == CLIPCODE_IN) {

            if (ddrenderer.StartShadowing(&_shadowPlane)) {

                // collect geometry to be shadowed into one single frame
                _geometry->Render(ddrenderer);

                // find all the lights casting shadows, create shadows
                LightContext lctx(&ddrenderer);
                _geoContainingLights->CollectLights(lctx);

                // finish up
                ddrenderer.StopShadowing();
            }
        }
    }

    Bbox3 *BoundingVol (void);

    static void bbox_callback (LightContext&, Light&, void*);

    void DoKids(GCFuncObj proc)
    {
        AttributedGeom::DoKids(proc);
        (*proc)(_geoContainingLights);
    }

    VALTYPEID GetValTypeId()
    {
        return SHADOWGEOM_VTYPEID;
    }

    #if _USE_PRINT
        ostream& Print (ostream &os)
            { return os <<"shadow(" << _geometry <<")"; }
    #endif

  protected:

    Plane3    _shadowPlane;
    Geometry *_geoContainingLights;
    Bbox3     _bbox;
};



/*****************************************************************************
This method computes the bounding box of the shadows (on the shadow plane) of
the shadow geometry.
*****************************************************************************/

Bbox3* ShadowGeom::BoundingVol (void)
{
    _bbox = *nullBbox3;    // Initialize bbox to null.

    // Initiate a light-collection traversal over the light-containing
    // geometry, which will call back to the bbox_callback function below for
    // each light source encountered.  The bounding box will be augmented with
    // the shadow projection (on the shadow plane) for each light source.

    LightContext context (&bbox_callback, this);
    _geoContainingLights->CollectLights (context);

    // Return the resulting bounding box of all shadows on the shadow plane.

    return NEW Bbox3 (_bbox);
}



/*****************************************************************************
This function is called back for each light geometry encountered in the light
geometry graph.  It calculates the projection of each vertex of the geometry
bounding box on the shadow plane and augments the total bounding box of all
shadows cast on the shadow plane.
*****************************************************************************/

void ShadowGeom::bbox_callback (
    LightContext &context,     // Light Traversal Context
    Light        &light,       // Specific Light Object Encountered
    void         *data)        // Pointer to Shadow Geometry
{
    // We can't use SAFE_CAST here since we're casting from a void*.

    ShadowGeom * const shadow = (ShadowGeom*) data;

    // Skip ambient lights, since they cast no shadows.

    if (light.Type() == Ltype_Ambient)
        return;

    // Enumerate the eight vertices of the bounding box for the shadowed geom.

    Point3Value boxverts[8];
    shadow->_geometry->BoundingVol()->GetPoints (boxverts);

    switch (light.Type())
    {
        default:
            Assert (!"Invalid light type encountered.");
            break;

        case Ltype_Directional:
        {
            // For directional lights, cast rays from the vertices of the bbox
            // corners onto the shadow plane, in the same direction as the
            // directional light.  Use these projected corners to augment the
            // bounding box of all cast shadows.

            Vector3Value Ldir = *context.GetTransform() * (-(*zVector3));

            unsigned int i;
            for (i=0;  i < 8;  ++i)
            {
                Ray3 ray (boxverts[i], Ldir);
                Real t = Intersect (ray, shadow->_shadowPlane);

                // Use the projected point to augment the bounding box as long
                // as the light projects the point onto the plane, and the
                // light ray is not parallel to the shadow plane.

                if ((t > 0) && (t < HUGE_VAL))
                {   shadow->_bbox.Augment (ray.Evaluate(t));
                    Assert (fabs(Distance(shadow->_shadowPlane,ray.Evaluate(t))) < 1e6);
                }
            }

            break;
        }

        case Ltype_Point:
        case Ltype_Spot:
        {
            // For positioned lights (we ignore any other properties of
            // spotlights), cast rays from the light position through the bbox
            // corners onto the shadow plane.  Use these projected corners to
            // augment the bounding box of all cast shadows.

            Point3Value Lpos = *context.GetTransform() * (*origin3);

            // The light/object pair will cast a shadow only if the following
            // are true:  the light is on the positive side of the plane, and
            // the center of the object's bbox is on the positive side of the
            // plane, and at least one of the bbox's corner vertices lies
            // between the light and the plane.

            Plane3 &plane = shadow->_shadowPlane;

            unsigned int i;
            bool casts_shadow = false;

            const Real lightdist = Distance (plane, Lpos);

            if (lightdist > 0)
            {
                Point3Value *center =
                    shadow->_geometry->BoundingVol()->Center();

                if (Distance (plane, *center) > 0)
                {
                    for (i=0;  i < 8;  ++i)
                    {
                        if (Distance(plane,boxverts[i]) < lightdist)
                        {   casts_shadow = true;
                            break;
                        }
                    }
                }
            }

            if (casts_shadow)
            {
                for (i=0;  i < 8;  ++i)
                {
                    Ray3 ray (Lpos, boxverts[i] - Lpos);
                    Real t = Intersect (ray, plane);

                    if ((t > 0) && (t < HUGE_VAL))
                    {
                        // Use the projected point to augment the bounding box
                        // as long as the light projects the point onto the
                        // plane, and the light ray is not parallel to the
                        // shadow plane.

                        shadow->_bbox.Augment (ray.Evaluate(t));
                    }
                    else
                    {
                        // The ray goes away from the plane, so "chop" it down
                        // to 99% of the height of the light position.  This is
                        // the same hack that D3DRM uses.

                        Vector3Value N = plane.Normal();   // Unit Plane Normal
                        N.Normalize();

                        // Figure out the directed offset to bring the point to
                        // closer to the plane than the light source, and apply
                        // to get a new point.

                        Real offset = 1.01 * Dot (N, ray.Direction());

                        // If the ray is parallel to the plane, then the above
                        // dot product will be zero.  In this case, just offset
                        // the corner point toward the shadow plane by 1% of
                        // the distance from the plane.

                        if (offset <= 1e-6)
                            offset = 0.01;

                        Point3Value P2 = boxverts[i] - (offset * N);

                        // Now intersect the ray with the new point, which is
                        // closer to the plane than the light source, and hence
                        // guaranteed to intersect the plane.

                        Ray3 ray2 (Lpos, P2 - Lpos);
                        t = Intersect (ray2, plane);

                        Assert (t < HUGE_VAL);
                        shadow->_bbox.Augment (ray2.Evaluate(t));
                    }
                }
            }

            break;
        }
    }
}



Geometry *ShadowGeometry (
    Geometry     *geoToShadow,
    Geometry     *lightsgeo,
    Point3Value  *planePoint,
    Vector3Value *planeNormal)
{
    return NEW ShadowGeom (geoToShadow, lightsgeo, planePoint, planeNormal);
}



/*****************************************************************************
This class of geometry enables RM's advanced shadow-rendering.
*****************************************************************************/

class AlphaShadowGeom : public AttributedGeom
{
  public:

    AlphaShadowGeom (Geometry *geometry, bool alphaShadows)
        : AttributedGeom(geometry), _alphaShadows(alphaShadows) {}

    void Render3D (GeomRenderer &ddrenderer)
    {
        ddrenderer.PushAlphaShadows(_alphaShadows);
        _geometry->Render(ddrenderer);
        ddrenderer.PopAlphaShadows();
    }

    #if _USE_PRINT
        virtual ostream& Print (ostream& os) {
            return os << "AlphaShadowGeom(" << _alphaShadows << ","
                      << _geometry << ")";
        }
    #endif

  protected:

    bool _alphaShadows;
};



Geometry*
AlphaShadows (Geometry *geo, bool alphaShadows)
{
    if (!geo || (geo == emptyGeometry))
        return emptyGeometry;

    return NEW AlphaShadowGeom (geo, alphaShadows);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\geom\txtrgeom.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Support for texturing geometry with DAImages and RMTexture
    handles.

*******************************************************************************/


#include "headers.h"

#include "privinc/dispdevi.h"
#include "privinc/geomi.h"
#include "privinc/xformi.h"

#include "privinc/colori.h"
#include "privinc/ddrender.h"
#include "privinc/lighti.h"
#include "privinc/soundi.h"
#include "privinc/probe.h"
#include "privinc/opt.h"
#include "privinc/comutil.h"
#include "privinc/server.h"
#include "backend/perf.h"
#include "backend/bvr.h"
#include "fullattr.h"

Geometry *
NewRMTexturedGeom(RMTextureBundle texInfo, Geometry *geo)
{
    if (geo == emptyGeometry) return geo;

    FullAttrStateGeom *f = CombineState(geo);

    // Don't worry about releasing a current texture if one is
    // there... nothing is being held onto.

    f->AppendFlag(GEOFLAG_CONTAINS_EXTERNALLY_UPDATED_ELT);

    f->SetAttr(FA_TEXTURE);
    f->SetMostRecent(FA_TEXTURE); // for blend
    f->_textureBundle._nativeRMTexture = true;
    f->_textureBundle._rmTexture = texInfo;

    return f;
}

AxAValue
ConstHelper(AxAValue constGeoVal, RMTextureBundle *texInfo)
{
    AxAValue result;

    if (constGeoVal) {

        Geometry *constGeo = SAFE_CAST(Geometry *, constGeoVal);
        result = NewRMTexturedGeom(*texInfo, constGeo);

    } else {

        result = NULL;

    }

    return result;
}

class RMTexturedGeomBvr : public DelegatedBvr {
  friend class RMTexturedGeomPerf;

  public:
    RMTexturedGeomBvr(Bvr             geometry,
                      GCIUnknown     *data,
                      IDXBaseObject  *baseObj,
                      RMTextureBundle texInfo)
    : DelegatedBvr(geometry)
    {
        _data = data;
        _texInfo = texInfo;

        // Don't maintain an internal reference.  The guy we call
        // will.
        _baseObj = baseObj;
    }

    virtual AxAValue GetConst(ConstParam & cp) {
        // Can never assume we're fully const, since the texture can
        // change outside of DA's control.
        return NULL;
    }

    virtual Perf _Perform(PerfParam& p);

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_base);
        (*proc)(_data);
    }

  private:
    GCIUnknown             *_data;
    RMTextureBundle         _texInfo;
    IDXBaseObject          *_baseObj;
};

class RMTexturedGeomPerf : public DelegatedPerf {
  public:
    RMTexturedGeomPerf(Perf geo, RMTexturedGeomBvr *bvr)
    : DelegatedPerf(geo), _bvr(bvr)
    {
        if (_bvr->_baseObj) {
            HRESULT hr =
                _bvr->_baseObj->GetGenerationId(&_previousTextureAge);

            Assert(SUCCEEDED(hr));
        }
    }

    virtual void _DoKids(GCFuncObj proc) {
        (*proc)(_base);
        (*proc)(_bvr);
    }

    virtual AxAValue GetConst(ConstParam & cp) {
        // Can never assume we're fully const, since the texture can
        // change outside of DA's control.
        return NULL;
    }

    virtual AxAValue _GetRBConst(RBConstParam& p) {

        // Treat like a switcher, and we'll trigger an event when it
        // changes.
        //
        // TODO: This is probably heavier weight than it
        // needs to be, since we're going to generate an event each
        // time the texture changes, invalidating the entire view!!!
        
        p.AddChangeable(this);
        return ConstHelper(_base->GetRBConst(p), &_bvr->_texInfo);
    }

    bool CheckChangeables(CheckChangeablesParam &ccp) {
        
        IDXBaseObject *bo = _bvr->_baseObj;
        
        if (bo) {
            ULONG currAge;
            HRESULT hr = bo->GetGenerationId(&currAge);
            Assert(SUCCEEDED(hr));

            if (currAge != _previousTextureAge) {

                // Tell the current view that an event has happened to
                // it.

                TraceTag((tagSwitcher,
                          "Texture changed for view 0x%x, txtrGeom 0x%x - %d -> %d",
                          IntGetCurrentView(),
                          _bvr,
                          _previousTextureAge,
                          currAge));
                
                _previousTextureAge = currAge;

                return true;
            }
        }

        return false;
    }
    
    virtual AxAValue _Sample(Param& p) {

        Geometry *sampledGeo =
            SAFE_CAST(Geometry *, _base->Sample(p));

        return NewRMTexturedGeom(_bvr->_texInfo, sampledGeo);
    }

  private:
    RMTexturedGeomBvr *_bvr;
    ULONG              _previousTextureAge;
};

Perf
RMTexturedGeomBvr::_Perform(PerfParam& p)
{
    return NEW RMTexturedGeomPerf(::Perform(_base, p), this);
}


Bvr
applyD3DRMTexture(Bvr geo, IUnknown *texture)
{
    HRESULT hr;

    if (texture == NULL) {
        RaiseException_UserError(E_FAIL, IDS_ERR_GEO_BAD_RMTEXTURE);
    }

    RMTextureBundle texInfo;

    
    hr = texture->QueryInterface(IID_IDirect3DRMTexture3,
                                 (void **)&texInfo._texture3);

    if (SUCCEEDED(hr)) {
        texInfo._isRMTexture3 = true;

        // Don't want the extra reference.
        texInfo._texture3->Release();

    } else {

        texInfo._isRMTexture3 = false;
        hr = texture->QueryInterface(IID_IDirect3DRMTexture,
                                     (void **)&texInfo._texture1);
        if (FAILED(hr)) {
            // Not a texture at all
            RaiseException_UserError(E_FAIL, IDS_ERR_GEO_BAD_RMTEXTURE);
        }

        // Don't want the extra reference
        texInfo._texture1->Release();
    }

    GCIUnknown *gciunk = NEW GCIUnknown(texture);

    DAComPtr<IDXBaseObject> baseObj;
    hr = texture->QueryInterface(IID_IDXBaseObject,
                                 (void **)&baseObj);

    if (FAILED(hr)) {
        // Should happen automatically, but doesn't always (RM for
        // instance doesn't do this as a matter of course.)
        baseObj = NULL;
    }

    // We'll make a more intelligent distinction between texture1
    // and texture3 in the future.
    if (texInfo._isRMTexture3) {
        texInfo._voidTex = texInfo._texture3;
    } else {
        texInfo._voidTex = texInfo._texture1;
    }

    texInfo._gcUnk = gciunk;

    return NEW RMTexturedGeomBvr(geo, gciunk, baseObj, texInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\geom\trimesh.cpp ===
/*******************************************************************************
Copyright (c) 1998 Microsoft Corporation.  All rights reserved.

    Triangle Mesh Geometry

*******************************************************************************/

#include "headers.h"
#include "d3drm.h"
#include "backend/bvr.h"
#include "privinc/geomi.h"
#include "privinc/d3dutil.h"
#include "privinc/rmvisgeo.h"



/*****************************************************************************
This object manages the behavior of a triangle mesh.
*****************************************************************************/

class TriMeshBvrImpl : public BvrImpl
{
  friend class TriMeshPerfImpl;

  public:

    TriMeshBvrImpl (void);
    ~TriMeshBvrImpl (void);

    bool Init (TriMeshData&);
    void CleanUp (void);

    DXMTypeInfo GetTypeInfo (void);

    // Return the constant value for this behavior if one exists.

    AxAValue GetConst (ConstParam &);

    // Mark member values as in-use.

    void _DoKids (GCFuncObj procedure);

    // Construct a TriMesh performance from this behavior.

    Perf _Perform (PerfParam &);

  protected:

    // Private Methods

    bool ValidateParams (TriMeshData &);

    bool BuildStaticMesh (TriMeshData &);
    bool SetupDynamicMesh (TriMeshData &);

    // Member Data Fields

    IDirect3DRMMesh *_mesh;     // Underlying RM Mesh Object
    D3DRMVERTEX     *_verts;    // D3DRM Vertices
    unsigned int     _nVerts;   // Count of D3DRMVertices

    Bvr *_vPosBvr;      // Dynamic Vertex Positions
    Bvr *_vNormBvr;     // Dynamic Vertex Normals
    Bvr *_vUVBvr;       // Dynamic Vertex Surface Coords

    Perf _constPerf;    // Constant Performance of this Behavior

    bool _fullyStatic;  // True if Mesh is Fully Constant
    bool _posStatic;    // True if Vertex Positions   are Fully Constant
    bool _normStatic;   // True if Vertex Normals     are Fully Constant
    bool _uvStatic;     // True if Vertex Surf Coords are Fully Constant
};



/*****************************************************************************
This object manages the performance of a triangle mesh behavior.
*****************************************************************************/

class TriMeshPerfImpl : public PerfImpl
{
  public:

    TriMeshPerfImpl (TriMeshBvrImpl&);
    ~TriMeshPerfImpl (void);

    bool Init (PerfParam&);
    void CleanUp (void);

    // Return a static value of this performance.

    AxAValue _Sample (Param &);

    // Mark member values as in-use.

    void _DoKids (GCFuncObj procedure);

  private:

    TriMeshBvrImpl &_tmbvr;     // Master TriMesh Behavior

    Perf *_vPos;    // Vertex Position  Performances (when positions dynamic)
    Perf *_vNorm;   // Vertex Normal    Performances (when normals dynamic)
    Perf *_vUV;     // Vertex SurfCoord Performances (when surfcoords dynamic)

    IDirect3DRMMesh *_mesh;     // Perf-local Copy of RM Mesh
    RM1MeshGeo      *_meshgeo;  // Mesh Geo for RM1 (pre DX6)
    RM3MBuilderGeo  *_mbgeo;    // MeshBuilder Geo for RM3 and Above (DX6+)
};



/*****************************************************************************
These structures are used to manage static vertex objects.
*****************************************************************************/

    // This STL comparison class is used to lexicographically compare two RM
    // vertices while ignoring the color field (which we'll use to assign
    // vertex id's temporarily).

class RMVertLess
{
  public:

    bool operator() (const D3DRMVERTEX &lhs, const D3DRMVERTEX &rhs) const
    {
        if (lhs.position.x < rhs.position.x) return true;
        if (lhs.position.x > rhs.position.x) return false;
        if (lhs.position.y < rhs.position.y) return true;
        if (lhs.position.y > rhs.position.y) return false;
        if (lhs.position.z < rhs.position.z) return true;
        if (lhs.position.z > rhs.position.z) return false;
        if (lhs.normal.x   < rhs.normal.x)   return true;
        if (lhs.normal.x   > rhs.normal.x)   return false;
        if (lhs.normal.y   < rhs.normal.y)   return true;
        if (lhs.normal.y   > rhs.normal.y)   return false;
        if (lhs.normal.z   < rhs.normal.z)   return true;
        if (lhs.normal.z   > rhs.normal.z)   return false;
        if (lhs.tu         < rhs.tu)         return true;
        if (lhs.tu         > rhs.tu)         return false;
        if (lhs.tv         < rhs.tv)         return true;
        return false;
    }
};

typedef set<D3DRMVERTEX, RMVertLess> VertSet;



/*****************************************************************************
These structures are used to manage dynamic vertex objects.
*****************************************************************************/

    // This structure holds information for a vertex in a dynamic context.
    // Sometimes all instances of a given vertex property will be constant
    // (e.g. when UV's come in as float tuples), and sometimes only some
    // properties will be constant (e.g. instances of constant position
    // behaviors mixed with dynamic ones).  The isBvrXxx flags denote each
    // property type for each vertex.  The index is used to hold the final RM
    // index into the RM mesh topology.

struct DynVertData
{
    int  index;           // Vertex Index in RM Mesh Topology
    bool isBvrPos;        // If true, position is a Point3 behavior.
    bool isBvrNorm;       // If true, normal is a Vector3 behavior.
    bool isBvrUV;         // If true, UV is a Point2 behavior.

    union { Bvr bvr;  float floats[3]; } pos;    // Position   Data
    union { Bvr bvr;  float floats[3]; } norm;   // Normal     Data
    union { Bvr bvr;  float floats[2]; } uv;     // Surf Coord Data
};


    // This method compares two instances of dynamic vertex data to determine
    // whether the first argument is less than the second one.  The ordering is
    // inconsequential, but it needs to be rigorous to ensure that the STL set
    // that uses this function will properly track which vertices already exist
    // in the vertex set.

class DynVertLess
{
  public:

    bool operator() (const DynVertData &A, const DynVertData &B) const
    {
        // First compare the vertex position.  Behavior pointers are ranked
        // less than float triples.

        if (A.isBvrPos)
        {
            if (B.isBvrPos)
            {   if (A.pos.bvr < B.pos.bvr) return true;
                if (A.pos.bvr > B.pos.bvr) return false;
            }
            else
            {   return true;
            }
        }
        else
        {
            if (B.isBvrPos)
            {   return false;
            }
            else
            {   if (A.pos.floats[0] < B.pos.floats[0]) return true;
                if (A.pos.floats[0] > B.pos.floats[0]) return false;
                if (A.pos.floats[1] < B.pos.floats[1]) return true;
                if (A.pos.floats[1] > B.pos.floats[1]) return false;
                if (A.pos.floats[2] < B.pos.floats[2]) return true;
                if (A.pos.floats[2] > B.pos.floats[2]) return false;
            }
        }

        // Next compare the vertex normal.  Behavior pointers are ranked
        // less than float triples.

        if (A.isBvrNorm)
        {
            if (B.isBvrNorm)
            {   if (A.norm.bvr < B.norm.bvr) return true;
                if (A.norm.bvr > B.norm.bvr) return false;
            }
            else
            {   return true;
            }
        }
        else
        {
            if (B.isBvrNorm)
            {   return false;
            }
            else
            {   if (A.norm.floats[0] < B.norm.floats[0]) return true;
                if (A.norm.floats[0] > B.norm.floats[0]) return false;
                if (A.norm.floats[1] < B.norm.floats[1]) return true;
                if (A.norm.floats[1] > B.norm.floats[1]) return false;
                if (A.norm.floats[2] < B.norm.floats[2]) return true;
                if (A.norm.floats[2] > B.norm.floats[2]) return false;
            }
        }

        // Next compare the vertex surface coordinates.  Behavior pointers are
        // ranked less than float tuples.

        if (A.isBvrUV)
        {
            if (B.isBvrUV)
            {   if (A.uv.bvr < B.uv.bvr) return true;
                if (A.uv.bvr > B.uv.bvr) return false;
            }
            else
            {   return true;
            }
        }
        else
        {
            if (B.isBvrUV)
            {   return false;
            }
            else
            {   if (A.uv.floats[0] < B.uv.floats[0]) return true;
                if (A.uv.floats[0] > B.uv.floats[0]) return false;
                if (A.uv.floats[1] < B.uv.floats[1]) return true;
                if (A.uv.floats[1] > B.uv.floats[1]) return false;
            }
        }

        // At this point, all elements must have compared equal, so A is not
        // less than B.

        return false;
    }
};

    // This STL set holds dynamic vertices.

typedef set<DynVertData, DynVertLess> DynVertSet;




//============================================================================
//===================  V E R T E X   I T E R A T O R S  ======================
//============================================================================




/*****************************************************************************
This is the base class for trimesh vertex iterators, which iterate through the
vertices of a fully-static trimesh.
*****************************************************************************/

class ATL_NO_VTABLE TMVertIterator
{
  public:

    TMVertIterator (TriMeshData &tmdata) : _tm(tmdata) { }
    virtual bool Init (void) = 0;

    virtual void Reset (void) = 0;
    virtual bool NextVert (D3DRMVERTEX &v) = 0;
    virtual bool NextVert (DynVertData &v) = 0;

    void LoadVert (D3DRMVERTEX &v, int ipos, int inorm, int iuv);
    void LoadVert (DynVertData &v, int ipos, int inorm, int iuv);

  protected:

    TriMeshData &_tm;   // Triangle Mesh Data

    int _currTri;       // Current Triangle
    int _currTriVert;   // Current Triangle Vertex
};



/*****************************************************************************
This method loads the referenced static vertex data according to the indices
given for position, normal and UV.
*****************************************************************************/

void TMVertIterator::LoadVert (
    D3DRMVERTEX &v,
    int ipos,
    int inorm,
    int iuv)
{
    // Load up the vertex position.

    ConstParam dummy;

    if (_tm.vPosFloat)
    {
        v.position.x = _tm.vPosFloat [(3*ipos) + 0];
        v.position.y = _tm.vPosFloat [(3*ipos) + 1];
        v.position.z = _tm.vPosFloat [(3*ipos) + 2];
    }
    else
    {
        Point3Value *vpos =
            SAFE_CAST (Point3Value*, _tm.vPosPoint3[ipos]->GetConst(dummy));

        v.position.x = vpos->x;
        v.position.y = vpos->y;
        v.position.z = vpos->z;
    }

    // Load up the vertex normal values.

    if (_tm.vNormFloat)
    {
        v.normal.x = _tm.vNormFloat [(3*inorm) + 0];
        v.normal.y = _tm.vNormFloat [(3*inorm) + 1];
        v.normal.z = _tm.vNormFloat [(3*inorm) + 2];
    }
    else
    {   Vector3Value *vnorm =
            SAFE_CAST (Vector3Value*, _tm.vNormVector3[inorm]->GetConst(dummy));
        v.normal.x = vnorm->x;
        v.normal.y = vnorm->y;
        v.normal.z = vnorm->z;
    }

    // Normalize the normal vector to ensure that it has unit length, but let
    // zero normals pass through as zero vectors.

    const Real lensq = (v.normal.x * v.normal.x)
                     + (v.normal.y * v.normal.y)
                     + (v.normal.z * v.normal.z);

    if ((lensq != 1) && (lensq > 0))
    {
        const Real len = sqrt(lensq);
        v.normal.x /= len;
        v.normal.y /= len;
        v.normal.z /= len;
    }

    // Load up the vertex surface coordinate.

    if (_tm.vUVFloat)
    {
        v.tu = _tm.vUVFloat [(2*iuv) + 0];
        v.tv = _tm.vUVFloat [(2*iuv) + 1];
    }
    else
    {
        Point2Value *vuv =
            SAFE_CAST (Point2Value*, _tm.vUVPoint2[iuv]->GetConst(dummy));

        v.tu = vuv->x;
        v.tv = vuv->y;
    }

    // We need to flip the V coordinate from DA's standard cartesian
    // coordinates (origin lower-left, V increases upwards) to RM's windows
    // coordinates (origin upper-left, V increases downwards).

    v.tv = 1 - v.tv;
}



/*****************************************************************************
This method loads the referenced dynamic vertex data according to the indices
given for position, normal and UV.
*****************************************************************************/

void TMVertIterator::LoadVert (
    DynVertData &v,
    int ipos,
    int inorm,
    int iuv)
{
    // Load up the vertex position.

    ConstParam dummy;

    if (_tm.vPosPoint3)
    {
        // We know that this position is given as a behavior, but it may be
        // a constant behavior.  If it's not constant, load the data as a
        // behavior, otherwise load the vertex's constant value (as floats).

        Point3Value *vpos =
            SAFE_CAST (Point3Value*, _tm.vPosPoint3[ipos]->GetConst(dummy));

        if (!vpos)
        {   v.isBvrPos = true;
            v.pos.bvr = _tm.vPosPoint3[ipos];
        }
        else
        {   v.isBvrPos = false;
            v.pos.floats[0] = vpos->x;
            v.pos.floats[1] = vpos->y;
            v.pos.floats[2] = vpos->z;
        }
    }
    else
    {
        v.isBvrPos = false;
        v.pos.floats[0] = _tm.vPosFloat [(3*ipos) + 0];
        v.pos.floats[1] = _tm.vPosFloat [(3*ipos) + 1];
        v.pos.floats[2] = _tm.vPosFloat [(3*ipos) + 2];
    }

    // Load up the vertex normal.

    if (_tm.vNormVector3)
    {
        // This normal is given as a behavior, but it may be constant.  If it's
        // not constant, load the normal behavior, otherwise load the normal's
        // constant value (as floats).

        Vector3Value *vnorm =
            SAFE_CAST (Vector3Value*, _tm.vNormVector3[inorm]->GetConst(dummy));

        if (!vnorm)
        {   v.isBvrNorm = true;
            v.norm.bvr = _tm.vNormVector3[inorm];
        }
        else
        {   v.isBvrNorm = false;
            v.norm.floats[0] = vnorm->x;
            v.norm.floats[1] = vnorm->y;
            v.norm.floats[2] = vnorm->z;
        }
    }
    else
    {
        v.isBvrNorm = false;
        v.norm.floats[0] = _tm.vNormFloat [(3*inorm) + 0];
        v.norm.floats[1] = _tm.vNormFloat [(3*inorm) + 1];
        v.norm.floats[2] = _tm.vNormFloat [(3*inorm) + 2];
    }

    // If the normal vector is constant, then normalize here to unit length.
    // Keep zero normal vectors as zero normal vectors.

    if (!v.isBvrNorm)
    {
        const Real lensq = (v.norm.floats[0] * v.norm.floats[0])
                         + (v.norm.floats[1] * v.norm.floats[1])
                         + (v.norm.floats[2] * v.norm.floats[2]);

        if ((lensq != 1) && (lensq > 0))
        {
            const Real len = sqrt(lensq);
            v.norm.floats[0] /= len;
            v.norm.floats[1] /= len;
            v.norm.floats[2] /= len;
        }
    }

    // Load up the vertex surface coordinate.

    if (_tm.vUVPoint2)
    {
        // This UV is a behavior, but it may be constant.  If it's not
        // constant, load the UV behavior, otherwise load the UV's constant
        // value (as floats).

        Point2Value *vuv =
            SAFE_CAST (Point2Value*, _tm.vUVPoint2[iuv]->GetConst(dummy));

        if (!vuv)
        {   v.isBvrUV = true;
            v.uv.bvr = _tm.vUVPoint2[iuv];
        }
        else
        {   v.isBvrUV = false;
            v.uv.floats[0] = vuv->x;
            v.uv.floats[1] = vuv->y;
        }
    }
    else
    {
        v.isBvrUV = false;
        v.uv.floats[0] = _tm.vUVFloat [(2*iuv) + 0];
        v.uv.floats[1] = _tm.vUVFloat [(2*iuv) + 1];
    }

    // For static UV values, flip the V coordinate to convert from DA's
    // standard cartesian coordinates (origin lower-left, V increasing upwards)
    // to RM's windows coordinates (origin upper-left, V increasing downwards).

    if (!v.isBvrUV)
    {
        v.uv.floats[1] = 1 - v.uv.floats[1];
    }
}



/*****************************************************************************
This trimesh vertex iterator works on non-indexed trimeshes.
*****************************************************************************/

class TMVertIteratorNonIndexed : public TMVertIterator
{
  public:

    TMVertIteratorNonIndexed (TriMeshData &tmdata);
    bool Init (void);

    void Reset (void);
    bool NextVert (D3DRMVERTEX &v);
    bool NextVert (DynVertData &v);

  private:

    void IncrementVert (void);

    int _currVert;      // Current Vertex
};



TMVertIteratorNonIndexed::TMVertIteratorNonIndexed (TriMeshData &tmdata)
    : TMVertIterator(tmdata)
{
    Reset();
}



bool TMVertIteratorNonIndexed::Init (void)
{
    return true;
}


void TMVertIteratorNonIndexed::Reset (void)
{
    _currTri  = 0;
    _currVert = 0;
    _currTriVert  = 0;
}



/*****************************************************************************
This method increments the vertex index.
*****************************************************************************/

void TMVertIteratorNonIndexed::IncrementVert (void)
{
    // Increment the TriMesh vertex and the triangle vertex number.
    // Increment the triangle counter if the previous vertex was a third
    // triangle vertex.

    ++ _currVert;
    ++ _currTriVert;

    if (_currTriVert >= 3)
    {
        _currTriVert = 0;
        ++ _currTri;
    }
}




/*****************************************************************************
This method gets the next static vertex of the non-indexed trimesh.
*****************************************************************************/

bool TMVertIteratorNonIndexed::NextVert (D3DRMVERTEX &v)
{
    Assert (_currTri < _tm.numTris);

    LoadVert (v, _currVert, _currVert, _currVert);

    IncrementVert();

    return true;
}



/*****************************************************************************
This method gets the next dynamic vertex of the non-indexed trimesh.
*****************************************************************************/

bool TMVertIteratorNonIndexed::NextVert (DynVertData &v)
{
    Assert (_currTri < _tm.numTris);

    LoadVert (v, _currVert, _currVert, _currVert);

    IncrementVert();

    return true;
}



/*****************************************************************************
This trimesh vertex iterator works on static indexed triangle meshes.
*****************************************************************************/

class TMVertIteratorIndexed : public TMVertIterator
{
  public:

    TMVertIteratorIndexed (TriMeshData &tmdata);
    bool Init (void);

    void Reset (void);
    bool NextVert (D3DRMVERTEX &v);
    bool NextVert (DynVertData &v);

  private:

    bool GetIndices (int &ipos, int &inorm, int &iuv);
    void IncrementVert (void);

    int _posIndex;     // Index for Vertex Position Index
    int _posStride;    // Stride for Position Indices
    int _posIMax;      // Maximum Valid Index for Positions

    int _normIndex;    // Index for Vertex Normal Index
    int _normStride;   // Stride for Normal Indices
    int _normIMax;     // Maximum Valid Index for Normals

    int _uvIndex;      // Index for Vertex UV Index
    int _uvStride;     // Stride for UV Indices
    int _uvIMax;       // Maximum Valid Index for UVs
};



/*****************************************************************************
*****************************************************************************/

TMVertIteratorIndexed::TMVertIteratorIndexed (TriMeshData &tmdata)
    : TMVertIterator(tmdata)
{
}



/*****************************************************************************
*****************************************************************************/

bool TMVertIteratorIndexed::Init (void)
{
    if (_tm.numIndices < 7)
    {   DASetLastError (E_FAIL, IDS_ERR_GEO_TMESH_MIN_INDICES);
        return false;
    }

    // Set up the index strides.

    _posStride  = _tm.indices[1];
    _normStride = _tm.indices[3];
    _uvStride   = _tm.indices[5];

    // Set up max valid index.  This is the last legal index of the start
    // of the last vertex data.

    _posIMax  = _tm.numPos  - ((_tm.vPosPoint3)   ? 1 : 3);
    _normIMax = _tm.numNorm - ((_tm.vNormVector3) ? 1 : 3);
    _uvIMax   = _tm.numUV   - ((_tm.vUVPoint2)    ? 1 : 2);

    Reset();

    return true;
}



void TMVertIteratorIndexed::Reset (void)
{
    _currTri     = 0;
    _currTriVert = 0;

    _posIndex   = _tm.indices[0];
    _normIndex  = _tm.indices[2];
    _uvIndex    = _tm.indices[4];
}



/*****************************************************************************
This method gets the next indices for the vertex properties (position, normal,
UV), based on the index array and the specified step/stride offsets.
*****************************************************************************/

bool TMVertIteratorIndexed::GetIndices (int &ipos, int &inorm, int &iuv)
{
    // Validate Vertex Position Indices

    if ((_posIndex < 0) || (_tm.numIndices <= _posIndex))
    {
        char arg[32];
        wsprintf (arg, "%d", _posIndex);

        DASetLastError (E_FAIL, IDS_ERR_GEO_TMESH_OOB_PINDEX, arg);
        return false;
    }

    ipos = _tm.indices[_posIndex];

    if ((ipos < 0) || (_posIMax < ipos))
    {
        char arg[32];
        wsprintf (arg, "%d", ipos);

        DASetLastError (E_FAIL, IDS_ERR_GEO_TMESH_BAD_PINDEX, arg);
        return false;
    }

    // Validate Vertex Normal Indices

    if ((_normIndex < 0) || (_tm.numIndices <= _normIndex))
    {
        char arg[32];
        wsprintf (arg, "%d", _normIndex);

        DASetLastError (E_FAIL, IDS_ERR_GEO_TMESH_OOB_NINDEX, arg);
        return false;
    }

    inorm = _tm.indices[_normIndex];

    if ((inorm < 0) || (_normIMax < inorm))
    {
        char arg[32];
        wsprintf (arg, "%d", inorm);

        DASetLastError (E_FAIL, IDS_ERR_GEO_TMESH_BAD_NINDEX, arg);
        return false;
    }

    // Validate Vertex UV Indices

    if ((_uvIndex < 0) || (_tm.numIndices <= _uvIndex))
    {
        char arg[32];
        wsprintf (arg, "%d", _uvIndex);

        DASetLastError (E_FAIL, IDS_ERR_GEO_TMESH_OOB_UINDEX, arg);
        return false;
    }

    iuv = _tm.indices[_uvIndex];

    if ((iuv < 0) || (_uvIMax < iuv))
    {
        char arg[32];
        wsprintf (arg, "%d", iuv);

        DASetLastError (E_FAIL, IDS_ERR_GEO_TMESH_BAD_UINDEX, arg);
        return false;
    }

    return true;
}



/*****************************************************************************
This method increments the vertex property indices.
*****************************************************************************/

void TMVertIteratorIndexed::IncrementVert (void)
{
    // Increment the TriMesh vertex and the triangle vertex number.
    // Increment the triangle counter if the previous vertex was a third
    // triangle vertex.

    ++ _currTriVert;

    if (_currTriVert >= 3)
    {
        _currTriVert = 0;
        ++ _currTri;
    }

    _posIndex  += _posStride;
    _normIndex += _normStride;
    _uvIndex   += _uvStride;
}



/*****************************************************************************
This method fetches the next static vertex of the indexed trimesh.
*****************************************************************************/

bool TMVertIteratorIndexed::NextVert (D3DRMVERTEX &v)
{
    Assert (_currTri < _tm.numTris);

    int ipos, inorm, iuv;

    if (!GetIndices (ipos, inorm, iuv))
        return false;

    LoadVert (v, ipos, inorm, iuv);

    IncrementVert();

    return true;
}



/*****************************************************************************
This method fetches the next dynamic vertex of the indexed trimesh.  It
returns true if it successfully did it.
*****************************************************************************/

bool TMVertIteratorIndexed::NextVert (DynVertData &v)
{
    Assert (_currTri < _tm.numTris);

    int ipos, inorm, iuv;

    if (!GetIndices (ipos,inorm,iuv))
        return false;

    LoadVert (v, ipos, inorm, iuv);

    IncrementVert();

    return true;
}



/*****************************************************************************
This method returns a new vertex iterator appropriate to the indexing of the
given trimesh data.
*****************************************************************************/

TMVertIterator* NewTMVertIterator (TriMeshData &tm)
{
    TMVertIterator *tmviterator;

    if (tm.numIndices && tm.indices)
        tmviterator = NEW TMVertIteratorIndexed (tm);
    else
        tmviterator = NEW TMVertIteratorNonIndexed (tm);

    if (!tmviterator)
        DASetLastError (E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY);
    else if (!tmviterator->Init())
        tmviterator = NULL;

    return tmviterator;
}




//============================================================================
//===========  T R I M E S H   B E H A V I O R   M E T H O D S  ==============
//============================================================================



/*****************************************************************************
The constructor for the TriMeshBvrImpl trivially initializes the device.  The
Init() method must be invoked (and the return value checked) to activate the
object.
*****************************************************************************/

TriMeshBvrImpl::TriMeshBvrImpl (void)
    : _mesh (NULL),
      _verts (NULL),
      _nVerts (0),
      _vPosBvr (NULL),
      _vNormBvr(NULL),
      _vUVBvr  (NULL),
      _constPerf (NULL),
      _fullyStatic (true),
      _posStatic (true),
      _normStatic (true),
      _uvStatic (true)
{
}

bool TriMeshBvrImpl::Init (TriMeshData &tmdata)
{
    if (!ValidateParams (tmdata))
        return false;

    // Check to see if all vertex properties are constant.

    ConstParam dummy;

    if (tmdata.vPosPoint3)
    {
        int i = tmdata.numPos;
        while (i--)
        {
            if (!tmdata.vPosPoint3[i]->GetConst(dummy))
            {
                _fullyStatic = false;
                _posStatic = false;
                i=0;
            }
        }
    }

    if (tmdata.vNormVector3)
    {
        int i = tmdata.numNorm;
        while (i--)
        {
            if (!tmdata.vNormVector3[i]->GetConst(dummy))
            {
                _fullyStatic = false;
                _normStatic = false;
                i=0;
            }
        }
    }

    if (tmdata.vUVPoint2)
    {
        int i = tmdata.numUV;
        while (i--)
        {
            if (!tmdata.vUVPoint2[i]->GetConst(dummy))
            {
                _fullyStatic = false;
                _uvStatic = false;
                i=0;
            }
        }
    }

    if (_fullyStatic)
    {
        if (!BuildStaticMesh (tmdata))
            return false;

        Geometry *geo;

        if (GetD3DRM3())
        {
            RM3MBuilderGeo *mbgeo;

            geo = mbgeo = NEW RM3MBuilderGeo(_mesh);

            if (!geo)
            {   DASetLastError (E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY);
                return false;
            }

            // Invoke RM optimization on fully-static meshbuilder.

            mbgeo->Optimize();
        }
        else
        {
            geo = NEW RM1MeshGeo(_mesh);

            if (!geo)
            {   DASetLastError (E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY);
                return false;
            }
        }

        _constPerf = ConstPerf (geo);
    }
    else
    {
        if (!SetupDynamicMesh (tmdata))
            return false;
    }

    return true;
}



/*****************************************************************************
The destruction and cleanup of a TriMeshBvrImpl are both related, and CleanUp
implements the actual cleanup of the TriMeshBvrImpl resources.
*****************************************************************************/

TriMeshBvrImpl::~TriMeshBvrImpl (void)
{
    CleanUp();
}

void TriMeshBvrImpl::CleanUp (void)
{
    if (_mesh)
    {   _mesh->Release();
        _mesh = NULL;
    }

    if (_verts)
    {   delete [] _verts;
        _verts = NULL;
    }

    if (_vPosBvr)
    {   delete [] _vPosBvr;
        _vPosBvr = NULL;
    }

    if (_vNormBvr)
    {   delete [] _vNormBvr;
        _vNormBvr = NULL;
    }

    if (_vUVBvr)
    {   delete [] _vUVBvr;
        _vUVBvr = NULL;
    }
}



/*****************************************************************************
This method claims garbage-collected objects as still in-use.
*****************************************************************************/

void TriMeshBvrImpl::_DoKids (GCFuncObj procedure)
{
    // Mark all time-varying vertex properties as used.

    unsigned int i;

    if (_vPosBvr)
    {
        for (i=0;  i < _nVerts;  ++i)
            if (_vPosBvr[i])
                (*procedure) (_vPosBvr[i]);
    }

    if (_vNormBvr)
    {
        for (i=0;  i < _nVerts;  ++i)
            if (_vNormBvr[i])
                (*procedure) (_vNormBvr[i]);
    }

    if (_vUVBvr)
    {
        for (i=0;  i < _nVerts;  ++i)
            if (_vUVBvr[i])
                (*procedure) (_vUVBvr[i]);
    }

    (*procedure) (_constPerf);
}



/*****************************************************************************
This method returns the type info for a TriMeshBvrImpl.
*****************************************************************************/

DXMTypeInfo TriMeshBvrImpl::GetTypeInfo (void)
{
    return GeometryType;
}



/*****************************************************************************
This method builds a fully-static triangle mesh.  It returns true if it
succeeded.
*****************************************************************************/

bool TriMeshBvrImpl::BuildStaticMesh (TriMeshData &tmdata)
{
    TMVertIterator *tmviterator = NewTMVertIterator (tmdata);

    if (!tmviterator) return false;

    // Allocate memory for the trimesh face data.

    unsigned int *fdata = THROWING_ARRAY_ALLOCATOR
                          (unsigned int, 3*tmdata.numTris);

    VertSet       vset;                        // Unique Vertex Set
    unsigned int  vcount   = 0;                // Vertex Counter
    unsigned int *fdptr    = fdata;            // Face Data Traversal Pointer
    unsigned int  trisleft = tmdata.numTris;   // Number of Triangles Remaining
    bool          dx3      = !GetD3DRM3();

    while (trisleft)
    {
        using std::pair;

        // Set Insertion Result
        pair<set<D3DRMVERTEX, RMVertLess>::iterator, bool> vsetResult;

        D3DRMVERTEX rmvert;    // RM Vertex

        // Add each of the three vertices for the current face.

        int i;

        for (i=0;  i < 3;  ++i)
        {
            // Get the next vertex from the iterator.  If this fails, then
            // something's wrong with the given data.

            if (!tmviterator->NextVert (rmvert))
                return false;

            // Try to insert the current vertex into the vertex set.  Note that
            // we overload the otherwise unused DWORD color field of the RM
            // vertex to hold the vertex index.

            rmvert.color = vcount;

            vsetResult = vset.insert (rmvert);

            if (!vsetResult.second)
            {
                // If the insertion failed (because of a collision with an
                // identical vertex already in the set), then use the ID of
                // the already existing vertex.

                *fdptr = (vsetResult.first)->color;
            }
            else
            {
                // If the insertion succeeded, then no other vertex in the set
                // had the same data.

                *fdptr = vcount;
                ++ vcount;
            }

            // Increment the face-data pointer to hold the next vertex id.

            ++fdptr;
        }

        // If we're on DX3, then we need clockwise vertex orientation, so flip
        // the last two vertices of the previous triangle.

        if (dx3)
        {
            const int temp = fdptr[-2];
            fdptr[-2] = fdptr[-1];
            fdptr[-1] = temp;
        }

        -- trisleft;
    }

    // Done with the trimesh vertex iterator; release it.

    delete tmviterator;

    // Ensure that we wrote as many vertex indices as we expected.

    Assert ((fdptr - fdata) == (tmdata.numTris * 3));

    // Ensure that the vertex set holds as many vertices as we expect.

    Assert (vset.size() == vcount);

    // Create the RM mesh.

    TD3D (GetD3DRM1()->CreateMesh (&_mesh));

    // Add the trimesh face data to the mesh.

    D3DRMGROUPINDEX resultIndex;

    TD3D (_mesh->AddGroup (vcount, static_cast<unsigned> (tmdata.numTris),
                           3, fdata, &resultIndex));

    Assert (resultIndex == 0);    // Expect that this is the only group.

    // Done with the face data; delete it.

    delete [] fdata;

    // Now allocate and populate the vertex buffer.

    D3DRMVERTEX *rmvdata = THROWING_ARRAY_ALLOCATOR (D3DRMVERTEX, vcount);

    VertSet::iterator vseti = vset.begin();

    while (vseti != vset.end())
    {
        const int i = (*vseti).color;
        rmvdata[i] = (*vseti);
        rmvdata[i].color = 0;

        ++ vseti;
    }

    // Set the vertex data on the RM mesh.

    TD3D (_mesh->SetVertices (resultIndex, 0, vcount, rmvdata));

    // Done with the vertex data; delete it.

    delete [] rmvdata;

    return true;
}



/*****************************************************************************
This method sets up a dynamic mesh behavior for subsequent sampling via the
Perform() method on the TriMeshBvr.  It will collapse the vertex set as much
as possible, generate the final mesh topology, and keep track of the vertex
property behaviors for subsequent sampling.  Note that TriMesh performances
will have a reference to the TriMesh behavior that spawned them, and will use
many of the member fields of the TriMesh behavior object.  Also note that this
process assumes that no TriMesh performance will be sampled at the same time
as another TriMesh performance based on the same TriMesh behavior.  This
method returns true if it succeeded.
*****************************************************************************/

bool TriMeshBvrImpl::SetupDynamicMesh (TriMeshData &tmdata)
{
    TMVertIterator *tmviterator = NewTMVertIterator (tmdata);

    if (!tmviterator) return false;

    // Allocate memory for the trimesh face data.

    unsigned int *fdata = THROWING_ARRAY_ALLOCATOR
                          (unsigned int, 3*tmdata.numTris);

    // Traverse all triangles in the trimesh, collecting up the vertices into
    // a set of unique vertices, and building RM mesh topology as we go.

    DynVertSet    vset;                        // Unique Vertex Set
    unsigned int  vcount   = 0;                // Vertex Counter
    unsigned int *fdptr    = fdata;            // Face Data Traversal Pointer
    unsigned int  trisleft = tmdata.numTris;   // Number of Triangles Remaining
    bool          dx3      = !GetD3DRM3();

    while (trisleft)
    {
        using std::pair;

        // Set Insertion Result
        pair<set<DynVertData, DynVertLess>::iterator, bool> vsetResult;

        DynVertData vert;    // RM Vertex

        // Add each of the three vertices for the current face.

        int i;

        for (i=0;  i < 3;  ++i)
        {
            // Get the next vertex from the iterator.  If this fails, then
            // something's wrong with the given data.

            if (!tmviterator->NextVert (vert))
                return false;

            // Try to insert the current vertex into the vertex set.

            vert.index = vcount;

            vsetResult = vset.insert (vert);

            if (!vsetResult.second)
            {
                // If the insertion failed (because of a collision with an
                // identical vertex already in the set), then use the index of
                // the already existing vertex.

                *fdptr = (vsetResult.first)->index;
            }
            else
            {
                // If the insertion succeeded, then no other vertex in the set
                // had the same data.

                *fdptr = vcount;
                ++ vcount;
            }

            // Increment the face-data pointer to hold the next vertex id.

            ++fdptr;
        }

        // If we're on DX3, then we need clockwise vertex orientation, so flip
        // the last two vertices of the previous triangle.

        if (dx3)
        {
            const int temp = fdptr[-2];
            fdptr[-2] = fdptr[-1];
            fdptr[-1] = temp;
        }

        -- trisleft;
    }

    // Done with the trimesh vertex iterator; release it.

    delete tmviterator;

    // Ensure that we wrote as many vertex indices as we expected.

    Assert ((fdptr - fdata) == (tmdata.numTris * 3));

    // Ensure that the vertex set holds as many vertices as we expect.

    _nVerts = vset.size();

    Assert (_nVerts == vcount);

    // Create the RM mesh.

    TD3D (GetD3DRM1()->CreateMesh (&_mesh));

    // Add the trimesh face data to the mesh.

    D3DRMGROUPINDEX resultIndex;

    TD3D (_mesh->AddGroup (vcount, static_cast<unsigned> (tmdata.numTris),
                           3, fdata, &resultIndex));

    Assert (resultIndex == 0);    // Expect that this is the only group.

    // Done with the face data; delete it.

    delete [] fdata;

    // Allocate the array of RM vertices we'll use to update the vertex values.

    _verts = THROWING_ARRAY_ALLOCATOR (D3DRMVERTEX, _nVerts);

    // At this point, we need to set everything up for the dynamic properties
    // of the trimesh vertex data.  Allocate behavior arrays for those
    // properties that contain dynamic elements (that are not fully static)

    if (!_posStatic)   _vPosBvr  = THROWING_ARRAY_ALLOCATOR (Bvr, _nVerts);
    if (!_normStatic)  _vNormBvr = THROWING_ARRAY_ALLOCATOR (Bvr, _nVerts);
    if (!_uvStatic)    _vUVBvr   = THROWING_ARRAY_ALLOCATOR (Bvr, _nVerts);

    // Write out all of the static vertex property values to the D3DRMVERTEX
    // array, and load up the vertex behavior arrays.

    DynVertSet::iterator vi;

    for (vi=vset.begin();  vi != vset.end();  ++vi)
    {
        const DynVertData &v = (*vi);
        const int index = v.index;

        if (v.isBvrPos)
            _vPosBvr[index] = v.pos.bvr;
        else
        {
            if (_vPosBvr)
                _vPosBvr[index] = NULL;

            _verts[index].position.x = v.pos.floats[0];
            _verts[index].position.y = v.pos.floats[1];
            _verts[index].position.z = v.pos.floats[2];
        }

        if (v.isBvrNorm)
            _vNormBvr[index] = v.norm.bvr;
        else
        {
            if (_vNormBvr)
                _vNormBvr[index] = NULL;

            _verts[index].normal.x = v.norm.floats[0];
            _verts[index].normal.y = v.norm.floats[1];
            _verts[index].normal.z = v.norm.floats[2];
        }

        if (v.isBvrUV)
            _vUVBvr[index] = v.uv.bvr;
        else
        {
            if (_vUVBvr)
                _vUVBvr[index] = NULL;

            _verts[index].tu = v.uv.floats[0];
            _verts[index].tv = v.uv.floats[1];
        }

        _verts[index].color = 0;
    }

    return true;
}



/*****************************************************************************
This routine is used to validate the incoming TriMesh parameters as much as
possible.  TriMesh should be pretty much bulletproof with respect to parameter
handling.
*****************************************************************************/

bool TriMeshBvrImpl::ValidateParams (TriMeshData &tm)
{
    // Ensure that the number of triangles is valid, and that the number of
    // vertex elements for each datatype is non-zero.

    if ((tm.numTris<1) || (tm.numPos<1) || (tm.numNorm<1) || (tm.numUV<1))
    {   DASetLastError (E_INVALIDARG, IDS_ERR_INVALIDARG);
        return false;
    }

    // Make sure we've got vertex data.

    if (  ((!tm.vPosFloat)  && (!tm.vPosPoint3))
       || ((!tm.vNormFloat) && (!tm.vNormVector3))
       || ((!tm.vUVFloat)   && (!tm.vUVPoint2))
       )
    {
        DASetLastError (E_INVALIDARG, IDS_ERR_INVALIDARG);
        return false;
    }

    // If the trimesh is unindexed, then make sure that we have the expected
    // number of vertex elements.

    if (tm.numIndices == 0)
    {
        // For non-indexed trimeshes, we expect a list of 3*nTris vertex
        // elements.

        const int nVerts = 3 * tm.numTris;

        // Calculate the number of data elements for the given number of
        // triangles.  This is either n floats or 1 DA behavior per vertex.

        const int posEltsMin  = nVerts * ((tm.vPosFloat  != 0) ? 3 : 1);
        const int normEltsMin = nVerts * ((tm.vNormFloat != 0) ? 3 : 1);
        const int uvEltsMin   = nVerts * ((tm.vUVFloat   != 0) ? 2 : 1);

        // Validate vertex data array sizes.

        if (tm.numPos < posEltsMin)
        {
            char arg1[32], arg2[32], arg3[32];
            wsprintf (arg1, "%d", tm.numPos);
            wsprintf (arg2, "%d", tm.numTris);
            wsprintf (arg3, "%d", posEltsMin);

            DASetLastError
                (E_INVALIDARG, IDS_ERR_GEO_TMESH_MIN_POS, arg1,arg2,arg3);

            return false;
        }

        if (tm.numNorm < normEltsMin)
        {
            char arg1[32], arg2[32], arg3[32];
            wsprintf (arg1, "%d", tm.numNorm);
            wsprintf (arg2, "%d", tm.numTris);
            wsprintf (arg3, "%d", normEltsMin);

            DASetLastError
                (E_INVALIDARG, IDS_ERR_GEO_TMESH_MIN_NORM, arg1,arg2,arg3);

            return false;
        }

        if (tm.numUV < uvEltsMin)
        {
            char arg1[32], arg2[32], arg3[32];
            wsprintf (arg1, "%d", tm.numUV);
            wsprintf (arg2, "%d", tm.numTris);
            wsprintf (arg3, "%d", uvEltsMin);

            DASetLastError
                (E_INVALIDARG, IDS_ERR_GEO_TMESH_MIN_UV, arg1,arg2,arg3);

            return false;
        }
    }
    else
    {
        // If the trimesh has an indices block, then you need at least the
        // three step-stride pairs, plus at least one index.

        if (tm.numIndices <= 6)
        {
            DASetLastError (E_INVALIDARG, IDS_ERR_GEO_TMESH_MIN_INDICES);
            return false;
        }
    }

    return true;
}



/*****************************************************************************
*****************************************************************************/

AxAValue TriMeshBvrImpl::GetConst (ConstParam&)
{
    if (_fullyStatic)
    {   
        return GetPerfConst(_constPerf);
    }

    return NULL;
}



/*****************************************************************************
*****************************************************************************/

Perf TriMeshBvrImpl::_Perform (PerfParam &perfdata)
{
    if (_fullyStatic)
        return _constPerf;

    TriMeshPerfImpl *tmperf = NEW TriMeshPerfImpl (*this);

    if (!tmperf)
    {
        DASetLastError (E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY);
    }
    else if (!tmperf->Init(perfdata))
    {
        tmperf->CleanUp();
        tmperf = NULL;
    }

    return tmperf;
}



/*****************************************************************************
This is the generator function for TriMesh behaviors.
*****************************************************************************/

Bvr TriMeshBvr (TriMeshData &tm)
{
    TriMeshBvrImpl *tmesh = NEW TriMeshBvrImpl();

    if (!tmesh)
    {
        DASetLastError (E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY);
    }
    else if (!tmesh->Init(tm))
    {
        tmesh->CleanUp();
        tmesh = NULL;
    }

    return tmesh;
}




//============================================================================
//========  T R I M E S H   P E R F O R M A N C E   M E T H O D S  ===========
//============================================================================



/*****************************************************************************
TriMesh Performance Constructor:  This just does trivial construction; the
Init function is used to activate this object.
*****************************************************************************/

TriMeshPerfImpl::TriMeshPerfImpl (TriMeshBvrImpl &tmbvr)
    : _tmbvr (tmbvr),
      _vPos (NULL),
      _vNorm (NULL),
      _vUV (NULL),
      _mesh (NULL),
      _meshgeo (NULL),
      _mbgeo (NULL)
{
}


bool TriMeshPerfImpl::Init (PerfParam &perfdata)
{
    // Allocate arrays of vertex property performances for those properties
    // that are time-varying.

    if (_tmbvr._vPosBvr)
    {
        _vPos = THROWING_ARRAY_ALLOCATOR (Perf, _tmbvr._nVerts);

        unsigned int i;
        for (i=0;  i < _tmbvr._nVerts;  ++i)
        {
            const Bvr bvr = _tmbvr._vPosBvr[i];

            if (bvr)
                _vPos[i] = bvr->Perform (perfdata);
            else
                _vPos[i] = NULL;
        }
    }

    if (_tmbvr._vNormBvr)
    {
        _vNorm = THROWING_ARRAY_ALLOCATOR (Perf, _tmbvr._nVerts);

        unsigned int i;
        for (i=0;  i < _tmbvr._nVerts;  ++i)
        {
            const Bvr bvr = _tmbvr._vNormBvr[i];

            if (bvr)
                _vNorm[i] = bvr->Perform (perfdata);
            else
                _vNorm[i] = NULL;
        }
    }

    if (_tmbvr._vUVBvr)
    {
        _vUV = THROWING_ARRAY_ALLOCATOR (Perf, _tmbvr._nVerts);

        unsigned int i;
        for (i=0;  i < _tmbvr._nVerts;  ++i)
        {
            const Bvr bvr = _tmbvr._vUVBvr[i];

            if (bvr)
                _vUV[i] = bvr->Perform (perfdata);
            else
                _vUV[i] = NULL;
        }
    }

    // Clone the mesh from the spawning trimesh behavior to get the topology.

    IUnknown *mesh_unknown;
    TD3D (_tmbvr._mesh->QueryInterface (IID_IUnknown, (void**)&mesh_unknown));

    TD3D (_tmbvr._mesh->Clone
             (mesh_unknown, IID_IDirect3DRMMesh, (void**)&_mesh));

    return true;
}



/*****************************************************************************
The destruction and cleanup of a TriMeshPerfImpl are both related, and CleanUp
implements the actual cleanup of the TriMeshPerfImpl resources.
*****************************************************************************/


TriMeshPerfImpl::~TriMeshPerfImpl (void)
{
    CleanUp();
}

void TriMeshPerfImpl::CleanUp (void)
{
    if (_vPos)
    {   delete [] _vPos;
        _vPos = NULL;
    }

    if (_vNorm)
    {   delete [] _vNorm;
        _vNorm = NULL;
    }

    if (_vUV)
    {   delete [] _vUV;
        _vUV = NULL;
    }

    if (_mesh)
    {   _mesh->Release();
        _mesh = NULL;
    }
}



/*****************************************************************************
This method claims all AxAValueObj objects as in-use, so they aren't discarded
from the transient heap.
*****************************************************************************/

void TriMeshPerfImpl::_DoKids (GCFuncObj procedure)
{
    // First claim the TriMeshBvr that spawned us.

    (*procedure) (&_tmbvr);

    // Claim all vertex property performances.

    unsigned int i;   // Performance Index

    if (_vPos)
    {
        for (i=0;  i < _tmbvr._nVerts;  ++i)
            if (_vPos[i])
                (*procedure) (_vPos[i]);
    }

    if (_vNorm)
    {
        for (i=0;  i < _tmbvr._nVerts;  ++i)
            if (_vNorm[i])
                (*procedure) (_vNorm[i]);
    }

    if (_vUV)
    {
        for (i=0;  i < _tmbvr._nVerts;  ++i)
            if (_vUV[i])
                (*procedure) (_vUV[i]);
    }

    (*procedure) (_meshgeo);
    (*procedure) (_mbgeo);
}



/*****************************************************************************
This method samples the dynamic trimesh for a given time and returns the
geometry that represents the current value.  Note that this works with the
assumption that trimesh performances of the same trimesh behavior will not
be sampled simultaneously.
*****************************************************************************/

AxAValue TriMeshPerfImpl::_Sample (Param &sampledata)
{
    // Sample vertex positions if they're dynamic.

    unsigned int i;
    D3DRMVERTEX *rmvert;

    if (_vPos)
    {
        Perf *posperf = _vPos;

        rmvert = _tmbvr._verts;

        for (i=0;  i < _tmbvr._nVerts;  ++i)
        {
            if (*posperf)
            {
                Point3Value *posvalue =
                    SAFE_CAST (Point3Value*, (*posperf)->Sample(sampledata));

                rmvert->position.x = posvalue->x;
                rmvert->position.y = posvalue->y;
                rmvert->position.z = posvalue->z;
            }

            ++ posperf;
            ++ rmvert;
        }
    }

    // Sample vertex normals if they're dynamic.  We also need to normalize the
    // normal vectors to ensure they're unit length.

    if (_vNorm)
    {
        Perf *normperf = _vNorm;

        rmvert = _tmbvr._verts;

        for (i=0;  i < _tmbvr._nVerts;  ++i)
        {
            if (*normperf)
            {
                Vector3Value *normvalue =
                    SAFE_CAST (Vector3Value*, (*normperf)->Sample(sampledata));

                const Real lensq = normvalue->LengthSquared();

                if ((lensq != 1) && (lensq > 0))
                {
                    const Real len = sqrt (lensq);
                    rmvert->normal.x = normvalue->x / len;
                    rmvert->normal.y = normvalue->y / len;
                    rmvert->normal.z = normvalue->z / len;
                }
                else
                {
                    rmvert->normal.x = normvalue->x;
                    rmvert->normal.y = normvalue->y;
                    rmvert->normal.z = normvalue->z;
                }
            }

            ++ normperf;
            ++ rmvert;
        }
    }

    // Sample vertex surface coordinates if they're dynamic.  Note that DA's
    // surface coordinates are standard cartesian (origin lower-left,
    // V increasing upwards), while RM's surface coordinates mirror windows
    // (origin upper-left, increasing downwards).  Thus, we flip the V
    // coordinate when we sample.

    if (_vUV)
    {
        Perf *uvperf = _vUV;

        rmvert = _tmbvr._verts;

        for (i=0;  i < _tmbvr._nVerts;  ++i)
        {
            if (*uvperf)
            {
                Point2Value *uvvalue =
                    SAFE_CAST (Point2Value*, (*uvperf)->Sample(sampledata));

                rmvert->tu =     uvvalue->x;
                rmvert->tv = 1 - uvvalue->y;
            }

            ++ uvperf;
            ++ rmvert;
        }
    }

    // Now that we've updated all of the dynamic elements for the RM vertices,
    // update the vertices in the RM mesh.

    TD3D (_mesh->SetVertices(0, 0, _tmbvr._nVerts, _tmbvr._verts));

    // Normally, we'll be sampled on the transient heap, so it's safe to side-
    // effect the underlying mesh.  However, if we're being snapshotted, we
    // need to return a new mesh that isn't changed by side-effect (subsequent
    // samples).  If we're not transient (i.e. we need a persistent value),
    // we clone the mesh here.

    AxAValueObj *result;

    if (GetHeapOnTopOfStack().IsTransientHeap())
    {
        // Since we're on the transient heap, it's safe to side-effect the
        // result value (this performance won't be kept across frames).  Thus
        // we can just return the updated/side-effected RMVisualGeo result.

        if (GetD3DRM3())
        {
            // Use the existing RM3MeshBuilderGeo if we've got one, otherwise
            // create one for the first time.

            if (_mbgeo)
                _mbgeo->Reset (_mesh);
            else
            {
                DynamicHeapPusher dhp (GetGCHeap());
               _mbgeo = NEW RM3MBuilderGeo (_mesh);
            }

            result = _mbgeo;
        }
        else
        {
            // If we haven't yet wrapped the underlying mesh in the RM1MeshGeo
            // object, wrap it here.  Changes to the underlying mesh will
            // transparently manifest themselves in the wrapped object.

            if (_meshgeo)
            {
                _meshgeo->MeshGeometryChanged();
            }
            else
            {
                DynamicHeapPusher dhp (GetGCHeap());
                _meshgeo = NEW RM1MeshGeo (_mesh);
            }

            result = _meshgeo;
        }
    }
    else
    {
        // We're not on the transient heap, so the returned value must be
        // persistent (and not side-effected).  This will happen when the
        // performance is being snapshotted, for example.  In this case, we
        // must return a new mesh result that we don't change in the future.
        // To do this, clone the underlying mesh and wrap it in the appropriate
        // RMVisualGeo object.

        IUnknown        *mesh_unknown;    // Needed for Mesh Cloning
        IDirect3DRMMesh *mesh;            // Cloned RM Mesh

        TD3D (_mesh->QueryInterface (IID_IUnknown, (void**)&mesh_unknown));
        TD3D (_mesh->Clone (mesh_unknown, IID_IDirect3DRMMesh, (void**)&mesh));

        // Wrap the cloned mesh in the appropriate RMVisualGeo object.

        if (GetD3DRM3())
            result = NEW RM3MBuilderGeo (mesh);
        else
            result = NEW RM1MeshGeo (mesh);

        if (!result)
            DASetLastError (E_OUTOFMEMORY, IDS_ERR_OUT_OF_MEMORY);

        // Done with our reference to the cloned mesh (the RMVisualGeo wrapper
        // holds a reference).

        mesh->Release();
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\cropdimg.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of the CroppedImage class, a subclass
    of Image.

--*/

#include "headers.h"
#include "privinc/imagei.h"
#include "privinc/probe.h"
#include "privinc/imgdev.h"
#include "privinc/vec2i.h"      // For access to Point2 class
#include "privinc/except.h"
#include "privinc/overimg.h"
#include "privinc/cropdimg.h"
#include "privinc/opt.h"


void
CroppedImage::Render(GenericDevice& d)
{
    // Make sure the cast is legal.
    Assert(DYNAMIC_CAST(ImageDisplayDev *, &d) != NULL);

    ImageDisplayDev &dev = SAFE_CAST(ImageDisplayDev &, d);

    dev.PushCroppedImage(this);

    dev.SmartRender(_image, ATTRIB_CROP);
    
    dev.PopCroppedImage();
}


Real
CroppedImage::DisjointBBoxAreas(DisjointCalcParam &param)
{
    DisjointCalcParam newParam;
    param.CalcNewParamFromBox(_croppingBox, &newParam);

    return _image->DisjointBBoxAreas(newParam);
}

void
CroppedImage::_CollectDirtyRects(DirtyRectCtx &ctx)
{
    Bbox2 oldClipBox = ctx.GetClipBox();

    ctx.AccumulateClipBox(_croppingBox);

    CollectDirtyRects(_image, ctx);
    
    ctx.SetClipBox(oldClipBox);
}


Bool
CroppedImage::DetectHit(PointIntersectCtx& ctx)
{
    // If the local coordinate point is outside of the cropping box,
    // then no hit, otherwise perform operation on the image.
    Point2Value *lcPt = ctx.GetLcPoint();

    if (!lcPt) return FALSE;    // singular transform
    
    if (_croppingBox.Contains(Demote(*lcPt))) {
        return _image->DetectHit(ctx);
    } else {
        return FALSE;
    }
}


Image *CreateCropImage(const Point2& botLeft, const Point2 &topRight, Image *image)
{
    if ((topRight.x <= botLeft.x) || (topRight.y <= botLeft.y)) {
        return emptyImage;
    }

    Bbox2 box(botLeft, topRight);

#if BADIDEA

    if (image->CheckImageTypeId(OVERLAYEDIMAGE_VTYPEID)) {
        
        //
        // Dynamic expression reduction
        //
        OverlayedImage *overImg = (OverlayedImage *)image;
        
        Image *newTop = NEW CroppedImage(box, overImg->Top());
        Image *newBot = NEW CroppedImage(box, overImg->Bottom());
        overImg->SetTopBottom(newTop, newBot);
        return overImg;
    } else if(image->CheckImageTypeId(OPAQUEIMAGE_VTYPEID)) {

        //
        // Opaque Image
        //
        AttributedImage *opcImg = (AttributedImage *)image;

        if(opcImg->_image->CheckImageTypeId(OVERLAYEDIMAGE_VTYPEID)) {
            
            OverlayedImage *overImg = (OverlayedImage *)opcImg->_image;

            //
            // Push xf past opacity, under overlay
            //
            overImg->SetTopBottom(NEW CroppedImage(box, overImg->Top()),
                                  NEW CroppedImage(box, overImg->Bottom()));
            
            opcImg->_image = overImg;
            return opcImg;
        } else {
            // !over
            // !opac
            // => error
            Assert(FALSE && "There's something wrong with dynamic image reduction");
        }
    }
        
#endif  BADIDEA

    return NEW CroppedImage(box, image);
}


Image *CropImage(Point2Value *botLeft, Point2Value *topRight, Image *image)
{
    return CreateCropImage(Demote(*botLeft),Demote(*topRight),image);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\ddsimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

#include <privinc/ddsimg.h>


DirectDrawSurfaceImage::DirectDrawSurfaceImage(
    IDDrawSurface *ddsurf,
    bool holdReference)
{
    _Init(holdReference);
    _InitSurfaces(ddsurf, NULL);
}


DirectDrawSurfaceImage::DirectDrawSurfaceImage(
    IDDrawSurface *iddSurf,
    IDXSurface *idxSurf,
    bool holdReference)
{
    Assert( iddSurf && idxSurf );
    _Init(holdReference);
    _InitSurfaces(iddSurf, idxSurf);
}
    
void DirectDrawSurfaceImage::_Init( bool holdReference )
{
    _resolution = ViewerResolution();
    _holdReference = holdReference;

    // Only reason we need to register this is to allow for deletion
    // when needed.
    if (holdReference) {
        DynamicPtrDeleter<DirectDrawSurfaceImage> *dltr =
            new DynamicPtrDeleter<DirectDrawSurfaceImage>(this);
        GetHeapOnTopOfStack().RegisterDynamicDeleter(dltr);
    }

    _flags |= IMGFLAG_CONTAINS_EXTERNALLY_UPDATED_ELT;
    #if DEVELOPER_DEBUG
    _surfacesSet = false;
    #endif
}

DirectDrawSurfaceImage::~DirectDrawSurfaceImage()
{
    CleanUp();
}

void
DirectDrawSurfaceImage::CleanUp()
{
    // todo: consider telling the device we KNOW we are associated
    // with that we're oging away, instead of telling all the views
    DiscreteImageGoingAway(this);
    TraceTag((tagGCMedia, "DirectDrawSurfaceImage::CleanUp %x", this));

    if (_holdReference) {
        RELEASE(_iddSurf);
        RELEASE(_idxSurf);
    }
}

void
DirectDrawSurfaceImage::Render(GenericDevice& dev)
{
    ImageDisplayDev &idev = (ImageDisplayDev &)dev;
    idev.RenderDirectDrawSurfaceImage(this);
}


void
DirectDrawSurfaceImage::InitIntoDDSurface(DDSurface *ddSurf,
                                          ImageDisplayDev *dev)
{
    if( _iddSurf && !_idxSurf ) {
        Assert(ddSurf->IDDSurface() == _iddSurf);

        // Need to set the color key on the DDSurface.  First grab
        // from the IDirectDrawSurface.
        DDCOLORKEY ckey;
        HRESULT hr = _iddSurf->GetColorKey(DDCKEY_SRCBLT, &ckey);

        if (hr == DDERR_NOCOLORKEY) {
            // It's fine to not have a color key, just return
            return;
        } else if (FAILED(hr)) {
            RaiseException_InternalError("GetColorKey failed");
        } else {
            // And set on the DDSurface.
            ddSurf->SetColorKey(ckey.dwColorSpaceLowValue);
        }
    }
}

void DirectDrawSurfaceImage::
GetIDDrawSurface(IDDrawSurface **outSurf)
{
    Assert( outSurf );
    *outSurf = _iddSurf;
    if(_iddSurf) _iddSurf->AddRef();
}

void DirectDrawSurfaceImage::
GetIDXSurface(IDXSurface **outSurf)
{
    Assert( outSurf );
    *outSurf = _idxSurf;
    if(_idxSurf) _idxSurf->AddRef();
}

void DirectDrawSurfaceImage::
_InitSurfaces(IDDrawSurface *iddSurf,  IDXSurface *idxSurf)
{
    Assert( (iddSurf  && !idxSurf) ||
            (iddSurf  &&  idxSurf) );

    #if DEVELOPER_DEBUG
    Assert(_surfacesSet == false);
    #endif

    _idxSurf = idxSurf;
    _iddSurf = iddSurf;
    if(_holdReference) {
        if(_idxSurf) _idxSurf->AddRef();
        _iddSurf->AddRef();
    }

    #if DEVELOPER_DEBUG
    _surfacesSet = true;
    #endif

    _bboxReady = FALSE;

    // OPTIMIZE: if this happens every frame
    // we should be able to do better.
    GetSurfaceSize(_iddSurf, &_width, &_height);
    SetRect(&_rect, 0,0,_width,_height);
    _membersReady = TRUE;
}
    

Image *ConstructDirectDrawSurfaceImage(IDDrawSurface *dds)
{
    return NEW DirectDrawSurfaceImage(dds, true);
}

Image *ConstructDirectDrawSurfaceImageWithoutReference(IDDrawSurface *idds)
{
    return NEW DirectDrawSurfaceImage(idds, false);
}

Image *ConstructDirectDrawSurfaceImageWithoutReference(IDDrawSurface *idds, IDXSurface *idxs)
{
    return NEW DirectDrawSurfaceImage(idds, idxs, false);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\colorkeyedimage.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

*******************************************************************************/


#include "headers.h"

#include <privinc/imagei.h>
#include <privinc/ColorKeyedImage.h>

ColorKeyedImage::
ColorKeyedImage(Image *underlyingImage, Color *clrKey) :
     AttributedImage(underlyingImage),
     _colorKey(clrKey)
{
}

void ColorKeyedImage::
Render(GenericDevice& dev)
{
    ImageDisplayDev &idev = SAFE_CAST(ImageDisplayDev &, dev);

    bool wasSet = idev.ColorKeyIsSet();
    Color *oldKey;
    if( wasSet ) {
        oldKey = idev.GetColorKey();
    }

    // set my key
    idev.SetColorKey( GetColorKey() );

    //
    // RENDER
    //
    idev.RenderColorKeyedImage(this);

    // unstash
    if( wasSet ) {
        idev.SetColorKey( oldKey );
    } else {
        idev.UnsetColorKey();
    }        
}

void ColorKeyedImage::
DoKids(GCFuncObj proc)
{
    AttributedImage::DoKids(proc);
    (*proc)( _colorKey );
}

extern Color *emptyColor;

Image *ConstructColorKeyedImage( Image *image, Color *clrKey )
{
    if(clrKey == emptyColor) {
        return image;
    } else {
        return NEW ColorKeyedImage( image, clrKey );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\cachdimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

#include "privinc/cachdimg.h"
#include "privinc/dddevice.h"
#include "privinc/path2i.h"
#include "include/appelles/color.h"
#include "include/appelles/path2.h"
#include "include/appelles/linestyl.h"

CachedImage::CachedImage(Image *underlyingImage,
                         bool   usedAsTexture)
{
    _dev = NULL;
    _image = underlyingImage;
    _usedAsTexture = usedAsTexture;
}

CachedImage::~CachedImage()
{
    CleanUp();
}

void
CachedImage::InitializeWithDevice(ImageDisplayDev *dev, Real res)
{
    _resolution = res;
    _dev = (DirectDrawImageDevice *)dev;
    _bbox = _image->BoundingBox();
    
    _nominalWidth = (unsigned long) ((_bbox.max.x - _bbox.min.x ) * GetResolution());
    _nominalHeight = (unsigned long)((_bbox.max.y - _bbox.min.y ) * GetResolution());

    // fix up the width and height.
    if(_nominalWidth %2)  _nominalWidth++;
    if(_nominalHeight %2) _nominalHeight++;
    _nominalWidth +=4;
    _nominalHeight+=4;

    short w, h;
    _image->ExtractRenderResolution(&w, &h, true);
    _width = w;
    _height = h;

    // Can't both be 0.
    if (_width == 0 && _height == 0) {

        // Bogus, just use the defaults
        _width = -1;
        _height = -1;
    }

    if (_width == -1) {
        if (_usedAsTexture) {
            _width = DEFAULT_TEXTURE_WIDTH;
        } else {
            _width = _nominalWidth;
        }
    }

    if (_height == -1) {
        if (_usedAsTexture) {
            _height = DEFAULT_TEXTURE_HEIGHT;
        } else {
            _height = _nominalHeight;
        }
    }

    if ((_width == 0 || _height == 0) &&
        (_nominalHeight != 0 && _nominalWidth != 0)) {

        Assert(!(_width == 0 && _height == 0));
        
        // Maintain aspect ratio.
        short anchoredDimension =
            _width == 0 ? _height : _width;

        if (_nominalHeight > _nominalWidth) {
            
            Real factor = (Real)(_nominalWidth) /
                          (Real)(_nominalHeight);

            _height = anchoredDimension;
            _width = anchoredDimension * factor;
            
        } else {
            
            Real factor = (Real)(_nominalHeight) /
                          (Real)(_nominalWidth);

            _width = anchoredDimension;
            _height = anchoredDimension * factor;
        }
    }
    SetRect(&_rect, 0,0, _width, _height);

    _membersReady = TRUE;
    _bboxReady = TRUE;
}

void
CachedImage::InitIntoDDSurface(DDSurface *ddSurf,
                           ImageDisplayDev *dev)
{
    Assert(_membersReady && "members not initialized in CachedImage::InitIntoSurface");
    Assert((ddSurf->Width() >= GetPixelWidth()) && "given surf wrong size!");
    Assert((ddSurf->Height() >= GetPixelHeight()) && "given surf wrong size!");

    bool bScaled = false;
    Image *imgToUse;
    
    if (_width != _nominalWidth || _height != _nominalHeight) {

        // Rescale the image so all of it will fit into the surface
        // it's being rendered onto.
        Real wscale = ((Real)_width) / ((Real)_nominalWidth);
        Real hscale = ((Real)_height) / ((Real)_nominalHeight);
        Transform2 *xf = ScaleRR(wscale, hscale);
        
        // This will disappear after we render it so we don't hang on to
        // any references.
        imgToUse = NEW Transform2Image(xf, _image);
        bScaled = true;
        
    } else {
        imgToUse = _image;    
    }

#if _DEBUG

    if (IsTagEnabled(tagCachedImagesVisuals)) {
        Bbox2 box2 = imgToUse->BoundingBox();

        // Make an 'X' inside a box over the image
        Point2 pts[8];
        pts[0] = box2.min;
        pts[1].Set(box2.min.x, box2.max.y);
        pts[2] = box2.max;
        pts[3].Set(box2.max.x, box2.min.y);
        pts[4] = pts[0];
        pts[5] = pts[2];
        pts[6] = pts[1];
        pts[7] = pts[3];
        
        Path2 *path = InternalPolyLine2(8, pts);
        

        Color *col = NEW Color(1, 1, 1);
        LineStyle *ls = LineColor(col, defaultLineStyle);

        Image *border = DrawPath(ls, path);
        imgToUse = Overlay(border, imgToUse);        
    }
    
#endif

    
    DirectDrawImageDevice *ddDev =
        SAFE_CAST(DirectDrawImageDevice *, dev);

    Bbox2 origbox;
    if(bScaled) {
        // save off orig bbox & switch
        origbox = ddSurf->Bbox();
        Real sizeh = (_height / GetResolution()) /2;
        Real sizew = (_width  / GetResolution()) /2;
        ddSurf->SetBbox(-sizew, -sizeh, sizew, sizeh);
    }
    ddDev->RenderImageOnDDSurface(imgToUse, ddSurf); // showme(ddSurf)
    if(bScaled) {
        // reset orig bbox if we switched it.
        ddSurf->SetBbox(origbox);
    }
}

Bool
CachedImage::DetectHit(PointIntersectCtx & ctx)
{
    return _image->DetectHit(ctx);
}

/* Render: if any dimension is being scaled up, just rerender the
   underlying image.

   This avoids pixellation problems.

   TODO: cache the re-render image at the appropriate resolution.
*/

void
CachedImage::Render(GenericDevice& dev)
{
    DirectDrawImageDevice &idev = SAFE_CAST(DirectDrawImageDevice &, dev);

    // if there's tiny scale or any complex transforms on the cached
    // image, render natively.
    
    if (    idev.IsScale(1.00000001) ||
         ! (idev.GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX)) ) {        

        _image->Render(dev);

    } else {
        DiscreteImage::Render(dev);
    }
}

void
CachedImage::DoKids(GCFuncObj proc)
{
    DiscreteImage::DoKids(proc);
    (*proc)(_image);
}

void CachedImage::CleanUp()
{
    DiscreteImageGoingAway(this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\geom\xfile.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Reading a .X File as a Geometry.

*******************************************************************************/

#include "headers.h"
#include <d3drm.h>
#include <d3drmdef.h>
#include "appelles/gattr.h"
#include "appelles/readobj.h"
#include "privinc/urlbuf.h"
#include "privinc/bbox3i.h"
#include "privinc/resource.h"
#include "privinc/debug.h"
#include "privinc/d3dutil.h"
#include "privinc/rmvisgeo.h"
#include "privinc/stlsubst.h"
#include "privinc/importgeo.h"
#include "privinc/comutil.h"



class FrameContext;

void    RM1LoadCallback (IDirect3DRMObject*, REFIID, void*);
void    RM3LoadCallback (IDirect3DRMObject*, REFIID, void*);
void    RM1LoadCallback_helper (IDirect3DRMObject*, REFIID, void*);
void    RM3LoadCallback_helper (IDirect3DRMObject*, REFIID, void*);
HRESULT RM1LoadTexCallback (char*, void*, IDirect3DRMTexture**);
HRESULT RM1LoadTexCallback_helper (char*, void*, IDirect3DRMTexture**);
HRESULT RM3LoadTexCallback (char*, void*, IDirect3DRMTexture3**);
HRESULT RM3LoadTexCallback_helper (char*, void*, IDirect3DRMTexture3**);
bool    MeshBuilderToMesh (IDirect3DRMMeshBuilder*, IDirect3DRMMesh**, bool);
void    TraverseD3DRMFrame (IDirect3DRMFrame*, FrameContext&);
void    GatherVisuals (IDirect3DRMFrame*, FrameContext&);


/*****************************************************************************
A base class for maintaining error results.
*****************************************************************************/

class D3DErrorCtx
{
  public:
    D3DErrorCtx() : _error(false) {}

    void SetError() { _error = true; }
    bool Error() { return _error; }

  protected:
    bool _error;
};



/*****************************************************************************
The following class manages the context for .X file loading callbacks.
*****************************************************************************/

class XFileData : public D3DErrorCtx
{
  public:

    XFileData (bool v1Compatible, TextureWrapInfo *wrapinfo) :
        _aggregate (emptyGeometry),
        _wrapInfo (wrapinfo),
        _v1Compatible (v1Compatible)
    {
    }

    ~XFileData (void)
    {
    }

    // This function is called for each object read in from the .X file.
    // We just aggregate this geometry with the current geometry union.

    void AddGeometry (Geometry *geometry)
    {   _aggregate = PlusGeomGeom (_aggregate, geometry);
    }

    // Add and null-name encountered meshbuilders.  This is due to the lack of
    // object-name scoping in RM and our need for backwards-compatiblity.

    void AddMBuilder (IDirect3DRMMeshBuilder3*);
    void ClearMBNames (void);

    // This function returns the aggregation of all given geometries.

    Geometry *GetAggregateGeometry (void)
    {   return _aggregate;
    }

    // this function stashes away the absolute URL of the .X file, which
    // is used to build the absolute URLs of the texture files referenced
    // by the .X file

    void SaveHomeURL(char *homeURL)
    {
        lstrcpyn(_home_url,homeURL,INTERNET_MAX_URL_LENGTH);
        _home_url[INTERNET_MAX_URL_LENGTH - 1] = '\0';
        return;
    }

    // get the absolute URL of the .X file that we stashed away

    char* GetHomeURL(void)
    {
        return _home_url;
    }

    TextureWrapInfo *_wrapInfo;
    bool             _v1Compatible;

  protected:

    bool      _error;
    Geometry *_aggregate;
    char      _home_url[INTERNET_MAX_URL_LENGTH];

    vector<IDirect3DRMMeshBuilder3*> _mblist;
};



/*****************************************************************************
These routines add mbuilders and clear mbuilder names (for backwards compat,
and due to the lack of object-name scoping in RM).
*****************************************************************************/

void XFileData::AddMBuilder (IDirect3DRMMeshBuilder3 *mb)
{
    VECTOR_PUSH_BACK_PTR (_mblist, mb);
}


void XFileData::ClearMBNames (void)
{
    while (_mblist.size() > 0)
    {   
        IDirect3DRMMeshBuilder3 *mb = _mblist.back();
        _mblist.pop_back();
        AD3D (mb->SetName(NULL));
    }
}



/*****************************************************************************
This function takes the pathname of a .X file and returns the Geometry read in
from that file.
*****************************************************************************/

Geometry* ReadXFileForImport (
    char            *pathname,   // Full URL
    bool             v1Compatible,
    TextureWrapInfo *pWrapInfo)
{

    // 3D is disabled on pre-DX3 systems.

    if (sysInfo.VersionD3D() < 3)
        RaiseException_UserError (E_FAIL, IDS_ERR_PRE_DX3);

    Assert (pathname);

    INetTempFile tempFile(pathname);
    char *tempFileName = tempFile.GetTempFileName();

    Assert (tempFileName);

    TraceTag ((tagReadX, "Importing \"%s\"", pathname));

    XFileData xdata (v1Compatible, pWrapInfo);   // Load Callback Context

    // Save .X file's absolute URL so we can form absolute URLs to texture
    // files referenced by .X file.

    xdata.SaveHomeURL (pathname);

    // Call the generic D3DRM load call.  This sets up callbacks for objects
    // (meshbuilders or frames) or textures read in from the file.

    HRESULT result;

    if (GetD3DRM3())
    {
        const int guidlistcount = 3;

        static IID *guidlist [guidlistcount] =
        {   (GUID*) &IID_IDirect3DRMMeshBuilder3,
            (GUID*) &IID_IDirect3DRMFrame3,
            (GUID*) &IID_IDirect3DRMProgressiveMesh
        };

        Assert (guidlistcount == (sizeof(guidlist) / sizeof(guidlist[0])));

        // If we catch an exception here then we must have incorrectly
        // failed to catch an exception we threw in one of the
        // callbacks.  This would be a BAD bug
        //
        // Disabled for now since it cannot compile with the inlined
        // try block
        #if _DEBUG1
        __try {
        #endif
        result = GetD3DRM3()->Load
                 (   tempFileName, NULL, guidlist, guidlistcount,
                     D3DRMLOAD_FROMFILE, RM3LoadCallback_helper, &xdata,
                     RM3LoadTexCallback_helper, &xdata, NULL
                 );
        #if _DEBUG1
        } __except ( HANDLE_ANY_DA_EXCEPTION ) {
            Assert(false && "BUG:  Failed to catch an exception in D3DRM callback.");
        }
        #endif

        // Now that we're done with the file, we need to null-out the mbuilder
        // object names so they don't get used in future .X files.  For example,
        // if a mbuilder with name "Arrow" is defined here, it will be used in
        // a subsequent X file even if a different mbuilder with the name
        // "Arrow" is defined in that file.  To work around this, we clear all
        // of the names of mbuilders from this file.

        xdata.ClearMBNames();
    }
    else
    {
        const int guidlistcount = 2;

        static IID *guidlist [guidlistcount] =
        {   (GUID*) &IID_IDirect3DRMMeshBuilder,
            (GUID*) &IID_IDirect3DRMFrame
        };

        Assert (guidlistcount == (sizeof(guidlist) / sizeof(guidlist[0])));

        // If we catch an exception here then we must have incorrectly
        // failed to catch an exception we threw in one of the
        // callbacks.  This would be a BAD bug
        //
        // Disabled for now since it cannot compile with the inlined
        // try block
        #if _DEBUG1
        __try {
        #endif
        result = GetD3DRM1()->Load
                 (   tempFileName, NULL, guidlist, guidlistcount,
                     D3DRMLOAD_FROMFILE, RM1LoadCallback_helper, &xdata,
                     RM1LoadTexCallback_helper, &xdata, NULL
                 );
        #if _DEBUG1
        } __except ( HANDLE_ANY_DA_EXCEPTION ) {
            Assert(false && "BUG:  Failed to catch an exception in D3DRM callback.");
        }
        #endif
    }

    if (xdata.Error()) {
        TraceTag((tagError, "D3DRM Get error"));
        RaiseException_InternalError("D3DRM Get error");
    }

    switch (result)
    {
        case D3DRM_OK: break;

        default:                  // If we don't know the error, then just pass
            TD3D (result);        // it to the regular HRESULT error handler.
            return emptyGeometry;

        case D3DRMERR_FILENOTFOUND:
            RaiseException_UserError (E_FAIL, IDS_ERR_FILE_NOT_FOUND, pathname);

        case D3DRMERR_BADFILE:
            RaiseException_UserError (E_FAIL, IDS_ERR_CORRUPT_FILE, pathname);
    }

    return xdata.GetAggregateGeometry ();
}



/*****************************************************************************
This class maintains the context during the traversal of a DX3 (RM1) frame
hierarchy.
*****************************************************************************/

class FrameContext : public D3DErrorCtx
{
  public:

    // Define a mapping between meshbuilders and meshes, and the number of
    // references to each meshbuilder.  We need to do this to ensure that we
    // properly handle multiply-referenced leaf geometries, and to keep a list
    // of all meshes in the frame.

    typedef map <IDirect3DRMMeshBuilder*, IDirect3DRMMesh*> MeshMap;

    typedef vector<IDirect3DRMMesh*> MeshVector;

    FrameContext ()
    : _xform (identityTransform3), depth(0) {}

    ~FrameContext ()
    {
        for (MeshMap::iterator i = _meshmap.begin();
             i != _meshmap.end(); i++) {
            // We've been holding on to the meshbuilder handles to ensure that
            // pointers to each meshbuilder are unique to handle multiply-
            // instanced geometries.  Release the last instance here.

            (*i).first->Release();
            (*i).second->Release();
        }

        _meshmap.erase (_meshmap.begin(), _meshmap.end());
    }

    // These methods manage the transform stack while traversing frame graphs.

    void        SetTransform (Transform3 *xf) { _xform = xf; }
    Transform3 *GetTransform (void)           { return _xform; }

    void AddTransform (Transform3 *xf)
    {   _xform = TimesXformXform (_xform, xf);
    }

    // These methods build up and return the bounding box for the entire
    // frame graph.

    void AugmentModelBbox (Bbox3 *box) {
        _bbox.Augment (*TransformBbox3 (_xform, box));
    }

    Bbox3 *GetBbox (void) {
        return NEW Bbox3 (_bbox);
    }

    // This method loads all of the meshes we've converted from meshbuilders
    // into a single vector element (to be used with RM1FrameGeo objects).

    void LoadMeshVector (MeshVector *mvec)
    {
        MeshMap::iterator mi = _meshmap.begin();

        while (mi != _meshmap.end())
        {
            VECTOR_PUSH_BACK_PTR (*mvec, (*mi).second);

            ++ mi;
        }
    }

    // The traversal depth.  The first frame is depth 1.

    int depth;

    // These methods manage which meshes correspond to which meshbuilders.
    // The mapping between the two is noted because a meshbuilder may be
    // instanced several times in a frame graph.

    IDirect3DRMMesh *GetMatchingMesh (IDirect3DRMMeshBuilder *mb)
    {   MeshMap::iterator mi = _meshmap.find (mb);
        return (mi == _meshmap.end()) ? NULL : (*mi).second;
    }

    // This routine is called to establish a relation between a meshbuilder and
    // a corresponding mesh.  NOTE:  GetMatchingMesh() should be called first
    // to ensure that there isn't already an existing match for the given
    // meshbuilder object.

    void AddMesh (IDirect3DRMMeshBuilder *builder, IDirect3DRMMesh *mesh)
    {
        // Ensure that this is a new entry.

        #if _DEBUG
        {   MeshMap::iterator mi = _meshmap.find (builder);
            Assert (mi == _meshmap.end());
        }
        #endif

        builder->AddRef();    // Hang on to the builder until context destruct.

        _meshmap[builder] = mesh;   // Set the association.
    }

  protected:

    Transform3  *_xform;       // Current Accumulated Transform
    Bbox3        _bbox;        // Total Frame Bounding Box
    MeshMap      _meshmap;     // Mesh/Builder Pairs
};


void RM1LoadCallback_helper (
    IDirect3DRMObject *object,      // The Generic D3D RM Object
    REFIID             id,          // The Object's GUID
    void              *user_data)   // Our Data (== XFileData*)
{
    __try {
        RM1LoadCallback(object, id, user_data);
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        ((XFileData*)user_data)->SetError();
    }

    object->Release();
}

/*****************************************************************************
The following is the main callback function for reading frames or meshes from
.X files using the RM1 interface (DX3).  This function is called for each
meshbuilder and each frame in the file.
*****************************************************************************/

void RM1LoadCallback (
    IDirect3DRMObject *object,      // The Generic D3D RM Object
    REFIID             id,          // The Object's GUID
    void              *user_data)   // Our Data (== XFileData*)
{
    XFileData &xdata = *(XFileData*)(user_data);

    if (id == IID_IDirect3DRMMeshBuilder)
    {
        TraceTag ((tagReadX, "RM1LoadCallback (mbuilder %x)", object));

        DAComPtr<IDirect3DRMMeshBuilder> meshBuilder;

        if (FAILED(AD3D(object->QueryInterface
                    (IID_IDirect3DRMMeshBuilder, (void**)&meshBuilder))))
        {
            xdata.SetError();
            return;
        }

        // Convert the meshbuilder object to a mesh, and flip over to the
        // right-handed coordinate system.

        DAComPtr<IDirect3DRMMesh> mesh;

        if (!MeshBuilderToMesh (meshBuilder, &mesh, true))
            xdata.SetError();

        xdata.AddGeometry (NEW RM1MeshGeo (mesh));
    }
    else if (id == IID_IDirect3DRMFrame)
    {
        TraceTag ((tagReadX, "RM1LoadCallback (frame %x)", object));

        DAComPtr<IDirect3DRMFrame> frame;

        if (FAILED(AD3D(object->QueryInterface
                    (IID_IDirect3DRMFrame, (void**)&frame))))
        {
            xdata.SetError();
            return;
        }

        // Add a top-level scale of -1 in Z to convert to RH coordinates.

        if (FAILED(AD3D(frame->AddScale (D3DRMCOMBINE_BEFORE, 1,1,-1))))
        {
            xdata.SetError();
            return;
        }

        FrameContext context;

        TraverseD3DRMFrame (frame, context);

        // Now get a list of all the meshes in the frame.

        FrameContext::MeshVector meshvec;
        context.LoadMeshVector (&meshvec);

        xdata.AddGeometry (NEW RM1FrameGeo (frame,&meshvec,context.GetBbox()));

        if (context.Error())
            xdata.SetError();
    }
    else
    {
        AssertStr (0, "Unexpected type fetched from RM1LoadCallback.");
    }
}



/*****************************************************************************
This callback procedure is invoked for each object loaded from an X file using
the RM3 (DX6) load procedure.
*****************************************************************************/

void RM3LoadCallback_helper (
    IDirect3DRMObject *object,      // The Generic D3D RM Object
    REFIID             id,          // The Object's GUID
    void              *user_data)   // Our Data (== XFileData*)
{
    __try {
        RM3LoadCallback(object, id, user_data);
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        ((XFileData*)user_data)->SetError();
    }

    object->Release();
}

void RM3LoadCallback (
    IDirect3DRMObject *object,      // The Generic D3D RM Object
    REFIID             id,          // The Object's GUID
    void              *user_data)   // Our Data (== XFileData*)
{
    XFileData &xdata = *(XFileData*)(user_data);

    DAComPtr<IDirect3DRMMeshBuilder3>    mbuilder;
    DAComPtr<IDirect3DRMFrame3>          frame;
    DAComPtr<IDirect3DRMProgressiveMesh> pmesh;

    if (SUCCEEDED(RD3D(object->QueryInterface
                      (IID_IDirect3DRMMeshBuilder3, (void**)&mbuilder))))
    {
        TraceTag ((tagReadX, "RM3LoadCallback (mbuilder3 %x)", mbuilder));

        xdata.AddMBuilder (mbuilder);

        RM3MBuilderGeo *builder = NEW RM3MBuilderGeo (mbuilder, false);
        if (xdata._wrapInfo) {
            builder->TextureWrap (xdata._wrapInfo);
        }

        builder->Optimize();    // Invoke RM Optimization

        xdata.AddGeometry (builder);
    }
    else if (SUCCEEDED(RD3D(object->QueryInterface
                           (IID_IDirect3DRMFrame3, (void**)&frame))))
    {
        TraceTag ((tagReadX, "RM3LoadCallback (frame3 %x)", frame));

        if (xdata._v1Compatible)
        {
            // Unless we're using the new wrapped geometry import, break the
            // imported frame transform to maintain backwards compatibility.
            // We do this by cancelling out the valid Zflip on one side of
            // the transform and placing it on the incorrect side.

            HRESULT result;

            result = RD3D(frame->AddScale (D3DRMCOMBINE_BEFORE, 1, 1, -1));
            AssertStr (SUCCEEDED(result), "Combine before-xform failure");

            result = RD3D(frame->AddScale (D3DRMCOMBINE_AFTER,  1, 1, -1));
            AssertStr (SUCCEEDED(result), "Combine after-xform failure");
        }

        RM3FrameGeo *rm3frame = NEW RM3FrameGeo (frame);

        if (xdata._wrapInfo) {
            rm3frame->TextureWrap (xdata._wrapInfo);
        }

        xdata.AddGeometry (rm3frame);
    }
    else if (SUCCEEDED(RD3D(object->QueryInterface
                           (IID_IDirect3DRMProgressiveMesh, (void**)&pmesh))))
    {
        TraceTag ((tagReadX, "RM3LoadCallback (pmesh %x)", pmesh));

        xdata.AddGeometry (NEW RM3PMeshGeo (pmesh));
    }
    else
    {
        AssertStr (0, "Unexpected type fetched from RM3LoadCallback.");
    }
}



/*****************************************************************************
This function is called back for each texture in the RM1 load of an X file.
*****************************************************************************/

HRESULT RM1LoadTexCallback_helper (
    char                *name,           // Texture File Name
    void                *user_data,      // Our Data (== XFileData*)
    IDirect3DRMTexture **texture)        // Destination Texture Handle
{
    HRESULT ret;

    __try {
        ret = RM1LoadTexCallback(name, user_data, texture);
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        ret = DAGetLastError();
    }

    return ret;
}



HRESULT RM1LoadTexCallback (
    char                *name,           // Texture File Name
    void                *user_data,      // Our Data (== XFileData*)
    IDirect3DRMTexture **texture)        // Destination Texture Handle
{
    TraceTag ((tagReadX,"RM1LoadTexCallback \"%s\", texture %x",name,texture));
    HRESULT ret;

    // Get the absolute URL of the texture file.

    XFileData *const xdata = (XFileData*) user_data;
    URLRelToAbsConverter absoluteURL(xdata->GetHomeURL(),name);
    char *resultURL = absoluteURL.GetAbsoluteURL();

    // get it over to local machine

    INetTempFile tempFile;

    *texture = NULL;
    if (!tempFile.Open(resultURL)) {

        ret = D3DRMERR_FILENOTFOUND;
        TraceTag ((tagError,"RM1LoadTexCallback: \"%s\" not found",resultURL));

    } else {

        // Get the local file name and pass it along to RM to load texture.

        char *tempFileName = tempFile.GetTempFileName();
        ret = RD3D(GetD3DRM1()->LoadTexture (tempFileName, texture));

        TraceTag ((tagGTextureInfo, "Loaded RM texture %x from \"%s\"",
                   texture, resultURL));

    }

    return ret;
}



/*****************************************************************************
This function is called back for each texture in the RM3 load of an X file.
*****************************************************************************/

HRESULT RM3LoadTexCallback_helper (
    char                 *name,           // Texture File Name
    void                 *user_data,      // Our Data (== XFileData*)
    IDirect3DRMTexture3 **texture)        // Destination Texture Handle
{
    HRESULT ret;

    __try {
        ret = RM3LoadTexCallback(name, user_data, texture);
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        ret = DAGetLastError();
    }

    return ret;
}



HRESULT RM3LoadTexCallback (
    char                 *name,           // Texture File Name
    void                 *user_data,      // Our Data (== XFileData*)
    IDirect3DRMTexture3 **texture)        // Destination Texture Handle
{
    TraceTag ((tagReadX,"RM3LoadTexCallback \"%s\", texture %x",name,texture));
    HRESULT ret;

    // Get the absolute URL of the texture file.

    XFileData *const xdata = (XFileData*) user_data;
    URLRelToAbsConverter absoluteURL(xdata->GetHomeURL(),name);
    char *resultURL = absoluteURL.GetAbsoluteURL();

    // get it over to local machine

    INetTempFile tempFile;

    *texture = NULL;
    if (!tempFile.Open(resultURL)) {

        ret = D3DRMERR_FILENOTFOUND;
        TraceTag ((tagError,"RM3LoadTexCallback: \"%s\" not found",resultURL));

    } else {

        // Get the local file name and pass it along to RM to load texture.

        char *tempFileName = tempFile.GetTempFileName();
        ret = RD3D(GetD3DRM3()->LoadTexture (tempFileName, texture));

        TraceTag ((tagGTextureInfo, "Loaded RM texture %x from \"%s\"",
                   texture, resultURL));

    }

    return ret;
}



/*****************************************************************************
This procedure recursively traverses D3DRM frames, constructing the bounding
box for the entire frame, and tracking the internal meshes as it goes.
*****************************************************************************/

void TraverseD3DRMFrame (
    IDirect3DRMFrame *frame,
    FrameContext     &context)
{
    ++ context.depth;

    // Accumulate the current frame's modeling transform.

    Transform3 *oldxf = context.GetTransform();

    D3DRMMATRIX4D d3dxf;

    if (FAILED(AD3D (frame->GetTransform (d3dxf))))
    {   context.SetError();
        return;
    }

    context.AddTransform (GetTransform3(d3dxf));

    GatherVisuals(frame, context);

    // Traverse all of the child frames.

    IDirect3DRMFrameArray *children;

    if (FAILED(AD3D(frame->GetChildren(&children))))
    {   context.SetError();
        return;
    }

    DWORD count = children->GetSize();

    #if _DEBUG
    {   if (count)
            TraceTag ((tagReadX, "%d: %d children", context.depth, count));

        D3DRMMATERIALMODE matmode = frame->GetMaterialMode();

        TraceTag ((tagReadX, "%d: Material Mode is %s",
            context.depth,
            (matmode == D3DRMMATERIAL_FROMMESH)   ? "From-Mesh" :
            (matmode == D3DRMMATERIAL_FROMPARENT) ? "From-Parent" :
            (matmode == D3DRMMATERIAL_FROMFRAME)  ? "From-Frame" : "Unknown"));
    }
    #endif

    for (int i=0;  i < count;  ++i)
    {
        IDirect3DRMFrame *child;

        if (FAILED(AD3D (children->GetElement (i, &child))))
        {   context.SetError();
            return;
        }

        // We should just do an assert instead, this is to guard
        // against DX2.

        if (!child) {
            context.SetError();
            return;
        }

        TraceTag ((tagReadX, "%d: Traversing child %d.", context.depth, i));
        TraverseD3DRMFrame (child, context);
        TraceTag ((tagReadX, "%d: Return from child %d.", context.depth, i));

        child->Release();
    }

    children->Release();

    context.SetTransform (oldxf);

    -- context.depth;
}



/*****************************************************************************
This procedure gathers all visuals for a particular frame node, and
accumulates the state in the given frame context.
*****************************************************************************/

void GatherVisuals (IDirect3DRMFrame *frame, FrameContext& context)
{
    // Gather all of the visuals from the frame.

    DWORD count;   // Generic Array Count

    IDirect3DRMVisualArray *visuals;

    if (FAILED(AD3D(frame->GetVisuals(&visuals))))
    {   context.SetError();
        return;
    }

    count = visuals->GetSize();

    #if _DEBUG
        if (count)
            TraceTag ((tagReadX, "%d: %d visuals", context.depth, count));
    #endif

    HRESULT result;
    int     i;

    for (i=0;  i < count;  ++i)
    {
        IDirect3DRMVisual      *visual;
        IDirect3DRMMeshBuilder *builder;

        // See if the object is a mesh builder (this is what we expect).

        if (FAILED(AD3D(visuals->GetElement (i, &visual))))
        {   context.SetError();
            return;
        }

        Assert (visual);

        result = visual->QueryInterface
                         (IID_IDirect3DRMMeshBuilder, (void**)&builder);

        if (result != D3DRM_OK) {

            Assert (!"Unexpected visual type in .X file (not meshBuilder)");

        } else {
            TraceTag ((tagReadX, "%d: Visual %08x [%d] is a meshbuilder",
                context.depth, visual, i));

            // Remove the meshbuilder from the tree; we'll be using a mesh
            // in its stead.

            if (FAILED(AD3D(frame->DeleteVisual (builder))))
            {   context.SetError();
                return;
            }

            // First try to see if we've already dealt with this particular
            // meshbuilder (some meshes may be referenced more than once in the
            // scene graph).

            IDirect3DRMMesh *mesh = context.GetMatchingMesh (builder);

            // If we've already handled this meshbuilder, then just use the
            // resultant mesh and get the model-coord bounding box.

            D3DRMBOX d3dbox;

            if (mesh) {

                TraceTag ((tagReadX,
                    "%d: Builder %08x already mapped to mesh %08x",
                    context.depth, builder, mesh));

                // Augment the scene bbox with the bbox of the current mesh.

                if (FAILED(AD3D(mesh->GetBox(&d3dbox))))
                {   context.SetError();
                    return;
                }

            } else {

                // If we have NOT seen this meshbuilder before, then convert it
                // to a mesh and add the pair to the context.  Also keep it
                // from flipping the Z coordinates, since we do that at the
                // root of this frame graph.

                if (!MeshBuilderToMesh (builder, &mesh, false))
                    context.SetError();

                TraceTag ((tagReadX, "%d: Builder %08x converted to mesh %08x",
                           context.depth, builder, mesh));

                context.AddMesh (builder, mesh);

                if (FAILED(AD3D(builder->GetBox(&d3dbox))))
                {   context.SetError();
                    return;
                }
            }

            // Release the meshbuilder object.

            builder->Release();

            // Augment the scene bbox with the bbox of this mesh's instance.

            context.AugmentModelBbox (NEW Bbox3 (d3dbox));

            // Replace the meshbuilder object with the corresponding mesh.

            if (FAILED(AD3D(frame->AddVisual(mesh))))
            {   context.SetError();
                return;
            }
        }

        visual->Release();
    }

    visuals->Release();
}



/*****************************************************************************
Converts the mesh builder to a mesh, converts the vertex coords to right-hand
cartesian (position and surface coords).  Returns true if successful.
*****************************************************************************/

bool MeshBuilderToMesh (
    IDirect3DRMMeshBuilder  *inputBuilder,    // Mesh Builder Object
    IDirect3DRMMesh        **outputMesh,      // Resultant Mesh Object
    bool                     flipZ)           // If true, invert Z coord.
{
    *outputMesh = 0;

    // Convert to right-handed coordinate system if needed.

    if (flipZ) {
        Assert (!GetD3DRM3() && "Shouldn't do flipz when D3DRM3 available.");

        if (FAILED(AD3D(inputBuilder->Scale(D3DVAL(1),D3DVAL(1),D3DVAL(-1)))))
            return false;
    }

    // Generate a mesh which will be stored with this Geometry object.

    if (FAILED(AD3D(inputBuilder->CreateMesh(outputMesh))))
        return false;

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\discimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

#include "privinc/dibimage.h"
#include "privinc/discimg.h"


const Bbox2 DiscreteImage::BoundingBox(void)
{
    if(!_bboxReady) {
        //
        // Build bounding box
        //
        Assert( (_width>0) && (_height>0) && "width or height invalid in DiscreteImage::BoundingBox");
        Assert( (_resolution>0) && "_resolution invalid in DiscreteImage::BoundingBox");

        _bbox.Set(Real( - GetPixelWidth() ) * 0.5 / GetResolution(),
                  Real( - GetPixelHeight() ) * 0.5 / GetResolution(),
                  Real( GetPixelWidth() ) * 0.5 / GetResolution(),
                  Real( GetPixelHeight() ) * 0.5 / GetResolution());
        _bboxReady = TRUE;
    }
    return _bbox;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\dibimage.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Support for DIB images from DIB and BMP files

*******************************************************************************/

#include "headers.h"

#include <strstrea.h>
#include "privinc/dibimage.h"
#include "privinc/probe.h"
#include "privinc/imgdev.h"
#include "privinc/ddutil.h"
#include "privinc/util.h"
#include "privinc/bbox2i.h"
#include "privinc/ddSurf.h"
#include "privinc/vec2i.h"
#include "appelles/readobj.h"
#include "privinc/viewport.h"
#include "privinc/dddevice.h"
#include "privinc/error.h"
#include "privinc/except.h"
#include "privinc/debug.h"
#include "privinc/resource.h"


DibImageClass::DibImageClass(HBITMAP hbm,
                             COLORREF colorRef,
                             Real resolution)
{
    if(resolution < 0) {
        _resolution = ViewerResolution();
    } else {
        _resolution = resolution;
    }

    _noDib      = TRUE;
    _hbm        = hbm;
    _colorRef   = colorRef;

    TraceTag((tagDibImageInformative, "Dib Image %x has HBM %x and clrKey %x", this, _hbm, _colorRef));
    
    ConstructWithHBM();
    _noDib = FALSE;

    _2ndCkValid = false;
    _2ndClrKey  = 0xffffffff;
}


void
DibImageClass::ConstructWithHBM()
{
    BITMAP              bm;

    //
    // get size of the first bitmap.  assumption: all bitmaps are same size
    //
    GetObject(_hbm, sizeof(bm), &bm);      // get size of bitmap

    //
    // Set members
    //
    _width = bm.bmWidth;
    _height = bm.bmHeight;
    SetRect(&_rect, 0,0, _width, _height);
    
    TraceTag((tagDibImageInformative,
              "Dib %x NEW w,h = pixel: (%d, %d)",
              this, _width, _height));
    
    _membersReady=TRUE;
}

void DibImageClass::CleanUp()
{
    BOOL ret;
    if(_hbm) {
        TraceTag((tagGCMedia, "Dib Image %x deleting HBM %x", this, _hbm));
        ret = DeleteObject( _hbm );
        IfErrorInternal(!ret, "Could not delete hbm in dibImageClass destructor");
        DiscreteImageGoingAway(this);
    }
}


Bool
DibImageClass::DetectHit(PointIntersectCtx& ctx)
{
    // Check to see if the local point is in the bounding region.
    Point2Value *lcPt = ctx.GetLcPoint();

    if (!lcPt) return FALSE;    // singular transform
    
    if (BoundingBox().Contains(Demote(*lcPt))) {
        if (_colorRef != INVALID_COLORKEY) {
            // TODO: the device should be part of the point intersect
            // context.  that should be set before we do picking.
            DirectDrawImageDevice *dev =
                GetImageRendererFromViewport( GetCurrentViewport() );
            
            DDSurface *ddSurf = dev->LookupSurfaceFromDiscreteImage(this);
            if(!ddSurf) return FALSE;

            LPDDRAWSURFACE surface = ddSurf->IDDSurface();
            if(!surface) return FALSE;


            HDC hdc;
            COLORREF clr;
            hdc = ddSurf->GetDC("Couldn't get DC for DibImageClass::detectHit for dib");

            if(hdc) {

                // color key is set, see if hit is a transparent pixel.
                POINT pt;
                CenteredImagePoint2ToPOINT(lcPt, _width, _height, &pt);

                clr = GetPixel(hdc, pt.x, pt.y);
                ddSurf->ReleaseDC("couldn't releaseDC for DibImageClass::detectHit");
                return clr != _colorRef;
            } else {
                TraceTag((tagError, "Couldn't get DC on surface for DetectHit for transparent dib"));
                return FALSE;
            }
        } else
            return TRUE;
    } else 
        return FALSE;
}


void
DibImageClass::InitIntoDDSurface(DDSurface *ddSurf,
                                 ImageDisplayDev *dev)
{
    Assert( !_noDib && "There's no dib available in InitIntoSurface");
    Assert(_hbm && "No HBM in DibImageClass for InitIntoSurface");

    Assert( ddSurf->IDDSurface() );
    
    if( FAILED( ddSurf->IDDSurface()->Restore() ) ) {
        RaiseException_InternalError("Restore on ddSurf in DibImageClass::InitIntoDDSurface");
    }
    
    HRESULT ddrval = DDCopyBitmap(ddSurf->IDDSurface(), _hbm, 0, 0, 0, 0);
    TraceTag((tagDibImageInformative, "Dib %x Copied _hbm %x to surface %x", this, _hbm, ddSurf->IDDSurface()));
    IfDDErrorInternal(ddrval, "Couldn't copy bitmap to surface in DibImage");

    // Turn the colorkey into the physical color that it actually got
    // mapped to.  TODO: Note that if multiple views share this
    // object, the last one will be the one that wins.  That is, if
    // there are multiple physical colors that this gets mapped to
    // through different views, only one (the last one) will be
    // recorded.  
    if (_colorRef != INVALID_COLORKEY) {

        HDC hdc;
        if (ddSurf->IDDSurface()->GetDC(&hdc) == DD_OK) {
            DWORD oldPixel = GetPixel(hdc, 0, 0);
            SetPixel(hdc, 0, 0, _colorRef); // put in
            _colorRef = GetPixel(hdc, 0, 0); // pull back out
            SetPixel(hdc, 0, 0, oldPixel);
            ddSurf->IDDSurface()->ReleaseDC(hdc);
        }
        
    }
}



//////////////////////////////////////////
// IMPORT DIB.  Return NULL if no match for the filename. 
//////////////////////////////////////////

Image **
ReadDibForImport(char *urlPathname,
                 char *cachedFilename,
                 IStream * pstream,
                 bool useColorKey,
                 BYTE ckRed,
                 BYTE ckGreen,
                 BYTE ckBlue,
                 int *count,
                 int **delays,
                 int *loop)
{
    TraceTag((tagImport, "Read Image file %s for URL %s",
              cachedFilename,
              urlPathname));

    // Allocations below assume current heap is GC heap.
    Assert(&GetHeapOnTopOfStack() == &GetGCHeap());

    HBITMAP *bitmapArray = NULL;
    COLORREF *colorKeys = NULL;
    Image **imArr = NULL;         

    bitmapArray = UtilLoadImage(cachedFilename, 
                                pstream,
                                0, 0,
                                &colorKeys, 
                                count,
                                delays,
                                loop);
    if (!bitmapArray) {
        imArr = (Image **)AllocateFromStore(sizeof(Image **));
        *imArr = PluginDecoderImage(urlPathname,
                                    cachedFilename,
                                    pstream,
                                    useColorKey,
                                    ckRed,
                                    ckGreen,
                                    ckBlue);
        if (*imArr == NULL) {
            delete imArr;
            imArr = NULL;
        }
        else {
            *count = 1;
        }
    }
    else {
        Assert((*count > 0) && "Bad bitmapCount in ReadDibForImaport");

        COLORREF userColorRef = useColorKey ? 
            RGB(ckRed, ckGreen, ckBlue) : INVALID_COLORKEY;        

        imArr = (Image **)AllocateFromStore((*count) * sizeof(Image **));
        for(int i=0; i < *count; i++) {
            // If the file itself didn't provide us with a color key, and one
            // is specified, use it.
            COLORREF curColorRef;
            if(colorKeys) {
                curColorRef = (colorKeys[i] != -1) ? colorKeys[i] : userColorRef;            
            }
            else 
                curColorRef = userColorRef;
            
            imArr[i] = NEW DibImageClass(bitmapArray[i],curColorRef);
        }

        if (colorKeys)
            StoreDeallocate(GetGCHeap(), colorKeys);

        if (bitmapArray)
            StoreDeallocate(GetGCHeap(), bitmapArray);

    }

    TraceTag((tagImport, "Loaded %d hbms from file: %s", *count, cachedFilename));

    return imArr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\dxxf.cpp ===
/*******************************************************************************
Copyright (c) 1997-1998 Microsoft Corporation.  All rights reserved.

    Support the hosting of DXTransforms from inside of DirectAnimation.

*******************************************************************************/

#include "headers.h"
#include "privinc/imagei.h"
#include "backend/bvr.h"
#include "backend/perf.h"
#include "backend/timeln.h"
#include "privinc/dxxf.h"
#include "privinc/bbox2i.h"
#include "privinc/ddsurf.h"
#include "privinc/ddsimg.h"
#include "privinc/dddevice.h"
#include "privinc/server.h"
#include "privinc/ddrender.h"
#include "privinc/viewport.h"
#include "privinc/overimg.h"
#include "privinc/rmvisgeo.h"
#include "privinc/d3dutil.h"
#include "privinc/dxmatl.h"
#include "privinc/comutil.h"
#include "privinc/opt.h"
#include "privinc/meshmaker.h"
#include <d3drmvis.h>
#include <dxterror.h>


DeclareTag(tagDXTransformPerPixelAlphaOutputOff, "DXTransforms", "Turn off output per pixel alpha support");

DeclareTag(tagDXTransformTracePick, "DXTransforms", "Trace picking");

// Forward decl.
// If necessary, do a Setup.  Do an Execute.  In all cases, fill in
// outputValue with the output for this.
HRESULT
DXXFSetupAndExecute(Bvr bvr,                   /* in */
                    IUnknown **newInputArray,  /* in */
                    REFIID     outputIID,      /* in */
                    DirectDrawViewport *viewport, /* in - img only */
                    int        requestedWidth, /* in - img only */
                    int        requestedHeight, /* in - img only */
                    bool       invokedAsExternalVisual, /* in */
                    bool       executeRequired, /* in */
                    void     **outputValue);   /* out */

// All of these MAX values are for programming convenience for the
// time being (and are reasonable maximum values).  When it becomes a
// priority, they should be made more dynamic.
#define MAX_INPUTS_TO_CACHE 5
#define MAX_INPUTS          10
#define MAX_PARAM_BVRS      20


void GetRenderDimensions(Image *im,
                         unsigned short *pWidth,
                         unsigned short *pHeight)
{
    if (im->CheckImageTypeId(DISCRETEIMAGE_VTYPEID)) {
                
        DiscreteImage *discImg =
            SAFE_CAST(DiscreteImage *, im);

        *pWidth = discImg->GetPixelWidth();
        *pHeight = discImg->GetPixelHeight();
                
    } else {

        short w, h;
        im->ExtractRenderResolution(&w, &h, true);
        if (w != -1) {

            *pWidth = w;
            *pHeight = h;
                    
        } else {

            *pWidth = DEFAULT_TEXTURE_WIDTH;
            *pHeight = DEFAULT_TEXTURE_HEIGHT;

        }
    }
}

class GeometryInputBundle {
  public:
    GeometryInputBundle() {
        _geo = NULL;
        _creationID = 0;
    }

    void Validate(Geometry *geo,
                  DirectDrawImageDevice *dev)
    {
        if (_geo != geo ||
            _creationID != geo->GetCreationID() ||
            _creationID == PERF_CREATION_ID_BUILT_EACH_FRAME) {

            _geo = geo;

            _mb.Release();
            DumpGeomIntoBuilder(geo,
                                dev,
                                &_mb);

            _creationID = geo->GetCreationID();
      
        } else {

            // TODO: What to do about generation id's if the original
            // visuals that contributed are changing?
      
        }
    
    }

    IUnknown *GetUnknown() {
        _mb->AddRef();
        return _mb;
    }
    
  protected:
    Geometry                         *_geo;
    long                              _creationID;
    DAComPtr<IDirect3DRMMeshBuilder3> _mb;
};

class ImageAsDXSurfaceBundle {
  public:
    ImageAsDXSurfaceBundle() {
        _im = NULL;
        _lastSurfFromPool = false;
    }

    void Validate(Image *im,
                  DirectDrawImageDevice *dev,
                  IDXSurfaceFactory *f,
                  SurfacePool *sourcePool,
                  ULONG inputNumber) {

        if (im != _im ||
            im->GetCreationID() != _creationID ||
            _creationID == PERF_CREATION_ID_BUILT_EACH_FRAME) {

            // Not the same as last time.
            
            _im = im;
            _creationID = _im->GetCreationID();

            GetRenderDimensions(im, &_w, &_h);
            
            DWORD ck;
            bool  junk1;
            bool  junk2;
            bool  doFitToDimensions = true;

            if (_ddsurface && _lastSurfFromPool) {
                // Put old surface back on pool to be picked up
                // again. 
                sourcePool->AddSurface(_ddsurface);
            }
                    
            DDSurfPtr<DDSurface> dds;

            DDSurface *result =
                dev->RenderImageForTexture(im, _w, _h,
                                           &ck, &junk1, junk2,
                                           doFitToDimensions,
                                           sourcePool,
                                           NULL,
                                           _ddsurface,
                                           &_lastSurfFromPool,
                                           &dds,
                                           false);

            // If *either* the DDSurface is the same, or the
            // underlying IDirectDrawSurface is the same, just
            // increment the generation id.  Note that the
            // IDirectDrawSurface might be the same without the
            // ddsurface being the same if someone uses a new
            // DDSurface with the same underlying IDirectDrawSurface.
            // Trident3D does this with HTML textures and animated
            // GIFs.
            
            if (dds == _ddsurface ||
                (_ddsurface &&
                 (dds->IDDSurface_IUnk() == _ddsurface->IDDSurface_IUnk()))) { 

                // Only relevant if dds==_ddsurface
                Assert(dds->IDDSurface_IUnk() ==
                       _ddsurface->IDDSurface_IUnk());

                if (dds != _ddsurface) {
                    // Underlying IDirectDrawSurface's are the same,
                    // but ddsurf's aren't, so release the old and keep
                    // the new..
                    _ddsurface.Release();
                    _ddsurface = dds;
                }
                
                // depending on the nature of the surface pools, this
                // may be the same surface used as last time.  In this
                // case, that's fine, and we bump the gen id on the
                // dxsurface.
                _dxsurf->IncrementGenerationId(true);
                
            } else {

                // otherwise, replace members with new ones.
                
                _ddsurface.Release();
                _ddsurface = dds;

                // This is HACK and should be pulled once we correct the TODO in ddsurf.cpp _INIT(
                if(dds->ColorKeyIsValid()) {
                    DWORD key = dds->ColorKey();
                    dds->UnSetColorKey();
                    dds->SetColorKey(key);
                }
                // end of HACK

                _iddsurf.Release();
                _iddsurf = dds->IDDSurface();

                _dxsurf.Release();
                HRESULT hr = f->CreateFromDDSurface(_iddsurf,
                                                    NULL,
                                                    0,
                                                    NULL,
                                                    IID_IDXSurface,
                                                    (void **)&_dxsurf);

                if (SUCCEEDED(hr)) {
                    // Label with input number
                    hr = _dxsurf->SetAppData(inputNumber);
                }
                    
                if (FAILED(hr)) {
                    RaiseException_InternalError("Creation of DXSurf failed");
                }

            }

        }
    }

    IUnknown *GetUnknown() {
        _dxsurf->AddRef();
        return _dxsurf;
    }

    void GetDimensions(unsigned short *pW, unsigned short *pH) {
        *pW = _w;
        *pH = _h;
    }

    Image                        *_im;
    long                          _creationID;
    DDSurfPtr<DDSurface>          _ddsurface;
    DAComPtr<IDirectDrawSurface>  _iddsurf;
    DAComPtr<IDXSurface>          _dxsurf;
    bool                          _lastSurfFromPool;
    unsigned short                _w, _h;
};

class InputBundle {
  public:
    // Note that ideally these would be a union, but we can't get that
    // to work, presumably because they contain DAComPtr's which have
    // destructors, and that would be ambiguous.  In the meantime,
    // just keep both around.  Doesn't waste too much space.
    GeometryInputBundle    _geoBundle;
    ImageAsDXSurfaceBundle _imgBundle;
};

class ApplyDXTransformBvrImpl;

class MyDeletionNotifier : public SurfacePool::DeletionNotifier {
  public:
    MyDeletionNotifier(ApplyDXTransformBvrImpl &bvr) : _bvr(bvr) {}
    
    void Advise(SurfacePool *pool);

  protected:
    ApplyDXTransformBvrImpl &_bvr;
};

class ApplyDXTransformBvrImpl : public BvrImpl {
  public:
    ApplyDXTransformBvrImpl(IDXTransform *theXf,
                            IDispatch *theXfAsDispatch,
                            LONG numInputs,
                            Bvr *inputBvrs,
                            Bvr  evaluator);

    ~ApplyDXTransformBvrImpl();

    void Init();

    // Custom methods for this subclass of BvrImpl
    HRESULT AddBehaviorProperty(BSTR property,
                                Bvr  bvrToAdd);

    // Standard methods
    virtual Perf _Perform(PerfParam& p);
    virtual void _DoKids(GCFuncObj proc);
    virtual DWORD GetInfo(bool recalc);
        

    virtual DXMTypeInfo GetTypeInfo () { return _outputType; }
    virtual AxAValue GetConst(ConstParam & cp);

    SurfacePool *GetSurfacePool(DirectDrawImageDevice *dev) {
        
        if (!_surfPool) {
            _surfPool = dev->_freeTextureSurfacePool;
            _surfPool->RegisterDeletionNotifier(&_poolDeletionNotifier);
        }

        if (dev->_freeTextureSurfacePool != _surfPool) {
            RaiseException_InternalError(
                "Uggh!! Transforms can only currently be used on one device");
        }
        
        return _surfPool;
    }

    // Keeping all this member data public, since it's only used by
    // code in this file.
    
    DAComPtr<IDXTransform>              _theXf;
    DAComPtr<IDispatch>                 _theXfAsDispatch;
    DAComPtr<IDXEffect>                 _theXfAsEffect;
    DAComPtr<IDirect3DRMExternalVisual> _theXfAsExternalVisual;
    DAComPtr<IDXSurfacePick>            _theXfAs2DPickable;
    
    DAComPtr<IDirect3DRMFrame3>         _framedExternalVisual;
    
    LONG                   _numInputs;
    Bvr                   *_inputBvrs;
    DXMTypeInfo            _inputTypes[MAX_INPUTS];
    DXMTypeInfo            _outputType;

    InputBundle            _inputBundles[MAX_INPUTS];
    
    Bvr                    _evaluator;
    DWORD                  _miscFlags;
    bool                   _miscFlagsValid;
    IUnknown              *_cachedInputs[MAX_INPUTS_TO_CACHE];
    IUnknown              *_cachedOutput;
    bool                   _neverSetup;

    // Only one of these will be valid, depending on the output type
    // of the behavior.  Note that we *don't* keep a reference for
    // this guy, since we know that _cachedOutput has one.
    union {
        IDirect3DRMMeshBuilder3 *_cachedOutputAsBuilder;
        // Put other type-specific possibilities here as they're
        // needed.  
    };

    // For image producing transforms only
    short                  _cachedSurfWidth;
    short                  _cachedSurfHeight;
    DDSurfPtr<DDSurface>   _cachedDDSurf;

    // Lists additional behaviors being used as parameters.
    LONG                   _numParams;
    DISPID                 _paramDispids[MAX_PARAM_BVRS];
    Bvr                    _paramBvrs[MAX_PARAM_BVRS];
    ULONG                  _previousAge;

    // Just need at most one of these.  We protect construction and
    // destruction of this with a critical section.
    IDXTransformFactory *_transformFactory;
    IDXSurfaceFactory   *_surfaceFactory;
    DWORD                  _info;

    SurfacePool       *_surfPool;
    MyDeletionNotifier _poolDeletionNotifier;
    bool               _surfPoolHasBeenDeleted;

  protected:
    // For things we really know aren't needed beyond this class...

    void ValidateInputs(bool *pInvolvesGeometry,
                        bool *pInvolvesImage);
    void InitializeTransform(bool involvesGeometry,
                             bool involvesImage);
    void QueryForAdditionalInterfaces();

};


void
MyDeletionNotifier::Advise(SurfacePool *pool)
{
    // Surface pool is going away... mark it as such in the behavior.
    // Note that the surfacemgr crit sect is held here.
    Assert(_bvr._surfPool == pool);
    _bvr._surfPoolHasBeenDeleted = true;
    _bvr._surfPool = NULL;

    // Go through and release out the ddsurf ptrs since the holding pool
    // is gone, and thus the surfaces are too.  They won't need to be
    // accessed again.  If we delayed release until the image bundle
    // went away, then the ddraw stuff would be gone, and we'd crash. 
    for (int i = 0; i < _bvr._numInputs; i++) {
        _bvr._inputBundles[i]._imgBundle._ddsurface.Release();
    }
    
}



////////////// Input processing utility /////////////////

IUnknown **
ProcessInputs(ApplyDXTransformBvrImpl &xf,
              AxAValue                *vals,
              DirectDrawImageDevice   *imgDev)
{
    IUnknown **rawInputs = THROWING_ARRAY_ALLOCATOR(LPUNKNOWN, xf._numInputs);

    for (int i = 0; i < xf._numInputs; i++) {
        if (vals[i] == NULL) {
      
            rawInputs[i] = NULL;
      
        } else {

            if (xf._inputTypes[i] == GeometryType) {
                Geometry *geo = SAFE_CAST(Geometry *, vals[i]);
                xf._inputBundles[i]._geoBundle.Validate(geo,
                                                        imgDev);

                rawInputs[i] =
                    xf._inputBundles[i]._geoBundle.GetUnknown();
                
            } else if (xf._inputTypes[i] == ImageType) {
                
                Image *im = SAFE_CAST(Image *, vals[i]);

                xf._inputBundles[i]._imgBundle.Validate(
                    im,
                    imgDev,
                    xf._surfaceFactory,
                    xf.GetSurfacePool(imgDev),
                    i+1);

                rawInputs[i] = xf._inputBundles[i]._imgBundle.GetUnknown();

#if _DEBUG
                if ((IsTagEnabled(tagDXTransformsImg0) && i == 0) ||
                    (IsTagEnabled(tagDXTransformsImg1) && i == 1)) {

                    showme2(xf._inputBundles[i]._imgBundle._iddsurf);
                    
                }
#endif _DEBUG           

            }
        }
    }

    // Finally, return our successful output
    return rawInputs;
}

////////////// Bounds calculation utility /////////////////

// Calculate bounds of output (either 2D or 3D) from bounds of inputs
// by calling MapBoundsIn2Out.
void
CalcBounds(ApplyDXTransformBvrImpl &xf, // input
           AxAValue                *vals, // input
           DXBNDS                  *pOutputBounds)
{    
    DXBNDS inputBounds[MAX_INPUTS];

    bool haveAGeometryInput = false;

        // Zero the array of bounds information...
    ZeroMemory(inputBounds, sizeof(inputBounds[0]) * MAX_INPUTS);

    for (int i = 0; i < xf._numInputs; i++) {

        if (xf._inputTypes[i] == GeometryType) {

            haveAGeometryInput = true;

            inputBounds[i].eType = DXBT_CONTINUOUS;
            DXCBND *bnd = inputBounds[i].u.C;

            if (vals[i]) {
                Geometry *geo = SAFE_CAST(Geometry *, vals[i]);
                Bbox3 *result = geo->BoundingVol();
                Point3Value& pMin = result->min;
                Point3Value& pMax = result->max;
                
                // The following will be the case if there's an empty
                // geometry. 
                if (pMin.x > pMax.x || pMin.y > pMax.y || pMin.z > pMax.z) {

                    bnd[0].Min = bnd[1].Min =
                        bnd[2].Min = bnd[0].Max =
                        bnd[1].Max = bnd[2].Max = 0.0;
                
                } else {
                
                    bnd[0].Min = pMin.x;
                    bnd[1].Min = pMin.y;
                    bnd[2].Min = pMin.z;
                    bnd[0].Max = pMax.x;
                    bnd[1].Max = pMax.y;
                    bnd[2].Max = pMax.z;
                
                }
                
            } else {
                memset(bnd, 0, sizeof(DXCBND)*4);
            }
                
        } else if (xf._inputTypes[i] == ImageType) {

            // Give image resolution as discrete pixels.
            inputBounds[i].eType = DXBT_DISCRETE;
            DXDBND *bnd = inputBounds[i].u.D;

            if (vals[i]) {
                
                bnd[0].Min = 0;
                bnd[1].Min = 0;

                Image *im = SAFE_CAST(Image *, vals[i]);
                unsigned short w, h;
                GetRenderDimensions(im, &w, &h);
                bnd[0].Max = w;
                bnd[1].Max = h;

            } else {
                memset(bnd, 0, sizeof(DXDBND)*4);
            }

        }
    }

        
    HRESULT hr =
        TIME_DXXFORM(
            xf._theXf->MapBoundsIn2Out(inputBounds,
                                       xf._numInputs,
                                       0,
                                       pOutputBounds));

    // Aargh!! This is only here because not all xforms report their
    // bounds.
    if (FAILED(hr)) {
    
        // TODO: HACKHACK temporary, last minute beta1 workaround for
        // 19448 until DXTransforms actually implement MapBoundsIn2Out
        // correctly.  Just take input bounds, and scale up by some
        // factor. 

        // Need to zero out the structure to take care of values we might
        // not set.
        ZeroMemory(pOutputBounds, sizeof(DXBNDS));

        if (haveAGeometryInput && xf._numInputs == 1) {
        
            const float hackScaleAmt = 10.0;
            (*pOutputBounds).eType = DXBT_CONTINUOUS;
            DXCBND *outBnd = (*pOutputBounds).u.C;
            DXCBND *inBnd = inputBounds[0].u.C;

            double mid, half, halfScaled;
        
            mid = inBnd[0].Min + (inBnd[0].Max - inBnd[0].Min) / 2;
            half = inBnd[0].Max - mid;
            halfScaled = half * hackScaleAmt;
            outBnd[0].Min = mid - halfScaled;
            outBnd[0].Max = mid + halfScaled;
        
            mid = inBnd[1].Min + (inBnd[1].Max - inBnd[1].Min) / 2;
            half = inBnd[1].Max - mid;
            halfScaled = half * hackScaleAmt;
            outBnd[1].Min = mid - halfScaled;
            outBnd[1].Max = mid + halfScaled;
        
            mid = inBnd[2].Min + (inBnd[2].Max - inBnd[2].Min) / 2;
            half = inBnd[2].Max - mid;
            halfScaled = half * hackScaleAmt;
            outBnd[2].Min = mid - halfScaled;
            outBnd[2].Max = mid + halfScaled;
        
        } else {

            // If not a single input geo, just make up some bounds
            (*pOutputBounds).eType = DXBT_CONTINUOUS;
            DXCBND *outBnd = (*pOutputBounds).u.C;
            outBnd[0].Min = outBnd[1].Min = outBnd[2].Min = -10.0;
            outBnd[0].Max = outBnd[1].Max = outBnd[2].Max =  10.0;
            //RaiseException_UserError(E_FAIL, IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
        }
    }
        
}
                
const Bbox2
BNDSToBBox2(DXBNDS &bnds)
{
    double minx, maxx, miny, maxy;
    DXCBND *cbnd;
    DXDBND *dbnd;
            
    switch (bnds.eType) {

      case DXBT_CONTINUOUS:
        cbnd = bnds.u.C;
        minx = cbnd[0].Min;
        miny = cbnd[1].Min;

        maxx = cbnd[0].Max;
        maxy = cbnd[1].Max;
        break;

      case DXBT_DISCRETE:

        {
            // When the bounds are discrete, assume they have their origin
            // at the lower left and are in pixels.  In this case, we need
            // to convert to meters and center.
            dbnd = bnds.u.D;
            Assert(dbnd[0].Min == 0.0);
            Assert(dbnd[1].Min == 0.0);

            maxx = dbnd[0].Max;
            maxy = dbnd[1].Max;

            Real twiceRes = 2.0 * ::ViewerResolution();
            maxx /= twiceRes;
            maxy /= twiceRes;

            minx = -maxx;
            miny = -maxy;
        }
        
        break;

      default:
        RaiseException_UserError(E_FAIL, IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
        break;
    }

    return Bbox2(minx, miny, maxx, maxy);
}

Bbox3 *
BNDSToBBox3(DXBNDS &bnds)
{
    double minx, maxx, miny, maxy, minz, maxz;
    DXCBND *cbnd;
    DXDBND *dbnd;
            
    switch (bnds.eType) {

      case DXBT_CONTINUOUS:
        cbnd = bnds.u.C;
        minx = cbnd[0].Min;
        miny = cbnd[1].Min;
        minz = cbnd[2].Min;

        maxx = cbnd[0].Max;
        maxy = cbnd[1].Max;
        maxz = cbnd[2].Max;
        break;

      case DXBT_DISCRETE:

        {
            // When the bounds are discrete, assume they have their origin
            // at the lower left and are in pixels.  In this case, we need
            // to convert to meters and center.
            dbnd = bnds.u.D;
            Assert(dbnd[0].Min == 0.0);
            Assert(dbnd[1].Min == 0.0);
            Assert(dbnd[2].Min == 0.0);

            maxx = dbnd[0].Max;
            maxy = dbnd[1].Max;
            maxz = dbnd[2].Max;

            Real twiceRes = 2.0 * ::ViewerResolution();
            maxx /= twiceRes;
            maxy /= twiceRes;
            maxz /= twiceRes;

            minx = -maxx;
            miny = -maxy;
            minz = -maxz;
        }
        
        break;

      default:
        RaiseException_UserError(E_FAIL, IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
        break;
    }

    return NEW Bbox3(minx, miny, minz, maxx, maxy, maxz);
}

void
CalcBoundsToBbox2(ApplyDXTransformBvrImpl &xf, // input
                 AxAValue                *vals, // input
                 Bbox2     &bbox2Out)  // output
{
    DXBNDS outputBounds;
    CalcBounds(xf, vals, &outputBounds);
    bbox2Out = BNDSToBBox2(outputBounds);
}

void
CalcBoundsToBbox3(ApplyDXTransformBvrImpl &xf, // input
                 AxAValue                *vals, // input
                 Bbox3     **ppBbox3Out)  // output
{
    DXBNDS outputBounds;
    CalcBounds(xf, vals, &outputBounds);
    *ppBbox3Out = BNDSToBBox3(outputBounds);
}

////////////// ApplyDXTransformGeometry Subclass /////////////////

class CtxAttrStatePusher {
  public:
    CtxAttrStatePusher(GeomRenderer &dev) : _dev(dev) {
        _dev.PushAttrState();
    }

    ~CtxAttrStatePusher() {
        _dev.PopAttrState();
    }

  protected:
    GeomRenderer &_dev;
};

class ApplyDXTransformGeometry : public Geometry {
  public:

    ApplyDXTransformGeometry(ApplyDXTransformBvrImpl *xfBvr,
                             AxAValue                *vals) {
        
        _xfBvr = xfBvr;
        _vals = vals;
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_xfBvr);
        for (int i = 0; i < _xfBvr->_numInputs; i++) {
            (*proc)(_vals[i]);
        }
    }

    // Collect up all the lights, sounds, and textures from the input
    // geometries.
    void  CollectLights(LightContext &context) {
        for (int i = 0; i < _xfBvr->_numInputs; i++) {
            if (_xfBvr->_inputTypes[i] == GeometryType) {
                Geometry *g = SAFE_CAST(Geometry *, _vals[i]);
                g->CollectLights(context);
            }
        }
    }

    void  CollectSounds(SoundTraversalContext &context) {
        for (int i = 0; i < _xfBvr->_numInputs; i++) {
            if (_xfBvr->_inputTypes[i] == GeometryType) {
                Geometry *g = SAFE_CAST(Geometry *, _vals[i]);
                g->CollectSounds(context);
            }
        }
    }

    void  CollectTextures(GeomRenderer &device) {
        for (int i = 0; i < _xfBvr->_numInputs; i++) {
            if (_xfBvr->_inputTypes[i] == GeometryType) {
                Geometry *g = SAFE_CAST(Geometry *, _vals[i]);
                g->CollectTextures(device);
            }
        }
    }
    
    void  RayIntersect (RayIntersectCtx &context) {

        if (context.LookingForSubmesh()) {

            // Picking into the inputs of the transform
            for (int i = 0; i < _xfBvr->_numInputs; i++) {
                if (_xfBvr->_inputTypes[i] == GeometryType) {
                    Geometry *geo =
                        SAFE_CAST(Geometry *, _vals[i]);

                    if (geo) {
                        geo->RayIntersect(context);
                    }
                    
                }
            }
            
        } else if (_xfBvr->_cachedOutput) {
            
            // Do this only if our bvr's output is valid.
            context.SetDXTransformInputs(_xfBvr->_numInputs,
                                         _vals,
                                         this);

            context.Pick(_xfBvr->_cachedOutputAsBuilder);
            
            context.SetDXTransformInputs(0, NULL, NULL);

        }
        
    }

    // Produces a printed representation on the debugger.
#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "ApplyDXTransformGeometry";
    }
#endif

    Bbox3 *BoundingVol() {

        // For transforms that take all geometries in, create empty
        // meshbuilder inputs and do a single setup/execute if we've
        // never been setup before.  Otherwise, the transforms may not
        // be able to compute the bounds correctly.
        if (_xfBvr->_neverSetup) {
            
            bool allGeo = true;
            int i;
            for (i = 0; i < _xfBvr->_numInputs && allGeo; i++) {
                if (_xfBvr->_inputTypes[i] != GeometryType) {
                    allGeo = false;
                }
            }

            IUnknown *rawInputs[MAX_INPUTS];
            
            if (allGeo) {
                for (i = 0; i < _xfBvr->_numInputs; i++) {
                    IDirect3DRMMeshBuilder3 *mb;
                    TD3D(GetD3DRM3()->CreateMeshBuilder(&mb));
                    TD3D(mb->QueryInterface(IID_IUnknown,
                                            (void **)&rawInputs[i]));
                    RELEASE(mb);
                }

                IDirect3DRMMeshBuilder3 *outputBuilder;
                
                HRESULT hr =
                    DXXFSetupAndExecute(_xfBvr,
                                        rawInputs,
                                        IID_IDirect3DRMMeshBuilder3,
                                        NULL, 0, 0,
                                        false,
                                        false,
                                        (void **)&outputBuilder);

                for (i = 0; i < _xfBvr->_numInputs; i++) {
                    RELEASE(rawInputs[i]);
                }

                RELEASE(outputBuilder);
            }
        }
        
        Bbox3 *pBbox3;
        CalcBoundsToBbox3(*_xfBvr, _vals, &pBbox3);
        return pBbox3;
    }

    void Render(GenericDevice& genDev) {

        GeomRenderer& geomRenderer = SAFE_CAST(GeomRenderer&, genDev);

        if (geomRenderer.CountingPrimitivesOnly_DoIncrement()) {
            return;
        }
        
        ApplyDXTransformBvrImpl& x = *_xfBvr;
        DirectDrawImageDevice& imgDev = geomRenderer.GetImageDevice();

        // Do things differently based on number and types of inputs.
        IUnknown **rawInputs = ProcessInputs(x, _vals, &imgDev);

        bool topOfChain = !geomRenderer.IsMeshmaker();
        bool invokeAsExternalVisual =
            x._theXfAsExternalVisual && topOfChain;

        if (rawInputs) {
            IDirect3DRMMeshBuilder3 *outputBuilder;

            HRESULT hr = DXXFSetupAndExecute(_xfBvr,
                                             rawInputs,
                                             IID_IDirect3DRMMeshBuilder3,
                                             NULL, 0, 0,
                                             invokeAsExternalVisual,
                                             true,
                                             (void **)&outputBuilder);


            for (int i = 0; i < x._numInputs; i++) {
                RELEASE(rawInputs[i]);
            }
                
            delete [] rawInputs;

            if (SUCCEEDED(hr)) {
                if (invokeAsExternalVisual) {

                    // If we haven't put the extvis in a frame yet,
                    // then do so, and keep it around.  Otherwise, RM
                    // ends up re-initializing the extvis all the
                    // time. 
                    if (!x._framedExternalVisual) {
                        
                        TD3D(GetD3DRM3()->
                               CreateFrame(NULL,
                                           &x._framedExternalVisual));

                        TD3D(x._framedExternalVisual->
                               AddVisual(x._theXfAsExternalVisual));
                        
                    }

                    
                    // Submit the external visual to the renderer directly.

                    RM3FrameGeo *extVisGeo =
                        NEW RM3FrameGeo (x._framedExternalVisual);

                    geomRenderer.Render(extVisGeo);

                    extVisGeo->CleanUp();    // Done with the frame geo.
                    
                } else {
                    geomRenderer.RenderMeshBuilderWithDeviceState(outputBuilder);
                    RELEASE(outputBuilder);
                }
            } else {
                RaiseException_UserError(E_FAIL, IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
            }
          
        }
    }

    VALTYPEID GetValTypeId() { return DXXFGEOM_VTYPEID; }
    
  protected:
    ApplyDXTransformBvrImpl *_xfBvr;
    AxAValue                *_vals;
};

////////////// ApplyDXTransformImage Subclass /////////////////



class ApplyDXTransformImage : public Image {


  public:
    ApplyDXTransformImage(ApplyDXTransformBvrImpl *xfBvr,
                          AxAValue                *vals) {
        
        _xfBvr = xfBvr;
        _vals = vals;
    }

    virtual void DoKids(GCFuncObj proc) {
        Image::DoKids(proc);
        (*proc)(_xfBvr);
        for (int i = 0; i < _xfBvr->_numInputs; i++) {
            (*proc)(_vals[i]);
        }
    }

    virtual const Bbox2 BoundingBox(void) {
        Bbox2 bbox2;
        CalcBoundsToBbox2(*_xfBvr, _vals, bbox2);
        return bbox2;
    }

#if BOUNDINGBOX_TIGHTER
    virtual const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
#error "Fill in"
    }
#endif  // BOUNDINGBOX_TIGHTER

    virtual const Bbox2 OperateOn(const Bbox2 &box) {
        return box;
    }

    // Helper to just pick against the output surface if there is
    // one. 
    Bool PickOutputSurf(PointIntersectCtx& ctx) {
        Bool result = FALSE;
        
        if (_xfBvr->_cachedDDSurf) {

            // Image will not be used immediately after we're done
            // here, so don't worry about releasing it.
            Image *tmpImg =
                ConstructDirectDrawSurfaceImageWithoutReference(
                    _xfBvr->_cachedDDSurf->IDDSurface());

            result = tmpImg->DetectHit(ctx);

        }

        TraceTag((tagDXTransformTracePick,
                  "Picking against output surf = %s",
                  result ? "TRUE" : "FALSE"));
            
        return result;
    }
    
    // Process an image for hit detection.  TODO: Need to ask the
    // DXTransform about this... this is logged as bug 12755 against
    // DXTransforms.  For now, just return false.
    virtual Bool  DetectHit(PointIntersectCtx& ctx) {

        HRESULT hr;
        
        Bool result = FALSE;
        
        // If we don't know how to pick into a 2D xform, then we have
        // to consider it unpicked, and just try to pick the output. 
        if (!_xfBvr->_theXfAs2DPickable) {

            result = PickOutputSurf(ctx);

        } else if (_xfBvr->_cachedDDSurf) {

            // Pick into the transform's inputs.

            // First transform the input point to the space of the
            // transform.
            Assert(_xfBvr->_cachedSurfHeight != -1);
            Assert(_xfBvr->_cachedSurfWidth != -1);
            Point2Value *outputHitDaPoint = ctx.GetLcPoint();

            // singular transform 
            if (!outputHitDaPoint)
                return FALSE;    
            
            POINT   outputHitGdiPoint;
            CenteredImagePoint2ToPOINT(outputHitDaPoint,
                                       _xfBvr->_cachedSurfWidth,
                                       _xfBvr->_cachedSurfHeight,
                                       &outputHitGdiPoint);

            DXVEC dxtransPtOnOutput, dxtransPtOnInput;
            ULONG inputSurfaceIndex;

            dxtransPtOnOutput.eType = DXBT_DISCRETE;
            dxtransPtOnOutput.u.D[0] = outputHitGdiPoint.x;
            dxtransPtOnOutput.u.D[1] = outputHitGdiPoint.y;
            dxtransPtOnOutput.u.D[2] = 0;
            dxtransPtOnOutput.u.D[3] = 0;
            
            hr = TIME_DXXFORM(_xfBvr->_theXfAs2DPickable->
                                  PointPick(&dxtransPtOnOutput,
                                            &inputSurfaceIndex,
                                            &dxtransPtOnInput));

            TraceTag((tagDXTransformTracePick,
                      "Image picked into DA point (%8.5f,%8.5f) == DXT point (%d, %d).  HRESULT is 0x%x",
                      outputHitDaPoint->x,
                      outputHitDaPoint->y,
                      outputHitGdiPoint.x,
                      outputHitGdiPoint.y,
                      hr));

            switch (hr) {
              case S_OK:

                // Now we know which input was hit, and where that
                // input was hit.  Convert back to DA coordinates, and
                // continue traversing.
                if (inputSurfaceIndex < _xfBvr->_numInputs) {

                    AxAValue v = _vals[inputSurfaceIndex];
                    if (v->GetTypeInfo() == ImageType) {

                        Image *inputIm = SAFE_CAST(Image *, v);

                        POINT  inputHitGdiPoint;

                        Assert(dxtransPtOnInput.eType == DXBT_DISCRETE);
                        inputHitGdiPoint.x = dxtransPtOnInput.u.D[0];
                        inputHitGdiPoint.y = dxtransPtOnInput.u.D[1];

                        unsigned short w, h;
                        _xfBvr->
                            _inputBundles[inputSurfaceIndex].
                            _imgBundle.GetDimensions(&w, &h);

                        Point2Value inputHitDaPoint;
                        CenteredImagePOINTToPoint2(&inputHitGdiPoint,
                                                   w,
                                                   h,
                                                   inputIm,
                                                   &inputHitDaPoint);

                        TraceTag((tagDXTransformTracePick,
                                  "Hit input surface %d at DXT point (%d, %d) == DA point (%8.5f, %8.5f)",
                                  inputSurfaceIndex,
                                  inputHitGdiPoint.x,
                                  inputHitGdiPoint.y,
                                  inputHitDaPoint.x,
                                  inputHitDaPoint.y));

                        // Grab and stash current traversal data.  We
                        // basically reset our pick context's info to
                        // pick in the world coordinates of the input
                        // image, then reset our state back.
                        
                        Point2Value *stashedPoint = ctx.GetWcPoint();
                        Transform2 *stashedXf = ctx.GetTransform();
                        Transform2 *stashedImgXf = ctx.GetImageOnlyTransform();

                        // It's possible that the input image will
                        // have a huge coordinate system.  If this is
                        // the case, the conversion to GDI will result
                        // in out of range values.
                        // Thus, scale down both the image and the
                        // pick point by an equivalent amount.  Map to
                        // what would be 512 pixels on the longer
                        // side.

                        const int destPixelDim = 512;
                        Bbox2 origBox = inputIm->BoundingBox();

                        Real origH = origBox.max.y - origBox.min.y;
                        Real origW = origBox.max.x - origBox.min.x;

                        Real centerX = origBox.min.x + origW / 2.0;
                        Real centerY = origBox.min.y + origH / 2.0;

                        Real srcDim = origH > origW ? origH : origW;
                        Real dstDim =
                            (Real)(destPixelDim) / ViewerResolution();

                        Real scaleFac = dstDim / srcDim;

                        Image *imToUse = inputIm;

                        // Only need to scale if we would be scaling
                        // down.  ScaleFacs >= 1 mean that the image
                        // will work fine as it is.
                        if (scaleFac < 1) {

                            Image *centeredIm =
                                TransformImage(TranslateRR(-centerX, -centerY),
                                               imToUse);

                            Image *scaledIm =
                                TransformImage(ScaleRR(scaleFac, scaleFac),
                                               centeredIm);

                            imToUse = scaledIm;

                            // Translate the hit point similarly.
                            inputHitDaPoint.x -= centerX;
                            inputHitDaPoint.y -= centerY;
                            
                            // Scale the input hit point down similarly. 
                            inputHitDaPoint.x *= scaleFac;
                            inputHitDaPoint.y *= scaleFac;

                        }
                        
                        ctx.PushNewLevel(&inputHitDaPoint);

                        result = imToUse->DetectHit(ctx);

                        ctx.RestoreOldLevel(stashedPoint,
                                            stashedXf,
                                            stashedImgXf);

                    }

                }
                break;

              case DXT_S_HITOUTPUT:
                // Didn't hit the inputs, but the output was hit.
                TraceTag((tagDXTransformTracePick, "Got DXT_S_HITOUTPUT"));
                result = TRUE;
                break;

              case S_FALSE:
                // Didn't hit anything.
                TraceTag((tagDXTransformTracePick, "Got S_FALSE"));
                result = FALSE;
                break;

              case E_NOTIMPL:
                // Transform may say this isn't implemented.  In this
                // case, just pick the output surface.
                TraceTag((tagDXTransformTracePick, "Got E_NOTIMPL"));
                result = PickOutputSurf(ctx);
                break;
                
              default:
                // unexpected hr.
                TraceTag((tagDXTransformTracePick, "Got unexpected result"));
                RaiseException_UserError(E_FAIL,
                                         IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
                break;
            }

        } else {

            // No output surface, can't do any picking.
        }

        return result;
    }

    void Render(GenericDevice& genDev) {

        HRESULT hr;

        DirectDrawImageDevice *dev =
            SAFE_CAST(DirectDrawImageDevice *, &genDev);

        DirectDrawViewport &viewport = dev->_viewport;

        IUnknown **rawInputs = ProcessInputs(*_xfBvr, _vals, dev);

        DXBNDS outputBounds;
        CalcBounds(*_xfBvr, _vals, &outputBounds);

        Assert(outputBounds.eType == DXBT_DISCRETE);
        DXDBND *dbnd = outputBounds.u.D;

        int resultWidth = dbnd[0].Max;
        int resultHeight = dbnd[1].Max;

        DAComPtr<IDirectDrawSurface> outputSurf;
        hr = DXXFSetupAndExecute(_xfBvr,
                                 rawInputs,
                                 IID_IDirectDrawSurface,
                                 &viewport,
                                 resultWidth,
                                 resultHeight,
                                 false,
                                 true,
                                 (void **)&outputSurf);

#if _DEBUG
        if (IsTagEnabled(tagDXTransformsImgOut)) {
            showme2(outputSurf);
        }
#endif _DEBUG   

        for (int i = 0; i < _xfBvr->_numInputs; i++) {
            RELEASE(rawInputs[i]);
        }
                
        delete [] rawInputs;

        if (SUCCEEDED(hr)) {
            
            Image *tmpImg;

            #if _DEBUG
            if(IsTagEnabled(tagDXTransformPerPixelAlphaOutputOff)) {
                tmpImg =
                    ConstructDirectDrawSurfaceImageWithoutReference(
                        _xfBvr->_cachedDDSurf->IDDSurface());
            } else 
            #endif
              {
                  // give it the iddsurface and the idxsurface
                  tmpImg =
                      ConstructDirectDrawSurfaceImageWithoutReference(
                          _xfBvr->_cachedDDSurf->IDDSurface(),
                          _xfBvr->_cachedDDSurf->GetIDXSurface(_xfBvr->_surfaceFactory));
              }
            
            tmpImg->Render(genDev);

        } else {

            RaiseException_UserError(E_FAIL, IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
            
        }

        // output surf released on exit
    }   


    // Print a representation to a stream.
#if _USE_PRINT
    virtual ostream& Print(ostream& os) {
        return os << "ApplyDXTransformImage";
    }
#endif

    // Ok, we can cache these, but now we're supporting per pixel
    // alpha output on dxtransforms.  which means... no more caching,
    // sorry.  Also, there's a bug with caching dxtransforms.  has to
    // do with dimensions.  
    virtual int Savings(CacheParam&) { return 0; }

  protected:
    ApplyDXTransformBvrImpl     *_xfBvr;
    AxAValue                    *_vals;
};





////////////// Performance //////////////////

// Helper function just sets a dispatch-property to a specified
// value.
HRESULT PutProperty(IDispatch *pDisp,
                    DISPID dispid,
                    AxAValue val)
{
    DISPID propPutDispid = DISPID_PROPERTYPUT;
    DISPPARAMS dispparams;
    VARIANTARG varArg;
    ::VariantInit(&varArg); // Initialize the VARIANT

    dispparams.rgvarg = &varArg;
    dispparams.rgdispidNamedArgs = &propPutDispid;
    dispparams.cArgs = 1;
    dispparams.cNamedArgs = 1;
            
    DXMTypeInfo ti = val->GetTypeInfo();
    if (ti == AxANumberType) {

        double num = ValNumber(val);
                
        dispparams.rgvarg[0].vt = VT_R4;
        dispparams.rgvarg[0].fltVal = num;

        TraceTag((tagDXTransforms,
                  "Setting dispid %d to floating point %8.3f",
                  dispid,
                  num));

    } else if (ti == AxAStringType) {

        WideString wstr = ValString(val);

        dispparams.rgvarg[0].vt = VT_BSTR;
        dispparams.rgvarg[0].bstrVal = SysAllocString(wstr);

        TraceTag((tagDXTransforms,
                  "Setting dispid %d to string %ls",
                  dispid,
                  wstr));
                        
    } else if (ti == AxABooleanType) {

        BOOL bval = BooleanTrue(val);
    
        dispparams.rgvarg[0].vt = VT_BOOL;
        dispparams.rgvarg[0].boolVal = (VARIANT_BOOL)bval;
        
    } else {
        // Shouldn't get here.  Type mismatch should have been
        // caught upon construction of the behavior. 
        Assert(!"Shouldn't be here... ");
    }

    HRESULT hr = pDisp->Invoke(dispid,
                               IID_NULL,
                               LOCALE_SYSTEM_DEFAULT,
                               DISPATCH_PROPERTYPUT,
                               &dispparams,
                               NULL,
                               NULL,
                               NULL);

    TraceTag((tagDXTransforms,
              "Invoke resulted in %hr",
              hr));

    // need to free the information that we put into dispparams
    if(dispparams.rgvarg[0].vt == VT_BSTR) {
        SysFreeString(dispparams.rgvarg[0].bstrVal); 
    }
    ::VariantClear(&varArg); // clears the CComVarient

    return hr;
}

AxAValue
ConstructAppropriateDXTransformStaticValue(ApplyDXTransformBvrImpl *bvr,
                                           AxAValue                *vals) {
    AxAValue result;

    if (bvr->_outputType == ImageType) {
        result = NEW ApplyDXTransformImage(bvr, vals);
    } else if (bvr->_outputType == GeometryType) {
        result = NEW ApplyDXTransformGeometry(bvr, vals);
    } else {
        Assert(!"Unsupported output type for DXTransforms");
    }
    
    return result;
}
                                               
class ApplyDXTransformPerfImpl : public PerfImpl {
  public:
    ApplyDXTransformPerfImpl(PerfParam& pp,
                             ApplyDXTransformBvrImpl *bvr,
                             Perf *inputPerfs,
                             long  numParams,
                             Perf *paramPerfs,
                             Perf  evalPerf) {
        _tt = pp._tt;
        _bvr = bvr;
        _inputPerfs = inputPerfs;
        _evalPerf = evalPerf;

        Assert(numParams < MAX_PARAM_BVRS);
        for (int i = 0; i < MAX_PARAM_BVRS; i++) {

            if (i < numParams) {
                _paramPerfsInThisPerf[i] = paramPerfs[i];
            } else {
                _paramPerfsInThisPerf[i] = NULL;
            }
            
        }

    }

    ~ApplyDXTransformPerfImpl() {
        StoreDeallocate(GetSystemHeap(), _inputPerfs);
    }

    virtual AxAValue _GetRBConst(RBConstParam& rbp) {

        rbp.AddChangeable(this);

        return CommonSample(NULL, &rbp);
    }
    
    virtual bool CheckChangeables(CheckChangeablesParam& ccp) {

        ULONG age;
        HRESULT hr =
            _bvr->_theXf->GetGenerationId(&age);

        Assert(SUCCEEDED(hr));

        if (age != _bvr->_previousAge) {
            // The DXTransform has changed externally to DA.
            return true;
        }

        return false;
    }

    virtual AxAValue _Sample(Param& p) {
        return CommonSample(&p, NULL);
    }

#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "ApplyDXTransformPerfImpl"; }
#endif
    
    virtual void _DoKids(GCFuncObj proc) {
        for (long i=0; i< _bvr->_numInputs; i++) {
            (*proc)(_inputPerfs[i]);
        }
        for (i = 0; i< _bvr->_numParams; i++) {
            (*proc)(_paramPerfsInThisPerf[i]);
        }
        (*proc)(_bvr);
        (*proc)(_tt);
        (*proc)(_evalPerf);
    }

  protected:

    // Support both Sample and GetRBConst.
    AxAValue CommonSample(Param *p, RBConstParam *rbp) {

        // Only one should be non-null.
        Assert((p && !rbp) || (rbp && !p));
        
        AxAValue *vals = (AxAValue *)
            AllocateFromStore(_bvr->_numInputs * sizeof(AxAValue));

        long idx;
        bool failedRBConst = false;
        for (idx = 0; idx < _bvr->_numInputs && !failedRBConst; idx++) {
            Perf perf = _inputPerfs[idx];
            if (perf) {
                AxAValue val;
                if (p) {
                    vals[idx] = perf->Sample(*p);
                    Assert(vals[idx]);
                } else {
                    vals[idx] = perf->GetRBConst(*rbp);
                    if (!vals[idx]) {
                        failedRBConst = true;
                    }
                }
            } else {
                vals[idx] = NULL;
            }
        }

        if (failedRBConst) {
            Assert(rbp);
            DeallocateFromStore(vals);
            return NULL;
        }

        // Apply the sampled parameters to the filter.  Use *all* the
        // bvr's params, not just those in the perf.
        for (idx = 0; idx < _bvr->_numParams && !failedRBConst; idx++) {

            // First check to see if the corresponding param bvr is non-
            // NULL in the parent bvr.  If it is NULL, then this has been
            // removed, and we shouldn't execute it.
            if (_bvr->_paramBvrs[idx] == NULL) {

                // Null out corresponding performance so it will be
                // collected. 
                if (_paramPerfsInThisPerf[idx] != NULL) {
                    _paramPerfsInThisPerf[idx] = NULL;
                }

            } else {

                // If bvr was added since the last sample, then
                // perform it and store it here.
                if (_paramPerfsInThisPerf[idx] == NULL) {
                    
                    DynamicHeapPusher h(GetGCHeap());
                    
                    // Perform at the current time
                    Param *theP;
                    if (p) {
                        theP = p;
                    } else {
                        theP = &rbp->GetParam();
                    }
                    
                    PerfParam pp(theP->_time,
                                 Restart(_tt, theP->_time, *theP));
                    
                    _paramPerfsInThisPerf[idx] =
                        ::Perform(_bvr->_paramBvrs[idx], pp);
                }

                Assert(_paramPerfsInThisPerf[idx]);

                AxAValue val;
                if (p) {
                    val = _paramPerfsInThisPerf[idx]->Sample(*p);
                    Assert(val);
                } else {
                    val = _paramPerfsInThisPerf[idx]->GetRBConst(*rbp);
                    if (!val) {
                        failedRBConst = true;
                    }
                }

                if (val) {
                    HRESULT hr = ::PutProperty(_bvr->_theXfAsDispatch,
                                               _bvr->_paramDispids[idx],
                                               val);

                    // Nothing interesting for us to do with an error
                    // here. 
                }
                
            }
        }

        // Establish the time on the effect if allowed.
        if (_evalPerf && _bvr->_theXfAsEffect) {
            AxAValue evalTime;

            if (p) {
                evalTime = _evalPerf->Sample(*p);
                Assert(evalTime);
            } else {
                evalTime = _evalPerf->GetRBConst(*rbp);
                if (!evalTime) {
                    failedRBConst = true;
                }
            }

            if (evalTime) {
                
                double evalTimeDouble = ValNumber(evalTime);

                float currProgress;
                _bvr->_theXfAsEffect->get_Progress(&currProgress);

                float evalTimeFloat = evalTimeDouble;

                if (evalTimeFloat != currProgress) {

                    _bvr->_theXfAsEffect->put_Progress(evalTimeFloat);

                } else {

                    // For setting breakpoints.
                    DebugCode(int breakHere = 0);
                    
                }
                
            }
        }

        AxAValue result;
        if (failedRBConst) {
            Assert(rbp);
            DeallocateFromStore(vals);
            result = NULL;
        } else {
            result = ConstructAppropriateDXTransformStaticValue(_bvr, vals);
        }

        return result;
    }

    
    TimeXform                _tt;
    ApplyDXTransformBvrImpl *_bvr;         // backpointer
    Perf                    *_inputPerfs;
    Perf                     _evalPerf;
    Perf                     _paramPerfsInThisPerf[MAX_PARAM_BVRS];
};


////////////// Behavior //////////////////

bool
TypeSupported(const GUID& candidateGuid,
              GUID *acceptableGuids,
              int   numAcceptable)
{
    GUID *g = &acceptableGuids[0];
    for (int i = 0; i < numAcceptable; i++) {
        if (candidateGuid == *g++) {
            return true;
        }
    }

    return false;
}

// Return type info of specified input or output or, if input or
// output doesn't exist, or it is a type we don't understand, return
// NULL. 
DXMTypeInfo 
FindType(IDXTransform *xf,
         bool isOutput,
         int index,
         bool *pIsOptional)
{
    HRESULT hr;
    DXMTypeInfo result = NULL;

    const int maxTypes = 5;
    ULONG count = maxTypes;
    GUID  allowedTypes[maxTypes];
    DWORD pdwFlags;

    hr = xf->GetInOutInfo(isOutput,
                          index,
                          &pdwFlags,
                          allowedTypes,
                          &count,
                          NULL);

    if (hr != S_OK) {
        return NULL;
    }

    if (pIsOptional) {
        *pIsOptional = (pdwFlags & DXINOUTF_OPTIONAL) ? true : false;
    }
    
    // Figure out what the output of this transform is going to be.
    // TODO: Support multiple output types as tuples.  For now, we
    // just fail on multiple output types.

    if (TypeSupported(IID_IDirect3DRMMeshBuilder, allowedTypes, count) ||
        TypeSupported(IID_IDirect3DRMMeshBuilder2, allowedTypes, count) ||
        TypeSupported(IID_IDirect3DRMMeshBuilder3, allowedTypes, count)) {
        
        result = GeometryType;
        
    } else if (TypeSupported(IID_IDirectDrawSurface, allowedTypes, count) ||
               TypeSupported(IID_IDirectDrawSurface2, allowedTypes, count)) {
        
        result = ImageType;
        
    };

    // Anything else, we don't understand yet.
    return result;
}
         
              

ApplyDXTransformBvrImpl::ApplyDXTransformBvrImpl(IDXTransform *theXf,
                                                 IDispatch *theXfAsDispatch,
                                                 LONG numInputs,
                                                 Bvr *inputBvrs,
                                                 Bvr  evaluator)
: _transformFactory(NULL),
  _surfaceFactory(NULL),
  _poolDeletionNotifier(*this)
{
    _theXf = theXf;
    _theXfAsDispatch = theXfAsDispatch;
    _numInputs = numInputs;
    _inputBvrs = inputBvrs;
    _evaluator = evaluator;

    memset(_cachedInputs, 0, sizeof(_cachedInputs));
    _numParams = 0;
    
    _cachedOutput = NULL;
    _surfPool = NULL;
    _surfPoolHasBeenDeleted = false;
}

// Separate out initialization so we don't throw an exception in a
// constructor.
void
ApplyDXTransformBvrImpl::Init()
{
    _previousAge = 0xFFFFFFFF;
    
    bool involvesGeometry, involvesImage;
    
    ValidateInputs(&involvesGeometry, &involvesImage);
    InitializeTransform(involvesGeometry, involvesImage);
    QueryForAdditionalInterfaces();

    HRESULT hr = _theXf->GetMiscFlags(&_miscFlags);
    _miscFlagsValid = SUCCEEDED(hr);

    if (_miscFlagsValid) {
        // Clear "blend with output" flag, since we're always
        // rendering image transforms to intermediate surfaces.
        _miscFlags &= ~DXTMF_BLEND_WITH_OUTPUT;
        
        hr = _theXf->SetMiscFlags(_miscFlags);
        Assert(SUCCEEDED(hr));  // better not fail.
    }
    
    _neverSetup = true;
}

void
ApplyDXTransformBvrImpl::ValidateInputs(bool *pInvolvesGeometry,
                                        bool *pInvolvesImage)
{
    _cachedSurfWidth = -1;
    _cachedSurfHeight = -1;

    if (_numInputs > MAX_INPUTS) {
        RaiseException_InternalError("Too many inputs to DXTransform");
    }

    // First be sure there's only one output by making sure output
    // index 1 fails.
    DXMTypeInfo ti = FindType(_theXf, true, 1, NULL);

    if (ti != NULL) {
        RaiseException_UserError(DISP_E_TYPEMISMATCH,
                                 IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
    }

    // Now get the output types on the first output.
    _outputType = FindType(_theXf, true, 0, NULL);

    if (!_outputType) {
        RaiseException_UserError(DISP_E_TYPEMISMATCH,
                                 IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
    }

    *pInvolvesGeometry = (_outputType == GeometryType);
    *pInvolvesImage = (_outputType == ImageType);
    
    // Be sure the input types are valid.
    for (int i = 0; i < _numInputs; i++) {

        bool ok = false;

        if (_inputBvrs[i]) {
            
            _inputTypes[i] = _inputBvrs[i]->GetTypeInfo();

            if (_inputTypes[i] == GeometryType) {
                *pInvolvesGeometry = true;
            } else if (_inputTypes[i] == ImageType) {
                *pInvolvesImage = true;
            }
        
            DXMTypeInfo expectedType = FindType(_theXf, false, i, NULL);

            if (expectedType == _inputTypes[i]) {
                ok = true;
            }
            
        } else {

            // Be sure the input is optional
            bool isOptional;
            DXMTypeInfo expectedType = FindType(_theXf, false, i, &isOptional);

            if (isOptional) {
                ok = true;
                _inputTypes[i] = expectedType;
            }
            
        }

        if (!ok) {
            RaiseException_UserError(DISP_E_TYPEMISMATCH,
                               IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
        }
        
    }

    // Be sure there aren't additional required inputs.
    bool isOptional;
    DXMTypeInfo nextType =
        FindType(_theXf, false, _numInputs, &isOptional);

    if (nextType && !isOptional) {
        RaiseException_UserError(DISP_E_TYPEMISMATCH,
                                 IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
    }

    // D3DRM3 interface needs to be available for us to deal with
    // transforms that involve geometry.  If it's not, we need to fail
    // out. 
    if (*pInvolvesGeometry && GetD3DRM3() == NULL) {
        RaiseException_UserError(E_FAIL, IDS_ERR_EXTEND_DXTRANSFORM_NEED_DX6);
    }

    // Once we've validated our inputs, do this...
    GetInfo(true);
}

void
ApplyDXTransformBvrImpl::InitializeTransform(bool involvesGeometry,
                                             bool involvesImage)
{
    HRESULT hr;
    
    hr = CoCreateInstance( CLSID_DXTransformFactory,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IDXTransformFactory,
                           (void **)&_transformFactory);

    if (FAILED(hr)) {
        RaiseException_InternalError("Creation of DXTransformFactory failed");
    }

    DAComPtr<IServiceProvider> sp;
    hr = _transformFactory->QueryInterface(IID_IServiceProvider,
                                                 (void **)&sp);
    
    if (FAILED(hr)) {
        RaiseException_InternalError("QI for ServiceProvider failed");
    }
            
    hr = sp->QueryService(SID_SDXSurfaceFactory,
                          IID_IDXSurfaceFactory,
                          (void **)&_surfaceFactory);
    
    if (FAILED(hr)) {
        RaiseException_InternalError("QueryService of DXSurfaceFactory failed");
    }

    // Ensure that the D3DRM service is established on the
    // factory if this is a geometry-based transform
    if (involvesGeometry) {
        HRESULT hr = _transformFactory->SetService(SID_SDirect3DRM,
                                                   GetD3DRM3(),
                                                   FALSE);
        if (FAILED(hr)) {
            Assert(!"SetService failed");
            RaiseException_InternalError("SetService failed");
        }
    }

    if (involvesImage) {
        IDirectDraw3 *ddraw3;
        HRESULT hr = GetDirectDraw(NULL, NULL, &ddraw3);
        if (FAILED(hr)) {
            Assert(!"GetDdraw3 failed");
            RaiseException_InternalError("No ddraw3");
        }
        
        hr = _transformFactory->SetService(SID_SDirectDraw,
                                           ddraw3,
                                           FALSE);
        if (FAILED(hr)) {
            Assert(!"SetService failed");
            RaiseException_InternalError("SetService failed");
        }
    }

    // Tell the factory about this transform.
    hr = _transformFactory->InitializeTransform(_theXf,
                                                      NULL, 0, NULL, 0,
                                                      NULL, NULL);
    if (FAILED(hr)) {
        RaiseException_InternalError("Init from DXTransformFactory failed");
    }
}

void
ApplyDXTransformBvrImpl::QueryForAdditionalInterfaces()
{
    /////////// Query for IDXEffect /////////////////
    
    HRESULT hr =
        _theXf->QueryInterface(IID_IDXEffect, (void **)&_theXfAsEffect);

    // Be sure we set _theXfAsEffect correctly.
    Assert((SUCCEEDED(hr) && _theXfAsEffect) ||
           (FAILED(hr) && !_theXfAsEffect));

    // If we're an effect, and the evaluator hasn't been specified,
    // create a meaningful one.
    if (_theXfAsEffect && !_evaluator) {
        float dur;
        hr = _theXfAsEffect->get_Duration(&dur);

        if (SUCCEEDED(hr) && (dur > 0.0)) {
            // make the evaluator go from 0 to 1 over dur seconds.
            _evaluator = InterpolateBvr(zeroBvr,
                                        oneBvr,
                                        ConstBvr(RealToNumber(dur)));
        }
    }

    /////////// Query for IDirect3DRMExternalVisual /////////////////
    
    hr = _theXf->QueryInterface(IID_IDirect3DRMExternalVisual,
                                (void **)&_theXfAsExternalVisual);

    // Be sure we set _theXfAsExternalVisual correctly.
    Assert((SUCCEEDED(hr) && _theXfAsExternalVisual) ||
           (FAILED(hr) && !_theXfAsExternalVisual));

    /////////// Query for IDXSurfacePick /////////////////

    if (_outputType == ImageType) {
        
        hr = _theXf->QueryInterface(IID_IDXSurfacePick,
                                    (void **)&_theXfAs2DPickable);

        // Be sure we set _theXfAs2DPickable correctly.
        Assert((SUCCEEDED(hr) && _theXfAs2DPickable) ||
               (FAILED(hr) && !_theXfAs2DPickable));
        
    }
    
}

ApplyDXTransformBvrImpl::~ApplyDXTransformBvrImpl()
{
    for (int i = 0; i < MAX_INPUTS_TO_CACHE; i++) {
        RELEASE(_cachedInputs[i]);
    }
    RELEASE(_cachedOutput);
    RELEASE(_transformFactory);
    RELEASE(_surfaceFactory);

    if (_surfPool && !_surfPoolHasBeenDeleted) {

        // Advise the surface mgr to remove our deletion notifier
        _surfPool->UnregisterDeletionNotifier(&_poolDeletionNotifier);

        // The normal destruction process will return the
        // ddsurfs to the pool, since they're in DDSurfPtr<>
        // templates. 
            
            
    } else {

        // Just to put a breakpoint on.  Surfaces already null'd
        // out on the advise.
        Assert(true && "Surface pool deleted already.");
    }
}

// Custom method for this subclass of BvrImpl.  Apply the bvrToAdd
// each frame to the specified property.  Write over any previously
// established behavior.  If bvrToAdd is NULL, this removes the
// association with the property.
HRESULT
ApplyDXTransformBvrImpl::AddBehaviorProperty(BSTR property,
                                             Bvr  bvrToAdd)
{
    // First, lookup the property to be sure it's available on the
    // IDispatch.
    DISPID dispid;
    HRESULT hr =
        _theXfAsDispatch->GetIDsOfNames(IID_NULL,
                                        &property,
                                        1,
                                        LOCALE_SYSTEM_DEFAULT,
                                        &dispid);

    TraceTag((tagDXTransforms,
              "Property %ls becomes dispid %d with hr %hr",
              property, dispid, hr));
    
    if (FAILED(hr)) {
        return hr;
    }

    if (bvrToAdd) {
        
        // Be sure that the type of the behavior is consistent with
        // the property's type.  If not, we should fail here. 
    
        DXMTypeInfo ti = bvrToAdd->GetTypeInfo();
        CComVariant VarResult;
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
       
        hr = _theXfAsDispatch->Invoke(dispid,
                                      IID_NULL,
                                      LOCALE_SYSTEM_DEFAULT,
                                      DISPATCH_PROPERTYGET,
                                      &dispparamsNoArgs, 
                                      &VarResult,NULL,NULL);
        if (FAILED(hr)) {   
            return hr;
        }  
    
        CComVariant var;
        if(ti == AxAStringType) {
            WideString wstr = L"Just a test string";
            var.bstrVal = SysAllocString(wstr);
        } else if (ti == AxABooleanType) {
            var.boolVal = FALSE;  
        } else if (ti == AxANumberType) {
            var.fltVal = 100.00;
        } else {
            Assert(!"Shouldn't be here");
        }
        hr  = var.ChangeType(VarResult.vt, NULL);
        if (FAILED(hr)) 
            RaiseException_UserError(E_FAIL, DISP_E_TYPEMISMATCH,IDS_ERR_TYPE_MISMATCH);

    }

    // Search through existing parameters and replace if
    // necessary.  Don't decrement _numParams, since we're just poking
    // holes in the list if the bvr is NULL, not compacting it.  
    bool foundIt = false;
    for (int i = 0; i < _numParams && !foundIt; i++) {
        if (_paramDispids[i] == dispid) {
            foundIt = true;
            _paramBvrs[i] = bvrToAdd;
        }
    }

    // Else, add on to the list if non-null behavior. 
    if (!foundIt && bvrToAdd != NULL) {

        if (_numParams == MAX_PARAM_BVRS) {
            return E_FAIL;
        }

        _paramDispids[_numParams] = dispid;
        _paramBvrs[_numParams] = bvrToAdd;

        _numParams++;
    }

    return S_OK;
}

Perf ApplyDXTransformBvrImpl::_Perform(PerfParam& p)
{
    Perf *inputPerfs =
        (Perf *)StoreAllocate(GetSystemHeap(),
                              sizeof(Perf) * _numInputs);
    
    Perf  paramPerfs[MAX_PARAM_BVRS];

    for (long i=0; i<_numInputs; i++) {
        Bvr b = _inputBvrs[i];
        inputPerfs[i] = b ? ::Perform(b, p) : NULL;
    }

    // Construct the list of parameter performances for as many
    // parameters as we *currently* have.  Subsequently added bvrs
    // will be performed on the next sample by the Performance.
    for (i = 0; i < _numParams; i++) {
        // Might be null if removed
        if (_paramBvrs[i] == NULL) {
            paramPerfs[i] = NULL;
        } else {
            paramPerfs[i] =  ::Perform(_paramBvrs[i], p);
        }
    }

    Perf evalPerf =
        _evaluator ? ::Perform(_evaluator, p) : NULL;

    return NEW ApplyDXTransformPerfImpl(p,
                                        this,
                                        inputPerfs,
                                        _numParams,
                                        paramPerfs, 
                                        evalPerf);
}

void
ApplyDXTransformBvrImpl::_DoKids(GCFuncObj proc)
{
    for (long i=0; i<_numInputs; i++) {
        (*proc)(_inputBvrs[i]);
    }

    (*proc)(_evaluator);

    for (i = 0; i < _numParams; i++) {
        (*proc)(_paramBvrs[i]);
    }
}

DWORD
ApplyDXTransformBvrImpl::GetInfo(bool recalc)
{
    _info = BVR_IS_CONSTANT;
    
    for (long i=0; i<_numInputs; i++) {
        Bvr b = _inputBvrs[i];
        if (b) {
            _info &= b->GetInfo(recalc);
        }
    }

    for (i = 0; i < _numParams; i++) {
        _info &= _paramBvrs[i]->GetInfo(recalc);
    }

    return _info;
}


// We disable constant folding for dxtransforms since we don't
// currently have a way of recognizing that something became
// "un-constant" through the addition of a new property after the
// bvr's been started.  Thus, for now, assume that they're *never*
// constant, and try to come up with some smart approaches later.
// Note that there was a previous version of this code that did the
// the right constant folding (assuming that the properties wouldn't
// be set after the fact).  This can be found in SLM versions v20 and
// prior (prior to 12/23/98).
AxAValue
ApplyDXTransformBvrImpl::GetConst(ConstParam & cp)
{
    return NULL;
}
    
Bvr
ConstructDXTransformApplier(IDXTransform *theXf,
                            IDispatch *theXfAsDispatch,
                            LONG numInputs,
                            Bvr *inputBvrs,
                            Bvr  evaluator)
{
    ApplyDXTransformBvrImpl *obj =
        NEW ApplyDXTransformBvrImpl(theXf,
                                    theXfAsDispatch,
                                    numInputs,
                                    inputBvrs,
                                    evaluator);

    obj->Init();

    return obj;
}


HRESULT
DXXFAddBehaviorPropertyToDXTransformApplier(BSTR property,
                                            Bvr  bvrToAdd,
                                            Bvr  bvrToAddTo)
{
    ApplyDXTransformBvrImpl *dxxfBvr =
        SAFE_CAST(ApplyDXTransformBvrImpl *, bvrToAddTo);

    return dxxfBvr->AddBehaviorProperty(property, bvrToAdd);
}

// TODO: Someday, may want to make this more
// object-oriented... separate out image from geom stuff...  Certainly
// not critical, though.

HRESULT
DXXFSetupAndExecute(Bvr bvr,
                    IUnknown          **newInputArray,
                    REFIID              outputIID,
                    DirectDrawViewport *viewport,
                    int                 requestedWidth,
                    int                 requestedHeight,
                    bool                invokeAsExternalVisual,
                    bool                executeRequired,
                    void              **outputValue)
{
    ApplyDXTransformBvrImpl &bv =
        *(SAFE_CAST(ApplyDXTransformBvrImpl *, bvr));

    HRESULT hr = S_OK;
    bool mustSetup = false;
    
    // Have to be pessimistic
    if (bv._numInputs > MAX_INPUTS_TO_CACHE) {
        
        mustSetup = true;
        
    } else {

        // Go through each cached input and compare pointers with the
        // incoming one.  If any differ, then we will need to redo setup.
        // In this case, also stash the values into the cache.
        for (int i = 0; i < bv._numInputs; i++) {
            if (newInputArray[i] != bv._cachedInputs[i]) {
            
                mustSetup = true;
            
                RELEASE(bv._cachedInputs[i]);
            
                newInputArray[i]->AddRef();
                bv._cachedInputs[i] = newInputArray[i];

            }
        }

        if (!mustSetup && !bv._cachedOutput && !invokeAsExternalVisual) {
            // Assert that the only way we can think we don't need to
            // setup and yet our output cache is nil is if there are no
            // inputs.  In this case, we really do want to setup.
            Assert(bv._numInputs == 0);
            mustSetup = true;
        }

    }

    // May also need to setup again if our output surface isn't the
    // right size.
    bool needToCreateNewOutputSurf = false;
    if (bv._outputType == ImageType) {
        needToCreateNewOutputSurf = 
            (bv._cachedSurfWidth != requestedWidth ||
             bv._cachedSurfHeight != requestedHeight);

        if (needToCreateNewOutputSurf) {
            mustSetup = true;
        }
    }

    if (mustSetup) {
        
        if (bv._outputType == GeometryType) {

            RELEASE(bv._cachedOutput);
            
            TD3D(GetD3DRM3()->CreateMeshBuilder(&bv._cachedOutputAsBuilder));

            hr = bv._cachedOutputAsBuilder->
                    QueryInterface(IID_IUnknown, 
                                   (void **)&bv._cachedOutput);

            // QI'ing for IUnknown had better not fail!!
            Assert(SUCCEEDED(hr));

            // We don't want to keep a ref for this guy, since we have
            // a ref in _cachedOutput itself.
            bv._cachedOutputAsBuilder->Release();
            
        } else if (bv._outputType == ImageType) {

            // If we don't need a new output surf, just recycle the
            // existing one through the next Setup call.
            if (needToCreateNewOutputSurf) {

                RELEASE(bv._cachedOutput);

                // Release whatever old one we had.
                bv._cachedDDSurf.Release();


                DDPIXELFORMAT pf;
                ZeroMemory(&pf, sizeof(pf));
                pf.dwSize = sizeof(pf);
                pf.dwFlags = DDPF_RGB;
                pf.dwRGBBitCount = 32;
                pf.dwRBitMask = 0xff0000;
                pf.dwGBitMask = 0x00ff00;
                pf.dwBBitMask = 0x0000ff;
                
                viewport->CreateSizedDDSurface(&bv._cachedDDSurf,
                                               pf,
                                               requestedWidth,
                                               requestedHeight,
                                               NULL,
                                               notVidmem);

                #if _DEBUG
                if(IsTagEnabled(tagDXTransformPerPixelAlphaOutputOff)) {
                    bv._cachedDDSurf->SetColorKey(viewport->GetColorKey());
                    bv._cachedOutput = bv._cachedDDSurf->IDDSurface_IUnk();
                    bv._cachedOutput->AddRef();
                } else
                #endif

                  {
                      // UNSET the color key
                      bv._cachedDDSurf->UnSetColorKey();
                      
                      // get the iunk of the idxsurf in _cachedOutput
                      bv._cachedDDSurf->GetIDXSurface(bv._surfaceFactory)->
                          QueryInterface(IID_IUnknown, (void **) &(bv._cachedOutput));
                  }
                
                bv._cachedSurfWidth = (SHORT)requestedWidth;
                bv._cachedSurfHeight = (SHORT)requestedHeight;
                
            }
            
        } else {
            
            Assert(!"Unsupported type for setup caching");
            
        }
    }

    if (invokeAsExternalVisual) {
        *outputValue = NULL;
    } else {
        // This does an AddRef
        hr = bv._cachedOutput->QueryInterface(outputIID,
                                              outputValue);
    }

    Assert(SUCCEEDED(hr));      // else internal error.

    if (mustSetup) {
        hr = TIME_DXXFORM(bv._theXf->Setup(newInputArray,
                                           bv._numInputs,
                                           &bv._cachedOutput,
                                           1,
                                           0));

        TraceTag((tagDXTransforms, "Called Setup() on 0x%x",
                  bv._theXf));
            
        if (FAILED(hr)) {
            if (executeRequired) {
                RaiseException_UserError(E_FAIL, IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
            } else {
                // If we don't require an execute, then tolerate
                // failures of Setup, as some transforms don't want to
                // setup with empty meshbuilder inputs (Melt, for
                // one.)
                hr = S_OK;
            }
        }

        if (bv._neverSetup) {
            bv._neverSetup = false;
        }
    }

    // Only execute if we're not invoked as an external visual.
    if (executeRequired && !invokeAsExternalVisual) {
        // If the transform's generation id hasn't changed, then we don't
        // need to call Execute.
        ULONG age;
        hr = bv._theXf->GetGenerationId(&age);
        if (FAILED(hr) || (age != bv._previousAge) || mustSetup) {

            // If an image output, clear the image to the color key,
            // since the transform will not necessarily write all
            // bits.
            
            if (bv._outputType == ImageType) {
                viewport->
                    ClearDDSurfaceDefaultAndSetColorKey(bv._cachedDDSurf);
            }

            hr = TIME_DXXFORM(bv._theXf->Execute(NULL, NULL, NULL));
        
            TraceTag((tagDXTransforms, "Called Execute() on 0x%x",
                      bv._theXf));
            
            if (FAILED(hr)) {
                RaiseException_UserError(E_FAIL, IDS_ERR_EXTEND_DXTRANSFORM_FAILED);
            }

            // Re-get the gen id.  It may have changed during Execute().
            hr = bv._theXf->GetGenerationId(&age);
            if (SUCCEEDED(hr)) {
                bv._previousAge = age;
            }
        
        }
        
    } 
        
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\geomimg.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Implements the projected geometry class.

*******************************************************************************/

#include <headers.h>
#include "privinc/imgdev.h"
#include "privinc/geomimg.h"
#include "privinc/dispdevi.h"
#include "privinc/imagei.h"
#include "privinc/imgdev.h"
#include "appelles/geom.h"
#include "privinc/ddrender.h"
#include "privinc/geomi.h"
#include "privinc/opt.h"
#include "privinc/probe.h"
#include "privinc/vec2i.h"
#include "privinc/vec3i.h"
#include "privinc/bbox3i.h"
#include "privinc/camerai.h"
#include "privinc/except.h"
#include "privinc/dddevice.h"
#include "privinc/d3dutil.h"
#include "privinc/tls.h"

//////////////  Image from projected geometry  ////////////////////

ProjectedGeomImage::ProjectedGeomImage(Geometry *g, Camera *cam) :
    _geo(g), _camera(cam), _bbox(NullBbox2), _bboxIsSet(false)
{
    // Propagate external changers into images
    if (g->GetFlags() & GEOFLAG_CONTAINS_EXTERNALLY_UPDATED_ELT) {
        _flags |= IMGFLAG_CONTAINS_EXTERNALLY_UPDATED_ELT;
    }

    // And opacity
    if (g->GetFlags() & GEOFLAG_CONTAINS_OPACITY) {
        _flags |= IMGFLAG_CONTAINS_OPACITY;
    }
}


void
ProjectedGeomImage::Render(GenericDevice& _dev)
{
    if(_dev.GetDeviceType() != IMAGE_DEVICE)
       return; // nothing to do here, no reason to traverse

    ImageDisplayDev &dev = SAFE_CAST(ImageDisplayDev &, _dev);

    dev.RenderProjectedGeomImage(this, _geo, _camera);
}



/*****************************************************************************
Compute the 2D bounding box of projected geometry.  Note that this actually
computes the bounding box of the projected geometry's 3D bounding box, so
there may be a considerable amount of "slop" around the 3D object.
*****************************************************************************/

static int neighbor[8][3] =               //  3---7    Bbox Vertex Neighbors
{   {1,2,4}, {0,3,5}, {0,3,6}, {1,2,7},   // 2---6|
    {0,5,6}, {1,4,7}, {2,4,7}, {3,5,6}    // |1--|5    Index 1: Vertex
};                                        // 0---4     Index 2: Neighbor[0..2]

    // Returns true if the point is behind the image plane (other side of the
    // projection point).  Recall that camera coordinates are left-handed.

static inline int BehindImagePlane (bool right_handed, Point3Value *p)
{
    return (right_handed == (p->z < 0));
}

    // Calculate the intersection of the line between the two points and the
    // image (Z=0) plane.  Augment the bounding box with this intersection.

static void AddZ0Intersect (Bbox2 &bbox,Real Sx,Real Sy, Point3Value *P, Point3Value *Q)
{
    Real t = P->z / (P->z - Q->z);       // Get the intersection point from
    Real x = P->x + t*(Q->x - P->x);     // P to Q with the Z=0 plane.
    Real y = P->y + t*(Q->y - P->y);
    bbox.Augment (x/Sx, y/Sy);
}


const Bbox2 ProjectedGeomImage::BoundingBox (void)
{
    if ( !_bboxIsSet )
    {
        Real sx, sy;     // Camera X/Y Scaling Factors
        _camera->GetScale (&sx, &sy, 0);

        // Generate the eight corner vertices of the 3D bounding box.  Though
        // the bounding box is axis-aligned in world coordinates, this may not
        // be true for camera coordinates.

        Bbox3  *vol = _geo->BoundingVol();

        if (vol->Positive()) {
            
            Point3Value *vert[8];

            vert[0] = NEW Point3Value (vol->min.x, vol->min.y, vol->min.z);
            vert[1] = NEW Point3Value (vol->min.x, vol->min.y, vol->max.z);
            vert[2] = NEW Point3Value (vol->min.x, vol->max.y, vol->min.z);
            vert[3] = NEW Point3Value (vol->min.x, vol->max.y, vol->max.z);
            vert[4] = NEW Point3Value (vol->max.x, vol->min.y, vol->min.z);
            vert[5] = NEW Point3Value (vol->max.x, vol->min.y, vol->max.z);
            vert[6] = NEW Point3Value (vol->max.x, vol->max.y, vol->min.z);
            vert[7] = NEW Point3Value (vol->max.x, vol->max.y, vol->max.z);

            // Transform the eight corner vertices to camera coordinates.

            int i;

            Transform3 *wToC = _camera->WorldToCamera();
            if (!wToC) {
                return NullBbox2;
            }
        
            Point3Value *xVert[8];
            for (i=0;  i < 8;  ++i)
                xVert[i] = TransformPoint3 (wToC, vert[i]);

            // Now find the intersection of the line from the camera projection
            // point to each corner vertex on the other side of the image plane.
            // If a vertex is on the same side as the projection point, then we
            // use instead the intersection points of the three edges emanating
            // from that vertex.  The bounding box of these intersection points
            // will be the bounding box for the projected geometry image.

            bool right_handed = (GetD3DRM3() != 0);
            for (i=0;  i < 8;  ++i)
              {
                  if (BehindImagePlane (right_handed, xVert[i]))
                    {
                        Point2 projPt = Demote(*(_camera->Project(vert[i])));
                        _bbox.Augment(projPt.x,projPt.y);
                    }
                  else
                    {
                        if (BehindImagePlane (right_handed, xVert[neighbor[i][0]]))
                            AddZ0Intersect (_bbox,sx,sy, xVert[i], xVert[neighbor[i][0]]);

                        if (BehindImagePlane (right_handed, xVert[neighbor[i][1]]))
                            AddZ0Intersect (_bbox,sx,sy, xVert[i], xVert[neighbor[i][1]]);

                        if (BehindImagePlane (right_handed, xVert[neighbor[i][2]]))
                            AddZ0Intersect (_bbox,sx,sy, xVert[i], xVert[neighbor[i][2]]);
                    }
              }

        } else {

            _bbox = NullBbox2;
            
        }

        _bboxIsSet = true;
    }

    return _bbox;
}



/*****************************************************************************
To pick a projected geometry image, fire a picking ray through the camera into
the scene defined by the geometry.
*****************************************************************************/

Bool ProjectedGeomImage::DetectHit (PointIntersectCtx& context2D)
{
    RayIntersectCtx context3D;

    bool result = false;

    if (context3D.Init (context2D, _camera, _geo))
    {
        _geo->RayIntersect (context3D);
        result = context3D.ProcessEvents();
    }

    return result;
}



Image *RenderImage (Geometry *geo, Camera *cam)
{
    return NEW ProjectedGeomImage (geo, cam);
}

int ProjectedGeomImage::Savings(CacheParam& p)
{
    if (GetThreadLocalStructure()->_geometryBitmapCaching == PreferenceOff) {
        return 0;
    } else {
        return 5;
    }
}

AxAValue
ProjectedGeomImage::_Cache(CacheParam &p)
{
    _geo = SAFE_CAST(Geometry *, AxAValueObj::Cache(_geo, p));
    return this;
}


void ProjectedGeomImage::DoKids(GCFuncObj proc)
{ 
    Image::DoKids(proc);
    (*proc)(_geo);
    (*proc)(_camera);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "privinc/server.h"
#include "privinc/imagei.h"
#include "privinc/probe.h"
#include "privinc/imgdev.h"
#include "privinc/except.h"
#include "privinc/transimg.h"


#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\gradimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of gradient image values

*******************************************************************************/

#include "headers.h"

#include "privinc/imagei.h"
#include "privinc/polygon.h"
#include "privinc/colori.h"
#include "privinc/vec2i.h"
#include "privinc/bbox2i.h"
#include "privinc/GradImg.h"
#include "backend/values.h"

#define  USE_RADIAL_GRADIENT_RASTERIZER 0

class Point2Value;
class Color;

const Real SMALLNUM = 1.0e-10;

class GradientImage : public Image {

    friend Image *NewGradientImage(
        int numPts,
        Point2Value **pts,
        Color **clrs);

  private:
    GradientImage() {
        _flags |= IMGFLAG_CONTAINS_GRADIENT;
    }

    void PostConstructorInitialize(
        int numPts,
        Point2Value **pts,
        Color **clrs)
    {
        _numPts = numPts;
        _pts = pts;
        _clrs = clrs;
        _polygon = NewBoundingPolygon();
        _polygon->AddToPolygon(_numPts, _pts);
    }
    
  public:
    void Render(GenericDevice& dev) {
        ImageDisplayDev &idev = SAFE_CAST(ImageDisplayDev &, dev);
        idev.RenderGradientImage(this, _numPts, _pts, _clrs);
    }
        
    
    const Bbox2 BoundingBox(void) {
        return _polygon->BoundingBox();
    }

    #if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        return _polygon->BoundingBoxTighter(bbctx);
    }
    #endif  // BOUNDINGBOX_TIGHTER

    const Bbox2 OperateOn(const Bbox2 &box) {
        return box;
    }

    // Process an image for hit detection
    Bool  DetectHit(PointIntersectCtx& ctx) {
        Point2Value *lcPt = ctx.GetLcPoint();

        if (!lcPt) return FALSE;        // singular transform

        return _polygon->PtInPolygon(lcPt);
    }

    int Savings(CacheParam& p) { return 2; }
    
#if _USE_PRINT
    ostream& Print(ostream& os) { return os << "GradientImage"; }
#endif
    
    virtual void DoKids(GCFuncObj proc) {
        Image::DoKids(proc);
        (*proc)(_polygon);
        for (int i=0; i<_numPts; i++) {
            (*proc)(_pts[i]);
            (*proc)(_clrs[i]);
        }
    }

  private:
    int _numPts;
    BoundingPolygon *_polygon;
    Point2Value **_pts;
    Color **_clrs;
};

//
// helper function to create a gradient image and initialize it
// the right way.  Note that PostConstructorInitialize can raise and exception
//
Image *NewGradientImage(
    int numPts,
    Point2Value **pts,
    Color **clrs)
{
    GradientImage *gi = NEW GradientImage;
    gi->PostConstructorInitialize(numPts, pts, clrs);
    return gi;
}
    



//
// helper function to create a gradient image and initialize it
// the right way.  Note that PostConstructorInitialize can raise and exception
//
Image *NewMulticolorGradientImage(
    int numOffsets,
    double *offsets,
    Color **clrs,
    MulticolorGradientImage::gradientType type)
{
    MulticolorGradientImage *gi = NULL;
    
    switch( type ) {
      case MulticolorGradientImage::radial:
        gi = NEW RadialMulticolorGradientImage;
        break;
      case MulticolorGradientImage::linear:
        gi = NEW LinearMulticolorGradientImage;
        break;
      default:
        Assert(!"Error gradient type");
    }
    
    gi->PostConstructorInitialize(numOffsets, offsets, clrs);
    return gi;
}
    


Image *GradientPolygon(AxAArray *ptList, AxAArray *clrList)
{
    int numPts = ptList->Length();

    if(numPts < 3)
        RaiseException_UserError(E_FAIL, IDS_ERR_IMG_NOT_ENOUGH_PTS_3);

    if(numPts != clrList->Length())
        RaiseException_UserError(E_FAIL, IDS_ERR_IMG_ARRAY_MISMATCH);
    
    Point2Value **pts = (Point2Value **)AllocateFromStore((numPts) * sizeof(Point2Value *));
    for (int i = 0; i < numPts; i++) 
        pts[i] = (Point2Value *)(*ptList)[i];

    Color **clrs = (Color **)AllocateFromStore((numPts) * sizeof(Color *));
    for (i = 0; i < numPts; i++)
        clrs[i] = (Color *)(*clrList)[i];

    // TODO: It should use AxAArray directly...
    return NewGradientImage(numPts, pts, clrs);
}

Image *RadialGradientPolygon(Color *inner, Color *outer, 
                             DM_ARRAYARG(Point2Value*, AxAArray*) points, AxANumber *fallOff)
{
    #if USE_RADIAL_GRADIENT_RASTERIZER
    double *offs = (double *)AllocateFromStore(2*sizeof(double));
    offs[0] = 0.0; offs[1] = 1.0;
    Color **clrs =  (Color **)AllocateFromStore(2*sizeof(Color *));
    clrs[0] = inner; clrs[1]= outer;
    return NewMulticolorGradientImage(2, offs, clrs);
    #endif
    
    
    int numPts = points->Length();
    int i;
    Image *shape = emptyImage;

    // Calculate the boundingBox of the array of points.  This
    // wouldn't be necessary if we we being passed a path, since we would have the Bbox.
    Real maxX, maxY, minX, minY;
    for(i=0; i<numPts; i++) {
        Real cX = ((Point2Value *)(*points)[i])->x;
        Real cY = ((Point2Value *)(*points)[i])->y;
        if (i == 0) {
            minX = cX;
            minY = cY;
            maxX = cX;
            maxY = cY;
        } else {
            minX = (cX < minX) ? cX : minX;
            minY = (cY < minY) ? cY : minY;
            maxX = (cX > maxX) ? cX : maxX;
            maxY = (cY > maxY) ? cY : maxY;
        }
    }
    Point2Value *origin = NEW Point2Value((minX+maxX)/2,(minY+maxY)/2);

    for(i=0; i<numPts; i++) {
        // TODO: Consider moving these out into more static storage, so
        // they are not allocated every time we construct one of these.
        Point2Value **pts = (Point2Value **)AllocateFromStore(3 * sizeof(Point2Value *));
        
        pts[0] = origin;
        pts[1] = (Point2Value *)(*points)[i];       
        pts[2] = (Point2Value *)(*points)[(i+1)%numPts];

        Color **clrs = (Color **)AllocateFromStore(3 * sizeof(Color *));    
        clrs[0] = inner;
        clrs[1] = outer;
        clrs[2] = outer;

        shape = Overlay(shape, NewGradientImage(3, pts, clrs));
    }
    return shape;
}

Image *
GradientSquare(Color *lowerLeft,
               Color *upperLeft,
               Color *upperRight,
               Color *lowerRight)
{
    // This creates a unit-sized square, centered at the origin.
    
    // TODO: Consider moving these out into more static storage, so
    // they are not allocated every time we construct one of these.
    Point2Value **p1 = (Point2Value **)AllocateFromStore(3 * sizeof(Point2Value *));
    Point2Value **p2 = (Point2Value **)AllocateFromStore(3 * sizeof(Point2Value *));
    Point2Value **p3 = (Point2Value **)AllocateFromStore(3 * sizeof(Point2Value *));
    Point2Value **p4 = (Point2Value **)AllocateFromStore(3 * sizeof(Point2Value *));
    p1[0] = p2[0] = p3[0] = p4[0] = origin2;
    p1[1] = p4[2] = NEW Point2Value(-0.5, -0.5);
    p1[2] = p2[1] = NEW Point2Value(-0.5,  0.5);
    p2[2] = p3[1] = NEW Point2Value(0.5, 0.5);
    p3[2] = p4[1] = NEW Point2Value(0.5, -0.5);

    Color **c1 = (Color **)AllocateFromStore(3 * sizeof(Color *));
    Color **c2 = (Color **)AllocateFromStore(3 * sizeof(Color *));
    Color **c3 = (Color **)AllocateFromStore(3 * sizeof(Color *));
    Color **c4 = (Color **)AllocateFromStore(3 * sizeof(Color *));
    
    // This first color is the bilinear average of the others.
    Real r = (lowerLeft->red + upperLeft->red +
              upperRight->red + lowerRight->red) / 4.0;
    
    Real g = (lowerLeft->green + upperLeft->green +
              upperRight->green + lowerRight->green) / 4.0;
    
    Real b = (lowerLeft->blue + upperLeft->blue +
              upperRight->blue + lowerRight->blue) / 4.0;
    Color *mid =  NEW Color(r, g, b);
    
    c1[0] = c2[0] = c3[0] = c4[0] = mid;
    c1[1] = c4[2] = lowerLeft;
    c1[2] = c2[1] = upperLeft;
    c2[2] = c3[1] = upperRight;
    c3[2] = c4[1] = lowerRight;

    Image *t1 = NewGradientImage(3, p1, c1);
    Image *t2 = NewGradientImage(3, p2, c2);
    Image *t3 = NewGradientImage(3, p3, c3);
    Image *t4 = NewGradientImage(3, p4, c4);
    
    return Overlay(t1, Overlay(t2, Overlay(t3, t4)));
}

Image *
GradientHorizontal(Color *start, Color *stop, AxANumber *fallOff)
{    
    // TODO: IHammer code integration will need to occur to do
    // nonlinear fallOff.  For now, we ignore the falloff and this
    // simply becomes a call to gradientSquare;
    return GradientSquare(start,start,stop,stop);
}

// Constructs a gradient square in which the color radiates linearly outward 
Image *
RadialGradientSquare(Color *inner, Color *outer, AxANumber *fallOff)
{
    #if USE_RADIAL_GRADIENT_RASTERIZER
    double *offs = (double *)AllocateFromStore(2*sizeof(double));
    offs[0] = 0.0; offs[1] = 1.0;
    Color **clrs =  (Color **)AllocateFromStore(2*sizeof(Color *));
    clrs[0] = inner; clrs[1]= outer;
    return NewMulticolorGradientImage(2, offs, clrs);
    #endif
    
    // TODO: IHammer code integration will need to occur to do
    // nonlinear fallOff.  For now, we ignore the falloff.

    // This creates a unit-sized square, centered at the origin.
    Image *square = emptyImage;
    for(int i=0; i<4; i++) {
        // TODO: Consider moving these out into more static storage, so
        // they are not allocated every time we construct one of these.
        Point2Value **pts = (Point2Value **)AllocateFromStore(3 * sizeof(Point2Value *));
        pts[0] = origin2;
        pts[1] = NEW Point2Value(0.5, 0.5);
        pts[2] = NEW Point2Value(0.5, -0.5);

        Color **clrs = (Color **)AllocateFromStore(3 * sizeof(Color *));    
        clrs[0] = inner;
        clrs[1] = outer;
        clrs[2] = outer;
        Image *quad = TransformImage(RotateRealR(pi/2*i), 
            NewGradientImage(3, pts, clrs));
        square = Overlay( square, quad );        
    }
    return square;
}

// A fanned poly with specified number of outer edges to determine
// the tesselation.  The color at the center is specified in
// innerColor, and outerColor specifies the color at all of the outer
// vertices. NOTE: This is now an internal function only.
Image *
RadialGradientRegularPoly(Color *inner, Color *outer, 
                          AxANumber *numEdges, AxANumber *fallOff)
{
    #if USE_RADIAL_GRADIENT_RASTERIZER
    double *offs = (double *)AllocateFromStore(2*sizeof(double));
    offs[0] = 0.0; offs[1] = 1.0;
    Color **c =  (Color **)AllocateFromStore(2*sizeof(Color *));
    c[0] = inner; c[1]= outer;
    return NewMulticolorGradientImage(2, offs, c);
    #endif    
    
    
    // TODO: IHammer code integration will need to occur to do
    // nonlinear fallOff.  For now, we ignore the falloff.
    int numOuterPts = (int)(NumberToReal(numEdges) + 1);
    
    if(numOuterPts < 4)
        RaiseException_UserError(E_FAIL, IDS_ERR_IMG_NOT_ENOUGH_PTS_3);

    // TODO: Consider moving these out into more static storage, so
    // they are not allocated every time we construct one of these.
    Point2Value **pts = (Point2Value **)AllocateFromStore((numOuterPts + 1) *
                                                sizeof(Point2Value *));
    
    pts[0] = origin2;

    Real inc = (pi * 2.0) / (Real)(numOuterPts - 1);

    int i;
    Real ang;
    
    for (i = 0, ang = 0.0; i < numOuterPts; i++, ang += inc) {
        pts[i+1] = NEW Point2Value(.5*cos(ang), .5*sin(ang));
    }

    Color **clrs = (Color **)AllocateFromStore((numOuterPts + 1) *
                                               sizeof(Color *));
    clrs[0] = inner;
    for (i = 0; i < numOuterPts; i++) {
        clrs[i+1] = outer;
    }

    return NewGradientImage(numOuterPts + 1, pts, clrs);
}

Image *_RadialGradientMulticolor(AxAArray *offsets,
                                 AxAArray *colors,
                                 MulticolorGradientImage::gradientType type)                             
{
    int numOffsets = offsets->Length();
    Assert( numOffsets == colors->Length() );

    Color **clrs = (Color **)AllocateFromStore(numOffsets * sizeof(Color *));
    double *off  = (double *)AllocateFromStore(numOffsets * sizeof(double));
    for(int i=0; i<numOffsets; i++) {
        off[i] = ValNumber( (*offsets)[i] );
        clrs[i] = SAFE_CAST( Color *, (*colors)[i] );
        Assert(clrs[i]);
    }

    return NewMulticolorGradientImage(numOffsets, off, clrs, type);
}

Image *RadialGradientMulticolor(AxAArray *offsets, AxAArray *colors)
{
    return _RadialGradientMulticolor(offsets, colors, MulticolorGradientImage::radial);
}

Image *LinearGradientMulticolor(AxAArray *offsets, AxAArray *colors)
{
    return _RadialGradientMulticolor(offsets, colors, MulticolorGradientImage::linear);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\hatchimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of hatch image values

*******************************************************************************/

#include "headers.h"

#include "privinc/imagei.h"
#include "privinc/linei.h"
#include "privinc/polygon.h"
#include "privinc/colori.h"
#include "backend/values.h"
#include "privinc/path2i.h"

class Point2Value;
class Color;

Image *
ConstructHatch(int numLines, Real *pts, Color* lineClr, Real dt) {
    Image *hatch = emptyImage;
    LineStyle *ls = NEW LineColorStyleClass(lineClr, defaultLineStyle);
    for(int i=0; i<numLines*4; i+=4) {
      Path2 *ln = Line2(Point2(pts[i],pts[i+1]), 
                        Point2(pts[i+2],pts[i+3]) );
      hatch = Overlay( LineImageConstructor(ls, ln), hatch );
    }
    Point2 minPt(-.5*dt,-.5*dt),
           maxPt(.5*dt,.5*dt);

    return TileImage(CreateCropImage(minPt, maxPt, hatch));
}

Image *HatchHorizontal(Color *lineClr, AxANumber *spacing) {
    Real dt = spacing->GetNum();
    Real pts[] = { -dt, .5*dt, dt, .5*dt, -dt, -.5*dt, dt, -.5*dt } ; 
    return ConstructHatch(2, pts, lineClr, dt);
}

Image *HatchVertical(Color *lineClr, AxANumber *spacing) {
    Real dt = spacing->GetNum();
    Real pts[] = { -.5*dt, -dt, -.5*dt, dt, .5*dt, -.5*dt, .5*dt, .5*dt } ; 
    return ConstructHatch(2, pts, lineClr, dt);
}

Image *HatchForwardDiagonal(Color *lineClr, AxANumber *spacing) {
    Real dt = spacing->GetNum();
    Real pts[] = { -dt, -dt, dt, dt, 0, dt, -dt, 0, dt, 0, 0, -dt } ; 
    return ConstructHatch(2, pts, lineClr, dt);
}

Image *HatchBackwardDiagonal(Color *lineClr, AxANumber *spacing) {
    Real dt = spacing->GetNum();
    Real pts[] = { -dt, dt, dt, -dt, 0, dt, dt, 0, -dt, 0, 0, -dt } ; 
    return ConstructHatch(2, pts, lineClr, dt);
}

Image *HatchCross(Color *lineClr, AxANumber *spacing) {
    Real dt = spacing->GetNum();
    Real pts[] = { -dt, .5*dt, dt, .5*dt, -dt, -.5*dt, dt, -.5*dt, 
                 -.5*dt, -dt, -.5*dt, dt, .5*dt, -.5*dt, .5*dt, .5*dt } ; 
    return ConstructHatch(4, pts, lineClr, dt);
}

Image *HatchDiagonalCross(Color *lineClr, AxANumber *spacing) {
    Real dt = spacing->GetNum();
    Real pts[] = { -dt, dt, dt, -dt, 0, dt, dt, 0, -dt, 0, 0, -dt,  
                   -dt, -dt, dt, dt, 0, dt, -dt, 0, dt, 0, 0, -dt } ; 
    return ConstructHatch(4, pts, lineClr, dt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\matteimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Defines the "clipImage" operator which applies a matte to an
    image. 

*******************************************************************************/

#include "headers.h"

#include "privinc/imagei.h"
#include "privinc/mattei.h"
#include "privinc/imgdev.h"
#include "privinc/dddevice.h"
#include "privinc/polygon.h"
#include "privinc/matteimg.h"
#include "privinc/path2i.h"
#include "privinc/opt.h"

MatteImage::MatteImage(Matte *matte, Image *imgToStencil)
      : _matte(matte), AttributedImage(imgToStencil)
{

    Bbox2 box =
        IntersectBbox2Bbox2(_matte->BoundingBox(),
                            _image->BoundingBox());

    _box = box;
}

Bool   
MatteImage::DetectHit(PointIntersectCtx& ctx)
{
    DirectDrawImageDevice* ddDev = GetImageRendererFromViewport( GetCurrentViewport() );

    // Do trivial reject in Local Coordinates
    Point2Value *lcPt = ctx.GetLcPoint();
    if (!_box.Contains(Demote(*lcPt))) {
        return FALSE;
    }

    // Do actual picking in World Coordinates
    Point2Value *pt = ctx.GetWcPoint();

    //
    // Grab a DC for whatever surface the renderer deems correct
    //
    HDC hdc;
    hdc = ddDev->RenderGetDC("Couldn't get DC in MatteImage::DetectHit");
    if(!hdc) return FALSE;

    //
    // Accumulate the rgn in region for the given DC
    //
    HRGN region;
    bool justDoPath = false;
    Matte::MatteType result = 
        _matte->GenerateHRGN(hdc,
                             NULL,
                             NULL, 
                             ctx.GetTransform(),
                             &region,
                             justDoPath);

    // Using GetLcPoint and doing this would be ok too.  Greg thinks
    // it's lower risk to use the GetWcPoint as Steve suggested.  -RY
    //_matte->GenerateHRGN(hdc, identityTransform2, &region);
    
    GDI_Deleter regionDeleter((HGDIOBJ)region);

    //
    // Dump the DC, we don't need it
    //
    ddDev->RenderReleaseDC("Coultdn't release DC in MatteImage::Render");    

    switch (result) {
      case Matte::fullyOpaque:
      case Matte::fullyClear:

        switch (result) {
          case Matte::fullyOpaque:
            // Can't see anything through matte... go on.
            return FALSE; // XXX: hey, can you detect an opaque matte ?
            break;
            
          case Matte::fullyClear:
            return _image->DetectHit(ctx);
            break;
        }
        break;

      case Matte::nonTrivialHardMatte:

        // is the point in the region ?
        Bool hit =  ddDev->DetectHit(region, pt);

        if(hit) hit = _image->DetectHit(ctx);

        return hit;
        break;
    }

    return FALSE;
}


void
MatteImage::Render(GenericDevice& genDev)
{
    DirectDrawImageDevice& ddDev = SAFE_CAST(DirectDrawImageDevice &, genDev);

    // If we have a color key set, then turn on aa_solid and force
    // dagdi to raster using sample resolution of 1
    bool popQualFlags = false;
    DWORD oldQualFlags = ddDev.GetImageQualityFlags();
    int oldSampRes = ddDev.GetSampleResolution();
    if( ddDev.ColorKeyIsSet() ) {
        popQualFlags = true;
        ddDev.SetImageQualityFlags( oldQualFlags | CRQUAL_AA_SOLIDS_ON );
        ddDev.SetSampleResolution( 1 );
    }

    ddDev.RenderMatteImage(this, _matte, _image );

    if( popQualFlags ) {
        ddDev.SetImageQualityFlags( oldQualFlags );
        ddDev.SetSampleResolution( oldSampRes );
    }   
}

Real
MatteImage::DisjointBBoxAreas(DisjointCalcParam &param)
{
    DisjointCalcParam newParam;
    param.CalcNewParamFromBox(_matte->BoundingBox(), &newParam);

    return _image->DisjointBBoxAreas(newParam);
}

void
MatteImage::_CollectDirtyRects(DirtyRectCtx &ctx)
{
    Bbox2 oldClipBox = ctx.GetClipBox();

    ctx.AccumulateClipBox(_matte->BoundingBox());

    CollectDirtyRects(_image, ctx);
    
    ctx.SetClipBox(oldClipBox);
}


Bool
MatteImage::RenderWithCallBack(
    callBackPtr_t callBack,
    void *callBackCtx,
    HRGN *regionPtr,
    Transform2 *xform,
    bool justDoPath)
{
    Assert(callBackCtx && "callBackCtx is NULL in RenderWithCallBack");

    //
    // Accumulate the rgn in region for the given DC
    //
    Matte::MatteType result = 
        _matte->GenerateHRGN(NULL,
                             callBack,
                             callBackCtx, 
                             xform, 
                             regionPtr,
                             justDoPath);

    if( justDoPath ) return TRUE;
    
    switch (result) {
        
      case Matte::fullyOpaque:
      case Matte::fullyClear:
        
        switch (result) {
          case Matte::fullyOpaque:
            // Can't see anything through matte... go on.
            break;
            
          case Matte::fullyClear:
            // Just process as if no stencil were there
            DirectDrawImageDevice* ddDev = 
                GetImageRendererFromViewport( GetCurrentViewport() );
            _image->Render(*ddDev);
            break;
        }

        Assert( !(*regionPtr) && "A region shouldn't be defined here!");

        return FALSE;
        break;

      case Matte::nonTrivialHardMatte:

        Assert( (*regionPtr) && "A region should be defined here!");
        break;
    }
    return TRUE;
}

Image *
ClipImage(Matte *m, Image *im)
{
    Image *result = NULL;
    
    if (m == clearMatte) {
        
        // entire im shines through clearMatte
        result = im;
        
    } else if (m == opaqueMatte || im == emptyImage) {
        
        // nothing gets through opaqueMatte
        result = emptyImage;
        
    } else {

        // Specialized optimization that rewrites a potentially 
        // transformed text-path based matte with a solid color image
        // into an StringImage.  You can think of this transformation
        // as going from:
        //
        //   MatteImage(MatteFromPath(TextPath(myText).Transform(myXf)),
        //              SolidColorImage(myColor)
        //
        // to
        //
        //   StringImage(myText.Color(myColor)).Transform(myXf)
        //

        if (im->CheckImageTypeId(SOLIDCOLORIMAGE_VTYPEID)) {

            Path2 *p = m->IsPathRepresentableMatte();

            if (p) {
                
                Transform2 *xf = identityTransform2;
            
                TransformedPath2 *xfp = p->IsTransformedPath();

                if (xfp) {
                    // Just work on the raw path.
                    p = xfp->GetPath();
                    xf = xfp->GetXf();
                }

                // The underlying path had better not be a transformed
                // path.
                Assert(!p->IsTransformedPath());

                TextPath2 *tp = p->IsTextPath();
            
                if (tp) {

                    Text *text = tp->GetText();
                    bool  restartClip = tp->GetRestartClip();

                    // Can't do it if it's a restart clip... 
                    if (!restartClip) {

                        SolidColorImageClass *scImg =
                            SAFE_CAST(SolidColorImageClass *, im);

                        Color *col = scImg->GetColor();

                        Text *coloredText = TextColor(col, text);
                    
                        Image *newImg = RenderTextToImage(coloredText);

                        result = TransformImage(xf, newImg);

                    }

                }

            }
            
        }

        if (!result) {
        
            result = NEW MatteImage(m, im);

        }
    }

    return result;
}

int MatteImage::Savings(CacheParam& p) {

  //    return 0;   // disable caching of matted images because of off-by-one errors
// #if 0

    // individual matted solid color images themselves don't warrant
    // much of a score, but they should contribute so that overlays of
    // them can get a meaningful savings.
    
    if (_image->GetValTypeId() == SOLIDCOLORIMAGE_VTYPEID) {
        return 1;
    } else {
        return 2;
    }
    
// #endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\montage.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Private implementation of the montage type

*******************************************************************************/

#include "headers.h"
#include "appelles/montage.h"
#include "privinc/opt.h"

//// Define a container for image, depth pairs.

class ImageDepthPair {
  public:
    Image *image;
    Real  depth;
};

static int
operator<(ImageDepthPair i1, ImageDepthPair i2)
{
    return i1.depth < i2.depth;
}

static int
operator==(ImageDepthPair i1, ImageDepthPair i2)
{
    return i1.depth == i2.depth;
}

////////// Abstract Montage *implementation class  //////////////

class ATL_NO_VTABLE Montage : public AxAValueObj {
  public:

    // This method fills the vector in with any image/depth pairs in
    // the montage.  Note that it doesn't do any sorting.
    virtual void     DumpInto(vector<ImageDepthPair>& montageVec) = 0;

#if _USE_PRINT
    virtual ostream& Print(ostream& os) const = 0;
#endif

    virtual DXMTypeInfo GetTypeInfo() { return MontageType; }

};

////////////  Empty Montage *////////////

class EmptyMontage : public Montage {
  public:
    void     DumpInto(vector<ImageDepthPair>& montageVec) {}

#if _USE_PRINT
    ostream& Print(ostream& os) const {
        return os << "emptyMontage";
    }
#endif
};

Montage *emptyMontage = NULL;

////////////  Primitive Montage *////////////

// The primitive montage simply has a single image and depth.

class PrimitiveMontage : public Montage {
  public:
    PrimitiveMontage(Image *im, Real d) : _image(im), _depth(d) {}

    void     DumpInto(vector<ImageDepthPair>& montageVec) {
        ImageDepthPair p;
        p.image = _image;
        p.depth = _depth;

#if _DEBUG      
        int s = montageVec.size();
#endif
    
        montageVec.push_back(p);

#if _DEBUG      
        Assert(montageVec.size() == s + 1);
#endif
        
    }

#if _USE_PRINT
    ostream& Print(ostream& os) const {
        return os << "ImageMontage(" << _image << ", " << _depth << ")";
    }
#endif

    virtual AxAValue _Cache(CacheParam &p) {
        _image = SAFE_CAST(Image *, AxAValueObj::Cache(_image, p));
        return this;
    }

    virtual void DoKids(GCFuncObj proc) { (*proc)(_image); }

  protected:
    Image *_image;
    Real   _depth;
};

Montage *ImageMontage(Image *image, AxANumber *depth)
{
    return NEW PrimitiveMontage(image, NumberToReal(depth));
}


//////////  Composite Montage *////////////////

class CompositeMontage : public Montage {
  public:
    CompositeMontage(Montage *m1, Montage *m2) : _montage1(m1), _montage2(m2) {}

    // Just ask the sub-montages to fill in.
    void     DumpInto(vector<ImageDepthPair>& montageVec) {
        _montage1->DumpInto(montageVec);
        _montage2->DumpInto(montageVec);
    }

#if _USE_PRINT
    ostream& Print(ostream& os) const {
        return os << "(" << _montage1 << " + " << _montage2 << ")";
    }
#endif

    virtual AxAValue _Cache(CacheParam &p) {

        // Cache the individual pieces.  TODO: May want to try to
        // cache entirely as an overlay.
        // Just cache the individual pieces
        CacheParam newParam = p;
        newParam._pCacheToReuse = NULL;
        _montage1 = SAFE_CAST(Montage *, AxAValueObj::Cache(_montage1, newParam));
        _montage2 = SAFE_CAST(Montage *, AxAValueObj::Cache(_montage2, newParam));

        return this;
    }

    virtual void DoKids(GCFuncObj proc) { 
        (*proc)(_montage1);
        (*proc)(_montage2);
    }

  protected:
    Montage *_montage1;
    Montage *_montage2;
};

Montage *UnionMontageMontage(Montage *m1, Montage *m2)
{
    return NEW CompositeMontage(m1, m2);
}

//////////////////////////////////////////////////

Image *Render(Montage *m)
{
    vector<ImageDepthPair> imageDepthPairs;

    // Dump all of the images and depths into this vector
    m->DumpInto(imageDepthPairs);

    int numImages = imageDepthPairs.size();

    // Sort according to the depths, but maintain relative ordering
    // for those within a single depth.
    std::stable_sort(imageDepthPairs.begin(), imageDepthPairs.end());

    AxAValue *vals = THROWING_ARRAY_ALLOCATOR(AxAValue, numImages);

    for (int i = 0; i < numImages; i++) {
        vals[i] = imageDepthPairs[numImages-i-1].image;
    }

    AxAArray *arr = MakeValueArray(vals, numImages, ImageType); 
        
    delete [] vals;

    return OverlayArray(arr);
}

#if _USE_PRINT
ostream&
operator<<(ostream& os, Montage *m)
{
    return m->Print(os);
}
#endif

// TODO: Breakout a separate class that can just aggregate all of
// these together, rather than making separate binary trees.
Montage *UnionMontage(AxAArray *montages)
{
    montages = PackArray(montages);

    int numMtgs = montages->Length();

    Montage *result;
 
    switch (numMtgs) {
      case 0:
        result = emptyMontage;
        break;
 
      case 1:
        result = SAFE_CAST(Montage *, (*montages)[0]);
        break;
      
      default:
        result = SAFE_CAST(Montage *, (*montages)[0]);
        for(int i=1; i < numMtgs; i++) {
            // Be sure to union these in in the order they appear,
            // since order within a specific depth is important.
            result =
                UnionMontageMontage(result,
                                    SAFE_CAST(Montage *,
                                              ((*montages)[i])));
        }
        break;
    }

    return result;
}


void
InitializeModule_Montage()
{
    emptyMontage = NEW EmptyMontage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\imagei.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

Abstract:
    Implements image operations and subclasses.

*******************************************************************************/

#include "headers.h"
#include "privinc/imagei.h"
#include "privinc/overimg.h"
#include "privinc/imgdev.h"
#include "privinc/ddrender.h"
#include "appelles/geom.h"
#include "appelles/camera.h"
#include "appelles/path2.h"
#include "appelles/linestyl.h"
#include "privinc/geomi.h"
#include "privinc/bbox2i.h"
#include "privinc/dddevice.h"
#include "privinc/probe.h"
#include "privinc/except.h"
#include "privinc/util.h"
#include "privinc/cachdimg.h"
#include "privinc/basic.h"
#include "privinc/xform2i.h"
#include "backend/values.h"
#include "backend/preference.h"
#include "privinc/drect.h"
#include "privinc/opt.h"

void
RenderImageOnDevice(DirectDrawViewport *vp,
                    Image *image,
                    DirtyRectState &d)
{
    vp->RenderImage(image, d);
}


Bbox2Value *BoundingBox(Image *image)
{
    return Promote(image->BoundingBox());
}

#if _USE_PRINT
// Image *printing function.
ostream&
operator<<(ostream &os, Image *image)
{
    return image->Print(os);
}
#endif

//////////////  UNRenderable IMAGE  ////////////////////

#if 0
void UnrenderableImage::Render(GenericDevice& dev) {
    if (dev.GetRenderMode() != RENDER_MODE)   return;
    ImageDisplayDev &idev = SAFE_CAST(ImageDisplayDev &, dev);
    idev.RenderUnrenderableImage();
}
#endif

//////////////  Cached IMAGE  ////////////////////

// Return incoming image if we choose not to cache.

Image *
CacheHelper(Image *imgToCache, CacheParam &p)
{
    Image *img;

    // Can't properly cache things that have elements that get
    // externally updated.  May be able to revisit and propagate
    // changes properly to cause re-caching.  Also can't deal with
    // elements with opacity.
    
    DWORD cantDoIt = IMGFLAG_CONTAINS_EXTERNALLY_UPDATED_ELT |
                     IMGFLAG_CONTAINS_OPACITY;
    
    if (imgToCache->GetFlags() & cantDoIt) {

        img = NULL;
        
    } else {
    
        Assert(!p._pCacheToReuse ||
               !(*p._pCacheToReuse) ||
               SAFE_CAST(Image *, *p._pCacheToReuse));
    
        img =
            p._idev->CanCacheImage(imgToCache,
                                   (Image **)p._pCacheToReuse,
                                   p);

#if _DEBUG
        if (IsTagEnabled(tagCacheOpt)) {
            Bbox2 bb = imgToCache->BoundingBox();
            float res = p._idev->GetResolution();
            int l = (int)(bb.min.x * res);
            int r = (int)(bb.max.x * res);
            int t = (int)(bb.min.y * res);
            int b = (int)(bb.max.y * res);
            TraceTag((tagCacheOpt,
                      "Caching an image: %x as %x - %s.  Bbox = (%d, %d) -> (%d, %d)",
                      imgToCache, img, img ? "SUCCEEDED" : "FAILED",
                      l, t, r, b));
        }
    
#endif    

    }
    
    return img ? img : imgToCache;
}



/*****************************************************************************
The constructor for the images, besides initializing various members, also
stamps itself with a unique identifier for use in texture and other caching.
*****************************************************************************/

static CritSect *ImageIdCritSect = NULL;   // Image Id CritSection
long   Image::_id_next = 0;                // Image ID Generator

Image::Image()
{
    _opacity = 1.0;
    _flags = IMGFLAG_IS_RENDERABLE;
    _creationID = PERF_CREATION_ID_BUILT_EACH_FRAME;
    _oldestConstituentSampleId = _creationID;
    _cachedImage = NULL;

    // Stamp the image with a unique identifier.

    {
        CritSectGrabber csg(*ImageIdCritSect);
        _id = _id_next++;
    }

    #if _DEBUG
        _desiredRenderingWidth  = -1;
        _desiredRenderingHeight = -1;
    #endif /* _DEBUG */
}


// TODO: We should also be accumulating clips and crops, as they
// affect the images bbox.  So, this should be implemented on Clipped
// and Cropped images (though it's not harmful that it's not...)
Real
Image::DisjointBBoxAreas(DisjointCalcParam &param)
{
    // By default, just get the image's bbox, transform it by the
    // accumulated xform, intersect it with the accumulated clipbox,
    // and get the result's area. 
    Bbox2 xformedBbox = TransformBbox2(param._accumXform, BoundingBox());

    Bbox2 clippedBox = IntersectBbox2Bbox2(xformedBbox,
                                            param._accumulatedClipBox);
    
    return clippedBox.Area();
}


void
Image::CollectDirtyRects(Image *img, DirtyRectCtx &ctx)
{
    // By default, we need to look at the creation ID and, based on
    // it, do one of the following:
    // a) If sample is constant since last frame, then it's not going
    //    to be part of a dirty rect.  Don't do anything in this
    //    case. 
    // b) If sample is non-constant, and contains no overlays, then
    //    get its bbox, transform it, and add to the dirty rect list
    // c) If sample is non-constant and contains overlays, proceed
    //    down the overlays.
    // d) If we've been told (via the ctx) to process everything, then
    //    just blindly continue down.

    if (img == emptyImage) {
        return;
    }
    
    int id = img->GetCreationID();
    bool process = ctx._processEverything ||
                   id == PERF_CREATION_ID_BUILT_EACH_FRAME || 
                   id > ctx._lastSampleId;

    if (process) {

        // Non-constant, determine if it has an overlay
        if (img->_flags & IMGFLAG_CONTAINS_OVERLAY) {

            // Node has overlays.  Continue down it.
            img->_CollectDirtyRects(ctx);

        } else if (img->_flags & IMGFLAG_CONTAINS_UNRENDERABLE_WITH_BOX) {

            // Ignore this node, it can't have an overlay, and we
            // don't want to add it in to our context.  TODO: Note
            // that the better way to do ttis whole thing about
            // UNRENDERABLE_WITH_BOX would be just to have a bbox
            // collection context, but that would require changes to
            // the signature of bbox, which is too much work right
            // now. 
            
            // Just for setting a breakpoint...
            Assert(img);
            
        } else if (img != emptyImage) {

            // There are no overlays, and this is time varying, so
            // grab the rectangle.
            Bbox2 bb = img->BoundingBox();

            // Ignore null bounding boxes.
            if (bb != NullBbox2) {
                Bbox2 xformedBbox =
                    TransformBbox2(ctx._accumXform, bb);

                ctx.AddDirtyRect(xformedBbox);
            }
            
        }
        
    } else {

        // Record that this image was found in this frame.  Stash it
        // along with the currently accumulated bbox on the context,
        // to distinguish multiple instances of this image.  If the
        // same pair wasn't found last time, then we'll need to extend
        // our dirty rectangle list to include it.  After we're done
        // collecting, we'll see if there were any from last frame
        // that are not in this frame.  These are guys we'll need to
        // add to our dirty rectangle list as well, to restore the
        // background they've uncovered.

        Bbox2 bb = img->BoundingBox();
        Bbox2 xfBox =
            TransformBbox2(ctx._accumXform, bb);

        ctx.AddToConstantImageList(img, xfBox);

    }
}


void
Image::_CollectDirtyRects(DirtyRectCtx &ctx)
{
    // The default dirty rectangle collector doesn't do anything.  We
    // test to be sure there are no overlays.  If there are, we've
    // made an internal logic error, since all of those nodes need to
    // override this method.
    Assert(!(_flags & IMGFLAG_CONTAINS_OVERLAY));
}


AxAValue Image::_Cache(CacheParam &p)
{
    Assert(p._idev && "NULL dev passed into cache.");

    Image *ret;

    int c = this->Savings(p);

    if (c >= savingsThreshold) {

        ret = CacheHelper(this, p);

    } else {
        
        ret = this;
        
    }

    return ret;
}


void Image::DoKids(GCFuncObj proc)
{
    (*proc)(_cachedImage);
}


// Returning -1 means that there is no conclusive rendering resolution
// for this image.
void
Image::ExtractRenderResolution(short *width, short *height, bool negOne)
{
    if (_flags & IMGFLAG_CONTAINS_DESIRED_RENDERING_RESOLUTION) {
        
        Assert(_desiredRenderingWidth != -1);
        Assert(_desiredRenderingHeight != -1);
        
        *width = _desiredRenderingWidth;
        *height = _desiredRenderingHeight;

    } else {
        
        if (negOne) {
            *width = -1;
            *height = -1;
        }
            
#if _DEBUG
        // In debug, always set these to -1.
        *width = -1;
        *height = -1;
#endif /* _DEBUG */
        
    }
}


class CachePreferenceClosure : public PreferenceClosure {
  public:
    CachePreferenceClosure(Image *im, CacheParam &p) :
    _image(im), _p(p) {}
        
    void Execute() {
        _result = AxAValueObj::Cache(_image, _p);
    }

    Image          *_image;
    CacheParam     &_p;
    AxAValue        _result;
};

class SavingsPreferenceClosure : public PreferenceClosure {
  public:
    SavingsPreferenceClosure(Image *im, CacheParam &p) :
    _image(im), _p(p) {}
        
    void Execute() {
        _result = _image->Savings(_p);
    }

    Image          *_image;
    CacheParam     &_p;
    int             _result;
};


class CachePreferenceImage : public AttributedImage {
  public:
    CachePreferenceImage(Image *img,
                         BoolPref bitmapCaching,
                         BoolPref geometryBitmapCaching)
    : AttributedImage(img)
    {
        _bitmapCaching = bitmapCaching;
        _geometryBitmapCaching = geometryBitmapCaching;
    }

    AxAValue _Cache(CacheParam &p) {
        CachePreferenceClosure cl(_image, p);
        PreferenceSetter ps(cl,
                            _bitmapCaching,
                            _geometryBitmapCaching);
        ps.DoIt();
        AxAValue result = cl._result;

        return result;
    }

    int Savings(CacheParam &p) {
        SavingsPreferenceClosure cl(_image, p);
        PreferenceSetter ps(cl,
                            _bitmapCaching,
                            _geometryBitmapCaching);
        ps.DoIt();
        int result = cl._result;

        return result;
    }
    
#if _USE_PRINT
    ostream& Print (ostream &os) {
        return os << "CachePreference" << _image;
    }
#endif
    
  protected:
    BoolPref _bitmapCaching;
    BoolPref _geometryBitmapCaching;
};

AxAValue
Image::ExtendedAttrib(char *attrib, VARIANT& val)
{
    Image *result = this;       // unless we figure out otherwise. 

    CComVariant ccVar;
    HRESULT hr = ccVar.ChangeType(VT_BOOL, &val);

    if (SUCCEEDED(hr)) {

        bool prefOn = ccVar.boolVal ? true : false;

        bool gotOne = false;
        BoolPref bmapCaching = NoPreference;
        BoolPref geometryBmapCaching = NoPreference;
    
        if (0 == lstrcmp(attrib, "BitmapCachingOn")) {
            gotOne = true;
            bmapCaching = prefOn ? PreferenceOn : PreferenceOff;
        } else if (0 == lstrcmp(attrib, "GeometryBitmapCachingOn")) {
            gotOne = true;
            geometryBmapCaching = prefOn ? PreferenceOn : PreferenceOff;
        }

        if (gotOne) {
            result = NEW CachePreferenceImage(this,
                                              bmapCaching,
                                              geometryBmapCaching);
        }

    }

    return result;
}

///////////////////  AttributedImage  /////////////

AttributedImage::AttributedImage(Image *image)
    : _image(image)
{
    //
    // Inherit the opacity of the underlying image
    //
    SetOpacity( image->GetOpacity() );

    // Get flags from the underlying image.
    _flags = _image->GetFlags();

    short w, h;
    _image->ExtractRenderResolution(&w, &h, false);

    _desiredRenderingWidth = w;
    _desiredRenderingHeight = h;

    // For an attributed image, the oldest constituent is the oldest
    // constituent of the base image.
    _oldestConstituentSampleId = _image->GetOldestConstituentID();
}

void
AttributedImage::Render(GenericDevice& dev) {
    // By default, just delegate to the image.
    _image->Render(dev);
}   

// ---
// These methods all delegate to the image.  They can all be
// overridden in subclasses. 
// ---

// Extract a bounding box from this image, outside of which
// everything is transparent.
const Bbox2
AttributedImage::BoundingBox(void) {
    // By default, just delegate to the image

    return _image->BoundingBox();
}

Real
AttributedImage::DisjointBBoxAreas(DisjointCalcParam &param) {
    return _image->DisjointBBoxAreas(param);
}

void
AttributedImage::_CollectDirtyRects(DirtyRectCtx &ctx)
{

    if (ctx._processEverything) {

        CollectDirtyRects(_image, ctx);

    } else {
    
        // We're here because either the attribute of this image is new
        // or the underlying image is new (or both).  If the attribute is
        // new, the image will claim to be old, but we still want to
        // process it, so we set the override state in the ctx to do
        // that.

        Assert(GetCreationID() == PERF_CREATION_ID_BUILT_EACH_FRAME ||
               GetCreationID() > ctx._lastSampleId);

    
        long imId = _image->GetCreationID();
        bool imageNew = (imId == PERF_CREATION_ID_BUILT_EACH_FRAME ||
                         imId > ctx._lastSampleId);

        bool setProcessEverything =
            !imageNew && !ctx._processEverything;
    
        if (setProcessEverything) {
            ctx._processEverything = true;
        }

        CollectDirtyRects(_image, ctx);

        if (setProcessEverything) {
            Assert(ctx._processEverything);
            ctx._processEverything = false;
        }

    }
}

#if BOUNDINGBOX_TIGHTER
const Bbox2
AttributedImage::BoundingBoxTighter(Bbox2Ctx &bbctx) {
    // By default, just delegate to the image

    return _image->BoundingBoxTighter(bbctx);
}
#endif  // BOUNDINGBOX_TIGHTER

// Process an image for hit detection
Bool
AttributedImage::DetectHit(PointIntersectCtx& ctx) {
    // By default, just delegate to the image
    return _image->DetectHit(ctx);
}

int
AttributedImage::Savings(CacheParam& p)
{
    return _image->Savings(p);
}

// This, by default, just returns the box.  Certain classes will
// override. 
const Bbox2 
AttributedImage::OperateOn(const Bbox2 &box)
{
    return box;
}

void
AttributedImage::DoKids(GCFuncObj proc)
{
    Image::DoKids(proc);
    (*proc)(_image);
}

bool
AttributedImage::ContainsOcclusionIgnorer()
{
    return _image->ContainsOcclusionIgnorer();
}

AxAValue AttributedImage::_Cache(CacheParam &p)
{
    Assert(p._idev && "NULL dev passed into cache.");

    Image *ret = this;
    int c = this->Savings(p);

    if (c >= savingsThreshold) {

        // First try to cache entire image.
        Image *cachedImage = CacheHelper(this, p);

        // CacheHelper returns "this" if it's unable to successfully
        // cache. 
        if (cachedImage != this) {
            return cachedImage;
        }
    }

    // If entire attributed image can't be cached, try to cache the
    // underlying image.
    _image = SAFE_CAST(Image *, AxAValueObj::Cache(_image, p));
    
    return this;
}
    
//////////////  EmptyImage  ////////////////////

#if _DEBUG
bool g_createdEmptyImage = false;
#endif _DEBUG

class EmptyImageClass : public UnrenderableImage {
  public:
    EmptyImageClass() {
        _creationID = PERF_CREATION_ID_FULLY_CONSTANT;
        _oldestConstituentSampleId = PERF_CREATION_ID_FULLY_CONSTANT;
        

#if _DEBUG
        // Only one of these should ever be created, else our
        // assumption about the creation id is wrong.
        Assert(!g_createdEmptyImage);
        g_createdEmptyImage = true;
#endif _DEBUG   

    }
#if _USE_PRINT
    ostream& Print (ostream &os) {
        return os << "emptyImage";
    }
#endif
};

Image *emptyImage = NULL;

//////////////  DetectableEmptyImage  ////////////////////

#if _DEBUG
bool g_createdTransparentPickableImage = false;
#endif _DEBUG

class TransparentPickableImageClass : public UnrenderableImage {
  public:
    TransparentPickableImageClass() {
        _creationID = PERF_CREATION_ID_FULLY_CONSTANT;
        _oldestConstituentSampleId = PERF_CREATION_ID_FULLY_CONSTANT;

        // Note that the better way to do ttis whole thing about
        // UNRENDERABLE_WITH_BOX would be just to have a bbox
        // collection context, so that bbox for this guy would return
        // NULL when we're collecting "rendering" bboxes, and
        // universalBbox when collecting "picking" bboxes, but that
        // would require changes to the signature of bbox, which is
        // too much work right now.
        _flags = IMGFLAG_CONTAINS_UNRENDERABLE_WITH_BOX;

#if _DEBUG
        // Only one of these should ever be created, else our
        // assumption about the creation id is wrong.
        Assert(!g_createdTransparentPickableImage);
        g_createdTransparentPickableImage = true;
#endif _DEBUG   
        
    }

    // This image has a universal bbox, since it's detectable
    // everywhere. 
    inline const Bbox2 BoundingBox(void) { return UniverseBbox2; }

#if BOUNDINGBOX_TIGHTER
    Bbox2 *BoundingBoxTighter(Bbox2Ctx &bbctx) { return universeBbox2; }
#endif  // BOUNDINGBOX_TIGHTER

    // This image is always hit
    Bool  DetectHit(PointIntersectCtx& ctx) { return TRUE; }

#if _USE_PRINT
    ostream& Print (ostream &os) {
        return os << "InternalTransparentPickableImage";
    }
#endif
};

Image *detectableEmptyImage = NULL;


/////////////////  Undetectable Image /////////////////////

class UndetectableImg : public AttributedImage {
  public:
    UndetectableImg(Image *image) : AttributedImage(image) {}

    // The undetectable image just delegates everything to the
    // subimage, except for hit detection, which is always false. 
    Bool DetectHit(PointIntersectCtx&) { return FALSE; }

#if _USE_PRINT
    ostream& Print (ostream &os) {
        return os << "undetectable(" << _image << ")";
    }
#endif

};

Image *
UndetectableImage(Image *image)
{
    return NEW UndetectableImg(image);
}

Image *MapToUnitSquare(Image *img)
{
    Bbox2 bbox = img->BoundingBox();

    Point2 min = bbox.min;
    Point2 max = bbox.max;
    double xmin = min.x;
    double ymin = min.y;
    double xmax = max.x;
    double ymax = max.y;

    bool isInfinite =
        (fabs(xmin) == HUGE_VAL) ||
        (fabs(xmax) == HUGE_VAL) ||
        (fabs(ymin) == HUGE_VAL) ||
        (fabs(ymax) == HUGE_VAL);

    if (isInfinite || (xmax == xmin) || (ymax == ymin)) {
        return img;
    }
        
    double xscl = 1.0 / (xmax - xmin);
    double yscl = 1.0 / (ymax - ymin);

    Transform2 *sxf = ScaleRR(xscl, yscl);
    Transform2 *txf = TranslateRR(-xmin, -ymin);
    return TransformImage(TimesTransform2Transform2(sxf, txf),
                          img);
    
}

Image *ClipPolygon(AxAArray* points, Image* image)
{
  return ClipImage(RegionFromPath(PolyLine2(points)), image);
}

// This calls _BoundingBox if cached is false, set cached, stashed the
// bbox points into cachedBox.  It returns a Bbox2 of the same
// value of cachedBox.
// TODO: This is temp until we deal with the sharing issues later
const Bbox2 CacheImageBbox2(Image *img, bool& cached, Bbox2 &cachedBox)
{
    // use default copy constructor to copy bits
    // NOTE: don't just return &cachedBox, it'll be treated as a real
    // AxAValueObj then.
    
    if (!cached) {
        Bbox2 b = img->_BoundingBox();
        cachedBox = b;         
        cached = true;
        return b;
    }

    return cachedBox;
}

///////////////////////////////////////////////////////////

void
InitializeModule_Image()
{
    ImageIdCritSect = NEW CritSect;
    emptyImage = NEW EmptyImageClass;
    detectableEmptyImage = NEW TransparentPickableImageClass;
}

void
DeinitializeModule_Image(bool)
{
    delete ImageIdCritSect;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\opaqeimg.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of an OpaqueImage, subclass
    of Image.

--*/

#include "headers.h"
#include <privinc/imagei.h>
#include <privinc/imgdev.h>

//
// yup, the OpaqueImageClass is in imagei.h
//

Image *OpaqueImage(AxANumber *opacity, Image *image)
{
   return NEW OpaqueImageClass(NumberToReal(opacity), image);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\movieimg.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

     Implements a movie (mpeg or avi) image

*******************************************************************************/

#include <headers.h>

#include "privinc/movieImg.h"
#include "privinc/imgdev.h"
#include "privinc/geomimg.h"
#include "privinc/dispdevi.h"
#include "privinc/imagei.h"
#include "privinc/imgdev.h"
#include "privinc/ddrender.h"
#include "privinc/probe.h"
#include "privinc/camerai.h"
#include "privinc/except.h"
#include "privinc/dddevice.h"
#include "appelles/readobj.h"
#include "backend/moviebvr.h"
#include "privinc/urlbuf.h"
#include "privinc/bufferl.h"  // bufferElement db stuff

//////////////  Image from movie  ////////////////////
MovieImage::MovieImage(QuartzVideoReader *videoReader, Real res)
: _dev(NULL), _url(NULL)
{
    Assert(videoReader && "no movie class!");
    Assert(res>0 && "bad res for movie image");
    _resolution = res;
    _width  = videoReader->GetWidth();
    _height = videoReader->GetHeight();

    { // keep a copy the url so we may generate new streams later
        char *url = videoReader->GetURL();
        _url = (char *)StoreAllocate(GetSystemHeap(), strlen(url)+1);
        strcpy(_url, url);
    }

    SetRect(&_rect, 0,0, _width, _height);
    _membersReady = TRUE;

    _length = videoReader->GetDuration();

    TraceTag((tagGCMedia, "MovieImage(%x)::MovieImage stream %x",
              this, videoReader));
}


void MovieImage::CleanUp()
{
    StoreDeallocate(GetSystemHeap(), _url);

    // Why are we acquiring this lock?  Never acquire a lock and call
    // a function which may also acquire a lock.  This currently
    // causes deadlock in our system - not a good thing to do.
//    extern Mutex avModeMutex;
//    MutexGrabber mg(avModeMutex, TRUE); // Grab mutex

    DiscreteImageGoingAway(this);
} // end mutex context


MovieImageFrame::MovieImageFrame(Real time, MovieImagePerf *p)
: _perf(p), _time(time)
{
    _movieImage = _perf->GetMovieImage();
    _width      = _movieImage->GetPixelWidth();
    _height     = _movieImage->GetPixelHeight();
    _resolution = _movieImage->GetResolution();
    SetRect(&_rect, 0,0, _width, _height);
    _membersReady = TRUE;
}


void
MovieImageFrame::DoKids(GCFuncObj proc)
{
    DiscreteImage::DoKids(proc);
    (*proc)(_movieImage);
    (*proc)(_perf);
}


// --------------------------------------------------
// MOVIE IMAGE FRAME:  RENDER
// --------------------------------------------------
void
MovieImageFrame::Render(GenericDevice& _dev)
{
    if(_dev.GetDeviceType() != IMAGE_DEVICE)
        return; // no sound under images...

    bool forceFallback = false;  // force a fallback?

    TimeXform tt = _perf->GetTimeXform();

    if(!tt->IsShiftXform())
        forceFallback = true;   // fallback to non-retained mode!

    ImageDisplayDev &dev = SAFE_CAST(ImageDisplayDev &, _dev);
    dev.StashMovieImageFrame(this);
    // we will probably pass the bufferElement to this call eventualy
    dev.RenderMovieImage(GetMovieImage(), GetTime(), _perf, forceFallback);
    dev.StashMovieImageFrame(NULL);
}


void
DirectDrawImageDevice::RenderMovieImage(MovieImage *movieImage,
                                        Real time,
                                        MovieImagePerf *perf,
                                        bool forceFallback,
                                        DDSurface *targDDSurf)
{
    QuartzVideoBufferElement *bufferElement = perf->GetBufferElement();
    SurfaceMap *surfMap = GetSurfaceMap();

    bool b8Bit = (_viewport.GetTargetBitDepth() == 8)?true:false;

    // Don't render to the same targDDSurf at the same time
    // more than once per frame!
    if(targDDSurf) {
        if(time == targDDSurf->GetTimeStamp())
            return;
        else
            targDDSurf->SetTimeStamp(time);
    }

    // since movies are emptyImage outside of defined time range (0,movieLength)
    // we only do the work for the defined range and do nothing otherwise!
    //if((time >= 0.0) && (time <= movieImage->GetLength())) {
    // as a work around for the texture image when end of movie bug, I am
    // just going to allow movies to go continue rendering
    if(1){
        bool           thisIsAnOldFrame = false;
        LPDDRAWSURFACE givenMovieSurf   = NULL;

        // Get the surface associated with this movie image
        DDSurfPtr<DDSurface> mvDDSurf = perf->GetSurface();

        if (bufferElement == NULL) {
            bufferElement = perf->GrabMovieCache();

            if (bufferElement == NULL) {
                QuartzVideoStream *quartzStream =
                    NEW QuartzVideoStream(movieImage->GetURL(),
                                          mvDDSurf,
                                          forceFallback);

                bufferElement =
                    NEW QuartzVideoBufferElement(quartzStream);
            }

            perf->SetBufferElement(bufferElement);
        }

        QuartzVideoReader *videoReader =
            bufferElement->GetQuartzVideoReader();

        if(forceFallback && (videoReader->GetStreamType()==AVSTREAM))
            videoReader = bufferElement->FallbackVideo(true, mvDDSurf); // seekable

        bufferElement->FirstTimeSeek(time);

        if(!mvDDSurf) { // not cached in the performance yet, (our first time!)
            _ddrval = videoReader->GetFrame(time, &givenMovieSurf); // get surf
            if(_ddrval == MS_S_ENDOFSTREAM) // XXX query reader instead?
                perf->TriggerEndEvent();
            if(!givenMovieSurf) {
                TraceTag((tagAVmodeDebug,
                          "RenderMovieImage discovered video gone FALLBACK!!"));

                // not seekable, no surface to re-use
                videoReader = bufferElement->FallbackVideo(false, NULL);

                _ddrval = videoReader->GetFrame(time, &givenMovieSurf);
                if(!givenMovieSurf)
                    return;  // XXX hack for now
            }

            // XXX remove the SafeToContinue code?
            bool safe = videoReader->SafeToContinue();
            if(!safe) {
                // XXX call something on the stream which causes audio
                //     to be disconnected!
            }
            if(FAILED(_ddrval))
                RaiseException_InternalError("Couldn't get movie frame");

            TraceTag((tagAVmodeDebug,
                      "creating new mvDDSurf with surface = %x", givenMovieSurf));

            NEWDDSURF(&mvDDSurf,
                      givenMovieSurf,
                      movieImage->BoundingBox(),
                      movieImage->GetRectPtr(),
                      GetResolution(),
                      0, false, false, true,
                      "MovieImage Surface");

            perf->SetSurface(mvDDSurf); // Stash movie surface in performance
        } else {
            if(forceFallback && (videoReader->GetStreamType()==AVSTREAM)) {
                // seekable, re-use surface
                videoReader = bufferElement->FallbackVideo(true, mvDDSurf);
            }

            // Try to get the current frame.
            // If it's not available, use whatever's in mvDDSurf

            // Re-use an equivalent movie img frame
            if(time==mvDDSurf->GetTimeStamp()) {
                thisIsAnOldFrame = true;
            } else {
                mvDDSurf->SetTimeStamp(time);
            }

            if(!thisIsAnOldFrame) {
                _ddrval = videoReader->GetFrame(time, &givenMovieSurf);
                if(_ddrval == MS_S_ENDOFSTREAM) // XXX query reader instead?
                    perf->TriggerEndEvent();
                if(!givenMovieSurf) {
                    TraceTag((tagAVmodeDebug,
                              "RenderMovieImage discovered video gone FALLBACK!!"));

                    videoReader = bufferElement->FallbackVideo(false, mvDDSurf);
                    _ddrval = videoReader->GetFrame(time, &givenMovieSurf);
                }

                bool safe = videoReader->SafeToContinue();
                if(!safe) {
                    // XXX call something on the stream which causes audio
                    //     to be disconnected!
                }
                if(FAILED(_ddrval))  {
                    if(!mvDDSurf->IDDSurface())
                        RaiseException_InternalError("Couldn't get movie frame");
                    else
                        givenMovieSurf = mvDDSurf->IDDSurface();
                }
            }
        }

        if(!thisIsAnOldFrame) {

            // if we're paletized, convert the movie to our
            // palette
            if(b8Bit) {
                // make sure we have one stashed in mvDDSurf
                DAComPtr<IDDrawSurface> convSurf = mvDDSurf->ConvertedSurface();
                if(!convSurf) {

                    // Ok, create an identical surface and pass it
                    // on as the real thing.

                    _viewport.CreateOffscreenSurface(&convSurf,
                                                     _viewport.GetTargetPixelFormat(),
                                                     mvDDSurf->Width(),
                                                     mvDDSurf->Height());

                    _viewport.AttachCurrentPalette(convSurf);

                    mvDDSurf->SetConvertedSurface(convSurf); // stick in mvDDSurf
                }

                {
#define KEEP_FOR_DX5 0
#if KEEP_FOR_DX5
                    // convert
                    RECT rect = *(mvDDSurf->GetSurfRect());
                    HDC srcDC = mvDDSurf->GetDC("couldn't getDC for movie surf conversion (Src)");

                    HDC destDC; _ddrval = convSurf->GetDC(&destDC);
                    IfDDErrorInternal(_ddrval, "couldn't getDC for movie surf conversion (dest)");

                    int ret;
                    TIME_GDI(ret = StretchBlt(destDC,
                                              rect.left,
                                              rect.top,
                                              rect.right - rect.left,
                                              rect.bottom - rect.top,
                                              srcDC,
                                              rect.left,
                                              rect.top,
                                              rect.right - rect.left,
                                              rect.bottom - rect.top,
                                              SRCCOPY));
                    convSurf->ReleaseDC(destDC);
                    mvDDSurf->ReleaseDC("");
#endif // KEEP_FOR_DX5
                }

                {
#define CONVERT2 1
#if CONVERT2
                    //
                    // convert
                    //
                    IDDrawSurface *srcSurf = mvDDSurf->IDDSurface();

                    RECT rect = *(mvDDSurf->GetSurfRect());

                    HDC destDC; _ddrval = convSurf->GetDC(&destDC);
                    IfDDErrorInternal(_ddrval, "couldn't getDC for movie surf conversion (dest)");

                    LONG w = rect.right - rect.left;
                    LONG h = rect.bottom - rect.top;

                    struct {
                        BITMAPINFO b;
                        char foo[4096];  // big enough!
                    } bar;

                    bar.b.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                    bar.b.bmiHeader.biWidth = w; // reset below to pitch
                    bar.b.bmiHeader.biHeight = -h; // top down dib
                    bar.b.bmiHeader.biPlanes = 1;
                    bar.b.bmiHeader.biBitCount = 8;
                    bar.b.bmiHeader.biCompression = BI_RGB;
                    bar.b.bmiHeader.biSizeImage = 0;
                    bar.b.bmiHeader.biXPelsPerMeter =0;
                    bar.b.bmiHeader.biYPelsPerMeter = 0;
                    bar.b.bmiHeader.biClrUsed = 256;
                    bar.b.bmiHeader.biClrImportant = 0;

                    // Get palette
                    LPDIRECTDRAWPALETTE pal;
                    _ddrval = srcSurf->GetPalette( &pal );
                    IfDDErrorInternal(_ddrval, "can't get palette man");

                    PALETTEENTRY entries[256];
                    _ddrval = pal->GetEntries(0, 0, 256, entries);
                    IfDDErrorInternal(_ddrval, "GetEntries faild on palette in RenderMovie");
                    pal->Release();

                    RGBQUAD *quads = bar.b.bmiColors;
                    for( int i = 0; i < 256; i++ )
                      {
                          quads[i].rgbBlue = entries[i].peBlue;
                          quads[i].rgbGreen = entries[i].peGreen;
                          quads[i].rgbRed = entries[i].peRed;
                          quads[i].rgbReserved = 0;
                      }


                    // LOCK SRC SURFACE
                    DDSURFACEDESC srcDesc;
                    srcDesc.dwSize = sizeof(DDSURFACEDESC);
                    _ddrval = srcSurf->Lock(NULL, &srcDesc, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
                    if(_ddrval != DD_OK) {  convSurf->ReleaseDC(destDC);}
                    IfDDErrorInternal(_ddrval, "Can't Get destSurf lock for AlphaBlit");

                    void *srcp = srcDesc.lpSurface;
                    long srcPitch = srcDesc.lPitch;

                    bar.b.bmiHeader.biWidth = srcPitch;

                    //  B L I T    B L I T
                    SetMapMode(destDC, MM_TEXT);

                    int ret;
                    ret = StretchDIBits(destDC,
                                        rect.left, rect.top, w, h,
                                        rect.left, rect.top, w, h,
                                        srcp,
                                        &bar.b,
                                        DIB_RGB_COLORS,
                                        SRCCOPY);
#if _DEBUG
                    if(ret==GDI_ERROR) {
                        void *msgBuf;
                        FormatMessage(
                            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            GetLastError(),
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                            (LPTSTR) &msgBuf,
                            0,
                            NULL );

                        AssertStr(false, (char *)msgBuf);

                        LocalFree( msgBuf );
                    }
#endif

                    srcSurf->Unlock(srcp);
                    convSurf->ReleaseDC(destDC);

                    if(ret==GDI_ERROR) {
                        RaiseException_InternalError("StretchDIBits failed (movie 8bpp color conversion)");
                    }

#endif // convert2

                } // convert2

            }
        }

        DebugCode(
            if(givenMovieSurf) {
                // make sure the stashed surface is the same as the givensurf
                Assert((mvDDSurf->IDDSurface() == givenMovieSurf) &&
                       "Given movie surface not equal for formerly stashed surface!");
            }
            );

        IDDrawSurface *tmpSurf = NULL;
        if(b8Bit) {
            // swap surfaces.
            tmpSurf = mvDDSurf->IDDSurface();
            mvDDSurf->SetSurfacePtr( mvDDSurf->ConvertedSurface() );
        }

        if(targDDSurf) {
            // target surface has been specified.  render there to fill target
            TIME_DDRAW(targDDSurf->
                       Blt(targDDSurf->GetSurfRect(),
                           mvDDSurf, mvDDSurf->GetSurfRect(),
                           DDBLT_WAIT, NULL));
        } else { // Now that we have movie in mvDDSurf, render it like a dib...
            // Push the image onto the map
            surfMap->StashSurfaceUsingImage(movieImage, mvDDSurf); // Stash movie surface in performance
            RenderDiscreteImage(movieImage);
            surfMap->DeleteMapEntry(movieImage);  // XXX Pop it back off again!
        }


        if( tmpSurf ) { // replace surfaces
            mvDDSurf->SetConvertedSurface( mvDDSurf->IDDSurface() );
            mvDDSurf->SetSurfacePtr( tmpSurf );
        }

        // implicit release of mvDDSurf reference
    }   // end of movie defined
    else { // we are out of the defined range of the movie
        // check to see if we were playing.  If so send a trigger event
        if(0)
            perf->TriggerEndEvent();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\lineimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Line Image

*******************************************************************************/

#include "headers.h"
#include "privinc/imagei.h"
#include "privinc/imgdev.h"
#include "privinc/vec2i.h"
#include "privinc/bbox2i.h"
#include "privinc/probe.h"
#include "privinc/dddevice.h"
#include "privinc/path2i.h"
#include "privinc/linei.h"


//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
// Line Image
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////

DeclareTag(tagEnableLineBitmap, "Optimizations", "enable line bitmap cache");

class LineImage : public Image {
  public:
    LineImage(Path2 *path, LineStyle *style)
        : _path(path), _style(style) {}

    void Render(GenericDevice& dev);

    const Bbox2 BoundingBox (void);

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter (Bbox2Ctx &bbctx);
#endif  // BOUNDINGBOX_TIGHTER

    const Bbox2 OperateOn(const Bbox2 &box) {return box;}
    Bool  DetectHit(PointIntersectCtx& ctx) {
        return _path->DetectHit(ctx, _style);
    }

#if _USE_PRINT
    // Print a representation to a stream.
    ostream& Print(ostream& os) { return os << "LineImage"; }
#endif

    virtual void DoKids(GCFuncObj proc) { 
        Image::DoKids(proc);
        (*proc)(_path);
        (*proc)(_style);
    }

    virtual int Savings(CacheParam& p) { 
#if _DEBUG
        if (IsTagEnabled(tagEnableLineBitmap))
            return _path->Savings(p); 
#endif 
        return 0;
    }

    void Traverse(TraversalContext &ctx) {
        ctx.SetContainsLine();
    }
    
  protected:
    Path2     *_path;
    LineStyle *_style;
};


void LineImage::
Render(GenericDevice& dev) 
{
    DirectDrawImageDevice &imgDev = SAFE_CAST(DirectDrawImageDevice &, dev);
    
    imgDev.RenderLine(_path, _style);
};


// The BoundingBox method returns the bounding box of the path, enlarged to
// accomodate the given line style.

const Bbox2 LineImage::BoundingBox (void)
{
    Bbox2 bbox = _path->BoundingBox ();
    Real Offset = 0.0;
   
    // The following calculation can make the bounding box a little
    // too big when a wide line only widens the bounding box in one
    // dimension (e.g. a horizontal wide line with flat end cap
    // doesn't increase the width of the bounding box).

    if(_style->Detail() ) {
        Offset = 1 / ViewerResolution();    // Detailed lines.. 
    }
    else {
        Offset = _style->Width()/ 2;        // NOT detailed lines..
    }
    
    bbox.Augment (bbox.max.x + Offset , bbox.min.y - Offset);
    bbox.Augment (bbox.min.x - Offset , bbox.max.y + Offset);
    
    return bbox;
}

#if BOUNDINGBOX_TIGHTER
const Bbox2 LineImage::BoundingBoxTighter (Bbox2Ctx &bbctx)
{
    Bbox2 bbox = _path->BoundingBoxTighter (bbctx);

    if( ! _style->Detail() ) {

        // The following calculation can make the bounding box a little
        // too big if xf in bbctx is shear or rotate.  It also makes the box
        // too big when a wide line only widens the bounding box in one
        // dimension (e.g. a horizontal wide line with flat end cap
        // doesn't increase the width of the bounding box).
        Real halfWidth = _style->Width() / 2;
        Vector2Value halfVec (halfWidth, halfWidth);
        bbox.min -= halfVec;
        bbox.max += halfVec;
    }

    return bbox;
}
#endif  // BOUNDINGBOX_TIGHTER

Image *LineImageConstructor(LineStyle *style, Path2 *path)
{
    if(style->GetVisible())
        return NEW LineImage(path, style);
    else
        return emptyImage;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\pickimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Define a pickable image that triggers an event when it's picked

*******************************************************************************/


#include "headers.h"
#include "privinc/imagei.h"
#include "privinc/probe.h"

class PickableImg : public AttributedImage {
  public:

    PickableImg(Image *img, int eventId, bool ignoresOcclusion,
                bool uType = false, GCIUnknown *u = NULL)
    : AttributedImage(img), _eventId(eventId), 
      _ignoresOcclusion(ignoresOcclusion), _hasData(uType), _long(u) {}

    virtual void DoKids(GCFuncObj proc) {
        AttributedImage::DoKids(proc);
        (*proc)(_long);
    }
    
#if _USE_PRINT
    // Print a representation to a stream.
    ostream& Print(ostream& os) {
        return os << "PickableImage" << _image;
    };
#endif

    Bool  DetectHit(PointIntersectCtx& ctx) {

        Bool result;
        
        // Stash off if we're inside an occlusion ignorer.
        bool oldState = ctx.GetInsideOcclusionIgnorer();
        if (_ignoresOcclusion) {
            ctx.SetInsideOcclusionIgnorer(true);
        }
        
        // If the underlying image is hit, and we're currently looking
        // for picks, add this image to the context since we'll want
        // to extend.  If hit, but not currently looking, just return
        // TRUE, else return FALSE.

        bool alreadyGotUnoccludedHit = ctx.HaveWeGottenAHitYet();
        if (_image->DetectHit(ctx)) {

            // Only register the event if this node is to ignore
            // occlusion, or it's the first thing hit.
            if (_ignoresOcclusion || !alreadyGotUnoccludedHit) {
                ctx.AddEventId(_eventId, _hasData, _long);
            }
            
            result = TRUE;
            
        } else {
            
            result = FALSE;
            
        }

        if (_ignoresOcclusion) {
            ctx.SetInsideOcclusionIgnorer(oldState);
        }

        return result;
        
    }

    bool ContainsOcclusionIgnorer() {
        return _ignoresOcclusion;
    }

  protected:
    int   _eventId;
    bool  _ignoresOcclusion;
    bool _hasData;
    GCIUnknown *_long;
};

Image *PRIVPickableImage(Image *image,
                         AxANumber *id,
                         AxABoolean *ignoresOcclusionValue)
{ 
    bool ignoresOcclusion = ignoresOcclusionValue->GetBool() ? true : false;
    
    return NEW PickableImg(image,
                           (int)NumberToReal(id),
                           ignoresOcclusion);
}

AxAValue PRIVPickableImageWithData(AxAValue img,
                                   int id,
                                   GCIUnknown *data,
                                   bool ignoresOcclusion)
{
    return NEW PickableImg(SAFE_CAST(Image*,img), id,
                           ignoresOcclusion, true, data);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\overimg.cpp ===
/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

-------------------------------------*/

#include "headers.h"

#include "privinc/overimg.h"
#include "privinc/dddevice.h"
#include "privinc/imgdev.h"
#include "privinc/cachdimg.h"
#include "privinc/cropdimg.h"
#include "privinc/opt.h"


// Put anything that extends to binary and n-ary aggregators
// here.
const DWORD aggregatingFlags =
                IMGFLAG_CONTAINS_EXTERNALLY_UPDATED_ELT |
                IMGFLAG_CONTAINS_OPACITY |
                IMGFLAG_CONTAINS_UNRENDERABLE_WITH_BOX |
                IMGFLAG_CONTAINS_GRADIENT;



bool
DoesUnionSaveArea(Image *img)
{
    // Here, we take the disjoint bbox areas and check against
    // them (no fair counting open space in overlays)
    DisjointCalcParam p;
    p._accumXform = identityTransform2;
    p._accumulatedClipBox = UniverseBbox2;
    
    Real disjointArea = img->DisjointBBoxAreas(p);

    Real unionArea = img->BoundingBox().Area();

    // As long as the area of the union is within some factor
    // (larger than 1) of the sum of the areas, then the union is
    // considered to save area over the individual ones.  The factor
    // is > 1, because there are some economies gained by doing a
    // large one once rather than a bunch of small ones.
    const Real fudgeFactor = 1.50;

    return (unionArea < fudgeFactor * disjointArea);
}

bool
ShouldOverlayBeCached(Image *img, CacheParam& p)
{
    // Determine if we want to cache an overlay itself.  We do if

    // a) the area of the union of the bbox is within some constant
    //    factor of the sum of the areas of the individuals.
    // b) the sum of the caching savings of the two is beyond our
    //    acceptance threshold.
    // c) the overlay doesn't claim that it shouldn't be cached.

    DynamicHeapPusher h(GetTmpHeap());

    bool cacheOverlay = false;
    if (img->Savings(p) >= savingsThreshold) {
        cacheOverlay = DoesUnionSaveArea(img);
    }

    ResetDynamicHeap(GetTmpHeap());

    return cacheOverlay;
}


bool
ShouldTraverseSeparately(Image *img, DirtyRectCtx& ctx)
{
    bool traverseSeparately;
    int oldId = img->GetOldestConstituentID();
    
    if ((oldId != PERF_CREATION_ID_BUILT_EACH_FRAME &&
         oldId < ctx._lastSampleId) ||
        (img->GetFlags() & IMGFLAG_CONTAINS_UNRENDERABLE_WITH_BOX)) {

        // This means that some of our elements are constant with
        // respect to the previous rendering or we have an
        // unrenderable image in the tree that has a bbox that we
        // don't want to include.  In these cases, traverse
        // separately.
        traverseSeparately = true;

    } else {

        traverseSeparately = false;
        // Everything is new.  Traverse separately only if there's a
        // pixel-area coverage savings in doing so.
        if (DoesUnionSaveArea(img)) {
            traverseSeparately = false;
        } else {
            traverseSeparately = true;
        }
        
    }

    return traverseSeparately;
}

OverlayedImage::OverlayedImage(Image *top, Image *bottom)
{
    _top = top;
    _bottom = bottom;
    _cached = false;
    _cachedDisjointArea = -1.0;
    
    _containsOcclusionIgnorer =
        _top->ContainsOcclusionIgnorer() ||
        _bottom->ContainsOcclusionIgnorer();

    _flags |= IMGFLAG_CONTAINS_OVERLAY;

    DWORD mask = _top->GetFlags() & aggregatingFlags;
    _flags |= mask;

    mask = _bottom->GetFlags() & aggregatingFlags;
    _flags |= mask;
    
    long tid = _top->GetOldestConstituentID();
    long bid = _bottom->GetOldestConstituentID();

    if (tid == PERF_CREATION_ID_BUILT_EACH_FRAME) {
        _oldestConstituentSampleId = bid;
    } else if (bid == PERF_CREATION_ID_BUILT_EACH_FRAME) {
        _oldestConstituentSampleId = tid;
    } else {
        _oldestConstituentSampleId = MIN(tid, bid);
    }
}

void OverlayedImage::Render(GenericDevice& dev)
{
    OverlayPairRender(_top, _bottom, dev);
}

// An overlaid image's bbox is the union of the two component
// bboxes.  TODO:  This could be computed lazily and stashed.
const Bbox2 OverlayedImage::_BoundingBox()
{
    return UnionBbox2Bbox2(_top->BoundingBox(),
                           _bottom->BoundingBox());
}

Real
OverlayedImage::DisjointBBoxAreas(DisjointCalcParam &param)
{
    if (_cachedDisjointArea < 0) {
        // For an overlay, sum the areas of the indiv. bboxes. 
        Real topArea = _top->DisjointBBoxAreas(param);
        Real botArea = _bottom->DisjointBBoxAreas(param);

        _cachedDisjointArea = topArea + botArea;
    }

    return _cachedDisjointArea;
}

void
OverlayedImage::_CollectDirtyRects(DirtyRectCtx &ctx)
{
    bool traverseSeparately = ShouldTraverseSeparately(this, ctx); 

    if (traverseSeparately) {
        // Collect from bottom up, since order of insertion matters
        // for determining whether images switched layers.
        CollectDirtyRects(_bottom, ctx);
        CollectDirtyRects(_top, ctx);
    } else {
        // Just add this whole overlay as a single dirty rect.
        Bbox2 xformedBbox =
            TransformBbox2(ctx._accumXform, BoundingBox());

        ctx.AddDirtyRect(xformedBbox);
    }
}

Bool OverlayedImage::DetectHit(PointIntersectCtx& ctx)
{
    Bool gotTopHit = FALSE;
    // Only look at the top one if we either haven't gotten a hit
    // yet, or the top guy contains an occlusion ignorer, or we
    // are inside of an occlusion ignorer.
    if (!ctx.HaveWeGottenAHitYet() ||
        _top->ContainsOcclusionIgnorer() ||
        ctx.GetInsideOcclusionIgnorer()) {
            
        gotTopHit = _top->DetectHit(ctx);
    }

    if (gotTopHit) {
        ctx.GotAHit();
    }

    Bool gotBottomHit = FALSE;
        
    // Don't bother to catch the potential exception on this
    // one... just let it propagate up the stack, which will then
    // be interpreted as the image not being hit.

    // We continue down into the overlay stack if a) we haven't
    // gotten a hit so far, or b) we did get a hit, but the
    // bottom image contains a pickable image willing to ignore
    // occlusion.  Also continue if we're inside of an occlusion
    // ignorer. 
    if (!ctx.HaveWeGottenAHitYet() ||
        _bottom->ContainsOcclusionIgnorer() ||
        ctx.GetInsideOcclusionIgnorer()) {

        gotBottomHit = _bottom->DetectHit(ctx);
        if (gotBottomHit) {
            ctx.GotAHit();
        }
            
    }

    // TODO: Possible optimization.  If we're inside of an
    // occlusion ignorer, but there are no more nodes below us
    // that themselves are occlusion ignorers, then we can
    // potentially stop.  But *only* if we've gotten a hit within
    // our current occlusion ignorer.  Way too complex to attempt
    // right now.

    return gotTopHit || gotBottomHit;

}

int
OverlayedImage::Savings(CacheParam& p)
{
    // Consider the savings for the overlay to be the sum of the
    // savings of the individual elements.
    return _top->Savings(p) + _bottom->Savings(p);
}

//
// Overlayed image handles opacity because opacity
// is implicitly a tertiary operation: (opacity, im1, im2).
// So, each image floats the opacity of its underlying image
// up, so at this level, we can get the accumulated opacity
// from each top level image and set that opacity on the
// device and ask it to render.
// It is GUARANTEED that the device will do an alpha blit
// as the last operation at this level in the image tree
// because we floated opacity to the top of the branch.
// So, it will alwyas be the case that if there is opacity
// involved we do an alpha blit from the scratch surface
// to the current compositing surface.
//
void OverlayedImage::OverlayPairRender(Image *top,
                                       Image *bottom,
                                       GenericDevice& _dev)
{
    DirectDrawImageDevice &dev = SAFE_CAST(DirectDrawImageDevice &, _dev);
    //ImageDisplayDev &dev = SAFE_CAST(ImageDisplayDev &, _dev);

    // save dealtWith state. xxDeal is TRUE if we need to deal.
    Bool xfsDeal = ! dev.GetDealtWithAttrib(ATTRIB_XFORM_SIMPLE);
    Bool xfcDeal = ! dev.GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX);
    Bool crDeal = ! dev.GetDealtWithAttrib(ATTRIB_CROP);
    Bool opDeal = ! dev.GetDealtWithAttrib(ATTRIB_OPAC);
    //printf("opDeal: %d\n",opDeal);

    //
    // Now, if there's opacity at the parent, we want to do it here
    // at ONE time.  So we CAN'T let bottom & top do their own thing.
    //
    Real topOpacity = dev.GetOpacity();
    DirectDrawViewport &vp = (dev._viewport);
    if(opDeal) {
        dev.SetDealtWithAttrib(ATTRIB_OPAC, TRUE);  // liar
        dev.SetOpacity(1.0);
        dev.GetCompositingStack()->PushCompositingSurface(doClear, scratch);
    }
    
    //
    //  B O T T O M 
    //

    // ----------------------------------------
    // Deal with opacity: Bottom
    // ----------------------------------------
    DoOpacity(bottom, dev);

    
    // ----------------------------------------
    // GET INTERESTING RECT: BOTTOM
    // ----------------------------------------
    //
    // Now, the bottom node has left the interesting rectangle on the
    // destination surface.  Find the dest surface and get the
    // interesting rect.  Reset the rect on the surface
    //
    RECT bottomRect;
    DDSurface *targetDDSurf = NULL;
    Bool droppedInTarg = TRUE;
    if(dev.AllAttributorsTrue()) {
        // it left everything in the target surface, so get the
        // interesting rect from that surf
        targetDDSurf = dev.GetCompositingStack()->TargetDDSurface();

    } else {
        // everything's in the scratch surf.  do same
        targetDDSurf = dev.GetCompositingStack()->ScratchDDSurface();
        droppedInTarg = FALSE;  // for assertions
        
    }
    CopyRect(&bottomRect, targetDDSurf->GetInterestingSurfRect());

    
    // Ok: bottom did all it can, what has it left undone ?
    // xxRemains is true if an attributor is undealt with
    Bool xfsDealt =  dev.GetDealtWithAttrib(ATTRIB_XFORM_SIMPLE);
    Bool xfcDealt =  dev.GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX);
    Bool crDealt =  dev.GetDealtWithAttrib(ATTRIB_CROP);
    Bool opDealt =  dev.GetDealtWithAttrib(ATTRIB_OPAC);

    Image *modTop = top;

    if( (xfsDeal && xfsDealt) || (xfcDeal && xfcDealt) ) {
        //
        // top must deal with this now, since we're not sure if
        // there's an XF node in this tree, we can do one of two
        // things:
        // 1.> look for a top xf node to deal with the xfs
        // 2.> add a bogus node to artificially incite a xf
        //
        
        //
        // Add bogus xf node
        //
        modTop = NEW Transform2Image(identityTransform2, modTop);
    }
    if( crDeal && crDealt ) {
        modTop = NEW CroppedImage(UniverseBbox2, modTop);
    }
    if( opDeal && opDealt ) {
        //
        // not sure what this means yet.
        //
    }
        
        
    //
    // Reset "dealtWith" state
    //
    dev.SetDealtWithAttrib(ATTRIB_XFORM_SIMPLE, !xfsDeal);
    dev.SetDealtWithAttrib(ATTRIB_XFORM_COMPLEX, !xfcDeal);
    dev.SetDealtWithAttrib(ATTRIB_OPAC,  TRUE);
    dev.SetDealtWithAttrib(ATTRIB_CROP,  !crDeal);

    //
    //  T O P 
    //
    DoOpacity(modTop, dev);


    // ----------------------------------------
    // GET INTERESTING RECT: TOP
    // ----------------------------------------
    Assert((dev.AllAttributorsTrue() ? droppedInTarg : !droppedInTarg)
           &&  "Strange... one leaf dropped bits" &&
               "in target surf, but other leaf didn't.  BAAD!!");
    
    //
    // top left everything in the target surface, so get the
    // interesting rect from that surf
    //
    RECT topRect;
    CopyRect(&topRect, targetDDSurf->GetInterestingSurfRect());
    
    // UNION RECTS
    RECT unionedRects;
    UnionRect(&unionedRects, &topRect, &bottomRect);

    //
    // Set current interesting rect on targetsurface
    //
    targetDDSurf->SetInterestingSurfRect(&unionedRects);

    //
    // If the parent nodes have an opacity then we hid it from
    // the children, and now we'll reset the state for OPAC
    // so that our parent smartRender with do opacity for us.
    // Notice that we pulled out the targetSurface, and replaced
    // it with a compositing surface.  Now we'll move it to the
    // scratch surface and our parent will expect everything to be
    // there.
    //
    //
    // XXX: this won't work for: opac(0.5, over(opac(0.1, A), opac(0.8, B)))
    // But it will work for:
    // 1.>  opac(0.5, over(A,B))   where A & B have no opacity in them
    // 2.>  over( opac(0.4, A), opac(0.2, B) )   and there's no parent opacity
    //
    if(opDeal) {
        //printf("OverImage: set opac: FALSE\n");
        dev.SetOpacity(topOpacity);
        DirectDrawViewport &vp = dev._viewport;
        DDSurfPtr<DDSurface> dds; // my ref
        dds = dev.GetCompositingStack()->TargetDDSurface();
        dev.GetCompositingStack()->PopTargetSurface();
        if(dev.AllAttributorsTrue()) {
            //
            // Make the target the current scratch surface
            // assuming that the children left all their bits in the
            // target surface.
            //
            dev.GetCompositingStack()->ReplaceAndReturnScratchSurface(dds);
        } else {
            // ah, whoops, didn't need to replace
            // target surface.... bad. optimize.
            dev.GetCompositingStack()->PushTargetSurface(dds);
        }
        dev.SetDealtWithAttrib(ATTRIB_OPAC, FALSE);
    }

    // INVARIENT:  All the attribs that _bottom dealt with are also
    // INVARIENT:  dealt with by _top
    //Assert( xfsDealt && dev.GetDealtWithAttrib(ATTRIB_XFORM_SIMPLE) && "bottom dealt with XFORM but top didn't");
    //Assert( xfcDealt && dev.GetDealtWithAttrib(ATTRIB_XFORM_COMPLEX) && "bottom dealt with XFORM but top didn't");
    //Assert( crDealt && dev.GetDealtWithAttrib(ATTRIB_CROP) && "bottom dealt with CROP but top didn't");

    //Assert( opDealt && dev.GetDealtWithAttrib(ATTRIB_OPAC) && "bottom dealt with OPAC but top didn't");
    
}

void OverlayedImage::
DoOpacity(Image *image, ImageDisplayDev &dev)
{
    Real origOpac = dev.GetOpacity();

    dev.SetOpacity(origOpac * image->GetOpacity());
    dev.SmartRender(image, ATTRIB_OPAC);
    dev.SetOpacity(origOpac);
}

Image *Overlay(Image *top, Image *bottom)
{
    if (top == emptyImage) {
        return bottom;
    } else if (bottom == emptyImage) {
        return top;
    } else {
        return NEW OverlayedImage(top, bottom);
    }
}


AxAValue
OverlayedImage::_Cache(CacheParam &p)
{
    Image *result = this;
    
    if (ShouldOverlayBeCached(this, p)) {
        result = CacheHelper(this, p);
    }

    if (result == this) {

        // Just cache the individual pieces
        CacheParam newParam = p;
        newParam._pCacheToReuse = NULL;
        _top = SAFE_CAST(Image *, AxAValueObj::Cache(_top, newParam));
        _bottom = SAFE_CAST(Image *, AxAValueObj::Cache(_bottom, newParam));
    }

    return result;
}

void
OverlayedImage::DoKids(GCFuncObj proc)
{
    Image::DoKids(proc);
    (*proc)(_top);
    (*proc)(_bottom);
}

//////////////////////  Overlayed Array of Images  ////////////////////

class OverlayedArrayImage : public Image {
  public:

    // Interpret the array so that the first element is on the top.
    OverlayedArrayImage(AxAArray *sourceImgs)
    : _heapCreatedOn(GetHeapOnTopOfStack())
    {
        _cached = false;
        _cachedDisjointArea = -1.0;
        
        // Incoming images are ordered so that the zero'th element is
        // on the top.
        _numImages = sourceImgs->Length();

        _images =
            (Image **)AllocateFromStore(_numImages * sizeof(Image *));
        
        _overlayTree = NULL;
        
        _containsOcclusionIgnorer = false;
        _oldestConstituentSampleId = -1;

        int n = 0;

        for (int i = 0; i < _numImages; i++) {
            Image *img = (Image *)(*sourceImgs)[i];

            if (img==emptyImage)
                continue;

            _images[n] = img;

            // If any of these contain an occlusion ignorer, then the
            // whole array does.
            if (!_containsOcclusionIgnorer) {
                _containsOcclusionIgnorer =
                    img->ContainsOcclusionIgnorer();
            }

            long oid = img->GetOldestConstituentID();
            if (oid != PERF_CREATION_ID_BUILT_EACH_FRAME &&
                (i == 0 || oid < _oldestConstituentSampleId)) {

                // Check for i == 0 to be sure we set this the first
                // time we get a non-built-each-frame image.
                _oldestConstituentSampleId = oid;
            }

            DWORD mask = img->GetFlags() & aggregatingFlags;
            _flags |= mask;

            n++;
        }

        _numImages = n;

        if (_oldestConstituentSampleId == -1) {
            // Only way to get here is if all of the constituent
            // images where built each frame, in which case we want to
            // say that this was built each frame.
            _oldestConstituentSampleId = PERF_CREATION_ID_BUILT_EACH_FRAME;
        }
        
        _flags |= IMGFLAG_CONTAINS_OVERLAY;

        // Here we generate the overlay tree.  Note that for N images,
        // this tree will have [2n - 1] nodes and will be at most
        // [log(n)] deep.  Not so bad.
        if( _numImages <= 0 ) {
            _overlayTree = emptyImage;
        } else {
            _overlayTree = _GenerateOverlayTreeFromArray(_images, _numImages);
        }
    }

    ~OverlayedArrayImage() {
        StoreDeallocate(_heapCreatedOn, _images);
    }

    void Render(GenericDevice& dev) {

        // We used to render by taking pairs of images, from the bottom,
        // and rendering them using the pairwise overlay render
        // implemented for the binary overlay.
        // However, we now generate a balanced binary overlay tree
        // since there are problems with opacity and this approach to
        // rendering the overlayedArray and we'd like this to work
        // exactly like a tree of overlays.

        _overlayTree->Render(dev);
    }

    const Bbox2 BoundingBox(void) {
        return CacheImageBbox2(this, _cached, _cachedBbox);
    }

    // An overlaid image's bbox is the union of the component
    // bboxes.  TODO:  This could be computed lazily and stashed.
    const Bbox2 _BoundingBox() {
        Bbox2 totalBbox;
        for (int i = 0; i < _numImages; i++) {
            // Grow the total bbox by augmenting with each corner of
            // the constituent ones.
            Bbox2 bb = _images[i]->BoundingBox();

            // If contents are not that of an empty bbox.
            if (!(bb == NullBbox2)) {
                totalBbox.Augment(bb.min);
                totalBbox.Augment(bb.max);
            }
        }

        return totalBbox;
    }

    Real DisjointBBoxAreas(DisjointCalcParam &param) {

        if (_cachedDisjointArea < 0) {
            Real area = 0;
            for (int i = 0; i < _numImages; i++) {
                area += _images[i]->DisjointBBoxAreas(param);
            }

            _cachedDisjointArea = area;
        }

        return _cachedDisjointArea;
    }

    void _CollectDirtyRects(DirtyRectCtx &ctx) {
        
        bool traverseSeparately = ShouldTraverseSeparately(this, ctx); 

        if (traverseSeparately) {
            
            // Collect from bottom up, since order of insertion
            // matters for determining whether images switched
            // layers. 
            for (int i = _numImages - 1; i >= 0; i--) {
                CollectDirtyRects(_images[i], ctx);
            }
            
        } else {
            
            // Just add this whole overlay as a single dirty rect.
            Bbox2 xformedBbox =
                TransformBbox2(ctx._accumXform, BoundingBox());

            ctx.AddDirtyRect(xformedBbox);
        }
    }

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        Bbox2 totalBbox;
        for (int i = 0; i < _numImages; i++) {

            // Grow the total bbox by augmenting with each corner of
            // the constituent ones.
            Bbox2 bb = _images[i]->BoundingBoxTighter(bbctx);
            if (bb != NullBbox2) {

                // Should never get here, since this bb should never
                // have been built and the only null bbox should be
                // nullBbox2.
                Assert(!(bb == NullBbox2));
                
                totalBbox.Augment(bb.min);
                totalBbox.Augment(bb.max);
            }
        }

        return totalBbox;
    }
#endif  // BOUNDINGBOX_TIGHTER

    const Bbox2 OperateOn(const Bbox2 &box) {
        return IntersectBbox2Bbox2(box, BoundingBox());
    }

    Bool  DetectHit(PointIntersectCtx& ctx) {
        return DetectHitOnOverlaidArray(ctx,
                                        _numImages,
                                        _images,
                                        _containsOcclusionIgnorer);
    }

#if _USE_PRINT
    ostream& Print (ostream &os) {
        os << "Overlay(" << _numImages;
        int ems = 0;
        for (int i = 0; i<_numImages; i++) {
            if (_images[i]==emptyImage)
                ems++;
        }

        double ePercent = (double) ems / (double) _numImages;

        if (ePercent>0.9) {
            for (i = 0; i<_numImages; i++) {
                if (_images[i]!=emptyImage)
                    os << ",[" << i << "," << _images[i] << "]";
            }
        } else {
            for (i = 0; i<_numImages; i++) {
                os << "," << _images[i];
            }
        }
        return os << ")";
    }
#endif

    int Savings(CacheParam& p) {
        int savings = 0;
        for (int i = 0; i < _numImages; i++) {
            savings += _images[i]->Savings(p);
        }

        return savings;
    }

    // should also check the extent of the overlap here.  If there is
    // significant overlap, we should cache just one discrete image. 
    AxAValue _Cache(CacheParam &p) {

        Image *result = this;

        if (ShouldOverlayBeCached(this, p)) {
            result = CacheHelper(this, p);
        }

        if (result == this) {

            CacheParam newParam = p;
            newParam._pCacheToReuse = NULL;
            for (int i = 0; i < _numImages; i++) {
                _images[i] =
                    SAFE_CAST(Image *,
                              AxAValueObj::Cache(_images[i], newParam));
            }
        }

        return result;
    }

    virtual VALTYPEID GetValTypeId() { return OVERLAYEDARRAYIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == OverlayedArrayImage::GetValTypeId() ||
                Image::CheckImageTypeId(type));
    }

    virtual void DoKids(GCFuncObj proc) {
        Image::DoKids(proc);
        for (int i = 0; i < _numImages; i++) {
            (*proc)(_images[i]);
        }
        (*proc)(_overlayTree);
    }

    virtual bool ContainsOcclusionIgnorer() {
        return _containsOcclusionIgnorer;
    }

    virtual void Traverse(TraversalContext &ctx) {
        for (int i = 0; i < _numImages; i++) {
            _images[i]->Traverse(ctx);
        }
    }
    
    

  protected:
    // Image 0 is on the top, image n-1 is on the bottom.
    int          _numImages;
    Image      **_images;
    DynamicHeap& _heapCreatedOn;
    bool         _cached;
    Bbox2        _cachedBbox;
    Real         _cachedDisjointArea;
    bool         _containsOcclusionIgnorer;
    Image       *_overlayTree;

    Image *_GenerateOverlayTreeFromArray(Image *imgs[], int numImages);
    Image *_TreeFromArray(Image *imgs[], int i, int j);
};


Image *OverlayedArrayImage::
_GenerateOverlayTreeFromArray(Image *imgs[], int numImages)
{
    Assert(numImages > 0);
    Image *ret = _TreeFromArray(imgs, 0, numImages-1);
    return ret;
}

Image *OverlayedArrayImage::
_TreeFromArray(Image *imgs[], int i, int j)
{
    Assert(i<=j);

    //
    // one node
    //
    if( i==j ) return imgs[i];

    //
    // two nodes
    //
    if( (j-i)==1 )
        return NEW OverlayedImage(imgs[i], imgs[j]);

    //
    // three+ nodes
    //
    
    int n = (j-i)+1;  // tot # nodes
    Assert(n>=3);
    int n2 = n/2;     // 1/2 of # of nodes
    n2 += n2 % 2;     // add 1 if needed to make it even
    Assert(n2<=j);
    
    int endi = i + (n2-1);
    int begj = endi + 1;

    // Assert that the first half is even
    Assert( ((endi - i + 1) % 2) == 0 );

    // redundant asserts (see assert above) but can make debugging easier
    Assert(i <= endi);
    Assert(endi < begj);
    Assert(begj <= j);
    
    return NEW OverlayedImage(
        _TreeFromArray(imgs, i, endi),
        _TreeFromArray(imgs, begj, j));
}

Image *OverlayArray(AxAArray *imgs)
{
    imgs = PackArray(imgs);
    
    int numImgs = imgs->Length();

    switch (numImgs) {
      case 0:
        return emptyImage;

      case 1:
        return (Image *)((*imgs)[0]);

      case 2:
        return Overlay(((Image *)((*imgs)[0])),
                       ((Image *)((*imgs)[1])));

      default:
        return NEW OverlayedArrayImage(imgs);
    }

}



// Also used by DXTransforms...

Bool DetectHitOnOverlaidArray(PointIntersectCtx& ctx,
                              LONG               numImages,
                              Image            **images,
                              bool               containsOcclusionIgnorer)
{

    Bool gotHit = ctx.HaveWeGottenAHitYet();
    bool continueLooking = true;

    // Start from the top;
    for (int i = 0; i < numImages && continueLooking; i++) {

        // If we've already gotten a hit, only pay attention to
        // the next guy if it contains an occlusion ignorer.
        // Otherwise, continue on, since ones below it may still
        // contain an occlusion ignorer.  Also, continue on if
        // we're inside of an occlusion ignorer.

        if (!gotHit ||
            images[i]->ContainsOcclusionIgnorer() ||
            ctx.GetInsideOcclusionIgnorer()) {

            Bool hitThisOne = images[i]->DetectHit(ctx);

            if (hitThisOne) {
                ctx.GotAHit();
                gotHit = true;
            }
        }

        // Keep looking if we haven't gotten a hit, or if there is
        // an occlusion ignorer in these images.  (Possible
        // optimization: figure out if there's an occlusion
        // ignorer _only_ in the images after the one we're on.
        // Would take more bookkeeping.)  Also continue on if
        // we're inside of an occlusion ignorer.
        continueLooking =
            !gotHit ||
            containsOcclusionIgnorer ||
            ctx.GetInsideOcclusionIgnorer();
    }

    return gotHit;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\solidimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implements SolidImage, which is an infinite single
    colored image.  Mostly implemented in the header.

*******************************************************************************/


#include "headers.h"
#include <privinc/imagei.h>
#include <privinc/solidImg.h>


// Ok ok, SolidImage class is pretty small
// and light weight... so it's almost all implemented
// in the header.. anyoing huh ?

void
SolidColorImageClass::DoKids(GCFuncObj proc)
{
    Image::DoKids(proc);
    (*proc)(_color);
}


Image *SolidColorImage(Color *color)
{
    return NEW SolidColorImageClass(color);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\quality.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Simple image attribution that doesn't get elevated automatically

*******************************************************************************/

#include <headers.h>
#include "backend/bvr.h"
#include "privinc/server.h"
#include "privinc/basic.h"
#include "privinc/imagei.h"
#include "privinc/imgdev.h"

static const DWORD textTrait  = CRQUAL_AA_TEXT_ON | CRQUAL_AA_TEXT_OFF;
static const DWORD lineTrait  = CRQUAL_AA_LINES_ON | CRQUAL_AA_LINES_OFF;
static const DWORD solidTrait = CRQUAL_AA_SOLIDS_ON | CRQUAL_AA_SOLIDS_OFF;
static const DWORD clipTrait  = CRQUAL_AA_CLIP_ON | CRQUAL_AA_CLIP_OFF;
static const DWORD htmlTrait  = CRQUAL_MSHTML_COLORS_ON | CRQUAL_MSHTML_COLORS_OFF;
static const DWORD xformTrait = CRQUAL_QUALITY_TRANSFORMS_ON | CRQUAL_QUALITY_TRANSFORMS_OFF;
static CONST DWORD allTraits  = (textTrait |
                                 lineTrait |
                                 solidTrait |
                                 clipTrait |
                                 htmlTrait |
                                 xformTrait);

class ImageQualityImage : public AttributedImage {
  public:
    ImageQualityImage(Image *underlyingImg,
                      long renderWidth,
                      long renderHeight,
                      DWORD qualityFlags) :
        AttributedImage(underlyingImg)
    {
        _renderWidth = renderWidth;
        _renderHeight = renderHeight;
        _qualityFlags = qualityFlags;
    }

    void Validate() {

        bool ok = true;

        // Be sure dimensions are reasonable.
        if (_renderWidth <= 0 ||
            _renderHeight <= 0 ||
            _renderWidth > 65536 ||
            _renderHeight > 65536) {

            ok = false;

            // We allow this exception, to indicate that this isn't
            // setting the render dimensions.
            if (_renderWidth == -1 && _renderHeight == -1) {
                ok = true;
            }
            
        } else {

            // Valid rendering dimensions.
            _flags |= IMGFLAG_CONTAINS_DESIRED_RENDERING_RESOLUTION;
            _desiredRenderingWidth = _renderWidth;
            _desiredRenderingHeight = _renderHeight;
            
        }

        // And quality flags aren't self conflicting.
        if (((_qualityFlags & CRQUAL_AA_TEXT_ON) &&
             (_qualityFlags & CRQUAL_AA_TEXT_OFF)) ||
            ((_qualityFlags & CRQUAL_AA_LINES_ON) &&
             (_qualityFlags & CRQUAL_AA_LINES_OFF)) ||
            ((_qualityFlags & CRQUAL_AA_SOLIDS_ON) &&
             (_qualityFlags & CRQUAL_AA_SOLIDS_OFF)) ||
            ((_qualityFlags & CRQUAL_AA_CLIP_ON) &&
             (_qualityFlags & CRQUAL_AA_CLIP_OFF)) ||
            ((_qualityFlags & CRQUAL_MSHTML_COLORS_ON) &&
             (_qualityFlags & CRQUAL_MSHTML_COLORS_OFF)) ||
            ((_qualityFlags & CRQUAL_QUALITY_TRANSFORMS_ON) &&
             (_qualityFlags & CRQUAL_QUALITY_TRANSFORMS_OFF)) ||
            ((_qualityFlags & ~allTraits) != 0)) {
            ok = false;
        }
        
        if (!ok) {
            RaiseException_UserError(E_INVALIDARG, IDS_ERR_INVALIDARG);
        }
    }

    void Render(GenericDevice& gdev) {
        ImageDisplayDev &dev = SAFE_CAST(ImageDisplayDev &, gdev);

        bool setResolution = false;
        
        // Establish render resolution
        if (_renderWidth != -1) {
            Assert(_renderHeight != -1);

            long currHeight, currWidth;
            dev.GetRenderResolution(&currWidth, &currHeight);

            // Only set if we haven't already set up on this image, since
            // this is outer-overriding.
            if (currWidth == -1) {
                dev.SetRenderResolution(_renderWidth, _renderHeight);
                setResolution = true;
            }
        }

        DWORD stashedFlags = dev.GetImageQualityFlags();
        DWORD newFlags = stashedFlags;

        // If current accumulated flags have nothing to say about a
        // trait (lines aa on or off for example) then accumulate my
        // trait.

        _DoTrait(newFlags, textTrait);
        _DoTrait(newFlags, lineTrait);
        _DoTrait(newFlags, solidTrait);
        _DoTrait(newFlags, clipTrait);
        _DoTrait(newFlags, htmlTrait);
        _DoTrait(newFlags, xformTrait);

        dev.SetImageQualityFlags(newFlags);

        _image->Render(gdev);

        if (setResolution) {
            // Set back to default value
            dev.SetRenderResolution(-1, -1);
        }

        // Restore the old (outer) flags
        dev.SetImageQualityFlags(stashedFlags);
    }


#if _USE_PRINT
    // Print a representation to a stream.
    ostream& Print(ostream& os) {
        return os << "ImageQualityClass" << _renderWidth
                  << _renderHeight << _qualityFlags
                  << _image;
    }
#endif
    
  protected:

    void _DoTrait(DWORD &newFlags, const DWORD &trait)  {
        if (! (newFlags & trait) ) {
            newFlags |= (_qualityFlags & trait);
        }
    }
        
    
    long  _renderWidth;
    long  _renderHeight;
    DWORD _qualityFlags;
};

Image *
MakeImageQualityImage(Image *img,
                      long width,
                      long height,
                      DWORD dwQualFlags)
{
    ImageQualityImage *im =
        NEW ImageQualityImage(img, width, height, dwQualFlags);

    im->Validate();

    return im;
}
                  
static Image *
RenderResolutionStatic(Image *img, AxALong *width, AxALong *height)
{
    return MakeImageQualityImage(img,
                                 width->GetLong(),
                                 height->GetLong(),
                                 0); 
}

Bvr
RenderResolution(Bvr imgBvr, long width, long height)
{
    Bvr wBvr = UnsharedConstBvr(LongToAxALong(width));
    Bvr hBvr = UnsharedConstBvr(LongToAxALong(height));

    // TODO: share valprimop at module initialize
    return PrimApplyBvr(ValPrimOp(::RenderResolutionStatic,
                                  3,
                                  "RenderResolution",
                                  ImageType),
                        3, imgBvr, wBvr, hBvr);
}

static Image *
ImageQualityStatic(Image *img, AxALong *flags)
{
    return MakeImageQualityImage(img, -1, -1,
                                 (DWORD)(flags->GetLong()));
}

Bvr
ImageQuality(Bvr imgBvr, DWORD dwQualityFlags)
{
    Bvr flagsBvr = UnsharedConstBvr(LongToAxALong(dwQualityFlags));

    // TODO: share valprimop at module initialize
    return PrimApplyBvr(ValPrimOp(::ImageQualityStatic,
                                  2,
                                  "ImageQuality",
                                  ImageType),
                        2, imgBvr, flagsBvr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\transimg.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implements the Transform2Image class, a subclass of
    Image.

--*/

#include "headers.h"
#include "privinc/imagei.h"
#include "privinc/probe.h"
#include "privinc/imgdev.h"
#include "privinc/except.h"
#include "privinc/overimg.h"
#include "privinc/transimg.h"
#include "privinc/xform2i.h"
#include "privinc/opt.h"

Transform2Image::Transform2Image(Transform2 *xf, Image *img)
    : _xform(xf), AttributedImage(img)
{
}

// Extract a bounding box from this image, outside of which
// everything is transparent.
// note: this creates axis aligned bbox
const Bbox2
Transform2Image::BoundingBox() {
    return TransformBbox2(_xform, _image->BoundingBox());
}

Real
Transform2Image::DisjointBBoxAreas(DisjointCalcParam &param)
{
    Transform2 *newXf =
        TimesTransform2Transform2(param._accumXform, _xform);

    DisjointCalcParam newP;
    newP._accumXform = newXf;
    newP._accumulatedClipBox = TransformBbox2(_xform,
                                              param._accumulatedClipBox);
    
    return _image->DisjointBBoxAreas(newP);
}

void
Transform2Image::_CollectDirtyRects(DirtyRectCtx &ctx)
{
    Transform2 *stashedXf = ctx._accumXform;
    ctx._accumXform = TimesTransform2Transform2(stashedXf, _xform);

    // Now just call the _CollectDirtyRects on our superclass,
    // AttributedImage.  Do this because that method deals with the
    // ctx _processEverything flag correctly, and then invokes
    // CollectDirtyRects on the subimage.
    AttributedImage::_CollectDirtyRects(ctx);
    
    ctx._accumXform = stashedXf;
}

const Bbox2
Transform2Image::OperateOn(const Bbox2 &box) {
    return TransformBbox2(_xform, box);
}

Bool
Transform2Image::DetectHit(PointIntersectCtx& ctx) {
    Transform2 *stashedXf = ctx.GetTransform();
    ctx.SetTransform( TimesTransform2Transform2(stashedXf, _xform) );

    Transform2 *imgOnlyXf = ctx.GetImageOnlyTransform();
    ctx.SetImageOnlyTransform( TimesTransform2Transform2(imgOnlyXf, _xform) );

    Bool result = _image->DetectHit(ctx);

    ctx.SetImageOnlyTransform( imgOnlyXf );
    ctx.SetTransform(stashedXf);

    return result;
}

void
Transform2Image::Render(GenericDevice& _dev)
{
    ImageDisplayDev &dev = SAFE_CAST(ImageDisplayDev &, _dev);

    //
    // Push state in device
    //
    Transform2 *oldXf = dev.GetTransform();
    Transform2 *newXf = TimesTransform2Transform2(oldXf, _xform);
    dev.SetTransform(newXf); 
    
    // tell device about me
    dev.PushTransform2Image(this);

    int attrib;

    if( (_xform->Type() == Transform2::Shear) ||
        (_xform->Type() == Transform2::Rotation)) {

        attrib = ATTRIB_XFORM_COMPLEX; 

    } else if((_xform->Type() == Transform2::Identity) ||
              (_xform->Type() == Transform2::Translation) ||
              (_xform->Type() == Transform2::Scale)) {

        attrib = ATTRIB_XFORM_SIMPLE;

    } else {
        // XXX: could be more efficient.. ie: create a method on xforms.  
        // XXX: also this is the common case
        Real m[6];
        _xform->GetMatrix(m);
        if( m[1] != 0  ||  m[3] !=0 ) {
            attrib = ATTRIB_XFORM_COMPLEX; 
        } else {
            attrib = ATTRIB_XFORM_SIMPLE;
        }
            
    }

    dev.SmartRender(_image, attrib);

    dev.PopTransform2Image();
    
    dev.SetTransform(oldXf); // reset state.
}

// TODO: could cache the transform being computed, but that's likely
// to only be worthwhile if we have fairly deep trees of transforms.
DiscreteImage *
Transform2Image::IsPurelyTransformedDiscrete(Transform2 **theXform)
{
    Transform2 *underXf;
    DiscreteImage *pureDiscrete = _image->IsPurelyTransformedDiscrete(&underXf);

    if (pureDiscrete) {
        
        *theXform = TimesTransform2Transform2(_xform, underXf);
        return pureDiscrete;
        
    } else {
        
        return NULL;
        
    }
}

Image *TransformImage(Transform2 *xf, Image *image)
{
    // Just be sure xf isn't singular, and that img isn't empty. 
    if (AxABooleanToBOOL(IsSingularTransform2(xf)) || image == emptyImage) {
        return emptyImage;
    }

    // Transformations of a solid color image are just the solid color
    // image. 
    if (image->CheckImageTypeId(SOLIDCOLORIMAGE_VTYPEID)) {
        return image;
    }

    if (xf == identityTransform2) {
        return image;
    }

    return NEW Transform2Image(xf, image);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\plugimg.cpp ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    This is a discrete image that gets its bits filled in on the first
    rendering by reading from a pluggable image decoder.  Assume that
    there is no color-key transparency here. 

*******************************************************************************/

#include "headers.h"

#include <ddraw.h>
#include <ddrawex.h>
#include <htmlfilter.h>
#include <imgutil.h>

#include "privinc/imagei.h"
#include "privinc/discimg.h"
#include "privinc/vec2i.h"
#include "privinc/ddutil.h"
#include "privinc/debug.h"
#include "privinc/ddutil.h"
#include "privinc/ddsurf.h"
#include "privinc/dddevice.h"
#include "privinc/viewport.h"
#include "privinc/resource.h"
#include "include/appelles/hacks.h" // for viewer resolution

#define CHECK_HR(stmnt) \
  hr = stmnt;               \
  if (FAILED(hr)) {         \
      goto Error;           \
  }

// Returns whether or not the described surface will need a palette. 
bool
FillInSurfaceDesc(const GUID& bfid,
                  DDSURFACEDESC& ddsd)
{
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                          DDSCAPS_SYSTEMMEMORY;

    ddsd.ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd.ddpfPixelFormat.dwFlags = DDPF_RGB;

    bool needsPalette = false;
    
    if (IsEqualGUID(bfid, BFID_INDEXED_RGB_8)) {
        // Need to OWNDC for ddrawex.dll, otherwise getting dc on 8bit
        // surf won't work (and it will never work on non-ddrawex
        // ddraws). 
        ddsd.ddsCaps.dwCaps |= DDSCAPS_OWNDC;
        ddsd.ddpfPixelFormat.dwFlags |= DDPF_PALETTEINDEXED8;
        ddsd.ddpfPixelFormat.dwRGBBitCount = 8;
        ddsd.ddpfPixelFormat.dwRBitMask = 0;
        ddsd.ddpfPixelFormat.dwGBitMask = 0;
        ddsd.ddpfPixelFormat.dwBBitMask = 0;
        needsPalette = true;
    } else if (IsEqualGUID(bfid, BFID_RGB_555)) {
        ddsd.ddpfPixelFormat.dwRGBBitCount = 16;
        // Assume high-order 5 bits are red, mid-order 5 green,
        // low-order 5 blue.
        ddsd.ddpfPixelFormat.dwRBitMask = 0x00007C00L;
        ddsd.ddpfPixelFormat.dwGBitMask = 0x000003E0L;
        ddsd.ddpfPixelFormat.dwBBitMask = 0x0000001FL;
    } else if (IsEqualGUID(bfid, BFID_RGB_565)) {
        ddsd.ddpfPixelFormat.dwRGBBitCount = 16;
        // Assume high-order 5 bits are red, mid-order 6 green,
        // low-order 5 blue.
        ddsd.ddpfPixelFormat.dwRBitMask = 0x0000F800L;
        ddsd.ddpfPixelFormat.dwGBitMask = 0x000007E0L;
        ddsd.ddpfPixelFormat.dwBBitMask = 0x0000001FL;
    } else if (IsEqualGUID(bfid, BFID_RGB_24)) {
        ddsd.ddpfPixelFormat.dwRGBBitCount = 24;
        ddsd.ddpfPixelFormat.dwRBitMask = 0x00FF0000L;
        ddsd.ddpfPixelFormat.dwGBitMask = 0x0000FF00L;
        ddsd.ddpfPixelFormat.dwBBitMask = 0x000000FFL;
    } else if (IsEqualGUID(bfid, BFID_RGB_32)) {
        ddsd.ddpfPixelFormat.dwRGBBitCount = 32;
        ddsd.ddpfPixelFormat.dwRBitMask = 0x00FF0000L;
        ddsd.ddpfPixelFormat.dwGBitMask = 0x0000FF00L;
        ddsd.ddpfPixelFormat.dwBBitMask = 0x000000FFL;
    } else {
        // TODO: Add support for more BFIDs
        RaiseException_InternalError("Incoming bit depth not supported");
    }

    return needsPalette;
}

class CImageDecodeEventSink : public IImageDecodeEventSink {
  public:
    CImageDecodeEventSink(bool actuallyDecode,
                          DirectDrawViewport *viewport,
                          DDSurface *finalSurface)
        : _nRefCount (0)
    {
        _actuallyDecode = actuallyDecode;
        _infoGatheringSucceeded = false;

        if (!actuallyDecode) {
            _width = -1;
            _height = -1;
        } else {
            _finalSurfToBeBlitTo = finalSurface;
            _viewport = viewport;
        }
    }
    
    
    ~CImageDecodeEventSink() {}

    ULONG STDMETHODCALLTYPE AddRef() {
        _nRefCount++;
        return (_nRefCount);
    }

    ULONG STDMETHODCALLTYPE Release() {
        _nRefCount--;
        
        if (_nRefCount == 0) {
            TraceTag((tagImageDecode,
                      "Deleting CImageDecodeEventSink"));
            delete this;
            return (0);
        }

        return (_nRefCount);
    }
    
    STDMETHOD(QueryInterface)(REFIID iid, void** ppInterface) {
        
        if (ppInterface == NULL) {
            return (E_POINTER);
        }

        *ppInterface = NULL;

        if (IsEqualGUID(iid, IID_IUnknown)) {
              *ppInterface = (IUnknown*)(IImageDecodeEventSink *)this;
        } else if (IsEqualGUID(iid, IID_IImageDecodeEventSink)) {
            *ppInterface = (IImageDecodeEventSink*)this;
        } else {
            return (E_NOINTERFACE);
        }

        //  If we're going to return an interface, AddRef it first
        if (*ppInterface) {
              ((LPUNKNOWN)*ppInterface)->AddRef();
              return S_OK;
        }

        return (S_OK);
    }


    STDMETHOD(GetSurface)(LONG nWidth, LONG nHeight,
                          REFGUID bfid, 
                          ULONG nPasses,
                          DWORD dwHints,
                          IUnknown** ppSurface) {

        if (!ppSurface) {
            return E_POINTER;
        }

        if (!_actuallyDecode) {

            // In this case, we just want to stash away the dimensions
            // and the format, and then fail, so that we won't
            // actually read anything in.
            TraceTag((tagImageDecode, "Decoding width = %d, height = %d",
                      nWidth, nHeight));
            TraceTag((tagImageDecode, "Decoding format = %s",
                      IsEqualGUID(bfid , BFID_RGB_24) ? "BFID_RGB_24"
                      : (IsEqualGUID(bfid, BFID_RGB_8) ? "BFID_RGB_8"
                         : (IsEqualGUID(bfid, BFID_RGB_555) ? "BFID_RGB_555"
                            : "Something Else"))));

        
            _width = nWidth;
            _height = nHeight;

            _infoGatheringSucceeded = true;

            // Now that we have this stuff, return E_FAIL to indicate
            // not to continue with the download.
            return E_FAIL;
            
        } else {

            TraceTag((tagImageDecode, "2nd pass through GetSurface"));


            // This surface description is generated from the BFID and is
            // needed for comparing to the final surface coming in.
            DDSURFACEDESC ddsd;
            ddsd.dwHeight = nHeight;
            ddsd.dwWidth = nWidth;
            bool needsPalette = FillInSurfaceDesc(bfid, ddsd);

            // Compare pixel formats.  If identical, use the surface passed to this
            // method.  If the target surface needs a palette, however, use a separate
            // surface to accomodate the image palette.

            DDPIXELFORMAT& pf1 = _viewport->_targetDescriptor._pixelFormat;
            DDPIXELFORMAT& pf2 = ddsd.ddpfPixelFormat;
    
            if (!needsPalette &&
                pf1.dwFlags == pf2.dwFlags &&
                pf1.dwRGBBitCount == pf2.dwRGBBitCount &&
                pf1.dwRBitMask == pf2.dwRBitMask &&
                pf1.dwGBitMask == pf2.dwGBitMask &&
                pf1.dwBBitMask == pf2.dwBBitMask &&
                pf1.dwRGBAlphaBitMask == pf2.dwRGBAlphaBitMask) {

                TraceTag((tagImageDecode, "Using incoming surface"));

                // operator= takes a reference
                _surfToDecodeTo = _finalSurfToBeBlitTo->IDDSurface();
                _usingProvidedSurface = true;

            } else {

                TraceTag((tagImageDecode, "Creating separate surface"));
        
                // Create a NEW surface.  Will release after we blit to the
                // final one. 
                _viewport->CreateSpecialSurface(
                    &_surfToDecodeTo,
                    &ddsd,
                    "Couldn't create surface for plugin image decoding");

                // If the image surface is going to need a palette, attach one here.
                // Note that we do not need to initialize it:  the palette entries will
                // be assigned from the image decoder.

                if (needsPalette) {
                    PALETTEENTRY        ape[256];
                    LPDIRECTDRAWPALETTE pDDPalette;

                    _viewport->CreateDDPaletteWithEntries (&pDDPalette, ape);
                    if (FAILED(_surfToDecodeTo->SetPalette (pDDPalette))) {
                        Assert (!"Error attaching palette to PNG target surface.");
                     }
                    pDDPalette->Release();
                }
        
                _usingProvidedSurface = false;
            }
            
            IUnknown *unk;
            
            HRESULT hr =
                _surfToDecodeTo->QueryInterface(IID_IUnknown,
                                                (void **)&unk);
            if (FAILED(hr)) {
                Assert(FALSE && "QI for IUnknown failed");
                return E_FAIL;
            }

            // The QI did the AddRef, so don't worry about doing
            // another one.
            *ppSurface = unk;

            return S_OK;
        }
        
    }
    
    STDMETHOD(OnBeginDecode)(DWORD* pdwEvents,
                             ULONG* pnFormats, 
                             GUID** ppFormats) {

        if (!pdwEvents || !pnFormats || !ppFormats) {
            return E_POINTER;
        }
        
        // No progressive downloading or palette stuff now. 
        *pdwEvents = IMGDECODE_EVENT_USEDDRAW;

        const int numberOfFormatsUsed = 3;
        GUID *pFormats =
            (GUID*)CoTaskMemAlloc(numberOfFormatsUsed * sizeof(GUID));
        
        if (pFormats == NULL) {
            return E_OUTOFMEMORY;
        }

        *ppFormats = pFormats;
        
        // Return the formats in the order we'd prefer.  Come up with
        // the first format solely based upon the bitdepth of the
        // current display, since that's what we operate in.  The rest
        // are not as important in terms of their ordering, since all
        // of them will require a StretchBlt to get into native
        // format. 
        // TODO: We no longer import to either of the 16 bit formats
        // because we really don't know which is right for the final
        // use of the surface.  We need to think about what the
        // correct source for our "Native" import format should be.
        // the screen depth is not the right answer.
        HDC dc = GetDC (NULL);    
        int bpp = GetDeviceCaps(dc, BITSPIXEL) * GetDeviceCaps(dc, PLANES);
        ReleaseDC (NULL, dc);
        
        TraceTag((tagImageDecode, "Display is %d bits", bpp));

        switch (bpp) {
          case 32:
            *pFormats++ = BFID_RGB_32;
            *pFormats++ = BFID_RGB_24;
            *pFormats++ = BFID_RGB_8;
            break;

          case 24:
            *pFormats++ = BFID_RGB_24;
            *pFormats++ = BFID_RGB_32;
            *pFormats++ = BFID_RGB_8;
            break;
            
          case 16:
            *pFormats++ = BFID_RGB_32;
            *pFormats++ = BFID_RGB_24;
            *pFormats++ = BFID_RGB_8;
            break;
            
          case 8:
            *pFormats++ = BFID_RGB_8;
            *pFormats++ = BFID_RGB_32;
            *pFormats++ = BFID_RGB_24;
            break;
        }
        
        *pnFormats = numberOfFormatsUsed;

        return S_OK;
    }
    
    STDMETHOD(OnBitsComplete)() {
        Assert(FALSE && "Shouldn't be here, not registered for this");
        return S_OK;
    }
    
    STDMETHOD(OnDecodeComplete)(HRESULT hrStatus) {
        // Don't do anything special here.
        return S_OK;
    }
    
    STDMETHOD(OnPalette)() {
        Assert(FALSE && "Shouldn't be here, not registered for this");
        return S_OK;
    }
    
    STDMETHOD(OnProgress)(RECT* pBounds, BOOL bFinal) {
        Assert(FALSE && "Shouldn't be here, not registered for this");
        return S_OK;
    }

    void GetSurfToDecodeTo(IDirectDrawSurface **pSurfToDecodeTo) {
        _surfToDecodeTo->AddRef();
        *pSurfToDecodeTo = _surfToDecodeTo;
    }
    
    ULONG                           _width;
    ULONG                           _height;
    bool                            _infoGatheringSucceeded;
    bool                            _usingProvidedSurface;
    
  protected:
    ULONG                           _nRefCount;
    RECT                            _rcProg;
    DWORD                           _dwLastTick;
    bool                            _actuallyDecode;
    DDSurfPtr<DDSurface>            _finalSurfToBeBlitTo;
    DirectDrawViewport             *_viewport;
    DAComPtr<IDirectDrawSurface>    _surfToDecodeTo;
};


HINSTANCE hInstImgUtil = NULL;
CritSect *plugImgCritSect = NULL;

HRESULT
MyDecodeImage(IStream *pStream,
              IMapMIMEToCLSID *pMap,
              IUnknown *pUnkOfEventSink)
{
    CritSectGrabber csg(*plugImgCritSect);
    
    typedef HRESULT (WINAPI *DecoderFuncType)(IStream *,
                                              IMapMIMEToCLSID *,
                                              IUnknown *);

    static DecoderFuncType myDecoder = NULL;
  
    if (!myDecoder) {
        hInstImgUtil = LoadLibrary("imgutil.dll");
        if (!hInstImgUtil) {
            Assert(FALSE && "LoadLibrary of imgutil.dll failed");
            return E_FAIL;
        }

        FARPROC fptr = GetProcAddress(hInstImgUtil, "DecodeImage");
        if (!fptr) {
            Assert(FALSE && "GetProcAddress in imgutil.dll failed");
            return E_FAIL;
        }

        myDecoder = (DecoderFuncType)(fptr);
    }

    return (*myDecoder)(pStream, pMap, pUnkOfEventSink);
}

// Lifted from Qa.cpp, in Ken Sykes' test code.  TODO: Make sure this
// is necessary with kgallo.
#define MAX_URL 2048
void
MyAnsiToUnicode(LPWSTR lpw, LPCSTR lpa)
{
    while (*lpa)
        *lpw++ = (WORD)*lpa++;
    *lpw = 0;
}

// When realDecode is true, the width, height, and bfid params are not filled
// in and the surface must be correctly set up.  When it is false, the
// surface is ignored and the dimensions and bfid are filled in.  In both
// cases, the function will throw an appropriate exception on failure.

bool
DecodeImageFromFilename(char *szFileName,
                        IStream *pStream,
                        bool realDecode,
                        DirectDrawViewport *viewport,
                        DDSurface *finalSurface,
                        IDirectDrawSurface **pSurfToDecodeInto,
                        LONG *outWidth,  
                        LONG *outHeight)
{
    HRESULT hr;

    LARGE_INTEGER startPos = { 0, 0 };

    CImageDecodeEventSink *eventSink =
        NEW CImageDecodeEventSink (realDecode,
                                   viewport,
                                   finalSurface);

    if (!eventSink) //if the NEW failed
    {
        RaiseException_OutOfMemory("Failed to allocate CImageDecodeEventSink in DecodeImageFromFilename", sizeof(CImageDecodeEventSink));
    }

    DAComPtr<IUnknown> pEventSinkUnk;

    CHECK_HR( eventSink->QueryInterface(IID_IUnknown,
                                       (void **)&pEventSinkUnk) );

    TraceTag((tagImageDecode, "Starting decode of %s", szFileName));
    
    Assert(pStream);
    if(pStream) {
        pStream->Seek (startPos, STREAM_SEEK_SET, NULL);
    }
    else
    {
        goto Error;
    }

    hr = MyDecodeImage(pStream, NULL, pEventSinkUnk);

    if (!realDecode) {
        
        if (!eventSink->_infoGatheringSucceeded) {
            RaiseException_UserError(E_FAIL, IDS_ERR_NO_DECODER, szFileName);
        }

        // Be sure we have valid dimensions.
        if (eventSink->_width == -1 || eventSink->_height == -1) {
            
            TraceTag((tagImageDecode, "Getting dimensions failed"));
            RaiseException_UserError(E_FAIL, IDS_ERR_DECODER_FAILED, szFileName);
        }

        *outWidth = eventSink->_width;
        *outHeight = eventSink->_height;
        
        TraceTag((tagImageDecode,
                  "Getting dimensions succeeded: (%d, %d)",
                  *outWidth, *outHeight));
        
    } else {


        // If we're here and we fail, then something's weird.  We were
        // successfully able to instantiate the decoder enough to get
        // dimensions.  Going to consider this a User error, because
        // the decoder is outside of our control.
        Assert(!(FAILED(hr)));
        if (FAILED(hr)) {
            RaiseException_UserError(E_FAIL, IDS_ERR_DECODER_FAILED, szFileName);
        }

        eventSink->GetSurfToDecodeTo(pSurfToDecodeInto);

        TraceTag((tagImageDecode, "Ending decode of %s", szFileName));
        
        // All done.  Surf is filled in, nothing more to do.
    }
    
    return eventSink->_usingProvidedSurface;

Error:
    TraceTag((tagImageDecode, "Decoding failed with hr of %d", hr));
    RaiseException_InternalError("Image Decoding Failed");
    return false;
}


//////////////// PluginDecoderImageClass //////////////////



class PluginDecoderImageClass : public DiscreteImage {
  public:
    PluginDecoderImageClass()
    : _heapCreatedOn(NULL), _imagestream(NULL),
      _filename(NULL), _urlPath(NULL) {}

    void Init(char *urlPath,
              char *cachePath,
              IStream *imagestream,
              COLORREF colorKey);
    
    ~PluginDecoderImageClass();
    
    void InitIntoDDSurface(DDSurface *ddSurf,
                           ImageDisplayDev *dev);
    
#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "(PluginDecoderDiscreteImage @ " << (void *)this << ")";
    }   
#endif

    virtual VALTYPEID GetValTypeId() { return PLUGINDECODERIMAGE_VTYPEID; }
    virtual bool CheckImageTypeId(VALTYPEID type) {
        return (type == PluginDecoderImageClass::GetValTypeId() ||
                DiscreteImage::CheckImageTypeId(type));
    }
    
    bool ValidColorKey(LPDDRAWSURFACE surface, DWORD *colorKey) {
        if(_colorKey != INVALID_COLORKEY) {
            *colorKey = DDColorMatch(surface, _colorKey);
            return true;
        } else {
            *colorKey = INVALID_COLORKEY;  // xxx: won't work for argb
            return false;
        }
    }

  protected:
    COLORREF          _colorKey;
    DynamicHeap      *_heapCreatedOn;
    DAComPtr<IStream> _imagestream;
    char             *_filename;
    char             *_urlPath;
};

void
PluginDecoderImageClass::Init(char *urlPath,
                              char *cachePath,
                              IStream *imagestream,
                              COLORREF colorKey)
{
    _membersReady = false;
    
    // When this image subtype is Decoded, we first do a fake
    // decoding of the image, just to get the height and width.  Only
    // when InitIntoDDSurface is called do we actually do another
    // decode to get the real bits.

    _heapCreatedOn = &GetHeapOnTopOfStack();
    _colorKey = colorKey;

    _filename = (char *)StoreAllocate(*_heapCreatedOn,
                                      (lstrlen(cachePath) + 1) *
                                      sizeof(char));
    lstrcpy(_filename, cachePath);

    _urlPath = (char *)StoreAllocate(*_heapCreatedOn,
                                      (lstrlen(urlPath) + 1) *
                                      sizeof(char));
    lstrcpy(_urlPath, urlPath);
    
    // Initial decode will get width and height.
    Assert(imagestream);

    DecodeImageFromFilename(_filename,
                            imagestream,
                            false,
                            NULL,
                            NULL,
                            NULL,
                            &_width,
                            &_height);

    // Reset the stream back to its start
    LARGE_INTEGER pos;
    pos.LowPart = pos.HighPart = 0;
    HRESULT hr = imagestream->Seek(pos, STREAM_SEEK_SET, NULL);
    
    Assert(hr != E_PENDING && "Storage is asynchronous -- not expected");

    if (SUCCEEDED(hr)) {
        
        SetRect(&_rect, 0,0, _width, _height);

        // Only stash this if we've successfully been able to complete
        // our first pass.
        _imagestream = imagestream;
        
        _resolution = ViewerResolution();

        _membersReady = true;
    }
}

PluginDecoderImageClass::~PluginDecoderImageClass()
{
    if (_heapCreatedOn) {
        if (_filename)
            StoreDeallocate(*_heapCreatedOn, _filename);

        if (_urlPath)
            StoreDeallocate(*_heapCreatedOn, _urlPath);
    }
}


void
PluginDecoderImageClass::InitIntoDDSurface(DDSurface *finalSurface,
                                           ImageDisplayDev *dev)
{
    Assert( finalSurface );
    Assert( finalSurface->IDDSurface() );

    if( FAILED(finalSurface->IDDSurface()->Restore()) ) {
        RaiseException_InternalError("Restore on finalSurface in PluginDecoderImageClass");
    }   
        
    if (!_imagestream) {

        // This means we've already read this file once and closed the
        // stream.  Reopen the stream as a blocking stream (hopefully
        // it will still be in the local cache.)

        HRESULT hr =
            URLOpenBlockingStream(NULL,
                                  _urlPath,
                                  &_imagestream,
                                  0,
                                  NULL);

        if (FAILED(hr)) {
            TraceTag((tagImageDecode,
                      "InitIntoDDSurface - Failed to get an IStream."));
            RaiseException_UserError(hr, IDS_ERR_FILE_NOT_FOUND, _urlPath);
        }
        
    }
    Assert(_imagestream);
    
    // First, see if the surface we've been passed to render into is
    // the same format as the BFID of the image about to be decoded.
    // If so, just pass it directly as the surface to decode into.
    DirectDrawImageDevice *ddDev =
        SAFE_CAST(DirectDrawImageDevice *, dev);
    DirectDrawViewport& viewport = ddDev->_viewport;
        
    // Just go directly into the surface that we're passed.  Any
    // errors will be thrown as exceptions.
    DAComPtr<IDirectDrawSurface> surfToDecodeInto;
    
    bool usingProvidedSurface = 
        DecodeImageFromFilename(_filename,
                                _imagestream,
                                true,
                                &viewport,
                                finalSurface,
                                &surfToDecodeInto,
                                NULL,
                                NULL);

    if (!usingProvidedSurface) {

        PixelFormatConvert(surfToDecodeInto,
                           finalSurface->IDDSurface(),
                           _width,
                           _height,
                           NULL,
                           false);

        // if this was only used for decoding, release it here.
        surfToDecodeInto.Release();
    }

    // Release the stream.  If we need to decode into another surface,
    // we'll reopen the imagestream from the URLpath
    _imagestream.Release();
}

Image *
PluginDecoderImage(char *urlPath,
                   char *cachePath,
                   IStream *imagestream,
                   bool useColorKey,
                   BYTE ckRed,
                   BYTE ckGreen,
                   BYTE ckBlue)
{
    COLORREF colorRef;
    if (useColorKey) {
        colorRef = RGB(ckRed, ckGreen, ckBlue);
    } else {
        colorRef = INVALID_COLORKEY;
    }
    
    PluginDecoderImageClass * pPlugin = NEW PluginDecoderImageClass();

    pPlugin->Init(urlPath, cachePath, imagestream, colorRef);

    return pPlugin;
}

void
InitializeModule_PlugImg()
{
    if (!plugImgCritSect) {
        plugImgCritSect = NEW CritSect;
    }
}

void
DeinitializeModule_PlugImg(bool bShutdown)
{
    if (plugImgCritSect) {
        delete plugImgCritSect;
        plugImgCritSect = NULL;
    }
    
    if (hInstImgUtil) {
        FreeLibrary(hInstImgUtil);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\tiledimg.cpp ===
/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    Implements the TiledImage class
    which is an infinitly tiled image
    based on an aXb crop of an underlying
    image.

-------------------------------------*/

#include "headers.h"
#include "privinc/imagei.h"
#include "privinc/imgdev.h"
#include "privinc/vec2i.h"
#include "privinc/probe.h"
#include "privinc/bbox2i.h"
#include "privinc/overimg.h"
#include "appelles/xform2.h"

class TiledImage : public AttributedImage {
  public:

    TiledImage(Point2Value *minPt, Point2Value *maxPt, Image *img) :
        AttributedImage(img) 
    {
        _minPt = Demote(*minPt);
        _maxPt = Demote(*maxPt);
    }

    TiledImage(const Point2 &minPt, const Point2 &maxPt, Image *img) :
        _minPt(minPt), _maxPt(maxPt), AttributedImage(img) {}

    void Render(GenericDevice& dev);

    inline const Bbox2 BoundingBox() { return UniverseBbox2; }

    Real DisjointBBoxAreas(DisjointCalcParam &param) {
        // Could conceivably be smarter about how to calculate
        // disjoint bbox area for tiles, but returning infinity will
        // keep it on par with the Universal Bbox it returns.
        return HUGE_VAL;
    }
    
    void _CollectDirtyRects(DirtyRectCtx &ctx) {
        // A tiled image has universal extent, so just add this in.
        // TODO: Note that we should change this to pay attention to
        // cropping and matting, so that a tiled image won't
        // necessarily be considered to have universal extent.  This
        // current approach is overly pessimistic.
        ctx.AddDirtyRect(UniverseBbox2);
    }
    
#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) { return UniverseBbox2; }
#endif  // BOUNDINGBOX_TIGHTER

#if _USE_PRINT
    // Print a representation to a stream.
    ostream& Print(ostream& os) {
        return os << "TiledImage" << " <minPt> " << " <maxPt> " << _image;
    }
#endif

    Bool  DetectHit(PointIntersectCtx& ctx);

    int Savings(CacheParam& p) { return 2; }

    virtual void DoKids(GCFuncObj proc) { 
        AttributedImage::DoKids(proc);
    }

    // tiled image is an intermediate 'other' node even though it
    // attributes other image types, it's sufficiently different and
    // intermediate that it's considered 'other' instead of its
    // underlying type.
    virtual void Traverse(TraversalContext &ctx) {
        ctx.SetContainsOther();
    }
    
  protected:
    // define image to tile: box within minPt/maxPt
    Point2 _minPt, _maxPt;
};

void
TiledImage::Render(GenericDevice& _dev)
{
    ImageDisplayDev &dev = SAFE_CAST(ImageDisplayDev &, _dev);

    dev.RenderTiledImage(_minPt, _maxPt, _image);
}

Bool  
TiledImage::DetectHit(PointIntersectCtx& ctx) 
{
    Point2Value *ptv = ctx.GetLcPoint();

    if (!ptv) return FALSE;      // singular transform

    Point2 pt = Demote(*ptv);

    // get pt within the min/max bounds
    // then ask the underlying image if it's hit.
    
    // the point within the min/max bounds is:
    // p = min + [ (pt - min) MOD (max - min) ]
    // or: p = left + [ (pt - left) MOD width ]
    Real tileWidth = (_maxPt.x - _minPt.x);
    Real tileHeight= (_maxPt.y - _minPt.y);
    Real xRemainder = fmod(( pt.x - _minPt.x ), tileWidth);
    Real yRemainder = fmod(( pt.y - _minPt.y ), tileHeight);
    // we do this because fmod() can be negative
    Real modX = _minPt.x + (xRemainder < 0 ? (xRemainder + tileWidth)  : xRemainder);
    Real modY = _minPt.y + (yRemainder < 0 ? (yRemainder + tileHeight) : yRemainder);
    
    // Create a transform that transforms FROM the underlying
    // image space (modX,modY) TO the LcPoint (pt): pt = XF * mod
    // OR:  ptX = Tx + modX  implies:  Tx = ptX - modX
    Real tx = pt.x - modX;
    Real ty = pt.y - modY;
    Transform2 *UnderToLc = TranslateRR(tx,ty);

    // Since the transforms are encountered outside-in AND the transform
    // takes underlying image to Local, we need to put it BEFORE all the
    // encountered transforms... hence we premultiply (mult on left)
    // The net result is that the inverse of these transforms takes the
    // World Coordinate directly into the underlying image's space.
    // Note that this is different from what's done for a transformed image
    // on purpose.
    Transform2 *stashedXf = ctx.GetTransform();
    ctx.SetTransform( TimesTransform2Transform2( UnderToLc, stashedXf ) );
    Bool isHit = _image->DetectHit(ctx);
    ctx.SetTransform( stashedXf );
    
    return isHit;
}


Image *
TileImage_Old(const Point2 &minPt, const Point2 &maxPt, Image *image)
{
    // min must be lower left of max, if not return empty image
    if((minPt.x >= maxPt.x) || (minPt.y >= maxPt.y)) {
        return emptyImage;
    }

#if BADIDEA
    if (image->CheckImageTypeId(OVERLAYEDIMAGE_VTYPEID)) {
        
        //
        // Dynamic expression reduction
        //
        OverlayedImage *overImg = (OverlayedImage *)image;
        
        Image *newTop = NEW TiledImage(minPt, maxPt, overImg->Top());
        Image *newBot = NEW TiledImage(minPt, maxPt, overImg->Bottom());
        overImg->SetTopBottom(newTop, newBot);
        return overImg;
    } else if(image->CheckImageTypeId(OPAQUEIMAGE_VTYPEID)) {

        //
        // Opaque Image
        //
//        OpaqueImageClass *opcImg = (OpaqueImageClass *)image;
        AttributedImage *opcImg = (AttributedImage *)image;

        if(opcImg->_image->CheckImageTypeId(OVERLAYEDIMAGE_VTYPEID)) {
            
            OverlayedImage *overImg = (OverlayedImage *)opcImg->_image;

            //
            // Push xf past opacity, under overlay
            //
            overImg->SetTopBottom(NEW TiledImage(minPt, maxPt, overImg->Top()),
                                  NEW TiledImage(minPt, maxPt, overImg->Bottom()));
            
            opcImg->_image = overImg;
            return opcImg;
        } else {
            // !over
            // !opac
            // => error
            Assert(FALSE && "There's something wrong with dynamic image reduction");
        }
    }
#endif BADIDEA

    return NEW TiledImage(minPt, maxPt, image);
}

Image *
TileImage(Image *image)
{
    Bbox2 bbox = image->BoundingBox();

    return TileImage_Old(Point2(bbox.min.x, bbox.min.y),
                         Point2(bbox.max.x, bbox.max.y),
                         image);

    // BAD: Don't return the address of a field and pretend it's an
    // AxAValueObj!! 
    //return TileImage_Old(&bbox->min, &bbox->max, image);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\textimg.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

--*/

#include "headers.h"
#include "privinc/TextImg.h"
#include "privinc/texti.h"
#include "appelles/hacks.h"
#include "privinc/dddevice.h"

//////////  Rendering a text into an image  /////////////

void
TextImage::Render(GenericDevice& _dev)
{
    DirectDrawImageDevice &dev = SAFE_CAST(DirectDrawImageDevice &, _dev);
    TextCtx ctx(&dev, this);

    ctx.BeginRendering();
    _text->RenderToTextCtx(ctx);
    ctx.EndRendering();
}

void TextImage::DoKids(GCFuncObj proc)
{
    Image::DoKids(proc);
    (*proc)(_text);
}



const Bbox2
TextImage::DeriveBbox()
{
    // This is a lot like we're rendering: doing a bunch of the same work
    // that rendering does, except all we get out of it is a bbox!
    Bbox2 fooBox;
    if(_bbox == NullBbox2) {

        DirectDrawViewport *vp = GetCurrentViewport();

        if( vp ) {

            DirectDrawImageDevice *dev = GetImageRendererFromViewport( vp );
            
            TextCtx ctx(dev, this);
            
            ctx.BeginRendering(TextCtx::renderForBox);
                
            _text->RenderToTextCtx(ctx);
            
            ctx.EndRendering();
            
            // XXX: This is dumb...
            _bbox= ctx.GetStashedBbox();
        }
    }

    return _bbox;
}

Image *RenderTextToImage(Text *t)
{
    if ((t->GetStringPtr() == NULL) ||
        !StrCmpW(t->GetStringPtr(), L"")) {
        return emptyImage;
    }
    
    return NEW TextImage(t);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\urlimage.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

#include "headers.h"

#include <appelles/hacks.h>

#include <commctrl.h>
#include <ole2.h>
#include <dxhtml.h>

#include <privinc/server.h>
#include <server/view.h>       // GetEventQ()
#include <server/eventq.h>
#include <privinc/viewport.h>
#include <privinc/dddevice.h>
#include <privinc/ddsurf.h>
#include <privinc/ipc.h>
#include <privinc/UrlImage.h>

#include "DXHTML_i.c"  // DXHTML GUIDS


#define  USEDXHTML 1

UrlImage::UrlImage(IDirectXHTML *pDxhtml,
                   AxAString *url) :
         _url(url),
         _isHit(false),
         _downdLoadComplete(false)
{
#if USEDXHTML    
    Assert(pDxhtml);
#endif    

    _pDXHTML = pDxhtml; // addref
    
    DebugCode
    (
        _initialDDSurf = NULL;
    );
    
    if(_resolution < 0) {
        _resolution = NumberToReal(PRIV_ViewerResolution(0));
    }
    _width = _height = 0;
    SetBbox(_width, _height, _resolution);

    if(!SetupDxHtml()) {
        // can't render at all... we're useless.
        _pDXHTML = NULL;
    }

    _lastTime = _curTime = 0;
    
    // not necessary
    //DynamicPtrDeleter<UrlImage> *dltr = new DynamicPtrDeleter<UrlImage>(this);
    //GetHeapOnTopOfStack().RegisterDynamicDeleter(dltr);
}


void UrlImage::InitializeWithDevice(ImageDisplayDev *dev, Real res)
{
    if( !_membersReady) {
        _dev = (DirectDrawImageDevice *)dev;
        SetMembers(_dev->GetViewport()->Width(),
                   _dev->GetViewport()->Height());
        SetBbox(_width, _height, _resolution);
    }
}

bool UrlImage::SetupDxHtml()
{
#if USEDXHTML
    Assert( _pDXHTML );

    HRESULT hr;
    //
    // Setup Callback Interface for DXHTML
    //
    _pDXHTMLCallback = new CDirectXHTMLCallback(this); // ref=1

    if (!_pDXHTMLCallback)
    {
        Assert(0 && "Unable to Create DirectXHTMLCallback Interface!!!");
        return false;
    }

    hr = _pDXHTML->RegisterCallback(_pDXHTMLCallback, DXHTML_CBFLAGS_ALL);
    if (FAILED(hr))  return false;

    hr = _pDXHTML->put_scroll(true);
    if (FAILED(hr))  return false;

    hr = _pDXHTML->put_hyperlinkmode(DXHTML_HYPERLINKMODE_NONE);
    if (FAILED(hr))  return false;

    return true;
#else
    return false;
#endif
}

Bool UrlImage::
DetectHit(PointIntersectCtx& ctx)
{
    Point2Value *lcPt = ctx.GetLcPoint();

    if (!lcPt) return FALSE;    // singular matrix
    
    if (BoundingBox().Contains(Demote(lcPt))) {

        // we're hit, set this flag. render will pass
        // events down when it checks it
        _isHit = true;
        
        //::SubscribeToWindEvents(this);
        
        Point2Value *pts[1];
        pts[0] = lcPt;
        POINT gdiPts;
        _dev->TransformPointsToGDISpace(identityTransform2,
                                        pts,
                                        &gdiPts,
                                        1);

        _lastHitX = gdiPts.x;
        _lastHitY = gdiPts.y;
        
        LRESULT lResult;

        UINT msg = WM_MOUSEMOVE;
        WPARAM wParam = 0;
        LPARAM lParam = MAKELPARAM( gdiPts.x, gdiPts.y );

        #if USEDXHTML
        _pDXHTML->WindowMessage(msg, wParam, lParam, &lResult);
        #endif
    }
    return FALSE;
}

void UrlImage::OnWindowMessage(UINT msg,
                               WPARAM wParam,
                               LPARAM lParam)
{
    Assert(0);
    
    if( _pDXHTML ) {

        //case WM_SIZE:  pass this if we want it to change vp ?

        switch(msg) {
          case WM_LBUTTONUP:
          case WM_LBUTTONDOWN:
          case WM_LBUTTONDBLCLK:
          case WM_RBUTTONUP:
          case WM_RBUTTONDOWN:
          case WM_RBUTTONDBLCLK:
          case WM_MBUTTONUP:
          case WM_MBUTTONDOWN:
          case WM_MBUTTONDBLCLK:
            // lie about mouse pos!
            lParam = MAKELPARAM( _lastHitX, _lastHitY );
            break;
          case WM_KEYDOWN:
          case WM_SYSKEYDOWN:
          case WM_KEYUP:
          case WM_SYSKEYUP:
            break;

            // don't care
          case WM_MOUSEMOVE:
          default:
            return;  // out, we don't send other msgs down!
            break;
        }            

        LRESULT lResult;
        _pDXHTML->WindowMessage(msg, wParam, lParam, &lResult);
    } // if
}

/*
void UrlImage::OnEvent(AXAWindEvent *ev)
{

    Assert(ev);
    if( _pDXHTML ) {

        bool sendEvent = true;
        // send it down baby!

        UINT msg;
        WPARAM wParam = 0;
        LPARAM lParam = 0;

        _pDXHTML->WindowMessage(msg, wParam, lParam, &lResult);
        BYTE winMod = 0;
        if( ev->modifiers & AXAEMOD_SHIFT_MASK ) winMod |= VK_SHIFT;
        if( ev->modifiers & AXAEMOD_CTRL_MASK )  winMod |= VK_CTRL;
        if( ev->modifiers & AXAEMOD_MENU_MASK )  winMod |= VK_MENU;
        if( ev->modifiers & AXAEMOD_ALT_MASK )   winMod |= VK_ALT;
        if( ev->modifiers & AXAEMOD_META_MASK )  winMod |= VK_META;
            
        switch( ev->id ) {
          case AXAE_MOUSE_MOVE:
            // can't use these because we don't know how to map them
            sendEvent = false;
            break;
            
          case AXAE_MOUSE_BUTTON:

            if( ev->data == AXA_MOUSE_BUTTON_LEFT &&
                ev->bState == AXA_STATE_DOWN ) {
                msg = WM_LBUTTONDOWN;
            } else 
            if( ev->data == AXA_MOUSE_BUTTON_LEFT &&
                ev->bState == AXA_STATE_UP ) {
                msg = WM_LBUTTONUP;
            } else
                
            if( ev->data == AXA_MOUSE_BUTTON_RIGHT &&
                ev->bState == AXA_STATE_DOWN ) {
                msg = WM_RBUTTONDOWN;
            } else 
            if( ev->data == AXA_MOUSE_BUTTON_RIGHT &&
                ev->bState == AXA_STATE_UP ) {
                msg = WM_RBUTTONUP;
            } else
                
            if( ev->data == AXA_MOUSE_BUTTON_MIDDLE &&
                ev->bState == AXA_STATE_DOWN ) {
                msg = WM_MBUTTONDOWN;
            } else 
            if( ev->data == AXA_MOUSE_BUTTON_MIDDLE &&
                ev->bState == AXA_STATE_UP ) {
                msg = WM_MBUTTONUP;
            } 
                
            lParam = MAKELPARAM( _lastHitX, _lastHitY );
            break;
            
          case AXAE_KEY:
            char key = (char)ev->data; // which key
            
            if( ev->bState == AXA_STATE_DOWN )
                msg = WM_KEYDOWN;
            else
                msg = WM_KEYUP;

            lParam = 0xc0000000;
            wParam = key;
            break;
            
          case AXAE_FOCUS:
          case AXAE_APP_TRIGGER:
          default:
            sendEvent = false;
        }

        if( sendEvent ) {
            LRESULT lResult;
            _pDXHTML->WindowMessage(msg, wParam, lParam, &lResult);
        }
        
    } // if _pDXHTML
}
*/

#if 0
// for testing...
extern void
MyDoBits16(LPDDRAWSURFACE surf16, LONG width, LONG height);
#endif

void UrlImage::Render(GenericDevice& dev)
{

    if( _isHit ) {
        //
        // Update mshtml with all events since
        //
        EventQ &evQ = GetCurrentView().GetEventQ();

        AXAWindEvent *ev;

        #if USEDXHTML
        if( evQ.Iterate_BeginAtTime(_lastTime) && _pDXHTML) {
        #else
        if( evQ.Iterate_BeginAtTime(_lastTime)) {
        #endif  
        
            LRESULT lResult;
            while( ev = evQ.Iterate_GetCurrentEventBeforeTime(_curTime) ) {

                // put this in when events have window messages in them
                #if 0
        #if USEDXHTML
                if( ev->_msg != WM_MOUSEMOVE ) {
                    _pDXHTML->WindowMessage(ev->_msg,
                                            ev->_wParam,
                                            ev->_lParam,
                                            &lResult);
                }
        #endif
                #endif
            
                //if( ev->_msg == WM_LBUTTONDOWN ) TraceTag((tagError,"------> LButton Down <------"));
                //if( ev->_msg == WM_LBUTTONUP ) TraceTag((tagError,"------> LButton Up <------"));
                                
                evQ.Iterate_Next();
            }
        }
    } // _isHit

    
    #if USEDXHTML

    // to be smarter, just update the invalidates we get in the callback
    if( _pDXHTML && _membersReady && _downdLoadComplete) {
        HRESULT hr = _pDXHTML->UpdateSurfaceRect( GetRectPtr() );
        Assert( SUCCEEDED(hr) );
    }
    
    #else

    DebugCode(
        // paint bogus in the surface
        if( _initialDDSurf ) {
            MyDoBits16(_initialDDSurf->IDDSurface(),
                       _initialDDSurf->Width(),
                       _initialDDSurf->Height());
        }
    );
    
    #endif
    

    DiscreteImage::Render(dev);
}


void UrlImage::
InitIntoDDSurface(DDSurface *ddSurf,
                  ImageDisplayDev *dev)
{
    Assert( ddSurf );

    DebugCode(_initialDDSurf = ddSurf);
    
    //
    // Set up widht, height, rect, and bbox!
    //
    _width = ddSurf->Width();
    _height = ddSurf->Height();
    ::SetRect(&_rect, 0,0, _width, _height);
    SetBbox( GetPixelWidth(),
             GetPixelHeight(),
             GetResolution() );
    _bboxReady = TRUE;
    _membersReady = TRUE;


#if USEDXHTML
    Assert( _pDXHTML );
    HRESULT hr;

    hr = _pDXHTML->put_surface( ddSurf->IDDSurface() );
    Assert( SUCCEEDED(hr) );

    hr = _pDXHTML->put_src( _url->GetStr() );
    Assert( SUCCEEDED(hr) );
#endif    
}


Image *ConstructUrlImage(AxAString *str)
{
    DAComPtr< IDirectXHTML > pDxhtml;

    Image *outImage;
    
#if USEDXHTML
    HRESULT hr = CoCreateInstance(CLSID_CDirectXHTML,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IDirectXHTML,
                                  (void **)&pDxhtml);
    if (FAILED(hr))
    {
        TraceTag((tagError, "ContrustUrlImage - Unable to load DXHTML.DLL"));
        outImage = emptyImage;
    } else
#endif
      {
          outImage = NEW UrlImage(pDxhtml, str);
      }
    
    return outImage;
}

Image *UrlImageSetTime(Image *img, AxANumber *t)
{
    Assert(img);
    
    if(img->GetValTypeId() == URLIMAGE_VTYPEID) {
        UrlImage *urlImage = SAFE_CAST(UrlImage *, img);
        urlImage->SetSampleTime( NumberToReal(t) );
    }

    return img;
}
    

//**********************************************************************
// File name: dxhtmlcb.cpp
//
// Functions:
//
// Copyright (c) 1997 Microsoft Corporation. All rights reserved.
//**********************************************************************


//****************************************************************************
//
// CDirectXHTMLCallback::CDirectXHTMLCallback
// CDirectXHTMLCallback::~CDirectXHTMLCallback
// 
// Purpose:
//      Constructor and Destructor members for CDirectXHTMLCallback object.
//
//****************************************************************************

CDirectXHTMLCallback::CDirectXHTMLCallback( UrlImage *urlImage )
{
    _urlImage = urlImage;
    m_cRef  = 0;
}


CDirectXHTMLCallback::~CDirectXHTMLCallback( void )
{
}




//****************************************************************************
//
// CDirectXHTMLCallback::QueryInterface
// CDirectXHTMLCallback::AddRef
// CDirectXHTMLCallback::Release
// 
// Purpose:
//      IUnknown members for CDirectXHTMLCallback object.
//
//****************************************************************************

STDMETHODIMP CDirectXHTMLCallback::QueryInterface( REFIID riid, void **ppv )
{
    // DPF( 4, TEXT("CDirectXHTMLCallback::QueryInterface") );

    *ppv = NULL;

    //
    // BUGBUG - When we have a GUID interface, we should check for it
    //

    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    //DPGUID( TEXT("CDirectXHTMLCallback::QueryInterface"), riid);

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CDirectXHTMLCallback::AddRef( void )
{
    // DPF( 0, TEXT("CDirectXHTMLCallback::AddRef [%lu -> %lu]"), m_cRef, (m_cRef + 1) );

    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CDirectXHTMLCallback::Release( void )
{
    // DPF( 0, TEXT("CDirectXHTMLCallback::Release [%lu -> %lu]"), m_cRef, (m_cRef - 1) );

    if ( m_cRef == 0 )
    {
        // DPF( 0, TEXT("CDirectXHTMLCallback::Release - YIKES! Trying to decrement when Ref count is zero!!!") );
        //DBREAK();
        Assert(0 && "Release 0 obj!");
        return m_cRef;
    }

    if ( 0 != --m_cRef )
    {
        return m_cRef;
    }

    // DPF( 0, TEXT("CDirectXHTMLCallback::Release - CDirectXHTMLCallback has been deleted.") );
    delete this;
    return 0;
}




//****************************************************************************
// Function: CDirectXHTMLCallback::OnSetTitleText()
//
// Purpose:
//
// Parameters:
//
// Return Code:
//      HRESULT
//
// Comments:
//      None.
//
//****************************************************************************
STDMETHODIMP CDirectXHTMLCallback::OnSetTitleText( LPCWSTR lpszText )
{
    TCHAR szBuffer[MAX_PATH];
    TCHAR szMsg[MAX_PATH];

    // DPF( 4, TEXT("CDirectXHTMLCallback::OnSetTitleText") );

    /*
    //
    // Set Text
    //
    if ( WideCharToMultiByte( CP_ACP, 0, lpszText, -1, szBuffer, MAX_PATH, NULL, NULL ) )
    {
        wsprintf( szMsg, TEXT("Contain - %s"), szBuffer );
        SendMessage( pApp->m_hWndMain, WM_SETTEXT, 0, (LPARAM)szBuffer );
    }
    */
    return S_OK;
}




//****************************************************************************
// Function: CDirectXHTMLCallback::OnSetProgressText()
//
// Purpose:
//
// Parameters:
//
// Return Code:
//      HRESULT
//
// Comments:
//      None.
//
//****************************************************************************
STDMETHODIMP CDirectXHTMLCallback::OnSetProgressText( LPCWSTR lpszText )
{
    TCHAR szBuffer[MAX_PATH];

    // DPF( 4, TEXT("CDirectXHTMLCallback::OnSetProgressText") );

    /*
    //
    // Set Text
    //    
    if ( WideCharToMultiByte( CP_ACP, 0, lpszText, -1, szBuffer, MAX_PATH, NULL, NULL ) )
    {
        SendMessage( pApp->m_hWndStatusbar, SB_SETTEXT, SB_PROGRESSTEXT, (LPARAM)szBuffer );
    }
    */
    
    return S_OK;
}




//****************************************************************************
// Function: CDirectXHTMLCallback::OnSetStatusText()
//
// Purpose:
//
// Parameters:
//
// Return Code:
//      HRESULT
//
// Comments:
//      None.
//
//****************************************************************************
STDMETHODIMP CDirectXHTMLCallback::OnSetStatusText( LPCWSTR lpszText )
{
    TCHAR szBuffer[MAX_PATH];

    // DPF( 4, TEXT("CDirectXHTMLCallback::OnSetStatusText") );

    /*
    //
    // Set Text
    //    
    if ( WideCharToMultiByte( CP_ACP, 0, lpszText, -1, szBuffer, MAX_PATH, NULL, NULL ) )
    {
        SendMessage( pApp->m_hWndStatusbar, SB_SETTEXT, SB_STATUSTEXT, (LPARAM)szBuffer );
    }
    */
    
    return S_OK;
}


//****************************************************************************
// Function: CDirectXHTMLCallback::OnSetProgressText()
//
// Purpose:
//
// Parameters:
//
// Return Code:
//      HRESULT
//
// Comments:
//      None.
//
//****************************************************************************
STDMETHODIMP CDirectXHTMLCallback::OnSetProgressMax( const DWORD dwMax )
{
    /*
    if (pApp->m_hWndProgress) 
    {
        if ( dwMax == 0 )
        {
            ShowWindow( pApp->m_hWndProgress, SW_HIDE );
        }
        else
        {
            RECT rc;

            SendMessage( pApp->m_hWndStatusbar, SB_GETRECT, SB_PROGRESSMETER, (LPARAM)&rc );
            InflateRect( &rc, -GetSystemMetrics(SM_CXEDGE), -GetSystemMetrics(SM_CYEDGE) );
            SetWindowPos (pApp->m_hWndProgress, NULL, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW );
            SendMessage( pApp->m_hWndProgress, PBM_SETRANGE32, 0, (LPARAM)dwMax );
            SendMessage( pApp->m_hWndProgress, PBM_SETPOS, 0, 0);
        }
    }
    */
    return S_OK;
}




//****************************************************************************
// Function: CDirectXHTMLCallback::OnSetProgressPos()
//
// Purpose:
//
// Parameters:
//
// Return Code:
//      HRESULT
//
// Comments:
//      None.
//
//****************************************************************************
STDMETHODIMP CDirectXHTMLCallback::OnSetProgressPos( const DWORD dwPos )
{
    /*
    if ( pApp->m_hWndProgress )
    {
        SendMessage( pApp->m_hWndProgress, PBM_SETPOS, (LPARAM)dwPos, 0 );
    }
    */
    return S_OK;
}




//****************************************************************************
// Function: CDirectXHTMLCallback::OnCompletedDownload()
//
// Purpose:
//
// Parameters:
//
// Return Code:
//      HRESULT
//
// Comments:
//      None.
//
//****************************************************************************
STDMETHODIMP CDirectXHTMLCallback::OnCompletedDownload( void )
{
    SIZEL sizeDoc;
    _urlImage->GetDXHTML()->get_docsize( &sizeDoc );
    _urlImage->OnCompletedDownload( &sizeDoc );
    
    TraceTag((tagUrlImage,
              "Document has completed downloading...\n\nSize of Document is %d x %d",
              sizeDoc.cx, sizeDoc.cy ));

    return S_OK;
}




//****************************************************************************
// Function: CDirectXHTMLCallback::OnInvalidate()
//
// Purpose:  Invalidation notification from dxhtml.
//           We should issue a draw in reply.  
//
// Parameters:  lprc - RECT of newly invalidated area in client pixel units
//              fErase - equivalent of ::InvalidateRect()'s fErase param
//
// Return Code:
//      HRESULT
//
// Comments:
//      None.
//
//****************************************************************************
STDMETHODIMP CDirectXHTMLCallback::OnInvalidate( const RECT *lprc, 
                                                 DWORD       dwhRgn,
                                                 VARIANT_BOOL fErase )
{
    // DPF( 4, TEXT("CDirectXHTMLCallback::OnInvalidate") );

    /*
    HRGN hRgn = reinterpret_cast<HRGN>(dwhRgn);
    if( hRgn )
    {
        ::InvalidateRgn( pApp->m_hWndMain, hRgn, !!fErase );
    }
    else
    {
        ::InvalidateRect( pApp->m_hWndMain, lprc, !!fErase );
    }
    */
    return S_OK;
} // CDirectXHTMLCallback::OnInvalidate


//****************************************************************************
//****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\image\xformclrimg.cpp ===
/*******************************************************************************

Copyright (c) 1995-98 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

#include "privinc/imagei.h"
#include "privinc/xformi.h"

class TransformColorImage : public AttributedImage {

  public:
    TransformColorImage(Image *image, Transform3 *xf);

    void Render(GenericDevice& dev);

    #if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "(TransformColorImage @ " << (void *)this << ")";
    }   
    #endif

  private:
    Transform3 *_colorTransform;
};


TransformColorImage::TransformColorImage(
    Image *image, Transform3 *xf) : AttributedImage(image)
{
    _colorTransform = xf;
}


void TransformColorImage::Render(GenericDevice& dev)
{
}


Image *TransformColorRGBImage(Image *image, Transform3 *xf)
{
    return NEW TransformColorImage(image, xf);
}


/*
// FUTURE: 
Image *ConstructXfClrHSLImg(Image *image, Transform3 *hslxf)
{
    // change the hsl color xf to an rgb color xf
    Tranform3 *rgbxf = ConvertHSLTransformToRGBTransform( hslxf );
    return NEW TransformColorImage(image, rgbxf);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\arith.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of static arithmetic functions

*******************************************************************************/

#include "headers.h"
#include "appelles/arith.h"
#include "appelles/axaprims.h"

#define ASSOC_OP2(ourFunc, op) \
  AxANumber *ourFunc(AxANumber *a, AxANumber *b) \
  { return RealToNumber(NumberToReal(a) op NumberToReal(b)); }

#define ASSOC_BOOL_OP2(ourFunc, op)                    \
  AxABoolean *ourFunc(AxANumber *a, AxANumber *b) {                 \
     int result = NumberToReal(a) op NumberToReal(b);                            \
     AxABoolean *retval = result ? truePtr : falsePtr;    \
/*     printf("%8.5f %s %8.5f - Result %d, Retval 0x%x\n", *a, "op", *b, result, retval); */\
     return retval;  \
  }

#define ASSOC_FUNC1(ourFunc, mathFunc) \
  AxANumber *ourFunc(AxANumber *v) \
  { return RealToNumber(mathFunc(NumberToReal(v))); }

#define ASSOC_FUNC2(ourFunc, mathFunc) \
  AxANumber *ourFunc(AxANumber *u, AxANumber *v) \
  { return RealToNumber(mathFunc(NumberToReal(u), NumberToReal(v))); }


// Prefix operators
AxANumber *RealNegate(AxANumber *a) { return RealToNumber(- NumberToReal(a)); }
AxANumber *RealPositive(AxANumber *a) { return a; }

// Binary operators
ASSOC_OP2(RealMultiply, *  )
ASSOC_OP2(RealDivide,   /  )
ASSOC_OP2(RealAdd,      +  )
ASSOC_OP2(RealSubtract, -  )

ASSOC_BOOL_OP2(RealLT,       <  )
ASSOC_BOOL_OP2(RealLTE,      <= )
ASSOC_BOOL_OP2(RealGT,       >  )
ASSOC_BOOL_OP2(RealGTE,      >= )
ASSOC_BOOL_OP2(RealEQ,       == )
ASSOC_BOOL_OP2(RealNE,       != )

// Unary functions
ASSOC_FUNC1(RealAbs,      fabs)
ASSOC_FUNC1(RealSqrt,     sqrt)
ASSOC_FUNC1(RealFloor,    floor)
ASSOC_FUNC1(RealCeiling,  ceil)
ASSOC_FUNC1(RealAsin,     asin)
ASSOC_FUNC1(RealAcos,     acos)
ASSOC_FUNC1(RealAtan,     atan)
ASSOC_FUNC1(RealSin,      sin)
ASSOC_FUNC1(RealCos,      cos)
ASSOC_FUNC1(RealTan,      tan)
ASSOC_FUNC1(RealExp,      exp)
ASSOC_FUNC1(RealLn,       log)
ASSOC_FUNC1(RealLog10,    log10)

AxANumber *RealRadToDeg(AxANumber *rad)
{ return RealToNumber(NumberToReal(rad) / degToRad); }
AxANumber *RealDegToRad(AxANumber *deg)
{ return RealToNumber(NumberToReal(deg) * degToRad); }

AxANumber *RealRound(AxANumber *val)
{
    // Round is just floor(x+0.5)
    return RealToNumber(floor(NumberToReal(val) + 0.5));
}

// This special version of fmod works around an occasional floating
// point glitch where an operation like fmod(1840.0, 2.0) returns
// 1.9999999998.  Check for these sorts of epsilons and correct for
// them.   Our threshold is inexact, but better than not dealing with
// the problem.
static double
myFMod(double a, double b)
{
    double result = fmod(a, b);

    if (fabs(result - b) < 0.000000001) {
        result = 0.0;
    }

    return result;
}

// Binary functions
ASSOC_FUNC2(RealPower,   pow)
ASSOC_FUNC2(RealModulus, myFMod)
ASSOC_FUNC2(RealAtan2,   atan2)

// Random number functions.
// TODO: This relies on the constant folding mechanism for this to
// work.  Should really be a behavior.

class RandomSequence : public AxAValueObj {
  public:
    RandomSequence(Real seed);
    Real NextInSequence();
    Real GetRand(Real time);

    virtual DXMTypeInfo GetTypeInfo() { return AxANumberType; }

  protected:
    typedef map< Real, Real, less<Real> > RQueue;
    unsigned long _seed;
    RQueue* _randQ;
};

RandomSequence::RandomSequence(Real realSeed)
{
    // Just take the bit pattern of the input and treat it as an
    // unsigned long seed.
    Assert(sizeof(float) == sizeof(unsigned long));
    float floatSeed = (float)realSeed;
    _seed = *(unsigned long *)&floatSeed;

    // Create an offset to add to the initial seed.  This offset is
    // created once per executable invocation, and its purpose is to
    // prevent the same random number sequences from being generated
    // each time Appelles is started.  It more or less guarantees
    // randomness because the performance counter is a very high
    // resolution clock.
    static unsigned long perExecutableOffset = 0;
    if (perExecutableOffset == 0) {
        LARGE_INTEGER lpc;
        QueryPerformanceCounter(&lpc);
        perExecutableOffset = (unsigned long)lpc.LowPart;
    }

    _seed += perExecutableOffset;

    _randQ = NEW RQueue;

    GetHeapOnTopOfStack().RegisterDynamicDeleter
        (NEW DynamicPtrDeleter<RQueue>(_randQ));

}

Real
RandomSequence::NextInSequence()
{
    // Taken from the C-runtime rand() function distributed as source
    // with MS Visual C++ 4.0.
    _seed = _seed * 214013L + 2531011L;

    const unsigned int MAXVAL = 0x7fff;

    // This is between 0 and MAXVAL
    unsigned int newVal = (_seed >> 16) & MAXVAL;

    // Normalize to 0 to 1.
    return (Real)(newVal) / (Real)(MAXVAL);
}

static const Real CUTOFF = 0.5;

Real
RandomSequence::GetRand(Real time)
{
    // Cut off old random numbers, clean up.
    _randQ->erase(_randQ->begin(), _randQ->lower_bound(time - CUTOFF));

    // See if already there.
    RQueue::iterator i = _randQ->find(time);

    if (i != _randQ->end()) {
        return (*i).second;
    } else {
        Real next = NextInSequence();
        (*_randQ)[time] = next;
        return next;
    }
}

AxAValue RandomNumSequence(double seed)
{ return NEW RandomSequence(seed); }

AxAValue
PRIVRandomNumSequence(AxANumber *s)
{
    Real seed = NumberToReal(s);
    RandomSequence *rs = NEW RandomSequence(seed);
    
    return rs;
}

AxANumber *
PRIVRandomNumSampler(AxAValue seq, AxANumber *localTime)
{
    RandomSequence *randSeq = (RandomSequence *)seq;
    //Real result = randSeq->NextInSequence();
    Real result = randSeq->GetRand(ValNumber(localTime));

    return RealToNumber(result);
}

/*
  Formula from Salim
  The formula is:  f(t,s) = (t - 1)((2t-1)*s*t - 1)
  t is in [0,1]
  s is in [-1, 1] and Colin called it sharpness, 
  at s=0 we get linear rate
  for s in ]0,1] we get increasingly more slow-in-slow-out
  for s in [-1,0[ we get fast-in-fast-out

  to go from point A to point B, the linear formula is:
  C = B + (A-B)*t

  For slow-in-slow-out use C.substituteTime(f(t/duration, s))
  for a given sharpness s.

  f has the property that f(0,s) = 1 [at A], 
  f(1/2,s) = 1/2 [mid way], and 
  f(1,s)=0 [at B]
*/

AxANumber *Interpolate(AxANumber *from,
                       AxANumber *to,
                       AxANumber *duration,
                       AxANumber *time)
{
    Real d = ValNumber(duration);
    Real nTo = ValNumber(to);
    Real t = ValNumber(time);
    Real nFrom = ValNumber(from);

    if (d > 0.0) {
        t = t / d;
        t = CLAMP(t, 0, 1);
        return NEW AxANumber(nFrom + (nTo - nFrom) * t);
    } else
        return NEW AxANumber(t >= 0 ? nTo : nFrom);
}

AxANumber *SlowInSlowOut(AxANumber *from,
                         AxANumber *to,
                         AxANumber *duration,
                         AxANumber *sharpness,
                         AxANumber *time)
{
    Real d = ValNumber(duration);
    Real nTo = ValNumber(to);
    Real t = ValNumber(time);
    Real nFrom = ValNumber(from);

    if (d > 0.0) {
        Real s = ValNumber(sharpness);
        t = t / ValNumber(duration);
        s = CLAMP(s, -1, 1);
        t = CLAMP(t, 0, 1);
        Real f = (t - 1) * (((2 * t) - 1) * s * t - 1);

        return NEW AxANumber(nTo + (nFrom - nTo) * f);
    } else
        return NEW AxANumber(t >= 0 ? nTo : nFrom);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\axapair.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implement pair primitives

*******************************************************************************/


#include "headers.h"
#include "backend/values.h"
#include "privinc/except.h"
#include "appelles/axapair.h"

AxAValue FirstVal (AxAPair * p)
{
    return p->Left () ;
}

AxAValue SecondVal (AxAPair * p)
{
    return p->Right () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\axachstr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of the string primitive functions

*******************************************************************************/

#include <headers.h>
#include <string.h>
#include "privinc/except.h"
#include "privinc/storeobj.h"
#include "backend/values.h"
#include "backend/bvr.h"
#include "appelles/axaprims.h"
#include "appelles/axachstr.h"

// *************************************
// * string primitives 
// *************************************

AxAString * Concat(AxAString *s1, AxAString *s2)
{
    int n = lstrlenW(s1->GetStr()) + lstrlenW(s2->GetStr()) + 1;
    WideString str = (WideString) AllocateFromStore(sizeof(WCHAR) * n);

    StrCpyW(str, s1->GetStr());
    StrCatW(str, s2->GetStr());

    return NEW AxAString(str,false);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\4x4xform.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

    Transform-generating functions and transform manipulation.
*******************************************************************************/

#include "headers.h"
#include "appelles/common.h"

#include "privinc/matutil.h"
#include "privinc/xformi.h"
#include "privinc/vec3i.h"
#include "privinc/basic.h"
#include "appelles/xform.h"
#include "backend/values.h"

extern const Apu4x4Matrix apuIdentityMatrix;

    // The Xform4x4 class is just a wrapper for the Apu4x4Matrix that also
    // derives from Transform3.  It's apparently done this way so you can
    // operate on the Apu4x4Matrix without bringing along the full Transform3
    // class.

class Xform4x4 : public Transform3
{
  public:
    Apu4x4Matrix matrix;

    Xform4x4 () {}
    Xform4x4 (const Apu4x4Matrix& _matrix) : matrix(_matrix) {}
    virtual const Apu4x4Matrix& Matrix ();

    virtual bool SwitchToNumbers(Transform2::Xform2Type ty,
                                 Real                  *numbers) {

        switch (ty) {
          case Transform2::Translation:
            {
                if (matrix.form != Apu4x4Matrix::TRANSLATE_E) { return false; }
            
                Real x = numbers[0];
                Real y = numbers[1];
                Real z = numbers[2];
                if (matrix.pixelMode) {
                    x = PixelToNum(x);
                    y = PixelYToNum(y);
                    z = PixelToNum(z);
                }

                ApuTranslate(x, y, z, matrix.pixelMode, matrix);
            
            }
            break;

          case Transform2::Rotation:
            {
                // Note that here we're just looking for an upper 3x3,
                // since the matrix algebra here doesn't distinguish
                // those from the more specific rotations.  This means
                // that switching a shear to a rotate will succeed,
                // where one might expect it not to...
                if (matrix.form != Apu4x4Matrix::UPPER_3X3_E) { return false; }
                
                ApuRotate(numbers[0],
                          numbers[1],
                          numbers[2],
                          numbers[3] * degToRad,
                          matrix);
            }
            break;

          case Transform2::Scale:
            {
                // Note that here we're just looking for an upper 3x3,
                // since the matrix algebra here doesn't distinguish
                // those from the more specific scales.  This means
                // that switching a shear to a scale will succeed,
                // where one might expect it not to...
                if (matrix.form != Apu4x4Matrix::UPPER_3X3_E) { return false; }
                
                ApuScale(numbers[0],
                         numbers[1],
                         numbers[2],
                         matrix);
            }
            break;

        }

        return true;
    }
    
};



/*****************************************************************************
The Matrix() member function of a transform just returns the matrix used in
the implementation.
*****************************************************************************/

const Apu4x4Matrix& Xform4x4::Matrix ()
{
    return matrix;
}



/*****************************************************************************
This function converts from a generalized transform to a 4x4 matrix.
*****************************************************************************/

Transform3 *Apu4x4XformImpl (const Apu4x4Matrix& m)
{
    Transform3 *newxf = NEW Xform4x4 (m);

    CHECK_MATRIX(m);

    return newxf;
}



/****************************************************************************/

Transform3 *TranslateWithMode (Real Tx, Real Ty, Real Tz, bool pixelMode)
{
    Xform4x4 *m = NEW Xform4x4 ();
    ApuTranslate (Tx, Ty, Tz, pixelMode, m->matrix);

    CHECK_MATRIX(m->matrix);

    return m;
}

Transform3 *Translate (Real Tx, Real Ty, Real Tz)
{
    return TranslateWithMode(Tx, Ty, Tz, false);
}



/****************************************************************************/

Transform3 *TranslateReal3 (AxANumber *Tx, AxANumber *Ty, AxANumber *Tz)
{
    return Translate (NumberToReal(Tx), NumberToReal(Ty), NumberToReal(Tz));
}



/****************************************************************************/

Transform3 *TranslateVector3 (Vector3Value *delta)
{
    return Translate (delta->x, delta->y, delta->z);
}



/****************************************************************************/

Transform3 *TranslatePoint3 (Point3Value *new_origin)
{
    return Translate (new_origin->x, new_origin->y, new_origin->z);
}



/****************************************************************************/

Transform3 *Scale (Real Sx, Real Sy, Real Sz)
{
    Xform4x4 *m = NEW Xform4x4 ();
    ApuScale (Sx, Sy, Sz, m->matrix);
    CHECK_MATRIX(m->matrix);
    return m;
}



/****************************************************************************/

Transform3 *ScaleReal3 (AxANumber *x, AxANumber *y, AxANumber *z)
{
    return Scale (NumberToReal(x), NumberToReal(y), NumberToReal(z));
}



/****************************************************************************/

Transform3 *ScaleVector3 (Vector3Value *V)
{
    return Scale (V->x, V->y, V->z);
}



/****************************************************************************/

Transform3 *Scale3UniformDouble (Real n)
{
    return Scale (n, n, n);
}

Transform3 *Scale3UniformNumber (AxANumber *s)
{
    return (Scale3UniformDouble(NumberToReal (s)));
}



/*****************************************************************************
This function generates a transform that rotates points around the axis
specified by the three real values.  Since we're working in a left-hand
coordinate system, this means that rotations are clockwise if the vector
going from the origin to point <x,y,z> is poking us in the eye.  The angle
is assumed to be specified in radians.
*****************************************************************************/

Transform3 *RotateXyz (Real radians, Real x, Real y, Real z)
{
    Xform4x4 *m = NEW Xform4x4();
    ApuRotate (radians, x, y, z, m->matrix);

    CHECK_MATRIX(m->matrix);

    return m;
}



/*****************************************************************************
This function generates a rotation just as Rotate(angle,x,y,z), except that
the rotation axis is specified by a Vector3 *parameter.  Again, angles are
assumed to be specified in radians.
*****************************************************************************/

Transform3 *RotateAxis (Vector3Value *axis, Real radians)
{
    Xform4x4 *m = NEW Xform4x4();

    if (axis == xVector3)
        ApuRotateX (radians, m->matrix);
    else if (axis == yVector3)
        ApuRotateY (radians, m->matrix);
    else if (axis == zVector3)
        ApuRotateZ (radians, m->matrix);
    else
        ApuRotate (radians, axis->x,axis->y,axis->z, m->matrix);

    CHECK_MATRIX(m->matrix);

    return m;
}

Transform3 *RotateAxisReal (Vector3Value *axis, AxANumber *radians)
{   Real d = NumberToReal(radians);
    return(RotateAxis(axis,d));
}


/*****************************************************************************
The following three functions generate rotations about the X, Y & Z axes.
*****************************************************************************/

Transform3 *RotateX (Real radians)
{
    Xform4x4 *m = NEW Xform4x4();
    ApuRotateX (radians, m->matrix);
    CHECK_MATRIX(m->matrix);
    return m;
}

Transform3 *RotateY (Real radians)
{
    Xform4x4 *m = NEW Xform4x4();
    ApuRotateY (radians, m->matrix);
    CHECK_MATRIX(m->matrix);
    return m;
}

Transform3 *RotateZ (Real radians)
{
    Xform4x4 *m = NEW Xform4x4();
    ApuRotateZ (radians, m->matrix);
    CHECK_MATRIX(m->matrix);
    return m;
}



/*****************************************************************************
The following functions create shear transforms.  The parameters (a-f)
correspond to the following:
                                   Y
                                   |
    +-          -+                 +-c
    | 1  c  e  0 |                /|     a
    | a  1  f  0 |               d |     |
    | b  d  1  0 |                 +-----+-- X
    | 0  0  0  1 |              f /     /
    +-          -+              |/     b
                                +-e
                               /
                              Z
*****************************************************************************/

Transform3 *XShear3Double (Real a, Real b)
{
    Xform4x4 *m = NEW Xform4x4();
    ApuShear (a,b, 0,0, 0,0, m->matrix);
    CHECK_MATRIX(m->matrix);
    return m;
}

Transform3 *XShear3Number (AxANumber *a, AxANumber *b)
{   return (XShear3Double(NumberToReal(a),NumberToReal(b)));
}

Transform3 *YShear3Double (Real c, Real d)
{
    Xform4x4 *m = NEW Xform4x4();
    ApuShear (0,0, c,d, 0,0, m->matrix);
    CHECK_MATRIX(m->matrix);
    return m;
}

Transform3 *YShear3Number (AxANumber *c, AxANumber *d)
{   return (YShear3Double(NumberToReal(c),NumberToReal(d)));
}


Transform3 *ZShear3Double (Real e, Real f)
{
    Xform4x4 *m = NEW Xform4x4();
    ApuShear (0,0, 0,0, e,f, m->matrix);
    CHECK_MATRIX(m->matrix);
    return m;
}

Transform3 *ZShear3Number (AxANumber *e, AxANumber *f)
{   return (ZShear3Double(NumberToReal(e),NumberToReal(f)));
}


/*****************************************************************************
This function creates a Transform3 from the 16 matrix elements, top to bottom,
left to right.
*****************************************************************************/

Transform3 *Transform3Matrix16 (
    Real m00, Real m01, Real m02, Real m03,
    Real m10, Real m11, Real m12, Real m13,
    Real m20, Real m21, Real m22, Real m23,
    Real m30, Real m31, Real m32, Real m33)
{
    Xform4x4 *xf44 = NEW Xform4x4 ();
    Apu4x4MatrixArray_t &matrix = xf44->matrix.m;

    matrix[0][0]=m00; matrix[0][1]=m01; matrix[0][2]=m02; matrix[0][3]=m03;
    matrix[1][0]=m10; matrix[1][1]=m11; matrix[1][2]=m12; matrix[1][3]=m13;
    matrix[2][0]=m20; matrix[2][1]=m21; matrix[2][2]=m22; matrix[2][3]=m23;
    matrix[3][0]=m30; matrix[3][1]=m31; matrix[3][2]=m32; matrix[3][3]=m33;

    xf44->matrix.SetType();    // Auto-Characterize Matrix Type

    CHECK_MATRIX (xf44->Matrix());

    return xf44;
}



/*****************************************************************************
This function generates a transform from the 4x4 matrix specified in the 16
paramters.  Parameters are specified left to right, then top to bottom.
*****************************************************************************/

Transform3 *PRIVMatrixTransform4x4 (
    AxANumber *a00,   AxANumber *a01,   AxANumber *a02,   AxANumber *a03,
    AxANumber *a10,   AxANumber *a11,   AxANumber *a12,   AxANumber *a13,
    AxANumber *a20,   AxANumber *a21,   AxANumber *a22,   AxANumber *a23,
    AxANumber *a30,   AxANumber *a31,   AxANumber *a32,   AxANumber *a33)
{
    return Transform3Matrix16
           (   NumberToReal(a00), NumberToReal(a01),
               NumberToReal(a02), NumberToReal(a03),

               NumberToReal(a10), NumberToReal(a11),
               NumberToReal(a12), NumberToReal(a13),

               NumberToReal(a20), NumberToReal(a21),
               NumberToReal(a22), NumberToReal(a23),

               NumberToReal(a30), NumberToReal(a31),
               NumberToReal(a32), NumberToReal(a33)
           );
}

Transform3 *MatrixTransform4x4 (AxAArray *a)
{
    if (a->Length() != 16)
        RaiseException_UserError(E_FAIL, IDS_ERR_MATRIX_NUM_ELEMENTS);

    return Transform3Matrix16
           (   ValNumber ((*a)[ 0]), ValNumber ((*a)[ 1]),
               ValNumber ((*a)[ 2]), ValNumber ((*a)[ 3]),

               ValNumber ((*a)[ 4]), ValNumber ((*a)[ 5]),
               ValNumber ((*a)[ 6]), ValNumber ((*a)[ 7]),

               ValNumber ((*a)[ 8]), ValNumber ((*a)[ 9]),
               ValNumber ((*a)[10]), ValNumber ((*a)[11]),

               ValNumber ((*a)[12]), ValNumber ((*a)[13]),
               ValNumber ((*a)[14]), ValNumber ((*a)[15])
           );
}



/*****************************************************************************
This function creates a 4x4 transform from the given basis vectors and origin.
*****************************************************************************/

Transform3 *TransformBasis (
    Point3Value  *origin,
    Vector3Value *basisX,
    Vector3Value *basisY,
    Vector3Value *basisZ)
{
    Xform4x4 *xf44 = NEW Xform4x4 ();
    Apu4x4MatrixArray_t &matrix = xf44->matrix.m;

    matrix[0][0] = basisX->x;
    matrix[1][0] = basisX->y;
    matrix[2][0] = basisX->z;
    matrix[3][0] = 0;

    matrix[0][1] = basisY->x;
    matrix[1][1] = basisY->y;
    matrix[2][1] = basisY->z;
    matrix[3][1] = 0;

    matrix[0][2] = basisZ->x;
    matrix[1][2] = basisZ->y;
    matrix[2][2] = basisZ->z;
    matrix[3][2] = 0;

    matrix[0][3] = origin->x;
    matrix[1][3] = origin->y;
    matrix[2][3] = origin->z;
    matrix[3][3] = 1;

    xf44->matrix.SetType();    // Auto-Characterize Matrix Type

    CHECK_MATRIX (xf44->Matrix());

    return xf44;
}



/*****************************************************************************
This transformation is very useful for the common operation of translate
to origin, apply transformation, translate back.  The 'center' parameter
describes the point that is to be the virtual origin for the 'xform'.
*****************************************************************************/

#if 0   // UNUSED
Transform3 *DisplacedXform (Point3Value *center, Transform3 *xform)
{
    // xlt(center) o xform o xlt(-center)
    return
        TimesXformXform(TranslateVector3(MinusPoint3Point3(center,
                                                           origin3)),
           TimesXformXform(xform,
             TranslateVector3(MinusPoint3Point3(origin3, center))));
}
#endif



/*****************************************************************************
This transform returns the matrix associated with the specified Look-At-From
transform.  The three parameters are the position of the object, the target of
interest, and a vector that orients the "up" direction of the object.  Prior
to applying this transform, the object should be located at the origin, aimed
in the -Z direction, with +Y up.
*****************************************************************************/

Transform3 *LookAtFrom (
    Point3Value  *target,     // Target Point, or Point Of Interest
    Point3Value  *position,   // Position of the Eye/Camera
    Vector3Value *up)         // "Up" Direction of Camera
{
    // The object begins aimed in the -Z direction, and we want to compute the
    // NEW object Z axis (aim).  Keep in mind that since this corresponds to
    // an object pointing in -Z, the aim is actually negated.

    Vector3Value aim = (*position - *target);

    // If the aim is a zero vector, then the target and position points are
    // coincident, so we'll just use [0 0 1] as the aim vector.

    if (aim == *zeroVector3)
        aim = *zVector3;
    else
        aim.Normalize();

    // 'side' is the unit vector pointing off to the object's right.  If the up
    // vector and the aim are parallel, then we'll pick an arbitrary side
    // vector that is perpendicular to the aim.

    Vector3Value side = Cross (*up, aim);

    if (side != *zeroVector3)
        side.Normalize();

    else if (aim.x != 0)
    {   side.Set (aim.y, -aim.x, 0);
        side.Normalize();
    }

    else
    {   side = *xVector3;
    }

    // Calculate 'objup', the object's up vector for this orientation.  We
    // don't need to normalize here because 'aim' and 'side' are both unit
    // perpendicular vectors.

    Vector3Value objup = Cross (aim, side);

    // Given these three orthogonal unit vectors, we now construct the matrix
    // that describes the transformation to the specified camera position and
    // orientation.

    return Transform3Matrix16
           (   side.x, objup.x, aim.x, position->x,
               side.y, objup.y, aim.y, position->y,
               side.z, objup.z, aim.z, position->z,
               0,      0,       0,     1
           );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\bbox2i.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Definitions of 2D axis-aligned bounding box functions.

*******************************************************************************/

#include "headers.h"
#include "appelles/bbox2.h"
#include "privinc/bbox2i.h"
#include "privinc/vec2i.h"
#include "privinc/xform2i.h"



// This function returns the point at the center of the bounding box.  The origin
// is the center of the universe.  I don't think it makes sense, but as far as
// this function is implemented, the origin is also the center of null.

const Point2 Bbox2::Center(void) const
{
    Real Cx, Cy;

    if ((*this == NullBbox2) || (*this == UniverseBbox2)) {
        Cx = 0.0;
        Cy = 0.0;
    } else {
        Cx = (min.x + max.x) / 2;
        Cy = (min.y + max.y) / 2;
    }

    return Point2(Cx, Cy);
}


/*****************************************************************************
This function returns the intersection of the two bounding boxes.  If the
two boxes don't intersect, this function returns the null box.  Note that
the intersection between a box and the universe box is the original box,
the intersection between the null box and a box is the null box, and the
intersection between the null box and the universe is the null box.
*****************************************************************************/

const Bbox2 IntersectBbox2Bbox2(const Bbox2 &b1, const Bbox2 &b2)
{
    if((b1 == NullBbox2) || (b2 == NullBbox2))
        return NullBbox2;

    if (b1.max.x < b2.min.x || b1.max.y < b2.min.y ||
        b2.max.x < b1.min.x || b2.max.y < b1.min.y)
       return NullBbox2;

    Real xmin = MAX (b1.min.x, b2.min.x);
    Real ymin = MAX (b1.min.y, b2.min.y);
    Real xmax = MIN (b1.max.x, b2.max.x);
    Real ymax = MIN (b1.max.y, b2.max.y);

    return Bbox2(xmin, ymin, xmax, ymax);
}


Bbox2Value* IntersectBbox2Bbox2(Bbox2Value *b1, Bbox2Value *b2)
{
    if((b1 == nullBbox2) || (b2 == nullBbox2))
        return nullBbox2;

    if (b1->max.x < b2->min.x || b1->max.y < b2->min.y ||
        b2->max.x < b1->min.x || b2->max.y < b1->min.y)
       return nullBbox2;

    Real xmin = MAX (b1->min.x, b2->min.x);
    Real ymin = MAX (b1->min.y, b2->min.y);
    Real xmax = MIN (b1->max.x, b2->max.x);
    Real ymax = MIN (b1->max.y, b2->max.y);

    return NEW Bbox2Value(xmin, ymin, xmax, ymax);
}


/*****************************************************************************
This function returns the union of the two bounding boxes.  The union of
any box with null is the original box, and the union of anything with the
universe is the universe.
*****************************************************************************/

const Bbox2 UnionBbox2Bbox2(const Bbox2 &b1, const Bbox2 &b2)
{
    if(b1 == NullBbox2)
        return b2;
    if(b2 == NullBbox2)
        return b1;

    Real xmin = MIN (b1.min.x, b2.min.x);
    Real ymin = MIN (b1.min.y, b2.min.y);
    Real xmax = MAX (b1.max.x, b2.max.x);
    Real ymax = MAX (b1.max.y, b2.max.y);

    return Bbox2(xmin, ymin, xmax, ymax);
}



/*****************************************************************************
Transform the bounding box, and get the NEW axis-aligned bounding box.
*****************************************************************************/

const Bbox2 TransformBbox2(Transform2 *xf, const Bbox2 &box)
{
    // Check fringe cases first

    if ((box == UniverseBbox2) || (box == NullBbox2) || (xf == identityTransform2))
        return box;
    
    // Just transform the points.
    // This will result in a transformed box that
    // is not necessarily axis aligned.

    Point2 ptbl = TransformPoint2(xf, box.min);
    Point2 pttr = TransformPoint2(xf, box.max);

    // optimize: ONLY rotate needs all this work...
    // create the topleft and bottom right points also..
    Point2 pttl = TransformPoint2(xf, Point2(box.min.x, box.max.y));
    Point2 ptbr = TransformPoint2(xf, Point2(box.max.x, box.min.y));
    
    // Find the component mins and maxs of these two points, and these will be
    // put together to form the tightest axis-aligned bbox that surrounds the
    // non-axis aligned one.

    Real xmin = MIN (ptbl.x, MIN(pttr.x, MIN(pttl.x, ptbr.x)));
    Real ymin = MIN (ptbl.y, MIN(pttr.y, MIN(pttl.y, ptbr.y)));
    Real xmax = MAX (ptbl.x, MAX(pttr.x, MAX(pttl.x, ptbr.x)));
    Real ymax = MAX (ptbl.y, MAX(pttr.y, MAX(pttl.y, ptbr.y)));

    return Bbox2(xmin,ymin,xmax,ymax);
}

Bbox2Value* TransformBbox2(Transform2 *xf, Bbox2Value *box)
{
    // Check fringe cases first

    if ((box == universeBbox2) || (box == nullBbox2) || (xf == identityTransform2))
        return box;
    
    // Just transform the points.
    // This will result in a transformed box that
    // is not necessarily axis aligned.

    Point2 ptbl = TransformPoint2(xf, box->min);
    Point2 pttr = TransformPoint2(xf, box->max);

    // optimize: ONLY rotate needs all this work...
    // create the topleft and bottom right points also..
    Point2 pttl = TransformPoint2(xf, Point2(box->min.x, box->max.y));
    Point2 ptbr = TransformPoint2(xf, Point2(box->max.x, box->min.y));
    
    // Find the component mins and maxs of these two points, and these will be
    // put together to form the tightest axis-aligned bbox that surrounds the
    // non-axis aligned one.

    Real xmin = MIN (ptbl.x, MIN(pttr.x, MIN(pttl.x, ptbr.x)));
    Real ymin = MIN (ptbl.y, MIN(pttr.y, MIN(pttl.y, ptbr.y)));
    Real xmax = MAX (ptbl.x, MAX(pttr.x, MAX(pttl.x, ptbr.x)));
    Real ymax = MAX (ptbl.y, MAX(pttr.y, MAX(pttl.y, ptbr.y)));

    return NEW Bbox2Value(xmin,ymin,xmax,ymax);
}



/****************************************************************************/


Point2Value* MaxBbox2(Bbox2Value *box)
{   
    return NEW Point2Value(box->max.x,box->max.y);
}


Point2Value* MinBbox2(Bbox2Value *box)
{   
    return NEW Point2Value(box->min.x,box->min.y);
}


/***************************/
/***  Value Definitions  ***/
/***************************/

Bbox2Value *nullBbox2     = NULL;
Bbox2Value *unitBbox2     = NULL;
Bbox2Value *universeBbox2 = NULL;


/*****************************************************************************
This routine performs the intialization of static Bbox2 values.
*****************************************************************************/

void InitializeModule_Bbox2()
{
    // NOTE:  The following two definitions rely on the HUGE_VAL macro, which
    // effectively returns arbitrary-precision infinity.

    // The universe box goes from -infinity to +infinity.  It contains all
    // points and all other boxes.

    universeBbox2 = NEW Bbox2Value (-HUGE_VAL, -HUGE_VAL,
                                     HUGE_VAL,  HUGE_VAL);

    // The null box can be thought of as the universe turned inside out.  It
    // runs from a minimum of +inifinity to a maximum of -infinity.  It turns
    // out that these definitions for null and universe yield sane answers on
    // all the following operations, so you don't need to test for these values
    // explicitly.

    nullBbox2 = NEW Bbox2Value ( HUGE_VAL,  HUGE_VAL,
                                -HUGE_VAL, -HUGE_VAL);


    // The unit bbox spans (0,0) to (1,1).

    unitBbox2 = NEW Bbox2Value (0,0, 1,1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\bbox3i.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    3D axis aligned bounding box implementation

*******************************************************************************/

#include "headers.h"
#include <float.h>
#include <d3drmdef.h>
#include "appelles/vec3.h"
#include "privinc/xformi.h"
#include "privinc/vecutil.h"
#include "privinc/matutil.h"
#include "privinc/vec3i.h"
#include "privinc/bbox3i.h"


    /***************************/
    /***  Value Definitions  ***/
    /***************************/

Bbox3 *universeBbox3 = NULL;
Bbox3 *nullBbox3 = NULL;



/*****************************************************************************
Bbox3 Constructors
*****************************************************************************/

Bbox3::Bbox3 (Real xmin, Real ymin, Real zmin, Real xmax, Real ymax, Real zmax)
{   min.Set (xmin, ymin, zmin);
    max.Set (xmax, ymax, zmax);
}

Bbox3::Bbox3 (Point3Value &pmin, Point3Value &pmax)
{   min = pmin;
    max = pmax;
}

Bbox3::Bbox3 (void)
{   min.Set ( HUGE_VAL,  HUGE_VAL,  HUGE_VAL);
    max.Set (-HUGE_VAL, -HUGE_VAL, -HUGE_VAL);
}

Bbox3::Bbox3 (D3DRMBOX &d3dbox)
{
    min.Set (d3dbox.min.x, d3dbox.min.y, d3dbox.min.z);
    max.Set (d3dbox.max.x, d3dbox.max.y, d3dbox.max.z);
}



#if 0 // Currently Unused
/*****************************************************************************
This function returns the intersection of the two bounding boxes.  If the
two boxes don't intersect, this function returns the null box.  Note that
the intersection between a box and the universe box is the original box,
the intersection between the null box and a box is the null box, and the
intersection between the null box and the universe is the null box.
*****************************************************************************/

Bbox3 *Intersection (Bbox3 &b1, Bbox3 &b2)
{
    return NEW Bbox3 (
        MAX (b1.min.x, b2.min.x),
        MAX (b1.min.y, b2.min.y),
        MAX (b1.min.z, b2.min.z),
        MIN (b1.max.x, b2.max.x),
        MIN (b1.max.y, b2.max.y),
        MIN (b1.max.z, b2.max.z)
    );
}
#endif



/*****************************************************************************
This function returns the union of the two bounding boxes.  The union of
any box with null is the original box, and the union of anything with the
universe is the universe.
*****************************************************************************/

Bbox3 *Union (Bbox3 &b1, Bbox3 &b2)
{
    Real xmin = MIN (b1.min.x, b2.min.x);
    Real ymin = MIN (b1.min.y, b2.min.y);
    Real zmin = MIN (b1.min.z, b2.min.z);

    Real xmax = MAX (b1.max.x, b2.max.x);
    Real ymax = MAX (b1.max.y, b2.max.y);
    Real zmax = MAX (b1.max.z, b2.max.z);

    return NEW Bbox3 (xmin,ymin,zmin, xmax,ymax,zmax);
}



/*****************************************************************************
This function returns the bounding box extended to include the given point.
If the bounding box is null, the result is a zero-volume box that contains the
single point P.
*****************************************************************************/

void Bbox3::Augment (Real x, Real y, Real z)
{
    if (x < min.x)  min.x = x;
    if (y < min.y)  min.y = y;
    if (z < min.z)  min.z = z;

    if (x > max.x)  max.x = x;
    if (y > max.y)  max.y = y;
    if (z > max.z)  max.z = z;
}

void Bbox3::Augment (Point3Value &p)
{
    Augment (p.x, p.y, p.z);
}



/*****************************************************************************
This function augments the bounding box to include the second bounding box.
*****************************************************************************/

void Bbox3::Augment (Bbox3 &bbox)
{
    if (bbox.min.x < min.x)  min.x = bbox.min.x;
    if (bbox.min.y < min.y)  min.y = bbox.min.y;
    if (bbox.min.z < min.z)  min.z = bbox.min.z;

    if (bbox.max.x > max.x)  max.x = bbox.max.x;
    if (bbox.max.y > max.y)  max.y = bbox.max.y;
    if (bbox.max.z > max.z)  max.z = bbox.max.z;
}


/*****************************************************************************
This function fills an array of 8 points with the bbox's corners.
*****************************************************************************/

void Bbox3::GetPoints(Point3Value *pts)
{
    pts[0].Set(min.x,min.y,min.z);
    pts[1].Set(min.x,min.y,max.z);
    pts[2].Set(min.x,max.y,min.z);
    pts[3].Set(min.x,max.y,max.z);
    pts[4].Set(max.x,min.y,min.z);
    pts[5].Set(max.x,min.y,max.z);
    pts[6].Set(max.x,max.y,min.z);
    pts[7].Set(max.x,max.y,max.z);

    return;
}


/*****************************************************************************
This function clips the bounding box against a plane.
*****************************************************************************/

ClipCode Bbox3::Clip(Plane3 &plane)
{
    Point3Value points[8];
    GetPoints(points);

    ClipCode clip = points[0].Clip(plane);
    for (int i = 1; i < 8; i++) {
        if (points[i].Clip(plane) != clip) {
            clip = CLIPCODE_STRADDLE;
            break;
        }
    }
     
    return clip;
}


/*****************************************************************************
This routine tests the equality of this bounding box with another.
*****************************************************************************/

bool Bbox3::operator== (Bbox3 &other)
{
    return (min == other.min) && (max == other.max);
}



/*****************************************************************************
Return true if the bounding box is finite in all dimensions.  Note that a null
bbox is not finite.
*****************************************************************************/

bool Bbox3::Finite (void)
{
    return _finite(min.x) && _finite(min.y) && _finite(min.z)
        && _finite(max.x) && _finite(max.y) && _finite(max.z);
}



/*****************************************************************************
Return true if the box is non-negative in all dimensions.  Zero dimensions are
considered positive.
*****************************************************************************/

bool Bbox3::Positive (void)
{
    return (min.x <= max.x) && (min.y <= max.y) && (min.z <= max.z);
}



/*****************************************************************************
This routine transforms the given bounding box, and returns the new axis-
aligned bounding box.  It uses the idea from Graphics Gems I, Jim Arvo, pp
348-350.
*****************************************************************************/

Bbox3 *TransformBbox3 (Transform3 *xform, Bbox3 *box)
{
    // Check fringe cases first

    if ((*box == *universeBbox3) || (*box == *nullBbox3))
        return box;

    // Extract the min and max coords and the transform matrix.

    Real min[3], max[3];

    min[0] = box->min.x;     max[0] = box->max.x;
    min[1] = box->min.y;     max[1] = box->max.y;
    min[2] = box->min.z;     max[2] = box->max.z;

    const Apu4x4Matrix& mat = xform->Matrix();

    // The basic idea behind the following is that each transformed coordinate
    // will have a min and a max.  Since the bounding box is merely the set of
    // vertices of all permutations of min and max for each coordinate, there's
    // a quick shortcut.  Considering a single coordinate, it's the result of
    // the dot product between the corresponding row of the transform matrix
    // and the min/max coordinate values.  To find the minimum possible value
    // for the coordinate, we seek to minimize each term of the dot product.
    // For the max value, maximize each term.  Since all permutations of min/max
    // for each coordinate exist (e.g. <Xmin,Ymax,Zmax> or <Xmax,Ymax,Zmin>),
    // we can just pick and choose for each term, rather than transforming
    // each of all permutations (all bbox vertices).

    Real newmin[3], newmax[3];

    // Loop over each coordinate:  X, Y and Z

    for (int i=0;  i < 3;  ++i)
    {
        Real Bmin = mat[i][3];    // Start with the translation component.
        Real Bmax = Bmin;

        // Loop over each term of the dot product.

        for (int j=0;  j < 3;  ++j)
        {
            Real a = mat[i][j] * min[j]; // Grab the term from the min vector
            Real b = mat[i][j] * max[j]; // Grab the term from the max vector

            // We've calculated both possible values for this term.
            // Select the min & max values to add to the min & max dot
            // dot products.

            if (a < b)
            {   Bmin += a;
                Bmax += b;
            }
            else
            {   Bmin += b;
                Bmax += a;
            }
        }

        // Done for this coordinate.  Set the new bbox min/max vector component.

        newmin[i] = Bmin;
        newmax[i] = Bmax;
    }

    return NEW Bbox3 (newmin[0], newmin[1], newmin[2],
                      newmax[0], newmax[1], newmax[2]);
}



/*****************************************************************************
This routine unabashedly stolen from Graphics Gems I, "Fast Ray-Box
Intersection", pp. 395-396, Andrew Woo.
*****************************************************************************/

static bool HitBoundingBox (
    Real minB[3],    // box
    Real maxB[3],
    Real origin[3],  // ray origin
    Real dir[3],     // ray dir
    Real coord[3])   // output hit point
{
    const int NUMDIM = 3;
    const int RIGHT  = 0;
    const int LEFT   = 1;
    const int MIDDLE = 2;

    char inside = true;
    char quadrant[NUMDIM];
    int i;
    int whichPlane;
    double maxT[NUMDIM];
    double candidatePlane[NUMDIM];

    /* Find candidate planes; this loop can be avoided if
    rays cast all from the eye(assume perpsective view) */

    for (i=0; i<NUMDIM; i++) {
        if(origin[i] < minB[i]) {
            quadrant[i] = LEFT;
            candidatePlane[i] = minB[i];
            inside = false;
        }else if (origin[i] > maxB[i]) {
            quadrant[i] = RIGHT;
            candidatePlane[i] = maxB[i];
            inside = false;
        }else   {
            quadrant[i] = MIDDLE;
        }
    }

    /* Ray origin inside bounding box */
    if(inside) {
        coord[0] = origin[0];
        coord[1] = origin[1];
        coord[2] = origin[2];
        return (true);
    }

    /* Calculate T distances to candidate planes */
    for (i = 0; i < NUMDIM; i++) {
        if (quadrant[i] != MIDDLE && dir[i] !=0.)
            maxT[i] = (candidatePlane[i]-origin[i]) / dir[i];
        else
            maxT[i] = -1.;
    }

    /* Get largest of the maxT's for final choice of intersection */
    whichPlane = 0;
    for (i = 1; i < NUMDIM; i++) {
        if (maxT[whichPlane] < maxT[i])
            whichPlane = i;
    }

    /* Check final candidate actually inside box */
    if (maxT[whichPlane] < 0.) return (false);
    for (i = 0; i < NUMDIM; i++) {
        if (whichPlane != i) {
            coord[i] = origin[i] + maxT[whichPlane] *dir[i];
            if (coord[i] < minB[i] || coord[i] > maxB[i])
                return (false);
        } else {
            coord[i] = candidatePlane[i];
        }
    }

    return (true);                          /* ray hits box */
}       



/*****************************************************************************
Get the intersection of the given ray with the axis-aligned bounding box.  If
the ray does not hit the bounding box, this function returns null, otherwise
it returns the point of intersection.
*****************************************************************************/

Point3Value *Bbox3::Intersection (Ray3 *ray)
{
    Real minB[3], maxB[3], org[3], dir[3], result[3];

    minB[0] = min.x;
    minB[1] = min.y;
    minB[2] = min.z;

    maxB[0] = max.x;
    maxB[1] = max.y;
    maxB[2] = max.z;

    org[0] = ray->Origin().x;
    org[1] = ray->Origin().y;
    org[2] = ray->Origin().z;

    dir[0] = ray->Direction().x;
    dir[1] = ray->Direction().y;
    dir[2] = ray->Direction().z;

    bool hit = HitBoundingBox(minB, maxB, org, dir, result);

    return (hit) ? NEW Point3Value (result[0],result[1],result[2]) : NULL; 
}



/****************************************************************************/

Point3Value* Bbox3::Center (void)
{
    double x = min.x + (max.x - min.x) / 2;
    double y = min.y + (max.y - min.y) / 2;
    double z = min.z + (max.z - min.z) / 2;

    Point3Value* ppt = NEW Point3Value(x,y,z);
    return ppt;
}



/****************************************************************************/

Point3Value *MinBbox3 (Bbox3 *box) { return NEW Point3Value (box->min); }
Point3Value *MaxBbox3 (Bbox3 *box) { return NEW Point3Value (box->max); }



/*****************************************************************************
This routine initializes all of the static Bbox3 values.
*****************************************************************************/

void InitializeModule_Bbox3 (void)
{
    // NOTE:  The following two definitions rely on the HUGE_VAL macro, which
    // effectively returns double-precision infinity.

    // The universe box goes from -infinity to +infinity.  It contains
    // all points and all other boxes.
    universeBbox3 = NEW Bbox3
                    (   -HUGE_VAL, -HUGE_VAL, -HUGE_VAL,
                         HUGE_VAL,  HUGE_VAL,  HUGE_VAL
                    );

    // The null box can be thought of as the universe turned inside out.
    // It runs from a minimum of +inifinity to a maximum of -infinity.  It
    // turns out that these definitions for null and universe yield sane
    // answers on all the following operations, so you don't need to
    // test for these values explicitly.

    nullBbox3 = NEW Bbox3
                (    HUGE_VAL,  HUGE_VAL,  HUGE_VAL,
                    -HUGE_VAL, -HUGE_VAL, -HUGE_VAL
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\camera.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    In this model, all cameras are expressed as a transformed default camera.
The default camera is located at the origin, with +Y pointing up, and with a
projection point located at <0,0,1>.  The resulting image is defined by the
projection to the projection point onto the Z=0 image plane.

*******************************************************************************/

#include "headers.h"

#include "appelles/common.h"
#include "appelles/camera.h"

#include "privinc/matutil.h"
#include "privinc/xformi.h"
#include "privinc/vec2i.h"
#include "privinc/vec3i.h"
#include "privinc/camerai.h"
#include "privinc/basic.h"
#include "privinc/d3dutil.h"


    // Built-in Cameras.

Camera *baseCamera = NULL;               // Base Perspective  Camera
Camera *baseOrthographicCamera = NULL;   // Base Orthographic Camera

Camera *defaultCamera = NULL;            // Same as Base Perspective  Camera
Camera *orthographicCamera = NULL;       // Same as Base Orthographic Camera



/*****************************************************************************
Construct an initial camera from a camera type.  The basis of such a camera is
the identity matrix, so that an initial camera gazes in the -Z direction, with
+Y pointing up.  The imaging plane is at Z=0, and the projection point
(relevant for perspective cameras) is located at <0, 0, 1>.
*****************************************************************************/

Camera::Camera (CameraType camtype)
    : _heap (GetHeapOnTopOfStack())
{
    _basis    = Apu4x4XformImpl (apuIdentityMatrix);
    _type     = camtype;
    _depth    = HUGE_VAL;
    _depthRes = 0;

    _camToWorld = _worldToCam = NULL;
}



/*****************************************************************************
Construct a camera by transforming another camera.  The new camera inherits
the camera type of the base camera.
*****************************************************************************/

Camera::Camera (Transform3 *xform, Camera *basecam)
    : _heap (GetHeapOnTopOfStack())
{
    Transform3 *newxform = TimesXformXform (xform, basecam->_basis);

    // Ensure that the transformed camera still has a valid basis.  We
    // currently require that the basis is orthogonal and right-handed.  If the
    // new transform does not meet these criteria, then don't apply the
    // transform - treat the transform as a no-op and use the base camera's
    // transform.

    if (!newxform->Matrix().Orthogonal())
    {
        #if _DEBUG
        {
            if (IsTagEnabled(tagMathMatrixInvalid))
            {   F3DebugBreak();
            }

            OutputDebugString ("Bad camera transform (not orthogonal).\n");
        }
        #endif

        _basis = basecam->_basis;
    }
    else if (newxform->Matrix().Determinant() <= 0)
    {
        #if _DEBUG
        {
            if (IsTagEnabled(tagMathMatrixInvalid))
            {   F3DebugBreak();
            }

            OutputDebugString ("Bad camera transform (determinant).\n");
        }
        #endif

        _basis = basecam->_basis;
    }
    else
    {
        _basis = newxform;
    }

    _type     = basecam->_type;
    _depth    = basecam->_depth;
    _depthRes = basecam->_depthRes;

    _camToWorld = _worldToCam = NULL;
}



/*****************************************************************************
Construct a copy of a camera from another camera.
*****************************************************************************/

Camera::Camera (Camera *basecam)
    : _heap (GetHeapOnTopOfStack())
{
    _basis    = basecam->_basis->Copy();
    _type     = basecam->_type;
    _depth    = basecam->_depth;
    _depthRes = basecam->_depthRes;

    _camToWorld = _worldToCam = NULL;
}



/*****************************************************************************
Returns the camera to world transform (created on the Camera's dynamic heap).
As a side-effect, this function also computes the horizontal and vertical
scale factors, and the perspective projection point in world coordinates.
*****************************************************************************/

Transform3 *Camera::CameraToWorld (void)
{
    if (!_camToWorld)
    {
        PushDynamicHeap (_heap);  // Create data on the Camera's dynamic heap.

        Apu4x4Matrix basis = _basis->Matrix();

        // We need to get the transform from world coordinates to camera
        // coordinates.  First get the origin, viewing direction and nominal up
        // vector.  Note that we negate the Ck vector since we're going from
        // right-handed (world) coordinates to left-handed (camera).

        Point3Value Corigin (basis.m[0][3], basis.m[1][3], basis.m[2][3]);

        Vector3Value Ci (basis.m[0][0], basis.m[1][0], basis.m[2][0]);
        Vector3Value Cj (basis.m[0][1], basis.m[1][1], basis.m[2][1]);
        Vector3Value Ck (basis.m[0][2], basis.m[1][2], basis.m[2][2]);

        // Find the projection point from the basis k (Z) vector and the camera
        // origin.  Note that this is in world coordinates.

        _wcProjPoint = Corigin + Ck;

        // The basis Z vector will be flipped if we're not on RM6 (RM3
        // interface), since that camera space needs to be left-handed.

        bool right_handed = (GetD3DRM3() != 0);

        if (!right_handed)
            Ck *= -1;

        Real Sz = (_type == PERSPECTIVE) ? Ck.Length() : 1.0;

        _scale.Set (Ci.Length(), Cj.Length(), Sz);

        // Create the camera-to-world transform from the three normalized
        // basis vectors and the camera location.

        Apu4x4Matrix camera_world;

        camera_world.m[0][0] = Ci.x / _scale.x;  // Normalized Basis X Vector
        camera_world.m[1][0] = Ci.y / _scale.x;
        camera_world.m[2][0] = Ci.z / _scale.x;
        camera_world.m[3][0] = 0;

        camera_world.m[0][1] = Cj.x / _scale.y;  // Normalized Basis Y Vector
        camera_world.m[1][1] = Cj.y / _scale.y;
        camera_world.m[2][1] = Cj.z / _scale.y;
        camera_world.m[3][1] = 0;

        camera_world.m[0][2] = Ck.x / _scale.z;  // Normalized Basis Z Vector
        camera_world.m[1][2] = Ck.y / _scale.z;
        camera_world.m[2][2] = Ck.z / _scale.z;
        camera_world.m[3][2] = 0;

        camera_world.m[0][3] = Corigin.x;  // Load the basis origin.
        camera_world.m[1][3] = Corigin.y;
        camera_world.m[2][3] = Corigin.z;
        camera_world.m[3][3] = 1;

        camera_world.form     = Apu4x4Matrix::AFFINE_E;   // 3x4 Matrix
        camera_world.is_rigid = 1;          // Xformed Lines Have Same Length

        _camToWorld = Apu4x4XformImpl (camera_world);

        PopDynamicHeap();
    }

    return _camToWorld;
}



/*****************************************************************************
Returns the world to camera transform (created on the Camera's dynamic heap).
As a side effect, this function also computes the camera coordinates of the
perspective projection point.
*****************************************************************************/

Transform3 *Camera::WorldToCamera (void)
{
    if (!_worldToCam)
    {
        PushDynamicHeap (_heap);

        _worldToCam = CameraToWorld()->Inverse();
        if (!_worldToCam) {
            DASetLastError (E_FAIL, IDS_ERR_GEO_SINGULAR_CAMERA);
            return NULL;
        }

        PopDynamicHeap ();

        // Calculate the projection point in camera coordinates.

        _ccProjPoint = *TransformPoint3 (_worldToCam, &_wcProjPoint);
    }

    return _worldToCam;
}



/*****************************************************************************
This function returns the near and far clipping planes for a given world-
coordinate viewing volume.  Both near and far are given as positive distances,
regardless of the underlying handedness.  The 'depthpad' value is the padding,
in Z-buffer coordinates, for the near and far clipping planes.  Both Znear and
Zfar will be clipped to the image plane.  Thus, Zfar==0 implies that the
geometry is behind the view and is invisable.  In addition to this, if the
camera has an assigned depth resolution, it will clamp the far plane so that
the given resolution is maintained.  If there is no minimum depth resolution,
then if there is an absolute depth to the camera, then far is clamped to that.
If there are no depth settings, then the far plane is set to the furthest point
of the geometry.
*****************************************************************************/

bool Camera::GetNearFar (
    Bbox3 *wcVolume,   // World-Coordinate Object Volume To View
    Real   depthpad,   // Near/Far Padding in Z-buffer Coordinates
    Real  &Znear,      // Near Clip Plane, Camera Coordinates
    Real  &Zfar)       // Far  Clip Plane, Camera Coordinates
{
    // If the camera viewing depth is zero, then nothing is visible.

    if (_depth <= 0) return false;

    // Find the bounds of the world-coordinate bounding volume in camera
    // coordinates and extract the min and max depth from that.

    Transform3 *xf = WorldToCamera();
    if (!xf) return false;
    
    Bbox3 ccBbox = *TransformBbox3 (xf, wcVolume);

    bool right_handed = (GetD3DRM3() != 0);

    if (right_handed)
    {   Znear = -ccBbox.max.z;
        Zfar  = -ccBbox.min.z;
    }
    else
    {   Znear = ccBbox.min.z;
        Zfar  = ccBbox.max.z;
    }

    // Quit if the geometry is behind us.

    if (Zfar < 0) return false;

    // Offset by the distance from the projection point to the image plane, to
    // get the true hither/yon values.  First clamp values.

    if (Znear < 0)     Znear = 0;
    Assert (Zfar >= Znear);

    Znear += _scale.z;
    Zfar  += _scale.z;

    // If a minimum depth resolution is indicated in the camera, derive the
    // far clip to meet that requirement, and clamp Zfar to that distance.

    if (_depthRes)
    {
        // We compute yon by solving the following equation for yon:
        //
        //         ZMAX - 1   ((yon - depthRes) - hither) yon
        //         -------- = -------------------------------
        //           ZMAX     (yon - hither) (yon - depthRes)
        //
        // This is using the Zbuffer equation:
        //
        //                      (Z - hither) yon
        //         Zbuffer(Z) = ----------------
        //                      (yon - hither) Z

        const Real ZMAX = (1 << 16) - 1;   // Maximum 16-bit Z-buffer Value
        Real hither = Znear;               // Hither From Projection Point
        Real t = hither + _depthRes;       // Temporary Value

        Real yon = 0.5 * (t + sqrt(t*t + 4*hither*_depthRes*(ZMAX-1)));

        if (yon < Zfar)
        {   Zfar = yon;
            depthpad = 0;           // Don't pad yon, do hard clip.
        }
    }

    // If an absolute visible depth is specified, choose the minimum of this
    // depth and the actual furthest point of the geometry we're trying to
    // view.

    else if (_depth)
    {
        if (_depth < (Zfar - Znear))
        {   Zfar = Znear + _depth;
            depthpad = 0;           // Don't pad yon, do hard clip.
        }
    }

    // If the volume is to be depth-padded in Z, move out the near and far
    // planes to 'depthpad' units in Z space.

    if (depthpad > 0)
    {
        double min = Znear;
        double max = Zfar;

        Real s = min * max * (2*depthpad - 1);
        Real t = depthpad * (min + max);

        Znear = s / (t-max);
        Zfar  = s / (t-min);

        if (Znear > min) Znear = min;   // Fix garbage values.
        if (Zfar  < max) Zfar  = max;
    }

    Assert (Znear > 0);

    return true;
}



/*****************************************************************************
Returns the perspective projection point of the camera in world coordinates.
*****************************************************************************/

Point3Value Camera::WCProjPoint (void)
{
    // _wcProjPoint is set as a side-effect of the creation of the camera-
    // to-world transform.

    CameraToWorld();

    return _wcProjPoint;
}



/*****************************************************************************
Return the perspective projection point of the camera in camera coordinates.
*****************************************************************************/

Point3Value Camera::CCProjPoint (void)
{
    // The camera basis scaling factor is computed as a side effect of the
    // camera-to-world transform creation.

    CameraToWorld();

    bool right_handed = (GetD3DRM3() != 0);

    if (right_handed)
        _ccProjPoint.Set (0, 0,  _scale.z);
    else
        _ccProjPoint.Set (0, 0, -_scale.z);

    return _ccProjPoint;
}



/*****************************************************************************
Returns the scale factors of the camera view.  Each of the given addresses
may be nil.
*****************************************************************************/

void Camera::GetScale (Real *x, Real *y, Real *z)
{
    // The camera basis scaling factor is computed as a side effect of the
    // camera-to-world transform creation.

    CameraToWorld();

    if (x) *x = _scale.x;
    if (y) *y = _scale.y;
    if (z) *z = _scale.z;
}



/*****************************************************************************
This function returns a ray from the point on the image plane into the visible
space.  The returned ray originates from the pick point on the image plane,
and is unnormalized.
*****************************************************************************/

Ray3 *Camera::GetPickRay (Point2Value *imagePoint)
{
    // Get the location of the image point in camera coordinates.

    Point3Value pickPt (imagePoint->x, imagePoint->y, 0);
    pickPt.Transform (_basis);     // World Coord Camera Image-Plane Point

    Vector3Value direction;

    // If this is a perspective camera, then the direction of the pick ray is
    // from the world-coordinate projection point to the world-coordinate pick
    // point.  If this is an orthographic camera, then the direction is the
    // direction of the camera's -Z axis.

    if (_type == PERSPECTIVE)
        direction = pickPt - WCProjPoint();
    else
    {   Apu4x4Matrix basis = _basis->Matrix();
        direction = Vector3Value (-basis.m[0][2], -basis.m[1][2], -basis.m[2][2]);
    }

    return NEW Ray3 (pickPt, direction);
}



/*****************************************************************************
This function returns the projection of the world-coordinate point onto the
camera's image plane.
*****************************************************************************/

Point2Value *Camera::Project (Point3Value *world_point)
{
    Transform3 *xf = WorldToCamera();

    // If the transform is null, then the camera basis is non-invertible and
    // hence singular.  Thus, any arbitrary point is valid, and we return the
    // origin.

    if (!xf) return origin2;
    
    Point3Value Q = *TransformPoint3 (xf, world_point);

    if (_type == ORTHOGRAPHIC)
        return NEW Point2Value (Q.x/_scale.x, Q.y/_scale.y);
    else
    {
        Point3Value P = CCProjPoint();

        Real t = P.z / (P.z - Q.z);

        return NEW Point2Value ((P.x + t*(Q.x-P.x)) / _scale.x,
                                (P.y + t*(Q.y-P.y)) / _scale.y);
   }
}

AxAValue
Camera::ExtendedAttrib(char *attrib, VARIANT& val)
{
    return this;
}


/*****************************************************************************
Construct a NEW camera by transforming another camera.  The NEW camera
inherits the camera type of the base camera.
*****************************************************************************/

Camera *TransformCamera (Transform3 *transform, Camera *camera)
{
    return NEW Camera (transform, camera);
}



/*****************************************************************************
This function takes a camera and a number and returns a camera with the depth
clip set to that value.  In other words, the far clip will be set to the near
clip plus the depth.
*****************************************************************************/

Camera *Depth (AxANumber *depth, Camera *cam)
{
    Camera *newcam = NEW Camera (cam);
    newcam->SetDepth (NumberToReal (depth));
    return newcam;
}



/*****************************************************************************
This function takes a camera and a number and returns a camera with the depth
set so that depth is maximized and a minimum depth resolution of the given
units (camera coordinates) is met.  For example, calling this with 1mm will
yield a depth clip so that surfaces 1mm apart are guaranteed to appear at
different depths when rendered.
*****************************************************************************/

Camera *DepthResolution (AxANumber *resolution, Camera *cam)
{
    Camera *newcam = NEW Camera (cam);
    newcam->SetDepthResolution (NumberToReal (resolution));
    return newcam;
}



/*****************************************************************************
This function returns a parallel camera.  The camera is aimed in the -Z
direction, with +Y up, and the near clip plane is set at [0 0 near].
*****************************************************************************/

Camera *ParallelCamera (AxANumber *nearClip)
{
    if (NumberToReal(nearClip) == 0)
        return baseOrthographicCamera;
    else
        return NEW Camera (Translate (0, 0, NumberToReal(nearClip)),
                           baseOrthographicCamera);
}



/*****************************************************************************
The PerspectiveCamera function takes two scalars, 'focalDist' and 'nearClip'
and returns a perspective camera.  The resulting camera is aimed in the -Z
direction, with +Y up.  The near clip plane is located at [0 0 nearClip], the
projection point is located at [0 0 focalDist], and the camera is scaled so
that objects at Z=0 appear actual size.  Thus, the Z=0 plane can be thought of
as the projection plane.
*****************************************************************************/

Camera *PerspectiveCamera (AxANumber *_focalDist, AxANumber *_nearClip)
{
    Real focalDist = NumberToReal (_focalDist);   // Convert To Reals
    Real nearClip  = NumberToReal (_nearClip);

    if (focalDist <= nearClip)
        RaiseException_UserError (E_FAIL, IDS_ERR_GEO_CAMERA_FOCAL_DIST);

    // If the parameters match those of the base perspective camera, then
    // just return that camera without modifying it.

    if ((focalDist == 1) && (nearClip == 0)) return baseCamera;

    Real pNear = focalDist - nearClip;  // Dist Between Near Clip & Proj Point

    // Here we scale the camera so that the projected size of an object at
    // the Z=0 plane is scaled up to actual size.  To do this, scale the
    // camera down to the (smaller) projected unit size, so that the object
    // looks as big as actual size to the camera.

    Real camScale = pNear / focalDist;

    // Size the camera in X & Y by the scale above, scale the Z coordinate to
    // place the projection point (relative to the near clip plane, which is at
    // Z=0 for the base camera), and then translate the whole thing back to the
    // near clip plane.

    return NEW Camera (
        TimesXformXform (
            Translate (0, 0, nearClip),
            Scale (camScale, camScale, pNear)),
        baseCamera
    );
}



/*****************************************************************************
This function returns the projection of a world-coordinate point to image
(camera-plane) coordinates.
*****************************************************************************/

Point2Value *ProjectPoint (Point3Value *P, Camera *camera)
{
    return camera->Project (P);
}



/*****************************************************************************
This routine initializes static camera values.  For now, this is just the
default camera.
*****************************************************************************/

void InitializeModule_Camera (void)
{
    baseCamera             = NEW Camera (Camera::PERSPECTIVE);
    baseOrthographicCamera = NEW Camera (Camera::ORTHOGRAPHIC);

    defaultCamera      = baseCamera;
    orthographicCamera = baseOrthographicCamera;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\cloud.cpp ===
/*-------------------------------------

  Copyright (c) 1996 Microsoft Corporation

  Abstract:

  Implements Cloud class which maintains a set of n
  points that tightly bound some target object.
  The whole class is implemented here for now.

  -------------------------------------*/

#include "headers.h"
#include "privinc/cloud.h"
#include "privinc/vec3i.h"
#include "appelles/xform.h"

///////////////////////////////////////////////////
//          C L O U D   C L A S S
///////////////////////////////////////////////////

Cloud::Cloud()
{
    _nullCloud = TRUE;
    _minCurrent = FALSE;
    _maxCurrent = FALSE;
    ResetMax();
    ResetMin();
    _numPts = 0;
}

Point3Value Cloud::FindMinPointCoord()
{
    // optimize later
    //      if(_minCurrent == TRUE)
    //          return _minPt;

    ResetMin();
    Point3Value *p;
    for(int i=0; i<_numPts; i++) {
        p = &(_pointArray[i]);
        if(p->x < _minPt.x) _minPt.x = p->x;
        if(p->y < _minPt.y) _minPt.y = p->y;
        if(p->z < _minPt.z) _minPt.z = p->z;
    }
    _minCurrent = TRUE;
    return _minPt;
}

Point3Value Cloud::FindMaxPointCoord()
{
    // optimize later
    //      if(_maxCurrent == TRUE)
    //          return _maxPt;

    ResetMax();
    Point3Value *p;
    for(int i=0; i<_numPts; i++) {
        p = &(_pointArray[i]);
        if(p->x > _maxPt.x) _maxPt.x = p->x;
        if(p->y > _maxPt.y) _maxPt.y = p->y;
        if(p->z > _maxPt.z) _maxPt.z = p->z;
    }
    _maxCurrent = TRUE;
    return _maxPt;
}

void Cloud::Transform(Transform3 *xform)
{
    for(int i=0; i<_numPts; i++) {
        // copy point3
        _pointArray[i] = *(TransformPoint3(xform, &(_pointArray[i])));
    }
    _minCurrent = FALSE;
    _maxCurrent = FALSE;
}

void Cloud::Augment(Cloud &cloud)
{
    if(_nullCloud == TRUE) {
        // copy incoming cloud
        cloud.CopyInto(this);
    } else {
        // Really do an augment
        FindMinPointCoord();
        FindMaxPointCoord();

        Point3Value min = cloud.FindMinPointCoord();
        Point3Value max = cloud.FindMaxPointCoord();

        if(min.x < _minPt.x) _minPt.x = min.x;
        if(min.y < _minPt.y) _minPt.y = min.y;
        if(min.z < _minPt.z) _minPt.z = min.z;

        if(max.x > _maxPt.x) _maxPt.x = max.x;
        if(max.y > _maxPt.y) _maxPt.y = max.y;
        if(max.z > _maxPt.z) _maxPt.z = max.z;

        ForceEnumerateThesePlease(_minPt, _maxPt);
        _minCurrent = TRUE;
        _maxCurrent = TRUE;
    }
    _nullCloud = FALSE;
}

void Cloud::ForceEnumerateThesePlease(Point3Value &min, Point3Value &max) {
    _numPts = 0;
    EnumerateThesePlease(min.x,min.y,min.z,
                         max.x,max.y,max.z);
}

void Cloud::EnumerateThesePlease(Point3 &min, Point3 &max) {
    EnumerateThesePlease(min.x,min.y,min.z,
                         max.x,max.y,max.z);
}

void Cloud::EnumerateThesePlease(Real minx, Real miny, Real minz,
                                 Real maxx, Real maxy, Real maxz) {
    _nullCloud = FALSE;
    _minCurrent = FALSE;
    _maxCurrent = FALSE;
    AddPoint(*(NEW Point3Value(minx,miny,minz)));
    AddPoint(*(NEW Point3Value(minx,miny,maxz)));
    AddPoint(*(NEW Point3Value(minx,maxy,minz)));
    AddPoint(*(NEW Point3Value(minx,maxy,maxz)));
    AddPoint(*(NEW Point3Value(maxx,miny,minz)));
    AddPoint(*(NEW Point3Value(maxx,miny,maxz)));
    AddPoint(*(NEW Point3Value(maxx,maxy,minz)));
    AddPoint(*(NEW Point3Value(maxx,maxy,maxz)));
}

void Cloud::AddPoint(Point3Value &p) {
    if(_numPts >= GetMaxPts()) {
        Assert(FALSE && "Tried to add too many points to Cloud");
        return;
    }
    _pointArray[_numPts] = p;
    _numPts++;
}

void Cloud::CopyInto(Cloud *target) {
    target->_nullCloud = _nullCloud;
    target->_minCurrent = _minCurrent;
    target->_maxCurrent = _maxCurrent;

    target->_numPts = _numPts;
    target->_minPt = _minPt;
    target->_maxPt = _maxPt;

    for(int i=0; i < _numPts; i++)
        target->_pointArray[i] = _pointArray[i];
}

void Cloud::ResetMax() {
    _maxPt.x = _maxPt.y = _maxPt.z = - HUGE_VAL;
}

void Cloud::ResetMin() {
    _minPt.x = _minPt.y = _minPt.z =   HUGE_VAL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\fontstyl.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implements the font style data type

*******************************************************************************/

#include "headers.h"
#include "appelles/text.h"
#include "appelles/path2.h"
#include "appelles/matte.h"
#include "privinc/texti.h"
#include "privinc/colori.h"
#include "privinc/xform2i.h"

class FontStyle : public AxAValueObj {
  public:

    FontStyle() {
        _bold = false;
        _italic = false;
        _underline = false;
        _strikethrough = false;
        _fixedText = false;
        _col = black;
        _family = serifProportional;
        _antiAliasing = 0;
        _size = DEFAULT_TEXT_POINT_SIZE;
        _weight = (double)(FW_NORMAL) / 1000.0;
        _characterTransform = NULL;
    }

    FontStyle *Bold() {
        FontStyle *fs = NEW FontStyle(this);
        fs->_bold = true;
        return fs;
    }
    
    FontStyle *Underline() {
        FontStyle *fs = NEW FontStyle(this);
        fs->_underline = true;
        return fs;
    }
    
    FontStyle *Strikethrough() {
        FontStyle *fs = NEW FontStyle(this);
        fs->_strikethrough = true;
        return fs;
    }
    
    FontStyle *Italic() {
        FontStyle *fs = NEW FontStyle(this);
        fs->_italic = true;
        return fs;
    }
    
    FontStyle *TheColor(Color *col)  {
        FontStyle *fs = NEW FontStyle(this);
        fs->_col = col;
        return fs;
    }
    
    FontStyle *Face(AxAString *face) {
        FontStyle *fs = NEW FontStyle(this);
        fs->_family = NEW FontFamily(face);
        return fs;
    }
    
    FontStyle *Size(AxANumber *num) {
        FontStyle *fs = NEW FontStyle(this);
        Real sz = num->GetNum();

        // NOTE: if size is <= that means use
        // fixed text mode.  otherwise, use regular
        // text mode.
        if(sz < 0) {
            fs->_size = -sz;
            fs = fs->FixedText(true);
        } else {
            fs->_size = sz;
        }
        
        return fs;
    }

    FontStyle *Weight(AxANumber *num) {
        FontStyle *fs = NEW FontStyle(this);
        fs->_weight = num->GetNum();
        return fs;
    }
    
    FontStyle *AntiAliasing(AxANumber *num) {
        FontStyle *fs = NEW FontStyle(this);
        fs->_antiAliasing = (int)(num->GetNum());
        return fs;
    }

    FontStyle *TransformCharacters(Transform2 *xf) {
        FontStyle *fs = NEW FontStyle(this);
        fs->_characterTransform = xf;
        return fs;
    }
    
    FontStyle *FixedText(bool isFixed) {
        FontStyle *fs = NEW FontStyle(this);
        fs->_fixedText = isFixed;
        return fs;
    }
    
    Image *TextImage(AxAString *str) {
        Text *tx = BuildText(str);
        Image *img = RenderTextToImage(tx);
        Transform2 *xf = BuildScaler();
        img = TransformImage(xf, img);

        return img;
    }

    Path2 *TextPath(AxAString *str) {
        Text *tx = BuildText(str);
        Path2 *pth = OriginalTextPath(tx);
        Transform2 *xf = BuildScaler();
        pth = TransformPath2(xf, pth);

        return pth;
    }
    
    Matte *TextMatte(AxAString *str) {
        Text *tx = BuildText(str);
        Matte *matte = OriginalTextMatte(tx);
        Transform2 *xf = BuildScaler();
        matte = TransformMatte(xf, matte);

        return matte;
    }
    
    virtual DXMTypeInfo GetTypeInfo() { return FontStyleType; }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_col);
        (*proc)(_family);
        (*proc)(_characterTransform);
    }
    
  protected:
    FontStyle(FontStyle *fs) {
        _bold = fs->_bold;
        _italic = fs->_italic;
        _col = fs->_col;
        _family = fs->_family;
        _size = fs->_size;
        _strikethrough = fs->_strikethrough;
        _underline = fs->_underline;
        _weight = fs->_weight;
        _antiAliasing = fs->_antiAliasing;
        _fixedText = fs->_fixedText;
        _characterTransform = fs->_characterTransform;
    }

    Text *BuildText(AxAString *str) {
        Text *tx = SimpleText(str);

        if (_bold) { tx = TextBold(tx); }
        if (_italic) { tx = TextItalic(tx); }
        if (_underline) { tx = TextUnderline(tx); }
        if (_strikethrough) { tx = TextStrikethrough(tx); }
        if (_fixedText) { tx = TextFixedText(tx); }
        if (_characterTransform) { tx = TextTransformCharacter(_characterTransform, tx); }
        
        tx = TextColor(_col, tx);
        tx = TextFont(_family, _size, tx);
        tx = TextWeight(_weight, tx);
        tx = TextAntiAliased(_antiAliasing, tx);
        
        return tx;
    }

    Transform2 *BuildScaler() {
        // The size is specified in points, but the underlying
        // renderer wants a factor difference from the default point
        // size, thus we come up with this factor to effect a
        // different point size.
        double scaleFac = _size / DEFAULT_TEXT_POINT_SIZE;
        Transform2 *xf = Scale2(NEW AxANumber(scaleFac));

        return xf;
    }

    boolean     _bold;
    boolean     _italic;
    double      _weight;
    boolean     _underline;
    boolean     _strikethrough;
    boolean     _fixedText;
    Color      *_col;
    FontFamily *_family;
    double      _size;
    int         _antiAliasing;
    Transform2 *_characterTransform;
};

FontStyle *
Font(AxAString *str, AxANumber *size, Color *col)
{
    return defaultFont->Face(str)->Size(size)->TheColor(col);
}

Image *
ImageFromStringAndFontStyle(AxAString *str, FontStyle *fs)
{
    return fs->TextImage(str);
}


// This guy is declared in path2.h, but is dependent upon fontstyle.
Path2 *
TextPath2Constructor(AxAString *str, FontStyle *fs)
{
    return fs->TextPath(str);
}

// This guy is declared in matte.h, but is dependent upon fontstyle.
Matte *
TextMatteConstructor(AxAString *str, FontStyle *fs)
{
    return fs->TextMatte(str);
}


FontStyle *FontStyleBold(FontStyle *fs) { return fs->Bold(); }
FontStyle *FontStyleItalic(FontStyle *fs) { return fs->Italic(); }
FontStyle *FontStyleColor(FontStyle *fs, Color *col) { return fs->TheColor(col); }
FontStyle *FontStyleFace(FontStyle *fs, AxAString *str) { return fs->Face(str); }
FontStyle *FontStyleSize(FontStyle *fs, AxANumber *num) { return fs->Size(num); }

FontStyle *FontStyleAntiAliasing(AxANumber *aaStyle, FontStyle *fs)
{ return fs->AntiAliasing(aaStyle); }

FontStyle *
FontStyleUnderline(FontStyle *fs)
{ return fs->Underline(); }

FontStyle *
FontStyleStrikethrough(FontStyle *fs)
{ return fs->Strikethrough(); }

FontStyle *
FontStyleWeight(FontStyle *fs, AxANumber *weight)
{ return fs->Weight(weight); }

FontStyle *
FontStyleFixedText(FontStyle *fs, bool isFixed)
{ return fs->FixedText(isFixed); }

FontStyle *defaultFont;

////////////////////// IDA2FontStyle methods ////////////////////

FontStyle *
FontStyleTransformCharacters(FontStyle *fs, Transform2 *xf)
{ return fs->TransformCharacters(xf); }


void
InitializeModule_FontStyle()
{
    defaultFont = NEW FontStyle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\linestyl.cpp ===
/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    LineStyle, JointStyle, EndStyle, DashStyle implementation

-------------------------------------*/

#include "headers.h"

#include "backend/bvr.h"
#include "privinc/server.h"
#include "privinc/basic.h"
#include <appelles/linestyl.h>
#include <privinc/linei.h>
#include "privinc/basic.h"
#include "dartapi.h"  // for CR_XXX stuff


LineStyle *LineEndStyle( EndStyle *theStyle, LineStyle *ls)
{
    return NEW LineEndStyleClass( theStyle->_style, ls );
}

LineStyle *LineJoinStyle( JoinStyle *theStyle, LineStyle *ls)
{
    return NEW LineJoinStyleClass( theStyle->_style, ls );
}

LineStyle *LineDashStyle( DashStyle *theStyle, LineStyle *ls)
{
    return NEW LineDashStyleClass( theStyle->_style, ls );
}

LineStyle *LineWidthStyle(AxANumber *width, LineStyle *lineStyle)
{
    return NEW LineWidthStyleClass(NumberToReal(width), false, lineStyle);
}

LineStyle *LineDetailStyle(LineStyle *lineStyle)
{
    return NEW LineWidthStyleClass(0.0, true, lineStyle);  
}

LineStyle *LineColor(Color *clr, LineStyle *lineStyle)
{
    return NEW LineColorStyleClass(clr, lineStyle);
}

LineStyle *LineAntiAliasing(AxANumber *aaStyle, LineStyle *ls)
{
    Real style = aaStyle->GetNum();
    if(style > 0.0) {
        return NEW LineAntiAliasedStyleClass(true, ls);
    } else {
        return ls;
    }
}
//////////////////////////////////////////////////////////////////////
//////////   NEWER FUNCTIONS TO CONSTRUCT LINESTYLES     /////////////
//////////////////////////////////////////////////////////////////////
LineStyle *ConstructLineStyleMiterLimit(LineStyle *ls, AxANumber *limit)
{
    return NEW LineMiterLimitClass((float)limit->GetNum(), ls);
}



LineStyle *
ConstructLineStyleDashStyleStatic(LineStyle *ls, AxALong *ds)
{
    DashStyleEnum ds_enum = (DashStyleEnum) (ds->GetLong());

    if( (ds_enum != PS_SOLID) &&
        (ds_enum != PS_DASH) &&
        (ds_enum != PS_DOT) &&
        (ds_enum != PS_DASHDOT) &&
        (ds_enum != PS_DASHDOTDOT) &&
        (ds_enum != PS_NULL) ) {
        RaiseException_UserError( E_INVALIDARG, IDS_ERR_IMG_INVALID_LINESTYLE );
    }
    
    return NEW LineDashStyleClass(ds_enum, ls);
}

Bvr
ConstructLineStyleDashStyle(Bvr lsBvr, DWORD ds_enum)
{
    Bvr ds_enumBvr = UnsharedConstBvr(LongToAxALong(ds_enum));

    // TODO: share valprimop at module initialize
    return PrimApplyBvr(ValPrimOp(::ConstructLineStyleDashStyleStatic,
                                  2,
                                  "ConstructLineStyleDashStyle",
                                  LineStyleType),
                        2, lsBvr, ds_enumBvr);
}


LineStyle *
ConstructLineStyleJoinStyleStatic(LineStyle *ls, AxALong *js)
{
    JoinStyleEnum js_enum = (JoinStyleEnum) (js->GetLong());

    if( (js_enum != js_Round) &&
        (js_enum != js_Bevel) &&
        (js_enum != js_Miter) ) {
        RaiseException_UserError( E_INVALIDARG, IDS_ERR_IMG_INVALID_LINESTYLE );
    }
    
    return NEW LineJoinStyleClass(js_enum, ls);
}

Bvr
ConstructLineStyleJoinStyle(Bvr lsBvr, DWORD js_enum)
{
    Bvr js_enumBvr = UnsharedConstBvr(LongToAxALong(js_enum));

    // TODO: share valprimop at module initialize
    return PrimApplyBvr(ValPrimOp(::ConstructLineStyleJoinStyleStatic,
                                  2,
                                  "ConstructLineStyleJoinStyle",
                                  LineStyleType),
                        2, lsBvr, js_enumBvr);
}

LineStyle *
ConstructLineStyleEndStyleStatic(LineStyle *ls, AxALong *es)
{
    EndStyleEnum es_enum = (EndStyleEnum) (es->GetLong());

    if( (es_enum != es_Round) &&
        (es_enum != es_Square) &&
        (es_enum != es_Flat) ) {

        RaiseException_UserError( E_INVALIDARG, IDS_ERR_IMG_INVALID_LINESTYLE );
    }
    
    return NEW LineEndStyleClass(es_enum, ls);
}

Bvr
ConstructLineStyleEndStyle(Bvr lsBvr, DWORD es_enum)
{
    Bvr es_enumBvr = UnsharedConstBvr(LongToAxALong(es_enum));

    // TODO: share valprimop at module initialize
    return PrimApplyBvr(ValPrimOp(::ConstructLineStyleEndStyleStatic,
                                  2,
                                  "ConstructLineStyleEndStyle",
                                  LineStyleType),
                        2, lsBvr, es_enumBvr);
}

//
// External Constants
//
LineStyle *defaultLineStyle;
LineStyle *emptyLineStyle;

EndStyle *endStyleFlat;
EndStyle *endStyleSquare;
EndStyle *endStyleRound;

JoinStyle *joinStyleBevel;
JoinStyle *joinStyleRound;
JoinStyle *joinStyleMiter;

DashStyle *dashStyleSolid;
DashStyle *dashStyleDashed;

void
InitializeModule_LineStyle()
{
    defaultLineStyle = NEW LineStyle();  // Visible: true
    emptyLineStyle = NEW EmptyLineStyle();   // Visible: false

    endStyleFlat   = NEW EndStyle(es_Flat);
    endStyleSquare = NEW EndStyle(es_Square);
    endStyleRound  = NEW EndStyle(es_Round);

    joinStyleBevel = NEW JoinStyle(js_Bevel);
    joinStyleRound = NEW JoinStyle(js_Round);
    joinStyleMiter = NEW JoinStyle(js_Miter);

    dashStyleSolid  = NEW DashStyle(ds_Solid);
    dashStyleDashed = NEW DashStyle(ds_Dashed);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\color.cpp ===
/*******************************************************************************
Copyright (c) 1995-96  Microsoft Corporation

    Implementation of Color *values (RGB, HSL).

*******************************************************************************/

#include "headers.h"
#include <math.h>
#include "privinc/colori.h"
#include "privinc/basic.h"

    // Constant definitions

Color *red     = NULL;
Color *green   = NULL;
Color *blue    = NULL;
Color *cyan    = NULL;
Color *magenta = NULL;
Color *yellow  = NULL;
Color *white   = NULL;
Color *black   = NULL;
Color *gray    = NULL;
Color *aqua    = NULL;   
Color *fuchsia = NULL;      
Color *lime    = NULL;    
Color *maroon  = NULL;    
Color *navy    = NULL;    
Color *olive   = NULL;   
Color *purple  = NULL;   
Color *silver  = NULL; 
Color *teal    = NULL;  
Color *emptyColor = NULL;  

    // Local Functions

static void RgbToHsl (Real r, Real g, Real b, Real *h, Real *s, Real *l);
static void HslToRgb (Real H, Real S, Real L, Real &R, Real &G, Real &B);



/*****************************************************************************
This function sets the RGB values of a color.
*****************************************************************************/

void Color::SetRGB (Real r, Real g, Real b)
{   red   = r;
    green = g;
    blue  = b;
}



/*****************************************************************************
Set the color from the D3D color value
*****************************************************************************/

void Color::SetD3D (D3DCOLOR color)
{   red   = RGBA_GETRED (color)   / 255.0;
    green = RGBA_GETGREEN (color) / 255.0;
    blue  = RGBA_GETBLUE (color)  / 255.0;
}



/*****************************************************************************
This function adds the given RGB values to the current values.
*****************************************************************************/

void Color::AddColor (Color &other)
{   red   += other.red;
    green += other.green;
    blue  += other.blue;
}



/*****************************************************************************
This function returns the intensity of the color, based on the standard NTSC
RGB phosphor.  See Foley & VanDam II, p.589 for more information.
*****************************************************************************/

Real Color::Intensity (void)
{
    return (.299 * red) + (.587 * green) + (.114 * blue);
}



/*****************************************************************************
Compare a color with another color.
*****************************************************************************/

bool Color::operator== (const Color &other) const
{
    return (red   == other.red)
        && (green == other.green)
        && (blue  == other.blue);
}



/*****************************************************************************
Construct a color from red, green, and blue levels.
*****************************************************************************/

Color *RgbColorRRR (Real r, Real g, Real b)
{
    return NEW Color (r,g,b);
}

Color *RgbColor (AxANumber *r, AxANumber *g, AxANumber *b)
{
    return RgbColorRRR (NumberToReal(r),NumberToReal(g),NumberToReal(b));
}



/*****************************************************************************
Construct a color from hue, saturation, and luminance.
*****************************************************************************/

Color *HslColorRRR (Real h, Real s, Real l)
{
    Real r, g, b;
    HslToRgb (h, s, l, r, g, b);
    return NEW Color(r,g,b);
}

Color *HslColor (AxANumber *h, AxANumber *s, AxANumber *l)
{
    return HslColorRRR(NumberToReal(h), NumberToReal(s), NumberToReal(l));
}



/*****************************************************************************
This routine prints out the value of the given color.
*****************************************************************************/

#if _USE_PRINT
ostream& operator<< (ostream& os, Color& c)
{
    return os <<"colorRgb(" <<c.red <<"," <<c.green <<"," <<c.blue <<")";
}
#endif


/* Accessors */

AxANumber *RedComponent(Color *c)   { return RealToNumber (c->red);   }
AxANumber *GreenComponent(Color *c) { return RealToNumber (c->green); }
AxANumber *BlueComponent(Color *c)  { return RealToNumber (c->blue);  }

AxANumber *HueComponent (Color *c)
{
    Real h,s,l;
    RgbToHsl (c->red, c->green, c->blue, &h, &s, &l);
    return RealToNumber (h);
}

AxANumber *SaturationComponent (Color *c)
{
    Real h,s,l;
    RgbToHsl(c->red, c->green, c->blue, &h, &s, &l);
    return RealToNumber(s);
}

AxANumber *LuminanceComponent(Color *c)
{
    Real h,s,l;
    RgbToHsl(c->red, c->green, c->blue, &h, &s, &l);
    return RealToNumber(l);
}



/*****************************************************************************
RGB-HSL transforms.  /  Ken Fishkin, Pixar Inc., January 1989.
Given r,g,b on [0 ... 1], return (h,s,l) on [0 ... 1]
*****************************************************************************/

static void RgbToHsl (Real r, Real g, Real b, Real *h, Real *s, Real *l)
{
    Real v;
    Real m;
    Real vm;
    Real r2, g2, b2;

    v = (r > g) ? ((r > b) ? r : b)
                : ((g > b) ? g : b);

    m = (r < g) ? ((r < b) ? r : b)
                : ((g < b) ? g : b);

    // Check to see if we have positive luminance.
    // If not the color is pure black and h, s, l
    // are all zero.
    if ((*l = (m + v) / 2.0) <= 0.0) 
    {
        *h = 0.0;
        *s = 0.0;
        *l = 0.0;
        return;
    }

    // Check to see if we have positive saturation,
    // If not, the color is a pure shade of grey or
    // white, s is zero, and h is undefined.  Set h
    // to zero to prevent us or others from choking
    // on bad nums later.
    if ((*s = vm = v - m) > 0.0)
    {
        *s /= (*l <= 0.5) ? (v + m ) : (2.0 - v - m);
    }
    else
    {
        *s = 0.0;
        *h = 0.0;
        return;
    }


    r2 = (v - r) / vm;
    g2 = (v - g) / vm;
    b2 = (v - b) / vm;

    if (r == v)
        *h = (g == m ? 5.0 + b2 : 1.0 - g2);
    else if (g == v)
        *h = (b == m ? 1.0 + r2 : 3.0 - b2);
    else
        *h = (r == m ? 3.0 + g2 : 5.0 - r2);

    *h /= 6;
}


/*****************************************************************************
"A Fast HSL-to-RGB Transform" by Ken Fishkin from "Graphics Gems", Academic
Press, 1990.  Hue (H) can be any value; only the fractional part will be used
(travelling across the zero boundary is smooth).  Saturation (S) is clamped
to [0,1].  Luminance (L) yields black for L<0, and L>1 yields an overdrive
light.
*****************************************************************************/

static void HslToRgb (Real H, Real S, Real L, Real &R, Real &G, Real &B)
{
    if (H >= 0.0) {             // Modulo to fit into [0,1].
        H = fmod(H, 1.0);         
    } else {
        H = 1.0 + fmod(H, 1.0);
    }
    H = clamp(H, 0.0, 1.0);
    S = clamp(S, 0.0, 1.0);  // Clamp to [0,1].

    // V is the value of the color (a la HSV).

    Real V;
    if (L <= 0.5) {
        V = L * (1.0 + S);
    } else {
        V = L + S - (L * S);
    }

    if (V <= 0)
    {   R = G = B = 0;
        return;
    }

    Real min = 2*L - V;
    S = (V - min) / V;
    H *= 6;
    int sextant = (int) floor(H);
    Real vsf = V * S * (H - sextant);

    Real mid1 = min + vsf;
    Real mid2 = V - vsf;

    switch (sextant)
    {   case 0:  R = V;     G = mid1;  B = min;   break;
        case 1:  R = mid2;  G = V;     B = min;   break;
        case 2:  R = min;   G = V;     B = mid1;  break;
        case 3:  R = min;   G = mid2;  B = V;     break;
        case 4:  R = mid1;  G = min;   B = V;     break;
        case 5:  R = V;     G = min;   B = mid2;  break;
    }
}

void
InitializeModule_Color()
{
    red     = NEW Color (1.00, 0.00, 0.00);
    green   = NEW Color (0.00, 1.00, 0.00);
    blue    = NEW Color (0.00, 0.00, 1.00);
    cyan    = NEW Color (0.00, 1.00, 1.00);
    magenta = NEW Color (1.00, 0.00, 1.00);
    yellow  = NEW Color (1.00, 1.00, 0.00);
    white   = NEW Color (1.00, 1.00, 1.00);
    black   = NEW Color (0.00, 0.00, 0.00);
    gray    = NEW Color (0.50, 0.50, 0.50);
    aqua    = NEW Color (0.00, 1.00, 1.00);   
    fuchsia = NEW Color (1.00, 0.00, 1.00);    
    lime    = NEW Color (0.00, 1.00, 0.00);    
    maroon  = NEW Color (0.50, 0.00, 0.00);    
    navy    = NEW Color (0.00, 0.00, 0.50);    
    olive   = NEW Color (0.50, 0.50, 0.00);   
    purple  = NEW Color (0.50, 0.00, 0.50);   
    silver  = NEW Color (0.75, 0.75, 0.75); 
    teal    = NEW Color (0.00, 0.50, 0.50);  
    emptyColor = NEW Color (0.00, 0.00, 0.00);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\matte.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    2D mattes

*******************************************************************************/

#include "headers.h"
#include "privinc/mattei.h"
#include "privinc/path2i.h"
#include "privinc/except.h"
#include "privinc/xform2i.h"
#include "appelles/bbox2.h"
#include "privinc/bbox2i.h"
#include "privinc/polygon.h"
#include "privinc/texti.h"
#include "privinc/textctx.h"
#include "privinc/server.h"  // getCurrentImageDispdev...


//////////////////

Matte::MatteType
Matte::GenerateHRGN(HDC dc,
                    callBackPtr_t devCallBack,
                    void *devCtxPtr,
                    Transform2 *xform,
                    HRGN *hrgnOut,
                    bool justDoPath)
{
    // assert mutually exclusive
    Assert( (justDoPath  && !hrgnOut)  ||
            (!justDoPath && hrgnOut) );
    
    // Generate an initially empty HRGN
    MatteCtx ctx(dc,
                 devCallBack,
                 devCtxPtr,
                 xform,
                 justDoPath);

    // Accumulate into the context
    Accumulate(ctx);

    // Pull out HRGN and MatteType.
    if( hrgnOut ) {
        *hrgnOut = ctx.GetHRGN();
    }
    
    return ctx.GetMatteType();
}

inline Matte::MatteType   
Matte::GenerateHRGN(MatteCtx &inCtx,
                    HRGN *hrgnOut)
{
    return GenerateHRGN(inCtx._dc,
                        inCtx._devCallBack,
                        inCtx._devCtxPtr,
                        inCtx._xf,
                        hrgnOut,
                        inCtx._justDoPath);
}


//////////////////

class OpaqueMatte : public Matte {
  public:
    void Accumulate(MatteCtx& ctx) {
        // Just don't accum anything in.
    }
    inline const Bbox2 BoundingBox() {
        return NullBbox2;
    }

#if BOUNDINGBOX_TIGHTER
    inline const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        return NullBbox2;
    }
#endif  // BOUNDINGBOX_TIGHTER

#if 0
    Bool BoundingPgon(BoundingPolygon &pgon) {
        //pgon.SetBox(nullBbox2); maybe a fully opaque matte means no bounding pgon ?
        return FALSE;
    }
#endif

};

Matte *opaqueMatte = NULL;

//////////////////

class ClearMatte : public Matte {
  public:
    void Accumulate(MatteCtx& ctx) {

        // shouldn't be here at all if we're just accum path
        Assert( !ctx.JustDoPath() );
        
        // If we hit this, our matte is infinitely clear.
        ctx.AddInfinitelyClearRegion();
    }

    inline const Bbox2 BoundingBox() {
        return UniverseBbox2;
    }

#if BOUNDINGBOX_TIGHTER
    inline const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        return UniverseBbox2;
    }
#endif  // BOUNDINGBOX_TIGHTER

#if 0
    Bool BoundingPgon(BoundingPolygon &pgon) {
        pgon.SetBox(universeBbox2);
    }
#endif

#if _USE_PRINT
    ostream& Print(ostream& os) { return os << "ClearMatte"; }
#endif
};

Matte *clearMatte = NULL;

//////////////////

class HalfMatte : public Matte {
  public:
    void Accumulate(MatteCtx& ctx) {

        // shouldn't be here at all if we're just accum path
        Assert( !ctx.JustDoPath() );

        // If we hit this, our matte is clear on the top, opaque on the bottom
        ctx.AddHalfClearRegion();
    }

    inline const Bbox2 BoundingBox() {
        return Bbox2(-HUGE_VAL, 0, HUGE_VAL, HUGE_VAL);
    }

#if BOUNDINGBOX_TIGHTER
    inline const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        return Bbox2(-HUGE_VAL, 0, HUGE_VAL, HUGE_VAL);
    }
#endif  // BOUNDINGBOX_TIGHTER

#if 0
    void BoundingPgon(BoundingPolygon &pgon) {
        pgon.SetBox(BoundingBox());
    }
#endif

#if _USE_PRINT
    ostream& Print(ostream& os) { return os << "HalfMatte"; }
#endif
};

Matte *halfMatte = NULL;

//////////////////

class UnionedMatte : public Matte {
  public:
    UnionedMatte(Matte *m1, Matte *m2) : _m1(m1), _m2(m2) {}

    void Accumulate(MatteCtx& ctx) {
        // shouldn't be here at all if we're just accum path
        Assert( !ctx.JustDoPath() );

        _m1->Accumulate(ctx);
        _m2->Accumulate(ctx);
    }

    const Bbox2 BoundingBox() {
        return UnionBbox2Bbox2(_m1->BoundingBox(), _m2->BoundingBox());
    }

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        return UnionBbox2Bbox2(_m1->BoundingBoxTighter(bbctx), _m2->BoundingBoxTighter(bbctx));
    }
#endif  // BOUNDINGBOX_TIGHTER

#if 0
    Bool BoundingPgon(BoundingPolygon &pgon) {
        return FALSE;
    }
#endif

    // TODO: union matte could be constructed in terms of paths.
    // TODO: don't forget the following when trying to implement this:
    //   1.> each underlying matte needs to ACCUMULATE the path.
    //   right now pathbasedmatte, for example, does a begin/end.  in
    //   order to do union right, we need ONE begin at the first union
    //   and ONE end after it, and every path or textpath underneath
    //   just accumulates into the path (moveto, lineto, bezierto,
    //   etc...)
    //   2.> Also take out the assert in Accumulate above
    /*
    bool    IsPathRepresentableMatte() {
        return
            _m1->IsPathRepresentableMatte() &&
            _m2->IsPathRepresentableMatte();
    }
    */            

    virtual void DoKids(GCFuncObj proc) { 
        (*proc)(_m1);
        (*proc)(_m2);
    }
    
#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "UnionedMatte(" << _m1 << "," << _m2 << ")";
    }
#endif

  protected:
    Matte *_m1;
    Matte *_m2;
};

Matte *
UnionMatte(Matte *m1, Matte *m2)
{
    if (m1 == opaqueMatte) {
        return m2;
    } else if (m2 == opaqueMatte) {
        return m1;
    } else if (m1 == clearMatte || m2 == clearMatte) {
        return clearMatte;
    } else {
        return NEW UnionedMatte(m1, m2);
    }
}

//////////////////

class SubtractedMatte : public Matte {
  public:
    SubtractedMatte(Matte *m1, Matte *m2) : _m1(m1), _m2(m2) {}

    void Accumulate(MatteCtx& ctx) {

        // shouldn't be here at all if we're just accum path
        Assert( !ctx.JustDoPath() );

        // Use the provided ctx to accumulate m1 in...  This relies on
        // a+(b-c) == (a+b)-c.
        _m1->Accumulate(ctx);

        // Then, get the HRGN for m2, but pass in the current
        // transform as the one to subject m2 to.  This relies on
        // the identity: xf(a - b) == xf(a) - xf(b).
        HRGN m2Rgn;
        MatteType m2Type = _m2->GenerateHRGN(ctx,
                                             &m2Rgn);

        // TODO: Use the type of m2 to optimize.
        
        // Finally, subtract this HRGN from that being accumulated in
        // ctx.  This checks to see if m2Rgn (the region) is valid before
        // doing the subtraction.  This is OK that the region is not always
        // valid since there are instances that the two mattes move away from 
        // each other and the interseting region goes to zero.
        if(m2Rgn) {
            ctx.SubtractHRGN(m2Rgn);
        }

        // region m2Rgn is managed by ctx
    }
    
    const Bbox2 BoundingBox() {
        // TODO: this is an aproximation
        return _m1->BoundingBox();
    }

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        // TODO: this is an aproximation
        return _m1->BoundingBoxTighter(bbctx);
    }
#endif  // BOUNDINGBOX_TIGHTER

#if 0
    void BoundingPgon(BoundingPolygon &pgon) {
        // TODO: BoundingPolygon on subtracted matte not implemented
    }
#endif

    virtual void DoKids(GCFuncObj proc) { 
        (*proc)(_m1);
        (*proc)(_m2);
    }

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "SubtractedMatte(" << _m1 << "," << _m2 << ")";
    }
#endif

  protected:
    Matte *_m1;
    Matte *_m2;
};

Matte *
SubtractMatte(Matte *m1, Matte *m2)
{
    if (m1 == opaqueMatte || m2 == clearMatte) {
        return opaqueMatte;
    } else if (m2 == opaqueMatte) {
        return m1;
    } else if (m1 == m2) {
        return opaqueMatte;
    } else {
        return NEW SubtractedMatte(m1, m2);
    }
}

//////////////////

class IntersectedMatte : public Matte {
  public:
    IntersectedMatte(Matte *m1, Matte *m2) : _m1(m1), _m2(m2) {}

    void Accumulate(MatteCtx& ctx) {

        // shouldn't be here at all if we're just accum path
        Assert( !ctx.JustDoPath() );

        // Accumulate in an intersection of two regions.  Do so via:
        // a + xf(b isect c)) == a + (xf(b) isect xf(c))

        HRGN m1Rgn, m2Rgn;
        MatteType m1Type = _m1->GenerateHRGN(ctx,
                                             &m1Rgn);
        
        MatteType m2Type = _m2->GenerateHRGN(ctx,
                                             &m2Rgn);

        // TODO: Consider using return types to optimize.
        
        // Identities used in SubtractMatte below should ensure that
        // m1Rgn and m2Rgn are never NULL.
        Assert(m1Rgn && m2Rgn);

        ctx.IntersectAndAddHRGNS(m1Rgn, m2Rgn);

        // the regions are managed by the ctx
    }

    const Bbox2 BoundingBox() {
        return IntersectBbox2Bbox2(_m1->BoundingBox(), _m2->BoundingBox());
    }

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        return IntersectBbox2Bbox2(_m1->BoundingBoxTighter(bbctx), _m2->BoundingBoxTighter(bbctx));
    }
#endif  // BOUNDINGBOX_TIGHTER

#if 0
    void BoundingPgon(BoundingPolygon &pgon) {
         // TODO: BoundingPolygon on Intersected matte not implemented
        _m1->BoundingPgon(pgon);
        _m2->BoundingPgon(pgon);
    }
#endif

    virtual void DoKids(GCFuncObj proc) { 
        (*proc)(_m1);
        (*proc)(_m2);
    }

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "IntersectedMatte(" << _m1 << "," << _m2 << ")";
    }
#endif

  protected:
    Matte *_m1;
    Matte *_m2;
};

Matte *
IntersectMatte(Matte *m1, Matte *m2)
{
    if (m1 == opaqueMatte || m2 == opaqueMatte) {
        return opaqueMatte;
    } else if (m1 == clearMatte) {
        return m2;
    } else if (m2 == clearMatte) {
        return m1;
    } else if (m1 == m2) {
        return m1;
    } else {
        return NEW IntersectedMatte(m1, m2);
    }
}

//////////////////


class PathBasedMatte : public Matte {
  public:
    PathBasedMatte(Path2 *p) : _path(p) {}
    
    void Accumulate(MatteCtx& ctx) {


        // Accumulate the path into the device context
        _path->AccumPathIntoDC (ctx.GetDC(), ctx.GetTransform(), true);

        if( ctx.JustDoPath() ) {
            // we're done: the path is in the dc like we wanted!
        } else {

            // Convert the DC's current path into a region.
            HRGN rgn;
            TIME_GDI(rgn = PathToRegion(ctx.GetDC()));

            // If the region couldn't be created, bail out.

            if (rgn == 0) {
                return;
            }

            ctx.AddHRGN(rgn, nonTrivialHardMatte);
        
            // TODO: May want to optimize special case where the only
            // region comes from this path, in which case using
            // SelectClipPath *may* produce faster results.
        }

    }
        
    Bool ExtractAsSingleContour(Transform2 *xform,
                                int *numPts,            // out
                                POINT **gdiPts,          // out
                                Bool *isPolyline) {

        return _path->ExtractAsSingleContour(
            xform,
            numPts,
            gdiPts,
            isPolyline);
    }

    const Bbox2 BoundingBox() {
        return _path->BoundingBox();
    }

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        return _path->BoundingBoxTighter(bbctx);
    }
#endif  // BOUNDINGBOX_TIGHTER

    Path2   *IsPathRepresentableMatte() { return _path; }

    virtual void DoKids(GCFuncObj proc) { (*proc)(_path); }
    
#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "PathBasedMatte(" << _path << ")";
    }
#endif

  protected:
    Path2 *_path;
};


Matte *
RegionFromPath(Path2 *p)
{
    return NEW PathBasedMatte(p);
}

//////////////////

class TransformedMatte : public Matte {
  public:
    TransformedMatte(Transform2 *xf, Matte *m) : _xf(xf), _m(m) {}

    // Standard push, accumulate, process, and pop...
    void Accumulate(MatteCtx& ctx) {
        Transform2 *oldXf = ctx.GetTransform();
        ctx.SetTransform(TimesTransform2Transform2(oldXf, _xf));
        _m->Accumulate(ctx);
        ctx.SetTransform(oldXf);
    }

    Bool ExtractAsSingleContour(Transform2 *xform,
                                int *numPts,            // out
                                POINT **gdiPts,          // out
                                Bool *isPolyline) {

        return _m->ExtractAsSingleContour(
            TimesTransform2Transform2(xform, _xf),
            numPts,
            gdiPts,
            isPolyline);
    }

    const Bbox2 BoundingBox() {
        return TransformBbox2(_xf, _m->BoundingBox());
    }

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx) {
        Bbox2Ctx bbctxAccum(bbctx, _xf);
        return _m->BoundingBoxTighter(bbctxAccum);
    }
#endif  // BOUNDINGBOX_TIGHTER

#if 0
    void BoundingPgon(BoundingPolygon &pgon) {
        _m->BoundingPgon(pgon);
        pgon.Transform(_xf);
    }
#endif

    Path2 *IsPathRepresentableMatte() {
        
        Path2 *p = _m->IsPathRepresentableMatte();
        if (p) {
            return TransformPath2(_xf, p);
        } else {
            return NULL;
        }
    }

    virtual void DoKids(GCFuncObj proc) { 
        (*proc)(_xf);
        (*proc)(_m);
    }

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "TransformedMatte(" << _xf << "," << _m << ")";
    }
#endif

  protected:
    Transform2 *_xf;
    Matte      *_m;
};

Matte *
TransformMatte(Transform2 *xf, Matte *r)
{
    if (r == opaqueMatte || r == clearMatte ||
                            xf == identityTransform2) {
        return r;
    } else {
        return NEW TransformedMatte(xf, r);
    }
}

////////////////////////////////////

// TEXT MATTE
class TextMatte : public Matte {
  public:
    TextMatte(Text *text) : _text(text) {}

    void Accumulate(MatteCtx &ctx);
        
    const Bbox2 BoundingBox();

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter(Bbox2Ctx &bbctx);
#endif  // BOUNDINGBOX_TIGHTER

    Path2 *IsPathRepresentableMatte() {
        return OriginalTextPath(_text);
    }

    virtual void DoKids(GCFuncObj proc) { (*proc)(_text); }

#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "TextMatte(" << _text << ")";
    }
#endif

  private:
    Text *_text;
};

void TextMatte::
Accumulate(MatteCtx &ctx)
{
    // TODO: when we cleanup matte, let's make the image device part of
    // the matte context, ok ?
    TextCtx textCtx(
        GetImageRendererFromViewport( GetCurrentViewport() ));

    TIME_GDI(BeginPath(ctx.GetDC()));

    textCtx.BeginRendering(TextCtx::renderForPath,
                           ctx.GetDC(),
                           ctx.GetTransform());
    _text->RenderToTextCtx(textCtx);

    textCtx.EndRendering();

    TIME_GDI(EndPath(ctx.GetDC()));

    if( ctx.JustDoPath() ) {
        // we're done
    } else {
        //
        // create a region from the path
        //
        HRGN rgn;
        TIME_GDI(rgn = PathToRegion(ctx.GetDC()));
        if (rgn == 0) {
            RaiseException_InternalError("Couldn't create region for TextMatte");
        }

        ctx.AddHRGN(rgn, nonTrivialHardMatte);
    }
}

const Bbox2 TextMatte::BoundingBox()
{
    TextCtx ctx(
        GetImageRendererFromViewport( GetCurrentViewport() ));
    
    ctx.BeginRendering(TextCtx::renderForBox);
    
    _text->RenderToTextCtx(ctx);
    
    ctx.EndRendering();

    return ctx.GetStashedBbox();
}

#if BOUNDINGBOX_TIGHTER
const Bbox2 TextMatte::BoundingBoxTighter(Bbox2Ctx &bbctx)
{
    Transform2 *xf = bbctx.GetTransform();
    return TransformBbox2(xf, BoundingBox());
}
#endif  // BOUNDINGBOX_TIGHTER

Matte *OriginalTextMatte(Text *text)
{
    return NEW TextMatte(text);
}

////////////////////////////////////
void
InitializeModule_Matte()
{
    opaqueMatte = NEW OpaqueMatte;
    clearMatte = NEW ClearMatte;
    halfMatte =  NEW HalfMatte;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\polygon.cpp ===
/*-------------------------------------

Copyright (c) 1996 Microsoft Corporation

Abstract:

    Implements bounding polygon class

-------------------------------------*/

#include "headers.h"

#include <privinc/util.h>
#include <appelles/bbox2.h>
#include <privinc/bbox2i.h>
#include <privinc/vec2i.h>
#include <privinc/polygon.h>
#include <privinc/xform2i.h>


typedef list<Point2Value *> Point2List ;

// consider inlining this ?... nah
BoundingPolygon *NewBoundingPolygon(const Bbox2 &box)
{
    BoundingPolygon *bp = NEW BoundingPolygon;
    bp->PostConstructorInitialize();
    if (box != NullBbox2) {
        bp->SetBox(box);
    }
    return bp;
}

BoundingPolygon::BoundingPolygon() { }

void BoundingPolygon::
PostConstructorInitialize(void)
{
    _vertList   = NEW list<Point2Value *>;
    _vertexCount=0;
    _accumXform = identityTransform2;
    _xfDirty = FALSE;
    GetHeapOnTopOfStack().RegisterDynamicDeleter(NEW DynamicPtrDeleter<list<Point2Value *> >(_vertList));
}

BoundingPolygon::~BoundingPolygon()
{
    delete _vertList;
}

void BoundingPolygon::
Crop(const Bbox2 &box)
{
    Assert((_vertexCount == 0) || (_vertexCount >= 3) &&
           "Bad vertexCount in BoundingPolygon");

    if (_vertexCount == 0) 
        return;

    if (box.Contains(BoundingBox())) {

        // Return if we're already inside by the crop box.
        
        return;

    } else if (_vertexCount > 2) {

        Point2List list1;
        Point2List *fromList, *tempList, *currList;

        Point2List::iterator curr;
        Point2List::iterator prev;
        bool currOut, prevOut;
        //
        // Augment current set of verticies
        //

        Real minx = box.min.x;
        Real maxx = box.max.x;

        Real miny = box.min.y;
        Real maxy = box.max.y;

        fromList = _vertList;
        currList = &list1;

        //--------------------------------------------------
        // L E F T
        //--------------------------------------------------

        // prime
        curr = fromList->begin();
        prev = fromList->begin();
        curr++;

        for(unsigned int i=0; i < fromList->size(); i++) {
            
            currOut = (*curr)->x <= minx;
            prevOut = (*prev)->x <= minx;

            TestAndAdd(minx, 
                       (*prev)->x, (*prev)->y,
                       (*curr)->x, (*curr)->y,
                       prevOut, currOut,
                       TRUE,
                       *curr,
                       currList);

            curr++; prev++;
            if(curr == fromList->end()) {
                // we've gone past the end, last edge
                curr = fromList->begin();
            }
        } // for left
        
        //
        // Switch
        //
        tempList = fromList;

        fromList->erase(fromList->begin(), fromList->end());
        fromList = currList;
        currList = tempList;


        //--------------------------------------------------
        // R I G H T
        //--------------------------------------------------

        // prime
        curr = fromList->begin();
        prev = fromList->begin();
        curr++;

        for(i=0; i < fromList->size(); i++) {
            
            currOut = (*curr)->x >= maxx;
            prevOut = (*prev)->x >= maxx;

            TestAndAdd(maxx,
                       (*prev)->x, (*prev)->y,
                       (*curr)->x, (*curr)->y,
                       prevOut, currOut,
                       TRUE,
                       *curr,
                       currList);

            curr++; prev++;
            if(curr == fromList->end()) {
                // we've gone past the end, last edge
                curr = fromList->begin();
            }
        } // for right

        //
        // Switch
        //
        tempList = fromList;

        fromList->erase(fromList->begin(), fromList->end());
        fromList = currList;
        currList = tempList;

        //--------------------------------------------------
        // B O T T O M
        //--------------------------------------------------

        // prime
        curr = fromList->begin();
        prev = fromList->begin();
        curr++;

        for( i=0; i < fromList->size(); i++) {
            
            currOut = (*curr)->y <= miny;
            prevOut = (*prev)->y <= miny;

            TestAndAdd(miny,
                       (*prev)->y, (*prev)->x,
                       (*curr)->y, (*curr)->x,
                       prevOut, currOut,
                       FALSE,
                       *curr,
                       currList);

            curr++; prev++;
            if(curr == fromList->end()) {
                // we've gone past the end, last edge
                curr = fromList->begin();
            }
        } // for bottom

        //
        // Switch
        //
        tempList = fromList;

        fromList->erase(fromList->begin(), fromList->end());
        fromList = currList;
        currList = tempList;
 
        //--------------------------------------------------
        // T O P 
        //--------------------------------------------------

        // prime
        curr = fromList->begin();
        prev = fromList->begin();
        curr++;

        for(i=0; i < fromList->size(); i++) {
            
            currOut = (*curr)->y >= maxy;
            prevOut = (*prev)->y >= maxy;

            TestAndAdd(maxy,
                       (*prev)->y, (*prev)->x,
                       (*curr)->y, (*curr)->x,
                       prevOut, currOut,
                       FALSE,
                       *curr,
                       currList);

            curr++; prev++;
            if(curr == fromList->end()) {
                // we've gone past the end, last edge
                curr = fromList->begin();
            }
        } // for top

        //
        // update vertexCount
        //
        _vertexCount = _vertList->size();

    } // if vertextCount > 2
}

void BoundingPolygon::
TestAndAdd(Real axis,
           Real ax, Real ay,
           Real bx, Real by,
           Bool aOut,
           Bool bOut,
           Bool XY,
           Point2Value *b,
           Point2List *vertList)
{
    if( !(aOut ^ bOut) ) {
        // both out or both in
        if(aOut) {
            // both out
        } else {
            // both in
            // add curr to list
            vertList->push_back( b );
        }
    } else  {
        // crossing
        // intersection, find it
        Real int_y = ay + (by - ay) * (axis - ax) / (bx - ax);
        Real int_x = axis;
        
        if(!XY) {
            // swap x and y since we've actually just calculated the x intersect
            int_x = int_y;
            int_y = axis;
        }

        vertList->push_back( NEW Point2Value(int_x, int_y) );
        
        if( bOut ) {
            // last is in: already added
        } else {
            // curr is in:  add
            vertList->push_back( b );
        }
    }
}

void BoundingPolygon::
ForceTransform()
{
    Assert(FALSE && "Transform optimization not implemented yet");
    #if 0
    if(_xfDirty) {
        Point2List::iterator j = _vertList->begin();

        for(int i=0; i < _vertexCount; i++, j++) {
            (*j) = TransformPoint2Value(xform, *j );
        }
        _xfDirty = FALSE;
        _accumXform = identityTransform2;
    }
    #endif
}


void BoundingPolygon::
Transform(Transform2 *xform)
{
#if 0
    // do this later if we see the need
    // just accumulate, outside in
    _accumXfrom = 
        TimesTransform2Transform2(xform, _accumXform);
    _xfDirty = TRUE;
#else
    Point2List::iterator j = _vertList->begin();
    
    for(int i=0; i < _vertexCount; i++, j++) {
        (*j) = TransformPoint2Value(xform, *j );
    }
#endif
}

const Bbox2 BoundingPolygon::BoundingBox (void)
{
    Point2List::iterator j = _vertList->begin();

    Bbox2 bbox;
    for (int i=0;  i < _vertexCount;  ++i, ++j) {
       bbox.Augment (Demote(**j));
    }

    return bbox;
}

#if BOUNDINGBOX_TIGHTER
const Bbox2 BoundingPolygon::BoundingBoxTighter (Bbox2Ctx &bbctx)
{
    Point2List::iterator j = _vertList->begin();

    Bbox2 bbox;
    Transform2 *xf = bbctx.GetTransform();

    for (int i=0;  i < _vertexCount;  ++i, ++j) {
       bbox.Augment (*TransformPoint2Value(xf, *j));
    }

    return bbox;
}
#endif  // BOUNDINGBOX_TIGHTER



/*****************************************************************************
This procedure gets the Point2 vertices of the polygon in counter-clockwise
order.  This procedure returns the number of vertices that were successfully
loaded into the vertex array.
*****************************************************************************/

int BoundingPolygon::GetPointArray (
    Point2Value **vertArray,       // Destination Vertex Array
    Bool		 want_clockwise,  // True if Vertices Requested in Clockwise Order.
    bool		*flag_reversed)   // Returns Whether The Vertex Order Was Reversed.
{
    if (_vertexCount < 3) return 0;

    // First determine the vertex order of the polygon.

    const Real   epsilon   = 1e-12;             // Comparison Epsilon
    unsigned int vertsleft = _vertexCount - 1;  // Vertices Left to Examine

    Point2List::iterator vit = _vertList->begin();
    vertArray[0] = *vit;

    Point2Value V0 = *(*vit);   // First Vertex.

    Vector2Value A, B;  // These vectors will be used to form the cross product
                        // that tells us the polygon vertex ordering.

    // Find the first available vertex in the polygon that yields a non-zero
    // vector from the first vertex.

    do {
        -- vertsleft;
        ++ vit;
        A = *(*vit) - V0;

    } while (vertsleft && (A.LengthSquared() < (epsilon*epsilon)));

    if (!vertsleft) return 0;    // Bail out if all poly verts were co-linear.

    // Now that we've got a non-zero vector, iterate through the vertices
    // to generate a second vertex vector that yields a non-zero (within
    // epsilon) cross product.

    Real cross;

    do {
        -- vertsleft;
        ++ vit;
        cross = Cross (A, *(*vit)-V0);

    } while (vertsleft && (fabs(cross) < epsilon));

    // Bail out if we've got no vertices left and we didn't find a good cross
    // product.

    if (fabs(cross) < epsilon)
        return 0;

    // If the orientation asked for and the orientation of the vertex array
    // differ, reverse the vertices.  Note that a positive cross product
    // indicates a counter-clockwise orientation.

    bool reverse = (want_clockwise != (cross < 0));
    if (flag_reversed) *flag_reversed = reverse;

    if (reverse) {

        // [v0 v1 v2 ... vn-1 vn]  reverse->  [v0 vn vn-1 ... v2 v1]

        Point2List::reverse_iterator j = _vertList->rbegin();

        for (int i=1;  i < _vertexCount;  ++i, ++j)
            vertArray[i] = *j;

    } else {

        ++ (vit = _vertList->begin());
        for(int i=1;  i < _vertexCount;  ++i, ++vit)
            vertArray[i] = *vit;
    }
    
    return _vertexCount;
}

void BoundingPolygon::
SetBox(const Bbox2 &box)
{
        Assert((_vertexCount == 0) && "Bad Box in BoundingPolygon");
    if (_vertexCount == 0) {
        //
        // insert box, counterclockwise
        //
        _vertList->push_back(NEW Point2Value(box.min.x, box.min.y));
        _vertList->push_back(NEW Point2Value(box.max.x, box.min.y));
        _vertList->push_back(NEW Point2Value(box.max.x, box.max.y));
        _vertList->push_back(NEW Point2Value(box.min.x, box.max.y));

        _vertexCount = 4;
    } 
}
    
void BoundingPolygon::
AddToPolygon(BoundingPolygon &pgon)
{
    Point2List::iterator j = pgon._vertList->begin();
    for(int i=0; i < pgon._vertexCount; i++, j++) {
        _vertList->push_back(*j);
    }
    _vertexCount += pgon._vertexCount;
}

void BoundingPolygon::
AddToPolygon(int numPts, Point2Value **pts)
{
    for(int i=0; i <numPts; i++) {
        _vertList->push_back(pts[i]);
    }
    _vertexCount += numPts;
}

Bool BoundingPolygon::
PtInPolygon(Point2Value *pt)
{
    Assert((_vertexCount > 2) && "Bad vertex count in PtInPolygon");
    
    //
    // Case a ray from 'pt' in positive x.  if it hits
    // even number of line segments, return FALSE
    // odd number of line segments, return TRUE
    //
    Point2List::iterator j0 = _vertList->begin();
    Point2List::iterator j1 = j0;j1++;
    _vertList->push_back(*j0);
    Point2Value *a = *j0;
    Point2Value *b  = *j1;
    LONG hits = 0;
    for(int i=0; i < _vertexCount; i++, j0++, j1++) {

        a = *j0; b = *j1;
        
        //printf("%d: (%1.1f %1.1f)  (%1.1f, %1.1f)",i, a->x, a->y, b->x, b->y);

        //
        // if at least one point of the segment is to the right
        // of 'pt'.
        //
        Bool ax = (a->x >= pt->x);
        Bool bx = (b->x >= pt->x);
        Bool ay = (a->y >= pt->y);
        Bool by = (b->y >= pt->y);

        //printf(":: %d%d %d%d ",ax,ay,bx,by);
        if( (ax ^ bx) && (ay ^ by) ) {
            // use cross product test

            // If the cross product: a X b  is positive and
            // 'a' is below 'b' then there's a hit.
            // If the cross product is negative and 'a' is
            // above 'b', then there's a hit.
            // So, if  p = cross>0
            // and     q = a is below b
            // then:   hit = pq OR !p!q
            // which is:   = !(p XOR q)
            Real cross = CrossVector2Vector2(
                MinusPoint2Point2(a,pt),
                MinusPoint2Point2(b,pt));
                
            Bool pos = cross > 0.0;
            hits += !(pos ^ by);
            //printf(" crosses: %f %d hit:%d\n", cross, pos, !(pos ^ by));
        } else {
            // check for trivial accept
            if( ax && bx && ((!ay && by) || (ay && !by))) {
                hits++;
                //printf(" trivial accept\n");
            } else {
                //printf("\n");
            }
        }
                
    }

    _vertList->pop_back();

    return IsOdd(hits);
}

void BoundingPolygon::DoKids(GCFuncObj proc)
{
    (*proc)(_accumXform);
    for (list<Point2Value*>::iterator i=_vertList->begin();
         i != _vertList->end(); i++)
        (*proc)(*i);
}

#if _DEBUG
void BoundingPolygon::_debugOnly_Print()
{
    OutputDebugString("--> BoundingPolygon print\n");
    list<Point2Value*>::iterator i=_vertList->begin();
    for (int j=0;  i != _vertList->end(); j++, i++) {
        TraceTag((tagError, "   (%d)  %f, %f\n",
                  j,
                  (*i)->x,
                  (*i)->y));
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\matutil.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

Abstract:
    Transformation matrix utilities.

*******************************************************************************/

#include "headers.h"
#include <float.h>

#include "appelles/common.h"
#include "privinc/matutil.h"
#include "privinc/except.h"
#include "privinc/debug.h"


    /*********************************/
    /*** Local Function Prototypes ***/
    /*********************************/

static void adjoint(const Apu4x4Matrix *in, Apu4x4Matrix *out);
static Real det3x3(Real a1, Real a2, Real a3,
              Real b1, Real b2, Real b3,
              Real c1, Real c2, Real c3);
static bool inverse(const Apu4x4Matrix *in, Apu4x4Matrix *out);
static bool inverse3x3(const Apu4x4Matrix& in, Apu4x4Matrix& out);


    /****************************/
    /*** Constant Definitions ***/
    /****************************/

// Make the SINGULARITY_THRESHOLD constant quite small indeed, so that
// non-singular matrices whose elements themselves are quite small are
// not reported as singular matrices.
const Real SINGULARITY_THRESHOLD = 1.e-80;

const Apu4x4Matrix apuIdentityMatrix =
{
  {
    {1, 0, 0, 0},
    {0, 1, 0, 0},
    {0, 0, 1, 0},
    {0, 0, 0, 1}
  },
  Apu4x4Matrix::IDENTITY_E,
  1
};

    // This is a table of return types for matrix multiplies.  table[a][b] is
    // the type of A * B, where a and b are the types of A and B respectively.

const Apu4x4Matrix::form_e
Apu4x4Matrix::MultiplyReturnTypes[END_OF_FORM_E][END_OF_FORM_E] =
{
    // Uninitialized
    {
        UNINITIALIZED_E,    // uninitialized * uninitialized
        UNINITIALIZED_E,    // uninitialized * identity
        UNINITIALIZED_E,    // uninitialized * translation
        UNINITIALIZED_E,    // uninitialized * upper3x3
        UNINITIALIZED_E,    // uninitialized * affine
        UNINITIALIZED_E     // uninitialized * perspective
    },

    // identity
    {
        UNINITIALIZED_E,    // identity * uninitialized
        IDENTITY_E,         // identity * identity
        TRANSLATE_E,        // identity * translation
        UPPER_3X3_E,        // identity * upper3x3
        AFFINE_E,           // identity * affine
        PERSPECTIVE_E       // identity * perspective
    },

    // translate
    {
        UNINITIALIZED_E,    // translation * uninitialized
        TRANSLATE_E,        // translation * identity
        TRANSLATE_E,        // translation * translation
        AFFINE_E,           // translation * upper3x3
        AFFINE_E,           // translation * affine
        PERSPECTIVE_E       // translation * perspective
    },

    // upper3x3
    {
        UNINITIALIZED_E,    // upper3x3 * uninitialized
        UPPER_3X3_E,        // upper3x3 * identity
        AFFINE_E,           // upper3x3 * translation
        UPPER_3X3_E,        // upper3x3 * upper3x3
        AFFINE_E,           // upper3x3 * affine
        PERSPECTIVE_E       // upper3x3 * perspective
    },

    // affine
    {
        UNINITIALIZED_E,    // affine * uninitialized
        AFFINE_E,           // affine * identity
        AFFINE_E,           // affine * translation
        AFFINE_E,           // affine * upper3x3
        AFFINE_E,           // affine * affine
        PERSPECTIVE_E       // affine * perspective
    },

    // perspective
    {
        UNINITIALIZED_E,    // perspective * uninitialized
        PERSPECTIVE_E,      // perspective * identity
        PERSPECTIVE_E,      // perspective * translation
        PERSPECTIVE_E,      // perspective * upper3x3
        PERSPECTIVE_E,      // perspective * affine
        PERSPECTIVE_E       // perspective * perspective
    }
};


    // This array contains the string versions of the matrix forms.

const char* const Apu4x4Matrix::form_s [END_OF_FORM_E] =
{
    "UNINITIALIZED_E",
    "IDENTITY_E",
    "TRANSLATE_E",
    "UPPER_3X3_E",
    "AFFINE_E",
    "PERSPECTIVE_E"
};



#if _USE_PRINT
/*****************************************************************************
This method prints the text representation of the Apu4x4Matrix to the given
ostream.
*****************************************************************************/

ostream& Apu4x4Matrix::Print (ostream& os) const
{
    os << "Apu4x4Matrix (form=";

    if ((form < 0) || (form >= END_OF_FORM_E))
        os << (int)form;
    else
        os << form_s[form];

    os << ", is_rigid=" << (int)is_rigid;

    os << ",";

    for (int ii=0;  ii < 4;  ++ii)
    {   os << "\n    "
           << m[ii][0] << ", " << m[ii][1] << ", "
           << m[ii][2] << ", " << m[ii][3];
    }

    return os << ")\n" << flush;
}
#endif



/*****************************************************************************
Sets the Apu4x4Matrix to the identity matrix.
*****************************************************************************/

void Apu4x4Matrix::SetIdentity ()
{
    *this = apuIdentityMatrix;
}



/*****************************************************************************
Automatically characterize 4x4 and set the transform type.
*****************************************************************************/

void Apu4x4Matrix::SetType (void)
{
    // We know the matrix is rigid if it's identity or pure translate.
    // If it's upper_3x3 or affine, then we'd have to analyze the matrix.  The
    // brute force method takes 18 multiplies and 6 square roots, and possibly
    // for naught, so we'll just punt by default.  The result is that we take
    // the hard approach if we need to find the inverse.

    is_rigid = false;

    // The matrix is perspective if the bottom row is not [0 0 0 1].

    if ((m[3][0] != 0) || (m[3][1] != 0) || (m[3][2] != 0) || (m[3][3] != 1))
    {
        form = PERSPECTIVE_E;
    }
    else if ((m[0][3] == 0) && (m[1][3] == 0) && (m[2][3] == 0))
    {
        // The translate column is [0 0 0] (no translate).  If the upper
        // 3x3 is also canonical, then it's an identity matrix.

        if (  (m[0][0] == 1) && (m[0][1] == 0) && (m[0][2] == 0)
           && (m[1][0] == 0) && (m[1][1] == 1) && (m[1][2] == 0)
           && (m[2][0] == 0) && (m[2][1] == 0) && (m[2][2] == 1))
        {
            form = IDENTITY_E;      // Special case of upper 3x3.
            is_rigid = true;
        }
        else
        {
            form = UPPER_3X3_E;
        }
    }
    else
    {
        // The matrix has translation components.

        if (  (m[0][0] == 1) && (m[0][1] == 0) && (m[0][2] == 0)
           && (m[1][0] == 0) && (m[1][1] == 1) && (m[1][2] == 0)
           && (m[2][0] == 0) && (m[2][1] == 0) && (m[2][2] == 1))
        {
            form = TRANSLATE_E;     // Special case of affine.
            is_rigid = true;
        }
        else
        {
            form = AFFINE_E;
        }
    }
}



/*****************************************************************************
This function post-concatenates a translation to the Apu4x4Matrix.
*****************************************************************************/

void Apu4x4Matrix::PostTranslate (Real x, Real y, Real z)
{
    Real a03;
    Real a13;
    Real a23;
    Real a33 = 1.0;

    Assert((form != UNINITIALIZED_E) && "Translate of uninitialized matrix.");

    if (x == 0.0 && y == 0.0 && z == 0.0) return;

    switch (form)
    {
        case UNINITIALIZED_E:
            return;

        case IDENTITY_E:
            a03 = x;
            a13 = y;
            a23 = z;
            break;

        case TRANSLATE_E:
            a03 = m[0][3] + x;
            a13 = m[1][3] + y;
            a23 = m[2][3] + z;
            break;

        case UPPER_3X3_E:
            a03 = x * m[0][0] + y * m[0][1] + z * m[0][2];
            a13 = x * m[1][0] + y * m[1][1] + z * m[1][2];
            a23 = x * m[2][0] + y * m[2][1] + z * m[2][2];
            break;

        case AFFINE_E:
            a03 = x * m[0][0] + y * m[0][1] + z * m[0][2] + m[0][3];
            a13 = x * m[1][0] + y * m[1][1] + z * m[1][2] + m[1][3];
            a23 = x * m[2][0] + y * m[2][1] + z * m[2][2] + m[2][3];
            break;

        default:
            Assert((form == PERSPECTIVE_E) && "Unrecognized matrix type.");
            a03 = x * m[0][0] + y * m[0][1] + z * m[0][2] + m[0][3];
            a13 = x * m[1][0] + y * m[1][1] + z * m[1][2] + m[1][3];
            a23 = x * m[2][0] + y * m[2][1] + z * m[2][2] + m[2][3];
            a33 = x * m[3][0] + y * m[3][1] + z * m[3][2] + m[3][3];
            break;
    }

    m[0][3] = a03;
    m[1][3] = a13;
    m[2][3] = a23;
    m[3][3] = a33;

    form = MultiplyReturnTypes [form][TRANSLATE_E];
}



/*****************************************************************************
This function post-concatenates a scaling matrix to the Apu4x4Matrix.
*****************************************************************************/

void Apu4x4Matrix::PostScale (Real x, Real y, Real z)
{
    if ((x == 1) && (y == 1) && (z == 1)) return;

    Assert((form != UNINITIALIZED_E) && "Scaling of uninitialized matrix.");

    switch (form)
    {
        case UNINITIALIZED_E:
            return;

        case IDENTITY_E:
        case TRANSLATE_E:
            m[0][0] = x;
            m[1][1] = y;
            m[2][2] = z;
            break;

        case AFFINE_E:
        case UPPER_3X3_E:
            m[0][0] *= x;   m[0][1] *= y;   m[0][2] *= z;
            m[1][0] *= x;   m[1][1] *= y;   m[1][2] *= z;
            m[2][0] *= x;   m[2][1] *= y;   m[2][2] *= z;
            break;

        default:
            Assert((form == PERSPECTIVE_E) && "Unrecognized matrix type.");
            m[0][0] *= x;   m[0][1] *= y;   m[0][2] *= z;
            m[1][0] *= x;   m[1][1] *= y;   m[1][2] *= z;
            m[2][0] *= x;   m[2][1] *= y;   m[2][2] *= z;
            m[3][0] *= x;   m[3][1] *= y;   m[3][2] *= z;
            break;
    }

    form = MultiplyReturnTypes [form][UPPER_3X3_E];
    is_rigid = 0;
}



/*****************************************************************************
This function takes an Apu4x4Matrix, multiplies the given vector, and then
places the result in the 'result' parameter.  Note that the vector is
treated as a point, in that the translational component is taken into
account.
*****************************************************************************/

void Apu4x4Matrix::ApplyAsPoint(const ApuVector3& xv, ApuVector3& result) const
{
    Real x = xv.xyz[0];
    Real y = xv.xyz[1];
    Real z = xv.xyz[2];
    Real w;

    switch (form)
    {
        case UNINITIALIZED_E:
            result = apuZero3;
            break;

        case IDENTITY_E:
            result = xv;
            break;

        case TRANSLATE_E:
            result.xyz[0] = x + m[0][3];
            result.xyz[1] = y + m[1][3];
            result.xyz[2] = z + m[2][3];
            break;

        case UPPER_3X3_E:
            result.xyz[0] = m[0][0] * x + m[0][1] * y + m[0][2] * z;
            result.xyz[1] = m[1][0] * x + m[1][1] * y + m[1][2] * z;
            result.xyz[2] = m[2][0] * x + m[2][1] * y + m[2][2] * z;
            break;

        case AFFINE_E:
            result.xyz[0] = m[0][0] * x + m[0][1] * y + m[0][2] * z + m[0][3];
            result.xyz[1] = m[1][0] * x + m[1][1] * y + m[1][2] * z + m[1][3];
            result.xyz[2] = m[2][0] * x + m[2][1] * y + m[2][2] * z + m[2][3];
            break;

        case PERSPECTIVE_E:
            result.xyz[0] = m[0][0] * x + m[0][1] * y + m[0][2] * z + m[0][3];
            result.xyz[1] = m[1][0] * x + m[1][1] * y + m[1][2] * z + m[1][3];
            result.xyz[2] = m[2][0] * x + m[2][1] * y + m[2][2] * z + m[2][3];
            w = m[3][0] * x + m[3][1] * y + m[3][2] * z + m[3][3];
            result.xyz[0] /= w;
            result.xyz[1] /= w;
            result.xyz[2] /= w;
            break;

        default:
            // raise exception
            ;
    }
}


/*****************************************************************************
This function takes an Apu4x4Matrix, multiplies the given vector, and then
places the result in the 'result' parameter.  Note that the vector is
treated as a vector in an affine space, in that the translational
component is ignored.
*****************************************************************************/

void Apu4x4Matrix::ApplyAsVector(const ApuVector3& xv,
                                 ApuVector3& result) const
{
    Real x = xv.xyz[0];
    Real y = xv.xyz[1];
    Real z = xv.xyz[2];
    Real w;

    switch (form)
    {
        case UNINITIALIZED_E:
            result = apuZero3;
            break;

        // Ignore translational component.
        case IDENTITY_E:
        case TRANSLATE_E:
            result = xv;
            break;

        case UPPER_3X3_E:
        case AFFINE_E:
            result.xyz[0] = m[0][0] * x + m[0][1] * y + m[0][2] * z;
            result.xyz[1] = m[1][0] * x + m[1][1] * y + m[1][2] * z;
            result.xyz[2] = m[2][0] * x + m[2][1] * y + m[2][2] * z;
            break;

        case PERSPECTIVE_E:
            result.xyz[0] = m[0][0] * x + m[0][1] * y + m[0][2] * z;
            result.xyz[1] = m[1][0] * x + m[1][1] * y + m[1][2] * z;
            result.xyz[2] = m[2][0] * x + m[2][1] * y + m[2][2] * z;
            w = m[3][0] * x + m[3][1] * y + m[3][2] * z;
            result.xyz[0] /= w;
            result.xyz[1] /= w;
            result.xyz[2] /= w;
            break;

        default:
            // raise exception
            ;
    }
}



/*****************************************************************************
This method transforms a plane with the 4x4 matrix.  
*****************************************************************************/

bool Apu4x4Matrix::TransformPlane (
    Real A, Real B, Real C, Real D,   // Plane Equation Parameters
    Real result[4])                   // Resulting Plane Parameters
    const
{
    bool ok = true;
    
    Apu4x4Matrix inverse;

    switch (form)
    {
        case UNINITIALIZED_E:
            Assert (!"Attempt to transform plane by uninitialized matrix.");
            break;

        case IDENTITY_E:
            result[0] = A;
            result[1] = B;
            result[2] = C;
            result[3] = D;
            break;

        case TRANSLATE_E:
            result[0] = A;
            result[1] = B;
            result[2] = C;
            result[3] = D - A*m[0][3] - B*m[1][3] - C*m[2][3];
            break;

        case UPPER_3X3_E:
            ok = ApuInverse (*this, inverse);
            result[0] = A*inverse.m[0][0] + B*inverse.m[1][0] + C*inverse.m[2][0];
            result[1] = A*inverse.m[0][1] + B*inverse.m[1][1] + C*inverse.m[2][1];
            result[2] = A*inverse.m[0][2] + B*inverse.m[1][2] + C*inverse.m[2][2];
            result[3] = D;
            break;

        case AFFINE_E:
            ok = ApuInverse (*this, inverse);
            result[0] = A*inverse.m[0][0] + B*inverse.m[1][0] + C*inverse.m[2][0];
            result[1] = A*inverse.m[0][1] + B*inverse.m[1][1] + C*inverse.m[2][1];
            result[2] = A*inverse.m[0][2] + B*inverse.m[1][2] + C*inverse.m[2][2];
            result[3] = A*inverse.m[0][3] + B*inverse.m[1][3] + C*inverse.m[2][3] + D;
            break;

        case PERSPECTIVE_E:
            ok = ApuInverse (*this, inverse);
            result[0] = A*inverse.m[0][0] + B*inverse.m[1][0] + C*inverse.m[2][0] + D*inverse.m[3][0];
            result[1] = A*inverse.m[0][1] + B*inverse.m[1][1] + C*inverse.m[2][1] + D*inverse.m[3][1];
            result[2] = A*inverse.m[0][2] + B*inverse.m[1][2] + C*inverse.m[2][2] + D*inverse.m[3][2];
            result[3] = A*inverse.m[0][3] + B*inverse.m[1][3] + C*inverse.m[2][3] + D;
            break;
    }

    return ok;
}



/*****************************************************************************
This method returns the full determinant of the matrix.
*****************************************************************************/

Real Apu4x4Matrix::Determinant (void) const
{
    Real result;

    switch (form)
    {
        default:
        case UNINITIALIZED_E:
        {   AssertStr (0, "Determinant called on uninitialized matrix.");
            result = 0;
            break;
        }

        case IDENTITY_E:
        case TRANSLATE_E:
        {   result = 1;
            break;
        }

        case UPPER_3X3_E:
        case AFFINE_E:
        {   result = m[0][0] * (m[1][1]*m[2][2] - m[2][1]*m[1][2])
                   - m[1][0] * (m[0][1]*m[2][2] - m[2][1]*m[0][2])
                   + m[2][0] * (m[0][1]*m[1][2] - m[1][1]*m[0][2]);
            break;
        }

        case PERSPECTIVE_E:
        {
            // Aliases for readability (optimized out)

            const Real
                &m00=m[0][0],  &m01=m[0][1],  &m02=m[0][2],  &m03=m[0][3],
                &m10=m[1][0],  &m11=m[1][1],  &m12=m[1][2],  &m13=m[1][3],
                &m20=m[2][0],  &m21=m[2][1],  &m22=m[2][2],  &m23=m[2][3],
                &m30=m[3][0],  &m31=m[3][1],  &m32=m[3][2],  &m33=m[3][3];

            result = (m00*m11 - m10*m01) * (m22*m33 - m32*m23)
                   + (m20*m01 - m00*m21) * (m12*m33 - m32*m13)
                   + (m00*m31 - m30*m01) * (m12*m23 - m22*m13)
                   + (m10*m21 - m20*m11) * (m02*m33 - m32*m03)
                   + (m30*m11 - m10*m31) * (m02*m23 - m22*m03)
                   + (m20*m31 - m30*m21) * (m02*m13 - m12*m03);

            break;
        }
    }

    return result;
}



/*****************************************************************************
This routine returns true if the matrix is orthogonal (if all three basis
vectors are perpendicular to each other).
*****************************************************************************/

bool Apu4x4Matrix::Orthogonal (void) const
{
    const Real e = 1e-10;

    // X.Y =~ 0?

    if (fabs(m[0][0]*m[0][1] + m[1][0]*m[1][1] + m[2][0]*m[2][1]) > e)
        return false;

    // X.Z =~ 0?

    if (fabs(m[0][0]*m[0][2] + m[1][0]*m[1][2] + m[2][0]*m[2][2]) > e)
        return false;

    // Y.Z =~ 0?

    if (fabs(m[0][1]*m[0][2] + m[1][1]*m[1][2] + m[2][1]*m[2][2]) > e)
        return false;

    return true;
}



/*****************************************************************************
This function generates an Apu4x4Matrix that represents the specified
translation.
*****************************************************************************/

void ApuTranslate (
    Real          x_delta,
    Real          y_delta,
    Real          z_delta,
    bool          pixelMode,
    Apu4x4Matrix& result)
{
    result      = apuIdentityMatrix;
    result.form = Apu4x4Matrix::TRANSLATE_E;

    result.m[0][3] = x_delta;
    result.m[1][3] = y_delta;
    result.m[2][3] = z_delta;

    result.pixelMode = pixelMode;
}



/*****************************************************************************
This function generates an Apu4x4Matrix that represents the given scaling.
*****************************************************************************/

void ApuScale (
    Real          x_scale,
    Real          y_scale,
    Real          z_scale,
    Apu4x4Matrix& result)
{
    result = apuIdentityMatrix;

    if ((x_scale != 1) || (y_scale != 1) || (z_scale != 1))
    {   result.form = Apu4x4Matrix::UPPER_3X3_E;
        result.is_rigid = 0;
        result.m[0][0] = x_scale;
        result.m[1][1] = y_scale;
        result.m[2][2] = z_scale;
    }
}



/*****************************************************************************
This function loads the given result matrix with a general rotation.  The
rotation is counter-clockwise as you look from 'av' to the origin.
*****************************************************************************/

void ApuRotate (
    Real angle,                 // Angle of Rotation (Radians)
    Real Ax, Real Ay, Real Az,  // Coordinates of Axis of Rotation
    Apu4x4Matrix &result)       // Result Matrix
{
    result = apuIdentityMatrix;
    
    Real length = sqrt (Ax*Ax + Ay*Ay + Az*Az);

    // If length of rotation axis == 0, then just return identity. 

    if (length > SINGULARITY_THRESHOLD) {
        
        result.form     = Apu4x4Matrix::UPPER_3X3_E;
        result.is_rigid = 1;

        // Normalize the axis of rotation.
        Ax /= length;
        Ay /= length;
        Az /= length;

        Real sine   = sin (angle);
        Real cosine = cos (angle);

        Real ab = Ax * Ay * (1 - cosine);
        Real bc = Ay * Az * (1 - cosine);
        Real ca = Az * Ax * (1 - cosine);

        Real t = Ax * Ax;

        result.m[0][0] = t + cosine * (1 - t);
        result.m[1][2] = bc - Ax * sine;
        result.m[2][1] = bc + Ax * sine;

        t = Ay * Ay;
        result.m[1][1] = t + cosine * (1 - t);
        result.m[0][2] = ca + Ay * sine;
        result.m[2][0] = ca - Ay * sine;

        t = Az * Az;
        result.m[2][2] = t + cosine * (1 - t);
        result.m[0][1] = ab - Az * sine;
        result.m[1][0] = ab + Az * sine;

    }
}



/*****************************************************************************
The following three functions generate rotation transformations for the X, Y,
and Z axes.
*****************************************************************************/

void ApuRotateX (
    Real          angle,    // Angle of Rotation (Radians)
    Apu4x4Matrix &result)   // Resulting 4x4 Matrix
{
    result          = apuIdentityMatrix;
    result.form     = Apu4x4Matrix::UPPER_3X3_E;
    result.is_rigid = 1;

    result.m[1][1] = result.m[2][2] = cos (angle);
    result.m[1][2] = - (result.m[2][1] = sin (angle));
}


void ApuRotateY (
    Real          angle,    // Angle of Rotation (Radians)
    Apu4x4Matrix &result)   // Resulting 4x4 Matrix
{
    result          = apuIdentityMatrix;
    result.form     = Apu4x4Matrix::UPPER_3X3_E;
    result.is_rigid = 1;

    result.m[0][0] = result.m[2][2] = cos (angle);
    result.m[2][0] = - (result.m[0][2] = sin (angle));
}


void ApuRotateZ (
    Real          angle,    // Angle of Rotation (Radians)
    Apu4x4Matrix &result)   // Resulting 4x4 Matrix
{
    result          = apuIdentityMatrix;
    result.form     = Apu4x4Matrix::UPPER_3X3_E;
    result.is_rigid = 1;

    result.m[0][0] = result.m[1][1] = cos (angle);
    result.m[0][1] = - (result.m[1][0] = sin (angle));
}



/*****************************************************************************
This function loads 'result' with the shearing matrix defined by the six
values passed.
*****************************************************************************/

void ApuShear (
    Real a, Real b,        // Shear X Axis
    Real c, Real d,        // Shear Y Axis
    Real e, Real f,        // Shear Z Axis
    Apu4x4Matrix &result)
{
    result          = apuIdentityMatrix;
    result.form     = Apu4x4Matrix::UPPER_3X3_E;
    result.is_rigid = 0;

    // [ 1  c  e  0 ]
    // [ a  1  f  0 ]
    // [ b  d  1  0 ]
    // [ 0  0  0  1 ]

    result.m[1][0] = a;
    result.m[2][0] = b;

    result.m[0][1] = c;
    result.m[2][1] = d;

    result.m[0][2] = e;
    result.m[1][2] = f;
}



/*****************************************************************************
This function multiplies two Apu4x4Matrix values together and stores the
result into 'result'.
*****************************************************************************/

void ApuMultiply (
    const Apu4x4Matrix& a,
    const Apu4x4Matrix& b,
          Apu4x4Matrix& result)
{
    // Case 1: multiply into B

    if (&result == &b)
    {
        Apu4x4Matrix tmp = b;
        ApuMultiply(a, b, tmp);
        result = tmp;
    }

    // Case 2: multiply into A

    else if (&result == &a)
    {
        Apu4x4Matrix tmp = a;
        ApuMultiply(a, b, tmp);
        result = tmp;
    }

    // Case 3 & 4: Identity transformations

    else if (a.form <= Apu4x4Matrix::IDENTITY_E)
    {
        result = b;
    }
    else if (b.form <= Apu4x4Matrix::IDENTITY_E)
    {
        result = a;
    }

    // Case 5: Translation

    else if (b.form == Apu4x4Matrix::TRANSLATE_E)
    {
        result = a;
        result.PostTranslate(b.m[0][3], b.m[1][3], b.m[2][3]);
    }

    // Case 6: Affine transformation

    else if (   (a.form < Apu4x4Matrix::PERSPECTIVE_E)
             && (b.form < Apu4x4Matrix::PERSPECTIVE_E))
    {
        Real s;

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 4; j++)
            {
                s = a.m[i][0] * b.m[0][j];
                s += a.m[i][1] * b.m[1][j];
                s += a.m[i][2] * b.m[2][j];
                result.m[i][j] = s;
            }
        }
        result.m[0][3] += a.m[0][3];
        result.m[1][3] += a.m[1][3];
        result.m[2][3] += a.m[2][3];

        result.m[3][0] = 0.0;
        result.m[3][1] = 0.0;
        result.m[3][2] = 0.0;
        result.m[3][3] = 1.0;
        result.form = Apu4x4Matrix::MultiplyReturnTypes[a.form][b.form];
        result.is_rigid = a.is_rigid && b.is_rigid;
    }

    // Default case: fully general perspective transformation

    else
    {
        Real s;

        for (int i = 0; i < 4; i++)
        {
            for (int j = 0; j < 4; j++)
            {
                s = a.m[i][0] * b.m[0][j]
                  + a.m[i][1] * b.m[1][j]
                  + a.m[i][2] * b.m[2][j]
                  + a.m[i][3] * b.m[3][j];
                result.m[i][j] = s;
            }
        }
        result.is_rigid = a.is_rigid && b.is_rigid;
        result.form = Apu4x4Matrix::PERSPECTIVE_E;
    }
}



/*****************************************************************************
*****************************************************************************/

bool ApuInverse (const Apu4x4Matrix& m, Apu4x4Matrix& result)
{
    bool ok = true;
    if (m.form == Apu4x4Matrix::UNINITIALIZED_E)
    {
        result.form = Apu4x4Matrix::UNINITIALIZED_E;
    }
    else if (m.form == Apu4x4Matrix::IDENTITY_E)
    {
        result = apuIdentityMatrix;
    }
    else if (m.form == Apu4x4Matrix::TRANSLATE_E)
    {
        result = apuIdentityMatrix;
        result.m[0][3] = - m.m[0][3];
        result.m[1][3] = - m.m[1][3];
        result.m[2][3] = - m.m[2][3];
    }
    else if (m.form == Apu4x4Matrix::UPPER_3X3_E)
    {
        result = apuIdentityMatrix;
        if (m.is_rigid)
        {
            // special orthogonal: inverse is transpose
            ApuTranspose(m, result, 3);
        }
        else
        {
            // 3x3 inverse
            ok = inverse3x3(m, result);
        }
    }
    else
    {
        ok = inverse(&m, &result);
    }
    result.form = m.form;
    result.is_rigid = m.is_rigid;

    return ok;
}



/*****************************************************************************
*****************************************************************************/

void ApuTranspose (const Apu4x4Matrix& m, Apu4x4Matrix& result, int order)
{
    for (int i = 0; i < order; i++)
    {
        for (int j = 0; j < order; j++)
        {
            result.m[i][j] = m.m[j][i];
        }
    }
}



/*****************************************************************************
*****************************************************************************/

Real ApuDeterminant (const Apu4x4Matrix& m)
{
    return m.Determinant();
}

bool ApuIsSingular (const Apu4x4Matrix& m)
{
    // Calculate the 4x4 determinant.  If the determinant is zero, then the
    // inverse matrix is not unique.

    Real det = m.Determinant();

    return (fabs(det) < SINGULARITY_THRESHOLD);
}

/*****************************************************************************
Matrix Inversion, by Richard Carling, Graphics Gems I

NOTE:  Row reduction is faster in the 4x4 case.  If this becomes a noticeable
bottle neck during profiling, then change.
*****************************************************************************/


static bool
inverse3x3 (const Apu4x4Matrix& in, Apu4x4Matrix& out)
{
    bool ok;
    
    Real a00 = in.m[0][0];
    Real a01 = in.m[0][1];
    Real a02 = in.m[0][2];
    Real a10 = in.m[1][0];
    Real a11 = in.m[1][1];
    Real a12 = in.m[1][2];
    Real a20 = in.m[2][0];
    Real a21 = in.m[2][1];
    Real a22 = in.m[2][2];
    Real det = det3x3 (a00, a01, a02, a10, a11, a12, a20, a21, a22);

    if (fabs(det) < SINGULARITY_THRESHOLD) {

        out = apuIdentityMatrix;
        DASetLastError(E_FAIL, IDS_ERR_INVERT_SINGULAR_MATRIX);
        ok = false;

    } else {

        out.m[0][0] = (- (a12 * a21) + a11 * a22) / det;
        out.m[0][1] = (a02 * a21 - a01 * a22) / det;
        out.m[0][2] = (- (a02 * a11) + a01 * a12) / det;
        out.m[1][0] = (a12 * a20 - a10 * a22) / det;
        out.m[1][1] = (- (a02 * a20) + a00 * a22) / det;
        out.m[1][2] = (a02 * a10 - a00 * a12) / det;
        out.m[2][0] = (- (a11 * a20) + a10 * a21) / det;
        out.m[2][1] = (a01 * a20 - a00 * a21) / det;
        out.m[2][2] = (- (a01 * a10) + a00 * a11) / det;
        ok = true;
    }

    return ok;
}



/*****************************************************************************
inverse (original_matrix, inverse_matrix)

Calculate the inverse of a 4x4 matrix

         -1     1
        A  = -------- adjoint(A)
              det(A)
*****************************************************************************/

static bool
inverse (const Apu4x4Matrix *in, Apu4x4Matrix *out)
{
    int  i, j;
    Real det;
    bool ok = true;
    
    /* calculate the adjoint matrix */

    adjoint (in, out);

    // Calculate the 4x4 determinant.  If the determinant is zero, then the
    // inverse matrix is not unique.

    det = in->Determinant();

    if (fabs(det) < SINGULARITY_THRESHOLD) {
        *out = apuIdentityMatrix;
        DASetLastError(E_FAIL, IDS_ERR_INVERT_SINGULAR_MATRIX);
        ok = false;
    }

    /* scale the adjoint matrix to get the inverse */

    for (i=0; i<4; i++)
        for(j=0; j<4; j++)
            out->m[i][j] = out->m[i][j] / det;

    return ok;
}



/*****************************************************************************
adjoint (original_matrix, inverse_matrix)

Calculate the adjoint of a 4x4 matrix

Let  a   denote the minor determinant of matrix A obtained by deleting the ith
      ij

row and jth column from A.

                    i+j
     Let  b   = (-1)    a
           ij            ji

The matrix B = (b  ) is the adjoint of A.
                 ij
*****************************************************************************/

static void adjoint (const Apu4x4Matrix *in, Apu4x4Matrix *out)
{
    Real a1, a2, a3, a4, b1, b2, b3, b4;
    Real c1, c2, c3, c4, d1, d2, d3, d4;

    // Assign to individual variable names to aid selecting correct values.

    a1 = in->m[0][0]; b1 = in->m[0][1];
    c1 = in->m[0][2]; d1 = in->m[0][3];

    a2 = in->m[1][0]; b2 = in->m[1][1];
    c2 = in->m[1][2]; d2 = in->m[1][3];

    a3 = in->m[2][0]; b3 = in->m[2][1];
    c3 = in->m[2][2]; d3 = in->m[2][3];

    a4 = in->m[3][0]; b4 = in->m[3][1];
    c4 = in->m[3][2]; d4 = in->m[3][3];


    // Row column labeling reversed since we transpose rows & columns.

    out->m[0][0]  =   det3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);
    out->m[1][0]  = - det3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);
    out->m[2][0]  =   det3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);
    out->m[3][0]  = - det3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);

    out->m[0][1]  = - det3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);
    out->m[1][1]  =   det3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);
    out->m[2][1]  = - det3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);
    out->m[3][1]  =   det3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);

    out->m[0][2]  =   det3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);
    out->m[1][2]  = - det3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);
    out->m[2][2]  =   det3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);
    out->m[3][2]  = - det3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);

    out->m[0][3]  = - det3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);
    out->m[1][3]  =   det3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);
    out->m[2][3]  = - det3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);
    out->m[3][3]  =   det3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);
}



/*****************************************************************************
Real = det3x3( a1, a2, a3, b1, b2, b3, c1, c2, c3)

Calculate the determinant of a 3x3 matrix in the form

     | a1,  b1,  c1 |
     | a2,  b2,  c2 |
     | a3,  b3,  c3 |
*****************************************************************************/

static Real det3x3 (
    Real a1, Real a2, Real a3,
    Real b1, Real b2, Real b3,
    Real c1, Real c2, Real c3)
{
    Real ans;

    ans = a1 * (b2*c3 - b3*c2)
        - b1 * (a2*c3 - a3*c2)
        + c1 * (a2*b3 - a3*b2);

    return ans;
}



/*****************************************************************************
This routine examines the 4x4 matrix to ensure that it's valid (useful for
debug assertions.
*****************************************************************************/

#if _DEBUG

bool Valid (const Apu4x4Matrix& matrix)
{
    // Do an if-test rather than a direct return so we can set a breakpoint
    // on failure.

    if ((matrix.form != Apu4x4Matrix::UNINITIALIZED_E)
        && _finite (matrix.m[0][0])
        && _finite (matrix.m[0][1])
        && _finite (matrix.m[0][2])
        && _finite (matrix.m[0][3])
        && _finite (matrix.m[1][0])
        && _finite (matrix.m[1][1])
        && _finite (matrix.m[1][2])
        && _finite (matrix.m[1][3])
        && _finite (matrix.m[2][0])
        && _finite (matrix.m[2][1])
        && _finite (matrix.m[2][2])
        && _finite (matrix.m[2][3])
        && _finite (matrix.m[3][0])
        && _finite (matrix.m[3][1])
        && _finite (matrix.m[3][2])
        && _finite (matrix.m[3][3]))

    {   return true;
    }
    else
    {   return false;
    }
}


void CheckMatrix (const Apu4x4Matrix& matrix, char *file, int line)
{
    if (!Valid(matrix))
    {
        TraceTag ((tagWarning,
            "!!! Invalid matrix detected at %s[%d].", file, line));

        if (IsTagEnabled(tagMathMatrixInvalid))
        {   F3DebugBreak();
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\quati.cpp ===
/*++

Module Name:


Abstract:

--*/

#include "headers.h"

#ifdef QUATERNIONS_REMOVED_FOR_NOW

#include <appelles/common.h>
#include "privinc/vecutil.h"
#include "privinc/vec3i.h"
#include <appelles/xform.h>
#include <appelles/vec3.h>
#include <appelles/quat.h>
#include <privinc/quati.h>

const Quaternion *identityQuaternion = Quaternion *(
    new Quaternion(1.0, XyzVector3(0,0,0), 0, XyzVector3(0,0,0)));

// Private functions: not sure what use these are...
Quaternion *Normalize (Quaternion *q);
Real Length (Quaternion *q);
Real Dot (Quaternion *a, Quaternion *b);
Quaternion *operator+ (Quaternion *a, Quaternion *b);
Quaternion *operator* (Real c, Quaternion *q);
Quaternion *operator/ (Quaternion *q, Real c);
//Quaternion *Inverse (Quaternion *q);
//Real       Magnitude (Quaternion *q);

Quaternion *AngleAxisQuaternion(Real theta, Vector3Value *axis)
{
    return Quaternion *( new Quaternion(
        cos(theta/2.0),
        sin(theta/2.0) * Normalize(axis),
        theta,
        axis));
}

#define NEWQUATERNION(theta, axis)  Quaternion *( new Quaternion((theta), (axis)))

    // Rq(p) means rotate p using quaterion q and is defined as: qpq_bar
    //  where q_bar is the Conjugate.  If q=c+u, q_bar = c-u.

    // Composition of two quaternion transformations of p
    // Rqq'(p) = Rq(p) @ Rq'(p)   (where @ = compose)
    //         = Rq(Rq'(p))
    //         = Rq(q'pq'_bar)    (where q'_bar is the Conjugate of q')
    //         = q(q'pq'_bar)q_bar
    //         = (qq')p(q'_bar q_bar)
    //         = Rqq'(p)
// So: multiplication is composition of quaternions that
//     transform a point p in 3space.

Quaternion *operator* (Quaternion *a, Quaternion *b)
{
    Quaternion *q1 = a, *q2 = b;
    Real c1 = q1->C(),
         c2 = q2->C();
    Vector3Value *u1 = q1->U(),
            u2 = q2->U();

    // Multiply two quaternions:
    // qq' = (c + u)(c' + u')
    //     = (cc' - u dot u') + (u X u' + cu' + c'u)

    Real c = ( c1 * c2  -  Dot(u1, u2) );
    Vector3 *u = Cross(u1, u2) + (c1 * u2) + (c2 * u1);

    return NEWQUATERNION(c, u);
}

Quaternion *operator* (Real c, Quaternion *q)
{
    return NEWQUATERNION(c * q->C(), c * q->U());
}

Quaternion *operator- (Quaternion *q)
{
    return NEWQUATERNION(-(q->C()), -(q->U()) );
}

Quaternion *operator+ (Quaternion *a, Quaternion *b)
{
    return NEWQUATERNION(a->C() + b->C(), a->U() + b->U());
}

Quaternion *operator/ (Quaternion *q, Real c)
{
    return NEWQUATERNION(q->C() / c, q->U() / c);
}

Quaternion *Conjugate (Quaternion *q)
{
    return NEWQUATERNION(q->C(), - q->U());
}

Real Magnitude (Quaternion *q)
{
    return (q->C() * q->C()) + LengthSquared(q->U());
}

Real Dot (Quaternion *a, Quaternion *b)
{
    return (a->C() * b->C()) + Dot(a->U(), b->U());
}

Quaternion *Interp (Quaternion *a, Quaternion *b, Real alpha)
{
    // See Gems III, page 96 and gems II page 379
    // This is called a SLERP: Spherical Linear intERPoplation

    Real theta = acos(Dot(a, b)); // Angle between quaternions a and b.
    Real inv_sin_t = 1.0 / sin(theta);
    Real alpha_theta = alpha * theta;

    return (sin(theta - alpha_theta) * inv_sin_t) * a + (sin(alpha_theta) * inv_sin_t) * b;
}

/*
Quaternion *Inverse (Quaternion *q)
{
    return Conjugate(q) / Magnitude(q);
}
*/
Real Length (Quaternion *q)
{
    return sqrt(Magnitude(q));
}

Quaternion *Normalize (Quaternion *q)
{
    return q / Length(q);
}

/*
// Utilities to build Transform3 *matrix from Quaternion *Transform3 *Left(Quaternion *q)
{
    Vector3Value *v = q->U();
    Real c = q->C();
    return MatrixTransform(
                  c,  - ZCoord(v),   YCoord(v), XCoord(v),
          ZCoord(v),            c, - XCoord(v), YCoord(v),
        - YCoord(v),    XCoord(v),           c, ZCoord(v),
        - XCoord(v),  - YCoord(v), - ZCoord(v),        c);
}

Transform3 *Right(Quaternion *q)
{
    Vector3Value *v = q->U();
    Real c = q->C();
    return MatrixTransform(
                  c,    ZCoord(v), - YCoord(v), XCoord(v),
        - ZCoord(v),            c,   XCoord(v), YCoord(v),
          YCoord(v),  - XCoord(v),           c, ZCoord(v),
        - XCoord(v),  - YCoord(v), - ZCoord(v),        c);
}
*/

Transform3 *Rotate(Quaternion *q)
{
// The following explicit calculation (actually: multiplication
// of two special matricies) quarantees that we don't get any roundoff
// error in the bottom row and hence have RL reject the transform.
// - ddalal 09/20/95
    Vector3Value *v = q->U();
    Real c = q->C(), cc = c*c;
    Real x = XCoord(v), y = YCoord(v), z = ZCoord(v);
    Real xx = x*x, yy = y*y, zz = z*z;

    return MatrixTransform(
        (cc - zz - yy + xx),       2*(x*y - c*z),       2*(c*y + x*z), 0,
              2*(c*z + x*y), (cc - zz + yy - xx),       2*(y*z - c*x), 0,
              2*(x*z - c*y),       2*(y*z + c*x), (cc + zz - yy - xx), 0,
                           0,                   0,                   0, 1);
//                           0,                   0,                   0, (cc + zz + yy + xx));
}


// These could be more efficient by stashing theta + vector in quaternion
Vector3Value *AxisComponent(Quaternion *q)
{
    return q->Axis();
}

Real AngleComponent(Quaternion *q)
{
    return q->Angle();
}

#endif QUATERNIONS_REMOVED_FOR_NOW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\path2.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Path2 types and accumulation context.

*******************************************************************************/

#include "headers.h"
#include "privinc/path2i.h"
#include "privinc/vec2i.h"
#include "privinc/xform2i.h"
#include "privinc/except.h"
#include "backend/values.h"
#include "privinc/dddevice.h"
#include "privinc/linei.h"
#include "privinc/polygon.h"
#include "privinc/texti.h"
#include "privinc/stlsubst.h"
#include "privinc/curves.h"
#include "privinc/DaGdi.h"
#include "privinc/d3dutil.h"
#include "privinc/tls.h"

// TODO: Note that all of this code is ripe for some media specific
// constant folding optimizations.  In particular, if concatenated
// paths don't change from frame to frame, there is a lot of work
// being repeated every frame.  Need to investigate pushing constant
// folding down further, and whether or not it would _really_ be
// worthwhile.



    // The following class is used when traversing a path hierarchy to find
    // the lengths of the component subpaths.

class PathInfo
{
  public:

    PathInfo (Path2 *path_, Transform2 *xf_, Real length_, Real *sublengths_)
    : path(path_), xform(xf_), length(length_), sublengths(sublengths_)
    {
    }

    PathInfo (void) : path(0), xform(0), length(0), sublengths(0) {}

    ~PathInfo (void)
    {   if (sublengths) DeallocateFromStore(sublengths);
    }

    Path2      *path;         // Pointer to Subpath
    Transform2 *xform;        // Modelling Transform
    Real        length;       // Length of Path
    Real       *sublengths;   // List of Subpath Lengths
};


    // This class accumulates context state for Path2 traversals.

class Path2Ctx
{
  public:
    Path2Ctx (HDC dc, Transform2 *initXform)
    :   _dc          (dc),
        _xf          (initXform),
        _daGdi       (NULL),
        _viewportPixWidth  (-1),
        _viewportPixHeight (-1),
        _viewportRes       (-1),
        _tailPt      (0,0),
        _totalLength (0)
    {
    }

    Path2Ctx (DAGDI *daGdi,
              Transform2 *initXform,
              DWORD w,
              DWORD h,
              Real res)
    :   _dc          (NULL),
        _xf          (initXform),
        _daGdi       (daGdi),
        _viewportPixWidth(w),
        _viewportPixHeight(h),
        _viewportRes(res),
        _tailPt      (0,0),
        _totalLength (0),
        _isClosed(false)
    {
    }

    ~Path2Ctx (void)
    {
        for (vector<PathInfo*>::iterator i = _paths.begin();
             i != _paths.end(); i++) {
            delete (*i);
        }

        // Destructor of vector will do it.
        //_paths.erase (_paths.begin(), _paths.end());
    }

    void        SetTransform(Transform2 *xf) { _xf = xf; }
    Transform2 *GetTransform() { return _xf; }

    DWORD GetViewportPixelWidth() {
        Assert(_viewportPixWidth > 0);
        return _viewportPixWidth;
    }
    DWORD GetViewportPixelHeight() {
        Assert(_viewportPixHeight > 0);
        return _viewportPixHeight;
    }
    Real GetViewportResolution() {
        Assert(_viewportRes > 0);
        return _viewportRes;
    }

    void Closed() { _isClosed = true; }
    bool isClosed() { return _isClosed; }
    
    void GetTailPt(Point2Value& pt) { pt = _tailPt; }
    void SetTailPt(Point2Value& pt) { _tailPt = pt; }

    HDC  GetDC() { return _dc; }

    DAGDI *GetDaGdi() { return _daGdi; }
    
    // This function takes in the information for a particular subpath and adds
    // it to the list of subpath data.  This function is called during the
    // GatherLengths() traversal.

    void SubmitPathInfo (
        Path2 *path, Real length, Real *subLengths)
    {
        PathInfo *info = NEW PathInfo (path, _xf, length, subLengths);
        VECTOR_PUSH_BACK_PTR (_paths, info);
        _totalLength += length;
    }

    // Sample the path chain at the given parameter t.  This function is only
    // valid following a GatherLengths() traversal.  The parameter t is in
    // the range [0,1].

    Point2Value *SamplePath (Real t)
    {
        Real pathdist = t * _totalLength;
        vector<PathInfo*>::iterator pathinfo;

        for (pathinfo=_paths.begin();  pathinfo != _paths.end();  ++pathinfo)
        {
            if (pathdist <= (*pathinfo)->length)
                return (*pathinfo)->path->Sample (**pathinfo, pathdist);

            pathdist -= (*pathinfo)->length;
        }

        // Should have hit one of the subpaths by now; assume roundoff error
        // and get the maximum point of the last path.

        --pathinfo;
        return (*pathinfo)->path->Sample (**pathinfo, (*pathinfo)->length);
    }

    // The following flag is true if we haven't yet processed (or accumulated)
    // the first polyline or polyBezier in a series of one or more.

    Bool _newSeries;

  protected:
    Transform2 *_xf;
    HDC         _dc;
    Point2Value _tailPt;
    Real        _totalLength;
    DAGDI      *_daGdi;
    DWORD       _viewportPixWidth;
    DWORD       _viewportPixHeight;
    Real        _viewportRes;
    bool        _isClosed;

    vector<PathInfo*> _paths;    // List of Subpath Info
};

/*****************************************************************************
Helper functions for code factoring
*****************************************************************************/

const Bbox2 PolygonalPathBbox(int numPts, Point2Value **pts)
{
    Bbox2 bbox;

    for (int i=0;  i < numPts;  ++i)
        bbox.Augment (Demote(*pts[i]));

    return bbox;
}

const Bbox2 PolygonalPathBbox(int numPts, Point2 *pts)
{
    Bbox2 bbox;

    for (int i=0;  i < numPts;  ++i)
        bbox.Augment ( pts[i] );

    return bbox;
}


bool PolygonalTrivialReject( Point2Value *pt,
                             LineStyle *style,
                             const Bbox2 &naiveBox,
                             Transform2 *imgXf )
{
    // TODO: Note, that this won't work properly for sharply mitered
    // lines, where the angle is very acute, and the miter extends
    // very far from the naive bounding box
    
    // XXX: for now, join and end styles not
    // xxx: considered for picking: we assume rounded
    // xxx: ends
    if ( (!pt) ||
         (style->Detail()) ) {
        return true;
    } else {
        // COPY! don't side effect naiveBox
        Bbox2 box = naiveBox;

        Real aug = style->Width(); // way liberal.  could be 1/2 width

        aug *= 0.6;

        // TODO: Figure out the right thing for the width of the
        // line.  Seems like the width is in the local coordinate
        // space, but it's doesn't look like it (try the bezier pick
        // with the visual trace tag turned on).  So this is over
        // liberal, but it's better than no trivial reject.
        /*
        DirectDrawImageDevice *dev =
            GetImageRendererFromViewport( GetCurrentViewport() );
        if( dev ) {
            Real xs, ys;
            // imgXf is the width transform
            dev->DecomposeMatrix( imgXf, &xs, &ys, NULL );
            Real scale = (xs + ys) * 0.5;
            aug *= scale;
        }
        */
        
        box.min.x -= aug;
        box.min.y -= aug;
        box.max.x += aug;
        box.max.y += aug;
        
        if( !box.Contains( pt->x, pt->y )) {
            return true;
        }
    }
    
    return false;
}

/*****************************************************************************
Accumulate the paths into the DC.
*****************************************************************************/

void Path2::AccumPathIntoDC (
    HDC         dc,
    Transform2 *initXf,     // Initial Transform
    bool        forRegion)  // True if for Filled Region
{
    Path2Ctx ctx(dc, initXf);

    if(!BeginPath(dc)) {
        TraceTag((tagError, "Couldn't begin path in AccumPathIntoDC"));
    }

    ctx._newSeries = true;

    Accumulate (ctx);

    // This works around a bug in GDI that causes a bluescreen on some
    // platforms.  If we're accumulating this path for a filled region
    // then we close the figure before calling EndPath.

    if (forRegion)
        CloseFigure (dc);

    if (!EndPath(dc)) {
        TraceTag((tagError, "Couldn't end path in AccumPathIntoDC"));
    }
}

void Path2::RenderToDaGdi (DAGDI *daGdi,
                           Transform2 *initXform,
                           DWORD w,
                           DWORD h,
                           Real res,                       
                           bool forRegion)
{
    Path2Ctx ctx(daGdi, initXform, w, h, res);
    Accumulate(ctx);
}

AxAValue
Path2::ExtendedAttrib(char *attrib, VARIANT& val)
{
    return this;
}


/*****************************************************************************
A transformed 2D path.
*****************************************************************************/

TransformedPath2::TransformedPath2(Transform2 *xf, Path2 *p) :
   _xf(xf), _p(p)
{
}

Point2Value *
TransformedPath2::FirstPoint() {
    //
    // Just take the first point of the underlying path, and
    // transform it.
    //
    return TransformPoint2Value(_xf, _p->FirstPoint());
}

Point2Value *
TransformedPath2::LastPoint() {
    //
    // Just take the last point of the underlying path, and
    // transform it.
    //
    return TransformPoint2Value(_xf, _p->LastPoint());
}

// TODO: suspect this can be used to factor out some more render
// functions in the render layer...
class XformPusher {
  public:
    XformPusher(Path2Ctx& ctx, Transform2 *xf)
    : _ctx(ctx), _oldXf(ctx.GetTransform())
    { _ctx.SetTransform(TimesTransform2Transform2(_oldXf, xf)); }
    ~XformPusher() { _ctx.SetTransform(_oldXf); }
  private:
    Path2Ctx& _ctx;
    Transform2 *_oldXf;
};

void
TransformedPath2::GatherLengths (Path2Ctx &context)
{
    XformPusher xp (context, _xf);
    _p->GatherLengths (context);
}

Point2Value *
TransformedPath2::Sample (PathInfo &pathinfo, Real distance)
{
    Assert (!"Who's calling TransformPath2::Sample()?");
    return origin2;
}

// Standard push, accumulate, process, and pop...
void
TransformedPath2::Accumulate(Path2Ctx& ctx)
{
    XformPusher xp(ctx, _xf);
    _p->Accumulate(ctx);
}

// Just apply the transform...
Bool
TransformedPath2::ExtractAsSingleContour(Transform2 *initXform,
                                         int *numPts,            
                                         POINT **gdiPts,          
                                         Bool *isPolyline)
{

    return _p->ExtractAsSingleContour(
        TimesTransform2Transform2(initXform, _xf),
        numPts,
        gdiPts,
        isPolyline);
}

const Bbox2
TransformedPath2::BoundingBox (void)
{
    return TransformBbox2 (_xf, _p->BoundingBox());
}

#if BOUNDINGBOX_TIGHTER
const Bbox2
TransformedPath2::BoundingBoxTighter (Bbox2Ctx &bbctx)
{
    Bbox2Ctx bbctxAccum(bbctx, _xf);
    return _p->BoundingBoxTighter(bbctxAccum);
}
#endif  // BOUNDINGBOX_TIGHTER

Bool
TransformedPath2::DetectHit(PointIntersectCtx& ctx, LineStyle *style)
{
    Transform2 *stashedXf = ctx.GetTransform();
    ctx.SetTransform( TimesTransform2Transform2(stashedXf, _xf) );
    Bool result = _p->DetectHit(ctx, style);
    ctx.SetTransform(stashedXf);
    return result;
}

void
TransformedPath2::DoKids(GCFuncObj proc)
{
    (*proc)(_xf);
    (*proc)(_p);
}

Bool
TransformedPath2::IsClosed()
{
    return _p->IsClosed();
}


Path2 *
TransformPath2(Transform2 *xf, Path2 *p)
{
    if (xf == identityTransform2) {
        
        return p;
        
    } else {

        // Collapse underlying transforms if possible. 

        TransformedPath2 *underlyingXfdPath =
            p->IsTransformedPath();

        Path2 *pathToUse;
        Transform2 *xfToUse;

        if (underlyingXfdPath) {
            
            pathToUse = underlyingXfdPath->GetPath();
            xfToUse =
                TimesTransform2Transform2(xf,
                                          underlyingXfdPath->GetXf());
            
        } else {
            
            pathToUse = p;
            xfToUse = xf;
            
        }
        
        return NEW TransformedPath2(xfToUse, pathToUse);
    }
}


/*****************************************************************************
The BoundingBoxPath method takes a LineStyle, but this is inappropriate here,
since the linestyle is in image coordinates, while the path components are in
some unknown modeling coordinates.  In addition, some paths are used for
motion, rather than drawing.  Hence, we ignore the LineStyle here and just get
the pure bbox of the path.
*****************************************************************************/

Bbox2Value *BoundingBoxPath (LineStyle *style, Path2 *p)
{
    return Promote(p->BoundingBox());
}


Image *
DrawPath(LineStyle *border, Path2 *p) 
{
    return LineImageConstructor(border, p);
}

Image *
PathFill(LineStyle *border, Image *fill, Path2 *p) 
{
    Image *fillImg,*borderImg;
    fillImg = ClipImage(RegionFromPath(p), fill);
    borderImg = LineImageConstructor(border, p);
    return Overlay(borderImg, fillImg);    
}


/*****************************************************************************
This class concatentates two path objects.
*****************************************************************************/

class ConcatenatedPath2 : public Path2
{
  public:
    ConcatenatedPath2(Path2 *p1, Path2 *p2) {

        _p1 = p1;
        //
        // Pre transform the second path to fit the first
        //
        Transform2 *xlt = GetUntransformedConcatenationXlt(p1, p2);
        _p2 = TransformPath2(xlt, p2);
    }
    Point2Value *FirstPoint() {
        return _p1->FirstPoint();
    }

    Point2Value *LastPoint() {
        return _p2->LastPoint();
    }

    void GatherLengths (Path2Ctx &context)
    {   _p1->GatherLengths (context);
        _p2->GatherLengths (context);
    }

    Point2Value *Sample (PathInfo &pathinfo, Real distance)
    {   Assert (!"Who's calling ConcatenatedPath2::Sample()?");
        return origin2;
    }
    
    void Accumulate(Path2Ctx& ctx) {

        // Do first path in the concatenated path
        _p1->Accumulate(ctx);

        // Do second path.  This involves finding out the first point
        // of the second path, and transforming the second path to
        // align with the last point of the first, then processing this
        // transformed path.  We first need to transform the first
        // point into the world coordinate system being used to hold
        // the last point.

        //
        // Path1 is:  a--->b
        // Path2 is:  c--->d
        // xf_X is point 'X' with all the accumulated transforms
        //

        _p2->Accumulate(ctx);
    }

    const Bbox2 BoundingBox (void) {
        return UnionBbox2Bbox2 (_p1->BoundingBox(), _p2->BoundingBox());
    }

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter (Bbox2Ctx &bbctx) {
        return UnionBbox2Bbox2 (_p1->BoundingBoxTighter(bbctx), _p2->BoundingBoxTighter(bbctx));
    }
#endif  // BOUNDINGBOX_TIGHTER

    Bool DetectHit(PointIntersectCtx& ctx, LineStyle *style) {
        if (_p1->DetectHit(ctx, style)) {
            return TRUE;
        } else {
            return _p2->DetectHit(ctx, style);
        }
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_p1);
        (*proc)(_p2);
    }

    virtual int Savings(CacheParam& p) { 
        return MAX(_p1->Savings(p), _p2->Savings(p)); 
    }

    virtual bool CanRenderNatively() {
        return _p1->CanRenderNatively() && _p2->CanRenderNatively();
    }


  protected:
    Path2      *_p1;
    Path2      *_p2;

    //
    // For the untransformed path (no xforms applied from parents in the path2 tree)
    // find the last pt of the first, and the first point of the second.
    // Create a translation based on the difference such that when applied to p2,
    // the first point of p2 coincides with last point of p1.
    //
    Transform2 *GetUntransformedConcatenationXlt(Path2 *p1, Path2 *p2) {
        Point2Value *b = p1->LastPoint();
        Point2Value *c = p2->FirstPoint();

        Real x, y;
        x = b->x - c->x;
        y = b->y - c->y;

        //
        // dependency: returned xform copies real values
        // not pointers!
        //
        return TranslateRR(x, y);
    }
};

Path2 *
ConcatenatePath2(Path2 *p1, Path2 *p2)
{
    return NEW ConcatenatedPath2(p1, p2);
}

Path2 *Concat2Array(AxAArray *paths) 
{
    int numPaths = paths->Length();
    if(numPaths < 2)
      RaiseException_UserError(E_FAIL, IDS_ERR_INVALIDARG);

    Path2 *finalPath = (Path2 *)(*paths)[numPaths-1];
    for(int i=numPaths-2; i>=0; i--)
        finalPath = ConcatenatePath2((Path2 *)(*paths)[i], finalPath);
    return finalPath;
}

/*****************************************************************************
This class closes a path.  The original path is saved in _p1, the
NEW path of a line segment from the last point to the first point of the
original path is saved in _p2.
*****************************************************************************/

class ClosedConcatenatedPath2 : public ConcatenatedPath2
{
  public:
    ClosedConcatenatedPath2(Path2 *p1, Path2 *p2) : ConcatenatedPath2(p1, p2) {}

    void Accumulate(Path2Ctx& ctx) {

        if( ctx.GetDC() ) {
            // Do first path in the concatenated path
            _p1->Accumulate(ctx);
            
            // Close the path
            CloseFigure(ctx.GetDC());
        } else {
            ctx.Closed();
            _p1->Accumulate(ctx);
        }
            
    }

  Bool IsClosed() { return true; }

  Bool ExtractAsSingleContour(Transform2 *xf,int *numPts,POINT **gdiPts,Bool *isPolyline)
  { return(_p1->ExtractAsSingleContour(xf,numPts,gdiPts,isPolyline)); }
};

/*****************************************************************************
This class describes a path of connected line segments.
*****************************************************************************/

class PolylinePath2 : public Path2
{
  public:
    // NOTE: This class is expected to free the array of points passed to it.

    // codes are for the flags that go into the GDI PolyDraw
    // function.  If NULL, this is interpeted as a straight polyline.
    // Otherwise, the codes are used to have it be a combination of
    // LineTo's, BezierTo's, and MoveTo's.
    
    PolylinePath2(int numPts, Point2 *pts, double *codes) :
        _myHeap(GetHeapOnTopOfStack()),
            _numPts(numPts),
            _codes(NULL),
            _gdiPts(NULL),
            _dxfPts(NULL),
            _txtPts(NULL),
            _createdCodes(false)
    {
        _ptArray = (Point2 *) StoreAllocate(_myHeap, _numPts * sizeof(Point2));
        memcpy((void *) _ptArray, (void *) pts, _numPts * sizeof(Point2));
        
        if(!codes) {
            CreateDefaultCodes();
        } else {
            CopyDoubleCodes(codes);
        }
    }

    PolylinePath2(int numPts, double *pts, double *codes) :
        _myHeap(GetHeapOnTopOfStack()),
            _numPts(numPts),
            _codes(NULL),
            _gdiPts(NULL),
            _dxfPts(NULL),
            _txtPts(NULL),
            _createdCodes(false)
    {
        _ptArray = (Point2 *) StoreAllocate(_myHeap, _numPts * sizeof(Point2));
        Assert(sizeof(Point2) == (sizeof(double) * 2));
        memcpy((void *) _ptArray, (void *) pts, _numPts * sizeof(Point2));
        
        if(!codes) {
            CreateDefaultCodes();
        } else {
            CopyDoubleCodes(codes);
        }
    }

    PolylinePath2(int numPts, Point2Value **pts, BYTE *codes) :
        _myHeap(GetHeapOnTopOfStack()),
            _numPts(numPts),
            _codes(NULL),
            _gdiPts(NULL),
            _dxfPts(NULL),
            _txtPts(NULL)
    {
        _ptArray = (Point2 *) StoreAllocate(_myHeap, _numPts * sizeof(Point2));
        for (unsigned int i = 0; i < _numPts; i++) {
            _ptArray[i].x = pts[i]->x;
            _ptArray[i].y = pts[i]->y;
        }
        StoreDeallocate(_myHeap, pts);
        
        if(!codes) {
            CreateDefaultCodes();
        } else {
            CopyByteCodes(codes);
        }
    }

    ~PolylinePath2() { 
        if(_gdiPts) StoreDeallocate(_myHeap, _gdiPts);
        StoreDeallocate(_myHeap, _ptArray);
        if(_dxfPts) StoreDeallocate(_myHeap, _dxfPts);
        if(_codes) StoreDeallocate(_myHeap, _codes);
        delete _txtPts;
    }

    Point2Value *FirstPoint() {
        return Promote(_ptArray[0]);
    }

    Point2Value *LastPoint() {
        return Promote(_ptArray[_numPts-1]);
    }

    void GatherLengths (Path2Ctx &context)
    {
        // TODO: Extend this to deal with _codes, dealing with bezier
        // segments and skipping over MOVETO codes.
        
        Real *sublens = (Real*) AllocateFromStore((_numPts-1) * sizeof(Real));

        Transform2 *xf = context.GetTransform();
        Real pathlen = 0;

        int i;
        for (i=0;  i < (_numPts-1);  ++i)
        {
            Point2 P = TransformPoint2(xf, _ptArray[ i ]);
            Point2 Q = TransformPoint2(xf, _ptArray[i+1]);
            sublens[i] = Distance (P, Q);
            pathlen += sublens[i];
        }

        context.SubmitPathInfo (this, pathlen, sublens);
    }

    Point2Value *Sample (PathInfo &pathinfo, Real distance)
    {
        // TODO: Extend this to deal with _codes, dealing with bezier
        // segments and skipping over MOVETO codes.

        // Find the polyline segment that contains the point 'distance' units
        // along the entire polyline.

        int i;
        for (i=0;  i < (_numPts-1);  ++i)
        {
            if (distance <= pathinfo.sublengths[i])
                break;

            distance -= pathinfo.sublengths[i];
        }

        if (i >= (_numPts-1))
            return LastPoint();

        Real t=0;
        if(pathinfo.sublengths[i] > 0)
            t = distance / pathinfo.sublengths[i];

        Point2 P = TransformPoint2 (pathinfo.xform, _ptArray[ i ]);
        Point2 Q = TransformPoint2 (pathinfo.xform, _ptArray[i+1]);
        Point2 R = Lerp(P, Q, t);

        return NEW Point2Value (R.x, R.y);
    }
    
    void Accumulate(Path2Ctx& ctx) {

        // if the transform hasn't changed... <how do we know ?> then
        // we don't need to retransform the points.
        Transform2 *xf = ctx.GetTransform();

        // if there's no codes, you're going thru the slow path man.
        // the right thing to do is make and invariant that polyline
        // path2 will ALWAYS have codes with it.  since no _codes
        // means that it's a polyline why don't we create a
        // polylinepath2 in the first place, eh? eh ?!?
        if( ctx.GetDC() || _createdCodes) {
            
            // TODO: put the relevant device in the context!
            DirectDrawImageDevice *dev =
                GetImageRendererFromViewport( GetCurrentViewport() );

            // assures that _gdiPts exits
            _GenerateGDIPoints(dev, xf);
              
            Assert( _gdiPts );
            
            //
            // Figure out where the last point took us with respect to the
            // previous last point.  We'll use the difference to
            // accumulate into the transformation for appropriate handling
            // of path concatenation.
            //
            Point2Value *tailPt = Promote(TransformPoint2(xf, _ptArray[_numPts-1]));
            ctx.SetTailPt( *(tailPt) );

            if (_createdCodes) {          // regular polyline
            
                // Draw the polyline using GDI.  If the _newSeries flag is set, then
                // this is the first polyline in a series, so first move to the
                // starting point of the current polyline.

                if (ctx._newSeries) {
                    if (0 == MoveToEx (ctx.GetDC(), _gdiPts[0].x, _gdiPts[0].y, NULL)) {
                        TraceTag((tagError, "MoveToEx failed in PolylinePath2"));
                        //RaiseException_InternalError ("MoveToEx failed in PolylinePath2");
                    }

                    ctx._newSeries = false;
                }

                // In specifying the PolylineTo, we needn't specify the first point
                // again.  Either we're starting a NEW path (and henced moved there
                // in the code above), or we're continuing from the previous path
                // segment.  Since we always translate path segments so the first
                // point is coincident with the last point of the previous segment,
                // we skip the first point.  More importantly, if we specify the first
                // point (redundant), a bug in NT GDI causes a bluescreen.

                int result;
                TIME_GDI (result = PolylineTo(ctx.GetDC(), _gdiPts+1, _numPts-1));
                if (0 == result) {
                    
                    // if we failed and we don't have a DC and we created ourr own codes 
                    // Then try other method...
                    if(!ctx.GetDC()) {
                        goto render2DDsurf;
                    }
                    TraceTag((tagError, "PolylineTo failed"));
                
                    //RaiseException_InternalError ("PolylineTo failed");
                    
                }

            } else {                // use polydraw
                dev->GetDaGdi()->PolyDraw_GDIOnly(ctx.GetDC(), _gdiPts, _codes, _numPts);
            }
            
        } else {
render2DDsurf:
            // render into ddsurface
            Assert( ctx.GetDaGdi() );

            PolygonRegion polydrawPolygon;

            if( ctx.GetDaGdi()->DoAntiAliasing() ) {
                
                if(!_dxfPts) _GenerateDxfPoints();
                if(!_txtPts) {
                    // passing in _myHeap as the heap the codes and
                    // pts were created on.  however, it happens to
                    // not matter because we're telling TextPoints NOT
                    // to deallocate the members we set.
                    _txtPts = NEW TextPoints(_myHeap, false);
                    _txtPts->_count = _numPts;
                    _txtPts->_types = _codes;
                    _txtPts->_pts = _dxfPts;

                    DynamicPtrDeleter<TextPoints> *dltr = NEW DynamicPtrDeleter<TextPoints>(_txtPts);
                    _myHeap.RegisterDynamicDeleter(dltr);
                }
                
                polydrawPolygon.Init( _txtPts,
                                      ctx.GetViewportPixelWidth(),
                                      ctx.GetViewportPixelHeight(),
                                      ctx.GetViewportResolution(),
                                      xf );
                
                // We no longer need this since we can now assume that dxtrans
                // will always be on the system that we are.
            } else {
                // TODO: put the relevant device in the context!
                DirectDrawImageDevice *dev =
                    GetImageRendererFromViewport( GetCurrentViewport() );
                 
                _GenerateGDIPoints( dev, GetCurrentViewport()->GetAlreadyOffset(ctx.GetDaGdi()->GetDDSurface())?TimesTransform2Transform2(InverseTransform2(dev->GetOffsetTransform()), xf):xf);
                Assert( _gdiPts );

                polydrawPolygon.Init(_gdiPts, _numPts);
            }

            if(ctx.isClosed()) {
                _codes[_numPts-1] |= PT_CLOSEFIGURE;
            }
            ctx.GetDaGdi()->PolyDraw(&polydrawPolygon, _codes);
        }
    }

    bool CanRenderNatively() { return true; }
    
    Bool ExtractAsSingleContour(Transform2 *xf,
                                int *numPts,            
                                POINT **gdiPts,          
                                Bool *isPolyline) {

        // Don't support polydraw as a single contour.
        if (_codes) {
            return FALSE;
        }

        GetImageRendererFromViewport( GetCurrentViewport() )->
            TransformPointsToGDISpace(
                xf,
                _ptArray,
                _gdiPts,
                _numPts);

        *gdiPts = _gdiPts;
        *numPts = _numPts;
        *isPolyline = TRUE;

        return TRUE;
    }

    const Bbox2 BoundingBox (void);

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter (Bbox2Ctx &bbctx);
#endif  // BOUNDINGBOX_TIGHTER

    Bool DetectHit(PointIntersectCtx& ctx, LineStyle *style);

    virtual int Savings(CacheParam& p) { 
        return (_numPts > 10) ? 3 : 1;
    }

  private:

    void CreateDefaultCodes(void)
    {
        _codes = (BYTE *) StoreAllocate(_myHeap, _numPts * sizeof(BYTE));
        _codes[0] = PT_MOVETO;
        for(int i=1; i < _numPts; i++) {
            _codes[i] = PT_LINETO;
        }
        _createdCodes = true;
    }

    void CopyDoubleCodes(double *codes)
    {
        Assert(_numPts > 0);
        Assert(_codes == NULL);
        Assert(codes != NULL);
        _codes = (BYTE *) StoreAllocate(_myHeap, _numPts * sizeof(BYTE));
        for (int i = 0; i < _numPts; i++) {
            _codes[i] = (BYTE) codes[i];
        }

        // Now, change the code for the first point to be a MoveTo, since
        // there shouldn't be any state retention from previous
        // primitives.  (That is, we don't want to draw a connector from
        // the last point rendered to this first point... there's nothing
        // in the model that would suggest this behavior)
        _codes[0] = PT_MOVETO;
    }

    void CopyByteCodes(BYTE *codes)
    {
        Assert(_numPts > 0);
        Assert(_codes == NULL);
        Assert(codes != NULL);
        _codes = (BYTE *) StoreAllocate(_myHeap, _numPts * sizeof(BYTE));
        memcpy(_codes,codes,_numPts * sizeof(BYTE));

        // Now, change the code for the first point to be a MoveTo, since
        // there shouldn't be any state retention from previous
        // primitives.  (That is, we don't want to draw a connector from
        // the last point rendered to this first point... there's nothing
        // in the model that would suggest this behavior)
        _codes[0] = PT_MOVETO;
    }

    void _GenerateDxfPoints()
    {
        Assert( !_dxfPts );
        _dxfPts = (DXFPOINT *)StoreAllocate(_myHeap, sizeof(DXFPOINT) * _numPts);
        for(int i=0; i<_numPts; i++) {
            _dxfPts[i].x = (float) _ptArray[i].x;
            _dxfPts[i].y = (float) _ptArray[i].y;
        }
    }

    void _GenerateGDIPoints(DirectDrawImageDevice *dev, Transform2 *xf)
    {
        if( !_gdiPts ) {
            _gdiPts = (POINT *)StoreAllocate(_myHeap, _numPts * sizeof(POINT));
        }
       
        dev->TransformPointsToGDISpace(xf, _ptArray, _gdiPts, _numPts);
    }
            
  protected:
    int          _numPts;
    Point2      *_ptArray;
    BYTE        *_codes;
    POINT       *_gdiPts;
    DXFPOINT    *_dxfPts;
    TextPoints *_txtPts;
    DynamicHeap &_myHeap;
    bool        _createdCodes;
};


const Bbox2 PolylinePath2::BoundingBox(void)
{
    // TODO: This can, and should, be cached.
    // TODO; and... if it is, make sure clients don't sideeffect it.
    
    return PolygonalPathBbox(_numPts, _ptArray);
}

#if BOUNDINGBOX_TIGHTER
Bbox2 PolylinePath2::BoundingBoxTighter(Bbox2Ctx &bbctx)
{
    // TODO: This can, and should, be cached.
    
    Bbox2 bbox;
    Transform2 *xf = bbctx.GetTransform();

    for (int i=0;  i < _numPts;  ++i)
        bbox.Augment (TransformPoint2(xf, _ptArray[i]));

    return bbox;
}
#endif  // BOUNDINGBOX_TIGHTER


Bool PolylinePath2::DetectHit (PointIntersectCtx& ctx, LineStyle *style)
{
    // TODO: Take _codes into account
    
    Point2Value *ptValue = ctx.GetLcPoint();

    if( PolygonalTrivialReject( ptValue, style, BoundingBox(), 
                                ctx.GetImageOnlyTransform() ) )
        return false;
    

    int pointCount = _numPts-1;
    Real halfWidth = style->Width() * 0.5;

    Point2 pt = Demote(*ptValue);
    Point2 a, b;
    for(int i=0; i < pointCount; i++)
    {
        a = _ptArray[i];
        b = _ptArray[i+1];
        
        if(a == b) {
            // points are the same, no need to continue...
        }
        else {
            // Seems like this is faster, not sure why!

            Vector2 nw(-(b.y - a.y), (b.x - a.x));
            nw.Normalize();

            Vector2 ap = pt - a;
            Real dist = Dot(ap, nw);
            //printf("Dist = %f, half thickness = %f, d1=%f, w2=%f\n", dist, halfWidth, d1, _thick2);
            if ( fabs(dist) < halfWidth ) {
                Vector2 ab = b - a;
                Vector2 nab = ab;
                nab.Normalize();
                Real len = ab.Length();
                Real dist = Dot(ap, nab);
                return dist > -halfWidth  && dist < (len + halfWidth);
            }
        }
    }

    return FALSE;
}



/*****************************************************************************
The PolyBezierPath2 object creates a 2D path with a cubic Bezier curve.
*****************************************************************************/

class PolyBezierPath2 : public Path2
{
  public:

    // This constructor takes the number of cubic Bezier control points and
    // an array of control points.  

    PolyBezierPath2 (const int numPts, const Point2 pts[]);

    // This constructor takes the number of cubic Bezier control points and
    // an array of control points.  This class will delete the storage for
    // the array of points.

    PolyBezierPath2 (const int numPts, const Point2Value **pts);

    // This constructor takes a set of 'numBsPts'+3 B-spline control points and
    // a set 'numBsPts'+2 knots and constructs a C2 cubic Bezier curve.  This
    // class will delete the storage for the array of points.

    PolyBezierPath2 (const int numBsPts, Point2 bsPts[], Real knots[]);

    // Don't need a CleanUp since there is no system resource to be freed. 

    ~PolyBezierPath2() { 
        DeallocateFromStore (_gdiPts);
        // NOTE: Assumption we are responsible to free the passed in array
        // in the non-bspline case.
        DeallocateFromStore (_ptArray);
    }

    Point2Value *FirstPoint (void) { 
        return Promote(_ptArray[0]); 
    }

    Point2Value *LastPoint  (void) { 
        return Promote(_ptArray[_numPts-1]); 
    }

    // Gather the lengths of the cubic Bezier curves in the path.

    void GatherLengths (Path2Ctx &context) 
    {
        Real *sublens =
            (Real*) AllocateFromStore(sizeof(Real) * ((_numPts-1)/3));

        Transform2 *xf = context.GetTransform();
        Real pathlen = 0;

        // Traverse each cubic Bezier subcurve.  Note that we approximate the
        // length of the Bezier curve by computing the length of the control
        // polygon.  We may choose to improve this in the future.

        int i;
        for (i=0;  i < ((_numPts-1) / 3);  ++i)
        {
            sublens[i] = 0;

            int j;
            for (j=0;  j < 3;  ++j)
            {
                Point2 P = TransformPoint2(xf, _ptArray[3*i +  j ]);
                Point2 Q = TransformPoint2(xf, _ptArray[3*i + j+1]);
                sublens[i] += Distance(P,Q);
            }
            pathlen += sublens[i];
        }

        context.SubmitPathInfo (this, pathlen, sublens);
    }
    
    Point2Value *Sample (PathInfo &pathinfo, Real distance) 
    {
        // Find the polyline segment that contains the point 'distance' units
        // along the entire polyline.

        int numcurves = (_numPts - 1) / 3;

        int i;
        for (i=0;  i < numcurves;  ++i)
        {
            if (distance <= pathinfo.sublengths[i])
                break;

            distance -= pathinfo.sublengths[i];
        }

        if (i >= numcurves)
            return LastPoint();

        Real t = distance / pathinfo.sublengths[i];

        Point2 controlPoints[4];
        controlPoints[0] = TransformPoint2(pathinfo.xform, _ptArray[3*i+0]);
        controlPoints[1] = TransformPoint2(pathinfo.xform, _ptArray[3*i+1]);
        controlPoints[2] = TransformPoint2(pathinfo.xform, _ptArray[3*i+2]);
        controlPoints[3] = TransformPoint2(pathinfo.xform, _ptArray[3*i+3]);

        return Promote(EvaluateBezier (3, controlPoints, t));
    }

    void Accumulate(Path2Ctx& ctx);

    bool CanRenderNatively() const {
        // TODO: implement natively if flash needs this
        return false;
    }
    
    Bool ExtractAsSingleContour(Transform2 *initXform,
                                int *numPts,            
                                POINT **gdiPts,          
                                Bool *isPolyline) const {
        // #error "OK... fill this guy in..."
        return FALSE;
    }
    
    const Bbox2 BoundingBox (void);

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter (Bbox2Ctx &bbctx) const;
#endif  // BOUNDINGBOX_TIGHTER

    Bool DetectHit (PointIntersectCtx& ctx, LineStyle *style);

    virtual int Savings(CacheParam& p) const { 
        return (_numPts > 10) ? 3 : 1;
    }

  protected:
    int      _numPts;          // (_numPts - 1) / 3 Cubic Bezier Curves
    Point2  *_ptArray;             // Array of _numPts Points
    POINT   *_gdiPts;
};



/*****************************************************************************
Constructs a cubic poly Bezier path from a set of 3N+1 control points (where N
is an integer).
*****************************************************************************/

PolyBezierPath2::PolyBezierPath2 (const int numPts, const Point2 *pts)
  : _numPts(numPts), _ptArray(NULL)
{
    _ptArray = (Point2 *) AllocateFromStore(_numPts * sizeof(Point2));
    memcpy((void *) _ptArray, (void *) pts, _numPts * sizeof(Point2));

    // Scratch space for accumulating points into.  We may want to lazily
    // construct these, in case they never get used.

    _gdiPts = (POINT*) AllocateFromStore (numPts * sizeof(POINT));
}

PolyBezierPath2::PolyBezierPath2 (const int numPts, const Point2Value **pts)
  : _numPts(numPts), _ptArray(NULL)
{
    _ptArray = (Point2 *) AllocateFromStore(_numPts * sizeof(Point2));
    for (unsigned int i = 0; i < _numPts; i++) {
        _ptArray[i].x = pts[i]->x;
        _ptArray[i].y = pts[i]->y;
    }
    DeallocateFromStore(pts);

    // Scratch space for accumulating points into.  We may want to lazily
    // construct these, in case they never get used.

    _gdiPts = (POINT*) AllocateFromStore (numPts * sizeof(POINT));
}



/*****************************************************************************
This routine converts a cubic B-spline curve to a cubic Bezier polygon.  Given
L intervals, L cubic Bezier's are returned as 3L+1 control points.  The input
knots Ui must be repeated three times at the ends in order to interpolate the
endpoints of the B-spline polygon.
*****************************************************************************/

static void BSplineToBezier (
    const int     L,    // Number of Intervals
    const Point2  d[],  // B-Spline Control Polygon: [0,L+2]
    const Real    U[],  // Knot Sequence: [0,L+4]
          Point2  b[])  // Output Piecewise Bezier Polygon [0,3L]
{
    Point2 p;    // Pre- and Post- Bezier Point

    p    = Lerp (d[0], d[1], (U[2]-U[0]) / (U[3]-U[0]));
    b[1] = Lerp (d[1], d[2], (U[2]-U[1]) / (U[4]-U[1]));
    b[0] = Lerp (p,    b[1], (U[2]-U[1]) / (U[3]-U[1]));

    int i, i3;
    for (i=1, i3=3;  i < L;  ++i, i3+=3)
    {
        b[i3-1] = Lerp (d[ i ], d[i+1], (U[i+2]-U[ i ]) / (U[i+3]-U[ i ]));
        b[i3+1] = Lerp (d[i+1], d[i+2], (U[i+2]-U[i+1]) / (U[i+4]-U[i+1]));
        b[ i3 ] = Lerp (b[i3-1],b[i3+1],(U[i+2]-U[i+1]) / (U[i+3]-U[i+1]));
    }

    b[i3-1] = Lerp (d[ i ], d[i+1], (U[i+2]-U[ i ]) / (U[i+3]-U[ i ]));
    p       = Lerp (d[i+1], d[i+2], (U[i+2]-U[i+1]) / (U[i+4]-U[i+1]));
    b[ i3 ] = Lerp (b[i3-1],p,      (U[i+2]-U[i+1]) / (U[i+3]-U[i+1]));
}



/*****************************************************************************
The constructor takes L+3 B-spline control points, L+5 knots, and constructs L
cubic Bezier curves (3L+1 Bezier control points).  The knots must be
duplicated three times at each end in order to interpolate the first and last
control points.

NOTE: bsPts and knots will be deleted by this constructor.
*****************************************************************************/

PolyBezierPath2::PolyBezierPath2 (
    const int numBsPts, 
          Point2 bsPts[], 
          Real knots[])
{
    // Special case:  if we are given 3N+1 control points and the given knots
    // are of the form a,a,a, b,b,b, c,c,c, ... N,N,N, then the control polygon
    // for the BSpline is also a control net for a polyBezier.

    bool isPolyBezier = false;

    if (0 == ((numBsPts-1) % 3)) {

        // Test the knot vector to see if it matches the special case.  We use
        // the knowledge that knot values must increase monotonically, so
        // ((U[i+2] - U[i]) == 0)  must mean  U[i]==U[i+1]==U[i+2].  Also, the
        // strict limit below would be (i < (numBsPts+2)), but since i is
        // incremented by 3 these two are equivalent.

        for (int i=0;  (i < numBsPts) && (0 == (knots[i+2]-knots[i]));  i+=3)
            continue;

        // If all knots meet the condition, then just use the control points
        // of the BSpline as the control points for a polyBezier.

        if (i >= numBsPts) {   
            _numPts = numBsPts;
            _ptArray = bsPts;
            isPolyBezier = true;
        }
    }

    // If the BSpline is not of polyBezier form, then we need to convert the
    // cubic BSpline to a cubic polyBezier curve.

    if (!isPolyBezier) {

        _numPts = 3*numBsPts - 8;

        _ptArray = (Point2*) AllocateFromStore (_numPts * sizeof(Point2));

        // Generate the cubic Bezier points from the cubic B-spline curve.

        // Calculate the corresponding cubic Bezier control points and
        // copy them over to the points array.

        BSplineToBezier (numBsPts-3, bsPts, knots, _ptArray);

        // Done with the original BSpline control points

        DeallocateFromStore (bsPts);
    }

    DeallocateFromStore (knots);   // We're done with the knots.

    // Scratch space for accumulating points.

    _gdiPts = (POINT*) AllocateFromStore (_numPts * sizeof(POINT));
}



/*****************************************************************************
This routine lays out the curve using GDI.
*****************************************************************************/

void PolyBezierPath2::Accumulate (Path2Ctx& ctx)
{
    Transform2 *xf = ctx.GetTransform();

    if( ctx.GetDC() ) {

        GetImageRendererFromViewport( GetCurrentViewport() )
            -> TransformPointsToGDISpace (xf, _ptArray, _gdiPts, _numPts);

        // Figure out where the last point took us with respect to the previous
        // last point.  We'll use the difference to accumulate into the
        // transformation for appropriate handling of path concatenation.

        ctx.SetTailPt (*Promote(TransformPoint2(xf, _ptArray[_numPts-1])));

        // Draw the Bezier curve using GDI.  If this is the first in a series, then
        // move to the starting point before drawing, otherwise continue from the
        // end of the last element.

        if (ctx._newSeries) {   
            if (0 == MoveToEx (ctx.GetDC(), _gdiPts[0].x, _gdiPts[0].y, NULL)) {
                TraceTag((tagError, "MoveToEx failed in PolyBezierPath2"));
                //RaiseException_InternalError ("MoveToEx failed in PolyBezierPath2");
            }

            ctx._newSeries = false;
        }

        TIME_GDI( 
            if (0 == PolyBezierTo (ctx.GetDC(), _gdiPts + 1, _numPts - 1)) {
                TraceTag((tagError, "Polybezier failed"));
                //RaiseException_InternalError("Polybezier failed");
            }
        );

    } else {

        Assert( ctx.GetDaGdi() );
        // TODO: use dagdi to draw the bezier

    }
}


/*****************************************************************************
For the bounding box, we just take the convex hull of the bezier's control
points (guaranteed to contain the curve).
*****************************************************************************/

const Bbox2 PolyBezierPath2::BoundingBox (void)
{
    return PolygonalPathBbox(_numPts, _ptArray);
}

#if BOUNDINGBOX_TIGHTER
const Bbox2 PolyBezierPath2::BoundingBoxTighter (Bbox2Ctx &bbctx)
{
    Bbox2 bbox;
    Transform2 *xf = bbctx.GetTransform();

    for (int i=0;  i < _numPts;  ++i) {
        bbox.Augment (TransformPoint2(xf, _ptArray[i]));
    }

    return bbox;
}
#endif  // BOUNDINGBOX_TIGHTER



/*****************************************************************************
BUG:  This code is incorrect: it only tests hits on the control polygon, not
on the actual curve (so you'll rarely get a positive result if you pick on
the curve).
*****************************************************************************/

Bool PolyBezierPath2::DetectHit (PointIntersectCtx& ctx, LineStyle *style)
{
    // TODO: put the relevant device in the context!
    DirectDrawImageDevice *dev = GetImageRendererFromViewport( GetCurrentViewport() );

    // TODO: how to make sure the sound device isn't upon us!


    Point2Value *pt = ctx.GetLcPoint();
    if( PolygonalTrivialReject( pt, style, BoundingBox(), ctx.GetImageOnlyTransform() ) )
        return false;

    return dev->DetectHitOnBezier(this, ctx, style);
}


/*****************************************************************************
*****************************************************************************/


TextPath2::TextPath2(Text *text, bool restartClip)
{
    _text = text;
    _restartClip = restartClip;
}

Point2Value *
TextPath2::FirstPoint()
{
    Assert(!"who's calling TextPath2::FirstPoint");
    return origin2;
}

Point2Value *
TextPath2::LastPoint()
{
    Assert(!"who's calling TextPath2::LastPoint");
    return origin2;
}

void
TextPath2::GatherLengths (Path2Ctx &context)
{
    Assert (!"Somebody's callling TextPath2::GatherLengths()");
    return;
}

Point2Value *
TextPath2::Sample (PathInfo &pathinfo, Real distance)
{
    Assert (!"Who's calling TextPath2::Sample()?");
    return origin2;
}

void
TextPath2::Accumulate(Path2Ctx& ctx)
{
    TextCtx textCtx(GetImageRendererFromViewport( GetCurrentViewport() ));


    textCtx.BeginRendering(TextCtx::renderForPath,
                           ctx.GetDC(),
                           ctx.GetTransform());
    _text->RenderToTextCtx(textCtx);
    textCtx.EndRendering();
}

const Bbox2 TextPath2::BoundingBox (void)
{
    TextCtx ctx(GetImageRendererFromViewport( GetCurrentViewport() ));

    ctx.BeginRendering(TextCtx::renderForBox);

    _text->RenderToTextCtx(ctx);

    ctx.EndRendering();

    return ctx.GetStashedBbox();
}

#if BOUNDINGBOX_TIGHTER
const Bbox2 TextPath2::BoundingBoxTighter (Bbox2Ctx &bbctx)
{
    Transform2 *xf = bbctx.GetTransform();
    return TransformBbox2(xf, BoundingBox());
}
#endif  // BOUNDINGBOX_TIGHTER

Bool TextPath2::DetectHit(PointIntersectCtx& ctx, LineStyle *style)
{
    // Ughhh implemente this...
    return FALSE;
}

void
TextPath2::DoKids(GCFuncObj proc)
{
    (*proc)(_text);
}

class LinePath2 : public Path2
{
  public:
    LinePath2(Path2 *path, LineStyle *ls) {
        _path = path;
        _lineStyle = ls;
    }

    Point2Value *FirstPoint() {
        Assert(!"who's calling LinePath2::FirstPoint");
        return origin2;
    }

    Point2Value *LastPoint() {
        Assert(!"who's calling LinePath2::LastPoint");
        return origin2;
    }

    void GatherLengths (Path2Ctx &context) {
        Assert (!"Somebody's callling LinePath2::GatherLengths()");
        return;
    }

    Point2Value *Sample (PathInfo &pathinfo, Real distance)
    {   Assert (!"Who's calling LinePath2::Sample()?");
        return origin2;
    }

    void Accumulate(Path2Ctx& ctx) {
        // not impl
        return;
/*
  TextCtx textCtx(GetImageRendererFromViewport( GetCurrentViewport() ));
  textCtx.BeginRendering(TextCtx::renderForPath,
  ctx.GetDC(),
  ctx.GetTransform());
  _text->RenderToTextCtx(textCtx);
  textCtx.EndRendering();
  */
    }

    const Bbox2 BoundingBox (void) {
        // TODO: need to augment path with line thickness
        return _path->BoundingBox();
/*
  TextCtx ctx(GetImageRendererFromViewport( GetCurrentViewport() ));
  ctx.BeginRendering(TextCtx::renderForBox);
  _text->RenderToTextCtx(ctx);
  ctx.EndRendering();
  return ctx.GetStashedBbox();
  */
    }

#if BOUNDINGBOX_TIGHTER
    const Bbox2 BoundingBoxTighter (Bbox2Ctx &bbctx) {
        Transform2 *xf = bbctx.GetTransform();
        return TransformBbox2(xf, BoundingBox());
    }
#endif  // BOUNDINGBOX_TIGHTER

    Bool DetectHit(PointIntersectCtx& ctx, LineStyle *style)
    {
        // Ughhh implemente this...
        return FALSE;
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_path);
        (*proc)(_lineStyle);
    }

    virtual int Savings(CacheParam& p) { return _path->Savings(p); }

  protected:
    Path2 *_path;
    LineStyle *_lineStyle;
};

////////////////////////////////////////////////////////////////
//////// Constructors
////////////////////////////////////////////////////////////////

Path2 *
Line2(const Point2 &p1, const Point2 &p2)
{
    Point2 pts[2];
    pts[0] = p1;
    pts[1] = p2;
    return NEW PolylinePath2(2, pts, NULL);
}

Path2 *
Line2(Point2Value *p1, Point2Value *p2)
{
    Point2 pts[2];
    pts[0] = Demote(*p1);
    pts[1] = Demote(*p2);
    return NEW PolylinePath2(2, pts, NULL);
}

Path2 *
RelativeLine2(Point2Value *pt)
{
    return Line2(origin2, pt);
}

Path2 *
PolyLine2(AxAArray *ptArr)
{
    if(ptArr->Length() <= 0) {
        RaiseException_UserError(E_FAIL, IDS_ERR_IMG_NOT_ENOUGH_PTS_2); 
    }

    int numPts = ptArr->Length() == 1 ? 2 : ptArr->Length();
    Point2Value **pts = (Point2Value **)AllocateFromStore(numPts * sizeof(Point2Value *));
                    
    if(ptArr->Length() == 1){
        // Handle special case of only one point.
                        
        pts[0] = pts[1] = (Point2Value *)(*ptArr)[0];        
    } else {
        
        for (int i = 0; i < numPts; i++) {
            pts[i] = (Point2Value *)(*ptArr)[i];
        }
    }
        
    return NEW PolylinePath2(numPts, pts, NULL);
}

Path2 *NewPolylinePath2(DWORD numPts, Point2Value **pts, BYTE *codes)
{
    return NEW PolylinePath2(numPts, pts, codes);
}
    
Path2 *
PolydrawPath2Double(double *pointdata,
                    unsigned int numPts,
                    double *codedata,
                    unsigned int numCodes)
{
    if (numPts != numCodes) {
        RaiseException_UserError(E_FAIL, IDS_ERR_IMG_ARRAY_MISMATCH);
    }

    return NEW PolylinePath2(numPts, pointdata, codedata);
}

Path2 *
PolydrawPath2(AxAArray *ptArr,
              AxAArray *codeArr)
{
    int numPts = ptArr->Length();
    int numCodes = codeArr->Length();

    if (numPts != numCodes) {
        RaiseException_UserError(E_FAIL, IDS_ERR_IMG_ARRAY_MISMATCH);
    }

    Point2Value **pts = (Point2Value **)AllocateFromStore(numPts * sizeof(Point2Value *));
    BYTE    *codes = (BYTE *)AllocateFromStore(numPts * sizeof(BYTE));

    for (int i = 0; i < numPts; i++) {
        pts[i] = (Point2Value *)(*ptArr)[i];
        codes[i] = (BYTE)(NumberToReal((AxANumber *)(*codeArr)[i]));
    }

    PolylinePath2 *pp = NEW PolylinePath2(numPts, pts, codes);

    DeallocateFromStore(codes);

    return pp;
}

/*****************************************************************************
The B-spline path2 takes a set of 2D control points and knots, and returns a
path from them.  Given N control points, we expect N+2 knots.
*****************************************************************************/

Path2 *CubicBSplinePath (AxAArray *ptArray, AxAArray *knotArray)
{
    int numPts = ptArray->Length();

    // We need at least four control points to do a cubic curve.

    if (numPts < 4)
        RaiseException_UserError (E_FAIL, IDS_ERR_IMG_NOT_ENOUGH_PTS_4);

    // Extract the B-spline control points into an array of Point2*.

    Point2 *pts = (Point2 *) AllocateFromStore (numPts * sizeof(Point2));

    int i;
    for (i=0;  i < numPts;  ++i) {
        pts[i].x = ((Point2Value*) (*ptArray)[i])->x;
        pts[i].y = ((Point2Value*) (*ptArray)[i])->y;
    }

    // We need at least N+2 knots, where N is the number of B-spline control
    // points.

    int numKnots = knotArray->Length();

    if (numKnots != (numPts+2))
    {
        char kn[10];
        char pts[10];
        wsprintf(kn, "%d", numKnots);
        wsprintf(pts, "%d", numPts);
        RaiseException_UserError (E_FAIL, IDS_ERR_SPLINE_KNOT_COUNT, "3", kn, pts);
    }

    Real *knots =
        (Real*) AllocateFromStore (numKnots * sizeof(Real));

    Real lastknot = -HUGE_VAL;

    for (i=0;  i < (numPts+2);  ++i)
    {
        knots[i] = NumberToReal ((AxANumber*)(*knotArray)[i]);

        if (knots[i] < lastknot)
        {
            RaiseException_UserError(E_FAIL, IDS_ERR_SPLINE_KNOT_MONOTONICITY);
        }

        lastknot = knots[i];
    }

    return NEW PolyBezierPath2 (numPts, pts, knots);
}


Path2 *
OriginalTextPath(Text *tx)
{
    bool restartClip;

    // TODO: DDalal, fill in with ExtendAttrib stuff for choosing
    // this. 
    restartClip = false;
    
    return NEW TextPath2(tx, restartClip);
}

    // TextPath2Constructor is defined in fontstyl.

Path2 *
InternalPolyLine2(int numPts, Point2 *pts)
{
    return NEW PolylinePath2(numPts, pts, NULL);
}

////////////////////////////////////////
Path2 *
ConcatenatePath2(Path2 **paths, int numPaths)
{
    if (numPaths <= 0) {
        RaiseException_UserError(E_FAIL, IDS_ERR_ZERO_ELEMENTS_IN_ARRAY);
    }

    Path2 *pReturn = paths[0];

    for (int i = 1; i < numPaths; i++) {
        pReturn = ConcatenatePath2(pReturn, paths[i]);
    }

    return pReturn;
}

////////////////////////////////////////

Path2 *
ClosePath2(Path2 *p)
{
     Path2 *p2 = Line2(p->LastPoint(), p->FirstPoint());
     return NEW ClosedConcatenatedPath2(p, p2);
}

/*****************************************************************************
* This is derived from NT's implementation of Arc.
* Here's a comment block cloned from their source.
*
* Constructs a partial arc of 90 degrees or less using an approximation
* technique by Kirk Olynyk.  The arc is approximated by a cubic Bezier.
*
* Restrictions:
*
*    angle must be within 90 degrees of startAngle.
*
* Steps in constructing the curve:
*
*    1) Construct the conic section at the origin for the unit circle;
*    2) Approximate this conic by a cubic Bezier;
*    3) Scale result.
*
* 1)  Constructing the Conic
*
*       'startAngle' and 'endAngle' determine the end-points of the
*       conic (call them vectors from the origin, A and C).  We need the
*       middle vector B and the sharpness to completely determine the
*       conic.
*
*       For the portion of a circular arc that is 90 degrees or less,
*       conic sharpness is Cos((endAngle - startAngle) / 2).
*
*       B is calculated by the intersection of the two lines that are
*       at the ends of A and C and are perpendicular to A and C,
*       respectively.  That is, since A and C lie on the unit circle, B
*       is the point of intersection of the two lines that are tangent
*       to the unit circle at A and C.
*
*       If A = (a, b), then the equation of the line through (a, b)
*       tangent to the circle is ax + by = 1.  Similarly, for
*       C = (c, d), the equation of the line is cx + dy = 1.  The
*       intersection of these two lines is defined by:
*
*              x = (d - b) / (ad - bc)
*       and    y = (a - c) / (ad - bc).
*
*       Then, B = (x, y).
*
* 2)  Approximating the conic as a Bezier cubic
*
*       For sharpness values 'close' to 1, the conic may be approximated
*       by a cubic Bezier; error is less for sharpnesses closer to 1.
*
*     Error
*
*       Since the largest angle handled by this routine is 90 degrees,
*       sharpness is guaranteed to be between 1 / sqrt(2) = .707 and 1.
*       Error in the approximation for a 90 degree arc is approximately
*       0.2%; it is less for smaller angles.  0.2% is deemed small
*       enough error; thus, a 90 degree circular arc is always
*       approximated by just one Bezier.
*
*       One notable implication of the fact that arcs have less error
*       for smaller angles is that when a partial arc is xor-ed with
*       the corresponding complete ellipse, some of the partial arc
*       will not be completely xor-ed out.  (Too bad.)
*
*       Given a conic section defined by (A, B, C, S), we find the
*       cubic Bezier defined by the four control points (V0, V1, V2, V3)
*       that provides the closest approimxation.  We require that the
*       Bezier be tangent to the triangle at the same endpoints.  That is,
*
*               V1 = (1 - Tau1) A + (Tau1) B
*               V2 = (1 - Tau2) C + (Tau2) B
*
*       Simplify by taking Tau = Tau1 = Tau2, and we get:
*
*               V0 = A
*               V1 = (1 - Tau) A + (Tau) B
*               V2 = (1 - Tau) C + (Tau) B
*               V3 = C
*
*
*       Where Tau = 4 S / (3 (S + 1)), S being the sharpness.
*       S = cos(angle / 2) for an arc of 90 degrees or less.
*       So, for one quadrant of a circle, and since A and B actually
*       extend from the corners of the bound box, and not the center,
*
*         Tau = 1 - (4 * cos(45)) / (3 * (cos(45) + 1)) = 0.44772...
*
*       See Kirk Olynyk's "Conics to Beziers" for more.
*
* 3)    The control points for the bezier curve are scaled to the given radius.
*****************************************************************************/

Path2 *
partialQuadrantArc(Real startAngle, Real angle, Real xRadius, Real yRadius)
{
    // OZG: Line2 & PolyBezierPath2 constructors must take Point2.
    Real endAngle = startAngle + angle;
    Real sharpness = cos(angle/2),
         TAU = (sharpness * 4.0 / 3.0) / (sharpness + 1),
         oneMinusTAU = 1 - TAU;

    Real startX = cos(startAngle),
         startY = sin(startAngle),
         endX   = cos(endAngle),
         endY   = sin(endAngle),
         denom  = startX * endY - startY * endX;
    Vector2 startVec(startX, startY);
    Vector2 endVec(endX, endY);
    Vector2 middleVec(0, 0);

    Point2 startPt(startX, startY);
    Point2 endPt(endX, endY);

    if (denom == 0) {
        // We have zero angle arc.
        return Line2(startPt, endPt);
    }

    middleVec.x = (endY - startY) / denom;
    middleVec.y = (startX - endX) / denom;
    Vector2 ctl2Vec = startVec * oneMinusTAU + middleVec * TAU;
    Vector2 ctl3Vec = endVec * oneMinusTAU + middleVec * TAU;

    // The constructor will delete pts and knots.
    Point2 pts[4];
    pts[0] = startPt;
    pts[1].Set(ctl2Vec.x, ctl2Vec.y);
    pts[2].Set(ctl3Vec.x, ctl3Vec.y);
    pts[3] = endPt;

    PolyBezierPath2 *pReturn = NEW PolyBezierPath2(4, pts);
    Transform2 *xf = ScaleRR(xRadius, yRadius);
    return TransformPath2(xf, pReturn);
}

////////////////////////////////////////
// The path starts at the starting point of the arc and ends at the
// end point of the arc.

Path2 *
ArcValRRRR(Real startAngle, Real endAngle, Real width, Real height)
{
    Real sAngle = startAngle,
         eAngle = endAngle,
         angle = eAngle - sAngle,
         absAngle = fabs(angle);

    // Reduce the angle to less than 4*pi
    if (absAngle > 4*pi) {
        // We want absAngle to be betwwen 2*pi and 4*pi.
        Real quo = absAngle/(2*pi);
        absAngle -= (floor(quo)-1)*2*pi;
        if (angle < 0) {
            angle = -absAngle;
        } else {
            angle = absAngle;
        }
        eAngle = sAngle + angle;
    }

    Real quadAngle = (angle < 0) ? -pi/2 : pi/2,
         xR = width/2.0,
         yR = height/2.0;

    Path2 *pReturn = NULL, *pQuad = NULL;
    bool  bLastArc = false;

    do {
        if (fabs(eAngle - sAngle) <= pi/2) {
            pQuad = partialQuadrantArc(sAngle, eAngle-sAngle, xR, yR);
            bLastArc = true;
        } else {
            pQuad = partialQuadrantArc(sAngle, quadAngle, xR, yR);
            sAngle += quadAngle;
        }

        if (pReturn != NULL) {
            pReturn = ConcatenatePath2(pReturn, pQuad);
        } else {
            pReturn = pQuad;
        }
    } while (bLastArc == false);

    return pReturn;
}

Path2 *
ArcVal(AxANumber *startAngle, AxANumber *endAngle, AxANumber *width, AxANumber *height)
{
    return ArcValRRRR(startAngle->GetNum(),endAngle->GetNum(),
                      width->GetNum(),height->GetNum());
}

////////////////////////////////////////
// The path starts at the 0 degree point, moves counter-clockwise and
// ends at the same point.

Path2 *
OvalValRR(Real width, Real height)
{
    return ClosePath2(ArcValRRRR(0, 2*pi, width, height));
}

Path2 *
OvalVal(AxANumber *width, AxANumber *height)
{
    return OvalValRR(width->GetNum(),height->GetNum());
}

////////////////////////////////////////
// The path starts at the upper right corner of the horizontal line,
// moves counter-clockwise, and ends at the same point it starts.

Path2 *
RectangleValRR(Real width, Real height)
{
    Point2Value **pts = (Point2Value **) AllocateFromStore (4 * sizeof(Point2Value *));
    Real halfWidth = width/2;
    Real halfHeight = height/2;
    pts[0] = NEW Point2Value(halfWidth,  halfHeight);
    pts[1] = NEW Point2Value(-halfWidth, halfHeight);
    pts[2] = NEW Point2Value(-halfWidth, -halfHeight);
    pts[3] = NEW Point2Value(halfWidth,  -halfHeight);
    Path2 *rectPath = NEW PolylinePath2(4, pts, NULL);
    return ClosePath2(rectPath);
}

Path2 *
RectangleVal(AxANumber *width, AxANumber *height)
{
    return RectangleValRR(width->GetNum(),height->GetNum());
}

////////////////////////////////////////
// The path starts at the upper right corner of the horizontal line,
// moves counter-clockwise, and ends at the same point it starts.

Path2 *
RoundRectValRRRR(Real width, Real height, Real arcWidth, Real arcHeight)
{
    Real halfWidth = width/2,
         halfHeight = height/2,
         halfWidthAbs = fabs(halfWidth),
         halfHeightAbs = fabs(halfHeight),
         xR = arcWidth/2,
         yR = arcHeight/2,
         xRAbs = fabs(xR),
         yRAbs = fabs(yR);

    // Clamp arcWidth to width, arcHeight to height.
    if (halfWidthAbs < xRAbs)
        xRAbs = halfWidthAbs;
    if (halfHeightAbs < yRAbs)
        yRAbs = halfHeightAbs;

    Real halfWidthInner = halfWidthAbs - xRAbs,
         halfHeightInner = halfHeightAbs - yRAbs;

    if (halfWidth < 0)
         halfWidthInner = -halfWidthInner;
    if (halfHeight < 0)
         halfHeightInner = -halfHeightInner;

    Real widthInner = halfWidthInner*2,
         heightInner = halfHeightInner*2;

    Path2 **paths = (Path2 **)AllocateFromStore(8 * sizeof(Path2 *));
    paths[0] = Line2(Point2(halfWidthInner, halfHeight),
                     Point2(-halfWidthInner, halfHeight));
    paths[2] = RelativeLine2(NEW Point2Value(0, -heightInner));
    paths[4] = RelativeLine2(NEW Point2Value(widthInner, 0));
    paths[6] = RelativeLine2(NEW Point2Value(0, heightInner));

    // Check the end point of the first line path to decide the angle for the
    // first arc.
    Real beginAngle;
    bool inversed = (xR < 0) || (yR < 0);
    if (-halfWidthInner > 0) {
        if (halfHeight >= 0) {
            // The end point is in the 1st quadrant.
            beginAngle = inversed ? pi*3/2 : 0;
        } else {
            // The end point is in the 4th quadrant.
            beginAngle = inversed ? pi: pi*3/2;
        }
    } else if (-halfWidthInner < 0) {
        if (halfHeight > 0) {
            // The end point is in the 2nd quadrant.
            beginAngle = inversed ? 0 : pi/2;
        } else {
            // The end point is in the 3rd quadrant.
            beginAngle = inversed ? pi/2 : pi;
        }
    } else {
        if (halfHeight >= 0) {
            // The end point is in the 2nd quadrant.
            beginAngle = inversed ? 0 : pi/2;
        } else {
            // The end point is in the 4th quadrant.
            beginAngle = inversed ? pi: pi*3/2;
        }
    }

    // IHammer behavior.  Use the signs of arcWidth/arcHeight to determine the
    // direction of the arcs.
    Real angle;
    if (inversed)
        angle = -pi/2;
    else
        angle = pi/2;

    paths[1] = partialQuadrantArc(beginAngle, angle, xRAbs, yRAbs);
    beginAngle += pi/2;
    paths[3] = partialQuadrantArc(beginAngle, angle, xRAbs, yRAbs);
    beginAngle += pi/2;
    paths[5] = partialQuadrantArc(beginAngle, angle, xRAbs, yRAbs);
    beginAngle += pi/2;
    paths[7] = partialQuadrantArc(beginAngle, angle, xRAbs, yRAbs);

    return ClosePath2(ConcatenatePath2(paths, 8));
}

Path2 *
RoundRectVal(AxANumber *width, AxANumber *height, 
             AxANumber *arcWidth, AxANumber *arcHeight)
{
    return RoundRectValRRRR(width->GetNum(),height->GetNum(),
                            arcWidth->GetNum(),arcHeight->GetNum());
}


////////////////////////////////////////
// The path starts at the origin, moves to the starting point of the
// arc, continues to the end point of the arc, and ends at the origin.

Path2 *PieValRRRR (
    Real startAngle,
    Real endAngle,
    Real width,
    Real height)
{
    Real sAngle = startAngle,
         eAngle = endAngle;

    // Draw an oval if angle >= 2*pi.
    if (fabs(eAngle - sAngle) >= 2*pi) {
        return OvalValRR(width, height);
    }

    Point2 startPt(cos(sAngle),sin(sAngle));

    Path2 *pFirst = Line2(Origin2, startPt),
          *pArc = ArcValRRRR(startAngle, endAngle, 2, 2);

    Path2 *piePath = ConcatenatePath2(pFirst, pArc);
    Transform2 *xf = ScaleRR(width/2, height/2);
    return ClosePath2(TransformPath2(xf, piePath));
}

Path2 *PieVal (
    AxANumber *startAngle,
    AxANumber *endAngle,
    AxANumber *width,
    AxANumber *height)
{
    return PieValRRRR(startAngle->GetNum(),endAngle->GetNum(),
                      width->GetNum(),height->GetNum());
}


/*****************************************************************************
This function gathers information from all subpaths in the path, and maps the
total path length to the range [0,1].  It then uses 'num0to1' to evaluate the
total path, and sample the proper subpath based on the GatherLengths()
traversal.
*****************************************************************************/

Point2Value *Point2AtPath2 (Path2 *path, AxANumber *num0to1)
{
    Path2Ctx ctx (NULL, identityTransform2);

    path->GatherLengths (ctx);

    return ctx.SamplePath (CLAMP(ValNumber(num0to1), 0.0, 1.0));
}



Transform2 *Path2Transform(Path2 *path, AxANumber *num0to1)
{
    return TranslateVector2Value
           (MinusPoint2Point2 (Point2AtPath2(path, num0to1), origin2));
}


#if ONLY_IF_DOING_EXTRUSION

HINSTANCE hInstT3DScene = NULL;
CritSect *path2CritSect = NULL;


static HRESULT
MyExtrudeRegion(IDirect3DRMMeshBuilder3 *builder,
                int totalPts,
                LPPOINT pts,
                LPBYTE codes,
                Real extrusionDepth,
                bool sharedVertices,
                BYTE textureSetting,
                BYTE bevelType,
                Real frontBevelDepth,
                Real backBevelDepth,
                Real frontBevelAmt,
                Real backBevelAmt)
{
    CritSectGrabber csg(*path2CritSect);
    
    typedef HRESULT (WINAPI *ExtruderFuncType)(IDirect3DRMMeshBuilder3 *,
                                               int,
                                               LPPOINT,
                                               LPBYTE,
                                               Real,
                                               bool,
                                               BYTE,
                                               BYTE,
                                               Real,
                                               Real,
                                               Real,
                                               Real);

    static ExtruderFuncType myExtruder = NULL;
  
    if (!myExtruder) {
        hInstT3DScene = LoadLibrary("t3dscene.dll");
        if (!hInstT3DScene) {
            Assert(FALSE && "LoadLibrary of t3dscene.dll failed");
            return E_FAIL;
        }

        FARPROC fptr = GetProcAddress(hInstT3DScene, "ExtrudeRegion");
        if (!fptr) {
            Assert(FALSE && "GetProcAddress in t3dscene.dll failed");
            return E_FAIL;
        }

        myExtruder = (ExtruderFuncType)(fptr);
    }

    return (*myExtruder)(builder,
                         totalPts,
                         pts,
                         codes,
                         extrusionDepth,
                         sharedVertices,
                         textureSetting,
                         bevelType,
                         frontBevelDepth,
                         backBevelDepth,
                         frontBevelAmt,
                         backBevelAmt);
}


Geometry *extrudePath(AxANumber *extrusionDepth,
                      BYTE       textureSetting,
                      BYTE       bevelType,
                      AxANumber *frontBevelDepth,
                      AxANumber *backBevelDepth,
                      AxANumber *frontBevelAmt,
                      AxANumber *backBevelAmt,
                      Path2     *path)
{
    DAComPtr<IDirect3DRMMeshBuilder> builder;
    TD3D(GetD3DRM1()->CreateMeshBuilder(&builder));

    DAComPtr<IDirect3DRMMeshBuilder3> builder3;
    HRESULT hr =
        builder->QueryInterface(IID_IDirect3DRMMeshBuilder3,
                                (void **)&builder3);

    if (FAILED(hr)) {
        RaiseException_UserError(E_FAIL, IDS_ERR_MISCVAL_BAD_EXTRUDE);
    }

    // Get the points and codes from the path.
    HDC dc;
    TIME_GDI(dc = CreateCompatibleDC(NULL));
    
    path->AccumPathIntoDC(dc, identityTransform2, true);

    int totalPts;
    TIME_GDI(totalPts = GetPath(dc, NULL, NULL, 0));

    LPPOINT pts = THROWING_ARRAY_ALLOCATOR(POINT, totalPts);
    LPBYTE  codes = THROWING_ARRAY_ALLOCATOR(BYTE, totalPts);

    int numFilled;
    TIME_GDI(numFilled = GetPath(dc, pts, codes, totalPts));

    TIME_GDI(DeleteDC(dc));

    Assert(numFilled == totalPts);

    if (numFilled == -1) {
        hr = E_FAIL;
    } else {
        hr = MyExtrudeRegion(builder3,
                             totalPts,
                             pts,
                             codes,
                             NumberToReal(extrusionDepth),
                             true,
                             textureSetting,
                             bevelType,
                             NumberToReal(frontBevelDepth),
                             NumberToReal(backBevelDepth),
                             NumberToReal(frontBevelAmt),
                             NumberToReal(backBevelAmt));
    }
    
    delete [] pts;
    delete [] codes;

    if (FAILED(hr)) {
        RaiseException_UserError(E_FAIL, IDS_ERR_MISCVAL_BAD_EXTRUDE);
    }

    D3DRMBOX box;
    TD3D(builder->GetBox(&box));

    Bbox3 *bbx = NEW Bbox3(box.min.x, box.min.y, box.min.z,
                           box.max.x, box.max.y, box.max.z);
    
    Geometry *geo = NEW RM1MeshGeo (builder, bbx, false);

    return geo;
}


void
InitializeModule_Path2()
{
    if (!path2CritSect) {
        path2CritSect = NEW CritSect;
    }
}

void
DeinitializeModule_Path2(bool bShutdown)
{
    if (path2CritSect) {
        delete path2CritSect;
        path2CritSect = NULL;
    }
    
    if (hInstT3DScene) {
        FreeLibrary(hInstT3DScene);
    }
}

#endif ONLY_IF_DOING_EXTRUSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\spline.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of b-spline functions

*******************************************************************************/

#include "headers.h"
#include "privinc/vec2i.h"
#include "privinc/vec3i.h"
#include "privinc/except.h"
#include "privinc/debug.h"
#include "backend/values.h"
#include "include/appelles/bspline.h"
#include "backend/bvr.h"
#include "backend/perf.h"
#include "privinc/server.h"

static const Real EPSLION = 1e-6;

////////////////////  Spline Header  ///////////////////////

class ATL_NO_VTABLE Spline : public AxAValueObj {
  public:
    Spline(int degree,
           int numKnots, Real *knots,
           int numPts, AxAValue *pts,
           // numWeights == 0 indicates non-rational spline
           int numWeights, Real *weights);

    AxAValue Evaluate(Real param);

    // TODO: Not a type in avrtypes.h??
    virtual DXMTypeInfo GetTypeInfo() { return AxATrivialType; }

    virtual void DoKids(GCFuncObj proc) {
        for (int i=0; i<_numPts; i++) {
            if (_pts) (*proc)(_pts[i]);
            if (_spareArray) (*proc)(_spareArray[i]);
        }
    }

  protected:

    // Subclasses fill these in for the appropriate operations on the
    // relevant type of control point.
    virtual AxAValue CreateNewVal() = 0;
    virtual void     Copy(const AxAValue src, AxAValue& dst) = 0;
    virtual void     Add(const AxAValue v1,
                         const AxAValue v2,
                         AxAValue& result) = 0;
    virtual void     Mul(const AxAValue v,
                         const Real scalar,
                         AxAValue& result) = 0;

    void LazyInitialize();
    int  DetermineInterval(Real *param); // output the adjusted param
    
    int       _degree;
    int       _numKnots;
    Real     *_knots;
    int       _numPts;
    AxAValue *_pts;
    Bool      _rational;
    Real     *_weights;

    AxAValue    *_spareArray;         // same len as pts
    Real        *_spareWeights;       // same len as pts, if rational
    AxAValue     _temp;
    DynamicHeap& _heapCreatedOn;

    // data cached from previous evaluations
    int          _lastInterval;
};

////////////////////  Generic Spline Evaluation  ///////////////////////

Spline::Spline(int degree,
               int numKnots, Real *knots,
               int numPts, AxAValue *pts,
               int numWeights, Real *weights)
    
    : _heapCreatedOn(GetHeapOnTopOfStack())
{
    _degree = degree;
    _numKnots = numKnots;
    _knots = knots;
    _numPts = numPts;
    _pts = pts;
    _weights = weights;
    _rational = (numWeights != 0);

    _spareArray = NULL;
    _spareWeights = NULL;
    _lastInterval = 0;

    /////// Validate Input Data //////

    // Valid degree
    if (_degree < 1 || _degree > 3) {
        RaiseException_UserError(E_FAIL, IDS_ERR_SPLINE_BAD_DEGREE);
    }

    // Valid relationship between knots, points, and degree
    if (_numKnots != _numPts + _degree - 1) {
        char deg[4];
        char kn[10];
        char pts[10];
        wsprintf(deg, "%d", _degree);
        wsprintf(kn, "%d", _numKnots);
        wsprintf(pts, "%d", _numPts);
        RaiseException_UserError(E_FAIL, IDS_ERR_SPLINE_KNOT_COUNT, deg, kn, pts);
    }

    // Monotone knot vector
    for (int i = 0; i < _numKnots - 1; i++) {
        if (_knots[i] > _knots[i+1]) {
            RaiseException_UserError(E_FAIL, IDS_ERR_SPLINE_KNOT_MONOTONICITY);
        }
    }

    // Same number of weights as ctrl points.
    if (_rational && (numWeights != _numPts)) {
        RaiseException_UserError(E_FAIL, IDS_ERR_SPLINE_MISMATCHED_WEIGHTS);
    }

}

// Need to do some lazy initialization since virtual methods cannot be
// called from constructors.
void
Spline::LazyInitialize()
{
    PushDynamicHeap(_heapCreatedOn);

    // Just fill in spare array with the appropriate structure.  This
    // will be filled in during evaluation.  
    _spareArray = (AxAValue *)AllocateFromStore((_numPts + 1) * sizeof(AxAValue));
    
    for (int i = 0; i < _numPts+1; i++) {
        _spareArray[i] = CreateNewVal();
    }

    if (_rational) {
        _spareWeights = (Real *)AllocateFromStore((_numPts + 1)* sizeof(Real));
    }

    _temp = CreateNewVal();
    
    PopDynamicHeap();
}

int
Spline::DetermineInterval(Real *pU)
{
    // Heuristic assumes that u is monotonically increasing on
    // consecutive calls, thus we look at the current interval first,
    // and then the following interval.  If u is in neither, then we
    // perform an arbitrary search.

    Real u = *pU;
    
    int i = _lastInterval;
    
    if (_lastInterval != 0 && _knots[i] <= u && u < _knots[i+1]) {
        
        // In the same interval
        return i;
        
    } else if (u < _knots[_degree - 1]) {

        // If parameter less than beginning of range, clamp to
        // beginning of range.
        *pU = _knots[_degree - 1];
        return DetermineInterval(pU);
        
    } else if (u >= _knots[_numKnots - _degree]) {
        
        // If parameter greater than end of range, clamp to
        // end of range.
        *pU = _knots[_numKnots - _degree] - EPSLION;
        return DetermineInterval(pU);

    } else if ((i + 2 < _numKnots) &&
               _knots[i+1] <= u && u < _knots[i+2]) {
        
        // In the next interval
        _lastInterval = i + 1;
        return _lastInterval;

    } else if ((i == _numKnots - 1) &&
               (_knots[0] <= u && u < _knots[1])) {

        // Wrapped around back to the beginning
        _lastInterval = 0;
        return _lastInterval;
        
    } else {

        // Just do a linear search.  Could improve performance by
        // doing a binary search, but the presumption is that the
        // above special cases will pick up the vast majority of the
        // uses. 
        for (int j = 0; j <= _numKnots - 2; j++) {
            if ((_knots[j] <= u) && (u < _knots[j+1])) {
                _lastInterval = j;
                return j;
            }
        }

        // The only known reason we'd get to this point is if we have
        // the same value as the last knot.  Verify this is the case,
        // then search for the first knot with this value.
        Assert(u == _knots[_numKnots-1]);
        for (j = 0; j <= _numKnots - 2; j++) {
            if (_knots[j+1] == u) {
                _lastInterval = j;
                return j;
            }
        }

        Assert(FALSE && "Shouldn't be here");
    }
    
    return 0;
}

AxAValue
Spline::Evaluate(Real u)
{
    if (_spareArray == NULL) {
        LazyInitialize();
    }

    int interval = DetermineInterval(&u);

    // B-spline evaluator below uses the deBoor knot-insertion
    // algorithm, from Farin, Curves and Surfaces for CAGD, 
    // 3rd Ed., Chapter 10.
    
    int j, k;
    Real t1, t2;

    TraceTag((tagSplineEval,
              "Array fill: start = %d, stop = %d",
              interval - _degree + 1,
              interval + 1));
             
    // Re-fill relevant portions of the spare array
    for (j = interval - _degree + 1; j <= interval + 1; j++) {
        Copy(_pts[j], _spareArray[j]);
    }

    if (_rational) {
        for (j = interval - _degree + 1; j <= interval + 1; j++) {
            _spareWeights[j] = _weights[j];
        }
    }

    for (k = 1; k <= _degree; k++) {
        
        int lowerRange = interval - _degree + k + 1;
        
        TraceTag((tagSplineEval,
                  "Ranging j: start = %d, stop = %d",
                  interval + 1,
                  lowerRange));

        for (j = interval + 1; j >= lowerRange; j--) {

            int knotIndex = j + _degree - k;
            t1 = (_knots[knotIndex] - u) /
                 (_knots[knotIndex] - _knots[j - 1]);

            t2 = 1.0 - t1;

            // Following has the effect of
            //  sa[j] = t1 * sa[j-1] + t2 * sa[j];
            Mul(_spareArray[j-1], t1, _temp);
            Mul(_spareArray[j], t2, _spareArray[j]);
            Add(_spareArray[j], _temp, _spareArray[j]);

            if (_rational) {
                _spareWeights[j] = t1 * _spareWeights[j-1] +
                                   t2 * _spareWeights[j];
            }

        }
    }

    // Copy the result into a newly allocated value.
    AxAValue retVal = CreateNewVal();
    Copy(_spareArray[interval + 1], retVal);
    
    if (_rational) {

        // Get w coordinate of result, but if it's zero, avoid a
        // numerical error by making it extremely small.
        Real w = _spareWeights[interval + 1];
        if (w == 0) {
            w = 1e-30;
        }
        
        // Divide by w.
        Mul(retVal, 1.0/w, retVal);
    }
    
    return retVal;
}

////////////////////  Subclasses  ///////////////////////

//////////  Number //////////

class NumSpline : public Spline {
  public:
    NumSpline(int degree,
              int numKnots, Real *knots,
              int numPts, AxAValue *pts,
              int numWeights, Real *weights) :
    Spline(degree, numKnots, knots, numPts, pts, numWeights, weights) {}

  protected:
    AxAValue CreateNewVal() { return NEW AxANumber; }
    
    void Copy(const AxAValue src, AxAValue& dst) {
        ((AxANumber *&)dst)->SetNum(ValNumber(src));
    }
    
    void Add(const AxAValue val1, const AxAValue val2, AxAValue& result) {
        ((AxANumber *&)result)->SetNum(ValNumber(val1) +
                                       ValNumber(val2));
    }
    
    void Mul(const AxAValue val, const Real scalar, AxAValue& result) {
        ((AxANumber *&)result)->SetNum(ValNumber(val) * scalar);
    };
};

//////////  Point2 //////////

class Pt2Spline : public Spline {
  public:
    Pt2Spline(int degree,
              int numKnots, Real *knots,
              int numPts, AxAValue *pts,
              int numWeights, Real *weights) :
    Spline(degree, numKnots, knots, numPts, pts, numWeights, weights) {}
    
  protected:
    AxAValue CreateNewVal() { return NEW Point2Value; }
    
    void Copy(const AxAValue s, AxAValue& d) {
        Point2Value *src = (Point2Value *)s;
        Point2Value *& dst = (Point2Value *&)d;
        dst->x = src->x;
        dst->y = src->y;
    }
    
    void Add(const AxAValue val1, const AxAValue val2, AxAValue& result) {
        Point2Value *p1 = (Point2Value *)val1;
        Point2Value *p2 = (Point2Value *)val2;
        ((Point2Value *&)result)->x = p1->x + p2->x;
        ((Point2Value *&)result)->y = p1->y + p2->y;
    }
    
    void Mul(const AxAValue val, const Real scalar, AxAValue& result) {
        Point2Value *p = (Point2Value *)val;
        ((Point2Value *&)result)->x = p->x * scalar;
        ((Point2Value *&)result)->y = p->y * scalar;
    };
};

//////////  Point3 //////////

class Pt3Spline : public Spline {
  public:
    Pt3Spline(int degree,
              int numKnots, Real *knots,
              int numPts, AxAValue *pts,
              int numWeights, Real *weights) :
    Spline(degree, numKnots, knots, numPts, pts, numWeights, weights) {}
    
  protected:
    AxAValue CreateNewVal() { return NEW Point3Value; }
    
    void Copy(const AxAValue s, AxAValue& d) {
        Point3Value *src = (Point3Value *)s;
        Point3Value *& dst = (Point3Value *&)d;
        dst->x = src->x;
        dst->y = src->y;
        dst->z = src->z;
    }

    void Add(const AxAValue val1, const AxAValue val2, AxAValue& result) {
        Point3Value *p1 = (Point3Value *)val1;
        Point3Value *p2 = (Point3Value *)val2;
        ((Point3Value *&)result)->x = p1->x + p2->x;
        ((Point3Value *&)result)->y = p1->y + p2->y;
        ((Point3Value *&)result)->z = p1->z + p2->z;
    }
    
    void Mul(const AxAValue val, const Real scalar, AxAValue& result) {
        Point3Value *p = (Point3Value *)val;
        ((Point3Value *&)result)->x = p->x * scalar;
        ((Point3Value *&)result)->y = p->y * scalar;
        ((Point3Value *&)result)->z = p->z * scalar;
    };
};

//////////  Vector2 //////////

class Vec2Spline : public Spline {
  public:
    Vec2Spline(int degree,
               int numKnots, Real *knots,
               int numPts, AxAValue *pts,
               int numWeights, Real *weights) :
    Spline(degree, numKnots, knots, numPts, pts, numWeights, weights) {}
    
  protected:
    AxAValue CreateNewVal() { return NEW Vector2Value; }
    
    void Copy(const AxAValue s, AxAValue& d) {
        Vector2Value *src = (Vector2Value *)s;
        Vector2Value *& dst = (Vector2Value *&)d;
        dst->x = src->x;
        dst->y = src->y;
    }

    void Add(const AxAValue val1, const AxAValue val2, AxAValue& result) {
        Vector2Value *p1 = (Vector2Value *)val1;
        Vector2Value *p2 = (Vector2Value *)val2;
        ((Vector2Value *&)result)->x = p1->x + p2->x;
        ((Vector2Value *&)result)->y = p1->y + p2->y;
    }
    
    void Mul(const AxAValue val, const Real scalar, AxAValue& result) {
        Vector2Value *p = (Vector2Value *)val;
        ((Vector2Value *&)result)->x = p->x * scalar;
        ((Vector2Value *&)result)->y = p->y * scalar;
    };
};


//////////  Vector3 //////////

class Vec3Spline : public Spline {
  public:
    Vec3Spline(int degree,
               int numKnots, Real *knots,
               int numPts, AxAValue *pts,
               int numWeights, Real *weights) :
    Spline(degree, numKnots, knots, numPts, pts, numWeights, weights) {}
    
  protected:
    AxAValue CreateNewVal() { return NEW Vector3Value; }
    
    void Copy(const AxAValue s, AxAValue& d) {
        Vector3Value *src = (Vector3Value *)s;
        Vector3Value *& dst = (Vector3Value *&)d;
        dst->x = src->x;
        dst->y = src->y;
        dst->z = src->z;
    }

    void Add(const AxAValue val1, const AxAValue val2, AxAValue& result) {
        Vector3Value *p1 = (Vector3Value *)val1;
        Vector3Value *p2 = (Vector3Value *)val2;
        ((Vector3Value *&)result)->x = p1->x + p2->x;
        ((Vector3Value *&)result)->y = p1->y + p2->y;
        ((Vector3Value *&)result)->z = p1->z + p2->z;
    }
    
    void Mul(const AxAValue val, const Real scalar, AxAValue& result) {
        Vector3Value *p = (Vector3Value *)val;
        ((Vector3Value *&)result)->x = p->x * scalar;
        ((Vector3Value *&)result)->y = p->y * scalar;
        ((Vector3Value *&)result)->z = p->z * scalar;
    };
};

////////////////  Construction Functions  /////////////////


#define DEFINE_SPLINE_CONSTRUCTOR_FUNC(funcName, className) \
    Spline *                                       \
    funcName(int degree,                           \
             int numKnots, Real *knots,            \
             int numPts, AxAValue *pts,               \
             int numWeights, Real *weights)        \
    {                                              \
        return NEW className(degree,               \
                             numKnots, knots,      \
                             numPts, pts,          \
                             numWeights, weights); \
    }


DEFINE_SPLINE_CONSTRUCTOR_FUNC(NumberSpline, NumSpline);
DEFINE_SPLINE_CONSTRUCTOR_FUNC(Point2Spline, Pt2Spline);
DEFINE_SPLINE_CONSTRUCTOR_FUNC(Point3Spline, Pt3Spline);
DEFINE_SPLINE_CONSTRUCTOR_FUNC(Vector2Spline, Vec2Spline);
DEFINE_SPLINE_CONSTRUCTOR_FUNC(Vector3Spline, Vec3Spline);

//////////////  Construction from the untyped backend (calls more
/////////////   appropriately typed functions defined above.

typedef Spline *(*SplineConstructorFuncType)(int,
                                             int, Real *,
                                             int, AxAValue *,
                                             int, Real *);



static Spline *
buildSpline(int degree,
            long numKnots,
            long numPts,
            AxAValue *knotList,
            AxAValue *ptList,
            AxAValue *weightList,
            DXMTypeInfo tinfo)
{
    long i;

    Real *knots = (Real *)AllocateFromStore(numKnots * sizeof(Real));
    AxAValue *pts = (AxAValue *)AllocateFromStore(numPts * sizeof(AxAValue));
    
    for (i = 0; i < numKnots; i++) 
        knots[i] = ValNumber(knotList[i]);

    for (i = 0; i < numPts; i++) 
        pts[i] = ptList[i];

    AxAValue samplePt = pts[0];

    SplineConstructorFuncType constructorFunc;

    if (AxANumberType == tinfo) {
        constructorFunc = NumberSpline;
    } else if (Point2ValueType == tinfo) {
        constructorFunc = Point2Spline;
    } else if (Point3ValueType == tinfo) {
        constructorFunc = Point3Spline;
    } else if (Vector2ValueType == tinfo) {
        constructorFunc = Vector2Spline;
    } else if (Vector3ValueType == tinfo) {
        constructorFunc = Vector3Spline;
    } else {
        Assert(FALSE && "Shouldn't be here!!");
    }

    Spline *sp;
    
    if (weightList && (numPts > 0)) {
        
        int numWeights = numPts;
        Real *weights = (Real *)AllocateFromStore(numWeights * sizeof(Real));
        for (i = 0; i < numWeights; i++) 
            weights[i] = ValNumber(weightList[i]);
        
        sp = (*constructorFunc)(degree,
                                numKnots, knots,
                                numPts, pts,
                                numWeights, weights);

    } else {
        
        sp = (*constructorFunc)(degree,
                                numKnots, knots,
                                numPts, pts,
                                0, NULL);
    }

    return sp;
}

class SplinePerfImpl : public PerfImpl {
  public:
    SplinePerfImpl::SplinePerfImpl(TimeXform tt,
                                   Spline *spl,
                                   Perf evaluator,
                                   DXMTypeInfo tinfo);
    
    SplinePerfImpl::SplinePerfImpl(TimeXform tt,
                                   int degree,
                                   long k,
                                   long numPts,
                                   Perf *knotList,
                                   Perf *pointList,
                                   Perf *weightList,
                                   Perf evaluator,
                                   DXMTypeInfo tinfo);
    
    virtual AxAValue _Sample(Param& p);
    
    virtual void _DoKids(GCFuncObj proc) {
        long i;
        
        Assert(_evaluatorP && _tt && _tinfo);    // should always be there.
        
        (*proc)(_tt);

        (*proc)(_evaluatorP);

        if (_spl) _spl->DoKids(proc);

        if (_knotListP) 
            for (i=0; i<_k; i++)
                (*proc)(_knotListP[i]);

        for (i=0; i<_numPts; i ++) {
            if (_pointListP) (*proc)(_pointListP[i]);
            if (_weightListP) (*proc)(_weightListP[i]);
        }

        (*proc)(_tinfo);
        (*proc)(_spl);
    }

    virtual void CleanUp() {
    }

    virtual ~SplinePerfImpl() {
        CleanUp();
    }
    
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "splineP"; }
#endif
    
  private:
    TimeXform        _tt;
    DXMTypeInfo _tinfo;
    Perf             *_knotListP;
    Perf             *_pointListP;
    Perf             *_weightListP;
    Perf             _evaluatorP;
    int              _degree;
    long             _k;
    long             _numPts;
    Spline *         _spl;
};

SplinePerfImpl::SplinePerfImpl(TimeXform tt,
                               Spline *spl,
                               Perf evaluator,
                               DXMTypeInfo tinfo)
: _tt(tt), _spl(spl), _evaluatorP(evaluator), _tinfo(tinfo),
  _k(0), _numPts(0), _degree(0),
  _knotListP(NULL), _pointListP(NULL), _weightListP(NULL)
{
}

SplinePerfImpl::SplinePerfImpl(TimeXform tt,
                               int degree,
                               long k,
                               long numPts,
                               Perf *knotList,
                               Perf *pointList,
                               Perf *weightList,
                               Perf evaluator,
                               DXMTypeInfo tinfo)
: _tt(tt), _spl(NULL), _evaluatorP(evaluator), _tinfo(tinfo),
  _degree(degree), _k(k), _numPts(numPts),
  _knotListP(knotList), _pointListP(pointList), _weightListP(weightList)
{
}

AxAValue
SplinePerfImpl::_Sample(Param& p) {

    Spline *splineToSample;

    // If we're constant, use the spline we've already constructed,
    // else create a NEW one from the sampled lists.
    if (_spl) {
        
        splineToSample = _spl;
        
    } else {

        AxAValue *kv =
            (AxAValue*) AllocateFromStore(_k * sizeof(AxAValue));
        AxAValue *pv =
            (AxAValue*) AllocateFromStore(_numPts * sizeof(AxAValue));
        AxAValue *wv = _weightListP ?
            (AxAValue*) AllocateFromStore(_numPts * sizeof(AxAValue))
            : NULL;

        long i;

        for (i=0; i<_k; i++) {
            kv[i] = _knotListP[i]->Sample(p);
            if (!kv[i])
                break;
        }

        for (i=0; i<_numPts; i ++) {
            pv[i] = _pointListP[i]->Sample(p);
            if (wv) wv[i] = _weightListP[i]->Sample(p);
        }

        splineToSample = 
            buildSpline(_degree, _k, _numPts, kv, pv, wv, _tinfo);
        
    }

    AxANumber *evalParam = (AxANumber *)(_evaluatorP->Sample(p));

    Real newT = NumberToReal(evalParam);

    // Finally, pass into spline evaluation.
    return splineToSample->Evaluate(newT);
}
    
//////////////////  Behavior  ////////////////////

class SplineBvrImpl : public BvrImpl {
  public:
    SplineBvrImpl(int degree,
                  long numPts,
                  Bvr *knotList,
                  Bvr *pointList,
                  Bvr *weightList,
                  Bvr evaluator,
                  DXMTypeInfo tinfo)
          : _degree(degree),
            _numPts(numPts),
            _knotList(knotList),
            _pointList(pointList),
            _weightList(weightList),
            _evaluator(evaluator),
            _tinfo(tinfo),
            _splineHeap(NULL) {
                _k = _numPts + _degree - 1;
                _spl = GetSpline();
                GetInfo(true);
    }

    ~SplineBvrImpl() { 
        Assert((!_spl || _splineHeap) &&
               "No spline heap before CleanUp, only CleanUp or Destructor should be called, not both.");
        CleanUp();
    }
    
    virtual void CleanUp() {
        {
            DynamicHeapPusher dph(GetSystemHeap());

            if (_knotList) DeallocateFromStore(_knotList);
            if (_pointList) DeallocateFromStore(_pointList);
            if (_weightList) DeallocateFromStore(_weightList);
        }

        if (_splineHeap) {
            // delete _splineHeap;
            _splineHeap = NULL;
        }
    }

    Spline *GetSpline() {
        Bool isConst = TRUE;

        AxAValue *kv, *pv, *wv;
        
        // Create a heap for data allocated during spline
        // construction.  Will be deleted upon destruction/cleanup. Or
        // if it's not a constant.
        _splineHeap = &TransientHeap("Spline Heap", 250);

        {
            DynamicHeapPusher dhp(*_splineHeap);

            kv = (AxAValue*) AllocateFromStore(_k * sizeof(AxAValue));
            pv = (AxAValue*) AllocateFromStore(_numPts * sizeof(AxAValue));
            wv = _weightList ?
                (AxAValue*) AllocateFromStore(_numPts * sizeof(AxAValue))
                : NULL;
                
            long i;

            for (i=0; i<_k; i++) {
                ConstParam cp;
                kv[i] = _knotList[i]->GetConst(cp);
                if (!kv[i]) {
                    isConst = FALSE;
                    break;
                }
            }

            if (isConst) {
                ConstParam cp;
                for (i=0; i<_numPts; i ++) {
                    pv[i] = _pointList[i]->GetConst(cp);
                    if (!pv[i]) {
                        isConst = FALSE;
                        break;
                    }
                    if (wv) {
                        wv[i] = _weightList[i]->GetConst(cp);
                        if (!wv[i]) {
                            isConst = FALSE;
                            break;
                        }
                    }
                }
            }
        }

        if (isConst) {
            DynamicHeapPusher dhp(*_splineHeap);
            
            return buildSpline(_degree, _k, _numPts, kv, pv, wv, _tinfo);
        } else {
            delete _splineHeap;
            _splineHeap = NULL;
        }

        return NULL;
    }

    virtual DWORD GetInfo(bool recalc) {
        if (recalc) {
            _info = _evaluator->GetInfo(recalc);

            long i;
        
            if (_knotList) {
                for (i=0; i<_k; i++)
                    _info &= _knotList[i]->GetInfo(recalc);
            }
        
            for (i=0; i<_numPts; i++) {
                if (_pointList)
                    _info &= _pointList[i]->GetInfo(recalc);
                if (_weightList)
                    _info &= _weightList[i]->GetInfo(recalc);
            }
        }

        return _info;
    }
    
    virtual Perf _Perform(PerfParam& p) {
        if (_spl)
            return
                NEW SplinePerfImpl(p._tt, _spl,
                                   ::Perform(_evaluator, p),
                                   _tinfo);
        else {
            Perf *kp, *pp, *wp;
            
            {
                DynamicHeapPusher dhp(GetSystemHeap());
                
                kp = (Perf *) AllocateFromStore(_k * sizeof(Perf));
                pp = (Perf *) AllocateFromStore(_numPts * sizeof(Perf));
                wp = _weightList ?
                    (Perf *) AllocateFromStore(_numPts * sizeof(Perf))
                    : NULL;
            }
            
            long i;

            for (i=0; i<_k; i++)
                kp[i] = ::Perform(_knotList[i], p);
            for (i=0; i<_numPts; i ++) {
                pp[i] = ::Perform(_pointList[i], p);
                if (wp)
                    wp[i] = ::Perform(_weightList[i], p);
            }

            return NEW SplinePerfImpl(p._tt, _degree, _k, _numPts,
                                      kp, pp, wp, 
                                      ::Perform(_evaluator, p),
                                      _tinfo);
        }
    }

    virtual void _DoKids(GCFuncObj proc) {
        long i;
        
        if (_knotList) 
            for (i=0; i<_k; i++)
                (*proc)(_knotList[i]);
        
        for (i=0; i<_numPts; i++) {
            if (_pointList) (*proc)(_pointList[i]);
            if (_weightList) (*proc)(_weightList[i]);
        }
        
        if (_evaluator) (*proc)(_evaluator);

        if (_spl) (*proc)(_spl);
        (*proc)(_tinfo);
    }
        
#if _USE_PRINT
    virtual ostream& Print(ostream& os) { return os << "splinebvr"; }
#endif

    virtual DXMTypeInfo GetTypeInfo () { return _tinfo; }

  protected:
    int _degree;
    long _numPts;
    long _k;
    Bvr *_knotList;
    Bvr *_pointList;
    Bvr *_weightList;
    Bvr _evaluator;
    DXMTypeInfo _tinfo;
    Spline          *_spl;
    DynamicHeap     *_splineHeap;
    DWORD _info;
};


Bvr ConstructBSplineBvr(int degree,
                        long numPts,
                        Bvr *knots,
                        Bvr *points,
                        Bvr *weights,
                        Bvr evaluator,
                        DXMTypeInfo tinfo)
{
    return NEW SplineBvrImpl(degree,
                             numPts,
                             knots,
                             points,
                             weights,
                             evaluator,
                             tinfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\sound\dmusic.cpp ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\vec2.cpp ===
/*++
******************************************************************************
Copyright (c) 1995-96  Microsoft Corporation

Abstract:
    Implementation of 2D vectors and points.

******************************************************************************
--*/

#include "headers.h"
#include "privinc/vec2i.h"
#include "privinc/basic.h"


/*******************/
/***  Constants  ***/
/*******************/

Vector2Value *xVector2    = NULL;
Vector2Value *yVector2    = NULL;
Vector2Value *zeroVector2 = NULL;

Point2Value *origin2      = NULL;


/*****************************************************************************
External Interfaces for Vector Types
*****************************************************************************/

Vector2Value *XyVector2(AxANumber *x, AxANumber *y)
{   return NEW Vector2Value (NumberToReal(x), NumberToReal(y));
}

Vector2Value *XyVector2RR(Real x, Real y)
{   return NEW Vector2Value (x, y);
}

Vector2Value *PolarVector2(AxANumber *angle, AxANumber *radius)
{   Real a = NumberToReal(angle);
    Real r = NumberToReal(radius);

    return NEW Vector2Value(cos(a) * r, sin(a) * r);
}

Vector2Value *PolarVector2RR(Real angle, Real radius)
{   return NEW Vector2Value(cos(angle) * radius, sin(angle) * radius);
}

Vector2Value *NormalVector2(Vector2Value *V)
{   Vector2Value *result = NEW Vector2Value (*V);
    result->Normalize();
    return result;
}

AxANumber *LengthSquaredVector2 (Vector2Value *v)
{   return RealToNumber (v->LengthSquared());
}

AxANumber *LengthVector2 (Vector2Value *v)
{   return RealToNumber (v->Length());
}

Vector2Value *MinusVector2Vector2 (Vector2Value *v1, Vector2Value *v2)
{   return NEW Vector2Value (*v1 - *v2);
}

Vector2Value *PlusVector2Vector2 (Vector2Value *v1, Vector2Value *v2)
{   return NEW Vector2Value (*v1 + *v2);
}

Vector2Value *NegateVector2 (Vector2Value *v)
{   return NEW Vector2Value (-(*v));
}

Vector2Value *ScaleRealVector2R (Real scalar, Vector2Value *v)
{   return NEW Vector2Value (scalar * (*v));
}

Vector2Value *ScaleRealVector2 (AxANumber *scalar, Vector2Value *v)
{   return ScaleRealVector2R (NumberToReal(scalar), v);
}

Vector2Value *ScaleVector2Real(Vector2Value *v, AxANumber *scalar)
{   return ScaleRealVector2R (NumberToReal(scalar), v);
}

Vector2Value *DivideVector2Real(Vector2Value *v, AxANumber *scalar)
{   return NEW Vector2Value (*v / NumberToReal(scalar));
}

Vector2Value *DivideVector2RealR(Vector2Value *v, Real scalar)
{   return NEW Vector2Value (*v / scalar);
}

AxANumber *DotVector2Vector2 (Vector2Value *A, Vector2Value *B)
{   return RealToNumber (Dot(*A,*B));
}

Real RDotVector2Vector2 (Vector2Value *A, Vector2Value *B)
{   return Dot(*A,*B);
}

Real CrossVector2Vector2(Vector2Value *A, Vector2Value *B)
{   return Cross (*A, *B);
}

#if _USE_PRINT
ostream& operator<< (ostream& os, Vector2Value& v)
{   return os << "<" << v.x << ", " << v.y << ">";
}
#endif



/*****************************************************************************
Functions on Points
*****************************************************************************/

Point2Value *XyPoint2 (AxANumber *x, AxANumber *y)
{   return NEW Point2Value (NumberToReal(x), NumberToReal(y));
}

Point2Value *XyPoint2RR (Real x, Real y)
{   return NEW Point2Value (x, y);
}

Point2Value *PolarPoint2 (AxANumber *angle, AxANumber *radius)
{
    Real r = NumberToReal(radius);
    Real a = NumberToReal(angle);
    return NEW Point2Value(cos(a) * r, sin(a) * r);
}

Point2Value *PolarPoint2RR (Real angle, Real radius)
{   return NEW Point2Value(cos(angle) * radius, sin(angle) * radius);
}

Vector2Value *MinusPoint2Point2 (Point2Value *P, Point2Value *Q)
{   return NEW Vector2Value (*P - *Q);
}

Point2Value *PlusPoint2Vector2 (Point2Value *P, Vector2Value *V)
{   return NEW Point2Value (*P + *V);
}

Point2Value *MinusPoint2Vector2 (Point2Value *P, Vector2Value *V)
{   return NEW Point2Value (*P - *V);
}

AxANumber *DistancePoint2Point2 (Point2Value *P, Point2Value *Q)
{   return RealToNumber (Distance (*P, *Q));
}

AxANumber *DistanceSquaredPoint2Point2 (Point2Value *P, Point2Value *Q)
{   return RealToNumber (DistanceSquared (*P, *Q));
}

#if _USE_PRINT
ostream& operator<< (ostream& os, Point2Value& P)
{   return os << "<" << P.x << ", " << P.y << ">";
}
#endif



//////////////  Extractors  ////////////

AxANumber *XCoordVector2(Vector2Value *v) { return RealToNumber(v->x); }
AxANumber *YCoordVector2(Vector2Value *v) { return RealToNumber(v->y); }
AxANumber *RhoCoordVector2(Vector2Value *v) { return LengthVector2(v); }
AxANumber *ThetaCoordVector2(Vector2Value *v) {return RealToNumber(atan2(v->y, v->x));}

AxANumber *XCoordPoint2(Point2Value *p) { return RealToNumber(p->x); }
AxANumber *YCoordPoint2(Point2Value *p) { return RealToNumber(p->y); }
AxANumber *RhoCoordPoint2(Point2Value *p) {return DistancePoint2Point2(origin2, p);}
AxANumber *ThetaCoordPoint2(Point2Value *p) {return RealToNumber(atan2(p->y, p->x));}


void
InitializeModule_Vec2()
{
    xVector2    = NEW Vector2Value (1, 0);
    yVector2    = NEW Vector2Value (0, 1);
    zeroVector2 = NEW Vector2Value (0, 0);
    origin2     = NEW Point2Value (0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\text.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of the text type

*******************************************************************************/


#include "headers.h"
#include "appelles/text.h"
#include "appelles/axachstr.h"
#include "privinc/textctx.h"
#include "privinc/imagei.h"
#include "privinc/texti.h"
#include "privinc/dddevice.h"
#include "privinc/basic.h"
#include "backend/values.h"



///////////// Text Context
void  TextCtx::
RenderString(WideString str)
{
    DirectDrawImageDevice* idev = _dev;
    if(!idev) {
        idev = GetImageRendererFromViewport( GetCurrentViewport() );
    }

    switch(_forWhat) {
      case renderForBox:

        Assert(idev && "No imgdev avail in textCtx! <derive bbox>");
        
        if( GetFixedText() ) {
            _stashedBbox = idev->DeriveStaticTextBbox(*this, str);
        } else {
            bool bCharXf = GetCharacterTransform() ? true:false;
            _stashedBbox = idev->DeriveDynamicTextBbox(*this, str, bCharXf);
        }

        break;

      case renderForColor:

        _stashedColor = _col;
        break;

      case renderForPath:
        
        Assert(idev && "No imgdev avail in textCtx! <renderForPath>");
        Assert(_dc && "Bad _dc in textCtx! <renderForPath>");
        Assert(_xform && "Bad _xform in textCtx! <renderForPath>");

        if( GetFixedText() ) {
            idev->RenderStaticTextOnDC(*this, str, _dc, _xform);
        } else {
            idev->RenderDynamicTextOnDC(*this, str, _dc, _xform);
        }
        break;

      case renderForReal:
      default:
        Assert(idev && "No imgdev avail in textCtx! <render string>");

        //
        // Ask the image device to render the text.
        // Pass this context along with the string to render.
        //
        idev->RenderText(*this, str, _textImg);
        break;
    }
}   


////////////  Font functionality
FontFamily *serifProportional;
FontFamily *sansSerifProportional;
FontFamily *monospaced;

////////////  Text functionality

////////////  String functionality

AxAString *
NumberString(AxANumber *num, AxANumber *precision)
{
    char numBuffer[256];

    numBuffer[0] = 0;
    numBuffer[ARRAY_SIZE(numBuffer) - 1] = 0;
    int precis = (int)NumberToReal(precision);

    // clamp the precision to avoid bugs and weird errors.
    if (precis > 32) precis = 32;
    if (precis < 0) precis = 0;
    
    // The printf directive %.*f indicates that the precision should
    // be gotten from the argument list, and to format the number as a
    // floating point with the specified precision.
    _snprintf(numBuffer,
              ARRAY_SIZE(numBuffer) - 1,
              "%.*f",
              precis,
              NumberToReal(num));

    return CharPtrToString(numBuffer);
}

////////// Text is defined and implemented in privinc/texti.h


class SimpleTextImpl : public Text {
  public:
    SimpleTextImpl(AxAString * str) : _str(str) {}
    void RenderToTextCtx(TextCtx& ctx) {
        ctx.RenderString(_str->GetStr());
    }
    int GetCharacterCount() {
        // room for some optimization here.
        return lstrlenW(_str->GetStr());
    }
    WideString GetStringPtr() { return _str->GetStr(); }
    virtual void DoKids(GCFuncObj proc) { (*proc)(_str); }
  protected:
    AxAString * _str;
};

Text *SimpleText(AxAString * str)
{ return NEW SimpleTextImpl(str); }

////////////

class CatenatedTextImpl : public Text {
  public:
    CatenatedTextImpl(Text *a, Text *b) : _first(a), _second(b) {}
    void RenderToTextCtx(TextCtx& ctx) {
        _first->RenderToTextCtx(ctx);
        _second->RenderToTextCtx(ctx);
    }
    int GetCharacterCount() {
        Assert(FALSE && "Should not be using Concatinated text");
        return 0;
    }
    WideString GetStringPtr() {
        Assert(FALSE && "GetStringPtr not implemented on CatenatedText");
        return _first->GetStringPtr();
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_first);
        (*proc)(_second);
    }
  protected:
    Text *_first;
    Text *_second;
};

Text *CatenateText(Text *a, Text *b) { return NEW CatenatedTextImpl(a,b); }

////////////

class ColoredTextImpl : public Text {
  public:
    ColoredTextImpl(Color *c, Text *txt) : _color(c), _txt(txt) {}
    void RenderToTextCtx(TextCtx& ctx) {
        // Overriding attr: If the attr has already been set, this
        // won't do anything.
        ctx.SetColor(_color);
        _txt->RenderToTextCtx(ctx);
        ctx.ResetColor();
    }
    int GetCharacterCount() {
        return _txt->GetCharacterCount();
    }
    WideString GetStringPtr() {
        return _txt->GetStringPtr();
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_color);
        (*proc)(_txt);
    }

  protected:
    Color *_color;
    Text *_txt;
};

Text *TextColor(Color *c, Text *t) { return NEW ColoredTextImpl(c,t); }

////////////

class FontedTextImpl : public Text {
  public:
    FontedTextImpl(FontFamily *f, int size, Text *txt) : _font(f), _fontSize(size), _txt(txt) {}
    void RenderToTextCtx(TextCtx& ctx) {
        // Overriding attr: If the attr has already been set, this
        // won't do anything.
        ctx.SetFont(_font->GetFontFamily());
        ctx.SetFontFamily(_font->GetFontFamilyName()?_font->GetFontFamilyName()->GetStr():NULL);
        ctx.SetFontSize(_fontSize);
        
        _txt->RenderToTextCtx(ctx);
        ctx.ResetFont();
    }
    int GetCharacterCount() {
        return _txt->GetCharacterCount();
    }
    WideString GetStringPtr() {
        return _txt->GetStringPtr();
    }

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_font);
        (*proc)(_txt);
    }

  protected:
    FontFamily* _font;
    int  _fontSize;
    Text *_txt;
};

Text *TextFont(FontFamily *font, int size, Text *txt)
{ return NEW FontedTextImpl(font, size, txt); }

//Text *TextFontFromString(AxAString *fontStr, Text *txt)
//{ return NEW FontedTextImpl(NEW FontFamily(fontStr), txt); }


////////////

class AttributedTextImpl : public Text {
  public:

    enum Attr {
        bold,
        italic,
        underline,
        strikethrough,
        weight,
        antialiased,
        fixedText,
        characterTransform
    };

    AttributedTextImpl(Attr a, Text *txt) :
    _a(a), _txt(txt), _characterTransform(NULL) {}

    void RenderToTextCtx(TextCtx& ctx) {

        Real oldWeight;
        Real oldAntiAliased;
        Transform2 *oldCxf;
        switch (_a) {
          case bold:
            ctx.SetBold(TRUE);
            break;

          case italic:
            ctx.SetItalic(TRUE);
            break;

          case underline:
            ctx.SetUnderline(TRUE);
            break;

          case strikethrough:
            ctx.SetStrikethrough(TRUE);
            break;

          case weight:
            oldWeight = ctx.GetWeight();
            ctx.SetWeight(_weight);
            break;

          case antialiased:
            oldAntiAliased = ctx.GetAntiAlias();
            ctx.SetAntiAlias(_antiAlias);
            break;

          case fixedText:
            ctx.SetFixedText(true);
            break;

          case characterTransform:
            oldCxf = ctx.GetCharacterTransform();
            ctx.SetCharacterTransform(_characterTransform);
            break;
        }

        _txt->RenderToTextCtx(ctx);

        switch (_a) {
          case bold:
            ctx.SetBold(FALSE);
            break;

          case italic:
            ctx.SetItalic(FALSE);
            break;

          case underline:
            ctx.SetUnderline(FALSE);
            break;

          case strikethrough:
            ctx.SetStrikethrough(FALSE);
            break;

          case weight:
            ctx.SetWeight(oldWeight);
            break;
            
          case antialiased:
            ctx.SetAntiAlias(oldAntiAliased);
            break;
            
          case fixedText:
            ctx.SetFixedText(false);
            break;

          case characterTransform:
            ctx.SetCharacterTransform( oldCxf );
            break;
        }

    }
    int GetCharacterCount() {
        return _txt->GetCharacterCount();
    }
    WideString GetStringPtr() {
        return _txt->GetStringPtr();
    }
    void SetWeight(Real hs) { _weight = hs; }
    void SetAntiAlias(Real aa) { _antiAlias = aa; }
    void SetCharacterTransform(Transform2 *xf) {
        _characterTransform = xf;
    }
    
    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_txt);
        (*proc)(_characterTransform);
    }

  protected:
    Text *_txt;
    Attr   _a;
    Real   _weight;
    Real   _antiAlias;
    Transform2 *_characterTransform;
};

Text *TextBold(Text *t)
{ return NEW AttributedTextImpl(AttributedTextImpl::bold, t); }

Text *TextItalic(Text *t)
{ return NEW AttributedTextImpl(AttributedTextImpl::italic, t); }

Text *TextStrikethrough(Text *t)
{ return NEW AttributedTextImpl(AttributedTextImpl::strikethrough, t); }

Text *TextUnderline(Text *t)
{ return NEW AttributedTextImpl(AttributedTextImpl::underline, t); }

Text *TextFixedText(Text *t)
{ return NEW AttributedTextImpl(AttributedTextImpl::fixedText, t); }

Text *TextAntiAliased(Real antiAlias, Text *t)
{
    AttributedTextImpl *ti = 
        NEW AttributedTextImpl(AttributedTextImpl::antialiased, t);
    ti->SetAntiAlias(antiAlias);
    return ti;
}

Text *TextWeight(Real weight, Text *t)
{
    AttributedTextImpl *newTxt =
        NEW AttributedTextImpl(AttributedTextImpl::weight, t);

    newTxt->SetWeight(weight);

    return newTxt;
}

Text *TextTransformCharacter(Transform2 *xf, Text *t)
{
    if (xf == identityTransform2) {
        return t;
    }
    
    AttributedTextImpl *newTxt =
        NEW AttributedTextImpl(AttributedTextImpl::characterTransform, t);
    newTxt->SetCharacterTransform(xf);

    return newTxt;
}

void
InitializeModule_Text()
{
    serifProportional = NEW FontFamily(ff_serifProportional);
    sansSerifProportional = NEW FontFamily(ff_sansSerifProportional);
    monospaced = NEW FontFamily(ff_monospaced);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\vec3.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998  Microsoft Corporation

    Implementation of 3D vectors and points.

*******************************************************************************/

#include "headers.h"
#include "appelles/vec3.h"
#include "appelles/xform.h"
#include "privinc/vec3i.h"
#include "privinc/vecutil.h"
#include "privinc/xformi.h"
#include "privinc/basic.h"


    /*******************/
    /***  Constants  ***/
    /*******************/

Vector3Value *xVector3    = NULL;
Vector3Value *yVector3    = NULL;
Vector3Value *zVector3    = NULL;
Vector3Value *zeroVector3 = NULL;

Point3Value *origin3 = NULL;



/*****************************************************************************
Vector Methods
*****************************************************************************/

bool Vector3Value::operator== (Vector3Value &other)
{   return (x==other.x) && (y==other.y) && (z==other.z);
}


Vector3Value& Vector3Value::operator*= (Real s)
{   x *= s;
    y *= s;
    z *= s;
    return *this;
}


Real Vector3Value::LengthSquared (void)
{   return (x*x + y*y + z*z);
}


void Vector3Value::Transform (Transform3 *transform)
{
    const Apu4x4Matrix &matrix = transform->Matrix();
    ApuVector3 vec, result;

    vec.Set (x, y, z);

    matrix.ApplyAsVector (vec, result);

    x = result[0];
    y = result[1];
    z = result[2];
}


Vector3Value& Vector3Value::Normalize (void)
{
    if ((x != 0) || (y != 0) || (z != 0))
        *this *= (1/Length());

    return *this;
}



/*****************************************************************************
Vector3 Operators
*****************************************************************************/

Vector3Value operator+ (Vector3Value &A, Vector3Value &B)
{   return Vector3Value (A.x + B.x, A.y + B.y, A.z + B.z);
}


Vector3Value operator- (Vector3Value &A, Vector3Value &B)
{   return Vector3Value (A.x - B.x, A.y - B.y, A.z - B.z);
}


Vector3Value operator- (Vector3Value &V)
{   return Vector3Value (-V.x, -V.y, -V.z);
}


Vector3Value operator* (Real s, Vector3Value &V)
{   return Vector3Value (s * V.x, s * V.y, s * V.z);
}

Vector3Value operator* (Transform3 &T, Vector3Value &V)
{
    ApuVector3 vec, result;

    vec.Set (V.x, V.y, V.z);

    T.Matrix().ApplyAsVector (vec, result);

    return Vector3Value(result[0], result[1], result[2]);
}


/*****************************************************************************
Point Methods
*****************************************************************************/

bool Point3Value::operator== (Point3Value &other)
{   return (x==other.x) && (y==other.y) && (z==other.z);
}


void Point3Value::Transform (Transform3 *transform)
{
    const Apu4x4Matrix& matrix = transform->Matrix();
    ApuVector3 vec, result;

    vec.Set (x, y, z);

    matrix.ApplyAsPoint (vec, result);

    x = result[0];
    y = result[1];
    z = result[2];
}


ClipCode Point3Value::Clip(Plane3 &plane)
{
    if (Dot(plane.N,*(AsVector(*this))) + plane.d >= 0)
        return CLIPCODE_IN;
    else
        return CLIPCODE_OUT;
}



/*****************************************************************************
Point Operators
*****************************************************************************/


Real DistanceSquared (Point3Value &P, Point3Value &Q)
{
    Real dx = P.x - Q.x,
         dy = P.y - Q.y,
         dz = P.z - Q.z;

    return dx*dx + dy*dy + dz*dz;
}


Point3Value operator* (Transform3 &T, Point3Value &P)
{
    ApuVector3 pt, result;

    pt.Set (P.x, P.y, P.z);

    T.Matrix().ApplyAsPoint (pt, result);

    return Point3Value (result[0], result[1], result[2]);
}



/*****************************************************************************
Point/Vector Operators
*****************************************************************************/

Vector3Value operator- (Point3Value &P, Point3Value &Q)
{   return Vector3Value (P.x - Q.x, P.y - Q.y, P.z - Q.z);
}


Point3Value operator+ (Point3Value &P, Vector3Value &V)
{   return Point3Value (P.x + V.x, P.y + V.y, P.z + V.z);
}


Point3Value operator- (Point3Value &P, Vector3Value &V)
{   return Point3Value (P.x - V.x, P.y - V.y, P.z - V.z);
}



/*****************************************************************************
This routine computes the cross product of the two vectors and stores the
result in the destination vector.  It properly handles the case where one of
the source vectors is also a destination vector.
*****************************************************************************/

void Cross (Vector3Value &dest, Vector3Value &A, Vector3Value &B)
{
    Real x = (A.y * B.z) - (B.y * A.z);
    Real y = (A.z * B.x) - (B.z * A.x);
    Real z = (A.x * B.y) - (B.x * A.y);

    dest.Set (x,y,z);
}



/*****************************************************************************
This function returns the vector result of a cross product.
*****************************************************************************/

Vector3Value Cross (Vector3Value &A, Vector3Value &B)
{
    return Vector3Value ((A.y * B.z) - (A.z * B.y),
                         (A.z * B.x) - (A.x * B.z),
                         (A.x * B.y) - (A.y * B.x));
}



/*****************************************************************************
Return the dot product of the two vectors.
*****************************************************************************/

Real Dot (Vector3Value &A, Vector3Value &B)
{
    return (A.x * B.x) + (A.y * B.y) + (A.z * B.z);
}



/*****************************************************************************
Return the acute angle between two vectors.
*****************************************************************************/

Real AngleBetween (Vector3Value &A, Vector3Value &B)
{   return acos(Dot(A,B) / (A.Length() * B.Length()));
}



/*****************************************************************************
Convert polar coordinates to rectangular coordinates.  The azimuthal angle
begins at the +Z ray, and sweeps counter-clockwise about the +Y axis.  The
elevation angle begins in the XZ plane, and sweeps up toward the +Y axis.
*****************************************************************************/

static void PolarToRectangular (
    Real azimuth,                 // Rotation Around +Y (Radians) From +Z
    Real elevation,               // Rotation Up From XZ Plane Towards +Y
    Real radius,                  // Distance From Origin
    Real &x, Real &y, Real &z)    // Output Rectangular Coordinates
{
    Real XZradius = radius * cos(elevation);

    x = XZradius * sin(azimuth);
    y =   radius * sin(elevation);
    z = XZradius * cos(azimuth);
}



/*****************************************************************************
These functions return the polar coordinates of the given Cartesian
coordinate.
*****************************************************************************/

static Real RadiusCoord (Real x, Real y, Real z)
{   return sqrt (x*x + y*y + z*z);
}

static Real ElevationCoord (Real x, Real y, Real z)
{   return asin (y / RadiusCoord (x,y,z));
}

static Real AzimuthCoord (Real x, Real y, Real z)
{   return atan2 (x, z);
}



/*****************************************************************************
These create Vector3's from Cartesian or polar coordinates.
*****************************************************************************/

Vector3Value *XyzVector3 (AxANumber *x, AxANumber *y, AxANumber *z)
{   return NEW Vector3Value(NumberToReal(x), NumberToReal(y), NumberToReal(z));
}

Vector3Value *XyzVector3RRR (Real x, Real y, Real z)
{   return NEW Vector3Value(x, y, z);
}

Vector3Value *SphericalVector3 (
    AxANumber *azimuth,     // Angle about +Y, starting at +Z
    AxANumber *elevation,   // Angle up from XZ plane towards +Y
    AxANumber *radius)      // Vector Length
{
    return SphericalVector3RRR(NumberToReal(azimuth), NumberToReal(elevation), NumberToReal(radius));
}

Vector3Value *SphericalVector3RRR (
    Real azimuth,     // Angle about +Y, starting at +Z
    Real elevation,   // Angle up from XZ plane towards +Y
    Real radius)      // Vector Length
{
    Real x,y,z;

    PolarToRectangular
    (   azimuth, elevation, radius,
        x, y, z
    );

    return NEW Vector3Value(x, y, z);
}



/*****************************************************************************
These functions return the length and length squared of a vector.
*****************************************************************************/

AxANumber *LengthVector3 (Vector3Value *v)
{   return RealToNumber (v->Length());
}


AxANumber *LengthSquaredVector3 (Vector3Value *v)
{   return RealToNumber (v->LengthSquared());
}



/*****************************************************************************
This procedure returns a unit vector in the same direction as the given one.
*****************************************************************************/

Vector3Value *NormalVector3 (Vector3Value *v)
{   Vector3Value *N = NEW Vector3Value (*v);
    return &(N->Normalize());
}



/*****************************************************************************
Return the dot and cross product of two vectors.
*****************************************************************************/

AxANumber *DotVector3Vector3 (Vector3Value *A, Vector3Value *B)
{   return RealToNumber (Dot(*A,*B));
}


Vector3Value *CrossVector3Vector3 (Vector3Value *A, Vector3Value *B)
{   Vector3Value *V = NEW Vector3Value;
    Cross (*V, *A, *B);
    return V;
}


Vector3Value *NegateVector3 (Vector3Value *v)
{   return NEW Vector3Value (-(*v));
}


Vector3Value *ScaleVector3Real (Vector3Value *V, AxANumber *scalar)
{   return ScaleRealVector3R(NumberToReal(scalar),V);
}


Vector3Value *ScaleRealVector3 (AxANumber *scalar, Vector3Value *V)
{   return ScaleRealVector3R(NumberToReal(scalar),V);
}

Vector3Value *ScaleRealVector3R (Real scalar, Vector3Value *V)
{   return NEW Vector3Value (scalar * (*V));
}

Vector3Value *DivideVector3Real (Vector3Value *V, AxANumber *scalar)
{   return DivideVector3RealR (V, NumberToReal(scalar));
}

Vector3Value *DivideVector3RealR (Vector3Value *V, Real scalar)
{   return NEW Vector3Value ((1/scalar) * (*V));
}

Vector3Value *MinusVector3Vector3 (Vector3Value *A, Vector3Value *B)
{   return NEW Vector3Value (*A - *B);
}


Vector3Value *PlusVector3Vector3 (Vector3Value *A, Vector3Value *B)
{   return NEW Vector3Value (*A + *B);
}


AxANumber *AngleBetween (Vector3Value *A, Vector3Value *B)
{   return RealToNumber (AngleBetween (*A, *B));
}


#if _USE_PRINT
ostream& operator<< (ostream& os, Vector3Value& v)
{   return os << "<" << v.x << ", " << v.y << "," << v.z << ">";
}
#endif



////////  Functions on Points  /////////////

Point3Value* XyzPoint3 (AxANumber *x, AxANumber *y, AxANumber *z)
{   return NEW Point3Value(NumberToReal(x), NumberToReal(y), NumberToReal(z));
}

Point3Value* XyzPoint3RRR (Real x, Real y, Real z)
{   return NEW Point3Value(x, y, z);
}


Point3Value *SphericalPoint3 (
    AxANumber *azimuth,     // Angle About +Y, Starting At +Z
    AxANumber *elevation,   // Angle Up From XZ Plane Towards +Y
    AxANumber *radius)      // Distance From Origin
{
    return SphericalPoint3RRR(NumberToReal(azimuth), NumberToReal(elevation), NumberToReal(radius));
}

Point3Value *SphericalPoint3RRR (
    Real azimuth,     // Angle About +Y, Starting At +Z
    Real elevation,   // Angle Up From XZ Plane Towards +Y
    Real radius)      // Distance From Origin
{
    Real x,y,z;

    PolarToRectangular
    (   azimuth, elevation, radius,
        x, y, z
    );

    return NEW Point3Value (x, y, z);
}


Vector3Value *MinusPoint3Point3 (Point3Value *P, Point3Value *Q)
{   return NEW Vector3Value (*P - *Q);
}


Point3Value *PlusPoint3Vector3 (Point3Value *P, Vector3Value *V)
{   return NEW Point3Value (*P + *V);
}


Point3Value *MinusPoint3Vector3 (Point3Value *P, Vector3Value *V)
{   return NEW Point3Value (*P - *V);
}


AxANumber *DistancePoint3Point3 (Point3Value *P, Point3Value *Q)
{   return RealToNumber (Distance (*P, *Q));
}


Real RDistancePoint3Point3 (Point3Value *P, Point3Value *Q)
{   return Distance (*P, *Q);
}


AxANumber *DistanceSquaredPoint3Point3 (Point3Value *P, Point3Value *Q)
{   return RealToNumber (DistanceSquared (*P, *Q));
}


#if _USE_PRINT
ostream& operator<< (ostream& os, Point3Value& p)
{   return os << "<" << p.x << ", " << p.y << "," << p.z << ">";
}
#endif



/*****************************************************************************
Return a NEW vector that is the transformed given vector.
*****************************************************************************/

Vector3Value *TransformVec3 (Transform3 *transform, Vector3Value *vec)
{
    Vector3Value *result = NEW Vector3Value (*vec);
    result->Transform (transform);
    return result;
}

Point3Value *TransformPoint3 (Transform3 *transform, Point3Value *point)
{
    Point3Value *result = NEW Point3Value (*point);
    result->Transform (transform);
    return result;
}


//////////////  Extractors  ////////////

AxANumber *XCoordVector3(Vector3Value *v) { return RealToNumber(v->x); }
AxANumber *YCoordVector3(Vector3Value *v) { return RealToNumber(v->y); }
AxANumber *ZCoordVector3(Vector3Value *v) { return RealToNumber(v->z); }

AxANumber *XCoordPoint3(Point3Value *p) { return RealToNumber(p->x); }
AxANumber *YCoordPoint3(Point3Value *p) { return RealToNumber(p->y); }
AxANumber *ZCoordPoint3(Point3Value *p) { return RealToNumber(p->z); }

AxANumber *RhoCoordVector3 (Vector3Value *p)
{   return RealToNumber(RadiusCoord(p->x,p->y,p->z));
}

AxANumber *ThetaCoordVector3 (Vector3Value *p)
{   return RealToNumber(AzimuthCoord(p->x,p->y,p->z));
}

AxANumber *PhiCoordVector3 (Vector3Value *p)
{   return RealToNumber(ElevationCoord(p->x,p->y,p->z));
}

AxANumber *RhoCoordPoint3 (Point3Value *p)
{   return RealToNumber(RadiusCoord(p->x,p->y,p->z));
}

AxANumber *ThetaCoordPoint3 (Point3Value *p)
{   return RealToNumber(AzimuthCoord(p->x,p->y,p->z));
}

AxANumber *PhiCoordPoint3 (Point3Value *p)
{   return RealToNumber(ElevationCoord(p->x,p->y,p->z));
}

void
InitializeModule_Vec3()
{
    xVector3    = NEW Vector3Value (1,0,0);
    yVector3    = NEW Vector3Value (0,1,0);
    zVector3    = NEW Vector3Value (0,0,1);
    zeroVector3 = NEW Vector3Value (0,0,0);

    origin3 = NEW Point3Value (0,0,0);
}



/*****************************************************************************
This function transforms the Ray3 object by the given transform.
*****************************************************************************/

void Ray3::Transform (Transform3 *xform)
{
    orig.Transform (xform);
    dir.Transform (xform);
}



/*****************************************************************************
The evaluation function for a ray returns the point at P + tD.
*****************************************************************************/

Point3Value Ray3::Evaluate (Real t)
{
    return orig + (t * dir);
}



/*****************************************************************************
This function transforms a plane by a Transform3.
*****************************************************************************/

Plane3& Plane3::operator*= (Transform3 *T)
{
    Real R[4];   // Resulting Plane

    // To transform a plane, treat the four components as a row-vector, and
    // multiply by the inverse of the transform matrix.

    bool ok =  T->Matrix().TransformPlane (N.x, N.y, N.z, d, R);

    if (!ok) {
        TraceTag ((tagWarning, "Singular transform applied to Plane3 object."));

        // If we can't apply the transform, then ignore it.

        R[0] = N.x;
        R[1] = N.y;
        R[2] = N.z;
        R[3] = d;
    }

    N.x = R[0];
    N.y = R[1];
    N.z = R[2];
    d   = R[3];

    return *this;
}



/*****************************************************************************
This function normalizes the plane so that the normal vector is unit length.
*****************************************************************************/

Plane3& Plane3::Normalize (void)
{
    Real recip_len = 1 / N.Length();
    N *= recip_len;
    d *= recip_len;

    return *this;
}



/*****************************************************************************
This method returns the plane normal vector (arbitrary length).
*****************************************************************************/

Vector3Value Plane3::Normal (void)
{
    return Vector3Value (N);
}



/*****************************************************************************
This method returns the point on the given plane nearest the origin.
*****************************************************************************/

Point3Value Plane3::Point (void)
{
    Real scale = -d / N.LengthSquared();
    return Point3Value (scale*N.x, scale*N.y, scale*N.z);
}



/*****************************************************************************
This function returns the signed distance from the plane to the given point. 
If the sign is positive, then the point lies on the same side of the plane as
the plane normal.  If the distance is zero, the point lies on the plane.
*****************************************************************************/

Real Distance (Plane3 &plane, Point3Value &Q)
{
    Plane3 P (plane);

    P.Normalize();

    return (P.N.x * Q.x) + (P.N.y * Q.y) + (P.N.z * Q.z) + P.d;
}



/*****************************************************************************
This function returns the ray parameter for the intersection between the ray
and a plane.  If the ray is parallel to the plane, then this function returns
infinity.
*****************************************************************************/

Real Intersect (Ray3 &ray, Plane3 &plane)
{
    Real denom = Dot (plane.N, ray.Direction());

    if (fabs(denom) < 1e-6)
        return HUGE_VAL;

    return (-Dot(plane.N, *AsVector(ray.Origin())) - plane.d) / denom;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\xform2.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Implementation of 2D transformations

*******************************************************************************/

#include "headers.h"
#include "privinc/vec2i.h"
#include "privinc/xform2i.h"
#include "privinc/xformi.h"
#include "privinc/matutil.h"
#include "privinc/util.h"
#include "privinc/except.h"
#include "privinc/basic.h"
#include "backend/values.h"
#include "privinc/dddevice.h"  // need Real2Pix function for 
                               // TransformPointsToGDISpace


#include <math.h>

#define A00  m[0]
#define A01  m[1]
#define A02  m[2]
#define A10  m[3]
#define A11  m[4]
#define A12  m[5]


bool
Transform2::SwitchToNumbers(Xform2Type typeOfNewNumbers,
                            Real      *numbers)
{
    return false;
}

//--------------------------------------------------
//   Identity
//--------------------------------------------------

class IdentityXform2 : public Transform2 {
  public:
#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "identityTransform2";
    }
#endif
    Xform2Type Type() { return Identity;}
    void GetMatrix(Real m[6]) {A00=A11=1.0; A01=A02=A10=A12=0;}

    Transform2 *Copy() { return identityTransform2; }
};

Transform2 *identityTransform2 = NULL;


//--------------------------------------------------
// 2x3 Affine Translation Transformation
//--------------------------------------------------
class TranslationXform2 : public Transform2 {
  public:
    TranslationXform2(Real x, Real y, bool pixelMode) :
        tx(x), ty(y), _pixelMode(pixelMode) {}
    
#if _USE_PRINT
    ostream& Print(ostream& os) {
        os << "TranslationTransform2(";
        return os << tx << "," << ty << "," << _pixelMode << ")";
    }
#endif
    
    Xform2Type Type() { return Translation;}
    void GetMatrix(Real m[6]) {A00=A11=1.0; A01=A10=0; A02=tx; A12=ty;}

    Transform2 *Copy() { return NEW TranslationXform2(tx,ty,_pixelMode); }

    bool SwitchToNumbers(Xform2Type theType,
                         Real      *numbers) {
        
        if (theType != Xform2Type::Translation) { return false; }

        tx = numbers[0];
        ty = numbers[1];
        if (_pixelMode) {
            tx = ::PixelToNum(tx);
            ty = ::PixelYToNum(ty);
        }

        return true;
    }

    Real tx, ty;
    bool _pixelMode;
};

//--------------------------------------------------
// 2x3 Affine Scale Transformation
//--------------------------------------------------
class ScaleXform2 : public Transform2 {
  public:
    ScaleXform2(Real x, Real y) : sx(x), sy(y) {}
#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "ScaleTransform2(" << sx << "," << sy << ")";
    }
#endif
    Xform2Type Type() { return Scale;}
    void GetMatrix(Real m[6]) {A00=sx; A11=sy; A01=A10=A02=A12=0;}

    Transform2 *Copy() { return NEW ScaleXform2(sx,sy); }

    bool SwitchToNumbers(Xform2Type ty,
                         Real      *numbers) {
        
        if (ty != Xform2Type::Scale) { return false; }

        sx = numbers[0];
        sy = numbers[1];

        return true;
    }
    
    Real sx, sy;
};


//--------------------------------------------------
// 2x3 Affine Shear Transformation
//--------------------------------------------------
class ShearXform2 : public Transform2 {
  public:
    ShearXform2(Real x, Real y) : shx(x), shy(y) {}
#if _USE_PRINT
    ostream& Print(ostream& os) {
        return os << "ShearTransform2(" << shx << "," << shy << ")";
    }
#endif
    Xform2Type Type() { return Shear;}
    void GetMatrix(Real m[6]) {A00=A11=1.0; A10=shx; A01=shy; A02=A12=0;}

    Transform2 *Copy() { return NEW ShearXform2(shx,shy); }

    Real shx, shy;              // a01, a10
};

//--------------------------------------------------
// 2x3 Affine Rotation Transformation
//--------------------------------------------------
class RotationXform2 : public Transform2 {
  public:
    RotationXform2(Real _a00, Real _a01,
                   Real _a10, Real _a11) :
      a00(_a00), a01(_a01),
      a10(_a10), a11(_a11) {}
#if _USE_PRINT
    ostream& Print(ostream& os) {
        os << "RotationTransform2(";
        return os << a00 << "," << a01 << "," << a10 << "," << a11 << ")";
        }
#endif
    Xform2Type Type() { return Rotation;}
    void GetMatrix(Real m[6]) {A00=a00; A01=a01; A10=a10; A11=a11; A02=A12=0;}

    Transform2 *Copy() {
        return NEW RotationXform2(a00,a01,a10,a11);
    }

    bool SwitchToNumbers(Xform2Type ty,
                         Real      *numbers) {
        
        if (ty != Xform2Type::Rotation) { return false; }

        Real angInRadians = numbers[0] * degToRad;
        Real cost = cos(angInRadians);
        Real sint = sin(angInRadians);
        a00 = cost;
        a01 = -sint;
        a10 = sint;
        a11 = cost;
            
        return true;
    }
    
    Real a00, a01, a10, a11;
};

//--------------------------------------------------
// 2x3 Affine TwoByTwo Transformation
//--------------------------------------------------
class TwoByTwoXform2 : public Transform2 {
  public:
    TwoByTwoXform2(Real _a00, Real _a01,
                   Real _a10, Real _a11) :
      a00(_a00), a01(_a01),
      a10(_a10), a11(_a11) {}
#if _USE_PRINT
    ostream& Print(ostream& os) {
        os << "TwoByTwoTransform2(";
        return os << a00 << "," << a01 << "," << a10 << "," << a11 << ")";
    }
#endif
    Xform2Type Type() { return TwoByTwo;}
    void GetMatrix(Real m[6]) {A00=a00; A01=a01; A10=a10; A11=a11; A02=A12=0;}

    Transform2 *Copy() {
        return NEW TwoByTwoXform2(a00,a01,a10,a11);
    }

    Real a00, a01, a10, a11;
};

//--------------------------------------------------
// 2x3 Affine (Full) Transformation
//--------------------------------------------------
class FullXform2 : public Transform2 {
  public:
    FullXform2(Real _a00, Real _a01, Real _a02,
               Real _a10, Real _a11, Real _a12) :
               a00(_a00), a01(_a01), a02(_a02),
               a10(_a10), a11(_a11), a12(_a12) {}
#if _USE_PRINT
    ostream& Print(ostream& os) {
        os << "FullTransform2(";
        return os << a00 << "," << a01 << "," << a02 << "," 
                  << a10 << "," << a11 << "," << a12 << ")";
    }
#endif
    Xform2Type Type() {return Full;}
    void GetMatrix(Real m[6]) {A00=a00; A01=a01; A02=a02;
                               A10=a10; A11=a11; A12=a12;}

    Transform2 *Copy() {
        return NEW FullXform2(a00,a01,a02,a10,a11,a12);
    }

    Real a00, a01, a02,
         a10, a11, a12;
};

#undef A00
#undef A01
#undef A02
#undef A10
#undef A11
#undef A12

// ------------------------------------------------------------
// Utility Functions
// ------------------------------------------------------------

// This function takes a 3D (non-perspective) transform, and returns a 2D
// transform that mimics an orthographic view using the 3D transform.  In
// other words, it allows one to apply a virtual 3D transform to a 2D object.

Transform2 *ParallelTransform2(Transform3 *xform)
{
    // Extract out the first, second, and fourth columns.  We transform vectors
    // to extract the first and second columns, since vectors are unaffected
    // by translation components of a transform.
    
    Apu4x4Matrix mx = xform->Matrix();   
    // Construct the 2x3 transform2 from the 3D matrix elements.
    return NEW
        FullXform2(mx[0][0], mx[0][1], mx[0][3],
                   mx[1][0], mx[1][1], mx[1][3]);
}

// ------------------------------------------------------------
// Local Utility Functions
// ------------------------------------------------------------
inline Bool IsZero(Real n)
{
#define EPSILON  1.e-80
    return ((-EPSILON < n) && (n < EPSILON) ? TRUE : FALSE);
#undef EPSILON
}

// ------------------------------------------------------------
// External Constructor/Accessor Functions
// ------------------------------------------------------------

Transform2 *TranslateRRWithMode(Real tx, Real ty, bool pixelMode)
{
    if (IsZero(tx) && IsZero(ty)) {
        return identityTransform2;
    }
    
    return NEW TranslationXform2(tx, ty, pixelMode);
}

Transform2 *TranslateRR(Real tx, Real ty)
{ return TranslateRRWithMode(tx, ty, false); }

    // Translation

Transform2 *TranslateRealReal (AxANumber *Tx, AxANumber *Ty)
{
    return TranslateRR(NumberToReal(Tx),NumberToReal(Ty));
}

Transform2 *TranslateVector2Value (Vector2Value *delta)
{
    return TranslateRR(delta->x, delta->y);
}

Transform2 *Translate2PointValue(Point2Value *pos)
{
    return TranslateRR(pos->x, pos->y);
}

Transform2 * ScaleRR(Real x, Real y)
{
    if (IsZero(x - 1.0) && IsZero(y - 1.0)) {
        return identityTransform2;
    }
    
    return NEW ScaleXform2(x, y);
}

    // Scaling

Transform2 *ScaleRealReal (AxANumber *x, AxANumber *y)
{
    return ScaleRR(NumberToReal(x), NumberToReal(y));
}

Transform2 *ScaleVector2Value (Vector2Value *scale_vec)
{
    return ScaleRR(scale_vec->x, scale_vec->y);
}

// Need to disambiguate from Scale(Real) that returns a 3D transform.
Transform2 *Scale2 (AxANumber *uniform_scale)
{
    return ScaleRR(NumberToReal(uniform_scale),
                   NumberToReal(uniform_scale));
}

    // Rotation (around implicit Z)

Transform2 *Rotate2Radians(Real angle)
{
    if (IsZero(angle)) {
        return identityTransform2;
    }
    
    Real cost = cos(angle);
    Real sint = sin(angle);
    return NEW RotationXform2(cost, - sint, sint, cost);
}

Transform2 *RotateReal(AxANumber *angle)
{
    return Rotate2Radians(NumberToReal(angle));
}

Transform2 *RotateRealR(Real angle)
{
    return Rotate2Radians(angle);
}

    // Shear transformation

Transform2 *XShear2R (Real xAmt)
{
    if (IsZero(xAmt)) {
        return identityTransform2;
    }

    return NEW ShearXform2(xAmt, 0);
}

Transform2 *YShear2R (Real yAmt)
{
    if (IsZero(yAmt)) {
        return identityTransform2;
    }

    return NEW ShearXform2(0, yAmt);
}

Transform2 *XShear2 (AxANumber *xAmt)
{
    return XShear2R(NumberToReal(xAmt));
}

Transform2 *YShear2 (AxANumber *yAmt)
{
    return YShear2R(NumberToReal(yAmt));
}

    // 2x3 affine matrix transformation.  This follows the
    // pre-multiply conventions
    // (point is a column vector) in Foley & van Dam, 2nd ed.  This
    // means that (a13,a23) in a 2x3 is the translation component.

Transform2 *MatrixTransform(AxAArray *a)
{
    if (a->Length() != 6)
        RaiseException_UserError(E_FAIL, IDS_ERR_MATRIX_NUM_ELEMENTS);
    
    return NEW
        FullXform2(ValNumber((*a)[0]), ValNumber((*a)[1]), ValNumber((*a)[2]),
                   ValNumber((*a)[3]), ValNumber((*a)[4]), ValNumber((*a)[5]));
}

Transform2 *FullXform(Real a00, Real a01, Real a02,
                      Real a10, Real a11, Real a12)
{
    return NEW FullXform2(a00, a01, a02, a10, a11, a12);
}

#define TRAN(t)  ((TranslationXform2 *)t)
#define SCAL(t)  ((ScaleXform2 *)t)
#define SHR(t)   ((ShearXform2 *)t)
#define ROT(t)   ((RotationXform2 *)t)
#define TWOBY(t) ((TwoByTwoXform2 *)t)
#define FULL(t)  ((FullXform2 *)t)

    // Transform composition (*), and composition with inverse (/)

Transform2 *TimesTransform2Transform2(Transform2 *a, Transform2 *b)
{
    Transform2::Xform2Type
        typeA = a->Type(),
        typeB = b->Type();

    if(typeA == Transform2::Identity)
        return b;

    if(typeB == Transform2::Identity)
        return a;

    unsigned int multType = MAKEWORD(typeA, typeB);
    switch (multType) {

    case MAKEWORD(Transform2::Translation, Transform2::Translation):
        // Just add the corresponding translation components.
      return TranslateRR(TRAN(a)->tx + TRAN(b)->tx,
                         TRAN(a)->ty + TRAN(b)->ty);

    case MAKEWORD(Transform2::Translation, Transform2::Scale):
        // Slap 'em together
        return ( NEW FullXform2(SCAL(b)->sx, 0,           TRAN(a)->tx,
                                0,           SCAL(b)->sy, TRAN(a)->ty));

    case MAKEWORD(Transform2::Translation, Transform2::Shear):
        // Slap 'em together
        return ( NEW FullXform2(1,  SHR(b)->shy, TRAN(a)->tx,
                                SHR(b)->shx, 1,           TRAN(a)->ty));

    case MAKEWORD(Transform2::Translation, Transform2::Rotation):
        // Slap 'em together
        return ( NEW FullXform2(ROT(b)->a00, ROT(b)->a01, TRAN(a)->tx,
                                ROT(b)->a10, ROT(b)->a11, TRAN(a)->ty));

    case MAKEWORD(Transform2::Translation, Transform2::TwoByTwo):
        // Slap 'em together
        return ( NEW FullXform2(TWOBY(b)->a00, TWOBY(b)->a01, TRAN(a)->tx,
                                TWOBY(b)->a10, TWOBY(b)->a11, TRAN(a)->ty));

    case MAKEWORD(Transform2::Translation, Transform2::Full):
        return ( NEW FullXform2(
            FULL(b)->a00,
            FULL(b)->a01,
            TRAN(a)->tx + FULL(b)->a02,
            FULL(b)->a10,
            FULL(b)->a11,
            TRAN(a)->ty + FULL(b)->a12
            ));


    case MAKEWORD(Transform2::Scale, Transform2::Translation):
        // Slap 'em together
        return ( NEW FullXform2(
            SCAL(a)->sx, 0,           SCAL(a)->sx * TRAN(b)->tx,
            0,           SCAL(a)->sy, SCAL(a)->sy * TRAN(b)->ty));

    case MAKEWORD(Transform2::Scale, Transform2::Scale):
        // Mult corresponding componenets.
        return NEW ScaleXform2(SCAL(a)->sx * SCAL(b)->sx,
                               SCAL(a)->sy * SCAL(b)->sy);

    case MAKEWORD(Transform2::Scale, Transform2::Shear):
        return ( NEW TwoByTwoXform2(
            SCAL(a)->sx,               SCAL(a)->sx * SHR(b)->shy,
            SCAL(a)->sy * SHR(b)->shx, SCAL(a)->sy));

    case MAKEWORD(Transform2::Scale, Transform2::Rotation):
        return ( NEW TwoByTwoXform2(
            SCAL(a)->sx * ROT(b)->a00, SCAL(a)->sx * ROT(b)->a01,
            SCAL(a)->sy * ROT(b)->a10, SCAL(a)->sy * ROT(b)->a11));

    case MAKEWORD(Transform2::Scale, Transform2::TwoByTwo):
        return ( NEW TwoByTwoXform2(
            SCAL(a)->sx * TWOBY(b)->a00, SCAL(a)->sx * TWOBY(b)->a01,
            SCAL(a)->sy * TWOBY(b)->a10, SCAL(a)->sy * TWOBY(b)->a11));

    case MAKEWORD(Transform2::Scale, Transform2::Full):
        return ( NEW FullXform2(
            SCAL(a)->sx * FULL(b)->a00, SCAL(a)->sx * FULL(b)->a01, SCAL(a)->sx * FULL(b)->a02,
            SCAL(a)->sy * FULL(b)->a10, SCAL(a)->sy * FULL(b)->a11, SCAL(a)->sy * FULL(b)->a12));

    case MAKEWORD(Transform2::Shear, Transform2::Translation):
        return ( NEW FullXform2(
            1,           SHR(a)->shy, TRAN(b)->tx +  SHR(a)->shy * TRAN(b)->ty,
            SHR(a)->shx, 1,           TRAN(b)->ty +  SHR(a)->shx * TRAN(b)->tx));

    case MAKEWORD(Transform2::Shear, Transform2::Scale):
        return ( NEW TwoByTwoXform2(
            SCAL(b)->sx,               SCAL(b)->sy * SHR(a)->shy,
            SCAL(b)->sx * SHR(a)->shx, SCAL(b)->sy));

    case MAKEWORD(Transform2::Shear, Transform2::Shear):
        return ( NEW TwoByTwoXform2(
            1 + SHR(a)->shy * SHR(b)->shx, SHR(b)->shy + SHR(a)->shy,
                SHR(a)->shx + SHR(b)->shx, 1 + SHR(b)->shy * SHR(a)->shx));

    case MAKEWORD(Transform2::Shear, Transform2::Rotation):
        return ( NEW TwoByTwoXform2(
            ROT(b)->a00 + SHR(a)->shy * ROT(b)->a10,
            ROT(b)->a01 + SHR(a)->shy * ROT(b)->a11,
            ROT(b)->a10 + SHR(a)->shx * ROT(b)->a00,
            ROT(b)->a11 + SHR(a)->shx * ROT(b)->a01));

    case MAKEWORD(Transform2::Shear, Transform2::TwoByTwo):
        return ( NEW TwoByTwoXform2(
            TWOBY(b)->a00 + SHR(a)->shy * TWOBY(b)->a10,
            TWOBY(b)->a01 + SHR(a)->shy * TWOBY(b)->a11,
            TWOBY(b)->a10 + SHR(a)->shx * TWOBY(b)->a00,
            TWOBY(b)->a11 + SHR(a)->shx * TWOBY(b)->a01));

    case MAKEWORD(Transform2::Shear, Transform2::Full):
        return ( NEW FullXform2(
            FULL(b)->a00 + SHR(a)->shy * FULL(b)->a10,
            FULL(b)->a01 + SHR(a)->shy * FULL(b)->a11,
            FULL(b)->a02 + SHR(a)->shy * FULL(b)->a12,

            FULL(b)->a10 + SHR(a)->shx * FULL(b)->a00,
            FULL(b)->a11 + SHR(a)->shx * FULL(b)->a01,
            FULL(b)->a12 + SHR(a)->shx * FULL(b)->a02));


    case MAKEWORD(Transform2::Rotation, Transform2::Translation):
        return ( NEW FullXform2(
            ROT(a)->a00,
            ROT(a)->a01,
            ROT(a)->a00 * TRAN(b)->tx  +  ROT(a)->a01 * TRAN(b)->ty,

            ROT(a)->a10,
            ROT(a)->a11,
            ROT(a)->a10 * TRAN(b)->tx  +  ROT(a)->a11 * TRAN(b)->ty));

    case MAKEWORD(Transform2::Rotation, Transform2::Scale):
        return ( NEW TwoByTwoXform2(
            ROT(a)->a00 * SCAL(b)->sx,   ROT(a)->a01 * SCAL(b)->sy,
            ROT(a)->a10 * SCAL(b)->sx,   ROT(a)->a11 * SCAL(b)->sy));

    case MAKEWORD(Transform2::Rotation, Transform2::Shear):
        return ( NEW TwoByTwoXform2(
            ROT(a)->a00 + SHR(b)->shx * ROT(a)->a01, ROT(a)->a01 + SHR(b)->shy * ROT(a)->a00,
            ROT(a)->a10 + SHR(b)->shx * ROT(a)->a11, ROT(a)->a11 + SHR(b)->shy * ROT(a)->a10));

    case MAKEWORD(Transform2::Rotation, Transform2::Rotation):
        return ( NEW RotationXform2(
            ROT(a)->a00 * ROT(b)->a00 + ROT(a)->a01 * ROT(b)->a10,
            ROT(a)->a00 * ROT(b)->a01 + ROT(a)->a01 * ROT(b)->a11,
            ROT(a)->a10 * ROT(b)->a00 + ROT(a)->a11 * ROT(b)->a10,
            ROT(a)->a10 * ROT(b)->a01 + ROT(a)->a11 * ROT(b)->a11));

    case MAKEWORD(Transform2::Rotation, Transform2::TwoByTwo):
        return ( NEW RotationXform2(
            ROT(a)->a00 * TWOBY(b)->a00 + ROT(a)->a01 * TWOBY(b)->a10,
            ROT(a)->a00 * TWOBY(b)->a01 + ROT(a)->a01 * TWOBY(b)->a11,
            ROT(a)->a10 * TWOBY(b)->a00 + ROT(a)->a11 * TWOBY(b)->a10,
            ROT(a)->a10 * TWOBY(b)->a01 + ROT(a)->a11 * TWOBY(b)->a11));

    case MAKEWORD(Transform2::Rotation, Transform2::Full):
        return ( NEW FullXform2(
            ROT(a)->a00 * FULL(b)->a00 + ROT(a)->a01 * FULL(b)->a10, // 00
            ROT(a)->a00 * FULL(b)->a01 + ROT(a)->a01 * FULL(b)->a11, // 01
            ROT(a)->a00 * FULL(b)->a02 + ROT(a)->a01 * FULL(b)->a12, // 02

            ROT(a)->a10 * FULL(b)->a00 + ROT(a)->a11 * FULL(b)->a10, // 10
            ROT(a)->a10 * FULL(b)->a01 + ROT(a)->a11 * FULL(b)->a11, // 11
            ROT(a)->a10 * FULL(b)->a02 + ROT(a)->a11 * FULL(b)->a12)); // 12



    case MAKEWORD(Transform2::TwoByTwo, Transform2::Translation):
        return ( NEW FullXform2(
            TWOBY(a)->a00,
            TWOBY(a)->a01,
            TWOBY(a)->a00 * TRAN(b)->tx  +  TWOBY(a)->a01 * TRAN(b)->ty,

            TWOBY(a)->a10,
            TWOBY(a)->a11,
            TWOBY(a)->a10 * TRAN(b)->tx  +  TWOBY(a)->a11 * TRAN(b)->ty));

    case MAKEWORD(Transform2::TwoByTwo, Transform2::Scale):
        return ( NEW TwoByTwoXform2(
            TWOBY(a)->a00 * SCAL(b)->sx,   TWOBY(a)->a01 * SCAL(b)->sy,
            TWOBY(a)->a10 * SCAL(b)->sx,   TWOBY(a)->a11 * SCAL(b)->sy));

    case MAKEWORD(Transform2::TwoByTwo, Transform2::Shear):
        return ( NEW TwoByTwoXform2(
            TWOBY(a)->a00 + SHR(b)->shx * TWOBY(a)->a01, TWOBY(a)->a01 + SHR(b)->shy * TWOBY(a)->a00,
            TWOBY(a)->a10 + SHR(b)->shx * TWOBY(a)->a11, TWOBY(a)->a11 + SHR(b)->shy * TWOBY(a)->a10));

    case MAKEWORD(Transform2::TwoByTwo, Transform2::Rotation):
        return ( NEW RotationXform2(
            TWOBY(a)->a00 * ROT(b)->a00 + TWOBY(a)->a01 * ROT(b)->a10,
            TWOBY(a)->a00 * ROT(b)->a01 + TWOBY(a)->a01 * ROT(b)->a11,
            TWOBY(a)->a10 * ROT(b)->a00 + TWOBY(a)->a11 * ROT(b)->a10,
            TWOBY(a)->a10 * ROT(b)->a01 + TWOBY(a)->a11 * ROT(b)->a11));

    case MAKEWORD(Transform2::TwoByTwo, Transform2::TwoByTwo):
        return ( NEW RotationXform2(
            TWOBY(a)->a00 * TWOBY(b)->a00 + TWOBY(a)->a01 * TWOBY(b)->a10,
            TWOBY(a)->a00 * TWOBY(b)->a01 + TWOBY(a)->a01 * TWOBY(b)->a11,
            TWOBY(a)->a10 * TWOBY(b)->a00 + TWOBY(a)->a11 * TWOBY(b)->a10,
            TWOBY(a)->a10 * TWOBY(b)->a01 + TWOBY(a)->a11 * TWOBY(b)->a11));

    case MAKEWORD(Transform2::TwoByTwo, Transform2::Full):
        return ( NEW FullXform2(
            TWOBY(a)->a00 * FULL(b)->a00 + TWOBY(a)->a01 * FULL(b)->a10, // 00
            TWOBY(a)->a00 * FULL(b)->a01 + TWOBY(a)->a01 * FULL(b)->a11, // 01
            TWOBY(a)->a00 * FULL(b)->a02 + TWOBY(a)->a01 * FULL(b)->a12, // 02

            TWOBY(a)->a10 * FULL(b)->a00 + TWOBY(a)->a11 * FULL(b)->a10, // 10
            TWOBY(a)->a10 * FULL(b)->a01 + TWOBY(a)->a11 * FULL(b)->a11, // 11
            TWOBY(a)->a10 * FULL(b)->a02 + TWOBY(a)->a11 * FULL(b)->a12)); // 12


    case MAKEWORD(Transform2::Full, Transform2::Translation):
        return ( NEW FullXform2(
            FULL(a)->a00,
            FULL(a)->a01,
            FULL(a)->a00 * TRAN(b)->tx + FULL(a)->a01 * TRAN(b)->ty + FULL(a)->a02,

            FULL(a)->a10,
            FULL(a)->a11,
            FULL(a)->a10 * TRAN(b)->tx + FULL(a)->a11 * TRAN(b)->ty + FULL(a)->a12));

    case MAKEWORD(Transform2::Full, Transform2::Scale):
        return ( NEW FullXform2(
            FULL(a)->a00 * SCAL(b)->sx,
            FULL(a)->a01 * SCAL(b)->sy,
            FULL(a)->a02, // 02

            FULL(a)->a10 * SCAL(b)->sx,
            FULL(a)->a11 * SCAL(b)->sy,
            FULL(a)->a12)); // 12

    case MAKEWORD(Transform2::Full, Transform2::Shear):
        return ( NEW FullXform2(
            FULL(a)->a00 + FULL(a)->a01 * SHR(b)->shx, // 00
            FULL(a)->a00 * SHR(b)->shy + FULL(a)->a01, // 01
            FULL(a)->a02, // 02

            FULL(a)->a10 + FULL(a)->a11 * SHR(b)->shx, // 00
            FULL(a)->a10 * SHR(b)->shy + FULL(a)->a11, // 01
            FULL(a)->a12)); // 12


    case MAKEWORD(Transform2::Full, Transform2::Rotation):
        return ( NEW FullXform2(
            FULL(a)->a00 * ROT(b)->a00 + FULL(a)->a01 * ROT(b)->a10, // 00
            FULL(a)->a00 * ROT(b)->a01 + FULL(a)->a01 * ROT(b)->a11, // 01
            FULL(a)->a02, // 02

            FULL(a)->a10 * ROT(b)->a00 + FULL(a)->a11 * ROT(b)->a10, // 10
            FULL(a)->a10 * ROT(b)->a01 + FULL(a)->a11 * ROT(b)->a11, // 11
            FULL(a)->a12)); // 12


    case MAKEWORD(Transform2::Full, Transform2::TwoByTwo):
        return ( NEW FullXform2(
            FULL(a)->a00 * TWOBY(b)->a00 + FULL(a)->a01 * TWOBY(b)->a10, // 00
            FULL(a)->a00 * TWOBY(b)->a01 + FULL(a)->a01 * TWOBY(b)->a11, // 01
            FULL(a)->a02, // 02

            FULL(a)->a10 * TWOBY(b)->a00 + FULL(a)->a11 * TWOBY(b)->a10, // 10
            FULL(a)->a10 * TWOBY(b)->a01 + FULL(a)->a11 * TWOBY(b)->a11, // 11
            FULL(a)->a12)); // 12

    case MAKEWORD(Transform2::Full, Transform2::Full):
        return ( NEW FullXform2(
            FULL(a)->a00 * FULL(b)->a00 + FULL(a)->a01 * FULL(b)->a10, // 00
            FULL(a)->a00 * FULL(b)->a01 + FULL(a)->a01 * FULL(b)->a11, // 01
            FULL(a)->a00 * FULL(b)->a02 + FULL(a)->a01 * FULL(b)->a12 + FULL(a)->a02, // 02

            FULL(a)->a10 * FULL(b)->a00 + FULL(a)->a11 * FULL(b)->a10, // 10
            FULL(a)->a10 * FULL(b)->a01 + FULL(a)->a11 * FULL(b)->a11, // 11
            FULL(a)->a10 * FULL(b)->a02 + FULL(a)->a11 * FULL(b)->a12 + FULL(a)->a12)); // 12

    default:
        return a;               // TODO.

    } // switch

}

Transform2 *Compose2Array(AxAArray *xfs)
{
    xfs = PackArray(xfs);
    
    int numXFs = xfs->Length();
    if(numXFs < 2)
       RaiseException_UserError(E_FAIL, IDS_ERR_INVALIDARG);

    Transform2 *finalXF = (Transform2 *)(*xfs)[numXFs-1];
    for(int i=numXFs-2; i>=0; i--)
        finalXF = TimesTransform2Transform2((Transform2 *)(*xfs)[i], finalXF);
    return finalXF;
}

//------------------------------------------------------------------------------

    // Transformation of points and vectors

Point2Value *
TransformPoint2Value(Transform2 *a, Point2Value *pt)
{
    Point2Value *dst = Promote(TransformPoint2(a, Demote(*pt)));
    return dst;
}

Point2
TransformPoint2(Transform2 *a, const Point2& pt)
{
    Real dx, dy;

    switch (a->Type()) {

      case Transform2::Identity:
        dx = pt.x;
        dy = pt.y;
        break;

      case Transform2::TwoByTwo:
        dx = TWOBY(a)->a00 * pt.x + TWOBY(a)->a01 * pt.y;
        dy = TWOBY(a)->a10 * pt.x + TWOBY(a)->a11 * pt.y;
        break;

      case Transform2::Full:
        dx = FULL(a)->a00 * pt.x + FULL(a)->a01 * pt.y + FULL(a)->a02;
        dy = FULL(a)->a10 * pt.x + FULL(a)->a11 * pt.y + FULL(a)->a12;
        break;

      case Transform2::Rotation:
        dx = ROT(a)->a00 * pt.x + ROT(a)->a01 * pt.y;
        dy = ROT(a)->a10 * pt.x + ROT(a)->a11 * pt.y;
        break;

      case Transform2::Translation:
        dx = TRAN(a)->tx + pt.x;
        dy = TRAN(a)->ty + pt.y;
        break;

      case Transform2::Scale:
        dx = SCAL(a)->sx * pt.x;
        dy = SCAL(a)->sy * pt.y;
        break;

      case Transform2::Shear:
        dx = pt.x + SHR(a)->shy * pt.y;
        dy = pt.y + SHR(a)->shx * pt.x;
        break;

      default:
        Assert(FALSE && "Shouldn't be here");
        break;
    }

    return Point2(dx,dy);
}

Vector2Value *
TransformVector2Value(Transform2 *a, Vector2Value *v)
{
    Vector2Value *dst = Promote(TransformVector2(a, Demote(*v)));
    return dst;
}

Vector2
TransformVector2(Transform2 *a, const Vector2& vec)
{
    Real dstx, dsty;

    switch(a->Type()) {

        // Ignore translataional component for vector transformation.
      case Transform2::Identity:
      case Transform2::Translation:
        dstx = vec.x;
        dsty = vec.y;
        break;

      case Transform2::TwoByTwo:
        dstx = TWOBY(a)->a00 * vec.x + TWOBY(a)->a01 * vec.y;
        dsty = TWOBY(a)->a10 * vec.x + TWOBY(a)->a11 * vec.y;
        break;

        // Ignore the translational component for vector transformation.
      case Transform2::Full:
        dstx = FULL(a)->a00 * vec.x + FULL(a)->a01 * vec.y;
        dsty = FULL(a)->a10 * vec.x + FULL(a)->a11 * vec.y;
        break;

      case Transform2::Rotation:
        dstx = ROT(a)->a00 * vec.x + ROT(a)->a01 * vec.y;
        dsty = ROT(a)->a10 * vec.x + ROT(a)->a11 * vec.y;
        break;

      case Transform2::Scale:
        dstx = SCAL(a)->sx * vec.x;
        dsty = SCAL(a)->sy * vec.y;
        break;

      case Transform2::Shear:
        dstx = vec.x + SHR(a)->shy * vec.y;
        dsty = vec.y + SHR(a)->shx * vec.x;
        break;

      default:
        Assert(FALSE && "Shouldn't be here");
        break;

    }

    return Vector2(dstx,dsty);
}

    // Invert transformation

Transform2 *InverseTransform2 (Transform2 *a)
{
    Real coef, div;

    switch(a->Type()) {
    case Transform2::Identity:
        return identityTransform2; // Why not return a ?

    case Transform2::TwoByTwo:
        div = (TWOBY(a)->a00 * TWOBY(a)->a11  -  TWOBY(a)->a01 * TWOBY(a)->a10);
        if (IsZero(div)) return NULL;

        coef = 1.0 / div;
        return (
            NEW TwoByTwoXform2(
                coef * TWOBY(a)->a11, - coef * TWOBY(a)->a01,
              - coef * TWOBY(a)->a10,   coef * TWOBY(a)->a00));

    case Transform2::Full:
      {
        div = (FULL(a)->a00 * FULL(a)->a11  -  FULL(a)->a01 * FULL(a)->a10);

        if (IsZero(div)) return NULL;
        
        coef = 1.0 / div;
        Real aa =   coef * FULL(a)->a11,
             bb = - coef * FULL(a)->a01,
             cc = - coef * FULL(a)->a10,
             dd =   coef * FULL(a)->a00;

        return (
            NEW FullXform2(
                aa, bb, - aa * FULL(a)->a02 - bb * FULL(a)->a12,
                cc, dd, - cc * FULL(a)->a02 - dd * FULL(a)->a12));
       }

    case Transform2::Translation:
        return TranslateRR(- TRAN(a)->tx, - TRAN(a)->ty);

    case Transform2::Rotation:
        // This is basically a transpose.

        return (
            NEW RotationXform2(
                ROT(a)->a00, ROT(a)->a10,
                ROT(a)->a01, ROT(a)->a11));

    case Transform2::Scale:

      if (IsZero(SCAL(a)->sx) || IsZero(SCAL(a)->sy)) {
          return NULL;
      }

        return NEW ScaleXform2(1.0 / SCAL(a)->sx, 1.0 / SCAL(a)->sy);

    case Transform2::Shear:
        if(IsZero(SHR(a)->shy)) {
            // ShearY is 0, compute inversion cheaply!
            return NEW ShearXform2(- SHR(a)->shx, 0);

        } else if(IsZero(SHR(a)->shx)) {
            // ShearX is 0, compute inversion cheaply!
            return NEW ShearXform2(0, - SHR(a)->shy);

        } else {
            div = (1 - SHR(a)->shx * SHR(a)->shy);

            if (IsZero(div)) return NULL;

            // XhearX and ShearY are non-zero.  do a real inverse.
            coef = 1.0 / div;
            return (
                NEW RotationXform2(
                      coef,             - SHR(a)->shy * coef,
                    - SHR(a)->shx * coef, coef           ));
        }

    default:
        return a;  // never executed.
    } // switch
}

Transform2 *ThrowingInverseTransform2 (Transform2 *a)
{
    Transform2 *ret = InverseTransform2(a);

    if (ret==NULL)
        RaiseException_UserError(E_FAIL, IDS_ERR_INVERT_SINGULAR_MATRIX);

    return ret;
}

    // Is Singular

AxABoolean *IsSingularTransform2(Transform2 *a)
{
    Real divisor;

    switch(a->Type()) {
    case Transform2::Identity:
    case Transform2::Translation:
    case Transform2::Rotation:
        return falsePtr;

    case Transform2::TwoByTwo:
        divisor = (TWOBY(a)->a00 * TWOBY(a)->a11  -  TWOBY(a)->a01 * TWOBY(a)->a10);
        return IsZero(divisor) ? truePtr : falsePtr;

    case Transform2::Full:
        divisor = (FULL(a)->a00 * FULL(a)->a11  -  FULL(a)->a01 * FULL(a)->a10);
        return IsZero(divisor) ? truePtr : falsePtr;

    case Transform2::Scale:
        return (IsZero(SCAL(a)->sx) || IsZero(SCAL(a)->sy))  ? truePtr : falsePtr;

    case Transform2::Shear:
        divisor = (1 - SHR(a)->shx * SHR(a)->shy);
        return IsZero(divisor)  ? truePtr : falsePtr;

    default:
        return falsePtr; // never excecuted, needed by compiler
    } // switch
}

/* Specialized fast version of TransformPoints2To GDI space.
   
    Original code was roughly:

    HeapReseter heapReseter(_scratchHeap);
    for(int i=0; i<numPts; i++) {
        destPts[i] = TransformPoint2Value(xform, srcPts[i]);
    }

    for(i=0; i<numPts; i++) {
        gdiPts[i].x = width + Real2Pix(dst.x, resolution);
        gdiPts[i].y = height - Real2Pix(dst.y, resolution);
    }

    It allocated an array destPts[i] to hold the destination points.
    Then it transformed the source points to the destination points
    (this is done in DirectAnimation coordinate space).   Next it mapped
    the destination points to the GDI coordinate space.

    I've made the following changes:
         (1) avoid the intermediate creation of destination points
         (2) inlined TransformPoint2Value and split the loop (loop splitting:
             if the result of a test that is in the middle of a loop
             is independent of the loop, we can create multiple copies 
             of the loop, one per test to avoid doing the test in the
             inner loop.*/

/* Macro to do the specialized loop.   It takes two expressions, xexp and
   yexp, uses them to compute the NEW destination point x and y values
   respectively, and the converts those values to GDI values.  I assume
   that xexp and yexp use the following variables:
          a: the current xform
          x: the source x value
          y: the source y value
          */

#define REAL2PIX(imgCoord, res) (floor((imgCoord) * (res) + 0.5))
#define SPECIALIZED_LOOP(xexp,yexp) \
{                                               \
  int i; \
  for (i=0; i<numPts; i++) \
  { Real x = srcPts[i]->x, y = srcPts[i]->y; \
    gdiPts[i].x = width + REAL2PIX(xexp,resolution); \
    gdiPts[i].y = height - REAL2PIX(yexp,resolution); \
  } \
}

void 
TransformPointsToGDISpace(Transform2 *a,
                          Point2Value **srcPts, 
                          POINT *gdiPts,
                          int numPts,
                          int width,
                          int height,
                          Real resolution)
{ switch (a->Type()) {

      case Transform2::Identity:
        SPECIALIZED_LOOP(x,y)
        break;

      case Transform2::TwoByTwo:
         SPECIALIZED_LOOP(TWOBY(a)->a00 * x + TWOBY(a)->a01 * y,
                          TWOBY(a)->a10 * x + TWOBY(a)->a11 * y)
         break;
      case Transform2::Full:
         SPECIALIZED_LOOP(FULL(a)->a00 * x + FULL(a)->a01 * y + FULL(a)->a02,
                          FULL(a)->a10 * x + FULL(a)->a11 * y + FULL(a)->a12)
          break;

      case Transform2::Rotation:
         SPECIALIZED_LOOP(ROT(a)->a00 * x + ROT(a)->a01 * y,
                          ROT(a)->a10 * x + ROT(a)->a11 * y)
         break;

      case Transform2::Translation:
         SPECIALIZED_LOOP(TRAN(a)->tx + x,TRAN(a)->ty + y)
         break;

      case Transform2::Scale:
         SPECIALIZED_LOOP(SCAL(a)->sx * x,SCAL(a)->sy * y)
         break;

      case Transform2::Shear:
         SPECIALIZED_LOOP(x + SHR(a)->shy * y,y + SHR(a)->shx * x)
         break;

      default:
        Assert(FALSE && "Shouldn't be here");
        break;

    }
}

// TODO: Factor code

#undef SPECIALIZED_LOOP

// TODO: Can probably be made faster by not using indexing, but
// pointer arithmetic.

#define SPECIALIZED_LOOP(xexp,yexp) \
{                                               \
  int i; \
  for (i=0; i<numPts; i++) \
  { Real x = srcPts[i].x, y = srcPts[i].y; \
    gdiPts[i].x = width + REAL2PIX(xexp,resolution); \
    gdiPts[i].y = height - REAL2PIX(yexp,resolution); \
  } \
}

void 
TransformDXPoint2ArrayToGDISpace(Transform2 *a,
                               DXFPOINT *srcPts,
                               POINT *gdiPts,
                               int numPts,
                               int width,
                               int height,
                               Real resolution)
{ switch (a->Type()) {

      case Transform2::Identity:
        SPECIALIZED_LOOP(x,y)
        break;

      case Transform2::TwoByTwo:
         SPECIALIZED_LOOP(TWOBY(a)->a00 * x + TWOBY(a)->a01 * y,
                          TWOBY(a)->a10 * x + TWOBY(a)->a11 * y)
         break;
      case Transform2::Full:
         SPECIALIZED_LOOP(FULL(a)->a00 * x + FULL(a)->a01 * y + FULL(a)->a02,
                          FULL(a)->a10 * x + FULL(a)->a11 * y + FULL(a)->a12)
          break;

      case Transform2::Rotation:
         SPECIALIZED_LOOP(ROT(a)->a00 * x + ROT(a)->a01 * y,
                          ROT(a)->a10 * x + ROT(a)->a11 * y)
         break;

      case Transform2::Translation:
         SPECIALIZED_LOOP(TRAN(a)->tx + x,TRAN(a)->ty + y)
         break;

      case Transform2::Scale:
         SPECIALIZED_LOOP(SCAL(a)->sx * x,SCAL(a)->sy * y)
         break;

      case Transform2::Shear:
         SPECIALIZED_LOOP(x + SHR(a)->shy * y,y + SHR(a)->shx * x)
         break;

      default:
        Assert(FALSE && "Shouldn't be here");
        break;

    }
}


void 
TransformPoint2ArrayToGDISpace(Transform2 *a,
                               Point2 *srcPts,
                               POINT *gdiPts,
                               int numPts,
                               int width,
                               int height,
                               Real resolution)
{ switch (a->Type()) {

      case Transform2::Identity:
        SPECIALIZED_LOOP(x,y)
        break;

      case Transform2::TwoByTwo:
         SPECIALIZED_LOOP(TWOBY(a)->a00 * x + TWOBY(a)->a01 * y,
                          TWOBY(a)->a10 * x + TWOBY(a)->a11 * y)
         break;
      case Transform2::Full:
         SPECIALIZED_LOOP(FULL(a)->a00 * x + FULL(a)->a01 * y + FULL(a)->a02,
                          FULL(a)->a10 * x + FULL(a)->a11 * y + FULL(a)->a12)
          break;

      case Transform2::Rotation:
         SPECIALIZED_LOOP(ROT(a)->a00 * x + ROT(a)->a01 * y,
                          ROT(a)->a10 * x + ROT(a)->a11 * y)
         break;

      case Transform2::Translation:
         SPECIALIZED_LOOP(TRAN(a)->tx + x,TRAN(a)->ty + y)
         break;

      case Transform2::Scale:
         SPECIALIZED_LOOP(SCAL(a)->sx * x,SCAL(a)->sy * y)
         break;

      case Transform2::Shear:
         SPECIALIZED_LOOP(x + SHR(a)->shy * y,y + SHR(a)->shx * x)
         break;

      default:
        Assert(FALSE && "Shouldn't be here");
        break;

    }
}
#undef REAL2PIX

#undef TRAN
#undef SCAL
#undef SHR
#undef ROT
#undef TWOBY
#undef FULL

#if _USE_PRINT
ostream&
operator<<(ostream& os, Transform2 *a)
{
    return os << a->Print(os);
}
#endif


void
InitializeModule_Xform2()
{
    identityTransform2 = NEW IdentityXform2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\vecutil.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Noninline definitions of vector util functions

--*/

#include "headers.h"
#include "appelles/common.h"
#include "privinc/vecutil.h"
#include <math.h>

const Real BIGNUM = 1.0e10;

ApuVector3 apuXAxis3 = {1.0, 0.0, 0.0};
ApuVector3 apuYAxis3 = {0.0, 1.0, 0.0};
ApuVector3 apuZAxis3 = {0.0, 0.0, 1.0};
ApuVector3 apuZero3 = {0.0, 0.0, 0.0};

ApuBbox3 apuNegativeBbox3 = {{BIGNUM, BIGNUM, BIGNUM},
                             {-BIGNUM, -BIGNUM, -BIGNUM}};
ApuBbox3 apuUnitCubeBbox3 = {{0.0, 0.0, 0.0}, {1.0, 1.0, 1.0}};
ApuBbox3 apuTwoUnitCubeBbox3 = {{-1.0, -1.0, -1.0}, {1.0, 1.0, 1.0}};

static inline void
setmax(Real& current_value, Real new_value)
{
  if (new_value > current_value) current_value = new_value;
}

static inline void
setmin(Real& current_value, Real new_value)
{
  if (new_value < current_value) current_value = new_value;
}

void
ApuBbox3::augment(Real x, Real y, Real z)
{
  setmin(min.xyz[0], x);
  setmin(min.xyz[1], y);
  setmin(min.xyz[2], z);

  setmax(max.xyz[0], x);
  setmax(max.xyz[1], y);
  setmax(max.xyz[2], z);
}

void
ApuBbox3::center(ApuVector3& result) const
{
  result.xyz[0] = (max.xyz[0] - min.xyz[0]) / 2.0;
  result.xyz[1] = (max.xyz[1] - min.xyz[1]) / 2.0;
  result.xyz[2] = (max.xyz[2] - min.xyz[2]) / 2.0;
}

Bool
ApuEpsEq(Real value1, Real value2, Real epsilon)
{
  Real diff = value1 - value2;
  return -epsilon <= diff && diff < epsilon;
}

Real
ApuVector3::Length() const
{
  return sqrt(xyz[0] * xyz[0] + xyz[1] * xyz[1] + xyz[2] * xyz[2]);
}

Real
ApuVector3::LengthSquared() const
{
  return xyz[0] * xyz[0] + xyz[1] * xyz[1] + xyz[2] * xyz[2];
}

void
ApuVector3::Normalize()
{
  Real len =  sqrt(xyz[0] * xyz[0] + xyz[1] * xyz[1] + xyz[2] * xyz[2]);

  if (len == 0.0) return;

  xyz[0] /= len;
  xyz[1] /= len;
  xyz[2] /= len;
}

void
ApuVector3::operator+=(const ApuVector3& rhs)
{
 xyz[0] += rhs.xyz[0];
 xyz[1] += rhs.xyz[1];
 xyz[2] += rhs.xyz[2];
}

void
ApuVector3::operator-=(const ApuVector3& rhs)
{
 xyz[0] -= rhs.xyz[0];
 xyz[1] -= rhs.xyz[1];
 xyz[2] -= rhs.xyz[2];
}

void
ApuVector3::operator*=(Real rhs)
{
 xyz[0] *= rhs;
 xyz[1] *= rhs;
 xyz[2] *= rhs;
}

void
ApuVector3::operator/=(Real rhs)
{
 xyz[0] /= rhs;
 xyz[1] /= rhs;
 xyz[2] /= rhs;
}

void
ApuVector3::Negate()
{
 xyz[0] -= xyz[0];
 xyz[1] -= xyz[1];
 xyz[2] -= xyz[2];
}

void
ApuVector3::Zero()
{
 xyz[0] = - xyz[0];
 xyz[1] = - xyz[1];
 xyz[2] = - xyz[2];
}

Bool
ApuEpsEq(const ApuVector3& v1, const ApuVector3& v2,
         Real epsilon)
{
  return ApuEpsEq(v1.xyz[0], v2.xyz[0], epsilon) &&
         ApuEpsEq(v1.xyz[1], v2.xyz[1], epsilon) &&
         ApuEpsEq(v1.xyz[2], v2.xyz[2], epsilon);
}

Real
ApuDot(const ApuVector3& v1, const ApuVector3& v2)
{
 return v1.xyz[0] * v2.xyz[0] + v1.xyz[1] * v2.xyz[1] + v1.xyz[2] * v2.xyz[2];
}

Real
ApuDistance(const ApuVector3& v1, const ApuVector3& v2)
{
  ApuVector3 tmp = v2;
  tmp -= v1;
  return tmp.Length();
}


Real
ApuDistanceSquared(const ApuVector3& v1, const ApuVector3& v2)
{
  ApuVector3 tmp = v2;
  tmp -= v1;
  return tmp.LengthSquared();
}

void
ApuCross(const ApuVector3& v1, const ApuVector3& v2, ApuVector3& result)
{
  result.xyz[0] = v1.Y() * v2.Z() - v1.Z() * v2.Y();
  result.xyz[1] = v1.Z() * v2.X() - v1.X() * v2.Z();
  result.xyz[2] = v1.X() * v2.Y() - v1.Y() * v2.X();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\sound\aamidi.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    MIDI support

--*/

#include "headers.h"
#include <math.h>
#include <stdio.h>
#include "privinc/soundi.h"
#include "privinc/snddev.h"
#include "privinc/util.h"
#include "privinc/path.h"
#include "privinc/storeobj.h"
#include "privinc/debug.h"
#include "privinc/aadev.h"
#include "privinc/except.h"
#include "privinc/aamidi.h"

#include <unknwn.h>
#include <objbase.h> // needed for DEFINE_GUID
#include <msimusic.h>

#error This file needs to be moved off of try/catches before being compiled

myMessageHandler::~myMessageHandler() {}

HRESULT myMessageHandler::OnSongStarted(DWORD, IAASong FAR *pSong, 
    AAFlags flags)
{
//printf("song started\n");
return S_OK;
}


HRESULT myMessageHandler::OnSongEnded(DWORD, IAASong FAR *pSong, 
    AAFlags flags, DWORD lEndTime)
{
//printf("song ended\n");
return S_OK;
}


HRESULT myMessageHandler::OnSectionStarted(DWORD, IAASection FAR *pSection, 
    AAFlags flags)
{
//printf("section started\n");
return S_OK;
}


HRESULT myMessageHandler::OnSectionEnded(DWORD, IAASection FAR *pSection,
     AAFlags flags,
 DWORD lEndTime)
{
//printf("section ended\n");
return S_OK;
}


HRESULT myMessageHandler::OnSectionChanged(DWORD, IAASection FAR *pSection, 
    AAFlags flags)
{
//printf("section changed\n");
return S_OK;
}


HRESULT myMessageHandler::OnNextSection(DWORD, IAASection FAR *pSection, AAFlags flags)
{
//printf("next section\n");
return S_OK;
}


HRESULT myMessageHandler::OnEmbellishment(DWORD, AACommands embellishment, 
    AAFlags flags)
{
//printf("embellishment\n");
return S_OK;
}


HRESULT myMessageHandler::OnGroove(DWORD, AACommands groove, AAFlags flags)
{
//printf("groove\n");
return S_OK;
}


HRESULT myMessageHandler::OnMetronome(DWORD, unsigned short nMeasure, 
    unsigned short nBeat)
{
//printf("netronome\n");
return S_OK;
}


HRESULT myMessageHandler::OnMIDIInput(long lMIDIEvent, long lMusicTime)
{
//printf("MIDI input\n");
return S_OK;
}


HRESULT myMessageHandler::OnMusicStopped(DWORD dwTime)
{
return S_OK;
}


HRESULT myMessageHandler::OnNotePlayed(AAEVENT* pEvent)
{
//printf("note played\n");
return S_OK;
}


HRESULT myMessageHandler::OnMotifEnded(DWORD, IAAMotif *, AAFlags)
{ return S_OK; }


HRESULT myMessageHandler::OnMotifStarted(DWORD, IAAMotif *, AAFlags)
{ return S_OK; }


HRESULT myMessageHandler::OnMotifStoped(DWORD)
{ return S_OK; }


HRESULT myMessageHandler::OnUserEvent(DWORD, DWORD, DWORD)
{ return S_OK; }


myMessageHandler::myMessageHandler():IAANotifySink()
{
    m_cRef          = 0;

    // XXX MFC Stuff?
    //m_pCurrentClass = 0;
    //m_pLastClass    = 0;
}


HRESULT myMessageHandler::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
    HRESULT result = E_NOINTERFACE;
    if( ::IsEqualIID( riid, IID_IAANotifySink ) ||
        ::IsEqualIID( riid, IID_IUnknown ) ) {
        AddRef();
        *ppvObj = this;
        result = S_OK;
    }

    return result;
}


ULONG myMessageHandler::AddRef()
{
    return ++m_cRef;
}


ULONG myMessageHandler::Release()
{
    ULONG cRef;

    cRef = --m_cRef;
    //if( cRef == 0 )  // XXX WHY IS THIS UNSAFE WHEN IT IS CALLED?
        //delete this;

    return cRef;
}


aaMIDIsound::aaMIDIsound()
{
    // initialize
    _started  = FALSE;
    _ended    = FALSE;
    _looping  = FALSE;
    _section  =  NULL;  // section not loaded yet!

}

void aaMIDIsound::Open(char *MIDIfileName)
{

    // stash away a copy of the filename
    fileName = (char *)ThrowIfFailed(malloc(lstrlen(MIDIfileName) + 1)); // grab a long enough hunk
    lstrcpy(fileName, MIDIfileName);
}
aaMIDIsound::~aaMIDIsound()
{
    BufferElement *bufferElement;

    // walk list destroying everything...
    while(!bufferList.empty()) {
        bufferElement = bufferList.front();

        // XXX what all has to be stoped, released, destroyed??

        if(_section)
            _section->Release();


        free(bufferElement->path);
        delete bufferElement;
        bufferList.pop_front();
    }
}


bool aaMIDIsound::RenderAvailable(GenericDevice& _dev)
{
    MetaSoundDevice *metaDev = SAFE_CAST(MetaSoundDevice *, &_dev);
    AudioActiveDev  *aaDev   = metaDev->aaDevice;

    TraceTag((tagSoundRenders, "aaMIDIsound:Render()"));

    return(aaDev->_aactiveAvailable);
}


void aaMIDIsound::RenderStop(MetaSoundDevice *metaDev, 
    BufferElement *bufferElement)
{
    AudioActiveDev  *aaDev   = metaDev->aaDevice;

    if(aaDev->_aaEngine) {
        _ended   = FALSE;
        _started = FALSE;
        aaDev->_aaEngine->Stop(); // stop it
        }
}


void aaMIDIsound::RenderNewBuffer(BufferElement *bufferElement,
              MetaSoundDevice *metaDev)
{
    AudioActiveDev  *aaDev = metaDev->aaDevice;

    bufferElement->firstTime = GetCurrTime(); // need to know time to phase

    if(!aaDev->_aaEngine) {
        try {
            aaDev->_aaEngine = NEW AAengine();
            aaDev->_aaEngine->RegisterSink(this);
        }

#ifdef _DEBUG
        catch(char *errMsg)
#else
        catch(char *)
#endif

#error Remember to remove ALLL 'catch' blocks

        {
            aaDev->_aactiveAvailable = FALSE; // couldn't initialize AA!
            if(aaDev->_aaEngine)
                delete aaDev->_aaEngine;

#ifdef _DEBUG
            // XXX popup message continuing w/o MIDI
            fprintf(stderr, 
                "aaMIDIsound::RenderNewBuffer failed to create AAengine (%s), "),
                 errMsg;
            fprintf(stderr, "continuing w/o MIDI!\n");
#endif
        }
    }

    try {
        // play the midi file
        if(!_section) { // load the section if needed
            aaDev->_aaEngine->LoadSectionFile(fileName, &_section);
        }

        aaDev->_aaEngine->PlaySection(_section);
        _started = TRUE;
    }
#error Remember to remove ALLL 'catch' blocks
    catch(char *errMsg) {
        if(_section)
            _section->Release(); // XXX delete it, too?
        RaiseException_UserError(errMsg);
    }

}
#error Did you do it right ??  Look at code that does it right...


void aaMIDIsound::RenderAttributes(
    MetaSoundDevice *metaDev, BufferElement *bufferElement)
{
    AudioActiveDev  *aaDev   = metaDev->aaDevice;

    aaDev->_aaEngine->SetGain(metaDev->GetGain());       // do Gain
    aaDev->_aaEngine->SetRate(metaDev->GetPitchShift()); // do Rate

    //XXX Note: We would 'setpan' here if we knew how to move all of the
    //          MIDI instruments around!
    //aaDev->_aaEngine->SetPan(metaDev->GetPan()); // do Pan

    if(_ended && _started) { // if what we were playing has stopped
        if(metaDev->GetLooping()) { // looped sound 
            _ended   = FALSE;       // restart the sound
            _started = TRUE;
            aaDev->_aaEngine->PlaySection(_section);
        }
        // else nothing left to do, relinquish, shutdown, etc.
    }
}


void aaMIDIsound::RenderStartAtLocation(MetaSoundDevice *metaDev,
    BufferElement *bufferElement, double phase, Bool looping)
{
// XXX realy should start the MIDI playing, here!
}


Bool aaMIDIsound::RenderPhaseLessThanLength(double phase)
{
//return(phase < (-1*lengthInSecs));
return(1); // XXX since we don't know the play time of a midi sec we return 1
}


void aaMIDIsound::RenderSetMute(
    MetaSoundDevice *metaDev, BufferElement *bufferElement)
{
    AudioActiveDev  *aaDev   = metaDev->aaDevice;

    if(aaDev->_aaEngine)
        aaDev->_aaEngine->SetGain(0.0); // mute sound 
}


// XXX next two methods are temporarialy stubed in!
Bool aaMIDIsound::RenderCheckComplete(
    MetaSoundDevice *metaDev, BufferElement *bufferElement)
{
return FALSE;
}


void aaMIDIsound::RenderCleanupBuffer(
    MetaSoundDevice *metaDev, BufferElement *bufferElement)
{
}


double aaMIDIsound::GetLength()
{
// how do we ask audioActive for the length of the section?
return(9988776655.0); // set a large and identifyable number for now
}


HRESULT aaMIDIsound::OnSectionEnded(DWORD, IAASection FAR *pSection, 
    AAFlags flags, DWORD lEndTime)
{
//printf("section ended\n");
_ended = TRUE;  // notified that the section ended
return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\misc\xformi.cpp ===
/*++
********************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

Abstract:
    Lower level transformation implementation.

********************************************************************************
--*/

#include "headers.h"
#include "privinc/basic.h"
#include "appelles/xform.h"
#include "privinc/xformi.h"
#include "privinc/vecutil.h"
#include "privinc/vec3i.h"
#include "privinc/matutil.h"

    // This declaration effectively exists in matutil.cpp, but since static
    // initialization order between modules is not guaranteed (and thus may
    // not have executed before we reach this point), we repeat it here.

static const Apu4x4Matrix identityMatrix =
{
  {
    {1.0, 0.0, 0.0, 0.0},
    {0.0, 1.0, 0.0, 0.0},
    {0.0, 0.0, 1.0, 0.0},
    {0.0, 0.0, 0.0, 1.0}
  },
  Apu4x4Matrix::IDENTITY_E,
  1
};

Transform3 *identityTransform3 = NULL;

#if MATRIX_DEBUG
static void
VerifyMatrixInverse(Apu4x4Matrix mat, Apu4x4Matrix inv)
{
    // Ensure that mat and inv combine to the identity matrix.
    Apu4x4Matrix mul;
    ApuMultiply(mat, inv, mul);
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            if (i == j) {
                Assert(fabs(mul.m[i][j] - 1) < 0.01);
            } else {
                Assert(fabs(mul.m[i][j]) < 0.01);
            }
        }
    }
}
#endif MATRIX_DEBUG

Transform3 *
Transform3::Inverse()
{
    Apu4x4Matrix tmp;

    bool ok = ApuInverse(Matrix(), tmp);

    if (!ok) return NULL;
    
    #if MATRIX_DEBUG
        VerifyMatrixInverse(Matrix(), tmp);
    #endif MATRIX_DEBUG

    return Apu4x4XformImpl(tmp);
}

Bool
Transform3::IsSingular(void)
{
    return ApuIsSingular(Matrix());
}

Transform3 *
Transform3::Copy()
{
    // Just create a new Transform3* out of the matrix.  This results
    // in the Apu4x4Matrix object being copied into the newly
    // allocated Transform3 object.
    return Apu4x4XformImpl(Matrix());
}

#if _USE_PRINT
ostream&
Transform3::Print(ostream &os)
{
    Apu4x4Matrix m = Matrix();

    os << "[";
    for (int i = 0; i < 4; i++) {
        os << "[";
        for (int j = 0; j < 4; j++) {
            os << m[i][j];
            os << ((j == 3) ? "]" : ",");
        }
    }
    return os << "]";
}
#endif

Transform3 *
CopyTransform3(Transform3 *xf)
{
    return xf->Copy();
}

/*****************************************************************************
Multiplication and concatenation follow "pre-multiply" conventions:
x transformed by (A * B) is the same as A applied to the result of
transforming x by B.
*****************************************************************************/

Transform3 *TimesXformXform (Transform3 *a, Transform3 *b)
{
    const Apu4x4Matrix& ma = a->Matrix();
    const Apu4x4Matrix& mb = b->Matrix();
    Apu4x4Matrix result;

    ApuMultiply(ma, mb, result);

    #if MATRIX_DEBUG
        // Take the inverse and see if it is really the inverse.
        Transform3 *val = Apu4x4XformImpl(result);
        Transform3 *inv = val->Inverse();
        VerifyMatrixInverse(val->Matrix(), inv->Matrix());
    #endif MATRIX_DEBUG

    return Apu4x4XformImpl(result);
}

Transform3 *Compose3Array(AxAArray *xfs)
{
    xfs = PackArray(xfs);
    
    int numXFs = xfs->Length();
    if(numXFs < 2)
       RaiseException_UserError(E_FAIL, IDS_ERR_INVALIDARG);

    Transform3 *finalXF = (Transform3 *)(*xfs)[numXFs-1];
    for(int i=numXFs-2; i>=0; i--)
        finalXF = TimesXformXform((Transform3 *)(*xfs)[i], finalXF);

    return finalXF;
}

Transform3 *InverseTransform3(Transform3 *a)
{
    Transform3 *xfresult = a->Inverse();

    #if _DEBUG
        if (xfresult)
            CHECK_MATRIX (xfresult->Matrix());
    #endif

    return xfresult;
}

Transform3 *ThrowingInverseTransform3 (Transform3 *a)
{
    Transform3 *ret = InverseTransform3(a);

    if (ret==NULL)
        RaiseException_UserError(E_FAIL, IDS_ERR_INVERT_SINGULAR_MATRIX);

    return ret;
}

AxABoolean *IsSingularTransform3(Transform3 *a)
{
    return (a->IsSingular() == TRUE ? truePtr : falsePtr);
}


void
InitializeModule_Xform3()
{
    identityTransform3 = Apu4x4XformImpl(identityMatrix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\sound\geosound.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Support for Geometry constructed from sound.

*******************************************************************************/

#include "headers.h"
#include <privinc/soundi.h>
#include <privinc/geomi.h>
#include <privinc/mici.h>
#include <appelles/vec3.h>
#include <privinc/lighti.h>
#include <privinc/dsdev.h>
#include <privinc/debug.h>
#include "privinc/basic.h"
#include "privinc/helps.h"   // LinearTodB

SoundTraversalContext::SoundTraversalContext() : _currxform(identityTransform3) {};

void
SoundTraversalContext::addSound (Transform3 *transform, Sound *sound)
{
    // Note that the sound data gets copied onto the list, so it's OK
    // to put it on the stack.
    SoundData sdata;
    sdata._transform = transform;
    sdata._sound     = sound;

    _soundlist.push_back(sdata);
}


class SpatializedSound : public Sound {
  public:

    SpatializedSound(Microphone *mic) : microphone(mic) {
        // Allocate a sound context explicitly so that we can
        // deallocate it explicitly via a dynamic deleter.
        context = NEW SoundTraversalContext;
        DynamicPtrDeleter<SoundTraversalContext> *deleter =
            NEW DynamicPtrDeleter<SoundTraversalContext>(context);
        GetHeapOnTopOfStack().RegisterDynamicDeleter(deleter);
    }

    virtual ~SpatializedSound() { CleanUp(); }
    virtual void CleanUp() {
        // TODO: deal with Deleter in general
        // delete context;
    }
    
    virtual void Render(GenericDevice &dev);
#if _USE_PRINT
    ostream& Print(ostream& s) { return s << "(" << "spatial sound" << ")"; }
#endif

    SoundTraversalContext *context;
    Microphone *microphone;
};

int    power  = 1;
double coef   = 0.4;
double constt = 0.4;

void
SpatializedSound::Render(GenericDevice &_dev)
{
    Point3Value *soundPosition;
    double distance;
    double distanceAtten;
    double saveGain;

    vector<SoundData>::iterator i;

    TraceTag((tagSoundRenders, "SpatializedSound:Render()"));

    MetaSoundDevice *metaDev = SAFE_CAST(MetaSoundDevice *, &_dev);
    DirectSoundDev  *dsDev   = (DirectSoundDev *)metaDev->dsDevice;

    Transform3   *micTransform    = microphone->GetTransform();
    Point3Value  *micPosition     = TransformPoint3(micTransform, origin3);
    Vector3Value *micOrientation  = TransformVec3(micTransform, zVector3);

    for (i = context->_soundlist.begin();
         i != context->_soundlist.end(); ++i) {
        soundPosition = TransformPoint3(i->_transform, origin3);
        distance = RDistancePoint3Point3(soundPosition, micPosition);

        // calculate attenuation based on distance
        // XXX eventualy we will want the user to be able to select the factor!
        //distanceAtten = distance ? (1.0/(pow(distance/coef, power))) : 1.0;
        double d = constt+distance*coef;
        distanceAtten = (d>0.0) ? 1/d : 1.0;
        //double dBatten = LinearTodB(distanceAtten);
        
        //printf("distance= %fM, gain=%f\n", distance, distanceAtten);
        
        saveGain = metaDev->GetGain(); // stash current gain value

        // dB space addition yeilds multiplicative accumulation in linear space
        metaDev->SetGain(saveGain * distanceAtten);
        
        i->_sound->Render(_dev); // render sound tree
        
        metaDev->SetGain(saveGain); // restore stashed gain value
    }
}


Sound *RenderSound(Geometry *geo, Microphone *mic)
{
    // Ah, this is where the sublime journey recursively visiting every node
    // in the geometry, searching out for sounds to pass the accumulated
    // geometric transformation and microphone too begins.
    
    SpatializedSound *sSound = NEW SpatializedSound(mic);
    
    geo->CollectSounds(*(sSound->context));
    
    return sSound;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\sound\dsound.cpp ===
/*******************************************************************************
Copyright (c) 1995-97 Microsoft Corporation

    Specification and implementation of static wave sound

Static wave sounds are pcm sounds loaded completely within a dsound buffer 
and played from there.

*******************************************************************************/

#include "headers.h"
#include "privinc/helpds.h"  //dsound helper routines
#include "privinc/soundi.h"
#include "privinc/snddev.h"
#include "privinc/dsdev.h"
#include "privinc/util.h"
#include "privinc/pcm.h"
#include "privinc/bufferl.h"
#include "backend/sndbvr.h"

class StaticWaveSoundInstance : public SoundInstance {
  public:
    StaticWaveSoundInstance(LeafSound *snd, TimeXform tt,
                            unsigned char *&samples, PCM& pcm)
    : SoundInstance(snd, tt), _dsProxy(NULL),
      _samples(samples), _pcm(pcm), _staticBuffer(NULL), _ownSamples(false) {}

    ~StaticWaveSoundInstance() {
        ReleaseResources();
    }

    void Create(MetaSoundDevice*, SoundContext *);
    void StartAt(MetaSoundDevice*, double);
    void Adjust(MetaSoundDevice*);
    void Mute(bool mute);
    void ReleaseResources();
    bool Done();
    bool GetLength(double&);
    
  protected:
    void CheckResources();
    DSstaticBuffer *_staticBuffer;
    PCM& _pcm;
    unsigned char *& _samples;  // sound owns these, not us, so don't release
    bool _ownSamples;           // determine if we own the samples 
    DirectSoundProxy *_dsProxy;
};


void
StaticWaveSoundInstance::Create(MetaSoundDevice *metaDev, 
    SoundContext *soundContext)
{
    DirectSoundDev  *dsDev = metaDev->dsDevice;

    // 'stud' buffer to 'clone'
    DSstaticBuffer *dsMasterBuffer = dsDev->GetDSMasterBuffer(_snd);

    if(dsMasterBuffer==NULL) {
        // Create one and add a master buffer
        DirectSoundProxy *dsProxyForMaster = CreateProxy(dsDev);

        if(!dsProxyForMaster)
            return;             // nothing else to do...

        if(!_samples) { 
            // no master buffer AND no samples?
            // we must be on 2nd view? Get our own samples (XXX set something
            // so we know we have to release these!)

            // XXX a silent standin until we can get the actual samples again
            //     this should be temporary, we need this code to allow us to
            //     dispose of _samples and still be able to age masterbuffers
            //     for now we won't delete _samples
            int bytes = _pcm.GetNumberBytes();
            _samples = (unsigned char *)StoreAllocate(GetSystemHeap(), bytes);
            _ownSamples = true;  // we own these samples now
            memset(_samples, (_pcm.GetSampleByteWidth()==1)?0x80:0x00, bytes);
        }

        // create a new MasterBuffer + fill it with the sound's samples
        dsMasterBuffer = NEW DSstaticBuffer(dsProxyForMaster, &_pcm, _samples);

        // probably won't create another master buffer with this sound
        // XXX actualy this is no longer true now that we are aging master 
        //     buffers.  We now need to keep _samples around since the code
        //     to regenerate them isn't around for the moment, and may not
        //     be the time/space tradeoff we want to make even then...
        // StoreDeallocate(GetSystemHeap(), _samples);
        // _samples = NULL; // for safety's sake...

        // proxy and buffer gets deleted when the device goes away
        dsDev->AddDSMasterBuffer(_snd, dsMasterBuffer);
    }

    // get a proxy (notify the dsDev if it fails)
    if(!_dsProxy)  // may already be set by a previous Create
        _dsProxy = CreateProxy(dsDev);

    if(!_dsProxy)
        return;                 // nothing else to do...

    // create a new staticBuffer cloned from the masterBuffer    
    if(!_staticBuffer) // may already be set by a previous Create
        _staticBuffer = NEW DSstaticBuffer(_dsProxy, dsMasterBuffer->_dsBuffer);
}


void
StaticWaveSoundInstance::CheckResources()
{
    if((!_staticBuffer) || (!_dsProxy))  {
        Create(GetCurrentSoundDevice(), _soundContext);  // re-create our resources
    _staticBuffer->playing = true; // set this so that SetPtr can restart it
    _done = false;                 // so we can go again
    }
}


void
StaticWaveSoundInstance::StartAt(MetaSoundDevice* metaDev, double localTime)
{
    CheckResources(); // re-creates as needed

    Adjust(metaDev);

    double offset = fmod(localTime, _pcm.GetNumberSeconds());
    if(offset < 0)
        offset += _pcm.GetNumberSeconds();

    int phaseBytes = _pcm.SecondsToBytes(offset); // convert to sample domain
    int phasedLocation = phaseBytes % _pcm.GetNumberBytes(); // for safety/looping
    _staticBuffer->setPtr(phasedLocation);

    _staticBuffer->play(_loop);
}


void
StaticWaveSoundInstance::Adjust(MetaSoundDevice*)
{
    CheckResources(); // re-creates as needed

    _staticBuffer->SetGain(_hit ? _gain : Sound::_maxAttenuation);
    _staticBuffer->SetPan(_pan.GetdBmagnitude(), _pan.GetDirection());

    int newFrequency = (int)(_rate * _pcm.GetFrameRate()); // do PitchShift
    _staticBuffer->setPitchShift(newFrequency);

    if(_seek) {
        double sndLength = 0.0;      // default just in case...
        bool value = GetLength(sndLength);
        Assert(value); // always should know the length of a static sound!

        if((_position >= 0.0) && (_position <= sndLength)) { // if legal
            // convert to sample domain
            int phaseBytes = _pcm.SecondsToBytes(_position);

            // for safety/looping  
            // XXX we realy need to stop a sound seeked off the end of!
            int phasedLocation = phaseBytes % _pcm.GetNumberBytes();

            _staticBuffer->setPtr(phasedLocation);
        }

        _seek = false; // reset
    }
}


void
StaticWaveSoundInstance::Mute(bool mute)
{
    if(_staticBuffer)
        _staticBuffer->SetGain(mute ? Sound::_maxAttenuation : _gain);  
}


bool
StaticWaveSoundInstance::Done()
{
    if(_staticBuffer)
        return(!_staticBuffer->_paused && !_staticBuffer->isPlaying());
    else
        return false;
}


bool
StaticWaveSoundInstance::GetLength(double& leng)
{
    leng = _pcm.GetNumberSeconds();
    return true;
}


void 
StaticWaveSoundInstance::ReleaseResources()
{
    // need to check since optimization deletes stopped sounds early!
    if(_staticBuffer) {
        _staticBuffer->stop();  // stop it
        delete _staticBuffer;
        _staticBuffer = NULL;
    }

    // We usualy don't own _samples to worry about releasing
    if(_ownSamples) {
        _ownSamples = false;
        if(_samples) {
            delete _samples; // these must be samples we filled ourselves
            _samples = NULL;
        }
    }

    if(_dsProxy) {
       delete _dsProxy;
       _dsProxy = NULL;
    }
}


SoundInstance *
StaticWaveSound::CreateSoundInstance(TimeXform tt)
{
    return NEW StaticWaveSoundInstance(this, tt, _samples, _pcm);
}


StaticWaveSound::StaticWaveSound(unsigned char *origSamples, PCM *newPCM)
{
    _pcm.SetPCMformat(newPCM); // clone the pcm passed us
    _samples = origSamples;
}


StaticWaveSound::~StaticWaveSound()
{
    extern SoundBufferCache *GetSoundBufferCache();

    if(_samples) { // free samples if they haven't been used/freed yet
        StoreDeallocate(GetSystemHeap(), _samples);
        _samples = NULL;
    }

    GetSoundBufferCache()->DeleteBuffer(this); // delete entries left on cache

    SoundGoingAway(this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\sound\mic.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Support for the abstract microphone type.

--*/

#include "headers.h"
#include "privinc/mici.h"
#include "privinc/xformi.h"

////////////////  Default microphone  /////////////////////////

class DefaultMicrophone : public Microphone {
  public:
    Transform3 *GetTransform() const { return identityTransform3; }
#if _USE_PRINT
    ostream& Print(ostream& os) const {
        return os << "defaultMicrophone";
    }
#endif
};

Microphone *defaultMicrophone = NULL;

///////////////// Transformed Microphone ////////////////

class TransformedMic : public Microphone {
  public:

    TransformedMic(Transform3 *newXf, Microphone *mic) {
        xf = TimesXformXform(newXf, mic->GetTransform());
    }

    Transform3 *GetTransform() const { return xf; }

#if _USE_PRINT
    ostream& Print(ostream& os) const {
        // TODO... don't have print funcs for xforms.
        return os << "Apply(SOMEXFORM, defaultMic)";
    }
#endif

    virtual void DoKids(GCFuncObj proc) { (*proc)(xf); }

  protected:
    Transform3 *xf;
};

Microphone *TransformMicrophone(Transform3 *xf, Microphone *mic)
{
    return NEW TransformedMic(xf, mic);
}

#if _USE_PRINT
ostream&
operator<<(ostream& os, const Microphone *mic)
{
    return mic->Print(os);
}
#endif

void
InitializeModule_Mic()
{
    defaultMicrophone = NEW DefaultMicrophone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\sound\midi.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    The generic MIDI sound

--*/

#include "headers.h"
#include <math.h>
#include <stdio.h>
#include "privinc/soundi.h"
#include "privinc/snddev.h"
#include "privinc/util.h"
#include "privinc/path.h"
#include "privinc/storeobj.h"
#include "privinc/debug.h"
#include "privinc/except.h"

#include <unknwn.h>
#include <objbase.h> // needed for DEFINE_GUID

#ifdef SOMETIME


MIDIsound::MIDIsound(char *MIDIfileName)
{
// initialize
_started  = FALSE;
_ended    = FALSE;
_looping  = FALSE;
_section  =  NULL;  // section not loaded yet!

// stash away a copy of the filename
fileName = (char *)ThrowIfFailed(malloc(lstrlen(MIDIfileName) + 1)); // grab a long enough hunk
lstrcpy(fileName, MIDIfileName);
}


MIDIsound::~MIDIsound()
{
    TraceTag((tagGCMedia, "~MIDISound %x - NYI", this));
    return;
    
    BufferElement *bufferElement;

    // walk list destroying everything...
    while(!bufferList.empty()) {
        bufferElement = bufferList.front();

        // XXX what all has to be stoped, released, destroyed??

        if(_section)
            _section->Release();


        free(bufferElement->path);
        delete bufferElement;
        bufferList.pop_front();
    }
}


bool MIDIsound::RenderAvailable(MetaSoundDevice *metaDev)
{
    AudioActiveDev  *aaDev   = metaDev->aaDevice;

    TraceTag((tagSoundRenders, "MIDIsound:Render()"));

    return(aaDev->_aactiveAvailable);
}


void MIDIsound::RenderStop(MetaSoundDevice *metaDev, 
    BufferElement *bufferElement)
{
    AudioActiveDev  *aaDev   = metaDev->aaDevice;

    if(aaDev->_aaEngine) {
        _ended   = FALSE;
        _started = FALSE;
        aaDev->_aaEngine->Stop(); // stop it
        }
}


void MIDIsound::RenderNewBuffer(MetaSoundDevice *metaDev)
{
#ifdef RESTORE_WHEN_WE_PUT_AA_BACK_IN
    AudioActiveDev  *aaDev = metaDev->aaDevice;

    bufferElement->firstTime = GetCurrTime(); // need to know time to phase

    if(!aaDev->_aaEngine) {
        __try {
            aaDev->_aaEngine = NEW AAengine();
            aaDev->_aaEngine->RegisterSink(this);
        }
        __except( HANDLE_ANY_DA_EXCEPTION )  {
            aaDev->_aactiveAvailable = FALSE; // couldn't initialize AA!
            if(aaDev->_aaEngine)
                delete aaDev->_aaEngine;

#ifdef _DEBUG
            // XXX popup message continuing w/o MIDI
            fprintf(stderr, "MIDIsound::RenderNewBuffer failed to create AAengine (%s)", errMsg);
            fprintf(stderr, "continuing w/o MIDI!\n");
#endif
        }
    }

    __try {
        // play the midi file
        if(!_section) { // load the section if needed
            aaDev->_aaEngine->LoadSectionFile(fileName, &_section);
        }

        aaDev->_aaEngine->PlaySection(_section);
        _started = TRUE;
    }
    __except( HANDLE_ANY_DA_EXCEPTION ) {
        if(_section)
            _section->Release(); // XXX delete it, too?
        RETHROW;
    }

#endif
}


void MIDIsound::RenderAttributes(MetaSoundDevice *metaDev, 
    BufferElement *bufferElement, double rate, bool doSeek, double seek)
{
    AudioActiveDev  *aaDev   = metaDev->aaDevice;

    aaDev->_aaEngine->SetGain(metaDev->GetGain()); // do Gain
    aaDev->_aaEngine->SetRate(rate);               // do Rate

    //XXX Note: We would 'setpan' here if we knew how to move all of the
    //          MIDI instruments around!
    //aaDev->_aaEngine->SetPan(metaDev->GetPan()); // do Pan

    if(_ended && _started) { // if what we were playing has stopped
        if(metaDev->GetLooping()) { // looped sound 
            _ended   = FALSE;       // restart the sound
            _started = TRUE;
            aaDev->_aaEngine->PlaySection(_section);
        }
        // else nothing left to do, relinquish, shutdown, etc.
    }
}


void MIDIsound::RenderStartAtLocation(MetaSoundDevice *metaDev,
    BufferElement *bufferElement, double phase, Bool looping)
{
// XXX realy should start the MIDI playing, here!
}


Bool MIDIsound::RenderPhaseLessThanLength(double phase)
{
//return(phase < (-1*lengthInSecs));
return(1); // XXX since we don't know the play time of a midi sec we return 1
}


void MIDIsound::RenderSetMute(
    MetaSoundDevice *metaDev, BufferElement *bufferElement)
{
    AudioActiveDev  *aaDev   = metaDev->aaDevice;

    if(aaDev->_aaEngine)
        aaDev->_aaEngine->SetGain(0.0); // mute sound 
}


// XXX next two methods are temporarialy stubed in!
Bool MIDIsound::RenderCheckComplete(
    MetaSoundDevice *metaDev, BufferElement *bufferElement)
{
return FALSE;
}


void MIDIsound::RenderCleanupBuffer(
    MetaSoundDevice *metaDev, BufferElement *bufferElement)
{
}


HRESULT MIDIsound::OnSectionEnded(DWORD, IAASection FAR *pSection, 
    AAFlags flags, DWORD lEndTime)
{
//printf("section ended\n");
_ended = TRUE;  // notified that the section ended
return S_OK;
}

#endif /* SOMETIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\sound\qmidi.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    MIDI support

--*/

#include "headers.h"
#include "privinc/soundi.h"
#include "privinc/debug.h"
#include "privinc/except.h"
#include "privinc/qmidi.h"
#include "backend/sndbvr.h"

// min diff needed to bother setting q's rate
double qMIDIsound::_RATE_EPSILON = 0.01;

qMIDIsound::qMIDIsound() : _filterGraph(NULL)
{
    _filterGraph = NEW QuartzRenderer;
}


void qMIDIsound::Open(char *MIDIfileName)
{
    Assert(_filterGraph);
    _filterGraph->Open(MIDIfileName);
}


qMIDIsound::~qMIDIsound()
{
    if (_filterGraph) {
        _filterGraph->Stop();
        
        delete _filterGraph;
    }
}


bool 
qMIDIsound::RenderAvailable(MetaSoundDevice *metaDev)
{
    // XXX eventually we might want to stop forcing this...
    return(true); // quartz always assumed available
}


double 
qMIDIsound::GetLength()
{
    Assert(_filterGraph);
    return(_filterGraph->GetLength());
}


class MIDISoundInstance : public SoundInstance {
  public:
    MIDISoundInstance(LeafSound *snd, TimeXform tt)
    : SoundInstance(snd, tt) {}

    QuartzRenderer *GetMIDI() {
        qMIDIsound *m = SAFE_CAST(qMIDIsound *, _snd);

        Assert(m && m->GetMIDI());
        
        return m->GetMIDI();
    }

    void ReleaseResources() { }

    ~MIDISoundInstance() { 
        QuartzRenderer *filterGraph = GetMIDI();
        
        if(IsUsingMIDIHardware(_txSnd, filterGraph))
            AcquireMIDIHardware(NULL, NULL);
        else {
            // we don't have the hw, no need to stop
            // filterGraph->Stop();
        }
    }

    // ~MIDISoundInstance() { ReleaseResources(); }
    
    void Create(MetaSoundDevice*, SoundContext *) {}
    
    void StartAt(MetaSoundDevice*, double);
    void Adjust(MetaSoundDevice*);
    void Mute(bool mute);

    void CheckResources() {}
    
    bool Done() { return GetMIDI()->QueryDone(); }
    
    void CheckDone();
    
    bool GetLength(double& len) {
        len = GetMIDI()->GetLength();
        return true;
    }
};


void
MIDISoundInstance::CheckDone() 
{
    QuartzRenderer *filterGraph = GetMIDI();

    // give up if our filtergraph doesn't have the hw
    if(!IsUsingMIDIHardware(_txSnd, filterGraph))
        return;
        
    if(filterGraph->QueryDone()) { 
        if(_loop) { // looped sound 
            filterGraph->Position(0.0);
            filterGraph->Play();
        }
        // else nothing left to do, relinquish, shutdown, etc.
    }
}


void
MIDISoundInstance::Adjust(MetaSoundDevice *metaDev) 
{
    QuartzRenderer *filterGraph = GetMIDI();

    // give up if our filtergraph doesn't have the hw
    if (!IsUsingMIDIHardware(_txSnd, filterGraph))
        return;
        
    if(_seek) {
        filterGraph->Position(_position);
        _seek = false;  // reset
    }

    double rateChange = fabs(_rate - _lastRate);
    if (rateChange > qMIDIsound::_RATE_EPSILON) {
        filterGraph->SetRate(_rate); // do Rate
    }

    // unfortunately we expect these to fail
    __try {
        // do Gain
        filterGraph->SetGain(_hit ? _gain : Sound::_maxAttenuation);
    }
    __except( HANDLE_ANY_DA_EXCEPTION )  {
        //_gainWorks = false; // this is dissabled for good Quartz bvr
    }

    __try { // do Pan
        filterGraph->SetPan(_pan.GetdBmagnitude(), _pan.GetDirection()); 
    }
    __except( HANDLE_ANY_DA_EXCEPTION )  {
        //_panWorks = false;  // this is dissabled for good Quartz bvr
    }

    CheckDone();
}


void
MIDISoundInstance::StartAt(MetaSoundDevice* dev, double phase)
{
    TraceTag((tagSoundReaper1,
              "MIDISoundInstance::RenderStart phase=%f, this=0x%08X",
              phase, this));

    QuartzRenderer *filterGraph = GetMIDI();

    // steal the device for OUR sound!
    AcquireMIDIHardware(_txSnd, filterGraph);
    
    Assert(IsUsingMIDIHardware(_txSnd, filterGraph));
    
    double length = filterGraph->GetLength();
    double offset = fmod(phase, length);
    if(offset < 0)
        offset += length;

    filterGraph->Position(offset);
    filterGraph->Play();

    _lastRate = -1;             // force it to adjust rate
    Adjust(dev);
}


void
MIDISoundInstance::Mute(bool mute)
{
    // unfortunately we expect this to fail
    __try {
        GetMIDI()->SetGain(mute ? -200.0 : _gain); // do Gain
    }
    __except( HANDLE_ANY_DA_EXCEPTION )  {
        //_gainWorks = false;  // this is dissabled for good Quartz bvr
    }
}


SoundInstance *
qMIDIsound::CreateSoundInstance(TimeXform tt)
{
    return NEW MIDISoundInstance(this, tt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\sound\tmpguid.cpp ===
/**********************************************************************
Temp hack to declare these guids 
**********************************************************************/
#include "headers.h"
#include <windows.h>
#include <initguid.h>


// 05589f81-c356-11ce-bf01-00aa0055595a        FORMAT_WaveFormatEx
DEFINE_GUID(FORMAT_WaveFormatEx,
0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\sound\sattr.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Sound attributers

*******************************************************************************/

#include "headers.h"
#include "privinc/soundi.h"
#include "privinc/snddev.h"
#include "privinc/debug.h"
#include "appelles/axaprims.h"
#include "appelles/arith.h"
#include "privinc/basic.h"
#include "privinc/util.h"
#include "privinc/gendev.h"  // DeviceType

// definition of Sound static members
double Sound::_minAttenuation =     0;  // in dB
double Sound::_maxAttenuation = -1000;  // in dB (order of magnitude overkill)

//////// Looping ////////

class LoopingSound : public Sound {
  public:
    LoopingSound(Sound *snd) : _sound(snd) {}

    virtual void Render(GenericDevice& dev); 

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "Looping(" << _sound << ")";
    }
#endif

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_sound); 
        Sound::DoKids(proc);
    }

  protected:
    Sound *_sound;
};


void LoopingSound::Render(GenericDevice& _dev) 
{
    if (_dev.GetDeviceType()!=SOUND_DEVICE) {
        _sound->Render(_dev);   // just descend!
    }
    else { // we have a sound device and RENDER_MODE

        MetaSoundDevice *metaDev = SAFE_CAST(MetaSoundDevice *, &_dev);

        TraceTag((tagSoundRenders, "LoopingSound:Render()"));

        if (!metaDev->IsLoopingSet()) {
            metaDev->SetLooping();
            _sound->Render(_dev);    // render it looped
            metaDev->UnsetLooping();
        } else {
            _sound->Render(_dev);    // render it not looped
        }
    }
}


Sound *ApplyLooping(Sound *snd) { return NEW LoopingSound(snd); }

//////// Gain ////////

class GainSound : public Sound {
  public:
    GainSound( Real g, Sound *s ) : _gain( g ), _sound(s) {}

    virtual void Render(GenericDevice& dev);

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "Gain(" << _gain << ")(" << _sound << ")";
    }
#endif

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_sound); 
        Sound::DoKids(proc);
    }

  protected:
    Real  _gain;
    Sound *_sound;
};


void GainSound::Render(GenericDevice& _dev) 
{
    if(_dev.GetDeviceType()!=SOUND_DEVICE) {
        _sound->Render(_dev);  // just descend
    }
    else {
        MetaSoundDevice *metaDev = SAFE_CAST(MetaSoundDevice *, &_dev);

        TraceTag((tagSoundRenders, "GainSound:Render()"));

        // Gain composes into the context multiplicatively
        double stashed = metaDev->GetGain(); // stash to later restore

        // Gain is accumulates multiplicatively in the linear space (exposed)
        metaDev->SetGain(stashed * _gain);
        _sound->Render(_dev);
        metaDev->SetGain(stashed);
    }
}


Sound *ApplyGain(AxANumber *g, Sound *s)
{ return NEW GainSound(NumberToReal(g), s); }


//////// Pan ////////

class PanSound : public Sound {
  public:
    PanSound(Real pan, Sound *s) : _sound(s), _pan(pan) {}
    virtual void Render(GenericDevice& dev);

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "Pan(" << _pan << ")(" << _sound << ")";
    }
#endif

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(_sound); 
        Sound::DoKids(proc);
    }

  protected:
    Sound    *_sound;
    double    _pan;
};


void PanSound::Render(GenericDevice& _dev) 
{
    if (_dev.GetDeviceType() != SOUND_DEVICE) {
        _sound->Render(_dev); // just descend
    }
    else {
        MetaSoundDevice *metaDev = SAFE_CAST(MetaSoundDevice *, &_dev);

        TraceTag((tagSoundRenders, "PanSound:Render()"));

        double stashed = metaDev->GetPan();

        metaDev->SetPan(_pan + stashed); // additivly apply pan
        _sound->Render(_dev);
        metaDev->SetPan(stashed); // restore the stashed pan value
    }
}


Sound *ApplyPan(AxANumber *g, Sound *s) 
{
    return NEW PanSound(NumberToReal(g), s); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalibc\daheap.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _DAHEAP_H
#define _DAHEAP_H

extern bool HeapInit();
extern void HeapDeinit();
extern void * DAAlloc(size_t size);
extern void DAFree(void *p);

#endif /* _DAHEAP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\sound\stquartz.cpp ===
/*++

Copyright (c) 1995-97 Microsoft Corporation

Abstract:

    Streaming quartz sound

--*/

#include "headers.h"
#include "privinc/soundi.h"
#include <ddraw.h>
#include "privinc/snddev.h"
#include "privinc/util.h"
#include "privinc/debug.h"
#include "privinc/bground.h"
#include "privinc/stquartz.h"
#include "privinc/helpds.h"
#include "backend/sndbvr.h"
#include "privinc/bufferl.h"


#define THREADED // turn on threaded synthesizers
extern SoundBufferCache *GetSoundBufferCache();

StreamQuartzPCM::StreamQuartzPCM(char *fileName)
    : _fileName(NULL), _latency(0.5), _buffer(NULL)
{
    _fileName = (char *)
        StoreAllocate(GetSystemHeap(), strlen(fileName)+1);
    strcpy(_fileName, fileName); // copy fileName

    // XXX only for testing instantiate now (later use RenderNewBuffer!)
    //_quartzStream = NEW QuartzAudioStream(_fileName);
    //pcm.SetPCMformat(&(_quartzStream->pcm)); // set our format the same as theirs
}


StreamQuartzPCM::~StreamQuartzPCM()
{
    GetSoundBufferCache()->DeleteBuffer(this); // delete entries left on cache

    // destroy everything created in the constructor

    if(_fileName)
        StoreDeallocate(GetSystemHeap(), _fileName);

    if(_buffer)
        StoreDeallocate(GetSystemHeap(), _buffer);

    SoundGoingAway(this);
}


class StreamQuartzPCMSoundInstance : public SoundInstance {
  public:
    StreamQuartzPCMSoundInstance(LeafSound *snd, TimeXform tt, PCM& pcm)
    : SoundInstance(snd, tt), _quartzBufferElement(NULL), _pcm(pcm),
      _gotResources(false)
      //, _soundContext(NULL)
    {
        Assert(DYNAMIC_CAST(StreamQuartzPCM*, snd));

        // seems like a fine time to create the _soundContext
        // _soundContext = NEW SoundContext();
    }

    void ReleaseResources() { 
        // can be null if not started
        if(_quartzBufferElement) {
            // save info from the bufferElement in the context!
            // Assert(_soundContext);


            if(_quartzBufferElement->GetThreaded()) {
                _quartzBufferElement->SetKillFlag(true);
            }
            else {
                _quartzBufferElement->GetStreamingBuffer()->stop();
                delete _quartzBufferElement;
            }

            _quartzBufferElement = NULL;
            _gotResources        = false;

        }
    }

    ~StreamQuartzPCMSoundInstance() { ReleaseResources(); }

    StreamQuartzPCM *GetStreamQuartzPCM() {
        return SAFE_CAST(StreamQuartzPCM*, _snd);
    }

    void Create(MetaSoundDevice*, SoundContext *);
    void StartAt(MetaSoundDevice*, double);
    void Adjust(MetaSoundDevice*);
    void Mute(bool mute);
    bool Done();
    bool GetLength(double&);

    virtual void SetTickID(DWORD id) {
        if(_quartzBufferElement) {
            QuartzAudioReader *quartzAudioReader = 
                _quartzBufferElement->GetQuartzAudioReader();

            Assert(quartzAudioReader);

            quartzAudioReader->SetTickID(id);
        }
    }

  protected:
    QuartzBufferElement *_quartzBufferElement;
    PCM& _pcm;
    // SoundContext *_soundContext;

  private:
    void CheckResources();
    bool _gotResources;
};


void
StreamQuartzPCMSoundInstance::CheckResources()
{
    if(!_gotResources) {
        Create(GetCurrentSoundDevice(), _soundContext);  // re-create our resources
        _done   = false;                  // so we can go again
        _status = SND_FETAL;              // so we can go again
    }
}


QuartzAudioStream *
ThrowingNewQuartzAudioStream(char *url)
{ return NEW QuartzAudioStream(url); }


QuartzAudioStream *
NonThrowingNewQuartzAudioStream(char *url)
{
    QuartzAudioStream *result = NULL;
    
    __try {
        result = ThrowingNewQuartzAudioStream(url);
    } __except ( HANDLE_ANY_DA_EXCEPTION ) {
        result = NULL;
    }

    return result;
}


void
StreamQuartzPCMSoundInstance::Create(MetaSoundDevice *metaDev, 
    SoundContext *soundContext)
{   
    DirectSoundDev   *dsDev      = metaDev->dsDevice;
    SoundBufferCache *soundCache = GetSoundBufferCache();
    
    QuartzBufferElement *quartzBufferElement = 
        SAFE_CAST(QuartzBufferElement *, soundCache->GetBuffer(_snd));

    // get a proxy (notify the dsDev if it fails)
    DirectSoundProxy *dsProxy = CreateProxy(dsDev);
    if(!dsProxy)
        return;                         // nothing else to do...

    if(quartzBufferElement) { // did we find one on the cache?
        // ok use this one and its quartz but add the path and dsbuffer...

        // set our format same as theirs
        _pcm.SetPCMformat(&quartzBufferElement->GetQuartzAudioReader()->pcm);
        DSstreamingBuffer *streamingBuffer =
            NEW DSstreamingBuffer(dsProxy, &_pcm);
        quartzBufferElement->SetStreamingBuffer(streamingBuffer);
        quartzBufferElement->SetDSproxy(dsProxy);

        CComPtr<IStream> istream = quartzBufferElement->RemoveFile();

        if(istream.p) { // a valid stream handle?
            // add the streamhandle to the device
            dsDev->AddStreamFile(_snd, istream);
        }

        soundCache->RemoveBuffer(_snd);  // yup, use it + remove it from cache
    } else { //didn't find one, we will have to make out own...
        
        StreamQuartzPCM *p = GetStreamQuartzPCM();
        
        QuartzAudioStream *quartzStream =
            NonThrowingNewQuartzAudioStream(p->GetFileName());

        if(quartzStream==NULL) 
            return;
        
        _pcm.SetPCMformat(&(quartzStream->pcm)); // set our format same as theirs
        DSstreamingBuffer *streamingBuffer =
            NEW DSstreamingBuffer(dsProxy, &_pcm);

        quartzBufferElement = NEW // create new element
            QuartzBufferElement(p, quartzStream, streamingBuffer, dsProxy);
    }

    quartzBufferElement->SetSyncStart(); // synchronize this buffer

#ifdef THREADED 
    dsDev->AddSound(_snd, metaDev, quartzBufferElement);
#endif /* THREADED */

    // do it here just in case of exception above
    _quartzBufferElement = quartzBufferElement;

    // stuff info from soundContext into the bufferElement
    // _quartzBufferElement->Set() = _soundContext->Get();

    _gotResources = true;
}


void
StreamQuartzPCMSoundInstance::Adjust(MetaSoundDevice *metaDev)
{
    CheckResources();
    if(!_quartzBufferElement)  // exception handling
        return;
    
    DSstreamingBuffer *streamingBuffer =
        _quartzBufferElement->GetStreamingBuffer();

    if(_hit)
        streamingBuffer->SetGain(_gain);
    
    streamingBuffer->SetPan(_pan.GetdBmagnitude(), _pan.GetDirection());

    if(0) { // servo
        // all streamingSound::RenderSamples must update stats!
        streamingBuffer->updateStats();  // track sample
    }


    // limit rates to 0-2 (faster rates require infinite resources)
    // XXX eventualy we will use a quartz rate converter filter...
    double rate = fsaturate(0.0, 2.0, _rate); 
    int newFrequency = (int)(rate * _pcm.GetFrameRate());
    streamingBuffer->setPitchShift(newFrequency);

#ifdef THREADED  // communicate changes to the bg thread
    metaDev->dsDevice->SetParams(_quartzBufferElement, 
                                 _rate, _seek, _position, _loop);
    
    _seek = false;              // reset seek field
#else
    if(doSeek)   // do the work immediately if needed
        metaDev->_seek = seek;
    else
        metaDev->_seek = -1.0;  // negative number denotes no-seek
#endif /* THREADED */
}


void
StreamQuartzPCMSoundInstance::StartAt(MetaSoundDevice *metaDev, double phase)
{
    CheckResources();
    if (!_quartzBufferElement)  // exception handling
        return;
    
    QuartzAudioReader *quartzAudioReader = 
        _quartzBufferElement->GetQuartzAudioReader();

    Assert(quartzAudioReader);

    quartzAudioReader->InitializeStream();

    double offset =
        fmod(phase, quartzAudioReader->pcm.GetNumberSeconds());
    
    if(offset < 0)
        offset += quartzAudioReader->pcm.GetNumberSeconds();
    double frameOffset = quartzAudioReader->pcm.SecondsToFrames(offset);

    // XXX shouldn't we know if it is looped and mod the offset?
    //     what happens if we seek off the end?
    quartzAudioReader->SeekFrames(frameOffset);

    if(!quartzAudioReader->QueryPlaying()) 
        quartzAudioReader->Run(); // if filter graph isn't playing, then run it!

    _quartzBufferElement->RenderSamples(); // prime the buffer

    Assert(_quartzBufferElement->GetStreamingBuffer());
    
    _quartzBufferElement->GetStreamingBuffer()->play(TRUE);  
    _quartzBufferElement->_playing = TRUE;
}


bool
StreamQuartzPCMSoundInstance::GetLength(double& len)
{
    len = _pcm.GetNumberSeconds();
    return true;
}


void
QuartzBufferElement::RenderSamples()
{
    DSstreamingBuffer *streamingBuffer = GetStreamingBuffer();
    Assert(streamingBuffer);
    
    QuartzAudioReader *quartzAudioReader = GetQuartzAudioReader();
    Assert(quartzAudioReader);

    long framesFree;
    long framesToTransfer;
    long framesGot;
    long bufferFrameSize =
        streamingBuffer->pcm.SecondsToFrames(_snd->GetLatency());

    if(_snd->GetBuffer()==NULL) {
        _snd->SetBuffer((unsigned char *)StoreAllocate(GetSystemHeap(),
                        _snd->_pcm.FramesToBytes(bufferFrameSize)));
    }

    unsigned char *buffer = _snd->GetBuffer();
    
    framesFree       = streamingBuffer->framesFree();
    framesToTransfer = saturate(0, bufferFrameSize, framesFree);

    if(_doSeek) {
        double frameOffset = quartzAudioReader->pcm.SecondsToFrames(_seek);
        quartzAudioReader->SeekFrames(frameOffset);
        _doSeek = false;
    }

#ifdef OLD_DYNAMIC_PHASE
    // seek quartz as needed (needs to be mutexed)
    if(metaDev->_seek >= 0.0) {
        double frameOffset = quartzAudioReader->pcm.SecondsToFrames(metaDev->_seek);

        // XXX shouldn't we know if it is looped and mod the offset?
        //     what happens if we seek off the end?
        quartzAudioReader->SeekFrames(frameOffset);
    }
#endif OLD_DYNAMIC_PHASE


    // read quartz samples
    framesGot = quartzAudioReader->ReadFrames(framesToTransfer, buffer);

    if(framesGot == -1) { // FALLBACK!  We need to clone a new audio amstream!
        TraceTag((tagAVmodeDebug, "RenderSamples: audio gone FALLBACK!!"));
        quartzAudioReader = FallbackAudio();

        Assert(quartzAudioReader);
        
        // retry the get, now on the new stream
        framesGot = quartzAudioReader->ReadFrames(framesToTransfer, buffer);
    }

    if(framesGot)
        streamingBuffer->writeFrames(buffer, framesGot); // write them to dsound

    if(framesGot < framesToTransfer) { // end of file
        if (_loop) { // (explicitly use the metaDev passed us!)
            quartzAudioReader->SeekFrames(0); // restart the sound!
            framesToTransfer -= framesGot;
            framesGot = quartzAudioReader->ReadFrames(framesToTransfer, buffer);
            if(framesGot)
                streamingBuffer->writeFrames(buffer, framesGot); // write them to dsound
        }
        else {
            // XXX I need to standardize/factor this code!
            if(!streamingBuffer->_flushing)
                streamingBuffer->_flushing = 1;

            // flush the dsound buffer  (XXX fix dsound!)
            // NOTE: this may/will take a number of tries waiting for the
            //       last samples to play out!
            framesFree = streamingBuffer->framesFree();
            if(framesFree) {
                streamingBuffer->writeSilentFrames(framesFree);
                streamingBuffer->_flushing+= framesFree;
            }

            if(streamingBuffer->_flushing >
               streamingBuffer->TotalFrames()) {
                   // XXX self terminate sound
                   // XXX close the buffer after it has played out
            }
        }
    }
}


bool
StreamQuartzPCMSoundInstance::Done()
{
    if(!_quartzBufferElement)  // exception handling
        return false;
    
    DSstreamingBuffer *streamingBuffer =
        _quartzBufferElement->GetStreamingBuffer();

    Assert(streamingBuffer); 
    
    QuartzAudioReader *quartzAudioReader =
        _quartzBufferElement->GetQuartzAudioReader();

    //TraceTag((tagError, "RendercheckComplete:  QuartzAudioReader is %x", quartzAudioReader));

    // XXX: hack: Ken please make sure this is correct!  The problem
    // is that another thread destroys the quartzAudioReader and this
    // guys tries to access it...
    if(!quartzAudioReader) 
        return true;
    
    // XXX eventualy check if the input is exhausted and that the output has
    //     completely played out (initialy we will only check the former!)
    // (or do a prediction based on the number of samples in the buffer)
    return(quartzAudioReader->Completed());
}


void
StreamQuartzPCMSoundInstance::Mute(bool mute)
{
    if(!_quartzBufferElement)  // exception handling
        return;
    
    // mute sound (-100 Db attenuation)

    Assert(_quartzBufferElement->GetStreamingBuffer());
    
    _quartzBufferElement->GetStreamingBuffer()->
        SetGain(mute ? -100.0 : _gain); 
}


SoundInstance *
StreamQuartzPCM::CreateSoundInstance(TimeXform tt)
{
    return NEW StreamQuartzPCMSoundInstance(this, tt, _pcm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\sound\stream.cpp ===
/*++

Copyright (c) 1995-97 Microsoft Corporation

Abstract:

    Streaming sounds, synth support

--*/

#include "headers.h"
#include "privinc/helpds.h" 
#include "privinc/soundi.h"
#include "privinc/dsdev.h"
#include "privinc/snddev.h"
#include "privinc/util.h"
#include "privinc/sndfile.h"
#include "privinc/bground.h"
#include "privinc/bufferl.h"
#include "backend/sndbvr.h"

#define THREADED // turn on threaded synthesizers

class SinSynth : public LeafDirectSound {
  public:
    SinSynth(double newFreq=1.0);

    virtual SoundInstance *CreateSoundInstance(TimeXform tt);

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "SinSynth";
    }
#endif

  protected:
    double _sinFrequency;
};


class SinSynthSoundInstance : public SoundInstance {
  public:
    SinSynthSoundInstance(LeafSound *snd, TimeXform tt, double sf, PCM& pcm)
    : SoundInstance(snd, tt), _sinFrequency(sf),
      _synthBufferElement(NULL), _pcm(pcm) {}

    void ReleaseResources() {
        if(_synthBufferElement) {
            Assert(_synthBufferElement->GetStreamingBuffer());
            
            if(_synthBufferElement->GetThreaded())
                _synthBufferElement->SetKillFlag(true);
            else {
                _synthBufferElement->GetStreamingBuffer()->stop();
                delete _synthBufferElement;
                _synthBufferElement = NULL;
            }
        }
    }

    ~SinSynthSoundInstance() { ReleaseResources(); }

    void Create(MetaSoundDevice*, SoundContext *);
    void StartAt(MetaSoundDevice*, double);
    void Adjust(MetaSoundDevice*);
    void Mute(bool mute);
    bool Done() { return false; }
    bool GetLength(double&) { return false; }

  protected:
    SynthBufferElement *_synthBufferElement;
    double _sinFrequency;
    PCM& _pcm;

  private:
    void CheckResources();
};


void
SinSynthSoundInstance::Create(MetaSoundDevice *metaDev, SoundContext *)
{
    // XXX we probably don't want to do this everytime, but we can't
    //     do it in the constructor since we don't have the device then...
    // 16bit, mono, primary-buffer==native rate)
    DirectSoundDev  *dsDev = metaDev->dsDevice;

    // get a proxy (notify the dsDev if it fails)
    DirectSoundProxy *dsProxy = CreateProxy(dsDev);
    if(!dsProxy)
        return;                         // nothing else to do...

    _pcm.SetPCMformat(2, 1, dsProxy->GetPrimaryBuffer()->getSampleRate());

    DSstreamingBuffer *sbuffer = NEW DSstreamingBuffer(dsProxy, &_pcm);

    // setup the sin wave synth
    // create NEW element to hold our synth stuff
    _synthBufferElement = 
        NEW SynthBufferElement(sbuffer, dsProxy,
                               _sinFrequency, 0.0, _pcm.GetFrameRate());

#ifdef THREADED 
    dsDev->AddSound(_snd, metaDev, _synthBufferElement);
#endif /* THREADED */
}


void
SinSynthSoundInstance::CheckResources()
{
    if(!_synthBufferElement) {
        Create(GetCurrentSoundDevice(), (SoundContext *)0);  // re-create our resources
        _done = false;                    // so we can go again
    }
}


void
SinSynthSoundInstance::Adjust(MetaSoundDevice *metaDev)
{
    CheckResources();
    DSstreamingBuffer *streamingBuffer =
        _synthBufferElement->GetStreamingBuffer();

    if(_hit)
        streamingBuffer->SetGain(_gain);
    
    streamingBuffer->SetPan(_pan.GetdBmagnitude(), _pan.GetDirection());

    // TODO:
    metaDev->dsDevice->SetParams(_synthBufferElement, _rate, false, 0.0, _loop);
}


void
SinSynthSoundInstance::StartAt(MetaSoundDevice *metaDev, double)
{
    CheckResources();

#ifdef LATERON
    DirectSoundDev  *dsDev = metaDev->dsDevice;

    long sampleOffset =
        (long)(phase * dsDev->primaryBuffer->getSampleRate());
    //(long)(phase * dsDev->primaryBuffer->getSampleRate() / pitchShift);
    sampleOffset %= _soundFile->GetFrameCount();

    value += sampleOffset * delta??
#endif /* LATERON */
        
    _synthBufferElement->_playing = TRUE;
}


void
SynthBufferElement::RenderSamples()
{
    DSstreamingBuffer *streamingBuffer = GetStreamingBuffer();

    int framesFree;
    short buffer[100000]; // XXX set worstcase size == buffer size!

    double pitchShift   = _rate; // do PitchShift
    double currentDelta = _delta * pitchShift;
    double sampleRate   = 
        GetDSproxy()->GetPrimaryBuffer()->getSampleRate();

    if(framesFree = streamingBuffer->framesFree()) {
        double offset = 0.0; //sampleRate / pitchShift;
        //double offset = metaDev->GetPhase() * sampleRate / pitchShift;

        // For now synth, and xfer samples within render 
        for(int x = 0; x < framesFree; x++) {
            buffer[x]= (short)(32767.0 * sin(_value + offset));
            _value += currentDelta;
        }

        streamingBuffer->writeFrames(buffer, framesFree); // write samps!

        if(!streamingBuffer->_paused && !streamingBuffer->isPlaying())
            streamingBuffer->play(TRUE);  // start buffer looping
    }

    // all streamingSound::RenderSamples must update stats!
    streamingBuffer->updateStats();  // keep track of samples consumed
}


void
SinSynthSoundInstance::Mute(bool mute)
{
    CheckResources();
    _synthBufferElement->GetStreamingBuffer()->
        SetGain(mute ? Sound::_maxAttenuation : _gain); 
}


Bvr sinSynth;

void InitializeModule_SinSynth()
{
    sinSynth = SoundBvr(NEW SinSynth());
    //XXX put this back in later... getLeafSoundList()->AddSound(sinSynth);
    // or register dynamic deleater
}

SinSynth::SinSynth(double newFreq): _sinFrequency(newFreq) {}

SoundInstance *
SinSynth::CreateSoundInstance(TimeXform tt)
{
    return NEW SinSynthSoundInstance(this, tt, _sinFrequency, _pcm);
}

#ifdef DONT_DELETE_ME_I_HAVE_SYNC_CODE_EMBEDDED_IN_ME
StreamPCMfile::~StreamPCMfile()
{
    TraceTag((tagGCMedia, "~StreamPCMfile %x - NYI", this));
    return;
    
    BufferElement *bufferElement;

    while(!bufferList.empty()) { // walk bufferList destroying everything
        bufferElement = bufferList.front();

        ASSERT(bufferElement);
        if(bufferElement) {
            if(bufferElement->GetStreamingBuffer()) {
               bufferElement->GetStreamingBuffer()->stop();
               delete bufferElement->GetStreamingBuffer();
            }

            if(bufferElement->path)
                free(bufferElement->path);

            delete bufferElement;
        }
        bufferList.pop_front();
    }

    // destroy everything created in the constructor
    if(_fileName)
       free(_fileName);

    if(_soundFile)
       delete _soundFile;
}


void StreamPCMfile::RenderAttributes(MetaSoundDevice *metaDev, 
    BufferElement *bufferElement, double rate, bool doSeek, double seek)
{
    DirectSoundDev  *dsDev = metaDev->dsDevice;

    int attenuation = linearGainToDsoundDb(metaDev->GetGain()); // do Gain
    bufferElement->GetStreamingBuffer()->setGain(attenuation);

    int pan = linearPanToDsoundDb(metaDev->GetPan());   // do Pan
    bufferElement->GetStreamingBuffer()->setPan(pan);

    int newFrequency = (int)(rate * _sampleRate);
    bufferElement->GetStreamingBuffer()->setPitchShift(newFrequency);

    dsDev->SetParams(bufferElement->path, metaDev->GetPitchShift());

    if(0)
    { // servo
    // all streamingSound::RenderSamples must update stats!
    bufferElement->GetStreamingBuffer()->updateStats();  // keep track of samples consumed

    // get the buffer's media time
    Real mediaTime = bufferElement->GetStreamingBuffer()->getMediaTime();

    // compare it to our sampling time and the instanteneous time 
    Real globalTime = GetCurrentView().GetCurrentGlobalTime();

    // time transform it as needed (guess we will need to pass tt down here)
    // XXX I will after //trango goes back online!
    Bool tt = FALSE;

    Real localTime;
    if(!tt) {
        localTime = globalTime;
    }
    else {
        // time transform the globalTime...
        localTime = globalTime;
    }

    // watch them drift
    Real diff = mediaTime - localTime;

    // servo rate to correct, or phase to jump if too great?
    }
}


bool StreamPCMfile::RenderPosition(MetaSoundDevice *metaDev, 
    BufferElement *bufferElement, double *mediaTime)
{
    // all streamingSound::RenderSamples must update stats!
    bufferElement->GetStreamingBuffer()->updateStats();  // keep track of samples consumed

    // get the buffer's media time
    *mediaTime = bufferElement->GetStreamingBuffer()->getMediaTime();

    return(TRUE); // implemented
}


void StreamPCMfile::RenderStartAtLocation(MetaSoundDevice *metaDev,
    BufferElement *bufferElement, double phase, Bool loop)
{
    DirectSoundDev  *dsDev = metaDev->dsDevice;

    long sampleOffset =
        (long)(phase * dsDev->primaryBuffer->getSampleRate());
        //(long)(phase * dsDev->primaryBuffer->getSampleRate() / pitchShift);
    sampleOffset %= _soundFile->GetFrameCount();

    _soundFile->SeekFrames(sampleOffset, SEEK_SET); 
    bufferElement->playing = TRUE;
}


void StreamPCMfile::RenderSamples(MetaSoundDevice *metaDev, 
    BufferElement *bufferElement)
{
    int framesFree;
    short buffer[100000]; // XXX set worstcase size == buffer size!

    if(framesFree = bufferElement->GetStreamingBuffer()->framesFree()) {
        int actualFramesRead; 

        // For now read, xfer samples within render 
        // (will eventualy be in another thread)
        if(actualFramesRead = _soundFile->ReadFrames(buffer, framesFree)) {
            bufferElement->GetStreamingBuffer()->writeFrames(buffer, actualFramesRead); 

            if(!bufferElement->GetStreamingBuffer()->_paused && 
               !bufferElement->GetStreamingBuffer()->isPlaying())
                // start it (XXX find better way)
                bufferElement->GetStreamingBuffer()->play(TRUE);  // start buffer looping
            }
        else { // actualFramesRead == 0 
            if(metaDev->GetLooping())
                _soundFile->SeekFrames(0, SEEK_SET); // restart the sound!
            else { // non-looping sound ending
                if(!bufferElement->GetStreamingBuffer()->_flushing)
                    bufferElement->GetStreamingBuffer()->_flushing = 1;

                // flush the dsound buffer  (XXX fix dsound!)
                // NOTE: this may/will take a number of tries waiting for the 
                //       last samples to play out!
                framesFree = bufferElement->GetStreamingBuffer()->framesFree();
                bufferElement->GetStreamingBuffer()->writeSilentFrames(framesFree);
                bufferElement->GetStreamingBuffer()->_flushing+= framesFree;

                if(bufferElement->GetStreamingBuffer()->_flushing > 
                   bufferElement->GetStreamingBuffer()->TotalFrames()) {
                    // XXX self terminate sound
                    // XXX close the buffer after it has played out
                }
            }

        }
    }

    // all streamingSound::RenderSamples must update stats!
    bufferElement->GetStreamingBuffer()->updateStats();  // keep track of samples consumed
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\dalibc\delete.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"

#if !_DEBUGMEM
extern "C" void __cdecl free( void * p );

void operator delete( void * p )
{
    free(p);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\values\sound\sound.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Specification and implementation of Sound *subclasses.

*******************************************************************************/

#include "headers.h"
#include "privinc/helpds.h"  //dsound helper routines
#include "privinc/soundi.h"
#include "privinc/snddev.h"
#include "privinc/dsdev.h"
#include "privinc/util.h"
#include "privinc/debug.h"
#include "privinc/miscpref.h"
#include "privinc/bufferl.h" // buffer element stuff
#include "backend/sndbvr.h"

#define THREADED

extern miscPrefType miscPrefs; // registry prefs struct setup in miscpref.cpp

//////////////  Silence Sound ///////////////////
class SilentSound : public Sound {
  public:
    void Render(GenericDevice&)
        { TraceTag((tagSoundRenders, "SilentSound:Render()")); }

#if _USE_PRINT
    ostream& Print(ostream& s) { return s << "silence"; }
#endif
};

Sound *silence = NULL;


//////////////  Mixed Sound  ///////////////
class MixedSound : public Sound {
  public:

    MixedSound(Sound *s1, Sound *s2) : sound1(s1), sound2(s2) {}

    void Render(GenericDevice& _dev) {
        TraceTag((tagSoundRenders, "MixedSound:Render()"));

        // Just render the two component sounds individually
        sound1->Render(_dev);
        sound2->Render(_dev);
    }

#if _USE_PRINT
    ostream& Print(ostream& s) {
        return s << "(" << sound1 << " + " << sound2 << ")";
    }
#endif

    virtual void DoKids(GCFuncObj proc) {
        (*proc)(sound1);
        (*proc)(sound2);
        Sound::DoKids(proc);
    }

  protected:
    Sound *sound1;
    Sound *sound2;
};

Sound *Mix(Sound *snd1, Sound *snd2)
{
    if (snd1 == silence) {
        return snd2;
    } else if (snd2 == silence) {
        return snd1;
    } else {
        return NEW MixedSound(snd1, snd2);
    }
}

Sound *MixArray(AxAArray *snds)
{
    snds = PackArray(snds);
    
    int numSnds = snds->Length();
    
    if (numSnds < 1) {
       RaiseException_UserError(E_FAIL, IDS_ERR_INVALIDARG);
    }

    Sound *finalSnd = (Sound *)(*snds)[numSnds-1];

    if (numSnds > 1) {
        for(int i=numSnds-2; i>=0; i--) {
            finalSnd = Mix((Sound *)(*snds)[i], finalSnd);
        }
    }
    
    return finalSnd;
}


bool LeafDirectSound::RenderAvailable(MetaSoundDevice *metaDev)
{
    return(metaDev->dsDevice->_dsoundAvailable);
}


LeafSound::~LeafSound()
{
    TraceTag((tagSoundReaper1, "LeafSound::~LeafSound sound=0x0%8X", this));
}


double fpMod(double value, double mod)
{
    double remainder;
    double tmp;
    long whole;
    double result;

    Assert(mod > 0.0);

    tmp = value / mod;
    whole = (long)tmp;
    remainder = tmp - whole;
    result = remainder * mod;

    return(result);
}

#ifdef OLD_SOUND_CODE
extern miscPrefType miscPrefs; // registry prefs struct setup in miscpref.cpp
void LeafSound::Render(GenericDevice& _dev)
{
    double localTime1 =   0.0; // this is also phase

    // XXX shouldn't renderAvailable be doing this?  ifdef and verify!
    if(_dev.GetDeviceType() != SOUND_DEVICE)
        return;  // Game over Mon...

    MetaSoundDevice *metaDev = SAFE_CAST(MetaSoundDevice *, &_dev);

    // pull buffer from bufferlist based on path if available
    AVPath path = metaDev->GetPath(); // find Buffer based on SoundPath

    Mode renderMode = _dev.GetRenderMode();
    if(renderMode==STOP_MODE) {
#if _DEBUG
#if _USE_PRINT
        if(IsTagEnabled(tagSoundPath)) {
            TraceTag((tagSoundPath, "Stopping sub-path: <%s>", 
            AVPathPrintString2(path)));
        }
#endif
#endif
        // stop and remove buffers of all leafSounds on this subtree
        // or mute them if runOnce'd 
        metaDev->_bufferListList->DeleteBufferOnSubPath(this, path);

        return; // take the afternoon off...
    }

    if(AVPathContains(path, SNAPSHOT_NODE)) // snapShot'd path?
        return; // snapshot'd sounds are silent!

    if(!RenderAvailable(metaDev)) // should we stub out?
        return;                   // return immediatly!

#if _DEBUG
#if _USE_PRINT
    // Check to avoid AVPathPrintString call
        if (IsTagEnabled(tagSoundPath)) {
            TraceTag((tagSoundPath, "LeafSound::Render path: <%s>",
                      AVPathPrintString2(path)));
        }
#endif
#endif

    BufferElement *bufferElement = 
        metaDev->_bufferListList->GetBuffer(this, path); 
    if(bufferElement && !bufferElement->_valid)
        return; // return immediately on invalid==completed buffers!

    if((renderMode==RENDER_MODE)||(renderMode==RENDER_EVENT_MODE)){
        if(!bufferElement) {
            
            // is the sound run once?
            // yup, check if it is a restarted run once'd sound and relabel
            if(AVPathContains(path, RUNONCE_NODE) &&
               metaDev->_bufferListList->FindRelabel(this, path)) {
            }
            else { // sound not a restarted runonce.  create NEW sound instance
                __try {
                    RenderNewBuffer(metaDev); // creates NEW buffer + stores on device
                }
                __except( HANDLE_ANY_DA_EXCEPTION )  {
                    TraceTag((tagError, 
                        "RenderNewBuffer exception, skipping this sound"));
                    return;  // nothing we can do skip this NEW sound, but we 
                             // should catch it so the render may continue
                }
            }
        bufferElement =  // OK, now get the one we just created...
            metaDev->_bufferListList->GetBuffer(this, path); 
        Assert(bufferElement); // we should have a valid buffer by this point!
        bufferElement->SetRunOnce(AVPathContains(path, RUNONCE_NODE));
        }
    }

    // render attributes
    if(renderMode==RENDER_MODE) {
        double      slope =   1.0;  // set defaults
        double      servo =   0.0;
        double       seek =   0.0;
          bool     doSeek = false;
          bool      newTT = false;

        //class CView; // for CView GetCurrentView();

        // compute, rate, phase, localTime based on timeTransform
          //TimeSubstitution timeTransform = metaDev->GetTimeTransform();
          TimeXform timeTransform = metaDev->GetTimeTransform();
        if(timeTransform && !timeTransform->IsShiftXform()) {
            // XXX NOTE: 1st evaluation of a TT MUST be using the current time!
            double time1 = metaDev->GetCurrentTime();
            localTime1   = EvalLocalTime(timeTransform, time1);

#ifdef DYNAMIC_PHASE
            // determine if the timeTransform changed from last time!
            double lastTTtime = bufferElement->GetLastTTtime(); // last time
            double lastTTeval = bufferElement->GetLastTTeval(); // last eval

            double currentTTeval = EvalLocalTime(timeTransform, lastTTtime);
            if(currentTTeval != lastTTeval)
                newTT = true;
#endif

            double epsilon = GetCurrentView().GetFramePeriod();
            // XXX epsilon must never be zero (would cause a zero run!)
            if(epsilon < 0.01)
                epsilon = 0.01;

            // time2 -> end of time interval (currentTime + Epsilon)
            double time2      = time1 + epsilon;
            double localTime2 = EvalLocalTime(timeTransform, time2);

#ifdef DYNAMIC_PHASE
            // time3 -> used to detect pause transition between t1 and t2!
            double time3      = time2 + epsilon;
            double localTime3 = EvalLocalTime(timeTransform, time3);

            // calculate rate == 1st derivative, slope
            if(localTime2 == localTime3)
                slope = 0; // a hack to detect pause between t1 and t2...
            else
#endif
                slope = (localTime2 - localTime1) / (time2 - time1);

#ifdef DYNAMIC_PHASE
            // cache tt information for next time
            bufferElement->SetLastTTtime(time1);
            bufferElement->SetLastTTeval(localTime1);
#endif

            TraceTag((tagSoundDebug, "slope:%f (%f,%f), (%f,%f) e:%f",
                (float)slope, 
                (float)time1, (float)localTime1,
                (float)time2, (float)localTime2, epsilon));
        }


#ifdef SYNCHONIZE_ME
#define SEEK_THREASHOLD 0.2
        //if(miscPrefs._synchronize) { // play with mediaTime
        if(0) { // play with mediaTime
            double mediaTime;

            if(RenderPosition(metaDev, &mediaTime)) { //implemented?
                // compare it to our sampling time and the instanteneous time
                double globalTime = GetCurrentView().GetCurrentGlobalTime();

                // time transform it as needed
                double localTime;
                if(timeTransform) { // time transform the globalTime...
                    localTime = TimeTransform(timeTransform, globalTime);
                }
                else {
                    localTime = globalTime;
                }

                // watch them drift
                double diff = mediaTime - localTime;

                // servo rate to correct, or phase to jump if too great?
                if(abs(diff) < SEEK_THREASHOLD)
                    servo = -0.1 * diff;  // servo to correct
                else {
                    doSeek = true;
                    seek   = localTime;   // seek to where we ought to be
                    // XXX but what is an appropriate slope?
                    //    (calculated, last, or unit slope?)
                    slope  = 1.0;
                }
#ifdef _DEBUG
                printf("d:%f, s:%f seek:%f\n", diff, servo, seek);
#endif
            }
        }
#endif



        // seek as needed and play at rate slope and attributes on the devContext
        double rate =  slope + servo;
            seek = localTime1;
            doSeek = newTT;

    #ifdef DYNAMIC_PHASE
            // are we seeking off the end of a non-looped sound?
            if(doSeek) {
                double soundLength = GetLength();

                if(metaDev->GetLooping()){
                    seek = fpMod(seek, soundLength);
                }
                else { // not looped
                    // XXX actually if you seek off the front of a non-looped sound
                    //     we really should wait to play it a while...
                    if((seek < 0.0) || (seek >= soundLength)) {
                        // we seeked off the end of the sound
                        metaDev->_bufferListList->RemoveBuffer(this, path); 
                        return; // take the afternoon off...
                    }
                }
            }
    #endif

            rate = fsaturate(0.0, rate, rate); // elliminate non-negative rates!
            RenderAttributes(metaDev, bufferElement, rate, doSeek, seek);
            bufferElement->SetIntendToMute(false);
        }

        if (renderMode==MUTE_MODE) 
            RenderSetMute(metaDev, bufferElement);

        //determine if instantiation should be started, or if it has ended
        if ((renderMode==RENDER_MODE)||
            (renderMode==RENDER_EVENT_MODE)||
            (renderMode==MUTE_MODE)) {
            if(!bufferElement->_playing) { // evaluate starting the buffer
                double currentTime;

                if(bufferElement->SyncStart()) { 
                    DWORD lastTimeStamp, currentTimeStamp;
                    Time foo = 
                       ViewLastSampledTime(lastTimeStamp, currentTimeStamp);
                    DWORD currentSystemTime = GetPerfTickCount();
                    double delta = Tick2Sec(currentSystemTime - currentTimeStamp);
                    currentTime = delta + metaDev->GetCurrentTime();
                }
                else 
                    currentTime = metaDev->GetCurrentTime();  // sample time

                //TimeSubstitution timeTransform = metaDev->GetTimeTransform();
                TimeXform timeTransform = metaDev->GetTimeTransform();
                double localTime = (timeTransform) ? 
                    EvalLocalTime(timeTransform, currentTime) :
                    currentTime;

                if(metaDev->GetLooping()){
                    // looping start now at a phased location
                    RenderStartAtLocation(metaDev, bufferElement, localTime, 
                                          metaDev->GetLooping());
                }
                else {  // not looping -> potentialy delay start for the future
                    if(localTime >  GetLength()) {
                        // sound has already completed
                        bufferElement->_playing = TRUE;
                    }
                    else if(localTime >= 0.0) {
                        DWORD beforeTime, afterTime, deltaTime;
                        beforeTime = GetPerfTickCount();

                        // not looping, start at beggining after proper delay
                        RenderStartAtLocation(metaDev, bufferElement, localTime,
                                                  metaDev->GetLooping());

                        afterTime = GetPerfTickC