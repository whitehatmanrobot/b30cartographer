			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K1_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K2_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K2_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 4			       ;; number of entries
   DB	 41,"'"                        ;; '
   DB	 12,"+"                        ;; +
   DB	 43,"<"                        ;; <
   DB	 53,"-"                        ;; -
COM_NA_LO_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K2_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K3_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K3_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 4			       ;; number of entries
   DB	 12,"+"                        ;; +
   DB	 41,"<"                        ;; <
   DB	 43,"'"                        ;; '
   DB	 53,"-"                        ;; -
COM_NA_LO_K3_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K3_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G + P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K1_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 12			       ;; number of entries
   DB	  3,'"'                        ;;
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 43,'*'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
   DB	 86,'>'                        ;;
COM_NA_UP_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K1_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K2_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 XT_KB			     ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K2_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 13			       ;; number of entries
   DB	  3,'"'                        ;;
   DB	  4,''                        ;;
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
   DB	 41,'*'                        ;;
   DB	 43,'>'                        ;;
COM_NA_UP_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K2_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K3_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K3_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 13			       ;; number of entries
   DB	  3,'"'                        ;;
   DB	  4,''                        ;;
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
   DB	 41,'>'                        ;;
   DB	 43,'*'                        ;;
COM_NA_UP_K3_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K3_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type FERRARI
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 7			       ;; number of entries
   DB	  3,'@'                        ;;
   DB	  4,09CH		       ;; 
   DB	  5,'$'                        ;;
   DB	  8,'{'                        ;;
   DB	  9,'['                        ;;
   DB	 10,']'                        ;;
   DB	 11,'}'                        ;;
COM_THIRD_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift (ALTERNATE)
;; KEYBOARD TYPES: XT,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K1_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 9			       ;; number of entries
   DB	 12,'-','-'                    ;;
   DB	 13,'=','='                    ;;
   DB	 26,'[','['                    ;;
   DB	 27,']',']'                    ;;
   DB	 39,';',';'                    ;;
   DB	 40,027H,027H		       ;;
   DB	 41,060H,060H		       ;;
   DB	 43,'\','\'                    ;;
   DB	 53,'/','/'                    ;;
COM_THIRD_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift (ALTERNATE)
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K2_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K2_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 9			       ;; number of entries
   DB	 12,'-','-'                    ;;
   DB	 13,'=','='                    ;;
   DB	 26,'[','['                    ;;
   DB	 27,']',']'                    ;;
   DB	 39,';',';'                    ;;
   DB	 40,027H,027H		       ;;
   DB	 41,'\','\'                    ;;
   DB	 43,060H,060H		       ;;
   DB	 53,'/','/'                    ;;
COM_THIRD_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K2_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Fourth Shift (ALTERNATE+SHIFT)
;; KEYBOARD TYPES: XT,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_FOURTH_END-$	       ;; length of state section
   DB	 FOURTH_SHIFT		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_FOURTH_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 18			       ;; number of entries
   DB	  3,'@','@'                    ;;
   DB	  4,'#','#'                    ;;
   DB	  7,'^','^'                    ;;
   DB	  8,'&','&'                    ;;
   DB	  9,'*','*'                    ;;
   DB	 10,'(','('                    ;;
   DB	 11,')',')'                    ;;
   DB	 12,'_','_'                    ;;
   DB	 13,'+','+'                    ;;
   DB	 26,'{','{'                    ;;
   DB	 27,'}','}'                    ;;
   DB	 39,':',':'                    ;;
   DB	 40,'"','"'                    ;;
   DB	 41,'~','~'                    ;;
   DB	 43,'|','|'                    ;;
   DB	 51,'<','<'                    ;;
   DB	 52,'>','>'                    ;;
   DB	 53,'?','?'                    ;;
COM_FOURTH_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_FOURTH_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Fourth Shift (ALTERNATE+SHIFT)
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_FOURTH_K1_END-$	       ;; length of state section
   DB	 FOURTH_SHIFT		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_FOURTH_K1_T1_END-$        ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 18			       ;; number of entries
   DB	  3,'@','@'                    ;;
   DB	  4,'#','#'                    ;;
   DB	  7,'^','^'                    ;;
   DB	  8,'&','&'                    ;;
   DB	  9,'*','*'                    ;;
   DB	 10,'(','('                    ;;
   DB	 11,')',')'                    ;;
   DB	 12,'_','_'                    ;;
   DB	 13,'+','+'                    ;;
   DB	 26,'{','{'                    ;;
   DB	 27,'}','}'                    ;;
   DB	 39,':',':'                    ;;
   DB	 40,'"','"'                    ;;
   DB	 41,'|','|'                    ;;
   DB	 43,'~','~'                    ;;
   DB	 51,'<','<'                    ;;
   DB	 52,'>','>'                    ;;
   DB	 53,'?','?'                    ;;
COM_FOURTH_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_FOURTH_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_LO_END-$	       ;; length of state section
   DB	 GRAVE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
COM_GR_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_LO_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_SP_END-$	       ;; length of state section
   DB	 GRAVE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,96			       ;; STANDALONE GRAVE
COM_GR_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_LO_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_LOWER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
COM_CI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CI_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_SP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_SPACE	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,94			       ;; STANDALONE CIRCUMFLEX
COM_CI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Lower
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  COM_TI_LO_END-$		;; length of state section
    DB	  TILDE_LOWER			;; State ID
    DW	  G_KB+P12_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  COM_TI_LO_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  1				;; number of scans
    DB	  49,0A4H			;; scan code,ASCII - 
 COM_TI_LO_T1_END:			;;
					;;
    DW	  0				;;
					;;
 COM_TI_LO_END: 			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: Common
;;; STATE: Tilde Upper Case
;;; KEYBOARD TYPES: G, P12
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  COM_TI_UP_END-$		;; length of state section
    DB	  TILDE_UPPER			;; State ID
    DW	  G_KB+P12_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  COM_TI_UP_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  1				;; number of scans
    DB	  49,0A5H			;; scan code,ASCII - 
 COM_TI_UP_T1_END:			;;
					;;
    DW	  0				;; Size of xlat table - null table
					;;
 COM_TI_UP_END: 			;; length of state section
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Space Bar
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_TI_SP_END-$	       ;; length of state section
   DB	 TILDE_SPACE		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 07EH,0 		       ;; error character = standalone accent
				       ;;
   DW	 COM_TI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,07EH		       ;; STANDALONE TILDE
COM_TI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_TI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; Last State
COMMON_XLAT_END:		       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; NO Specific Translate Section for 865
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC NO_865_XLAT		       ;;
NO_865_XLAT:			       ;;
				       ;;
   DW	  CP865_XLAT_END-$	       ;; length of section
   DW	  865			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 865
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP865_NA_K1_UP_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP865_NA_UP_K1_T1_END-$       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	  5,0AFH		       ;; INTERNATIONAL MONEY SYMB
   DB	 41,015H		       ;; SECTION Symb
CP865_NA_UP_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP865_NA_K1_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 865
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP865_AC_LO_END-$		 ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP865_AC_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP865_AC_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP865_AC_LO_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 865
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP865_AC_UP_END-$		 ;; length of state section
   DB	 ACUTE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP865_AC_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 18,''                        ;; scan code,ASCII - 
CP865_AC_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP865_AC_UP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 865
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP865_AC_SP_END-$		 ;; length of state section
   DB	 ACUTE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP865_AC_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,39			       ;; scan code,ASCII - SPACE
CP865_AC_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP865_AC_SP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP865
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP865_DI_LO_END-$		 ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 254,0			       ;; error character = standalone accent
				       ;;
   DW	 CP865_DI_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 21,''                        ;; scan code,ASCII - y
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP865_DI_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP865_DI_LO_END:			 ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP865
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP865_DI_UP_END-$		 ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 254,0			       ;; error character = standalone accent
				       ;;
   DW	 CP865_DI_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 22,''                        ;; scan code,ASCII - U
   DB	 24,''                        ;; scan code,ASCII - O
   DB	 30,''                        ;; scan code,ASCII - A
CP865_DI_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP865_DI_UP_END:			 ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 865
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				       ;;
;  DW	 CP865_DI_SP_END-$		 ;; length of state section
;  DB	 DIARESIS_SPACE 	       ;; State ID
;  DW	 ANY_KB 		       ;; Keyboard Type
;  DB	 254,0			       ;; error character = standalone accent
;				       ;;
;  DW	 CP865_DI_SP_T1_END-$		 ;; Size of xlat table
;  DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;  DB	 1			       ;; number of scans
;  DB	 57,254 		       ;; error character = standalone accent
;CP865_DI_SP_T1_END:			 ;;
;				       ;;
;  DW	 0			       ;; Size of xlat table - null table
;CP865_DI_SP_END:			 ;; length of state section
;				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	  0			       ;; LAST STATE
				       ;;
CP865_XLAT_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; NO Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC NO_850_XLAT		       ;;
NO_850_XLAT:			       ;;
				       ;;
   DW	  CP850_XLAT_END-$	       ;; length of section
   DW	  850			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_K1_UP_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_NA_UP_K1_T1_END-$       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	  5,0CFH		       ;; INT MONEY SYMB
   DB	 41,0F5H		       ;; SECTION Symb
CP850_NA_UP_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_K1_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_LO_END-$		 ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 239,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 21,0ECH		       ;; y acute
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP850_AC_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_LO_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_UP_END-$		 ;; length of state section
   DB	 ACUTE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 239,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of entries
   DB	 18,090H		       ;;    E acute
   DB	 21,0EDH		       ;;    Y acute
   DB	 22,0E9H		       ;;    U acute
   DB	 23,0D6H		       ;;    I acute
   DB	 24,0E0H		       ;;    O acute
   DB	 30,0B5H		       ;;    A acute
CP850_AC_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_UP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_SP_END-$		 ;; length of state section
   DB	 ACUTE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 239,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,239 		       ;; scan code,ASCII - SPACE
CP850_AC_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_SP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_LO_END-$		 ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 21,''                        ;; scan code,ASCII - y
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP850_DI_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_LO_END:			 ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_UP_END-$		 ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,0D3H		       ;;    E Diaeresis
   DB	 22,''                        ;;    U Diaeresis
   DB	 23,0D8H		       ;;    I Diaeresis
   DB	 24,''                        ;;    O Diaeresis
   DB	 30,''                        ;;    A Diaeresis
CP850_DI_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_UP_END:			 ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_SP_END-$		 ;; length of state section
   DB	 DIARESIS_SPACE 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,249 		       ;; error character = standalone accent
CP850_DI_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
CP850_DI_SP_END:			 ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Grave Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_GR_UP_END-$	       ;; length of state section
   DB	 GRAVE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_GR_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,0D4H		       ;;    E grave
   DB	 22,0EBH		       ;;    U grave
   DB	 23,0DEH		       ;;    I grave
   DB	 24,0E3H		       ;;    O grave
   DB	 30,0B7H		       ;;    A grave
CP850_GR_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_GR_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Tilde Lower
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  CP850_TI_LO_END-$		;; length of state section
    DB	  TILDE_LOWER			;; State ID
    DW	  G_KB+P12_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  CP850_TI_LO_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  2				;; number of scans
    DB	  24,0E4H			;; scan code,ASCII - o tilde
    DB	  30,0C6H			;; scan code,ASCII - a tilde
 CP850_TI_LO_T1_END:			;;
					;;
    DW	  0				;;
					;;
 CP850_TI_LO_END:			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: 850
;;; STATE: Tilde Upper Case
;; KEYBOARD TYPES: G, P12
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  CP850_TI_UP_END-$		;; length of state section
    DB	  TILDE_UPPER			;; State ID
    DW	  G_KB+P12_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  CP850_TI_UP_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  2				;; number of scans
    DB	  24,0E5H			;; scan code,ASCII - O tilde
    DB	  30,0C7H			;; scan code,ASCII - A tilde
 CP850_TI_UP_T1_END:			;;
					;;
    DW	  0				;; Size of xlat table - null table
					;;
 CP850_TI_UP_END:			;; length of state section
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Circumflex Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_CI_UP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_UPPER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_CI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,0D2H		       ;;    E circumflex
   DB	 22,0EAH		       ;;    U circumflex
   DB	 23,0D7H		       ;;    I circumflex
   DB	 24,0E2H		       ;;    O circumflex
   DB	 30,0B6H		       ;;    A circumflex
CP850_CI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_CI_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 0			       ;; LAST STATE
				       ;;
CP850_XLAT_END: 		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CODE	 ENDS			       ;;
	 END			       ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kbd2\kdfnl.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;; LATEST CHANGE ALT & CTL

	PAGE	,132
	TITLE	MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Defintion File
;;
;; This file contains the keyboard tables for Netherlands
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;;
;; Modded from Belgian - DTF 20-Aug-86; 08-Sep-86
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC	       ;;
	INCLUDE POSTEQU.INC	       ;;
	INCLUDE KEYBMAC.INC	       ;;
				       ;;
	PUBLIC NL_LOGIC 	       ;;
	PUBLIC NL_437_XLAT	       ;;
	PUBLIC NL_850_XLAT	       ;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a liner search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE	    EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; NL State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
NL_LOGIC:

   DW  LOGIC_END-$		       ;; length
				       ;;
   DW  0			       ;; special features
				       ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND 	       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 IFF EITHER_CTL,NOT		       ;;
    IFF EITHER_ALT,NOT		       ;;
      IFF EITHER_SHIFT		       ;;
	  SET_FLAG DEAD_UPPER	       ;;
      ELSEF			       ;;
	  SET_FLAG DEAD_LOWER	       ;;
      ENDIFF			       ;;
    ELSEF			       ;;
      IFKBD G_KB+P12_KB 	       ;; For ENHANCED keyboard some
      ANDF R_ALT_SHIFT		       ;;  dead keys are on third shift
      ANDF EITHER_SHIFT,NOT	       ;;   which is accessed via the altgr key
	 SET_FLAG DEAD_THIRD	       ;;
      ENDIFF			       ;;
    ENDIFF			       ;;
 ENDIFF 			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:			       ;;
				       ;;
   IFF ACUTE,NOT		       ;;
      GOTO CEDILLA_PROC 	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ACUTE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_ACUTE:			       ;;
      PUT_ERROR_CHAR ACUTE_SPACE       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      GOTO NON_DEAD		       ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CEDILLA ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CEDILLA_PROC:			       ;;
				       ;;
   IFF CEDILLA,NOT		       ;;
      GOTO TILDE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CEDILLA_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT CEDILLA_LOWER     ;;
	    ELSEF		       ;;
	       XLATT CEDILLA_UPPER     ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT CEDILLA_UPPER     ;;
	    ELSEF		       ;;
	       XLATT CEDILLA_LOWER     ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CEDILLA:		       ;;
      PUT_ERROR_CHAR CEDILLA_SPACE     ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      GOTO NON_DEAD		       ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TILDE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
TILDE_PROC:			       ;;
				       ;;
   IFF TILDE,NOT		       ;;
      GOTO DIARESIS_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT TILDE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT TILDE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT TILDE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT TILDE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT TILDE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_TILDE:			       ;;
      PUT_ERROR_CHAR TILDE_SPACE       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:			       ;;
				       ;;
   IFF DIARESIS,NOT		       ;;
      GOTO GRAVE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT DIARESIS_SPACE	       ;;  exist for 437 so beep for
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_DIARESIS:		       ;;
      PUT_ERROR_CHAR DIARESIS_SPACE    ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:			       ;;
				       ;;
   IFF GRAVE,NOT		       ;;
      GOTO CIRCUMFLEX_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT GRAVE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_GRAVE:			       ;;
      PUT_ERROR_CHAR GRAVE_SPACE       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:		       ;;
				       ;;
   IFF CIRCUMFLEX,NOT		       ;;
      GOTO NON_DEAD		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CIRCUMFLEX:		       ;;
      PUT_ERROR_CHAR CIRCUMFLEX_SPACE  ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NON_DEAD:			       ;;
				       ;;
   IFKBD G_KB+P12_KB		       ;; Avoid accidentally translating
   ANDF LC_E0			       ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC		       ;;   G keyboard
   ENDIFF			       ;;
				       ;;
;;***BD ADDED FOR ALT, CTRL CASES      ;;
;;***MJS Added because of diferences   ;;
;;between KYB Types		       ;;
				       ;;
 IFKBD AT_KB+XT_KB		 ;;
      IFF EITHER_CTL,NOT	       ;;
	 IFF ALT_SHIFT		       ;; ALT - case
	    XLATT ALT_CASE	       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF EITHER_ALT,NOT	       ;; CTRL - case
	    XLATT CTRL_CASE	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
 ENDIFF 			       ;;
				       ;;
;;***MJS repeated for G, P12	       ;;
 IFKBD G_KB+P12_KB		       ;;
      IFF EITHER_CTL,NOT	       ;;
	ANDF ALT_SHIFT		       ;;
	ANDF R_ALT_SHIFT,NOT	       ;;
	    XLATT ALT_CASE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL		       ;;
	ANDF ALT_SHIFT		       ;; ALT - case
	ANDF R_ALT_SHIFT,NOT	       ;;
	    XLATT ALT_CASE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL		       ;;
	ANDF EITHER_ALT,NOT	       ;; CTRL - case
	    XLATT CTRL_CASE	       ;;
      ENDIFF			       ;;
 ENDIFF 			       ;;
;;***BD END OF ADDITION
 IFF  EITHER_CTL,NOT		       ;; Lower and upper case.  Alphabetic
    IFF EITHER_ALT,NOT		       ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT		       ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE,NOT	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_UPPER        ;;
	  IFF CAPS_STATE	       ;;
	      XLATT ALPHA_LOWER        ;;
	  ELSEF 		       ;;
	      XLATT ALPHA_UPPER        ;;
	  ENDIFF		       ;;
      ELSEF			       ;;
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE 	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_LOWER        ;;
	  IFF CAPS_STATE	       ;;
	     XLATT ALPHA_UPPER	       ;;
	  ELSEF 		       ;;
	     XLATT ALPHA_LOWER	       ;;
	  ENDIFF		       ;;
      ENDIFF			       ;; Third and Fourth shifts
    ELSEF			       ;; ctl off, alt on at this point
      IFKBD XT_KB+AT_KB 	 ;; XT, AT,  keyboards. Nordics
	 IFF EITHER_SHIFT	       ;; only.
	    XLATT FOURTH_SHIFT	       ;; ALT + shift
	 ELSEF			       ;;
	    XLATT THIRD_SHIFT	       ;; ALT
	 ENDIFF 		       ;;
      ELSEF			       ;; ENHANCED keyboard
	 IFF R_ALT_SHIFT	       ;; ALTGr
	 ANDF EITHER_SHIFT,NOT	       ;;
	    XLATT THIRD_SHIFT	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
    ENDIFF			       ;;
 ENDIFF 			       ;;
				       ;;
 EXIT_STATE_LOGIC		       ;;
				       ;;
LOGIC_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; NL Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC NL_COMMON_XLAT		       ;;
NL_COMMON_XLAT: 		       ;;
				       ;;
   DW	 COMMON_XLAT_END-$	       ;; length of section
   DW	 -1			       ;; code page
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Lower Shift Dead Key
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_LO_END-$	       ;; length of state section
   DB	 DEAD_LOWER		       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 26			       ;; scan code
   FLAG  DIARESIS		       ;; flag bit to set
   DB	 40			       ;;
   FLAG  ACUTE			       ;;
				       ;;
				       ;;
COM_DK_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Upper Shift Dead Key
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_UP_END-$	       ;; length of state section
   DB	 DEAD_UPPER		       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 3			       ;; number of entries
   DB	 26			       ;; scan code
   FLAG  CIRCUMFLEX		       ;; flag bit to set
   DB	 40			       ;;
   FLAG  GRAVE			       ;;
   DB	 13			       ;;
   FLAG  TILDE			       ;;
				       ;;
COM_DK_UP_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift Dead Key
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_TH_END-$	       ;; length of state section
   DB	 DEAD_THIRD		       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 1			       ;; number of entries
   DB	13			       ;;
   FLAG CEDILLA 		       ;;
				       ;;
COM_DK_TH_END:			       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
;  DW	 COM_AL_LO_END-$	       ;; length of state section
;  DB	 ALPHA_LOWER		       ;; State ID
;  DW	 G_KB + P12_KB		       ;; Keyboard Type
;  DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
;  DW	 COM_AL_LO_T1_END-$	       ;; Size of xlat table
;  DB	 STANDARD_TABLE 	       ;; xlat options:
;  DB	 0			       ;; number of entries
;COM_AL_LO_T1_END:		       ;;
				       ;;
;  DW	 0			       ;; Size of xlat table - null table
				       ;;
;COM_AL_LO_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				       ;;
;  DW	 COM_AL_UP_END-$	       ;; length of state section
;  DB	 ALPHA_UPPER		       ;; State ID
;  DW	 G_KB + P12_KB		       ;; Keyboard Type
;  DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
;  DW	 COM_AL_UP_T1_END-$	       ;; Size of xlat table
;  DB	 STANDARD_TABLE 	       ;; xlat options:
;  DB	 0			       ;; number of entries
;COM_AL_UP_T1_END:		       ;;
;				       ;;
;  DW	 0			       ;; Size of xlat table - null table
				       ;;
;COM_AL_UP_END: 		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 10			       ;; number of entries
   DB	 41,"@"                        ;; at sign
   DB	 12,"/"                        ;;
   DB	 13,0F8H		       ;;
   DB	 27,"*"                        ;;
   DB	 39,'+'                        ;;
   DB	 43,'<'                        ;;
   DB	 51,','                        ;;
   DB	 52,'.'                        ;;
   DB	 53,'-'                        ;;
   DB	 86,']'
COM_NA_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 17			       ;; number of entries
   DB	  2,'!'                        ;;
   DB	  3,'"'                        ;;
   DB	  4,'#'                        ;;
   DB	  5,'$'                        ;;
   DB	  6,'%'                        ;;
   DB	  7,'&'                        ;;
   DB	  8,'_'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,"'"                        ;;
   DB	 12,'?'                        ;;
   DB	 39,0F1H		       ;;
   DB	 43,'>'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'='                        ;;
   DB	 86,'['
COM_NA_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 16			       ;; number of entries
   DB	 41,0AAH		       ;;
   DB	  2,0FBH		       ;;
   DB	  3,0FDH		       ;;
   DB	  4,0FCH		       ;;
   DB	  5,0ACH		       ;;
   DB	  6,0ABH		       ;;
   DB	  7,0F3H		       ;;
   DB	  8,9CH 		       ;;
   DB	  9,'{'                        ;;
   DB	 10,'}'                        ;;
   DB	 12,5CH 		       ;;
   DB	 31,0E1H		       ;;
   DB	 44,0AEH		       ;;
   DB	 45,0AFH		       ;;
;  DB	 46,9BH 		       ;; special case
   DB	 50,0E6H		       ;; mu character
   DB	 52,0FAH		       ;;
COM_THIRD_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_END:			       ;;
				       ;;
;;******************************
;;***BD - ADDED FOR NUMERIC PAD (DECIMAL SEPERATOR)
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Numeric Key Pad
;; KEYBOARD TYPES : G_KB (P12 change does not apply)
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_PAD_K1_END-$	       ;; length of state section
   DB	 NUMERIC_PAD		       ;; State ID
   DW	 G_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_PAD_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 83,','                        ;; decimal seperator = ,
COM_PAD_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_PAD_K1_END: 		       ;;
				       ;;
;;******************************
;;***BD - ADDED FOR ALT CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K1_END-$	       ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_ALT_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 0			       ;; 2 number of entries
;   DB	  12,-1,-1		;;
;   DB	  53,0,82H			;;
COM_ALT_K1_T1_END:		       ;;
					;;
    DW	  0				;; Size of xlat table - null table
				       ;;
COM_ALT_K1_END: 		       ;;
					;;
;;******************************
;;***BD - ADDED FOR CTRL CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K1_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_CTRL_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 5			       ;; number of entries
   DB	 12,-1,-1		       ;;
   DB	 26,-1,-1		       ;;
   DB	 27,-1,-1		       ;;
   DB	 43,-1,-1		       ;;
   DB	 53,01FH,35h		       ;;
COM_CTRL_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CTRL_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Lower
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 COM_GR_LO_END-$		 ;; length of state section
   DB	 GRAVE_LOWER			 ;; State ID
   DW	 G_KB + P12_KB			 ;; Keyboard Type
   DB	 60H,0				 ;; error character = standalone accent
					 ;;
   DW	 COM_GR_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 5				 ;; number of scans
   DB	 18,''                          ;; scan code,ASCII - e
   DB	 30,''                          ;; scan code,ASCII - a
   DB	 24,''                          ;; scan code,ASCII - o
   DB	 22,''                          ;; scan code,ASCII - u
   DB	 23,''                          ;; scan code,ASCII - i
COM_GR_LO_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
COM_GR_LO_END:				 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Upper Case
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_UP_END-$	       ;; length of state section
   DB	 GRAVE_UPPER		       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 60H,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 0			       ;; number of scans
COM_GR_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_UP_END:			       ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Space Bar
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 COM_GR_SP_END-$		 ;; length of state section
   DB	 GRAVE_SPACE			 ;; State ID
   DW	 G_KB + P12_KB			 ;; Keyboard Type
   DB	 60H,0				 ;; error character = standalone accent
					 ;;
   DW	 COM_GR_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 1				 ;; number of scans
   DB	 57,60H 			 ;; STANDALONE GRAVE
COM_GR_SP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
COM_GR_SP_END:				 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_LO_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_LOWER	       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 5EH,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 30,''                        ;; scan code,ASCII - a
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
COM_CI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CI_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Upper
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_UP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_UPPER	       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 5EH,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 0			       ;; number of scans
COM_CI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CI_UP_END:			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_SP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_SPACE	       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 5EH,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,5EH 		       ;; STANDALONE CIRCUMFLEX
COM_CI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Space Bar
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 COM_TI_SP_END-$		 ;; length of state section
   DB	 TILDE_SPACE			 ;; State ID
   DW	 G_KB + P12_KB			 ;; Keyboard Type
   DB	 7EH,0				 ;; error character = standalone accent
					 ;;
   DW	 COM_TI_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 1				 ;; number of scans
   DB	 57,7EH 			 ;; STANDALONE TIDLE
COM_TI_SP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
COM_TI_SP_END:				 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Cedilla lower
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 COM_CE_LO_END-$		 ;; length of state section
   DB	 CEDILLA_LOWER			 ;; State ID
   DW	 G_KB + P12_KB			 ;; Keyboard Type
   DB	 0F7H,0 			 ;; error character = standalone accent
					 ;; CHNAGED MJS 31/10/86
   DW	 COM_CE_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 1				 ;; number of scans
   DB	 46,135 			 ;; scan code,ASCII - c
COM_CE_LO_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
COM_CE_LO_END:			 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: CedilIa Upper Case
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CE_UP_END-$	       ;; length of state section
   DB	 CEDILLA_UPPER		       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 0F7H,0 		       ;; error character = standalone accent
				       ;; CHANGED MJS 31/10/86
   DW	 COM_CE_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 46,128 		       ;; scan code,ASCII - C
COM_CE_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CE_UP_END:		       ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Cedilla Space Bar
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 COM_CE_SP_END-$		 ;; length of state section
   DB	 CEDILLA_SPACE			 ;; State ID
   DW	 G_KB + P12_KB			 ;; Keyboard Type
   DB	 0F7H,0 			 ;; error character = standalone accent
					 ;; CHANGED MJS 31/10/86
   DW	 COM_CE_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 1				 ;; number of scans
   DB	 57,0F7H			 ;; STANDALONE CEDILLA
COM_CE_SP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
COM_CE_SP_END:			 ;; length of state section
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DI_LO_END-$	       ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 0F9H,0 		       ;; error character = standalone accent
				       ;; CHANGED MJS 31/10/86
   DW	 COM_DI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 30,''                        ;; scan code,ASCII - a
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 21,''                        ;; scan code,ASCII - y
COM_DI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_DI_LO_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DI_SP_END-$	       ;; length of state section
   DB	 DIARESIS_SPACE 	       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 0F9H,0 		       ;; error character = standalone accent
				       ;; CHANGED MJS 31/10/86
   DW	 COM_DI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,0F9H		       ;; error character = standalone accent
COM_DI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
COM_DI_SP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; Last State
COMMON_XLAT_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; NL Specific Translate Section for 437
;;
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC NL_437_XLAT		       ;;
NL_437_XLAT:			       ;;
				       ;;
   DW	  CP437_XLAT_END-$	       ;; length of section
   DW	  437			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Third Shift
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_THIRD_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP437_THIRD_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 3			       ;; number of scans
;; DB	 2,7			       ;; NO CHAR - JUST BELL  should be super 1
;;				       ;; NOW COMM. MJS 31/10/86
;; DB	 7,0FCH 		       ;; NOW COMM. MJS 31/10/86
   DB	19,14H			       ;; NO CHAR - JUST BELL
;;				       ;; SHOULD O/P MJS 31/10/86
   DB	 46,9BH 		       ;; cent sign - 
   DB	 86,7CH 		       ;; vertical bar
				       ;;
CP437_THIRD_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_THIRD_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
;  DW	 CP437_NA_LO_END-$	       ;; length of state section
;  DB	 NON_ALPHA_LOWER	       ;; State ID
;  DW	 G_KB + P12_KB		       ;; Keyboard Type
;  DB	 -1,-1			       ;; default ignore error state
				       ;;
;  DW	 CP437_NA_LO_T1_END-$	       ;; Size of xlat table
;  DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;  DB	 0			       ;; number of scans
;CP437_NA_LO_T1_END:		       ;;
				       ;;
;  DW	 0			       ;; Size of xlat table - null table
				       ;;
;CP437_NA_LO_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_NA_UP_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP437_NA_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of scans
   DB	27,0B3H 		       ;; vert. line graphics
   DB	41,15H			       ;; Section symbol
CP437_NA_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_NA_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Tilde Lower
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP437_TI_LO_END-$		 ;; length of state section
   DB	 TILDE_LOWER			 ;; State ID
   DW	 G_KB + P12_KB			 ;; Keyboard Type
   DB	 7EH,0				 ;; error character = standalone accent
					 ;;
   DW	 CP437_TI_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 1				 ;; number of scans
   DB	 49,164 			 ;; scan code,ASCII - n
CP437_TI_LO_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP437_TI_LO_END:			 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Tilde Upper Case
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_TI_UP_END-$	       ;; length of state section
   DB	 TILDE_UPPER		       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 7EH,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_TI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 49,165 		       ;; scan code,ASCII - N
CP437_TI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_TI_UP_END:		       ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Acute Lower Case
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_AC_LO_END-$	       ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 027H,0 		       ;; error character = standalone accent
				       ;; CHANGED MJS 31/10/86
   DW	 CP437_AC_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 30,''                        ;; a acute
   DB	 18,''                        ;; e acute
   DB	 23,''                        ;; i acute
   DB	 24,''                        ;; o acute
   DB	 22,''                        ;; u acute
CP437_AC_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_AC_LO_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Acute Upper Case
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP437_AC_UP_END-$		 ;; length of state section
   DB	 ACUTE_UPPER			 ;; State ID
   DW	 G_KB + P12_KB			 ;; Keyboard Type
   DB	 027H,0 			 ;; error character = standalone accent
					 ;; CHANGED MJS 31/10/86
   DW	 CP437_AC_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 1				 ;; number of scans
   DB	 18,''                          ;; scan code,ASCII - e
CP437_AC_UP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP437_AC_UP_END:			 ;;
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Acute Space Bar
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP437_AC_SP_END-$		 ;; length of state section
   DB	 ACUTE_SPACE			 ;; State ID
   DW	 G_KB + P12_KB			 ;; Keyboard Type
   DB	 027H,0 			 ;; error character = standalone accent
					 ;; CHANGED MJS 34/10/86
   DW	 CP437_AC_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 1				 ;; number of scans
   DB	 57,027H			 ;; scan code,ASCII - SPACE
CP437_AC_SP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP437_AC_SP_END:			 ;;
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_DI_UP_END-$	       ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 0F9H,0 		       ;; error character = standalone accent
				       ;;
   DW	 CP437_DI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 30,''                        ;; scan code,ASCII - a
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
CP437_DI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_DI_UP_END:		       ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	  0			       ;; LAST STATE
				       ;;
CP437_XLAT_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; NL Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC NL_850_XLAT		       ;;
NL_850_XLAT:			       ;;
				       ;;
   DW	  CP850_XLAT_END-$	       ;; length of section
   DW	  850			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_UP_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP850_NA_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of scans
   DB	27,07CH 		       ;; vert line
   DB	41,0F5H 		       ;; section symbol
CP850_NA_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Third Shift
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_THIRD_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP850_THIRD_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 3			       ;; number of scans
;; DB	 2,0FBH 		       ;; NOW COMM. MJS 31/10/86
;; DB	 7,0F3H 		       ;; NOW COMM. MJS 31/10/86
   DB	19,0F4H 		       ;;
   DB	46,0BDH 		       ;; cent sign - 
   DB	86,0DDH 		       ;; true broken vertical
CP850_THIRD_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_THIRD_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Tilde Lower
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP850_TI_LO_END-$		 ;; length of state section
   DB	 TILDE_LOWER			 ;; State ID
   DW	 G_KB + P12_KB			 ;; Keyboard Type
   DB	 7EH,0				 ;; error character = standalone accent
					 ;;
   DW	 CP850_TI_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 3				 ;; number of scans
   DB	 30,0C6H			 ;; scan code,ASCII - a
   DB	 24,0E4H			 ;; scan code,ASCII - o
   DB	 49,164 			 ;; scan code,ASCII - n
CP850_TI_LO_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP850_TI_LO_END:			 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Tilde Upper Case
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_TI_UP_END-$	       ;; length of state section
   DB	 TILDE_UPPER		       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 7EH,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_TI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 30,0C7H		       ;; scan code,ASCII - A
   DB	 24,0E5H		       ;; scan code,ASCII - O
   DB	 49,165 		       ;; scan code,ASCII - N
CP850_TI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_TI_UP_END:		       ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850 - NOW IN COMMON MJS 31/10/86
;; STATE: Cedilla lower
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850 - NOW IN COMMON MJS 31/10/86
;; STATE: CedilIa Upper Case
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850 - NOW IN COMMON MJS 31/10/86
;; STATE: Cedilla Space Bar
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Acute Lower Case
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_LO_END-$	       ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 0EFH,0 		       ;; error character = standalone accent
   DW	 CP850_AC_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 30,''                        ;; a acute
   DB	 18,''                        ;; e acute
   DB	 23,''                        ;; i acute
   DB	 24,''                        ;; o acute
   DB	 22,''                        ;; u acute
   DB	 21,0ECH	       ;; y acute
CP850_AC_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_LO_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Acute Upper Case
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP850_AC_UP_END-$		 ;; length of state section
   DB	 ACUTE_UPPER			 ;; State ID
   DW	 G_KB + P12_KB			 ;; Keyboard Type
   DB	 0EFH,0 			 ;; error character = standalone accent
   DW	 CP850_AC_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 6				 ;; number of scans
   DB	 18,090H			 ;;    E acute
   DB	 30,0B5H			 ;;    A acute
   DB	 23,0D6H			 ;;    I acute
   DB	 24,0E0H			 ;;    O acute
   DB	 22,0E9H			 ;;    U acute
   DB	 21,0EDH			 ;;    Y acute
CP850_AC_UP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP850_AC_UP_END:			 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Acute Space Bar
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP850_AC_SP_END-$		 ;; length of state section
   DB	 ACUTE_SPACE			 ;; State ID
   DW	 G_KB + P12_KB			 ;; Keyboard Type
   DB	 0EFH,0 			 ;; error character = standalone accent
					 ;;
   DW	 CP850_AC_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 1				 ;; number of scans
   DB	 57,0EFH			 ;; scan code,ASCII - SPACE
CP850_AC_SP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP850_AC_SP_END:			 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850 - NOW IN COMMON MJS 31/10/86
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					 ;;
;; CODE PAGE: 850
;; STATE: Diaresis Upper
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_UP_END-$	       ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 0F9H,0 		       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 30,''                        ;; scan code,ASCII - A
   DB	 18,0D3H		       ;; scan code,ASCII - E
   DB	 23,0D8H		       ;; scan code,ASCII - I
   DB	 24,''                        ;; scan code,ASCII - O
   DB	 22,''                        ;; scan code,ASCII - U
CP850_DI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_UP_END:		       ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850 - NOW IN COMMON MJS 31/10/86
;; STATE: Diaeresis Space Bar
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Grave Upper
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP850_GR_UP_END-$		 ;; length of state section
   DB	 GRAVE_UPPER			 ;; State ID
   DW	 G_KB + P12_KB			 ;; Keyboard Type
   DB	 60H,0				 ;; error character = standalone accent
					 ;;
   DW	 CP850_GR_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 5				 ;; number of scans
   DB	 30,0B7H			 ;;    A grave
   DB	 18,0D4H			 ;;    E grave
   DB	 23,0DEH			 ;;    I grave
   DB	 24,0E3H			 ;;    O grave
   DB	 22,0EBH			 ;;    U grave
CP850_GR_UP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP850_GR_UP_END:			 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Circumflex Upper
;; KEYBOARD TYPES : G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP850_CI_UP_END-$		 ;; length of state section
   DB	 CIRCUMFLEX_UPPER		 ;; State ID
   DW	 G_KB + P12_KB			 ;; Keyboard Type
   DB	 5EH,0				 ;; error character = standalone accent
					 ;;
   DW	 CP850_CI_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 5				 ;; number of scans
   DB	 30,0B6H			 ;;    A circumflex
   DB	 18,0D2H			 ;;    E circumflex
   DB	 23,0D7H			 ;;    I circumflex
   DB	 24,0E2H			 ;;    O circumflex
   DB	 22,0EAH			 ;;    U circumflex
CP850_CI_UP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP850_CI_UP_END:			 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
     DW    0				 ;; LAST STATE
					 ;;
CP850_XLAT_END: 			 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
CODE	 ENDS				 ;;
	 END				 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kbd2\kdfro.asm ===
PAGE    ,132
        TITLE   PC DOS 3.3 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PC DOS 3.3 - NLS Support - Keyboard Definition File
;; (c) Copyright IBM Corp 1986,1987
;;
;; This file contains the keyboard tables for:
;; Romania
;; which form the Multilingual (ML) Group 2.
;;
;; Linkage Instructions:
;;      Refer to KDF.ASM.
;;
;;
;; WRITTEN:    Michael J. Saunders 2.OCTOBER 1987
;;             Adapted by Mihindu (Microsoft) Nov. 30, 1990
;; Created from Hungary by Yuri Starikov (Microsoft) Aug. 06, 1991
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        INCLUDE KEYBSHAR.INC           ;;
        INCLUDE POSTEQU.INC            ;;
        INCLUDE KEYBMAC.INC            ;;
                                       ;;
        PUBLIC RO_LOGIC                ;;
        PUBLIC RO_850_XLAT             ;;
        PUBLIC RO_852_XLAT             ;;
                                       ;;
CODE    SEGMENT PUBLIC 'CODE'          ;;
        ASSUME CS:CODE,DS:CODE         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a linear search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
STANDARD_TABLE      EQU   TYPE_2_TAB+ASCII_ONLY
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; RO State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
                                       ;;
RO_LOGIC:                              ;;
                                       ;;
   DW  LOGIC_END-$                     ;; length
                                       ;;
   DW  0                               ;; special features
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   OPTION EXIT_IF_FOUND                ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   IFF  EITHER_ALT,NOT                 ;;
   ANDF EITHER_CTL,NOT                 ;;
;;     IFF CAPS_STATE
;;         SET_FLAG DEAD_UPPER
;;     ELSEF
      IFF EITHER_SHIFT                 ;;
          SET_FLAG DEAD_UPPER          ;;
      ELSEF                            ;;
          SET_FLAG DEAD_LOWER          ;;
      ENDIFF                           ;;
;;     ENDIFF
   ELSEF                               ;;
      IFF EITHER_SHIFT,NOT             ;;
        IFKBD XT_KB+AT_KB
          IFF EITHER_CTL                ;;
          ANDF ALT_SHIFT                ;;
            SET_FLAG DEAD_THIRD        ;;
          ENDIFF                        ;;
        ELSEF
         IFF R_ALT_SHIFT               ;;
         ANDF EITHER_CTL,NOT           ;;
         ANDF LC_E0,NOT                ;;
            SET_FLAG DEAD_THIRD        ;;
         ENDIFF                        ;;
        ENDIFF
       ENDIFF
   ENDIFF                              ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
ACUTE_PROC:                            ;;
                                       ;;
   IFF ACUTE,NOT                       ;;
      GOTO CEDILLA_PROC                ;;
      ENDIFF                           ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT ACUTE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
         IFF EITHER_SHIFT              ;;
            IFF CAPS_STATE             ;;
               XLATT ACUTE_LOWER       ;;
            ELSEF                      ;;
               XLATT ACUTE_UPPER       ;;
            ENDIFF                     ;;
         ELSEF                         ;;
            IFF CAPS_STATE             ;;
               XLATT ACUTE_UPPER       ;;
            ELSEF                      ;;
               XLATT ACUTE_LOWER       ;;
            ENDIFF                     ;;
         ENDIFF                        ;;
      ENDIFF                           ;;
                                       ;;
INVALID_ACUTE:                         ;;
      PUT_ERROR_CHAR ACUTE_SPACE       ;; If we get here then either the XLATT
      BEEP                             ;; failed or we are ina bad shift state.
      GOTO NON_DEAD                    ;; Either is invalid so BEEP and fall
                                       ;; through to generate the second char.
                                       ;; Note that the dead key flag will be
                                       ;; reset before we get here.
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CEDILLA ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
CEDILLA_PROC:                          ;;
                                       ;;
   IFF CEDILLA,NOT                     ;;
      GOTO DIARESIS_PROC               ;;
      ENDIFF                           ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT CEDILLA_SPACE           ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
         IFF EITHER_SHIFT              ;;
            IFF CAPS_STATE             ;;
               XLATT CEDILLA_LOWER     ;;
            ELSEF                      ;;
               XLATT CEDILLA_UPPER     ;;
            ENDIFF                     ;;
         ELSEF                         ;;
            IFF CAPS_STATE             ;;
               XLATT CEDILLA_UPPER     ;;
            ELSEF                      ;;
               XLATT CEDILLA_LOWER     ;;
            ENDIFF                     ;;
         ENDIFF                        ;;
      ENDIFF                           ;;
                                       ;;
INVALID_CEDILLA:                       ;;
      PUT_ERROR_CHAR CEDILLA_LOWER     ;; If we get here then either the XLATT
      BEEP                             ;; failed or we are ina bad shift state.
      GOTO NON_DEAD                    ;; Either is invalid so BEEP and fall
                                       ;; through to generate the second char.
                                       ;; Note that the dead key flag will be
                                       ;; reset before we get here.
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
DIARESIS_PROC:                         ;;
                                       ;;
   IFF DIARESIS,NOT                    ;;
      GOTO GRAVE_PROC                  ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT DIARESIS_SPACE          ;;  exist for 850 so beep for
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
         IFF EITHER_SHIFT              ;;
            IFF CAPS_STATE             ;;
               XLATT DIARESIS_LOWER    ;;
            ELSEF                      ;;
               XLATT DIARESIS_UPPER    ;;
            ENDIFF                     ;;
         ELSEF                         ;;
            IFF CAPS_STATE             ;;
               XLATT DIARESIS_UPPER    ;;
            ELSEF                      ;;
               XLATT DIARESIS_LOWER    ;;
            ENDIFF                     ;;
         ENDIFF                        ;;
      ENDIFF                           ;;
                                       ;;
INVALID_DIARESIS:                      ;;
      PUT_ERROR_CHAR DIARESIS_LOWER    ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
GRAVE_PROC:                            ;;
                                       ;;
   IFF GRAVE,NOT                       ;;
      GOTO TILDE_PROC                  ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT GRAVE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT GRAVE_LOWER        ;;
           ELSEF                       ;;
              XLATT GRAVE_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT GRAVE_LOWER        ;;
           ELSEF                       ;;
              XLATT GRAVE_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_GRAVE:                         ;;
      PUT_ERROR_CHAR GRAVE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TILDE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TILDE_PROC:                            ;;
                                       ;;
   IFF TILDE,NOT                       ;;
      GOTO CIRCUMFLEX_PROC             ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT TILDE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT TILDE_LOWER        ;;
           ELSEF                       ;;
              XLATT TILDE_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE              ;;
              XLATT TILDE_UPPER        ;;
           ELSEF                       ;;
              XLATT TILDE_LOWER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
INVALID_TILDE:                         ;;
      PUT_ERROR_CHAR TILDE_LOWER       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
CIRCUMFLEX_PROC:                       ;;
                                       ;;
   IFF CIRCUMFLEX,NOT                  ;;
      GOTO CARON_PROC                  ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT CIRCUMFLEX_LOWER   ;;
           ELSEF                       ;;
              XLATT CIRCUMFLEX_UPPER   ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT CIRCUMFLEX_LOWER   ;;
           ELSEF                       ;;
              XLATT CIRCUMFLEX_UPPER   ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_CIRCUMFLEX:                    ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CARON ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
CARON_PROC:                            ;;
                                       ;;
   IFF CARON,NOT                       ;;
      GOTO BREVE_PROC                  ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT CARON_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT CARON_LOWER        ;;
           ELSEF                       ;;
              XLATT CARON_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT CARON_LOWER        ;;
           ELSEF                       ;;
              XLATT CARON_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_CARON:                         ;;
      PUT_ERROR_CHAR CARON_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BREVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
BREVE_PROC:                            ;;
                                       ;;
   IFF BREVE,NOT                       ;;
      GOTO OVERCIRCLE_PROC             ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT BREVE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT BREVE_LOWER        ;;
           ELSEF                       ;;
              XLATT BREVE_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT BREVE_LOWER        ;;
           ELSEF                       ;;
              XLATT BREVE_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_BREVE:                         ;;
      PUT_ERROR_CHAR BREVE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OVERCIRCLE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
OVERCIRCLE_PROC:                            ;;
                                       ;;
   IFF OVERCIRCLE,NOT                       ;;
      GOTO OGONEK_PROC             ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT OVERCIRCLE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT OVERCIRCLE_LOWER        ;;
           ELSEF                       ;;
              XLATT OVERCIRCLE_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT OVERCIRCLE_LOWER        ;;
           ELSEF                       ;;
              XLATT OVERCIRCLE_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_OVERCIRCLE:                         ;;
      PUT_ERROR_CHAR OVERCIRCLE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OGONEK ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
OGONEK_PROC:                            ;;
                                       ;;
   IFF OGONEK,NOT                       ;;
      GOTO OVERDOT_PROC             ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT OGONEK_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT OGONEK_LOWER        ;;
           ELSEF                       ;;
              XLATT OGONEK_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT OGONEK_LOWER        ;;
           ELSEF                       ;;
              XLATT OGONEK_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_OGONEK:                         ;;
      PUT_ERROR_CHAR OGONEK_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OVERDOT ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
OVERDOT_PROC:                            ;;
                                       ;;
   IFF OVERDOT,NOT                       ;;
      GOTO DOUBLEACUTE_PROC             ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT OVERDOT_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT OVERDOT_LOWER        ;;
           ELSEF                       ;;
              XLATT OVERDOT_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT OVERDOT_LOWER        ;;
           ELSEF                       ;;
              XLATT OVERDOT_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_OVERDOT:                       ;;
      PUT_ERROR_CHAR OVERDOT_SPACE     ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DOUBLEACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
DOUBLEACUTE_PROC:                      ;;
                                       ;;
   IFF DOUBLEACUTE,NOT                 ;;
      GOTO NON_DEAD                    ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT DOUBLEACUTE_SPACE       ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT DOUBLEACUTE_LOWER  ;;
           ELSEF                       ;;
              XLATT DOUBLEACUTE_UPPER  ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT DOUBLEACUTE_LOWER  ;;
           ELSEF                       ;;
              XLATT DOUBLEACUTE_UPPER  ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_DOUBLEACUTE:                   ;;
      PUT_ERROR_CHAR DOUBLEACUTE_SPACE ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
;***************************
NON_DEAD:                              ;;
;ADDED FOR DIVIDE SIGN                 ;;
    IFKBD G_KB+P12_KB                   ;; Avoid accidentally translating
    ANDF LC_E0                          ;;  the "/" on the numeric pad of the
      IFF EITHER_CTL,NOT
      ANDF EITHER_ALT,NOT
        XLATT DIVIDE_SIGN              ;;
      ENDIFF
      EXIT_STATE_LOGIC               ;;
    ENDIFF                             ;;
;BD END OF ADDITION
;****************************
;NON_DEAD:                              ;;
;                                       ;;
;  IFKBD G_KB+P12_KB                   ;; Avoid accidentally translating
;  ANDF LC_E0                          ;;  the "/" on the numeric pad of the
;     EXIT_STATE_LOGIC                 ;;   G keyboard
;  ENDIFF                              ;;
                                       ;;
   IFF  EITHER_ALT,NOT                 ;;
   ANDF EITHER_CTL,NOT                 ;;
      IFF EITHER_SHIFT                 ;;
;******************************************
;;***BD ADDED FOR NUMERIC PAD
          IFF NUM_STATE,NOT            ;;
              XLATT NUMERIC_PAD        ;;
          ENDIFF                       ;;
;;***BD END OF ADDITION
;*******************************************
          XLATT NON_ALPHA_UPPER        ;;
          IFF CAPS_STATE               ;;
              XLATT ALPHA_LOWER        ;;
;;              XLATT NON_ALPHA_LOWER    ;;
          ELSEF                        ;;
              XLATT ALPHA_UPPER        ;;
;;              XLATT NON_ALPHA_UPPER    ;;
          ENDIFF                       ;;
      ELSEF                            ;;
;******************************************
;;***BD ADDED FOR NUMERIC PAD
          IFF NUM_STATE                ;;
              XLATT NUMERIC_PAD        ;;
          ENDIFF                       ;;
;;***BD END OF ADDITION
;******************************************
          XLATT NON_ALPHA_LOWER        ;;
          IFF CAPS_STATE               ;;
             XLATT ALPHA_UPPER         ;;
;;             XLATT NON_ALPHA_UPPER     ;;
          ELSEF                        ;;
             XLATT ALPHA_LOWER         ;;
;;             XLATT NON_ALPHA_LOWER     ;;
          ENDIFF                       ;;
      ENDIFF                           ;;
   ELSEF                               ;;
      IFF EITHER_SHIFT,NOT             ;;
          IFKBD XT_KB+AT_KB      ;;
              IFF  EITHER_CTL          ;;
              ANDF ALT_SHIFT           ;;
                  XLATT THIRD_SHIFT    ;;
              ENDIFF                   ;;
          ELSEF                        ;;
              IFF EITHER_CTL,NOT       ;;
              ANDF R_ALT_SHIFT         ;;
                  XLATT THIRD_SHIFT    ;;
              ENDIFF                   ;;
          ENDIFF                       ;;
      IFKBD AT_KB+XT_KB          ;;
        IFF EITHER_CTL                 ;;
        ANDF ALT_SHIFT                 ;;
          XLATT ALT_CASE               ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
      IFKBD G_KB+P12_KB                ;;
        IFF EITHER_CTL                 ;;
        ANDF ALT_SHIFT                 ;;
          IFF R_ALT_SHIFT,NOT             ;;
            XLATT ALT_CASE                ;;
          ENDIFF                          ;;
        ENDIFF                            ;;
      ENDIFF                              ;;
     ENDIFF                               ;;
   ENDIFF                                 ;;
;IFF EITHER_SHIFT,NOT                     ;;
   IFKBD AT_KB+XT_KB                ;;
     IFF EITHER_CTL,NOT                   ;;
       IFF ALT_SHIFT                      ;; ALT - case
         XLATT ALT_CASE                   ;;
       ENDIFF                             ;;
     ELSEF                                ;;
         XLATT CTRL_CASE                  ;;
     ENDIFF                               ;;
   ENDIFF                                 ;;
                                          ;;
   IFKBD G_KB+P12_KB                      ;;
     IFF EITHER_CTL,NOT                   ;;
       IFF ALT_SHIFT                      ;; ALT - case
       ANDF R_ALT_SHIFT,NOT               ;;
         XLATT ALT_CASE                   ;;
       ENDIFF                             ;;
     ELSEF                                ;;
       IFF EITHER_ALT,NOT                 ;;
         XLATT CTRL_CASE                  ;;
       ENDIFF                             ;;
     ENDIFF                               ;;
     IFF EITHER_CTL                       ;;
     ANDF ALT_SHIFT                       ;;
     ANDF R_ALT_SHIFT,NOT                 ;;
        XLATT ALT_CASE                    ;;
     ENDIFF                               ;;
   ENDIFF                                 ;;
                                          ;;
   EXIT_STATE_LOGIC                       ;;
                                          ;;
LOGIC_END:                                ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;**********************************************************************
;; HU Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; Some common Characters are included from 128 - 165 where appropriate.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
 PUBLIC RO_COMMON_XLAT                 ;;
RO_COMMON_XLAT:                        ;;
                                       ;;
   DW     COMMON_XLAT_END-$            ;; length of section
   DW     -1                           ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: low shift Dead_lower
;; KEYBOARD TYPES: G
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
;  DW    COM_RO_LO_END-$               ;; length of state section
;  DB    DEAD_LOWER                    ;; State ID
;  DW    ANY_KB                          ;; Keyboard Type
;  DB    -1,-1                         ;; Buffer entry for error character
;                                      ;; Set Flag Table
;  DW    1                             ;; number of entries
;  DB    41                            ;;
;  FLAG  OGONEK                        ;;
                                       ;;
;COM_RO_LO_END:                        ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: low shift Dead_UPPER
;; KEYBOARD TYPES: G
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
;  DW    COM_RO_UP_END-$               ;; length of state section
;  DB    DEAD_UPPER                    ;; State ID
;  DW    ANY_KB                          ;; Keyboard Type
;  DB    -1,-1                         ;; Buffer entry for error character
;                                      ;; Set Flag Table
;  DW    1                             ;; number of entries
;  DB    41                            ;;
;  FLAG  OVERDOT                       ;;
;                                      ;;
;COM_RO_UP_END:                        ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Third Shift Dead Key
;; KEYBOARD TYPES: G
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_RO_TH_END-$               ;; length of state section
   DB    DEAD_THIRD                    ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;; Set Flag Table
   DW    10                            ;; number of entries
;; DB    2                             ;; TILDE IS NOT AN ACCENT KEY
;; FLAG  TILDE                         ;;
   DB    3                             ;;
   FLAG  CARON                         ;;
   DB    4                             ;;
   FLAG  CIRCUMFLEX                    ;;
   DB    5                             ;;
   FLAG  BREVE                         ;;
   DB    6                             ;;
   FLAG  OVERCIRCLE                    ;;
   DB    7                             ;;
   FLAG  OGONEK                        ;;
;;   DB    8                             ;; GRAVE IS NOT AN ACCENT KEY (YST)
;;   FLAG  GRAVE                         ;;
   DB    9                             ;;
   FLAG  OVERDOT                       ;;
   DB    10                            ;;
   FLAG  ACUTE                         ;;
   DB    11                            ;;
   FLAG  DOUBLEACUTE                   ;;
   DB    12                            ;;
   FLAG  DIARESIS                      ;;
   DB    13                            ;;
   FLAG  CEDILLA                       ;;
                                       ;;
COM_RO_TH_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;******************************
;;***BD - ADDED FOR NUMERIC PAD (DECIMAL SEPERATOR)
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Numeric Key Pad
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_PAD_K1_END-$              ;; length of state section
   DB    NUMERIC_PAD                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_PAD_K1_T1_END-$           ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB    83,','                        ;; decimal seperator = ,
COM_PAD_K1_T1_END:                     ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_PAD_K1_END:                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;******************************
;;***BD - ADDED FOR ALT CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Alt Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_ALT_K1_END-$              ;; length of state section
   DB    ALT_CASE                      ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_ALT_K1_T1_END-$           ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    3                             ;; number of entries
   DB    21,0,2CH                      ;;
   DB    44,0,15H                      ;;
   DB    53,0,82H                      ;;
COM_ALT_K1_T1_END:                     ;;
                                       ;;
    DW    0                            ;; Size of xlat table - null table
                                       ;;
COM_ALT_K1_END:                        ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CTRL_K2_END-$             ;; length of state section
   DB    CTRL_CASE                     ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_CTRL_K2_T1_END-$          ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    3                             ;; number of entries
   DB    21,01AH,2CH                   ;;
   DB    44,019H,15H                   ;;
   DB    53,01FH,0CH                   ;;
COM_CTRL_K2_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CTRL_K2_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_AL_LO_K1_END-$            ;; length of state section
   DB    ALPHA_LOWER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_AL_LO_K1_T1_END-$         ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    2                             ;; number of entries
;;   DB    11,"",0BH                  ;;
;;   DB    12,"",0CH                  ;;
   DB    21,"z",2CH                    ;;
   DB    44,"y",15H                    ;;
COM_AL_LO_K1_T1_END:                   ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_AL_LO_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_AL_UP_K1_END-$            ;; length of state section
   DB    ALPHA_UPPER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_AL_UP_K1_T1_END-$         ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    2                             ;; number of entries
;;   DB    11,"",0BH                  ;;
;;   DB    12,"",0CH                  ;;
   DB    21,"Z",2CH                    ;;
   DB    44,"Y",15H                    ;;
COM_AL_UP_K1_T1_END:                   ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_AL_UP_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_NA_LO_K1_END-$            ;; length of state section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_NA_LO_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    5                             ;; number of entries
   DB    12,"+"                        ;; -
   DB    13,"'"                        ;; -
   DB    41,"]"                        ;; -
   DB    53,"-"                        ;; -
   DB    86,"<"                        ;; -
COM_NA_LO_K1_T1_END:                   ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_NA_LO_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_NA_UP_K1_END-$            ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_NA_UP_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    17                            ;; number of entries
   DB     2,"!"                        ;;
   DB     3,'"'                        ;;
   DB     4,"#"                        ;;
   DB     5,"$"                        ;;
   DB     6,"%"                        ;;
   DB     7, "&"                       ;;
   DB     8,'/'                        ;;
   DB     9,'('                        ;;
   DB    10,')'                        ;;
   DB    11,'='                        ;;
   DB    12,'?'                        ;;
   DB    13,'*'                        ;;
   DB    41,'['                        ;;
   DB    51,03bH                       ;;
   DB    52,':'                        ;;
   DB    53,'_'                        ;;
   db    86,'>'                        ;;
COM_NA_UP_K1_T1_END:                   ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_NA_UP_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Third Shift
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_THIRD_END-$               ;; length of state section
   DB    THIRD_SHIFT                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type FERRARI
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_THIRD_T1_END-$            ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    17                            ;; number of entries
   DB     2,'~',02H                    ;;
   DB     8,'`',08H                    ;;
   DB    16,'\',10H                    ;;
   DB    17,'|',11H                    ;;
   DB    18,'',12H                    ;;
   DB    20,'$',14H                    ;;
   DB    21,0E1H,15H                   ;; SHARP S
   DB    23,'<',17H                    ;;
   DB    24,'>',18H                    ;;
   DB    26,'',1AH                    ;;
   DB    39,'$',27H                    ;;
   DB    40,0E1H,28H                   ;; SHARP S
   DB    47,'@',2FH                    ;;
   DB    48,'{',20H                    ;;
   DB    49,'}',21H                    ;;
   DB    51,'<',33H                    ;;
   DB    52,'>',35H                    ;;
COM_THIRD_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Last xlat table
COM_THIRD_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Caron Space
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CA_SP_END-$               ;; length of state section
   DB    CARON_SPACE                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F3H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_CA_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F3H                       ;; Caron Space
COM_CA_SP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CA_SP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Breve Space
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_BR_SP_END-$               ;; length of state section
   DB    BREVE_SPACE                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F4H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_BR_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F4H                       ;; BREVE SPACE
COM_BR_SP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_BR_SP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Ogonek Space
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_OG_SP_END-$               ;; length of state section
   DB    OGONEK_SPACE                  ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F2H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_OG_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F2H                       ;; OGONEK SPACE
COM_OG_SP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_OG_SP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Double Acute Space
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_DC_SP_END-$               ;; length of state section
   DB    DOUBLEACUTE_SPACE             ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F1H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_DC_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of entries
   DB    57,0F1H                       ;; DOUBLEACUTE SPACE
COM_DC_SP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_DC_SP_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CI_LO_END-$               ;; length of state section
   DB    CIRCUMFLEX_LOWER              ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    94,0                          ;; error character = standalone accent
                                       ;;
   DW    COM_CI_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    3                             ;; number of scans
   DB    23,''                        ;;  "    "  ,  "   - i
   DB    24,''                        ;; scan code,ASCII - o
   DB    30,''                        ;; scan code,ASCII - a
COM_CI_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;;
                                       ;;
COM_CI_LO_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CI_SP_END-$               ;; length of state section
   DB    CIRCUMFLEX_SPACE              ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    94,0                          ;; error character = standalone accent
                                       ;;
   DW    COM_CI_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,94                         ;; STANDALONE CIRCUMFLEX
COM_CI_SP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CI_SP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Overcircle Space Bar
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_OC_SP_END-$               ;; length of state section
   DB    OVERCIRCLE_SPACE              ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_OC_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F8H                       ;; STANDALONE OVERCIRCLE
COM_OC_SP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_OC_SP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Grave Space Bar
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_GR_SP_END-$               ;; length of state section
   DB    GRAVE_SPACE                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    96,0                          ;; error character = standalone accent
                                       ;;
   DW    COM_GR_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,96                         ;; STANDALONE GRAVE
COM_GR_SP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_GR_SP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Overdot
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ;;
    DW    COM_OD_SP_END-$               ;; length of state section
    DB    OVERDOT_SPACE                 ;; State ID
    DW    ANY_KB                          ;; Keyboard Type
    DB    0FAH,0                        ;; error character = standalone accent
                                        ;;
    DW    COM_OD_SP_T1_END-$            ;; Size of xlat table
    DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
    DB    1                             ;; number of scans
    DB    57,0FAH                       ;; STANDALONE OVERDOT
COM_OD_SP_T1_END:                       ;;
                                        ;;
    DW    0                             ;;
                                        ;;
COM_OD_SP_END:                          ;;
                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_AC_LO_END-$               ;; length of state section
   DB    ACUTE_LOWER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_AC_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    5                             ;; number of entries
   DB    18,082H                       ;;    e acute
   DB    22,0A3H                       ;;    u acute
   DB    23,0A1H                       ;;    i acute
   DB    24,0A2H                       ;;    o acute
   DB    30,0A0H                       ;;    a acute
COM_AC_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_AC_LO_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_AC_UP_END-$               ;; length of state section
   DB    ACUTE_UPPER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_AC_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of entries
   DB    18,090H                       ;;    E acute
COM_AC_UP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_AC_UP_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: P12_KB+ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_AC_SP_END-$               ;; length of state section
   DB    ACUTE_SPACE                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    027H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_AC_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,027H                       ;; error character = standalone accent
COM_AC_SP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
COM_AC_SP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Cedilla Lower Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CE_LO_END-$               ;; length of state section
   DB    CEDILLA_LOWER                 ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_CE_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    46,''                        ;; scan code,ASCII - 
COM_CE_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CE_LO_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Cedilla Upper Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CE_UP_END-$               ;; length of state section
   DB    CEDILLA_UPPER                 ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_CE_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    46,''                        ;;     CEDILLA
COM_CE_UP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CE_UP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Cedilla Space
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CE_SP_END-$               ;; length of state section
   DB    CEDILLA_SPACE                 ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_CE_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of entries
   DB    57,0F7H                       ;; CEDILLA SPACE
COM_CE_SP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CE_SP_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_DI_LO_END-$               ;; length of state section
   DB    DIARESIS_LOWER                ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
                                       ;;
   DW    COM_DI_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    4                             ;; number of scans
   DB    18,''                        ;; scan code,ASCII - e
   DB    22,''                        ;; scan code,ASCII - u
   DB    24,''                        ;; scan code,ASCII - o
   DB    30,''                        ;; scan code,ASCII - a
COM_DI_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_DI_LO_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_DI_UP_END-$               ;; length of state section
   DB    DIARESIS_UPPER                ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
                                       ;;
   DW    COM_DI_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    3                             ;; number of scans
   DB    22,''                        ;;    U Diaeresis
   DB    24,''                        ;;    O Diaeresis
   DB    30,''                        ;;    A Diaeresis
COM_DI_UP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_DI_UP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: P12_KB+ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_DI_SP_END-$               ;; length of state section
   DB    DIARESIS_SPACE                ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
                                       ;;
   DW    COM_DI_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,249                        ;; error character = standalone accent
COM_DI_SP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
COM_DI_SP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW    0                             ;; Last State
COMMON_XLAT_END:                       ;;  END OF COMMON SECTION
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CODE PAGE 850 MULTILINGUAL 2  SPECIFIC TRANSLATION
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
 PUBLIC RO_850_XLAT                    ;;
RO_850_XLAT:                           ;;
                                       ;;
    DW   CP850_XLAT_END-$              ;;
    DW   850                           ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_NA_LO_K1_END-$          ;; length of state section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP850_NA_LO_K1_T1_END-$       ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    0                             ;; number of entries
CP850_NA_LO_K1_T1_END:                 ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_NA_LO_K1_END:                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_NA_UP_K1_END-$          ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP850_NA_UP_K1_T1_END-$       ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB    5,-1                          ;; CURRENCY SYMBOL
CP850_NA_UP_K1_T1_END:                 ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_NA_UP_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_AL_LO_END-$             ;; length of state section
   DB    ALPHA_LOWER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; error character = standalone accent
                                       ;;
   DW    CP850_AL_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB    27,-1                         ;; BLOT OUT CHAR UNDER 850
CP850_AL_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_AL_LO_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_AL_UP_END-$             ;; length of state section
   DB    ALPHA_UPPER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; error character = standalone accent
                                       ;;
   DW    CP850_AL_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB    27,-1                         ;; BLOT OUT CHAR UNDER 850
CP850_AL_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_AL_UP_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_CI_LO_END-$               ;; length of state section
   DB    CIRCUMFLEX_LOWER              ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    94,0                          ;; error character = standalone accent
                                       ;;
   DW    CP850_CI_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of scans
   DB    18,88H                        ;;  e CIRCUMFLEX
   DB    23,8CH                        ;;  i CIRCUMFLEX
CP850_CI_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;;
                                       ;;
CP850_CI_LO_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Overcircle Lower Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_OC_LO_END-$               ;; length of state section
   DB    OVERCIRCLE_LOWER              ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP850_OC_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,86H                        ;; a OVERCIRCLE
CP850_OC_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_OC_LO_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Overcircle Upper Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_OC_UP_END-$               ;; length of state section
   DB    OVERCIRCLE_LOWER              ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP850_OC_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,8FH                        ;; A OVERCIRCLE
CP850_OC_UP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_OC_UP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Grave Lower Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_GR_LO_END-$               ;; length of state section
   DB    GRAVE_LOWER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    060H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP850_GR_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    5                             ;; number of scans
   DB    18,8AH                        ;; e GRAVE
   DB    22,97H                        ;; u GRAVE
   DB    23,8DH                        ;; i GRAVE
   DB    24,95H                        ;; o GRAVE
   DB    30,85H                        ;; a GRAVE
CP850_GR_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_GR_LO_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_DI_LO_END-$             ;; length of state section
   DB    DIARESIS_LOWER                ;; State ID
   DW    ANY_KB                   ;; Keyboard Type
   DB    0FEH,0                         ;; error character = standalone accent
                                       ;;
   DW    CP850_DI_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    16,8BH                        ;; i DIARESIS
CP850_DI_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
CP850_DI_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: P12_KB+ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_DI_SP_END-$             ;; length of state section
   DB    DIARESIS_SPACE                ;; State ID
   DW    ANY_KB                   ;; Keyboard Type
   DB    0FEH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP850_DI_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0FEH,0                     ;; error character = standalone accent
CP850_DI_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
CP850_DI_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Space
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_OG_SP_END-$             ;; length of state section
   DB    OGONEK_SPACE                  ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0FEH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP850_OG_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0FEH                       ;; OGONEK SPACE
CP850_OG_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_OG_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW    0                             ;; LAST STATE
                                       ;;
CP850_XLAT_END:                        ;; END OF CP850 SECTION
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CODE PAGE 852 MULTILINGUAL 2  SPECIFIC TRANSLATION
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
 PUBLIC RO_852_XLAT                    ;;
RO_852_XLAT:                           ;;
                                       ;;
    DW     CP852_XLAT_END-$            ;;
    DW     852                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_AL_LO_END-$           ;; length of state section
   DB    ALPHA_LOWER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP852_AL_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    5                             ;; number of entries
   DB    26,0C7H                       ;; a BREVE
   DB    27,08CH                       ;; i CIRCUMFLEX
   DB    39,0ADH                       ;; s CEDILLA
   DB    40,0EEH                       ;; t CEDILLA
   DB    43,083H                       ;; a CIRCUMFLEX
CP852_AL_LO_T1_END:                  ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_AL_LO_END:                     ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_AL_UP_END-$           ;; length of state section
   DB    ALPHA_UPPER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP852_AL_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    5                             ;; number of entries
   DB    26,0C6H                       ;; A BREVE
   DB    27,0D7H                       ;; I CIRCUMFLEX
   DB    39,0B8H                       ;; S CEDILLA
   DB    40,0DDH                       ;; T CEDILLA
   DB    43,0B6H                       ;; a CIRCUMFLEX
CP852_AL_UP_T1_END:                  ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_AL_UP_END:                     ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Third Shift
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_THIRD_END-$               ;; length of state section
   DB    THIRD_SHIFT                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type FERRARI
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP852_THIRD_T1_END-$            ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    7                             ;; number of entries
   DB    19,09EH,13H                   ;;
   DB    27,09EH,1BH                   ;;
   DB    31,0D0H,1FH                   ;; d STROKE
   DB    32,0D1H,20H                   ;; D STROKE
   DB    37,088H,25H                   ;; l STROKE
   DB    38,09DH,26H                   ;; L STROKE
   DB    50,0F5H,32H                   ;; paragraph SYMBOL
CP852_THIRD_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Last xlat table
CP852_THIRD_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP852
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_NA_LO_K1_END-$            ;; length of state section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP852_NA_LO_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    0                             ;; number of entries
CP852_NA_LO_K1_T1_END:                   ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_NA_LO_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP852
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_NA_UP_K1_END-$            ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP852_NA_UP_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   db    5, 0CFH
CP852_NA_UP_K1_T1_END:                   ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_NA_UP_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Lower
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_CA_LO_END-$             ;; length of state section
   DB    CARON_LOWER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F3H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_CA_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    9                             ;; number of scans
   DB    18,0D8H                       ;; e CARON
   DB    19,0FDH                       ;; r CARON
   DB    20,09CH                       ;; t CARON
   DB    21,0A7H                       ;; z CARON
   DB    31,0E7H                       ;; s CARON
   DB    32,0D4H                       ;; d CARON
   DB    38,096H                       ;; l CARON
   DB    46,09FH                       ;; c CARON
   DB    49,0E5H                       ;; n CARON
CP852_CA_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_CA_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Upper
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_CA_UP_END-$             ;; length of state section
   DB    CARON_UPPER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F3H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_CA_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    9                             ;; number of scans
   DB    18,0B7H                       ;; E CARON
   DB    19,0FCH                       ;; R CARON
   DB    20,09BH                       ;; T CARON
   DB    21,0A6H                       ;; Z CARON
   DB    31,0E6H                       ;; S CARON
   DB    32,0D2H                       ;; D CARON
   DB    38,095H                       ;; L CARON
   DB    46,0ACH                       ;; C CARON
   DB    49,0D5H                       ;; N CARON
CP852_CA_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_CA_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Space
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_CA_SP_END-$             ;; length of state section
;;   DB    CARON_SPACE                   ;; State ID
;;   DW    ANY_KB                          ;; Keyboard Type
;;   DB    0F3H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_CA_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F3H                       ;; e CARON
;;CP852_CA_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_CA_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Circumflex Upper
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_CI_UP_END-$             ;; length of state section
   DB    CIRCUMFLEX_UPPER              ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    05EH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_CI_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    3                             ;; number of scans
   DB    23,0D7H                       ;; I CIRCUMFLEX
   DB    24,0E2H                       ;; O CIRCUMFLEX
   DB    30,0B6H                       ;; A CIRCUMFLEX
CP852_CI_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_CI_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Lower
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_BR_LO_END-$             ;; length of state section
   DB    BREVE_LOWER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F4H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_BR_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,0C7H                       ;; a BREVE
CP852_BR_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_BR_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Upper
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_BR_UP_END-$             ;; length of state section
   DB    BREVE_UPPER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F4H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_BR_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,0C6H                       ;; A BREVE
CP852_BR_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_BR_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Space
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_BR_SP_END-$             ;; length of state section
;;   DB    BREVE_SPACE                   ;; State ID
;;   DW    ANY_KB                          ;; Keyboard Type
;;   DB    0F4H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_BR_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F4H                       ;; BREVE SPACE
;;CP852_BR_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_BR_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overcirle Lower
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OC_LO_END-$             ;; length of state section
   DB    OVERCIRCLE_LOWER              ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OC_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    22,085H                       ;; u OVERCIRCLE
CP852_OC_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OC_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overcircle Upper
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OC_UP_END-$             ;; length of state section
   DB    OVERCIRCLE_UPPER              ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OC_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    22,0DEH                       ;; O OVERCIRCLE
CP852_OC_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OC_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Lower
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OG_LO_END-$             ;; length of state section
   DB    OGONEK_LOWER              ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F2H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OG_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of scans
   DB    18,0A9H                       ;; e OGONEK
   DB    30,0A5H                       ;; a OGONEK
CP852_OG_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OG_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Upper
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OG_UP_END-$             ;; length of state section
   DB    OGONEK_UPPER              ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F2H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OG_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of scans
   DB    18,0A8H                       ;; E OGONEK
   DB    30,0A4H                       ;; A OGONEK
CP852_OG_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OG_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Space
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_OG_SP_END-$             ;; length of state section
;;   DB    OGONEK_SPACE                  ;; State ID
;;   DW    ANY_KB                          ;; Keyboard Type
;;   DB    0F2H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_OG_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F2H                       ;; OGONEK SPACE
;;CP852_OG_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_OG_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overdot Lower
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OD_LO_END-$             ;; length of state section
   DB    OVERDOT_LOWER              ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0FAH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OD_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    21,0BEH                       ;; z OVERDOT
CP852_OD_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OD_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overdot Upper
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OD_UP_END-$             ;; length of state section
   DB    OVERDOT_UPPER              ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0FAH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OD_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    21,0BDH                       ;; Z OVERDOT
CP852_OD_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OD_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_AC_LO_END-$             ;; length of state section
   DB    ACUTE_LOWER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_AC_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    7                             ;; number of entries
   DB    19,0EAH                       ;; r ACUTE
   DB    21,0ABH                       ;; z ACUTE
   DB    31,098H                       ;; s ACUTE
   DB    38,092H                       ;; l ACUTE
   DB    44,0ECH                       ;; y ACUTE
   DB    46,086H                       ;; c ACUTE
   DB    49,0E4H                       ;; n ACUTE
CP852_AC_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_AC_LO_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_AC_UP_END-$             ;; length of state section
   DB    ACUTE_UPPER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_AC_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    11                            ;; number of entries
   DB    19,0E8H                       ;; R ACUTE
   DB    21,08DH                       ;; Z ACUTE
   DB    22,0E9H                       ;; U ACUTE
   DB    23,0D6H                       ;; I ACUTE
   DB    24,0E0H                       ;; O ACUTE
   DB    30,0B5H                       ;; A ACUTE
   DB    31,097H                       ;; S ACUTE
   DB    38,091H                       ;; L ACUTE
   DB    44,0EDH                       ;; Y ACUTE
   DB    46,08FH                       ;; C ACUTE
   DB    49,0E3H                       ;; N ACUTE
CP852_AC_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_AC_UP_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: P12_KB+ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_AC_SP_END-$             ;; length of state section
   DB    ACUTE_SPACE                ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_AC_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0EFH                       ;; error character = standalone accent
CP852_AC_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
CP852_AC_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Lower Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_DC_LO_END-$             ;; length of state section
   DB    DOUBLEACUTE_LOWER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F1H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_DC_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    22,0FBH                       ;; u DOUBLEACUTE
   DB    24,08BH                       ;; o DOUBLEACUTE
CP852_DC_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_DC_LO_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Upper Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_DC_UP_END-$             ;; length of state section
   DB    DOUBLEACUTE_UPPER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F1H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_DC_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    22,0EBH                       ;; U DOUBLEACUTE
   DB    24,08AH                       ;; O DOUBLEACUTE
CP852_DC_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_DC_UP_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Space
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_DC_SP_END-$             ;; length of state section
;;   DB    DOUBLEACUTE_SPACE                   ;; State ID
;;   DW    ANY_KB                          ;; Keyboard Type
;;   DB    0F1H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_DC_SP_T1_END-$        ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of entries
;;   DB    57,0F1H                       ;; DOUBLEACUTE SPACE
;;CP852_DC_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_DC_SP_END:                       ;;
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_DI_UP_END-$             ;; length of state section
   DB    DIARESIS_UPPER                ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
                                       ;;
   DW    CP852_DI_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    18,0D3H                       ;;    E Diaeresis
CP852_DI_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_DI_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Lower Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_CE_LO_END-$             ;; length of state section
   DB    CEDILLA_LOWER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_CE_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    20,0EEH                       ;; t CEDILLA
   DB    31,0ADH                       ;; s CEDILLA
CP852_CE_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_CE_LO_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Upper Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_CE_UP_END-$             ;; length of state section
   DB    CEDILLA_UPPER                   ;; State ID
   DW    ANY_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_CE_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    20,0DDH                       ;; T CEDILLA
   DB    31,0B8H                       ;; S CEDILLA
CP852_CE_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_CE_UP_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Space
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_CE_SP_END-$             ;; length of state section
;;   DB    CEDILLA_SPACE                   ;; State ID
;;   DW    ANY_KB                          ;; Keyboard Type
;;   DB    0F7H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_CE_SP_T1_END-$        ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of entries
;;   DB    57,0F7H                       ;; CEDILLA SPACE
;;CP852_CE_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_CE_SP_END:                       ;;
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    0                             ;; LAST STATE
                                       ;;
CP852_XLAT_END:                        ;;  END OF CP852 SECTION
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
CODE     ENDS                          ;;  END OF PROGRAM
         END                           ;;
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kbd2\kdfpl.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
       PAGE    ,132
        TITLE   MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Definition File
;;
;; This file contains the keyboard tables for:
;; Poland
;; which form the Multilingual (ML) Group 2.
;;
;; Linkage Instructions:
;;      Refer to KDF.ASM.
;;
;;
;; WRITTEN:    Michael J. Saunders 2.OCTOBER 1987
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        INCLUDE KEYBSHAR.INC           ;;
	INCLUDE POSTEQU.INC	       ;;
        INCLUDE KEYBMAC.INC            ;;
                                       ;;
        PUBLIC PL_LOGIC                ;;
        PUBLIC PL_850_XLAT             ;;
        PUBLIC PL_852_XLAT             ;;
                                       ;;
CODE    SEGMENT PUBLIC 'CODE'          ;;
        ASSUME CS:CODE,DS:CODE         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a linear search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
STANDARD_TABLE      EQU   TYPE_2_TAB+ASCII_ONLY
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; PL State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
                                       ;;
PL_LOGIC:                              ;;
                                       ;;
   DW  LOGIC_END-$                     ;; length
                                       ;;
   DW  0                               ;; special features
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   OPTION EXIT_IF_FOUND                ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;  ***BD - THIS SECTION HAS BEEN UPDATED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFKBD G_KB                             ;;P12_KB - ONLY VALID FOR ENHANCED KB
                                       ;;
 IFF EITHER_CTL,NOT                    ;;
    IFF EITHER_ALT,NOT                 ;;
      IFF EITHER_SHIFT                 ;;
          SET_FLAG DEAD_UPPER          ;;
      ELSEF                            ;;
          SET_FLAG DEAD_LOWER          ;;
      ENDIFF                           ;;
    ELSEF                              ;;
      IFF R_ALT_SHIFT                  ;;
      ANDF EITHER_SHIFT,NOT            ;;
         SET_FLAG DEAD_THIRD           ;;
      ENDIFF                           ;;
    ENDIFF                             ;;
 ENDIFF                                ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
ACUTE_PROC:                            ;;
                                       ;;
   IFF ACUTE,NOT                       ;;
      GOTO CEDILLA_PROC                ;;
      ENDIFF                           ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT ACUTE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
         IFF EITHER_SHIFT              ;;
            IFF CAPS_STATE             ;;
               XLATT ACUTE_LOWER       ;;
            ELSEF                      ;;
               XLATT ACUTE_UPPER       ;;
            ENDIFF                     ;;
         ELSEF                         ;;
            IFF CAPS_STATE             ;;
               XLATT ACUTE_UPPER       ;;
            ELSEF                      ;;
               XLATT ACUTE_LOWER       ;;
            ENDIFF                     ;;
         ENDIFF                        ;;
      ENDIFF                           ;;
                                       ;;
INVALID_ACUTE:                         ;;
      PUT_ERROR_CHAR ACUTE_SPACE       ;; If we get here then either the XLATT
      BEEP                             ;; failed or we are ina bad shift state.
      GOTO NON_DEAD                    ;; Either is invalid so BEEP and fall
                                       ;; through to generate the second char.
                                       ;; Note that the dead key flag will be
                                       ;; reset before we get here.
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CEDILLA ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
CEDILLA_PROC:                          ;;
                                       ;;
   IFF CEDILLA,NOT                     ;;
      GOTO DIARESIS_PROC               ;;
      ENDIFF                           ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT CEDILLA_SPACE           ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
         IFF EITHER_SHIFT              ;;
            IFF CAPS_STATE             ;;
               XLATT CEDILLA_LOWER     ;;
            ELSEF                      ;;
               XLATT CEDILLA_UPPER     ;;
            ENDIFF                     ;;
         ELSEF                         ;;
            IFF CAPS_STATE             ;;
               XLATT CEDILLA_UPPER     ;;
            ELSEF                      ;;
               XLATT CEDILLA_LOWER     ;;
            ENDIFF                     ;;
         ENDIFF                        ;;
      ENDIFF                           ;;
                                       ;;
INVALID_CEDILLA:                       ;;
      PUT_ERROR_CHAR CEDILLA_LOWER     ;; If we get here then either the XLATT
      BEEP                             ;; failed or we are ina bad shift state.
      GOTO NON_DEAD                    ;; Either is invalid so BEEP and fall
                                       ;; through to generate the second char.
                                       ;; Note that the dead key flag will be
                                       ;; reset before we get here.
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
DIARESIS_PROC:                         ;;
                                       ;;
   IFF DIARESIS,NOT                    ;;
      GOTO GRAVE_PROC                  ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT DIARESIS_SPACE          ;;  exist for 850 so beep for
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
         IFF EITHER_SHIFT              ;;
            IFF CAPS_STATE             ;;
               XLATT DIARESIS_LOWER    ;;
            ELSEF                      ;;
               XLATT DIARESIS_UPPER    ;;
            ENDIFF                     ;;
         ELSEF                         ;;
            IFF CAPS_STATE             ;;
               XLATT DIARESIS_UPPER    ;;
            ELSEF                      ;;
               XLATT DIARESIS_LOWER    ;;
            ENDIFF                     ;;
         ENDIFF                        ;;
      ENDIFF                           ;;
                                       ;;
INVALID_DIARESIS:                      ;;
      PUT_ERROR_CHAR DIARESIS_LOWER    ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
GRAVE_PROC:                            ;;
                                       ;;
   IFF GRAVE,NOT                       ;;
      GOTO TILDE_PROC                  ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT GRAVE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT GRAVE_LOWER        ;;
           ELSEF                       ;;
              XLATT GRAVE_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT GRAVE_LOWER        ;;
           ELSEF                       ;;
              XLATT GRAVE_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_GRAVE:                         ;;
      PUT_ERROR_CHAR GRAVE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TILDE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TILDE_PROC:                            ;;
                                       ;;
   IFF TILDE,NOT                       ;;
      GOTO CIRCUMFLEX_PROC             ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT TILDE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT TILDE_LOWER        ;;
           ELSEF                       ;;
              XLATT TILDE_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE              ;;
              XLATT TILDE_UPPER        ;;
           ELSEF                       ;;
              XLATT TILDE_LOWER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
INVALID_TILDE:                         ;;
      PUT_ERROR_CHAR TILDE_LOWER       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
CIRCUMFLEX_PROC:                       ;;
                                       ;;
   IFF CIRCUMFLEX,NOT                  ;;
      GOTO CARON_PROC                  ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT CIRCUMFLEX_LOWER   ;;
           ELSEF                       ;;
              XLATT CIRCUMFLEX_UPPER   ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT CIRCUMFLEX_LOWER   ;;
           ELSEF                       ;;
              XLATT CIRCUMFLEX_UPPER   ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_CIRCUMFLEX:                    ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CARON ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
CARON_PROC:                            ;;
                                       ;;
   IFF CARON,NOT                       ;;
      GOTO BREVE_PROC                  ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT CARON_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT CARON_LOWER        ;;
           ELSEF                       ;;
              XLATT CARON_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT CARON_LOWER        ;;
           ELSEF                       ;;
              XLATT CARON_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_CARON:                         ;;
      PUT_ERROR_CHAR CARON_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BREVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
BREVE_PROC:                            ;;
                                       ;;
   IFF BREVE,NOT                       ;;
      GOTO OVERCIRCLE_PROC             ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT BREVE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT BREVE_LOWER        ;;
           ELSEF                       ;;
              XLATT BREVE_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT BREVE_LOWER        ;;
           ELSEF                       ;;
              XLATT BREVE_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_BREVE:                         ;;
      PUT_ERROR_CHAR BREVE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OVERCIRCLE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
OVERCIRCLE_PROC:                            ;;
                                       ;;
   IFF OVERCIRCLE,NOT                       ;;
      GOTO OGONEK_PROC             ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT OVERCIRCLE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT OVERCIRCLE_LOWER        ;;
           ELSEF                       ;;
              XLATT OVERCIRCLE_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT OVERCIRCLE_LOWER        ;;
           ELSEF                       ;;
              XLATT OVERCIRCLE_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_OVERCIRCLE:                         ;;
      PUT_ERROR_CHAR OVERCIRCLE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OGONEK ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
OGONEK_PROC:                            ;;
                                       ;;
   IFF OGONEK,NOT                       ;;
      GOTO OVERDOT_PROC             ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT OGONEK_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT OGONEK_LOWER        ;;
           ELSEF                       ;;
              XLATT OGONEK_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT OGONEK_LOWER        ;;
           ELSEF                       ;;
              XLATT OGONEK_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_OGONEK:                         ;;
      PUT_ERROR_CHAR OGONEK_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OVERDOT ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
OVERDOT_PROC:                            ;;
                                       ;;
   IFF OVERDOT,NOT                       ;;
      GOTO DOUBLEACUTE_PROC             ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT OVERDOT_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT OVERDOT_LOWER        ;;
           ELSEF                       ;;
              XLATT OVERDOT_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT OVERDOT_LOWER        ;;
           ELSEF                       ;;
              XLATT OVERDOT_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_OVERDOT:                         ;;
      PUT_ERROR_CHAR OVERDOT_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DOUBLEACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
DOUBLEACUTE_PROC:                            ;;
                                       ;;
   IFF DOUBLEACUTE,NOT                       ;;
      GOTO NON_DEAD                  ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT DOUBLEACUTE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT DOUBLEACUTE_LOWER        ;;
           ELSEF                       ;;
              XLATT DOUBLEACUTE_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT DOUBLEACUTE_LOWER        ;;
           ELSEF                       ;;
              XLATT DOUBLEACUTE_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_DOUBLEACUTE:                         ;;
      PUT_ERROR_CHAR DOUBLEACUTE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;; ***BD - NON_DEAD THRU LOGIC_END IS UPDATED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NON_DEAD:                              ;;
                                       ;;
   IFKBD G_KB                          ;; Avoid accidentally translating
   ANDF LC_E0                          ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC                 ;;   G keyboard
   ENDIFF                              ;;
                                       ;;
 IFF  EITHER_CTL,NOT                   ;; Lower and upper case.  Alphabetic
    IFF EITHER_ALT,NOT                 ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT                 ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
          IFF NUM_STATE,NOT            ;;
              XLATT NUMERIC_PAD        ;;
          ENDIFF                       ;;
;;***BD END OF ADDITION
          XLATT NON_ALPHA_UPPER        ;;
          IFF CAPS_STATE               ;;
              XLATT ALPHA_LOWER        ;;
          ELSEF                        ;;
              XLATT ALPHA_UPPER        ;;
          ENDIFF                       ;;
      ELSEF                            ;;
;;***BD ADDED FOR NUMERIC PAD
          IFF NUM_STATE                ;;
              XLATT NUMERIC_PAD        ;;
          ENDIFF                       ;;
;;***BD END OF ADDITION
          XLATT NON_ALPHA_LOWER        ;;
          IFF CAPS_STATE               ;;
             XLATT ALPHA_UPPER         ;;
          ELSEF                        ;;
             XLATT ALPHA_LOWER         ;;
          ENDIFF                       ;;
      ENDIFF                           ;; Third and Fourth shifts
    ELSEF                              ;; ctl off, alt on at this point
         IFF R_ALT_SHIFT               ;; ALTGr
         ANDF EITHER_SHIFT,NOT         ;;
            XLATT THIRD_SHIFT          ;;
         ENDIFF                        ;;
    ENDIFF                             ;;
 ENDIFF                                ;;
;**************************************;;
 IFF EITHER_SHIFT,NOT                  ;;
     IFF EITHER_CTL                    ;;
     ANDF ALT_SHIFT                    ;;
       IFF R_ALT_SHIFT,NOT             ;;
         XLATT ALT_CASE                ;;
       ENDIFF                          ;;
     ENDIFF                            ;;
 ENDIFF                                ;;
;**************************************;;
      IFF EITHER_CTL,NOT               ;;
         IFF ALT_SHIFT                 ;; ALT - case
         ANDF R_ALT_SHIFT,NOT          ;;
            XLATT ALT_CASE             ;;
         ENDIFF                        ;;
      ELSEF                            ;;
         IFF EITHER_ALT,NOT            ;; CTRL - case
            XLATT CTRL_CASE            ;;
         ENDIFF                        ;;
      ENDIFF                           ;;
ENDIFF                                 ;;
                                       ;;
 EXIT_STATE_LOGIC                      ;;
                                       ;;
LOGIC_END:                             ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;**********************************************************************
;; PL Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; Some common Characters are included from 128 - 165 where appropriate.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
 PUBLIC PL_COMMON_XLAT                 ;;
PL_COMMON_XLAT:                        ;;
                                       ;;
   DW     COMMON_XLAT_END-$            ;; length of section
   DW     -1                           ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: low shift Dead_lower
;; KEYBOARD TYPES: G
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_PL_LO_END-$               ;; length of state section
   DB    DEAD_LOWER                    ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;; Set Flag Table
   DW    1                             ;; number of entries
   DB    41                            ;;
   FLAG  OGONEK                        ;;
                                       ;;
COM_PL_LO_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: low shift Dead_UPPER
;; KEYBOARD TYPES: G
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_PL_UP_END-$               ;; length of state section
   DB    DEAD_UPPER                    ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;; Set Flag Table
   DW    1                             ;; number of entries
   DB    41                            ;;
   FLAG  OVERDOT                       ;;
                                       ;;
COM_PL_UP_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Third Shift Dead Key
;; KEYBOARD TYPES: G
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_PL_TH_END-$               ;; length of state section
   DB    DEAD_THIRD                    ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;; Set Flag Table
   DW    11                            ;; number of entries
;; DB    2                             ;; TILDE IS NOT AN ACCENT KEY
;; FLAG  TILDE                         ;;
   DB    3                             ;;
   FLAG  CARON                         ;;
   DB    4                             ;;
   FLAG  CIRCUMFLEX                    ;;
   DB    5                             ;;
   FLAG  BREVE                         ;;
   DB    6                             ;;
   FLAG  OVERCIRCLE                    ;;
   DB    7                             ;;
   FLAG  OGONEK                        ;;
   DB    8                             ;;
   FLAG  GRAVE                         ;;
   DB    9                             ;;
   FLAG  OVERDOT                       ;;
   DB    10                            ;;
   FLAG  ACUTE                         ;;
   DB    11                            ;;
   FLAG  DOUBLEACUTE                   ;;
   DB    12                            ;;
   FLAG  DIARESIS                      ;;
   DB    13                            ;;
   FLAG  CEDILLA                       ;;
                                       ;;
COM_PL_TH_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;******************************
;;***BD - ADDED FOR NUMERIC PAD (DECIMAL SEPERATOR)
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Numeric Key Pad
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_PAD_K1_END-$              ;; length of state section
   DB    NUMERIC_PAD                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_PAD_K1_T1_END-$           ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB    83,','                        ;; decimal seperator = ,
COM_PAD_K1_T1_END:                     ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_PAD_K1_END:                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;******************************
;;***BD - ADDED FOR ALT CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Alt Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_ALT_K1_END-$              ;; length of state section
   DB    ALT_CASE                      ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_ALT_K1_T1_END-$           ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    3                             ;; number of entries
   DB    21,0,2CH                      ;;
   DB    44,0,15H                      ;;
   DB    53,0,82H                      ;;
COM_ALT_K1_T1_END:                     ;;
                                       ;;
    DW    0                            ;; Size of xlat table - null table
                                       ;;
COM_ALT_K1_END:                        ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CTRL_K2_END-$             ;; length of state section
   DB    CTRL_CASE                     ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_CTRL_K2_T1_END-$          ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    3                             ;; number of entries
   DB    21,01AH,2CH                   ;;
   DB    44,019H,15H                   ;;
   DB    53,01FH,0CH                   ;;
COM_CTRL_K2_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CTRL_K2_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_AL_LO_K1_END-$            ;; length of state section
   DB    ALPHA_LOWER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_AL_LO_K1_T1_END-$         ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    2                             ;; number of entries
   DB    21,"z",2CH                    ;;
   DB    44,"y",15H                    ;;
COM_AL_LO_K1_T1_END:                   ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_AL_LO_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_AL_UP_K1_END-$            ;; length of state section
   DB    ALPHA_UPPER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_AL_UP_K1_T1_END-$         ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    2                             ;; number of entries
   DB    21,"Z",2CH                    ;;
   DB    44,"Y",15H                    ;;
COM_AL_UP_K1_T1_END:                   ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_AL_UP_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_NA_LO_K1_END-$            ;; length of state section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_NA_LO_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    4                             ;; number of entries
   DB    12,"+"                        ;; '
   DB    13,"'"                        ;;
   DB    86,"<"                        ;; <
   DB    53,"-"                        ;; -
COM_NA_LO_K1_T1_END:                   ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_NA_LO_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_NA_UP_K1_END-$            ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_NA_UP_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    12                            ;; number of entries
   DB     3,'"'                        ;;
   DB     7,'&'                        ;;
   DB     8,'/'                        ;;
   DB     9,'('                        ;;
   DB    10,')'                        ;;
   DB    11,'='                        ;;
   DB    12,'?'                        ;;
   DB    13,"*"                        ;;
   DB    86,'>'                        ;;
   DB    51,';'                        ;;
   DB    52,':'                        ;;
   DB    53,'_'                        ;;
COM_NA_UP_K1_T1_END:                   ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_NA_UP_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Third Shift
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_THIRD_END-$               ;; length of state section
   DB    THIRD_SHIFT                   ;; State ID
   DW    G_KB                          ;; Keyboard Type FERRARI
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_THIRD_T1_END-$            ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    12                            ;; number of entries
   DB     2,'~',02H                    ;;
   DB    16,'\',10H                    ;;
   DB    17,'|',11H                    ;;
   DB    26,'',1AH                    ;;
   DB    33,'[',21H                    ;;
   DB    34,']',22H                    ;;
   DB    39,'$',27H                    ;;
   DB    40,0E1H,28H                    ;; SHARP S
   DB    47,'@',2FH                    ;;
   DB    48,'{',30H                    ;;
   DB    49,'}',31H                    ;;
   DB    50,15H,32H                    ;;
COM_THIRD_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Last xlat table
COM_THIRD_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Caron Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CA_SP_END-$             ;; length of state section
   DB    CARON_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F3H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_CA_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F3H                       ;; Caron Space
COM_CA_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CA_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Breve Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_BR_SP_END-$             ;; length of state section
   DB    BREVE_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F4H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_BR_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F4H                       ;; BREVE SPACE
COM_BR_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_BR_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Ogonek Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_OG_SP_END-$             ;; length of state section
   DB    OGONEK_SPACE                  ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F2H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_OG_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F2H                       ;; OGONEK SPACE
COM_OG_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_OG_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Double Acute Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_DC_SP_END-$             ;; length of state section
   DB    DOUBLEACUTE_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F1H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_DC_SP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of entries
   DB    57,0F1H                       ;; DOUBLEACUTE SPACE
COM_DC_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_DC_SP_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CI_LO_END-$               ;; length of state section
   DB    CIRCUMFLEX_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    94,0                          ;; error character = standalone accent
                                       ;;
   DW    COM_CI_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    3                             ;; number of scans
   DB    23,''                        ;;  "    "  ,  "   - i
   DB    24,''                        ;; scan code,ASCII - o
   DB    30,''                        ;; scan code,ASCII - a
COM_CI_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;;
                                       ;;
COM_CI_LO_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CI_SP_END-$               ;; length of state section
   DB    CIRCUMFLEX_SPACE              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    94,0                          ;; error character = standalone accent
                                       ;;
   DW    COM_CI_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,94                         ;; STANDALONE CIRCUMFLEX
COM_CI_SP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CI_SP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Overcircle Space Bar
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_OC_SP_END-$               ;; length of state section
   DB    OVERCIRCLE_SPACE              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_OC_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F8H                       ;; STANDALONE OVERCIRCLE
COM_OC_SP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_OC_SP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Grave Space Bar
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_GR_SP_END-$               ;; length of state section
   DB    GRAVE_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    96,0                          ;; error character = standalone accent
                                       ;;
   DW    COM_GR_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,96                         ;; STANDALONE GRAVE
COM_GR_SP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_GR_SP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Overdot
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ;;
    DW    COM_OD_SP_END-$               ;; length of state section
    DB    OVERDOT_SPACE                 ;; State ID
    DW    G_KB                          ;; Keyboard Type
    DB    0FAH,0                        ;; error character = standalone accent
                                        ;;
    DW    COM_OD_SP_T1_END-$            ;; Size of xlat table
    DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
    DB    1                             ;; number of scans
    DB    57,0FAH                       ;; STANDALONE OVERDOT
COM_OD_SP_T1_END:                       ;;
                                        ;;
    DW    0                             ;;
                                        ;;
COM_OD_SP_END:                          ;;
                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_AC_LO_END-$               ;; length of state section
   DB    ACUTE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_AC_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    5                             ;; number of entries
   DB    18,082H                       ;;    e acute
   DB    22,0A3H                       ;;    u acute
   DB    23,0A1H                       ;;    i acute
   DB    24,0A2H                       ;;    o acute
   DB    30,0A0H                       ;;    a acute
COM_AC_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_AC_LO_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_AC_UP_END-$               ;; length of state section
   DB    ACUTE_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_AC_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of entries
   DB    18,090H                       ;;    E acute
COM_AC_UP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_AC_UP_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_AC_SP_END-$             ;; length of state section
   DB    ACUTE_SPACE                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    027H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_AC_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,027H                        ;; error character = standalone accent
COM_AC_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
COM_AC_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Cedilla Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CE_LO_END-$               ;; length of state section
   DB    CEDILLA_LOWER                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_CE_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    46,''                        ;; scan code,ASCII - 
COM_CE_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CE_LO_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Cedilla Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CE_UP_END-$               ;; length of state section
   DB    CEDILLA_UPPER                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_CE_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    46,''                        ;;     CEDILLA
COM_CE_UP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CE_UP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Cedilla Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CE_SP_END-$             ;; length of state section
   DB    CEDILLA_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_CE_SP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of entries
   DB    57,0F7H                       ;; CEDILLA SPACE
COM_CE_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CE_SP_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_DI_LO_END-$               ;; length of state section
   DB    DIARESIS_LOWER                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
                                       ;;
   DW    COM_DI_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    4                             ;; number of scans
   DB    18,''                        ;; scan code,ASCII - e
   DB    22,''                        ;; scan code,ASCII - u
   DB    24,''                        ;; scan code,ASCII - o
   DB    30,''                        ;; scan code,ASCII - a
COM_DI_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_DI_LO_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_DI_UP_END-$               ;; length of state section
   DB    DIARESIS_UPPER                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
                                       ;;
   DW    COM_DI_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    3                             ;; number of scans
   DB    22,''                        ;;    U Diaeresis
   DB    24,''                        ;;    O Diaeresis
   DB    30,''                        ;;    A Diaeresis
COM_DI_UP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_DI_UP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_DI_SP_END-$             ;; length of state section
   DB    DIARESIS_SPACE                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
                                       ;;
   DW    COM_DI_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,249                        ;; error character = standalone accent
COM_DI_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
COM_DI_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW    0                             ;; Last State
COMMON_XLAT_END:                       ;;  END OF COMMON SECTION
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CODE PAGE 850 MULTILINGUAL 2  SPECIFIC TRANSLATION
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
 PUBLIC PL_850_XLAT                    ;;
PL_850_XLAT:                           ;;
                                       ;;
    DW   CP850_XLAT_END-$              ;;
    DW   850                           ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_NA_LO_K1_END-$            ;; length of state section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP850_NA_LO_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB     5,-1                         ;; CURRENCY SYMBOL
CP850_NA_LO_K1_T1_END:                   ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_NA_LO_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_NA_UP_K1_END-$            ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP850_NA_UP_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB     5,-1                         ;; CURRENCY SYMBOL
CP850_NA_UP_K1_T1_END:                   ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_NA_UP_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_AL_LO_END-$             ;; length of state section
   DB    ALPHA_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; error character = standalone accent
                                       ;;
   DW    CP850_AL_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB    27,-1                         ;; BLOT OUT CHAR UNDER 850
CP850_AL_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_AL_LO_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_AL_UP_END-$             ;; length of state section
   DB    ALPHA_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; error character = standalone accent
                                       ;;
   DW    CP850_AL_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB    27,-1                         ;; BLOT OUT CHAR UNDER 850
CP850_AL_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_AL_UP_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_CI_LO_END-$               ;; length of state section
   DB    CIRCUMFLEX_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    94,0                          ;; error character = standalone accent
                                       ;;
   DW    CP850_CI_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of scans
   DB    18,88H                        ;;  e CIRCUMFLEX
   DB    23,8CH                        ;;  i CIRCUMFLEX
CP850_CI_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;;
                                       ;;
CP850_CI_LO_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Overcircle Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_OC_LO_END-$               ;; length of state section
   DB    OVERCIRCLE_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP850_OC_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,86H                        ;; a OVERCIRCLE
CP850_OC_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_OC_LO_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Overcircle Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_OC_UP_END-$               ;; length of state section
   DB    OVERCIRCLE_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP850_OC_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,8FH                        ;; A OVERCIRCLE
CP850_OC_UP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_OC_UP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Grave Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_GR_LO_END-$               ;; length of state section
   DB    GRAVE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    060H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP850_GR_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    5                             ;; number of scans
   DB    18,8AH                        ;; e GRAVE
   DB    22,97H                        ;; u GRAVE
   DB    23,8DH                        ;; i GRAVE
   DB    24,95H                        ;; o GRAVE
   DB    30,85H                        ;; a GRAVE
CP850_GR_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_GR_LO_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_DI_LO_END-$             ;; length of state section
   DB    DIARESIS_LOWER                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    0FEH,0                         ;; error character = standalone accent
                                       ;;
   DW    CP850_DI_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    16,8BH                        ;; i DIARESIS
CP850_DI_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
CP850_DI_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_DI_SP_END-$             ;; length of state section
   DB    DIARESIS_SPACE                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    0FEH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP850_DI_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0FEH,0                     ;; error character = standalone accent
CP850_DI_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
CP850_DI_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_OG_SP_END-$             ;; length of state section
   DB    OGONEK_SPACE                  ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0FEH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP850_OG_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0FEH                       ;; OGONEK SPACE
CP850_OG_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_OG_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW    0                             ;; LAST STATE
                                       ;;
CP850_XLAT_END:                        ;; END OF CP850 SECTION
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CODE PAGE 852 MULTILINGUAL 2  SPECIFIC TRANSLATION
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
 PUBLIC PL_852_XLAT                    ;;
PL_852_XLAT:                           ;;
                                       ;;
    DW     CP852_XLAT_END-$            ;;
    DW     852                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_AL_LO_END-$           ;; length of state section
   DB    ALPHA_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP852_AL_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    5                             ;; number of entries
   DB    26,0BEH                       ;; z OVERDOT
   DB    27,098H                       ;; s ACUTE
   DB    39,088H                       ;; l STROKE
   DB    40,0A5H                       ;; a OGONEK
   DB    43,0A2H                       ;; o ACUTE
CP852_AL_LO_T1_END:                  ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_AL_LO_END:                     ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_AL_UP_END-$           ;; length of state section
   DB    ALPHA_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP852_AL_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    5                             ;; number of entries
   DB    26,0E4H                       ;; n ACUTE
   DB    27,086H                       ;; c ACUTE
   DB    39,09DH                       ;; L STROKE
   DB    40,0A9H                       ;; e OGONEK
   DB    43,0ABH                       ;; z ACUTE
CP852_AL_UP_T1_END:                  ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_AL_UP_END:                     ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Third Shift
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_THIRD_END-$               ;; length of state section
   DB    THIRD_SHIFT                   ;; State ID
   DW    G_KB                          ;; Keyboard Type FERRARI
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP852_THIRD_T1_END-$            ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    3                             ;; number of entries
   DB    27,09EH,1BH                   ;;
   DB    31,0D0H,1FH                   ;; d STROKE
   DB    32,0D1H,20H                   ;; D STROKE
CP852_THIRD_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Last xlat table
CP852_THIRD_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP852
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_NA_LO_K1_END-$            ;; length of state section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP852_NA_LO_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB    13,027H                       ;; APOSTROPHE
CP852_NA_LO_K1_T1_END:                   ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_NA_LO_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP852
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_NA_UP_K1_END-$            ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP852_NA_UP_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    2                             ;; number of entries
   DB     5,0CFH                       ;; CURRENCY SYMBOL
   DB    13,02AH                       ;; ASTERISK
CP852_NA_UP_K1_T1_END:                   ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_NA_UP_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_CA_LO_END-$             ;; length of state section
   DB    CARON_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F3H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_CA_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    9                             ;; number of scans
   DB    18,0D8H                       ;; e CARON
   DB    19,0FDH                       ;; r CARON
   DB    20,09CH                       ;; t CARON
   DB    21,0A7H                       ;; z CARON
   DB    31,0E7H                       ;; s CARON
   DB    32,0D4H                       ;; d CARON
   DB    38,096H                       ;; l CARON
   DB    46,09FH                       ;; c CARON
   DB    49,0E5H                       ;; n CARON
CP852_CA_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_CA_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_CA_UP_END-$             ;; length of state section
   DB    CARON_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F3H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_CA_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    9                             ;; number of scans
   DB    18,0B7H                       ;; E CARON
   DB    19,0FCH                       ;; R CARON
   DB    20,09BH                       ;; T CARON
   DB    21,0A6H                       ;; Z CARON
   DB    31,0E6H                       ;; S CARON
   DB    32,0D2H                       ;; D CARON
   DB    38,095H                       ;; L CARON
   DB    46,0ACH                       ;; C CARON
   DB    49,0D5H                       ;; N CARON
CP852_CA_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_CA_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_CA_SP_END-$             ;; length of state section
;;   DB    CARON_SPACE                   ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F3H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_CA_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F3H                       ;; e CARON
;;CP852_CA_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_CA_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Circumflex Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_CI_UP_END-$             ;; length of state section
   DB    CIRCUMFLEX_UPPER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    05EH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_CI_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    3                             ;; number of scans
   DB    23,0D7H                       ;; I CIRCUMFLEX
   DB    24,0E2H                       ;; O CIRCUMFLEX
   DB    30,0B6H                       ;; A CIRCUMFLEX
CP852_CI_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_CI_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_BR_LO_END-$             ;; length of state section
   DB    BREVE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F4H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_BR_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,0C7H                       ;; a BREVE
CP852_BR_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_BR_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_BR_UP_END-$             ;; length of state section
   DB    BREVE_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F4H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_BR_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,0C6H                       ;; A BREVE
CP852_BR_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_BR_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_BR_SP_END-$             ;; length of state section
;;   DB    BREVE_SPACE                   ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F4H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_BR_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F4H                       ;; BREVE SPACE
;;CP852_BR_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_BR_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overcirle Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OC_LO_END-$             ;; length of state section
   DB    OVERCIRCLE_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OC_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    22,085H                       ;; u OVERCIRCLE
CP852_OC_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OC_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overcircle Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OC_UP_END-$             ;; length of state section
   DB    OVERCIRCLE_UPPER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OC_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    22,0DEH                       ;; O OVERCIRCLE
CP852_OC_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OC_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OG_LO_END-$             ;; length of state section
   DB    OGONEK_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F2H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OG_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of scans
   DB    18,0A9H                       ;; e OGONEK
   DB    30,0A5H                       ;; a OGONEK
CP852_OG_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OG_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OG_UP_END-$             ;; length of state section
   DB    OGONEK_UPPER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F2H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OG_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of scans
   DB    18,0A8H                       ;; E OGONEK
   DB    30,0A4H                       ;; A OGONEK
CP852_OG_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OG_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_OG_SP_END-$             ;; length of state section
;;   DB    OGONEK_SPACE                  ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F2H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_OG_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F2H                       ;; OGONEK SPACE
;;CP852_OG_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_OG_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overdot Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OD_LO_END-$             ;; length of state section
   DB    OVERDOT_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0FAH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OD_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    21,0BEH                       ;; z OVERDOT
CP852_OD_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OD_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overdot Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OD_UP_END-$             ;; length of state section
   DB    OVERDOT_UPPER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0FAH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OD_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    21,0BDH                       ;; Z OVERDOT
CP852_OD_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OD_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_AC_LO_END-$             ;; length of state section
   DB    ACUTE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_AC_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    7                             ;; number of entries
   DB    19,0EAH                       ;; r ACUTE
   DB    21,0ABH                       ;; z ACUTE
   DB    31,098H                       ;; s ACUTE
   DB    38,092H                       ;; l ACUTE
   DB    44,0ECH                       ;; y ACUTE
   DB    46,086H                       ;; c ACUTE
   DB    49,0E4H                       ;; n ACUTE
CP852_AC_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_AC_LO_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_AC_UP_END-$             ;; length of state section
   DB    ACUTE_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_AC_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    11                            ;; number of entries
   DB    19,0E8H                       ;; R ACUTE
   DB    21,08DH                       ;; Z ACUTE
   DB    22,0E9H                       ;; U ACUTE
   DB    23,0D6H                       ;; I ACUTE
   DB    24,0E0H                       ;; O ACUTE
   DB    30,0B5H                       ;; A ACUTE
   DB    31,097H                       ;; S ACUTE
   DB    38,091H                       ;; L ACUTE
   DB    44,0EDH                       ;; Y ACUTE
   DB    46,08FH                       ;; C ACUTE
   DB    49,0E3H                       ;; N ACUTE
CP852_AC_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_AC_UP_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_AC_SP_END-$             ;; length of state section
   DB    ACUTE_SPACE                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_AC_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0EFH                       ;; error character = standalone accent
CP852_AC_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
CP852_AC_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_DC_LO_END-$             ;; length of state section
   DB    DOUBLEACUTE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F1H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_DC_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    22,0FBH                       ;; u DOUBLEACUTE
   DB    24,08BH                       ;; o DOUBLEACUTE
CP852_DC_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_DC_LO_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_DC_UP_END-$             ;; length of state section
   DB    DOUBLEACUTE_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F1H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_DC_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    22,0EBH                       ;; U DOUBLEACUTE
   DB    24,08AH                       ;; O DOUBLEACUTE
CP852_DC_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_DC_UP_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_DC_SP_END-$             ;; length of state section
;;   DB    DOUBLEACUTE_SPACE                   ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F1H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_DC_SP_T1_END-$        ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of entries
;;   DB    57,0F1H                       ;; DOUBLEACUTE SPACE
;;CP852_DC_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_DC_SP_END:                       ;;
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_DI_UP_END-$             ;; length of state section
   DB    DIARESIS_UPPER                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
                                       ;;
   DW    CP852_DI_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    18,0D3H                       ;;    E Diaeresis
CP852_DI_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_DI_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_CE_LO_END-$             ;; length of state section
   DB    CEDILLA_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_CE_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    20,0EEH                       ;; t CEDILLA
   DB    31,0ADH                       ;; s CEDILLA
CP852_CE_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_CE_LO_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_CE_UP_END-$             ;; length of state section
   DB    CEDILLA_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_CE_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    20,0DDH                       ;; T CEDILLA
   DB    31,0B8H                       ;; S CEDILLA
CP852_CE_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_CE_UP_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_CE_SP_END-$             ;; length of state section
;;   DB    CEDILLA_SPACE                   ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F7H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_CE_SP_T1_END-$        ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of entries
;;   DB    57,0F7H                       ;; CEDILLA SPACE
;;CP852_CE_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_CE_SP_END:                       ;;
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    0                             ;; LAST STATE
                                       ;;
CP852_XLAT_END:                        ;;  END OF CP852 SECTION
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
CODE     ENDS                          ;;  END OF PROGRAM
         END                           ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kbd2\kdfnow.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
	PAGE  ,132
	TITLE MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Definition File
;;
;; This the file header and table pointers ONLY.
;; The actual tables are contained in seperate source files.
;; These are:
;;       KDFSP.ASM  - Spanish
;;       KDFPO.ASM  - Portuguese
;;       KDFGR.ASM  - German
;;       KDFIT142.ASM  - Italian
;;       KDFIT.ASM  - Italian
;;       KDFFR189.ASM  - French
;;       KDFFR.ASM  - French
;;       KDFSG.ASM  - Swiss German
;;       KDFSF.ASM  - Swiss French
;;       KDFDK.ASM  - Danish
;;       KDFUK168.ASM  - English
;;       KDFUK.ASM  - English
;;       KDFBE.ASM  - Belgium
;;       KDFNL.ASM  - Netherlands
;;       KDFNO.ASM  - Norway
;;       KDFLA.ASM  - Latin American
;;       KDFSV.ASM  - SWEDEN   -----> This moddule is used for both Sweden
;;            and Finland - exact same template
;;       KDFSU.ASM  - Finland  -----> Same module as Sweden eliminated
;;       KDFBR.ASM  - Brazil      [Mihindu 10/30/90 : added Brazil]
;;       KDFPL.ASM  - Poland      [Mihindu 11/30/90 : added Poland]
;;       KDFCZ.ASM  - Czech       [Mihindu 11/30/90 : added Czek]
;;       KDFSL.ASM  - Slovak      [Mihindu 11/30/90 : added Slovak]
;;       KDFHU.ASM  - Hungary     [Mihindu 11/30/90 : added Hungary]
;;       KDFYU.ASM  - Yugoslavia      [Mihindu 11/30/90 : added Yugoslavia]
;;           KDFRO.ASM  - Romanian          [ 02/24/93 : added Romanian ]
;;           KDFIC.ASM  - Iceland           [ 02/24/93 : added Iceland ]
;;           KDFJP.ASM  - JAPAN                    ;M000     ;JP9002, JP9009
;;       Dummy US - US
;; Linkage Instructions:
;;  The following instructions are contained in KDFLINK.BAT:
;;
;;  LINK KDF+KDFSP+KDFGE+KDFFR+KDFIT+KDFPO+KDFUK+KDFSG+KDFDK+KDFEOF;
;;  EXE2BIN KDF.EXE KEYBOARD.SYS
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;; Author:     NICK SAVAGE  - IBM Corp. - May 1986,87
;;
;; DCLove, March 8, 1988 - swapped 437/850 to 850/437 for SG & SF
;; DCLove, March 8, 1988 - uncommented SU(finland)& swapped 437/850 to 850/437
;;         as the Finnish want 850/437 vs. 437/850 for Sweden
;;         did not alter the pointer to kbid 153 to Sweden
;; CNS     April 14 1988 - swapped 437/850 to 850/437 for SP & LA
;; Kusuda  Feb. 1990     - Support Japanese keyboard.     ;M000         ;JP9002
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							 ;;
							 ;;
CODE  SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE         ;;
							 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; File Header
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
						 ;;
DB   0FFh,'KEYB   '                  ;; signature
DB   8 DUP(0)          ;; reserved
DW   0460H           ;; maximum size of Common Xlat Sect (650)
DW   01F0H           ;; max size of Specific Xlat Sect (350)
DW   0280H           ;; max size of State Logic (400)
DW   0             ;;AC000;reserved
;;  Number of IDs and languages incremented [Mihindu 10/30/90 : added Brazil]
;;  [Mihindu, 11/30/90 : added 5 more for Eastern Europe]
DW   22          ;;AC000 number of IDs
DW   23            ;M000    ;;AC000 number of languages
DB   'GR'                            ;; LANGUAGE CODE TABLE
DW   OFFSET GE_LANG_ENT,0      ;;
DB   'SP'                            ;;
DW   OFFSET SP_LANG_ENT,0      ;;
DB   'PO'                            ;;
DW   OFFSET PO_LANG_ENT,0      ;;
DB   'FR'                            ;;
DW   OFFSET FR2_LANG_ENT,0       ;;
DB   'DK'                            ;;
DW   OFFSET DK_LANG_ENT,0      ;;
;;DB   'SG'                            ;;
;;DW   OFFSET SG_LANG_ENT,0      ;;
DB   'IT'                            ;;
DW   OFFSET IT2_LANG_ENT,0       ;;
DB   'UK'                            ;;
DW   OFFSET UK2_LANG_ENT,0       ;;
;;DB   'SF'                            ;;
;;DW   OFFSET SF_LANG_ENT,0      ;;
DB   'BE'                            ;;
DW   OFFSET BE_LANG_ENT,0      ;;
DB   'NL'                            ;;
DW   OFFSET NL_LANG_ENT,0      ;;
DB   'NO'                            ;;
DW   OFFSET NO_LANG_ENT,0      ;;
DB   'CF'                            ;;
DW   OFFSET CF_LANG_ENT,0      ;;
DB   'SV'                            ;;
DW   OFFSET SV_LANG_ENT,0      ;;
DB   'SU'                            ;;
DW   OFFSET Su_LANG_ENT,0      ;;
DB   'LA'                            ;;
DW   OFFSET LA_LANG_ENT,0      ;;
DB   'BR'
DW   OFFSET BR_LANG_ENT,0      ;; [Mihindu 10/30/90 : added Brazil]
DB   'PL'
DW   OFFSET PL_LANG_ENT,0      ;; [Mihindu 11/30/90]
DB   'YU'
DW   OFFSET YU_LANG_ENT,0      ;; [Mihindu 11/30/90]
DB   'HU'
DW   OFFSET HU_LANG_ENT,0      ;; [Mihindu 11/30/90]
DB   'RO'
DW   OFFSET RO_LANG_ENT,0      ;;(YST)
DB   'IS'          ;;   sland !
DW   OFFSET IC_LANG_ENT,0      ;;
DB   'US'          ;;
DW   OFFSET DUMMY_ENT,0        ;;
;DB   'JP'            ;;M000        ;JP9002
;DW   OFFSET JP_LANG_ENT, 0       ;;M000        ;JP9002
DW    172          ;;AN000;ID CODE TABLE ***************************
DW   OFFSET SP_LANG_ENT,0      ;;AN000;
DW    163          ;;AN000;
DW   OFFSET PO_LANG_ENT,0      ;;AN000;
DW    120          ;;AN000;
DW   OFFSET FR1_LANG_ENT,0       ;;AN000;
DW    189          ;;AN000;
DW   OFFSET FR2_LANG_ENT,0       ;;AN000;
DW    159          ;;AN000;
DW   OFFSET DK_LANG_ENT,0      ;;AN000;
;;DW    000          ;;AN000;
;;DW   OFFSET SG_LANG_ENT,0      ;;AN000;
DW    129          ;;AN000;
DW   OFFSET GE_LANG_ENT,0      ;;AN000;
DW    142          ;;AN000;
DW   OFFSET IT1_LANG_ENT,0       ;;AN000;
DW    141          ;;AN000;
DW   OFFSET IT2_LANG_ENT,0       ;;AN000;
DW    168          ;;AN000;
DW   OFFSET UK1_LANG_ENT,0       ;;AN000;
DW    166          ;;AN000;
DW   OFFSET UK2_LANG_ENT,0       ;;AN000;
;;DW    150          ;;AN000;
;;DW   OFFSET SF_LANG_ENT,0      ;;AN000;
DW    120          ;;AN000;
DW   OFFSET BE_LANG_ENT,0      ;;AN000;
DW    143          ;;AN000;
DW   OFFSET NL_LANG_ENT,0      ;;AN000;
DW    155          ;;AN000;
DW   OFFSET NO_LANG_ENT,0      ;;AN000;
DW    058          ;;AN000;
DW   OFFSET CF_LANG_ENT,0      ;;AN000;
DW    153          ;;AN000;
DW   OFFSET SV_LANG_ENT,0      ;;AN000;
DW    171          ;;AN000;
DW   OFFSET LA_LANG_ENT,0      ;;AN000;
DW    161          ;;AN000;[ Added 03/09/93 for msdos6 supplemental disk]
DW   OFFSET IC_LANG_ENT,0      ;;AN000;
DW    275          ;;
DW   OFFSET BR2_LANG_ENT,0       ;; [ Verav : added Brazil IBM layout - Feb 92]
DW    274          ;;
DW   OFFSET BR_LANG_ENT,0      ;; [Mihindu 10/30/90 : added Brazil]
;DW    214
;DW   OFFSET PL_LANG_ENT,0       ;; [Mihindu 11/30/90]
;DW    243
;DW   OFFSET CZ_LANG_ENT,0       ;; [Mihindu 11/30/90]
;DW    245
;DW   OFFSET SL_LANG_ENT,0       ;; [Mihindu 11/30/90]
;DW    234
;DW   OFFSET YU_LANG_ENT,0       ;; [Mihindu 11/30/90]
;DW    208
;DW   OFFSET HU_LANG_ENT,0       ;; [Mihindu 11/30/90]
DW    103          ;;AN000;
DW   OFFSET DUMMY_ENT,0        ;;AN000;
;            ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; Language Entries
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							 ;;
	 EXTRN SP_LOGIC:NEAR           ;;
	 EXTRN SP_437_XLAT:NEAR        ;;
	 EXTRN SP_850_XLAT:NEAR        ;;
							 ;;
SP_LANG_ENT:             ;; language entry for SPANISH
	DB   'SP'                            ;;
	DW   172             ;; AN000;ID entry  (ID CODE)
	DW   OFFSET SP_LOGIC,0         ;; pointer to LANG kb table
	DB   1             ;; AN000;number of IDs
	DB   2             ;; number of code pages
	DW   850             ;; code page
	DW   OFFSET SP_850_XLAT,0        ;; table pointer
	DW   437             ;; code page
	DW   OFFSET SP_437_XLAT,0        ;; table pointer
							 ;;
;*****************************************************************************
		EXTRN FR1_LOGIC:NEAR     ;;AN000;
		EXTRN FR1_437_XLAT:NEAR    ;;AN000;
		EXTRN FR1_850_XLAT:NEAR    ;;AN000;
					 ;;
 FR1_LANG_ENT:         ;;AN000; language entry for FRANCE
	 DB 'FR'                             ;;AN000; SECONDARY KEYBOARD ID VALUE
	 DW 120        ;;AN000; ID entry
	 DW OFFSET FR1_LOGIC,0     ;;AN000; pointer to LANG kb table
	 DB 2        ;;AN000; number of code pages
	 DB 2        ;;AN000; number of ids
	 DW 437        ;;AN000; code page
	 DW OFFSET FR1_437_XLAT,0    ;;AN000; table pointer
	 DW 850        ;;AN000; code page
	 DW OFFSET FR1_850_XLAT,0    ;;AN000; table pointer
					 ;;AN000;
;*****************************************************************************
		EXTRN FR2_LOGIC:NEAR     ;;AC000;
		EXTRN FR2_437_XLAT:NEAR    ;;AC000;
		EXTRN FR2_850_XLAT:NEAR    ;;AC000;
					 ;;
 FR2_LANG_ENT:         ;; language entry for FRANCE
	 DB 'FR'                             ;; PRIMARY  KEYBOARD ID VALUE
	 DW 189        ;;AC000; ID entry
	 DW OFFSET FR2_LOGIC,0     ;;AC000; pointer to LANG kb table
	 DB 1        ;;AC000; number of ids
	 DB 2        ;;AC000; number of code pages
	 DW 437        ;;AC000; code page
	 DW OFFSET FR2_437_XLAT,0    ;;AC000; table pointer
	 DW 850        ;;AC000; code page
	 DW OFFSET FR2_850_XLAT,0    ;;AC000; table pointer
					 ;;
;****************************************************************************
	 EXTRN PO_LOGIC:NEAR       ;;AC000;
	 EXTRN PO_850_XLAT:NEAR    ;;AC000;
	 EXTRN PO_860_XLAT:NEAR    ;;AC000;
					 ;;
PO_LANG_ENT:         ;; language entry for PORTUGAL
	DB   'PO'                              ;;
	DW   163         ;;AN000; ID entry
	DW   OFFSET PO_LOGIC,0     ;; pointer to LANG kb table
	DB   1         ;;AC000; number of ids
	DB   2         ;;AC000; number of code pages
	DW   850         ;;AC000; code page
	DW   OFFSET PO_850_XLAT,0    ;;AC000; table pointer
	DW   860         ;;AC000; code page
	DW   OFFSET PO_860_XLAT,0    ;;AC000; table pointer
					 ;;
;*****************************************************************************
	 EXTRN DK_LOGIC:NEAR       ;;
	 EXTRN DK_850_XLAT:NEAR    ;;AC000;
	 EXTRN DK_865_XLAT:NEAR    ;;AC000;
					 ;;
 DK_LANG_ENT:        ;; language entry for DENMARK
	 DB 'DK'                             ;;
	 DW 159        ;;AN000; ID entry
	 DW OFFSET DK_LOGIC,0    ;; pointer to LANG kb table
	 DB 1        ;;AN000;number of ids
	 DB 2        ;;AC000; number of code pages
	 DW 850        ;;AC000; code page
	 DW OFFSET DK_850_XLAT,0     ;;AC000; table pointer
	 DW 865        ;;AC000; code page
	 DW OFFSET DK_865_XLAT,0     ;;AC000; table pointer
					 ;;
;*****************************************************************************
;;	 EXTRN SG_LOGIC:NEAR       ;;
;;	 EXTRN SG_850_XLAT:NEAR    ;;
;;	 EXTRN SG_437_XLAT:NEAR    ;;
					 ;;
;;SG_LANG_ENT:         ;; language entry for SWISS GERMAN
;;	DB   'SG'                              ;;
;;	DW   000         ;;AN001; ID entry
;;	DW   OFFSET SG_LOGIC,0     ;; pointer to LANG kb table
;;	DB   1         ;;AN000; number of ids
;;	DB   2         ;;AC000; number of code pages
;;	DW   850         ;; code page ;;;dcl 850 now default March 8, 1988
;;	DW   OFFSET SG_850_XLAT,0    ;; table pointer
;;	DW   437         ;; code page
;;	DW   OFFSET SG_437_XLAT,0    ;; table pointer
;;					 ;;
;*****************************************************************************
;;	 EXTRN SF_LOGIC:NEAR       ;;
;;	 EXTRN SF_850_XLAT:NEAR    ;;
;;	 EXTRN SF_437_XLAT:NEAR    ;;
;;					 ;;
;;SF_LANG_ENT:         ;; language entry for SWISS FRENCH
;;	DB   'SF'                              ;;
;;	DW   150         ;;AN000; ID entry
;;	DW   OFFSET SF_LOGIC,0     ;; pointer to LANG kb table
;;	DB   1             ;;AN000; number of ids
;;	DB   2         ;;AC000; number of code pages
;;	DW   850         ;; code page ;;;dcl 850 now default March 8, 1988
;;	DW   OFFSET SF_850_XLAT,0    ;; table pointer
;;	DW   437         ;; code page
;;	DW   OFFSET SF_437_XLAT,0    ;; table pointer
					 ;;
;*****************************************************************************
	 EXTRN GE_LOGIC:NEAR       ;;
	 EXTRN GE_437_XLAT:NEAR    ;;
	 EXTRN GE_850_XLAT:NEAR    ;;
					 ;;
GE_LANG_ENT:         ;; language entry for GERMANY
	DB   'GR'                              ;;
	DW   129         ;;AN000; ID entry
	DW   OFFSET GE_LOGIC,0     ;; pointer to LANG kb table
	DB   1             ;;AN000; number of ids
	DB   2         ;;AC000; number of code pages
	DW   437         ;; code page
	DW   OFFSET GE_437_XLAT,0    ;; table pointer
	DW   850         ;; code page
	DW   OFFSET GE_850_XLAT,0    ;; table pointer
					 ;;
;*****************************************************************************
		EXTRN IT1_LOGIC:NEAR     ;;AN000;
		EXTRN IT1_437_XLAT:NEAR    ;;AN000;
		EXTRN IT1_850_XLAT:NEAR    ;;AN000;
					 ;;
 IT1_LANG_ENT:         ;;AN000; language entry for ITALY
	 DB 'IT'                             ;;AN000; SECONDARY KEYBOARD ID VALUE
	 DW 142        ;;AN000; ID entry
	 DW OFFSET IT1_LOGIC,0     ;;AN000; pointer to LANG kb table
	 DB 2        ;;AN000;number of ids
	 DB 2        ;;AN000; number of code pages
	 DW 437        ;;AN000; code page
	 DW OFFSET IT1_437_XLAT,0    ;;AN000; table pointer
	 DW 850        ;;AN000; code page
	 DW OFFSET IT1_850_XLAT,0    ;;AN000; table pointer
					 ;;
;*****************************************************************************
		EXTRN IT2_LOGIC:NEAR     ;;
		EXTRN IT2_437_XLAT:NEAR    ;;
		EXTRN IT2_850_XLAT:NEAR    ;;
					 ;;
 IT2_LANG_ENT:         ;;AC000; language entry for ITALY
	 DB 'IT'                             ;;AC000;  PRIMARY KEYBOARD ID VALUE
	 DW 141        ;;AN000; ID entry
	 DW OFFSET IT2_LOGIC,0     ;;AN000; pointer to LANG kb table
	 DB 1       ;;AC000; number of ids
	 DB 2        ;;AC000; number of code pages
	 DW 437        ;;AC000; code page
	 DW OFFSET IT2_437_XLAT,0    ;;AC000; table pointer
	 DW 850        ;;AC000; code page
	 DW OFFSET IT2_850_XLAT,0    ;;AC000; table pointer
					 ;;
;*****************************************************************************
		EXTRN UK1_LOGIC:FAR      ;;AN000;
		EXTRN UK1_437_XLAT:FAR     ;;AN000;
		EXTRN UK1_850_XLAT:FAR     ;;AN000;
					 ;;
 UK1_LANG_ENT:         ;;AN000; language entry for UNITED KINGDOM
	 DB 'UK'                             ;;AN000; SECONDARY KEYBOARD ID VALUE
	 DW 168        ;;AN000; ID entry
	 DW OFFSET UK1_LOGIC,0     ;;AN000; pointer to LANG kb table
	 DB 2       ;;AN000; number of ids
	 DB 2        ;;AN000; number of code pages
	 DW 437        ;;AN000; code page
	 DW OFFSET UK1_437_XLAT,0    ;;AN000; table pointer
	 DW 850        ;;AN000; code page
	 DW OFFSET UK1_850_XLAT,0    ;;AN000; table pointer
					 ;;
;*****************************************************************************
		EXTRN UK2_LOGIC:FAR      ;;AC000;
		EXTRN UK2_437_XLAT:FAR     ;;AC000;
		EXTRN UK2_850_XLAT:FAR     ;;AC000;
					 ;;
 UK2_LANG_ENT:         ;;AN000; language entry for UNITED KINGDOM
	 DB 'UK'                             ;;AC000; PRIMARY KEYBOARD ID VALUE
	 DW 166        ;;AC000; ID entry
	 DW OFFSET UK2_LOGIC,0     ;;AC000; pointer to LANG kb table
	 DB 1       ;; AN000;number of ids
	 DB 2        ;;AN000; number of code pages
	 DW 437        ;;AC000; code page
	 DW OFFSET UK2_437_XLAT,0    ;;AC000; table pointer
	 DW 850        ;;AC000; code page
	 DW OFFSET UK2_850_XLAT,0    ;;AC000; table pointer
					 ;;
;*****************************************************************************
	 EXTRN BE_LOGIC:NEAR       ;;
	 EXTRN BE_437_XLAT:NEAR    ;;
	 EXTRN BE_850_XLAT:NEAR    ;;
					 ;;
BE_LANG_ENT:         ;; language entry for BELGIUM
	DB   'BE'                              ;;
	DW   120         ;;AN000; ID entry
	DW   OFFSET BE_LOGIC,0     ;; pointer to LANG kb table
	DB   1         ;;AN000; number of ids
	DB   2         ;;AN000; number of code pages
	DW   850         ;; code page ;; default to 850 - same as country.sys
	DW   OFFSET BE_850_XLAT,0    ;; table pointer
	DW   437         ;; code page
	DW   OFFSET BE_437_XLAT,0    ;; table pointer
					 ;;
;*****************************************************************************
;*****************************************************************************
		 EXTRN NL_LOGIC:NEAR     ;;
		 EXTRN NL_437_XLAT:NEAR    ;;
		 EXTRN NL_850_XLAT:NEAR    ;;
					 ;;
	NL_LANG_ENT:         ;; language entry for NETHERLANDS
		DB   'NL'                            ;;
		DW   143         ;;AN000; ID entry
		DW   OFFSET NL_LOGIC,0     ;; pointer to LANG kb table
		DB   1         ;;AN000; number of ids
		DB   2         ;;AN000; number of code pages
		DW   43        ;; code page
		DW   OFFSET NL_437_XLAT,0    ;; table pointer
		DW   850         ;; code page
		DW   OFFSET NL_850_XLAT,0    ;; table pointer
					 ;;
;*****************************************************************************
;*****************************************************************************
		 EXTRN NO_LOGIC:NEAR     ;;
		 EXTRN NO_850_XLAT:NEAR    ;;AC000;
		 EXTRN NO_865_XLAT:NEAR    ;;AC000;
					 ;;
	NO_LANG_ENT:         ;; language entry for NORWAY
		DB   'NO'                            ;;
		DW   155         ;;AN000; ID entry
		DW   OFFSET NO_LOGIC,0     ;; pointer to LANG kb table
		DB   1         ;;AN000; number of ids
		DB   2         ;;AN000; number of code pages
		DW   850         ;;AC000; code page
		DW   OFFSET NO_850_XLAT,0    ;;AC000; table pointer
		DW   865         ;;AC000; code page
		DW   OFFSET NO_865_XLAT,0    ;;AC000; table pointer
					 ;;
;*****************************************************************************
;*****************************************************************************
		 EXTRN SV_LOGIC:NEAR     ;;
		 EXTRN SV_437_XLAT:NEAR    ;;
		 EXTRN SV_850_XLAT:NEAR    ;;
					 ;;
	SV_LANG_ENT:         ;; language entry for SWEDEN
		DB   'SV'                            ;;
		DW   153         ;;AN000; ID entry
		DW   OFFSET SV_LOGIC,0     ;; pointer to LANG kb table
		DB   1         ;;AN000; number of ids
		DB   2         ;;AN000; number of code pages
		DW   437         ;; code page
		DW   OFFSET SV_437_XLAT,0    ;; table pointer
		DW   850         ;; code page
		DW   OFFSET SV_850_XLAT,0    ;; table pointer
					 ;;
;*****************************************************************************
;*****************************************************************************
;;  Already declared external above
;;  EXTRN Sv_LOGIC:NEAR     ;; Finland & Sweden have same layout,
;;  EXTRN Sv_437_XLAT:NEAR    ;; but different code page defaults,
;;  EXTRN Sv_850_XLAT:NEAR    ;; use Sweden data for Finland
					;;
 SU_LANG_ENT:       ;; language entry for FINLAND
	 DB 'SU'                            ;;
	 DW 153       ;; ID entry
	 DW OFFSET Sv_LOGIC,0   ;; pointer to LANG kb table
	 DB 1       ;; number of ids
	 DB 2       ;; number of code pages
	 DW 850       ;; code page  ;;;dcl 850 now default, March 8, 1988
	 DW OFFSET Sv_850_XLAT,0    ;; table pointer
	 DW 437       ;; code page
	 DW OFFSET Sv_437_XLAT,0    ;; table pointer
					;;
;*****************************************************************************
;*****************************************************************************
		 EXTRN CF_LOGIC:NEAR     ;;
		 EXTRN CF_863_XLAT:NEAR    ;;
		 EXTRN CF_850_XLAT:NEAR    ;;
					 ;;
	CF_LANG_ENT:         ;; language entry for Canadian-French
		DB   'CF'                            ;;
		DW   058         ;; ID entry
		DW   OFFSET CF_LOGIC,0     ;; pointer to LANG kb table
		DB   1         ;; number of ids
		DB   2         ;; number of code pages
		DW   863         ;; code page
		DW   OFFSET CF_863_XLAT,0    ;; table pointer
		DW   850         ;; code page
		DW   OFFSET CF_850_XLAT,0    ;; table pointer
					 ;;
;*****************************************************************************
		 EXTRN LA_LOGIC:NEAR     ;;
		 EXTRN LA_850_XLAT:NEAR    ;;
		 EXTRN LA_437_XLAT:NEAR    ;;
					 ;;
	LA_LANG_ENT:         ;; language entry for LATIN AMERICAN
		DB   'LA'                            ;;
		DW   171         ;;AN000; ID entry
		DW   OFFSET LA_LOGIC,0     ;; pointer to LANG kb table
		DB   1         ;;AN000; number of ids
		DB   2         ;;AN000; number of code pages
		DW   850         ;; code page
		DW   OFFSET LA_850_XLAT,0    ;; table pointer
		DW   437         ;; code page  ; default to 437 -same as country.sys
		DW   OFFSET LA_437_XLAT,0    ;; table pointer
					 ;;
;*****************************************************************************
;*****************************************************************************
		 EXTRN IC_LOGIC:NEAR     ;;
		 EXTRN IC_861_XLAT:NEAR    ;;
		 EXTRN IC_850_XLAT:NEAR    ;;
					 ;;
	IC_LANG_ENT:         ;; language entry for sland
		DB   'IS'                            ;;
		DW   161         ;; ID entry
		DW   OFFSET IC_LOGIC,0     ;; pointer to LANG kb table
		DB   1         ;; number of ids
		DB   2         ;; number of code pages
		DW   861         ;; code page
		DW   OFFSET IC_861_XLAT,0    ;; table pointer
		DW   850         ;; code page
		DW   OFFSET IC_850_XLAT,0    ;; table pointer

;*****************************************************************************
; [Mihindu 10/30/90 : added Brazil]

	 EXTRN BR_LOGIC:NEAR       ;;AC000;
	 EXTRN BR_850_XLAT:NEAR    ;;AC000;
	 EXTRN BR_437_XLAT:NEAR    ;;AC000;
					 ;;
BR_LANG_ENT:         ;; language entry for BRAZIL
	DB   'BR'        ;;
	DW   274         ;;AN000; ID entry
	DW   OFFSET BR_LOGIC,0     ;; pointer to LANG kb table
	DB   2         ;;AC000; number of ids
	DB   2         ;;AC000; number of code pages
	DW   850         ;;AC000; code page
	DW   OFFSET BR_850_XLAT,0    ;;AC000; table pointer
	DW   437         ;;AC000; code page
	DW   OFFSET BR_437_XLAT,0    ;;AC000; table pointer
					 ;;
																				 ;;
;*****************************************************************************
;       [Verav : added Brazil IBM layout - Feb 92]

	 EXTRN BR2_LOGIC:NEAR                   ;;AC000;
	 EXTRN BR2_850_XLAT:NEAR                ;;AC000;
	 EXTRN BR2_437_XLAT:NEAR                ;;AC000;
					 ;;
BR2_LANG_ENT:                             ;; language entry for BRAZIL
	DB   'BR'                              ;;
	DW   275                               ;;AN000; ID entry
	DW   OFFSET BR2_LOGIC,0                 ;; pointer to LANG kb table
	DB   1                                 ;;AC000; number of ids
	DB   2                                 ;;AC000; number of code pages
	DW   850                               ;;AC000; code page
	DW   OFFSET BR2_850_XLAT,0              ;;AC000; table pointer
	DW   437                               ;;AC000; code page
	DW   OFFSET BR2_437_XLAT,0              ;;AC000; table pointer
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	 EXTRN PL_LOGIC:NEAR           ;;
	 EXTRN PL_850_XLAT:NEAR        ;;
	 EXTRN PL_852_XLAT:NEAR        ;;
							 ;;
PL_LANG_ENT:             ;; language entry for POLAND
	DB   'PL'                            ;;
	DW   214             ;; Keyboard ID entry |
	DW   OFFSET PL_LOGIC,0         ;; pointer to LANG kb table
	DB   1             ;; number of ids        |
	DB   2             ;; number of code pages
	DW   850             ;; code page
	DW   OFFSET PL_850_XLAT,0        ;; table pointer
	DW   852             ;; code page
	DW   OFFSET PL_852_XLAT,0        ;; table pointer
							 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	 EXTRN YU_LOGIC:NEAR           ;;
	 EXTRN YU_850_XLAT:NEAR        ;;
	 EXTRN YU_852_XLAT:NEAR        ;;
							 ;;
YU_LANG_ENT:             ;; language entry for YUGOSLAVIA
	DB   'YU'                            ;;
	DW   234             ;; Keyboard ID entry |
	DW   OFFSET YU_LOGIC,0         ;; pointer to LANG kb table
	DB   1             ;; number of ids        |
	DB   2             ;; number of code pages |
	DW   850             ;; code page
	DW   OFFSET YU_850_XLAT,0        ;; table pointer
	DW   852             ;; code page
	DW   OFFSET YU_852_XLAT,0        ;; table pointer
							 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	 EXTRN HU_LOGIC:NEAR           ;;
	 EXTRN HU_850_XLAT:NEAR        ;;
	 EXTRN HU_852_XLAT:NEAR        ;;
							 ;;
HU_LANG_ENT:             ;; language entry for HUNGARY
	DB   'HU'                            ;;
	DW   208             ;; Keyboard ID entry |
	DW   OFFSET HU_LOGIC,0         ;; pointer to LANG kb table
	DB   1             ;; number of ids        |
	DB   2             ;; number of code pages
	DW   850             ;; code page
	DW   OFFSET HU_850_XLAT,0        ;; table pointer
	DW   852             ;; code page
	DW   OFFSET HU_852_XLAT,0        ;; table pointer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	 EXTRN RO_LOGIC:NEAR                 ;;
	 EXTRN RO_850_XLAT:NEAR              ;;
	 EXTRN RO_852_XLAT:NEAR              ;;
																			 ;;
RO_LANG_ENT:                           ;; language entry for ROMANIA
	DB   'RO'                            ;;
	DW   333                             ;; Keyboard ID entry |
	DW   OFFSET RO_LOGIC,0               ;; pointer to LANG kb table
	DB   1                               ;; number of ids        |
	DB   2                               ;; number of code pages
	DW   850                             ;; code page
	DW   OFFSET RO_850_XLAT,0            ;; table pointer
	DW   852                             ;; code page
	DW   OFFSET RO_852_XLAT,0            ;; table pointer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							 ;;
; M000 --- ADDDED SECTION for JAPANESE support

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				EXTRN   JP_LOGIC:NEAR            ;;                             ;JP9002
				EXTRN   JP_932_XLAT:NEAR         ;;                             ;JP9002
				EXTRN   JP_437_XLAT:NEAR         ;;                             ;JP9002
JP_LANG_ENT:                             ;;                             ;JP9002
		DB   'JP'                            ;;                             ;JP9002
		DW   194                             ;; keyboard ID for Japan       ;JP9009
		DW   OFFSET JP_LOGIC, 0              ;; pointer to LANG kb table    ;JP9002
		DB   1                               ;; number of ids               ;JP9002
		DB   2                               ;; number of code pages        ;JP9002
		DW   932                             ;; code page                   ;JP9002
		DW   OFFSET JP_932_XLAT, 0           ;; table pointer               ;JP9002
		DW   437                             ;; code page                   ;JP9002
		DW   OFFSET JP_437_XLAT, 0           ;; table pointer               ;JP9002
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; M000 -- end added section


DUMMY_ENT:             ;; language entry
	DB   'XX'                            ;;
	DW   103             ;;AC000; ID entry
	DW   OFFSET DUMMY_LOGIC,0        ;; pointer to LANG kb table
	DB   1             ;;AC000; number of ids
	DB   6             ;;AC000; number of code pages
	DW   437             ;; code page
	DW   OFFSET DUMMY_XLAT_437,0         ;; table pointer
	DW   850             ;; code page
	DW   OFFSET DUMMY_XLAT_850,0         ;; table pointer
	DW   852             ;; code page [Mihindu 11/30/90]
	DW   OFFSET DUMMY_XLAT_852,0         ;; table pointer
	DW   860             ;; code page
	DW   OFFSET DUMMY_XLAT_860,0         ;; table pointer
	DW   863             ;; code page
	DW   OFFSET DUMMY_XLAT_863,0         ;; table pointer
	DW   865             ;; code page
	DW   OFFSET DUMMY_XLAT_865,0         ;; table pointer
	DW   861             ;; code page   sland !
	DW   OFFSET DUMMY_XLAT_861,0         ;; table pointer
								 ;;
DUMMY_LOGIC:             ;;
	 DW  LOGIC_END-$           ;; length
	 DW  0             ;; special features
	 DB  92H,0,0             ;; EXIT_STATE_LOGIC_COMMAND
LOGIC_END:             ;;
							 ;;
DUMMY_XLAT_437:            ;;
	 DW   6            ;; length of section
	 DW   437            ;; code page
	 DW   0            ;; LAST STATE
							 ;;
DUMMY_XLAT_850:            ;;
	 DW   6            ;; length of section
	 DW   850            ;; code page
	 DW   0            ;; LAST STATE
							 ;;
DUMMY_XLAT_852:            ;; [Mihindu 11/30/90]
	 DW   6            ;; length of section
	 DW   852            ;; code page
	 DW   0            ;; LAST STATE
							 ;;
DUMMY_XLAT_860:            ;;
	 DW   6            ;; length of section
	 DW   860            ;; code page
	 DW   0            ;; LAST STATE
							 ;;
DUMMY_XLAT_865:            ;;
	 DW   6            ;; length of section
	 DW   865            ;; code page
	 DW   0            ;; LAST STATE
							 ;;
DUMMY_XLAT_863:            ;;
	 DW   6            ;; length of section
	 DW   863            ;; code page
	 DW   0            ;; LAST STATE
							 ;;
DUMMY_XLAT_861:            ;;
	 DW     6            ;; length of section
	 DW     861            ;; code page
	 DW     0            ;; LAST STATE      
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;*****************************************************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
							 ;;
CODE   ENDS            ;;
	 END             ;;
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kbd2\kdfpo.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;; LATEST CHANGE TO CTL [ and ] on XT moved to key 26 & 27

;; XT section enabled
;; ************* CNS 12/18/86


	PAGE	,132
	TITLE	MS-DOS 5.0 Keyboard Definition File

;; LATEST CHANGE P12 NUMERIC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Defintion File
;;
;; This file contains the keyboard tables for Portugeuse
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;;	       Updated for Portugal by M.J.Saunders WSD - August 1986.
;;	       modded : DTF 18-Sep-86
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC	       ;;
	INCLUDE POSTEQU.INC	       ;;
	INCLUDE KEYBMAC.INC	       ;;
				       ;;
	PUBLIC PO_LOGIC 	       ;;
	PUBLIC PO_860_XLAT	       ;;
	PUBLIC PO_850_XLAT	       ;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a linear search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE	    EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PO State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
PO_LOGIC:

   DW  LOGIC_END-$		       ;; length
				       ;;
   DW  0			       ;; special features
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND 	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   IFF	EITHER_ALT,NOT		       ;;
   ANDF EITHER_CTL,NOT		       ;;
      IFF EITHER_SHIFT		       ;;
	  SET_FLAG DEAD_UPPER	       ;;
      ELSEF			       ;;
	  SET_FLAG DEAD_LOWER	       ;;
      ENDIFF			       ;;
   ENDIFF			       ;;
IFF EITHER_SHIFT,NOT		       ;;
   IFKBD XT_KB+AT_KB		       ;;
      IFF EITHER_CTL		       ;;
      ANDF ALT_SHIFT		       ;;
	  SET_FLAG DEAD_THIRD	       ;;
      ENDIFF			       ;;
   ELSEF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF R_ALT_SHIFT		       ;;
	  SET_FLAG DEAD_THIRD	       ;;
      ENDIFF			       ;;
   ENDIFF			       ;;
ENDIFF				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:			       ;;
				       ;;
   IFF ACUTE,NOT		       ;;
      GOTO DIARESIS_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ACUTE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_ACUTE:			       ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      GOTO NON_DEAD		       ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:			       ;;
				       ;;
   IFF DIARESIS,NOT		       ;;
      GOTO GRAVE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT DIARESIS_SPACE	       ;;  exist for 437 so beep for
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_DIARESIS:		       ;;
      PUT_ERROR_CHAR DIARESIS_LOWER    ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:			       ;;
				       ;;
   IFF GRAVE,NOT		       ;;
      GOTO TILDE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT GRAVE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_GRAVE:			       ;;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TILDE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TILDE_PROC:			       ;;
				       ;;
   IFF TILDE,NOT		       ;;
      GOTO CIRCUMFLEX_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT TILDE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT TILDE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT TILDE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT TILDE_UPPER        ;;
	   ELSEF		       ;;
	      XLATT TILDE_LOWER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_TILDE:			       ;;
      PUT_ERROR_CHAR TILDE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:		       ;;
				       ;;
   IFF CIRCUMFLEX,NOT		       ;;
      GOTO NON_DEAD		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CIRCUMFLEX:		       ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
NON_DEAD:			       ;;
				       ;;
   IFKBD G_KB+P12_KB		       ;; Avoid accidentally translating
   ANDF LC_E0			       ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC		       ;;   G keyboard
   ENDIFF			       ;;
				       ;;
   IFF	EITHER_ALT,NOT		       ;; Lower and upper case.  Alphabetic
   ANDF EITHER_CTL,NOT		       ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT		       ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE,NOT	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_UPPER        ;;
	  IFF CAPS_STATE	       ;;
	      XLATT ALPHA_LOWER        ;;
	  ELSEF 		       ;;
	      XLATT ALPHA_UPPER        ;;
	  ENDIFF		       ;;
      ELSEF			       ;;
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE 	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_LOWER        ;;
	  IFF CAPS_STATE	       ;;
	     XLATT ALPHA_UPPER	       ;;
	  ELSEF 		       ;;
	     XLATT ALPHA_LOWER	       ;;
	  ENDIFF		       ;;
      ENDIFF			       ;;
   ELSEF			       ;;
      IFF EITHER_SHIFT,NOT	       ;;
	  IFKBD XT_KB+AT_KB	       ;;
	      IFF  EITHER_CTL	       ;;
	      ANDF ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	  ELSEF 		       ;;
	      IFF EITHER_CTL,NOT       ;;
	      ANDF R_ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	   ENDIFF		       ;;
      ENDIFF			       ;;
   ENDIFF			       ;;
;**************************************;;
 IFF EITHER_SHIFT,NOT		       ;;
   IFKBD XT_KB+AT_KB		       ;;
     IFF EITHER_CTL		       ;;
     ANDF ALT_SHIFT		       ;;
       XLATT ALT_CASE		       ;;
     ENDIFF			       ;;
   ENDIFF			       ;;
   IFKBD G_KB+P12_KB		       ;;
     IFF EITHER_CTL		       ;;
     ANDF ALT_SHIFT		       ;;
       IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ALT_CASE 	       ;;
       ENDIFF			       ;;
     ENDIFF			       ;;
   ENDIFF			       ;;
 ENDIFF 			       ;;
;**************************************;;
 IFKBD AT_KB+XT_KB		 ;;
      IFF EITHER_CTL,NOT	       ;;
	 IFF ALT_SHIFT		       ;; ALT - case
	    XLATT ALT_CASE	       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF EITHER_ALT,NOT	       ;; CTRL - case
	    XLATT CTRL_CASE	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
 ENDIFF 			       ;;
				       ;;
 IFKBD G_KB+P12_KB		       ;;
      IFF EITHER_CTL,NOT	       ;;
	 IFF ALT_SHIFT		       ;; ALT - case
	 ANDF R_ALT_SHIFT,NOT	       ;;
	    XLATT ALT_CASE	       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF EITHER_ALT,NOT	       ;; CTRL - case
	    XLATT CTRL_CASE	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL		       ;;
      ANDF ALT_SHIFT		       ;;
      ANDF R_ALT_SHIFT,NOT	       ;;
	   XLATT ALT_CASE	       ;;
      ENDIFF			       ;;
 ENDIFF 			       ;;
				       ;;
 EXIT_STATE_LOGIC		       ;;
				       ;;
LOGIC_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PO Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC PO_COMMON_XLAT		       ;;
PO_COMMON_XLAT: 		       ;;
				       ;;
   DW	 COMMON_XLAT_END-$	       ;; length of section
   DW	 -1			       ;; code page
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Lower Shift Dead Key
;; KEYBOARD TYPES: XT
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_LO_END-$	       ;; length of state section
   DB	 DEAD_LOWER		       ;; State ID
   DW	 XT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 27			       ;; scan code
   FLAG  ACUTE			       ;; flag bit to set
   DB	 41			       ;;
   FLAG  TILDE			       ;;
				       ;;
				       ;;
COM_DK_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Lower Shift Dead Key
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_LO_K1_END-$		  ;; length of state section
   DB	 DEAD_LOWER		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 27			       ;; scan code
   FLAG  ACUTE			       ;; flag bit to set
   DB	 43			       ;;
   FLAG  TILDE			       ;;
				       ;;
				       ;;
COM_DK_LO_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Upper Shift Dead Key
;; KEYBOARD TYPES: XT
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_UP_END-$	       ;; length of state section
   DB	 DEAD_UPPER		       ;; State ID
   DW	 XT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 27			       ;; scan code
   FLAG  GRAVE			       ;; flag bit to set
   DB	 41			       ;;
   FLAG  CIRCUMFLEX		       ;;
				       ;;
COM_DK_UP_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Upper Shift Dead Key
;; KEYBOARD TYPES: G, P12,
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_UP_K1_END-$		  ;; length of state section
   DB	 DEAD_UPPER		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 27			       ;; scan code
   FLAG  GRAVE			       ;; flag bit to set
   DB	 43			       ;;
   FLAG  CIRCUMFLEX		       ;;
				       ;;
COM_DK_UP_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift Dead Key
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_TH_END-$	       ;; length of state section
   DB	 DEAD_THIRD		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 1			       ;; number of entries
   DB	 26			       ;; scan code
   FLAG  DIARESIS		       ;; flag bit to set
				       ;;
COM_DK_TH_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: XT, G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K1_END-$		;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 XT_KB+G_KB+P12_KB	 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_ALT_K1_T1_END-$		;; Size of xlat table
   DB	 TYPE_2_TAB		     ;; xlat options:
   DB	 0			       ;; 2 number of entries
;   DB	  12,-1,-1			;; BLOT OUT HYPHEN
;   DB	  53,0,82H			;; MOVE HYPHEN
COM_ALT_K1_T1_END:			;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_ALT_K1_END: 			;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K1_END-$		 ;; length of state section
   DB	 CTRL_CASE			;; State ID   **** CNS 12/18
   DW	 G_KB+P12_KB			;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_CTRL_K1_T1_END-$		 ;; Size of xlat table
   DB	 TYPE_2_TAB		     ;; xlat options:
   DB	 7			       ;; number of entries
   DB	 09,1BH,09		       ;; [
   DB	 10,1DH,10		       ;; ]
   DB	 12,-1,-1		       ;; BLOT OUT HYPHEN
   DB	 1AH,-1,-1		       ;;   "   "   [
   DB	 1BH,-1,-1		       ;;   "   "   ]
   DB	 29H,1CH,29H		       ;; backslash
   DB	 53,01FH,35H		       ;; MOVE HYPHEN
COM_CTRL_K1_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CTRL_K1_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: XT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; *** CNS 12/18/86
				       ;;
   DW	 COM_CTRL_K2_END-$		 ;; length of state section
   DB	 CTRL_CASE			;; State ID
   DW	 XT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_CTRL_K2_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 5			       ;; number of entries
   DB	 12,-1,-1		       ;; BLOT OUT HYPHEN
   DB	 1AH,1BH,1AH		       ;;   "   "   [
   DB	 1BH,1DH,1BH		       ;;   "   "   ]
   DB	 43,1CH,43		       ;; backslash
   DB	 53,01FH,35H		       ;; MOVE HYPHEN
COM_CTRL_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CTRL_K2_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: XT, G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_LO_END-$	       ;; length of state section
   DB	 ALPHA_LOWER		       ;; State ID
   DW	 XT_KB+G_KB+P12_KB	 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 39,087H		       ;; c-cedilla
COM_AL_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: XT, G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_UP_END-$	       ;; length of state section
   DB	 ALPHA_UPPER		       ;; State ID
   DW	 XT_KB+G_KB+P12_KB	 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 39,080H		       ;; c-cedilla
COM_AL_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_UP_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: XT,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 6			       ;; number of entries
   DB	 12,"'"                        ;;
   DB	 13,0AEH		       ;;
   DB	 26,"+"                        ;;
   DB	 40,0A7H		       ;;
   DB	 43,"<"                        ;;
   DB	 53,"-"                        ;;
COM_NA_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: XT, , G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K1_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 7			       ;; number of entries
   DB	 12,"'"                        ;;
   DB	 13,0AEH		       ;;
   DB	 26,"+"                        ;;
   DB	 40,0A7H		       ;;
   DB	 41,"\"                        ;;
   DB	 53,"-"                        ;;
   DB	 86,"<"                        ;;
COM_NA_LO_K1_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 14			       ;;
   DB	  3,'"'                        ;;
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 13,0AFH		       ;; right double arrow 
   DB	 26,'*'                        ;;
   DB	 40,0A6H		       ;; a underscore
   DB	 43,'>'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
				       ;;
COM_NA_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K1_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 15			       ;;
   DB	  3,'"'                        ;;
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 13,0AFH		       ;; right double arrow 
   DB	 26,'*'                        ;;
   DB	 40,0A6H		       ;; a underscore
   DB	 41,07CH		       ;;|
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
   DB	 86,'>'                        ;;
				       ;;
COM_NA_UP_K1_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K1_END:			  ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: XT,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 8			       ;; number of entries
   DB	  2,'|'                        ;;
   DB	  3,'@'                        ;;
   DB	  5,09CH		       ;; 
   DB	  9,'{'                        ;;
   DB	 10,'}'                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 43,'\'                        ;;
COM_THIRD_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K1_END-$		  ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K1_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 6			       ;; number of entries
   DB	  3,'@'                        ;;
   DB	  4,09CH		       ;; 
   DB	  8,'{'                        ;;
   DB	  9,'['                        ;;
   DB	 10,']'                        ;;
   DB	 11,'}'                        ;;
COM_THIRD_K1_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Lower
;; KEYBOARD TYPES: XT, , G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_LO_END-$	       ;; length of state section
   DB	 GRAVE_LOWER		       ;; State ID
   DW	 XT_KB+G_KB+P12_KB	 ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
COM_GR_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_LO_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Space Bar
;; KEYBOARD TYPES: XT, , G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_SP_END-$	       ;; length of state section
   DB	 GRAVE_SPACE		       ;; State ID
   DW	 XT_KB+G_KB+P12_KB	 ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,96			       ;; STANDALONE GRAVE
COM_GR_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: XT, , G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_LO_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_LOWER	       ;; State ID
   DW	 XT_KB+G_KB+P12_KB	 ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
COM_CI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CI_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES: XT, , G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_SP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_SPACE	       ;; State ID
   DW	 XT_KB+G_KB+P12_KB	 ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,94			       ;; STANDALONE CIRCUMFLEX
COM_CI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Lower
;; KEYBOARD TYPES: XT,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  COM_TI_LO_END-$		;; length of state section
    DB	  TILDE_LOWER			;; State ID
    DW	  XT_KB 		  ;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  COM_TI_LO_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  4				;; number of scans
    DB	  30,0C6H			;; scan code,ASCII - tilde a
    DB	  24,0E4H			;; scan code,ASCII - tilde o
    DB	  49,0A4H			;; scan code,ASCII - 
    DB	  22,081h			;; scan code,ASCII - u diaresis
 COM_TI_LO_T1_END:			;; because the diaresis is not
					;; available on the XT
    DW	  0				;;
					;;
 COM_TI_LO_END: 			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: Common
;;; STATE: Tilde Upper Case
;;; KEYBOARD TYPES: XT,
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  COM_TI_UP_END-$		;; length of state section
    DB	  TILDE_UPPER		       ;; State ID
    DW	  XT_KB 		  ;; Keyboard Type
    DB	  07eH,0			 ;; error character = standalone accent
					;;
    DW	  COM_TI_UP_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  4				;; number of scans
    DB	  30,0C7H			;; scan code,ASCII - tilde A
    DB	  24,0E5H			;; scan code,ASCII - tilde O
    DB	  49,0A5H			;; scan code,ASCII - 
    DB	  22,09AH			;; scan code,ASCII - U diaresis
 COM_TI_UP_T1_END:			;; because the diaresis is not
					;; available on the XT
    DW	  0				;; Size of xlat table - null table
					;;
 COM_TI_UP_END: 			;; length of state section
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Lower
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  COM_TI_LO_K1_END-$		   ;; length of state section
    DB	  TILDE_LOWER			;; State ID
    DW	  G_KB+P12_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  COM_TI_LO_K1_T1_END-$ 	   ;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  3				;; number of scans
    DB	  30,0C6H			;; scan code,ASCII - tilde a
    DB	  24,0E4H			;; scan code,ASCII - tilde o
    DB	  49,0A4H			;; scan code,ASCII - 
 COM_TI_LO_K1_T1_END:			   ;;
					;;
    DW	  0				;;
					;;
 COM_TI_LO_K1_END:			   ;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: Common
;;; STATE: Tilde Upper Case
;;; KEYBOARD TYPES: G, P12
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  COM_TI_UP_K1_END-$		   ;; length of state section
    DB	  TILDE_UPPER		       ;; State ID
    DW	  G_KB+P12_KB			;; Keyboard Type
    DB	  07EH,0			 ;; error character = standalone accent
					;;
    DW	  COM_TI_UP_K1_T1_END-$ 	   ;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  3				;; number of scans
    DB	  30,0C7H			;; scan code,ASCII - tilde A
    DB	  24,0E5H			;; scan code,ASCII - tilde O
    DB	  49,0A5H			;; scan code,ASCII - 
 COM_TI_UP_K1_T1_END:			   ;;
					;;
    DW	  0				;; Size of xlat table - null table
					;;
 COM_TI_UP_K1_END:			   ;; length of state section
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Space Bar
;; KEYBOARD TYPES: XT, , G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_TI_SP_END-$	       ;; length of state section
   DB	 TILDE_SPACE		       ;; State ID
   DW	 XT_KB+G_KB+P12_KB	 ;; Keyboard Type
   DB	 07EH,0 			 ;; error character = standalone accent
				       ;;
   DW	 COM_TI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,07EH		      ;; STANDALONE TILDE
COM_TI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_TI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; Last State
COMMON_XLAT_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; PO Specific Translate Section for 860
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC PO_860_XLAT		       ;;
PO_860_XLAT:			       ;;
				       ;;
   DW	  CP860_XLAT_END-$	       ;; length of section
   DW	  860			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 860
;; STATE: Third Shift
;; KEYBOARD TYPES: G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP860_THIRD_K1_END-$		    ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP860_THIRD_K1_T1_END-$	    ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 5,015H 		      ;; section symbol
CP860_THIRD_K1_T1_END:			    ;;
				       ;;
   DW	 0			       ;; Last xlat table
CP860_THIRD_K1_END:			    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 860
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: XT, , G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP860_AC_LO_END-$		 ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 XT_KB+G_KB+P12_KB	 ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP860_AC_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP860_AC_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP860_AC_LO_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 860
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: XT, , G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP860_AC_UP_END-$	       ;; length of state section
   DB	 ACUTE_UPPER		       ;; State ID
   DW	 XT_KB+G_KB+P12_KB	 ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP860_AC_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,090H		       ;; E acute
   DB	 22,096H		       ;; U acute
   DB	 23,08BH		       ;; I acute
   DB	 24,09FH		       ;; O acute
   DB	 30,086H		       ;; A acute
CP860_AC_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP860_AC_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 860
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: XT, , G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP860_AC_SP_END-$		 ;; length of state section
   DB	 ACUTE_SPACE		       ;; State ID
   DW	 XT_KB+G_KB+P12_KB	 ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP860_AC_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,39			       ;; scan code,ASCII - SPACE
CP860_AC_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP860_AC_SP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 860
;; STATE: Grave Upper
;; KEYBOARD TYPES: XT, , G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP860_GR_UP_END-$	       ;; length of state section
   DB	 GRAVE_UPPER		       ;; State ID
   DW	 XT_KB+G_KB+P12_KB	 ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 CP860_GR_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,092H		       ;;    E grave
   DB	 22,09DH		       ;;    U grave
   DB	 23,098H		       ;;    I grave
   DB	 24,0A9H		       ;;    O grave
   DB	 30,091H		       ;;    A grave
CP860_GR_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP860_GR_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 860
;; STATE: Circumflex Upper
;; KEYBOARD TYPES: XT, , G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP860_CI_UP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_UPPER	       ;; State ID
   DW	 XT_KB+G_KB+P12_KB	 ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 CP860_CI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 30,08FH		       ;;    A circumflex
   DB	 18,089H		       ;;    E circumflex
   DB	 24,08CH		       ;;    O circumflex
CP860_CI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP860_CI_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 860
;; STATE: Tilde Lower
;; KEYBOARD TYPES: XT, , G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  CP860_TI_LO_END-$		  ;; length of state section
    DB	  TILDE_LOWER			;; State ID
    DW	  XT_KB+G_KB+P12_KB	  ;; Keyboard Type
    DB	  07eH,0			;; error character = standalone accent
					;;
    DW	  CP860_TI_LO_T1_END-$		  ;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  2				;; number of scans
    DB	  24,094H			;; scan code,ASCII - o tilde
    DB	  30,084H			;; scan code,ASCII - a tilde
 CP860_TI_LO_T1_END:			  ;;
					;;
    DW	  0				;;
					;;
 CP860_TI_LO_END:			  ;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: 860
;;; STATE: Tilde Upper Case
;;; KEYBOARD TYPES: XT, , G, P12,
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  CP860_TI_UP_END-$		  ;; length of state section
    DB	  TILDE_UPPER		       ;; State ID
    DW	  XT_KB+G_KB+P12_KB	  ;; Keyboard Type
    DB	  07eH,0			 ;; error character = standalone accent
					;;
    DW	  CP860_TI_UP_T1_END-$		  ;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  2				;; number of scans
    DB	  24,099H			;; scan code,ASCII - O tilde
    DB	  30,08EH			;; scan code,ASCII - A tilde
 CP860_TI_UP_T1_END:			;;
					;;
    DW	  0				;; Size of xlat table - null table
					;;
 CP860_TI_UP_END:			;; length of state section
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 860
;; STATE: Diaresis Lower
;; KEYBOARD TYPES: G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP860_DI_LO_END-$	       ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 0FEH,0 		       ;; error character = standalone accent
				       ;;
   DW	 CP860_DI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 22,081H		       ;;    u diaeresis
CP860_DI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP860_DI_LO_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 860
;; STATE: Diaresis Upper
;; KEYBOARD TYPES: G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP860_DI_UP_END-$	       ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 0FEH,0 		       ;; error character = standalone accent
				       ;;
   DW	 CP860_DI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 22,09AH		       ;;    U diaeresis
CP860_DI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP860_DI_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 860
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP860_DI_SP_END-$	       ;; length of state section
   DB	 DIARESIS_SPACE 	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 0FEH,0 		       ;; error character = standalone accent
				       ;;
   DW	 CP860_DI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,0FEH		       ;; scan code,ASCII - SPACE
CP860_DI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP860_DI_SP_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	  0			       ;; LAST STATE
				       ;;
CP860_XLAT_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PO Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC PO_850_XLAT		       ;;
PO_850_XLAT:			       ;;
				       ;;
   DW	  CP850_XLAT_END-$	       ;; length of section
   DW	  850			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Third Shift
;; KEYBOARD TYPES: G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_THIRD_K1_END-$		    ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_THIRD_K1_T1_END-$	    ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 5,0F5H 		      ;; section symbol
CP850_THIRD_K1_T1_END:			    ;;
				       ;;
   DW	 0			       ;; Last xlat table
CP850_THIRD_K1_END:			    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: XT, , G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_LO_END-$	       ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 XT_KB+G_KB+P12_KB	 ;; Keyboard Type
   DB	 239,0				;; error character = standalone accent
				       ;;
   DW	 CP850_AC_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 21,0ECH		       ;; y acute
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP850_AC_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_LO_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: XT, , G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_UP_END-$	       ;; length of state section
   DB	 ACUTE_UPPER		       ;; State ID
   DW	 XT_KB+G_KB+P12_KB	 ;; Keyboard Type
   DB	 239,0				;; error character = standalone accent
				       ;;
   DW	 CP850_AC_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,090H		       ;; E acute
   DB	 21,0EDH		       ;;    Y acute
   DB	 22,0E9H		       ;;    U acute
   DB	 23,0D6H		       ;;    I acute
   DB	 24,0E0H		       ;;    O acute
   DB	 30,0B5H		       ;;    A acute
CP850_AC_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: XT, , G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_SP_END-$		 ;; length of state section
   DB	 ACUTE_SPACE		       ;; State ID
   DW	 XT_KB+G_KB+P12_KB	 ;; Keyboard Type
   DB	 239,0				;; error character = standalone accent
				       ;;
   DW	 CP850_AC_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,239 			;; scan code,ASCII - SPACE
CP850_AC_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_SP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Lower
;; KEYBOARD TYPES: G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_LO_END-$	       ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,089H		       ;;    e diaeresis
   DB	 21,098H		       ;;    y diaeresis
   DB	 22,081H		       ;;    u diaeresis
   DB	 23,08BH		       ;;    i diaeresis
   DB	 24,094H		       ;;    o diaeresis
   DB	 30,084H		       ;;    a diaeresis
CP850_DI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_LO_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Upper
;; KEYBOARD TYPES: G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_UP_END-$	       ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,0D3H		       ;;    E diaeresis
   DB	 22,09AH		       ;;    U diaeresis
   DB	 23,0D8H		       ;;    I diaeresis
   DB	 24,099H		       ;;    O diaeresis
   DB	 30,08EH		       ;;    A diaeresis
CP850_DI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_SP_END-$		 ;; length of state section
   DB	 DIARESIS_SPACE 		  ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 249,0				;; error character = standalone accent
				       ;;
   DW	 CP850_DI_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,249 			;; scan code,ASCII - SPACE
CP850_DI_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_SP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Grave Upper
;; KEYBOARD TYPES: XT, , G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_GR_UP_END-$	       ;; length of state section
   DB	 GRAVE_UPPER		       ;; State ID
   DW	 XT_KB+G_KB+P12_KB	 ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_GR_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 30,0B7H		       ;;    A grave
   DB	 18,0D4H		       ;;    E grave
   DB	 23,0DEH		       ;;    I grave
   DB	 24,0E3H		       ;;    O grave
   DB	 22,0EBH		       ;;    U grave
CP850_GR_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_GR_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Tilde Lower
;; KEYBOARD TYPES: XT, , G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  CP850_TI_LO_END-$		  ;; length of state section
    DB	  TILDE_LOWER			;; State ID
    DW	  XT_KB+G_KB+P12_KB	  ;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  CP850_TI_LO_T1_END-$		  ;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  2				;; number of scans
    DB	  30,0C6H			;; scan code,ASCII - a tilde
    DB	  24,0E4H			;; scan code,ASCII - o tilde
 CP850_TI_LO_T1_END:			  ;;
					;;
    DW	  0				;;
					;;
 CP850_TI_LO_END:			  ;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: 850
;;; STATE: Tilde Upper Case
;;; KEYBOARD TYPES: XT, , G, P12,
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  CP850_TI_UP_END-$		  ;; length of state section
    DB	  TILDE_UPPER		       ;; State ID
    DW	  XT_KB+G_KB+P12_KB	  ;; Keyboard Type
    DB	  07eH,0			 ;; error character = standalone accent
					;;
    DW	  CP850_TI_UP_T1_END-$		  ;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  2				;; number of scans
    DB	  30,0C7H			;; scan code,ASCII - A tilde
    DB	  24,0E5H			;; scan code,ASCII - O tilde
 CP850_TI_UP_T1_END:			  ;;
					;;
    DW	  0				;; Size of xlat table - null table
					;;
 CP850_TI_UP_END:			  ;; length of state section
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: XT, , G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_CI_LO_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_LOWER	       ;; State ID
   DW	 XT_KB+G_KB+P12_KB	 ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_CI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 2			       ;; number of scans
   DB	 23,08CH		       ;;    i circumflex
   DB	 22,096H		       ;;    u circumflex
CP850_CI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_CI_LO_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Circumflex Upper
;; KEYBOARD TYPES: XT, , G, P12,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_CI_UP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_UPPER	       ;; State ID
   DW	 XT_KB+G_KB+P12_KB	 ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_CI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 30,0B6H		       ;;    A circumflex
   DB	 18,0D2H		       ;;    E circumflex
   DB	 23,0D7H		       ;;    I circumflex
   DB	 24,0E2H		       ;;    O circumflex
   DB	 22,0EAH		       ;;    U circumflex
CP850_CI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_CI_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 0			       ;; LAST STATE
				       ;;
CP850_XLAT_END: 		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CODE	 ENDS			       ;;
	 END			       ;;


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kbd2\kdfsf.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
	PAGE	,132

	TITLE	MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Defintion File
;;
;; This file contains the keyboard tables for Swiss French
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC	       ;;
	INCLUDE POSTEQU.INC	       ;;
	INCLUDE KEYBMAC.INC	       ;;
				       ;;
	PUBLIC SF_LOGIC 	       ;;
	PUBLIC SF_437_XLAT	       ;;
	PUBLIC SF_850_XLAT	       ;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a liner search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE	    EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; SG State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
SF_LOGIC:

   DW  LOGIC_END-$		       ;; length
				       ;;
   DW  0			       ;; special features
				       ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND 	       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;  ***BD - THIS SECTION HAS BEEN UPDATED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
IFF EITHER_ALT,NOT		       ;;
ANDF EITHER_CTL,NOT		       ;;
   IFF EITHER_SHIFT		       ;;
	SET_FLAG DEAD_UPPER	       ;;
   ELSEF			       ;;
	SET_FLAG DEAD_LOWER	       ;;
   ENDIFF			       ;;
ENDIFF				       ;;
IFF EITHER_SHIFT,NOT		       ;;
   IFKBD XT_KB+AT_KB		 ;;
      IFF EITHER_CTL		       ;;
      ANDF ALT_SHIFT		       ;;
	SET_FLAG DEAD_THIRD	       ;;
      ENDIFF			       ;;
   ELSEF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF R_ALT_SHIFT		       ;;
	 SET_FLAG DEAD_THIRD	       ;;
      ENDIFF			       ;;
   ENDIFF			       ;;
ENDIFF				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:			       ;;
				       ;;
   IFF ACUTE,NOT		       ;;
      GOTO DIARESIS_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ACUTE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_ACUTE:			       ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      GOTO NON_DEAD		       ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:			       ;;
				       ;;
   IFF DIARESIS,NOT		       ;;
      GOTO GRAVE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT DIARESIS_SPACE	       ;;  exist for 437 so beep for
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_DIARESIS:		       ;;
      PUT_ERROR_CHAR DIARESIS_LOWER    ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:			       ;;
				       ;;
   IFF GRAVE,NOT		       ;;
      GOTO TILDE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT GRAVE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_GRAVE:			       ;;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TILDE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TILDE_PROC:			       ;;
				       ;;
   IFF TILDE,NOT		       ;;
      GOTO CIRCUMFLEX_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT TILDE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT TILDE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT TILDE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT TILDE_UPPER        ;;
	   ELSEF		       ;;
	      XLATT TILDE_LOWER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_TILDE:			       ;;
      PUT_ERROR_CHAR TILDE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:		       ;;
				       ;;
   IFF CIRCUMFLEX,NOT		       ;;
      GOTO NON_DEAD		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CIRCUMFLEX:		       ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
NON_DEAD:			       ;;
				       ;;
   IFKBD G_KB+P12_KB		       ;; Avoid accidentally translating
   ANDF LC_E0			       ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC		       ;;   G keyboard
   ENDIFF			       ;;
				       ;;
   IFF	EITHER_ALT,NOT		       ;; Lower and upper case.  Alphabetic
   ANDF EITHER_CTL,NOT		       ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT		       ;; Numeric keys are not.
	  IFF CAPS_STATE	       ;;
	      XLATT BOTRH_F_CAPS       ;;
	      XLATT ALPHA_LOWER        ;;
	  ELSEF 		       ;;
	      XLATT ALPHA_UPPER        ;;
	  ENDIFF		       ;;
	  XLATT NON_ALPHA_UPPER        ;;
      ELSEF			       ;;
	  IFF CAPS_STATE	       ;;
	     XLATT BOTRH_CAPS	       ;;
	     XLATT ALPHA_UPPER	       ;;
	  ELSEF 		       ;;
	     XLATT ALPHA_LOWER	       ;;
	  ENDIFF		       ;;
	  XLATT NON_ALPHA_LOWER        ;;
      ENDIFF			       ;;
   ELSEF			       ;;
     IFF EITHER_SHIFT,NOT	       ;;
	  IFKBD XT_KB+AT_KB	 ;;
	      IFF  EITHER_CTL	       ;;
	      ANDF ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	  ELSEF 		       ;;
	      IFF EITHER_CTL,NOT       ;;
	      ANDF R_ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF			 ;;
	  ENDIFF			 ;;
      IFKBD AT_KB+XT_KB 	   ;;
	IFF EITHER_CTL			 ;;
	ANDF ALT_SHIFT			 ;;
	  XLATT ALT_CASE		 ;;
	ENDIFF				 ;;
      ENDIFF				 ;;
      IFKBD G_KB+P12_KB 		 ;;
	IFF EITHER_CTL			 ;;
	ANDF ALT_SHIFT			 ;;
	  IFF R_ALT_SHIFT,NOT		 ;;
	    XLATT ALT_CASE		 ;;
	  ENDIFF			 ;;
	ENDIFF				 ;;
      ENDIFF				 ;;
     ENDIFF				 ;;
   ENDIFF				 ;;
;IFF EITHER_SHIFT,NOT			 ;;
   IFKBD AT_KB+XT_KB		   ;;
     IFF EITHER_CTL,NOT 		 ;;
       IFF ALT_SHIFT			 ;; ALT - case
	 XLATT ALT_CASE 		 ;;
       ENDIFF				 ;;
     ELSEF				 ;;
	 XLATT CTRL_CASE		 ;;
     ENDIFF				 ;;
   ENDIFF				 ;;
					 ;;
   IFKBD G_KB+P12_KB			 ;;
     IFF EITHER_CTL,NOT 		 ;;
       IFF ALT_SHIFT			 ;; ALT - case
       ANDF R_ALT_SHIFT,NOT		 ;;
	 XLATT ALT_CASE 		 ;;
       ENDIFF				 ;;
     ELSEF				 ;;
	 XLATT CTRL_CASE		 ;;
     ENDIFF				 ;;
;  ENDIFF				 ;;
 ENDIFF 				 ;;
					 ;;
   EXIT_STATE_LOGIC			 ;;
					 ;;
LOGIC_END:				 ;;
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; SF Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC SF_COMMON_XLAT		       ;;
SF_COMMON_XLAT: 		       ;;
				       ;;
   DW	 COMMON_XLAT_END-$	       ;; length of section
   DW	 -1			       ;; code page
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Lower Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_SF_LO_END-$	       ;; length of state section
   DB	 DEAD_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 13			       ;; scan code
   FLAG  CIRCUMFLEX		       ;; flag bit to set
   DB	 27			       ;; scan code
   FLAG  DIARESIS		       ;; flag bit to set
				       ;;
				       ;;
COM_SF_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Upper Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_SF_UP_END-$	       ;; length of state section
   DB	 DEAD_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 1			       ;; number of entries
   DB	 13			       ;; scan code
   FLAG  GRAVE			       ;; flag bit to set
COM_SF_UP_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_TH_END-$	       ;; length of state section
   DB	 DEAD_THIRD		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 13			       ;; scan code
   FLAG  TILDE			       ;; flag bit to set
   DB	 12			       ;; scan code
   FLAG  ACUTE			       ;; flag bit to set
COM_DK_TH_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K1_END-$	       ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_ALT_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 2			       ;; 5 Number of entries
;  DB	 12,-1,-1		       ;;
;  DB	 13,-1,-1		       ;;
   DB	 21,0,2CH		       ;;
   DB	 44,0,15H		       ;;
;  DB	 53,0,82H		       ;;
COM_ALT_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_ALT_K1_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K1_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_CTRL_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 6			       ;; Number of entries
   DB	 12,-1,-1		       ;;
   DB	 21,01AH,15H		       ;;
   DB	 43,-1,-1		       ;;
   DB	 44,019H,2CH		       ;;
   DB	 53,01FH,35H		       ;;
   DB	 86,01CH,56H		       ;;
COM_CTRL_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CTRL_K1_END:			;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_LO_END-$	       ;; length of state section
   DB	 ALPHA_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	 21,'z'                        ;; small z
   DB	 44,'y'                        ;; small y
				       ;;
COM_AL_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_UP_END-$	       ;; length of state section
   DB	 ALPHA_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	 21,'Z'                        ;; caps  Z
   DB	 44,'Y'                        ;; caps  Y
COM_AL_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_UP_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G_KB+P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K1_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 7			       ;; number of entries
   DB	 12,"'"                        ;;
   DB	 26,8AH 		       ;; e Grave
   DB	 39,82H 		       ;; e Acute
   DB	 40,85H 		       ;; a Grave
   DB	 43,'$'                        ;;
   DB	 86,'<'                        ;;
   DB	 53,'-'                        ;;
COM_NA_LO_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: AT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				     ;;
 DW    COM_NA_LO_K2_END-$	     ;; length of state section
 DB    NON_ALPHA_LOWER		     ;; State ID
 DW    AT_KB			     ;; Keyboard Type
 DB    -1,-1			     ;; Buffer entry for error character
				     ;;
 DW    COM_NA_LO_K2_T1_END-$	     ;; Size of xlat table
 DB    STANDARD_TABLE		     ;; xlat options:
 DB    7			     ;; number of entries
 DB    12,"'"                        ;;
 DB    26,8AH			     ;; e Grave
 DB    39,82H			     ;; e Acute
 DB    40,85H			     ;; a Grave
 DB    41,'<'                        ;;
 DB    43,'$'                        ;;
 DB    53,'-'                        ;;
COM_NA_LO_K2_T1_END:		     ;;
				     ;;
   DW	 0			     ;; Size of xlat table - null table
				     ;;
COM_NA_LO_K2_END:		     ;;
				     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: XT_KB+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K3_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K3_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 7			       ;; number of entries
   DB	 12,"'"                        ;;
   DB	 26,8AH 		       ;; e Grave
   DB	 39,82H 		     ;; e Acute
   DB	 40,85H 		     ;; a Grave
   DB	 41,'$'                        ;;
   DB	 43,'<'                        ;;
   DB	 53,'-'                        ;;
COM_NA_LO_K3_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K3_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G_KB+P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 20			       ;; number of entries
   DB	 41,0F8H		       ;; degree symbol
   DB	  2,'+'                        ;;
   DB	  3,'"'                        ;;
   DB	  4,'*'                        ;;
   DB	  5,087H		       ;; 
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 43,09CH		       ;;
   DB	 27,'!'                        ;;
   DB	 86,'>'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
   DB	 26,81H 		       ;; u diaeresis
   DB	 39,94H 		       ;; o diaeresis
   DB	 40,84H 		       ;; a diaeresis
COM_NA_UP_T1_K1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K1_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K2_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K2_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 19			       ;; number of entries
   DB	 41,'>'                        ;; degree symbol
   DB	  2,'+'                        ;;
   DB	  3,'"'                        ;;
   DB	  4,'*'                        ;;
   DB	  5,087H		       ;; 
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 43,09CH		       ;;
   DB	 27,'!'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
   DB	 26,81H 		       ;; u diaeresis
   DB	 39,94H 		       ;; o diaeresis
   DB	 40,84H 		       ;; a diaeresis
COM_NA_UP_T1_K2_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K2_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K3_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K3_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 19			       ;; number of entries
   DB	 43,'>'                        ;; degree symbol
   DB	  2,'+'                        ;;
   DB	  3,'"'                        ;;
   DB	  4,'*'                        ;;
   DB	  5,087H		       ;; 
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 41,09CH		       ;;
   DB	 27,'!'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
   DB	 26,81H 		       ;; u diaeresis
   DB	 39,94H 		       ;; o diaeresis
   DB	 40,84H 		       ;; a diaeresis
COM_NA_UP_T1_K3_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K3_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K1_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_K1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  8			       ;; number of entries
   DB	  3,"@"                        ;;
   DB	  4,'#'                        ;;
   DB	  7,0AAH		       ;; 
   DB	 43,'}'                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 40,'{'                        ;;
   DB	 86,'\'                        ;;
COM_THIRD_T1_K1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K1_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K2_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_K2_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  9			       ;; number of entries
   DB	  3,"@"                        ;;
   DB	  4,'#'                        ;;
   DB	  5,0F8H		       ;; degree symbol
   DB	  8,07CH		       ;; broken vertical - |
   DB	 40,'}'                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 39,'{'                        ;;
   DB	 41,'\'                        ;;
COM_THIRD_T1_K2_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K2_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: XT+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K3_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_K3_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  9			       ;; number of entries
   DB	  3,"@"                        ;;
   DB	  4,'#'                        ;;
   DB	  5,0F8H		       ;; degree symbol
   DB	  6,0E8H		       ;; 	 symbol
   DB	 41,'}'                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 40,'{'                        ;;
   DB	 43,'\'                        ;;
COM_THIRD_T1_K3_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K3_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_LO_END-$	       ;; length of state section
   DB	 GRAVE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,08AH		       ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
COM_GR_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_LO_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_SP_END-$	       ;; length of state section
   DB	 GRAVE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,96			       ;; STANDALONE GRAVE
COM_GR_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_LO_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_LOWER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
COM_CI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CI_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_SP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_SPACE	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,94			       ;; STANDALONE CIRCUMFLEX
COM_CI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  COM_TI_LO_END-$		;; length of state section
    DB	  TILDE_LOWER			;; State ID
    DW	  ANY_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  COM_TI_LO_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  1				;; number of scans
    DB	  49,0A4H			;; scan code,ASCII - 
 COM_TI_LO_T1_END:			;;
					;;
    DW	  0				;;
					;;
 COM_TI_LO_END: 			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: Common
;;; STATE: Tilde Upper Case
;;; KEYBOARD TYPES: All
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  COM_TI_UP_END-$		;; length of state section
    DB	  TILDE_UPPER			;; State ID
    DW	  ANY_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  COM_TI_UP_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  1				;; number of scans
    DB	  49,0A5H			;; scan code,ASCII - 
 COM_TI_UP_T1_END:			;;
					;;
    DW	  0				;; Size of xlat table - null table
					;;
 COM_TI_UP_END: 			;; length of state section
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_TI_SP_END-$	       ;; length of state section
   DB	 TILDE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 07EH,0 		       ;; error character = standalone accent
				       ;;
   DW	 COM_TI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,07EH		       ;; STANDALONE TILDE
COM_TI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_TI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; Last State
COMMON_XLAT_END:		       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; SF Specific Translate Section for 437
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC SF_437_XLAT		       ;;
SF_437_XLAT:			       ;;
				       ;;
   DW	  CP437_XLAT_END-$	       ;; length of section
   DW	  437			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_NA_LO_END-$		 ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP437_NA_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 41,015H			;; Section Symbol
CP437_NA_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_NA_LO_END:			 ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_THIRD_K1_END-$		    ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP437_THIRD_T1_K1_END-$	    ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 3			       ;; number of entries
   DB	  2,0B3H		       ;; Solid vertical
   DB	  8,07CH		       ;; Broken vertical
   DB	  9,09BH		       ;;  cent sign
CP437_THIRD_T1_K1_END:			    ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_THIRD_K1_END:			    ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Third Shift
;; KEYBOARD TYPES: AT+XT+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_THIRD_K2_END-$		    ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 AT_KB+XT_KB		 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP437_THIRD_T1_K2_END-$	    ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	  8,07CH		       ;; Broken vertical
   DB	  6,015H		       ;; Section Symbol
CP437_THIRD_T1_K2_END:			    ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_THIRD_K2_END:			    ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_AC_LO_END-$		 ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_AC_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP437_AC_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_AC_LO_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_AC_UP_END-$		 ;; length of state section
   DB	 ACUTE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_AC_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 18,''                        ;; scan code,ASCII - 
CP437_AC_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_AC_UP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_DI_LO_END-$		 ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 34,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_DI_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 44,''                        ;; scan code,ASCII - y
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP437_DI_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_DI_LO_END:			 ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_DI_UP_END-$		 ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 34,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_DI_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 22,''                        ;; scan code,ASCII - U
   DB	 24,''                        ;; scan code,ASCII - O
   DB	 30,''                        ;; scan code,ASCII - A
CP437_DI_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_DI_UP_END:			 ;; length of state section
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: CapsLock
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_BOTRH_END-$	       ;; length of state section
   DB	 BOTRH_CAPS		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP437_BOTRH_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  3			       ;; number of entries
   DB	 39,082H		       ;; e ACUTE
   DB	 26,08AH		       ;; e GRAVE
   DB	 40,085H		       ;; a GRAVE
CP437_BOTRH_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
CP437_BOTRH_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: CapsLock + Shift
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_BOTRH_K1_END-$	       ;; length of state section
   DB	 BOTRH_F_CAPS		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP437_BOTRH_T2_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  3			       ;; number of entries
   DB	 39,094H		       ;; o di
   DB	 26,081H		       ;; u di
   DB	 40,084H		       ;; a di
CP437_BOTRH_T2_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
CP437_BOTRH_K1_END:		       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	  0			       ;; LAST STATE
				       ;;
CP437_XLAT_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; SF Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC SF_850_XLAT		       ;;
SF_850_XLAT:			       ;;
				       ;;
   DW	  CP850_XLAT_END-$	       ;; length of section
   DW	  850			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: CapsLock
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_BOTRH_END-$	       ;; length of state section
   DB	 BOTRH_CAPS		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_BOTRH_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  3			       ;; number of entries
   DB	 39,090H		       ;; CAP E ACUTE
   DB	 26,0D4H		       ;; CAP E GRAVE
   DB	 40,0B7H		       ;; CAP A GRAVE
CP850_BOTRH_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
CP850_BOTRH_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: CapsLock + Shift
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_BOTRH_K1_END-$	       ;; length of state section
   DB	 BOTRH_F_CAPS		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_BOTRH_T2_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  3			       ;; number of entries
   DB	 26,09AH		       ;; CAP U di
   DB	 39,099H		       ;; CAP O di
   DB	 40,08EH		       ;; CAP A di
CP850_BOTRH_T2_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
CP850_BOTRH_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G_KB+P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_LO_END-$		 ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_NA_LO_T1_END-$		;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 41,0F5H		       ;; Section Symbol
CP850_NA_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_LO_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
  DW	CP850_THIRD_K1_END-$	       ;; length of state section
  DB	THIRD_SHIFT		       ;; State ID
  DW	G_KB+P12_KB		       ;; Keyboard Type
  DB	-1,-1			       ;; Buffer entry for error character
				       ;;
  DW	CP850_THIRD_T1_K1_END-$        ;; Size of xlat table
  DB	STANDARD_TABLE		       ;; xlat options:
  DB	3			       ;; number of entries
  DB	 2,07CH 		       ;; Solid vertical
  DB	 8,0DDH 		       ;; Broken vertical
  DB	 9,0BDH 		       ;;  cent sign
CP850_THIRD_T1_K1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_THIRD_K1_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Third Shift
;; KEYBOARD TYPES: AT+XT+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_THIRD_K2_END-$		    ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 AT_KB+XT_KB		 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_THIRD_T1_K2_END-$	    ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	  8,0DDH		       ;; Broken vertical
   DB	  6,0F5H		       ;; Section Symbol
CP850_THIRD_T1_K2_END:			    ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_THIRD_K2_END:			    ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_LO_END-$		 ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 239,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 44,0ECH		       ;; y acute
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP850_AC_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_LO_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_UP_END-$	       ;; length of state section
   DB	 ACUTE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 239,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_UP_T1_END-$		;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of entries
   DB	 18,090H		       ;;    E acute
   DB	 44,0EDH		       ;;    Y acute
   DB	 22,0E9H		       ;;    U acute
   DB	 23,0D6H		       ;;    I acute
   DB	 24,0E0H		       ;;    O acute
   DB	 30,0B5H		       ;;    A acute
CP850_AC_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_UP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_SP_END-$		 ;; length of state section
   DB	 ACUTE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 239,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,239 		       ;; scan code,ASCII - SPACE
CP850_AC_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_SP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_LO_END-$		 ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 44,''                        ;; scan code,ASCII - y
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP850_DI_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_LO_END:			 ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_UP_END-$		 ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,0D3H		       ;;    E Diaeresis
   DB	 22,''                        ;;    U Diaeresis
   DB	 23,0D8H		       ;;    I Diaeresis
   DB	 24,''                        ;;    O Diaeresis
   DB	 30,''                        ;;    A Diaeresis
CP850_DI_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_UP_END:			 ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_SP_END-$		 ;; length of state section
   DB	 DIARESIS_SPACE 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,249 		       ;; error character = standalone accent
CP850_DI_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
CP850_DI_SP_END:			 ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Grave Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_GR_UP_END-$	       ;; length of state section
   DB	 GRAVE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_GR_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,0D4H		       ;;    E grave
   DB	 22,0EBH		       ;;    U grave
   DB	 23,0DEH		       ;;    I grave
   DB	 24,0E3H		       ;;    O grave
   DB	 30,0B7H		       ;;    A grave
CP850_GR_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_GR_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Tilde Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  CP850_TI_LO_END-$		;; length of state section
    DB	  TILDE_LOWER			;; State ID
    DW	  ANY_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  CP850_TI_LO_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  2				;; number of scans
    DB	  24,0E4H			;; scan code,ASCII - o tilde
    DB	  30,0C6H			;; scan code,ASCII - a tilde
 CP850_TI_LO_T1_END:			;;
					;;
    DW	  0				;;
					;;
 CP850_TI_LO_END:			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: 850
;;; STATE: Tilde Upper Case
;;; KEYBOARD TYPES: All
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  CP850_TI_UP_END-$		;; length of state section
    DB	  TILDE_UPPER			;; State ID
    DW	  ANY_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  CP850_TI_UP_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  2				;; number of scans
    DB	  24,0E5H			;; scan code,ASCII - O tilde
    DB	  30,0C7H			;; scan code,ASCII - A tilde
 CP850_TI_UP_T1_END:			;;
					;;
    DW	  0				;; Size of xlat table - null table
					;;
 CP850_TI_UP_END:			;; length of state section
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Circumflex Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_CI_UP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_UPPER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_CI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,0D2H		       ;;    E circumflex
   DB	 22,0EAH		       ;;    U circumflex
   DB	 23,0D7H		       ;;    I circumflex
   DB	 24,0E2H		       ;;    O circumflex
   DB	 30,0B6H		       ;;    A circumflex
CP850_CI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_CI_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
   DW	 0			       ;; LAST STATE
				       ;;
CP850_XLAT_END: 		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CODE	 ENDS			       ;;
	 END			       ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kbd2\kdfsg.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
	PAGE	,132

	TITLE	MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Defintion File
;;
;; This file contains the keyboard tables for Swiss German
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC	       ;;
	INCLUDE POSTEQU.INC	       ;;
	INCLUDE KEYBMAC.INC	       ;;
				       ;;
	PUBLIC SG_LOGIC 	       ;;
	PUBLIC SG_437_XLAT	       ;;
	PUBLIC SG_850_XLAT	       ;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a liner search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE	    EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; SG State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
SG_LOGIC:

   DW  LOGIC_END-$		       ;; length
				       ;;
   DW  0			       ;; special features
				       ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND 	       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;  ***BD - THIS SECTION HAS BEEN UPDATED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
IFF EITHER_ALT,NOT		       ;;
ANDF EITHER_CTL,NOT		       ;;
   IFF EITHER_SHIFT		       ;;
	SET_FLAG DEAD_UPPER	       ;;
      ELSEF			       ;;
	SET_FLAG DEAD_LOWER	       ;;
      ENDIFF			       ;;
ENDIFF				       ;;
IFF EITHER_SHIFT,NOT		       ;;
   IFKBD XT_KB+AT_KB		 ;;
      IFF EITHER_CTL		       ;;
      ANDF ALT_SHIFT		       ;;
	SET_FLAG DEAD_THIRD	       ;;
      ENDIFF			       ;;
   ELSEF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF R_ALT_SHIFT		       ;;
	 SET_FLAG DEAD_THIRD	       ;;
      ENDIFF			       ;;
   ENDIFF			       ;;
ENDIFF				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:			       ;;
				       ;;
   IFF ACUTE,NOT		       ;;
      GOTO DIARESIS_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ACUTE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_ACUTE:			       ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      GOTO NON_DEAD		       ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:			       ;;
				       ;;
   IFF DIARESIS,NOT		       ;;
      GOTO GRAVE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT DIARESIS_SPACE	       ;;  exist for 437 so beep for
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_DIARESIS:		       ;;
      PUT_ERROR_CHAR DIARESIS_LOWER    ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:			       ;;
				       ;;
   IFF GRAVE,NOT		       ;;
      GOTO TILDE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT GRAVE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_GRAVE:			       ;;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TILDE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TILDE_PROC:			       ;;
				       ;;
   IFF TILDE,NOT		       ;;
      GOTO CIRCUMFLEX_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT TILDE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT TILDE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT TILDE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT TILDE_UPPER        ;;
	   ELSEF		       ;;
	      XLATT TILDE_LOWER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_TILDE:			       ;;
      PUT_ERROR_CHAR TILDE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:		       ;;
				       ;;
   IFF CIRCUMFLEX,NOT		       ;;
      GOTO NON_DEAD		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CIRCUMFLEX:		       ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
NON_DEAD:			       ;;
				       ;;
   IFKBD G_KB+P12_KB		       ;; Avoid accidentally translating
   ANDF LC_E0			       ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC		       ;;   G keyboard
   ENDIFF			       ;;
				       ;;
   IFF	EITHER_ALT,NOT		       ;; Lower and upper case.  Alphabetic
   ANDF EITHER_CTL,NOT		       ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT		       ;; Numeric keys are not.
	  IFF CAPS_STATE	       ;;
	      XLATT BOTLH_F_CAPS       ;;
	      XLATT ALPHA_LOWER        ;;
	  ELSEF 		       ;;
	      XLATT ALPHA_UPPER        ;;
	  ENDIFF		       ;;
	  XLATT NON_ALPHA_UPPER        ;;
      ELSEF			       ;;
	  IFF CAPS_STATE	       ;;
	     XLATT BOTLH_CAPS	       ;;
	     XLATT ALPHA_UPPER	       ;;
	  ELSEF 		       ;;
	     XLATT ALPHA_LOWER	       ;;
	  ENDIFF		       ;;
	  XLATT NON_ALPHA_LOWER        ;;
      ENDIFF			       ;;
   ELSEF			       ;;
     IFF EITHER_SHIFT,NOT	       ;;
	  IFKBD XT_KB+AT_KB	 ;;
	      IFF  EITHER_CTL	       ;;
	      ANDF ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	  ELSEF 		       ;;
	      IFF EITHER_CTL,NOT       ;;
	      ANDF R_ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF			 ;;
	  ENDIFF			 ;;
      IFKBD AT_KB+XT_KB 	   ;;
	IFF EITHER_CTL			 ;;
	ANDF ALT_SHIFT			 ;;
	  XLATT ALT_CASE		 ;;
	ENDIFF				 ;;
      ENDIFF				 ;;
      IFKBD G_KB+P12_KB 		 ;;
	IFF EITHER_CTL			 ;;
	ANDF ALT_SHIFT			 ;;
	  IFF R_ALT_SHIFT,NOT		 ;;
	    XLATT ALT_CASE		 ;;
	  ENDIFF			 ;;
	ENDIFF				 ;;
      ENDIFF				 ;;
     ENDIFF				 ;;
   ENDIFF				 ;;
;IFF EITHER_SHIFT,NOT			 ;;
   IFKBD AT_KB+XT_KB		   ;;
     IFF EITHER_CTL,NOT 		 ;;
       IFF ALT_SHIFT			 ;; ALT - case
	 XLATT ALT_CASE 		 ;;
       ENDIFF				 ;;
     ELSEF				 ;;
	 XLATT CTRL_CASE		 ;;
     ENDIFF				 ;;
   ENDIFF				 ;;
					 ;;
   IFKBD G_KB+P12_KB			 ;;
     IFF EITHER_CTL,NOT 		 ;;
       IFF ALT_SHIFT			 ;; ALT - case
       ANDF R_ALT_SHIFT,NOT		 ;;
	 XLATT ALT_CASE 		 ;;
       ENDIFF				 ;;
     ELSEF				 ;;
	 XLATT CTRL_CASE		 ;;
     ENDIFF				 ;;
;  ENDIFF				 ;;
 ENDIFF 				 ;;
					 ;;
   EXIT_STATE_LOGIC			 ;;
					 ;;
LOGIC_END:				 ;;
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; SG Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC SG_COMMON_XLAT		       ;;
SG_COMMON_XLAT: 		       ;;
				       ;;
   DW	 COMMON_XLAT_END-$	       ;; length of section
   DW	 -1			       ;; code page
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Lower Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_SG_LO_END-$	       ;; length of state section
   DB	 DEAD_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 13			       ;; scan code
   FLAG  CIRCUMFLEX		       ;; flag bit to set
   DB	 27			       ;; scan code
   FLAG  DIARESIS		       ;; flag bit to set
				       ;;
				       ;;
COM_SG_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Upper Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_SG_UP_END-$	       ;; length of state section
   DB	 DEAD_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 1			       ;; number of entries
   DB	 13			       ;; scan code
   FLAG  GRAVE			       ;; flag bit to set
COM_SG_UP_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_TH_END-$	       ;; length of state section
   DB	 DEAD_THIRD		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 13			       ;; scan code
   FLAG  TILDE			       ;; flag bit to set
   DB	 12			       ;; scan code
   FLAG  ACUTE			       ;; flag bit to set
COM_DK_TH_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K1_END-$	       ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_ALT_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 2			       ;; 5 Number of entries
;  DB	 12,-1,-1		       ;;
;  DB	 13,-1,-1	       ;;
   DB	 21,0,2CH		       ;;
   DB	 44,0,15H		       ;;
;  DB	 53,0,82H		       ;;
COM_ALT_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_ALT_K1_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K1_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_CTRL_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 6			       ;; Number of entries
   DB	 12,-1,-1		       ;;
   DB	 21,01AH,15H		       ;;
   DB	 43,-1,-1		       ;;
   DB	 44,019H,2CH		       ;;
   DB	 53,01FH,35H		       ;;
   DB	 86,01CH,56H		       ;;
COM_CTRL_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CTRL_K1_END:			;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_LO_END-$	       ;; length of state section
   DB	 ALPHA_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	 21,'z'                        ;; small z
   DB	 44,'y'                        ;; small y
				       ;;
COM_AL_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_UP_END-$	       ;; length of state section
   DB	 ALPHA_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	 21,'Z'                        ;; caps  Z
   DB	 44,'Y'                        ;; caps  Y
COM_AL_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_UP_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G_KB+P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K1_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 7			       ;; number of entries
   DB	 12,"'"                        ;;
   DB	 39,''                        ;; diaresis - o
   DB	 26,''                        ;; diaresis - u
   DB	 40,''                        ;; diaresis - a
   DB	 43,'$'                        ;;
   DB	 86,'<'                        ;;
   DB	 53,'-'                        ;;
COM_NA_LO_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: AT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				     ;;
 DW    COM_NA_LO_K2_END-$	     ;; length of state section
 DB    NON_ALPHA_LOWER		     ;; State ID
 DW    AT_KB			     ;; Keyboard Type
 DB    -1,-1			     ;; Buffer entry for error character
				     ;;
 DW    COM_NA_LO_K2_T1_END-$	     ;; Size of xlat table
 DB    STANDARD_TABLE		     ;; xlat options:
 DB    7			     ;; number of entries
 DB    12,"'"                        ;;
 DB    39,''                        ;; diaresis - o
 DB    26,''                        ;; diaresis - u
 DB    40,''                        ;; diaresis - a
 DB    41,'<'                        ;;
 DB    43,'$'                        ;;
 DB    53,'-'                        ;;
COM_NA_LO_K2_T1_END:		     ;;
				     ;;
   DW	 0			     ;; Size of xlat table - null table
				     ;;
COM_NA_LO_K2_END:		     ;;
				     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: XT_KB+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K3_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K3_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 7			       ;; number of entries
   DB	 12,"'"                        ;;
   DB	 39,''                        ;; diaresis - o
   DB	 26,''                        ;; diaresis - u
   DB	 40,''                        ;; diaresis - a
   DB	 41,'$'                        ;;
   DB	 43,'<'                        ;;
   DB	 53,'-'                        ;;
COM_NA_LO_K3_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K3_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G_KB+P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 20			       ;; number of entries
   DB	 41,0F8H		       ;; degree symbol
   DB	  2,'+'                        ;;
   DB	  3,'"'                        ;;
   DB	  4,'*'                        ;;
   DB	  5,087H		       ;; 
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 43,09CH		       ;;
   DB	 27,'!'                        ;;
   DB	 86,'>'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
   DB	 39,''                        ;; acute e
   DB	 26,''                        ;; grave e
   DB	 40,''                        ;; grave a
COM_NA_UP_T1_K1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K1_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K2_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K2_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 19			       ;; number of entries
   DB	 41,'>'                        ;; degree symbol
   DB	  2,'+'                        ;;
   DB	  3,'"'                        ;;
   DB	  4,'*'                        ;;
   DB	  5,087H		       ;; 
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 43,09CH		       ;;
   DB	 27,'!'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
   DB	 39,''                        ;; acute e
   DB	 26,''                        ;; grave e
   DB	 40,''                        ;; grave a
COM_NA_UP_T1_K2_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K2_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K3_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K3_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 19			       ;; number of entries
   DB	 43,'>'                        ;; degree symbol
   DB	  2,'+'                        ;;
   DB	  3,'"'                        ;;
   DB	  4,'*'                        ;;
   DB	  5,087H		       ;; 
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 41,09CH		       ;;
   DB	 27,'!'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
   DB	 39,''                        ;; acute e - Shift stae for SWISS GR
   DB	 26,''                        ;; grave e
   DB	 40,''                        ;; grave a
COM_NA_UP_T1_K3_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K3_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K1_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_K1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  8			       ;; number of entries
   DB	  3,"@"                        ;;
   DB	  4,'#'                        ;;
   DB	  7,0AAH		       ;; 
   DB	 43,'}'                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 40,'{'                        ;;
   DB	 86,'\'                        ;;
COM_THIRD_T1_K1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K1_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K2_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_K2_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  9			       ;; number of entries
   DB	  3,"@"                        ;;
   DB	  4,'#'                        ;;
   DB	  5,0F8H		       ;; degree symbol
   DB	  8,07CH		       ;; broken vertical - |
   DB	 40,'}'                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 39,'{'                        ;;
   DB	 41,'\'                        ;;
COM_THIRD_T1_K2_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K2_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: XT+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K3_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_K3_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  9			       ;; number of entries
   DB	  3,"@"                        ;;
   DB	  4,'#'                        ;;
   DB	  5,0F8H		       ;; degree symbol
   DB	  6,0E8H		       ;; 	 symbol
   DB	 41,'}'                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 40,'{'                        ;;
   DB	 43,'\'                        ;;
COM_THIRD_T1_K3_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K3_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_LO_END-$	       ;; length of state section
   DB	 GRAVE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,08AH		       ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
COM_GR_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_LO_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_SP_END-$	       ;; length of state section
   DB	 GRAVE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,96			       ;; STANDALONE GRAVE
COM_GR_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_LO_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_LOWER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
COM_CI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CI_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_SP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_SPACE	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,94			       ;; STANDALONE CIRCUMFLEX
COM_CI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  COM_TI_LO_END-$		;; length of state section
    DB	  TILDE_LOWER			;; State ID
    DW	  ANY_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  COM_TI_LO_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  1				;; number of scans
    DB	  49,0A4H			;; scan code,ASCII - 
 COM_TI_LO_T1_END:			;;
					;;
    DW	  0				;;
					;;
 COM_TI_LO_END: 			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: Common
;;; STATE: Tilde Upper Case
;;; KEYBOARD TYPES: All
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  COM_TI_UP_END-$		;; length of state section
    DB	  TILDE_UPPER			;; State ID
    DW	  ANY_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  COM_TI_UP_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  1				;; number of scans
    DB	  49,0A5H			;; scan code,ASCII - 
 COM_TI_UP_T1_END:			;;
					;;
    DW	  0				;; Size of xlat table - null table
					;;
 COM_TI_UP_END: 			;; length of state section
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_TI_SP_END-$	       ;; length of state section
   DB	 TILDE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 07EH,0 		       ;; error character = standalone accent
				       ;;
   DW	 COM_TI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,07EH		       ;; STANDALONE TILDE
COM_TI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_TI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; Last State
COMMON_XLAT_END:		       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; SG Specific Translate Section for 437
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC SG_437_XLAT		       ;;
SG_437_XLAT:			       ;;
				       ;;
   DW	  CP437_XLAT_END-$	       ;; length of section
   DW	  437			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_NA_LO_END-$		 ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP437_NA_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 41,015H			;; Section Symbol
CP437_NA_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_NA_LO_END:			 ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_THIRD_K1_END-$		    ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP437_THIRD_T1_K1_END-$	    ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 3			       ;; number of entries
   DB	  2,0B3H		       ;; Solid vertical
   DB	  8,07CH		       ;; Broken vertical
   DB	  9,09BH		       ;;  cent sign
CP437_THIRD_T1_K1_END:			    ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_THIRD_K1_END:			    ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Third Shift
;; KEYBOARD TYPES: AT+XT+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_THIRD_K2_END-$		    ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 AT_KB+XT_KB		 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP437_THIRD_T1_K2_END-$	    ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	  8,07CH		       ;; Broken vertical
   DB	  6,015H		       ;; Section Symbol
CP437_THIRD_T1_K2_END:			    ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_THIRD_K2_END:			    ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_AC_LO_END-$		 ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_AC_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP437_AC_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_AC_LO_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_AC_UP_END-$		 ;; length of state section
   DB	 ACUTE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_AC_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 18,''                        ;; scan code,ASCII - 
CP437_AC_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_AC_UP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_DI_LO_END-$		 ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 34,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_DI_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 44,''                        ;; scan code,ASCII - y
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP437_DI_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_DI_LO_END:			 ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_DI_UP_END-$		 ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 34,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_DI_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 22,''                        ;; scan code,ASCII - U
   DB	 24,''                        ;; scan code,ASCII - O
   DB	 30,''                        ;; scan code,ASCII - A
CP437_DI_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_DI_UP_END:			 ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: CapsLock
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_BOTLH_K1_END-$	       ;; length of state section
   DB	 BOTLH_CAPS		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP437_BOTLH_K1_T1_END-$       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  3			       ;; number of entries
   DB	 39,099H		       ;; CAP O Umlaut
   DB	 26,09AH		       ;; CAP U Umlaut
   DB	 40,08EH		       ;; CAP A Umlaut
CP437_BOTLH_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
CP437_BOTLH_K1_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: CapsLock + Shift
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_BOTLH_T1_END-$	       ;; length of state section
   DB	 BOTLH_F_CAPS		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP437_BOTLH_T1_K2_END-$       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  3			       ;; number of entries
   DB	 39,082H		       ;; e Acute
   DB	 26,08AH		       ;; e Grave
   DB	 40,085H		       ;; a Grave
CP437_BOTLH_T1_K2_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
CP437_BOTLH_T1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	  0			       ;; LAST STATE
				       ;;
CP437_XLAT_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; SG Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC SG_850_XLAT		       ;;
SG_850_XLAT:			       ;;
				       ;;
   DW	  CP850_XLAT_END-$	       ;; length of section
   DW	  850			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: CapsLock
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_BOTLH_END-$	       ;; length of state section
   DB	 BOTLH_CAPS		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_BOTLH_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  3			       ;; number of entries
   DB	 26,09AH		       ;; CAP U Umlaut
   DB	 39,099H		       ;; CAP O Umlaut
   DB	 40,08EH		       ;; CAP A Umlaut
CP850_BOTLH_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
CP850_BOTLH_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: CapsLock + Shift
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_BOTLH_K1_END-$	       ;; length of state section
   DB	 BOTLH_F_CAPS		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_BOTLH_T1_K1_END-$       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  3			       ;; number of entries
   DB	 26,0D4H		       ;; CAP E Grave
   DB	 39,090H		       ;; CAP E Acute
   DB	 40,0B7H		       ;; CAP A Grave
CP850_BOTLH_T1_K1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
CP850_BOTLH_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G_KB+P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_LO_END-$		 ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_NA_LO_T1_END-$		;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 41,0F5H		       ;; Section Symbol
CP850_NA_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_LO_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
  DW	CP850_THIRD_K1_END-$	       ;; length of state section
  DB	THIRD_SHIFT		       ;; State ID
  DW	G_KB+P12_KB		       ;; Keyboard Type
  DB	-1,-1			       ;; Buffer entry for error character
				       ;;
  DW	CP850_THIRD_T1_K1_END-$        ;; Size of xlat table
  DB	STANDARD_TABLE		       ;; xlat options:
  DB	3			       ;; number of entries
  DB	 2,07CH 		       ;; Solid vertical
  DB	 8,0DDH 		       ;; Broken vertical
  DB	 9,0BDH 		       ;;  cent sign
CP850_THIRD_T1_K1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_THIRD_K1_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Third Shift
;; KEYBOARD TYPES: AT+XT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_THIRD_K2_END-$		    ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 AT_KB+XT_KB		 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_THIRD_T1_K2_END-$	    ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	  8,0DDH		       ;; Broken vertical
   DB	  6,0F5H		       ;; Section Symbol
CP850_THIRD_T1_K2_END:			    ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_THIRD_K2_END:			    ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_LO_END-$		 ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 239,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 44,0ECH		       ;; y acute
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP850_AC_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_LO_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_UP_END-$	       ;; length of state section
   DB	 ACUTE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 239,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_UP_T1_END-$		;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of entries
   DB	 18,090H		       ;;    E acute
   DB	 44,0EDH		       ;;    Y acute
   DB	 22,0E9H		       ;;    U acute
   DB	 23,0D6H		       ;;    I acute
   DB	 24,0E0H		       ;;    O acute
   DB	 30,0B5H		       ;;    A acute
CP850_AC_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_UP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_SP_END-$		 ;; length of state section
   DB	 ACUTE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 239,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,239 		       ;; scan code,ASCII - SPACE
CP850_AC_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_SP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_LO_END-$		 ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 44,''                        ;; scan code,ASCII - y
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP850_DI_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_LO_END:			 ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_UP_END-$		 ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,0D3H		       ;;    E Diaeresis
   DB	 22,''                        ;;    U Diaeresis
   DB	 23,0D8H		       ;;    I Diaeresis
   DB	 24,''                        ;;    O Diaeresis
   DB	 30,''                        ;;    A Diaeresis
CP850_DI_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_UP_END:			 ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_SP_END-$		 ;; length of state section
   DB	 DIARESIS_SPACE 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,249 		       ;; error character = standalone accent
CP850_DI_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
CP850_DI_SP_END:			 ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Grave Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_GR_UP_END-$	       ;; length of state section
   DB	 GRAVE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_GR_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,0D4H		       ;;    E grave
   DB	 22,0EBH		       ;;    U grave
   DB	 23,0DEH		       ;;    I grave
   DB	 24,0E3H		       ;;    O grave
   DB	 30,0B7H		       ;;    A grave
CP850_GR_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_GR_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Tilde Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  CP850_TI_LO_END-$		;; length of state section
    DB	  TILDE_LOWER			;; State ID
    DW	  ANY_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  CP850_TI_LO_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  2				;; number of scans
    DB	  24,0E4H			;; scan code,ASCII - o tilde
    DB	  30,0C6H			;; scan code,ASCII - a tilde
 CP850_TI_LO_T1_END:			;;
					;;
    DW	  0				;;
					;;
 CP850_TI_LO_END:			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: 850
;;; STATE: Tilde Upper Case
;;; KEYBOARD TYPES: All
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  CP850_TI_UP_END-$		;; length of state section
    DB	  TILDE_UPPER			;; State ID
    DW	  ANY_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  CP850_TI_UP_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  2				;; number of scans
    DB	  24,0E5H			;; scan code,ASCII - O tilde
    DB	  30,0C7H			;; scan code,ASCII - A tilde
 CP850_TI_UP_T1_END:			;;
					;;
    DW	  0				;; Size of xlat table - null table
					;;
 CP850_TI_UP_END:			;; length of state section
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Circumflex Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_CI_UP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_UPPER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_CI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,0D2H		       ;;    E circumflex
   DB	 22,0EAH		       ;;    U circumflex
   DB	 23,0D7H		       ;;    I circumflex
   DB	 24,0E2H		       ;;    O circumflex
   DB	 30,0B6H		       ;;    A circumflex
CP850_CI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_CI_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
   DW	 0			       ;; LAST STATE
				       ;;
CP850_XLAT_END: 		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CODE	 ENDS			       ;;
	 END			       ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kbd2\kdfsp.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;; LATEST CHANGE ALT & CTL	(November)

;LATEST CHANGE XT "\" third shift (December)
;;;;********************************************
;;;;********************************************
;;;;CONTAINS UPDATES FOR
;;;; 1) ALT, CTRL CASES
;;;; 2) DECIMAL SEPERATOR ON NUMERIC PAD
;;;; 3) STANDALONE DIARESIS VALID ONLY FOR 850
;;;;CHANGES ARE MARKED ***BD
;;;;********************************************
;;;;********************************************

	PAGE	,132
	TITLE	MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Defintion File
;;
;; This file contains the keyboard tables for Spanish.
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC	       ;;
	INCLUDE POSTEQU.INC	       ;;
	INCLUDE KEYBMAC.INC	       ;;
				       ;;
	PUBLIC SP_LOGIC 	       ;;
	PUBLIC SP_437_XLAT	       ;;
	PUBLIC SP_850_XLAT	       ;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a liner search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE	    EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; SP State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
SP_LOGIC:

   DW  LOGIC_END-$		       ;; length
				       ;;
   DW  0			       ;; special features
				       ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND 	       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   IFF	EITHER_ALT,NOT		       ;;
   ANDF EITHER_CTL,NOT		       ;;
      IFF EITHER_SHIFT		       ;;
	  SET_FLAG DEAD_UPPER	       ;;
      ELSEF			       ;;
	  SET_FLAG DEAD_LOWER	       ;;
      ENDIFF			       ;;
   ENDIFF			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:			       ;;
				       ;;
   IFF ACUTE,NOT		       ;;
      GOTO DIARESIS_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ACUTE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_ACUTE:			       ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      GOTO NON_DEAD		       ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:			       ;;
				       ;;
   IFF DIARESIS,NOT		       ;;
      GOTO GRAVE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT DIARESIS_SPACE	       ;;  exist for 437 so beep for
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_DIARESIS:		       ;;
      PUT_ERROR_CHAR DIARESIS_LOWER    ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:			       ;;
				       ;;
   IFF GRAVE,NOT		       ;;
      GOTO CIRCUMFLEX_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT GRAVE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_GRAVE:			       ;;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:		       ;;
				       ;;
   IFF CIRCUMFLEX,NOT		       ;;
      GOTO NON_DEAD		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CIRCUMFLEX:		       ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
NON_DEAD:			       ;;
				       ;;
   IFKBD G_KB+P12_KB		       ;; Avoid accidentally translating
   ANDF LC_E0			       ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC		       ;;   G keyboard
   ENDIFF			       ;;
;;***BD ADDED FOR ALT, CTRL CASES      ;;
      IFF EITHER_CTL,NOT	       ;;
	 IFF  ALT_SHIFT 	       ;; ALT - case
	 ANDF R_ALT_SHIFT,NOT	       ;;
	    XLATT ALT_CASE	       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF EITHER_ALT,NOT	       ;; CTRL - case
	    XLATT CTRL_CASE	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
;;***BD END OF ADDITION
				       ;;
   IFF	EITHER_ALT,NOT		       ;; Lower and upper case.  Alphabetic
   ANDF EITHER_CTL,NOT		       ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT		       ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE,NOT	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_UPPER        ;;
	  IFF CAPS_STATE	       ;;
	      XLATT ALPHA_LOWER        ;;
	  ELSEF 		       ;;
	      XLATT ALPHA_UPPER        ;;
	  ENDIFF		       ;;
      ELSEF			       ;;
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE 	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_LOWER        ;;
	  IFF CAPS_STATE	       ;;
	     XLATT ALPHA_UPPER	       ;;
	  ELSEF 		       ;;
	     XLATT ALPHA_LOWER	       ;;
	  ENDIFF		       ;;
      ENDIFF			       ;;
   ELSEF			       ;;
      IFF EITHER_SHIFT,NOT	       ;;
	  IFKBD XT_KB+AT_KB	 ;;
	      IFF  EITHER_CTL	       ;;
	      ANDF ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	  ELSEF 		       ;;
	      IFF EITHER_CTL,NOT       ;;
	      ANDF R_ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	   ENDIFF		       ;;
      ENDIFF			       ;;
   ENDIFF			       ;;
				       ;;
   EXIT_STATE_LOGIC		       ;;
				       ;;
LOGIC_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; SP Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC SP_COMMON_XLAT		       ;;
SP_COMMON_XLAT: 		       ;;
				       ;;
   DW	 COMMON_XLAT_END-$	       ;; length of section
   DW	 -1			       ;; code page
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Lower Shift Dead Key
;; KEYBOARD TYPES: G + P12
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_LO_K1_END-$	       ;; length of state section
   DB	 DEAD_LOWER		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 26			       ;; scan code
   FLAG  GRAVE			       ;; flag bit to set
   DB	 40			       ;;
   FLAG  ACUTE			       ;;
				       ;;
				       ;;
COM_DK_LO_K1_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Lower Shift Dead Key
;; KEYBOARD TYPES: AT + XT +
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_LO_K2_END-$	       ;; length of state section
   DB	 DEAD_LOWER		       ;; State ID
   DW	 AT_KB+XT_KB		 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 26			       ;; scan code
   FLAG  ACUTE			       ;; flag bit to set
   DB	 27			       ;;
   FLAG  GRAVE			       ;;
				       ;;
				       ;;
COM_DK_LO_K2_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Upper Shift Dead Key
;; KEYBOARD TYPES: G + P12
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_UP_K1_END-$	       ;; length of state section
   DB	 DEAD_UPPER		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 26			       ;; scan code
   FLAG  CIRCUMFLEX		       ;; flag bit to set
   DB	 40			       ;;
   FLAG  DIARESIS		       ;;
				       ;;
COM_DK_UP_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Upper Shift Dead Key
;; KEYBOARD TYPES: AT + XT +
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_UP_END-$	       ;; length of state section
   DB	 DEAD_UPPER		       ;; State ID
   DW	 AT_KB+XT_KB		 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 26			       ;; scan code
   FLAG  DIARESIS		       ;; flag bit to set
   DB	 27			       ;;
   FLAG  CIRCUMFLEX		       ;;
				       ;;
COM_DK_UP_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: G + AT + P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_LO_K1_END-$	       ;; length of state section
   DB	 ALPHA_LOWER		       ;; State ID
   DW	 G_KB+AT_KB+P12_KB	       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_LO_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	 39,164 		       ;; n-tilde
   DB	 43,135 		       ;; c-cedilla
COM_AL_LO_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_LO_K1_END:		       ;;

;;******************************
;;***BD - ADDED FOR NUMERIC PAD (DECIMAL SEPERATOR)
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Numeric Key Pad
;; KEYBOARD TYPES: p12 + G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_PAD_K1_END-$	       ;; length of state section
   DB	 NUMERIC_PAD		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_PAD_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 0			       ;; number of entries
; THIS IS A TEST ENTRY TO SHOW AN EXAMPLE
;  DB	 83,44			       ;; decimal seperator = ,
COM_PAD_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_PAD_K1_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Numeric Key Pad
;; KEYBOARD TYPES: AT+ XT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;				       ;;
;;   DW    COM_PAD_K2_END-$		 ;; length of state section
;;   DB    NUMERIC_PAD			 ;; State ID
;;   DW    AT_KB+XT_KB			 ;; Keyboard Type
;;   DB    -1,-1			 ;; Buffer entry for error character
;;					 ;;
;;   DW    COM_PAD_K2_T2_END-$		 ;; Size of xlat table
;;   DB    STANDARD_TABLE		 ;; xlat options:
;;   DB    1				 ;; number of entries
;;   DB    74,05eh			 ;; circumflex carat under the Prtscr key
;;COM_PAD_K2_T2_END:			 ;;
;;					 ;;
;;   DW    0				 ;; Size of xlat table - null table
;;					 ;;
;;COM_PAD_K2_END:			 ;;
;;					 ;;
;;;;******************************
;;***BD - ADDED FOR ALT CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K1_END-$	       ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_ALT_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 0			       ;; number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB	 53,225,0		       ;; TEST ENTRY
COM_ALT_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_ALT_K1_END: 		       ;;
				       ;;
;;******************************
;;***BD - ADDED FOR CTRL CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G_KB+P12_KB+AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K1_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 G_KB+P12_KB+AT_KB	       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_CTRL_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 2			       ;; number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB	 53,226,0		       ;; TEST ENTRY
   DB	 43,-1,-1		       ;; invalid slash
   DB	 41,28,41		       ;; valid slash
COM_CTRL_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CTRL_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: XT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K2_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 XT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_CTRL_K2_T2_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 1			       ;; number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB	 53,226,0		       ;; TEST ENTRY
   DB	 43,-1,-1		       ;; invalid slash
COM_CTRL_K2_T2_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CTRL_K2_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_LO_K2_END-$	       ;; length of state section
   DB	 ALPHA_LOWER		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_LO_K2_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	 39,164 		       ;; n-tilde
   DB	 41,135 		       ;; c-cedilla
COM_AL_LO_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_LO_K2_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: G + AT + P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_UP_K1_END-$	       ;; length of state section
   DB	 ALPHA_UPPER		       ;; State ID
   DW	 G_KB+AT_KB+P12_KB	       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_UP_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	 39,165 		       ;; N-tilde
   DB	 43,128 		       ;; C-cedilla
COM_AL_UP_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_UP_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_UP_K2_END-$	       ;; length of state section
   DB	 ALPHA_UPPER		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_UP_K2_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	 39,165 		       ;; N-tilde
   DB	 41,128 		       ;; C-cedilla
COM_AL_UP_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_UP_K2_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G + P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K1_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 6			       ;; number of entries
   DB	 12,"'"                        ;; '
   DB	 27,'+'                        ;; +
   DB	 86,'<'                        ;; <
   DB	 53,'-'                        ;; -
   DB	 41,167 		       ;; o-underline
   DB	 13,173 		       ;; upside-dowm !
COM_NA_LO_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K1_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K2_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K2_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 4			       ;; number of entries
   DB	 40,';'                        ;; ;
   DB	 41,'<'                        ;; <
   DB	 53,"'"                        ;; quote
   DB	 55,05eh		       ;; circumflex carat under the Prtscr key
COM_NA_LO_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K2_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K3_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K3_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 4			       ;; number of entries
   DB	 40,';'                        ;; ;
   DB	 43,'<'                        ;; <
   DB	 53,"'"                        ;; quote
   DB	 55,05eh		       ;; circumflex carat under the Prtscr key
COM_NA_LO_K3_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K3_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G + P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K1_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 16			       ;; number of entries
   DB	  3,'"'                        ;;
   DB	  4,250 		       ;; diacritic
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 13,168 		       ;; upside-dowm ?
   DB	 27,'*'                        ;;
   DB	 41,166 		       ;; a-underline
   DB	 86,'>'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
COM_NA_UP_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K1_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K2_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K2_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 8			       ;; number of entries
   DB	 41,'>'                        ;;
   DB	  2,0ADH		       ;; UPSIDE DOWN 
   DB	  3,168 		       ;; UPSIDE DOWN ?
   DB	  7,'/'                        ;;
   DB	 40,':'                        ;;
   DB	 51,'?'                        ;;
   DB	 52,'!'                        ;;
   DB	 53,'"'                        ;;
COM_NA_UP_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K2_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K3_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K3_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 8			       ;; number of entries
   DB	 43,'>'                        ;;
   DB	  2,0ADH		       ;; UPSIDE DOWN 
   DB	  3,168 		       ;; UPSIDE DOWN ?
   DB	  7,'/'                        ;;
   DB	 40,':'                        ;;
   DB	 51,'?'                        ;;
   DB	 52,'!'                        ;;
   DB	 53,'"'                        ;;
COM_NA_UP_K3_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K3_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: G + P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K1_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 9			       ;; number of entries
   DB	 41,'\'                        ;;
   DB	  2,'|'                        ;;
   DB	  3,'@'                        ;;
   DB	  4,'#'                        ;;
   DB	  7,170 		       ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 40,'{'                        ;;
   DB	 43,'}'                        ;;
COM_THIRD_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K2_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K2_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 4			       ;; number of entries
   DB	 41,'\'                        ;;
   DB	  3,'@'                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
COM_THIRD_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K2_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: XT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K3_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K3_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 4			       ;; number of entries
   DB	  3,'@'                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 43,'\'                        ;;
COM_THIRD_K3_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K3_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;					;;
;   DW	  COM_AC_LO_END-$		;; length of state section
;   DB	  ACUTE_LOWER			;; State ID
;   DW	  ANY_KB			;; Keyboard Type
;   DB	  39,0				;; error character = standalone accent
;					;;
;   DW	  COM_AC_LO_T1_END-$		;; Size of xlat table
;   DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
;   DB	  5				;; number of scans
;   DB	  18,''                        ;; scan code,ASCII - e
;   DB	  30,''                        ;; scan code,ASCII - a
;   DB	  24,''                        ;; scan code,ASCII - o
;   DB	  22,''                        ;; scan code,ASCII - u
;   DB	  23,''                        ;; scan code,ASCII - i
;COM_AC_LO_T1_END:			;;
;					;;
;   DW	  0				;; Size of xlat table - null table
;					;;
;COM_AC_LO_END: 			;;
;					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: Common
;;; STATE: Acute Upper Case
;;; KEYBOARD TYPES: All
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;					;;
;   DW	  COM_AC_UP_END-$		;; length of state section
;   DB	  ACUTE_UPPER			;; State ID
;   DW	  ANY_KB			;; Keyboard Type
;   DB	  39,0				;; error character = standalone accent
;					;;
;   DW	  COM_AC_UP_T1_END-$		;; Size of xlat table
;   DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
;   DB	  2				;; number of scans
;   DB	  18,''                        ;; scan code,ASCII - e
;COM_AC_UP_T1_END:			;;
;					;;
;   DW	  0				;; Size of xlat table - null table
;					;;
;COM_AC_UP_END: 			;;
;					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: Common
;;; STATE: Acute Space Bar
;;; KEYBOARD TYPES: All
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;					;;
;   DW	  COM_AC_SP_END-$		;; length of state section
;   DB	  ACUTE_SPACE			;; State ID
;   DW	  ANY_KB			;; Keyboard Type
;   DB	  39,0				;; error character = standalone accent
;					;;
;   DW	  COM_AC_SP_T1_END-$		;; Size of xlat table
;   DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
;   DB	  1				;; number of scans
;   DB	  57,39 			;; scan code,ASCII - SPACE
;COM_AC_SP_T1_END:			;;
;					;;
;   DW	  0				;; Size of xlat table - null table
;					;;
;COM_AC_SP_END: 			;;
;					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DI_LO_END-$	       ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_DI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 30,''                        ;; scan code,ASCII - a
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 21,''                        ;; scan code,ASCII - y
COM_DI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_DI_LO_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DI_UP_END-$	       ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_DI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 30,''                        ;; scan code,ASCII - a
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
COM_DI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_DI_UP_END:			       ;; length of state section
				       ;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_LO_END-$	       ;; length of state section
   DB	 GRAVE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 30,''                        ;; scan code,ASCII - a
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
COM_GR_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_LO_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_SP_END-$	       ;; length of state section
   DB	 GRAVE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,96			       ;; STANDALONE GRAVE
COM_GR_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_LO_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_LOWER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 30,''                        ;; scan code,ASCII - a
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
COM_CI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CI_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_SP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_SPACE	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,94			       ;; STANDALONE CIRCUMFLEX
COM_CI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; Last State
COMMON_XLAT_END:		       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; SP Specific Translate Section for 437
;; 437 IS COMPLETELY COVERED BY THE COMMON TABLE.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC SP_437_XLAT		       ;;
SP_437_XLAT:			       ;;
				       ;;
   DW	  CP437_XLAT_END-$	       ;; length of section
   DW	  437			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  CODE PAGE: Specific 437
;  STATE: Acute Lower Case
;  KEYBOARD TYPES: All
;  TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 CP437_AC_LO_END-$		  ; length of state section
   DB	 ACUTE_LOWER			; State ID
   DW	 ANY_KB 			; Keyboard Type
   DB	 39,0				; error character = standalone accent
					;
   DW	 CP437_AC_LO_T1_END-$		  ; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	; xlat options:
   DB	 5				; number of scans
   DB	 18,''                         ; scan code,ASCII - e
   DB	 30,''                         ; scan code,ASCII - a
   DB	 24,''                         ; scan code,ASCII - o
   DB	 22,''                         ; scan code,ASCII - u
   DB	 23,''                         ; scan code,ASCII - i
CP437_AC_LO_T1_END:			  ;
					;
   DW	 0				; Size of xlat table - null table
					;
CP437_AC_LO_END:			  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  CODE PAGE: 437
;  STATE: Acute Upper Case
;  KEYBOARD TYPES: All
;  TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 CP437_AC_UP_END-$		  ; length of state section
   DB	 ACUTE_UPPER			; State ID
   DW	 ANY_KB 			; Keyboard Type
   DB	 39,0				; error character = standalone accent
					;
   DW	 CP437_AC_UP_T1_END-$		  ; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	; xlat options:
   DB	 1				; number of scans
   DB	 18,''                         ; scan code,ASCII - e
CP437_AC_UP_T1_END:			  ;
					;
   DW	 0				; Size of xlat table - null table
					;
CP437_AC_UP_END:			  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  CODE PAGE: 437
;  STATE: Acute Space Bar
;  KEYBOARD TYPES: All
;  TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 CP437_AC_SP_END-$		  ; length of state section
   DB	 ACUTE_SPACE			; State ID
   DW	 ANY_KB 			; Keyboard Type
   DB	 39,0				; error character = standalone accent
					;
   DW	 CP437_AC_SP_T1_END-$		  ; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	; xlat options:
   DB	 1				; number of scans
   DB	 57,39				; scan code,ASCII - SPACE
CP437_AC_SP_T1_END:			  ;
					;
   DW	 0				; Size of xlat table - null table
					;
CP437_AC_SP_END:			  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	  0			       ;; LAST STATE
				       ;;
CP437_XLAT_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; SP Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC SP_850_XLAT		       ;;
SP_850_XLAT:			       ;;
				       ;;
   DW	  CP850_XLAT_END-$	       ;; length of section
   DW	  850			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_LO_END-$	       ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 0EFH,0 			 ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5				; number of scans
   DB	 18,''                         ; scan code,ASCII - e
   DB	 30,''                         ; scan code,ASCII - a
   DB	 24,''                         ; scan code,ASCII - o
   DB	 22,''                         ; scan code,ASCII - u
   DB	 23,''                         ; scan code,ASCII - i
;  DB	 21,0ECH    Delete until 3.4   ;; y acute
CP850_AC_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_LO_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_UP_END-$	       ;; length of state section
   DB	 ACUTE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 0EFH,0 			 ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                         ; scan code,ASCII - e
   DB	 30,0B5H		       ;;    A acute
   DB	 23,0D6H		       ;;    I acute
   DB	 24,0E0H		       ;;    O acute
   DB	 22,0E9H		       ;;    U acute
;  DB	 21,0EDH  Delete until 3.4     ;;    Y acute
CP850_AC_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_SP_END-$		 ;; length of state section
   DB	 ACUTE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 0EFH,0 			 ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,0EFH			 ;; scan code,ASCII - SPACE
CP850_AC_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_SP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_UP_END-$	       ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 2			       ;; number of scans
   DB	 18,0D3H		       ;;    E diaeresis
   DB	 23,0D8H		       ;;    I diaeresis
CP850_DI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW  CP850_DI_SP_END-$	       ;; length of state section
   DB	 DIARESIS_SPACE 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW  CP850_DI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,249 		       ;; error character = standalone accent
CP850_DI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
CP850_DI_SP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Grave Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_GR_UP_END-$	       ;; length of state section
   DB	 GRAVE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_GR_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 30,0B7H		       ;;    A grave
   DB	 18,0D4H		       ;;    E grave
   DB	 23,0DEH		       ;;    I grave
   DB	 24,0E3H		       ;;    O grave
   DB	 22,0EBH		       ;;    U grave
CP850_GR_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_GR_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Circumflex Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_CI_UP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_UPPER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_CI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 30,0B6H		       ;;    A circumflex
   DB	 18,0D2H		       ;;    E circumflex
   DB	 23,0D7H		       ;;    I circumflex
   DB	 24,0E2H		       ;;    O circumflex
   DB	 22,0EAH		       ;;    U circumflex
CP850_CI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_CI_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 0			       ;; LAST STATE
				       ;;
CP850_XLAT_END: 		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CODE	 ENDS			       ;;
	 END			       ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kbd2\kdfsu.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
	PAGE	,132

	TITLE	MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Definition File
;;
;; This file contains the keyboard tables for Finnish
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;; Updated:    MIKE SAUNDERS - WSD IBM Hursley Laboratory - August 1986
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC	       ;;
	INCLUDE POSTEQU.INC	       ;;
	INCLUDE KEYBMAC.INC	       ;;
				       ;;
	PUBLIC SU_LOGIC 	       ;;
	PUBLIC SU_437_XLAT	       ;;
	PUBLIC SU_850_XLAT	       ;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a linear search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE	    EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; SU State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
SU_LOGIC:

   DW  LOGIC_END-$		       ;; length
				       ;;
   DW  0			       ;; special features
				       ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND 	       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;  ***BD - THIS SECTION HAS BEEN UPDATED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 IFF EITHER_CTL,NOT		       ;;
    IFF EITHER_ALT,NOT		       ;;
      IFF EITHER_SHIFT		       ;;
	  SET_FLAG DEAD_UPPER	       ;;
      ELSEF			       ;;
	  SET_FLAG DEAD_LOWER	       ;;
      ENDIFF			       ;;
    ELSEF			       ;;
      IFKBD G_KB+P12_KB 	       ;; For ENHANCED keyboard some
      ANDF R_ALT_SHIFT		       ;;  dead keys are on third shift
      ANDF EITHER_SHIFT,NOT	       ;;   which is accessed via the altgr key
	 SET_FLAG DEAD_THIRD	       ;;
      ENDIFF			       ;;
    ENDIFF			       ;;
 ENDIFF 			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:			       ;;
				       ;;
   IFF ACUTE,NOT		       ;;
      GOTO DIARESIS_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ACUTE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_ACUTE:			       ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      GOTO NON_DEAD		       ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:			       ;;
				       ;;
   IFF DIARESIS,NOT		       ;;
      GOTO GRAVE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT DIARESIS_SPACE	       ;;  exist for 437 so beep for
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_DIARESIS:		       ;;
      PUT_ERROR_CHAR DIARESIS_LOWER    ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:			       ;;
				       ;;
   IFF GRAVE,NOT		       ;;
      GOTO TILDE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT GRAVE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_GRAVE:			       ;;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TILDE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TILDE_PROC:			       ;;
				       ;;
   IFF TILDE,NOT		       ;;
      GOTO CIRCUMFLEX_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT TILDE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT TILDE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT TILDE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT TILDE_UPPER        ;;
	   ELSEF		       ;;
	      XLATT TILDE_LOWER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_TILDE:			       ;;
      PUT_ERROR_CHAR TILDE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:		       ;;
				       ;;
   IFF CIRCUMFLEX,NOT		       ;;
      GOTO NON_DEAD		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CIRCUMFLEX:		       ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;; ***BD - NON_DEAD THRU LOGIC_END IS UPDATED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NON_DEAD:			       ;;
;;ADDED FOR DIVIDE SIGN 	       ;;
    IFKBD G_KB			       ;; Avoid accidentally translating
    ANDF LC_E0			       ;;  the "/" on the numeric pad of the
       IFF EITHER_CTL,NOT	       ;;
       ANDF EITHER_ALT,NOT	       ;;
	   XLATT DIVIDE_SIGN	       ;;
       ENDIFF			       ;;
       EXIT_STATE_LOGIC 	       ;;
    ENDIFF			       ;;
				       ;;
 IFF  EITHER_CTL,NOT		       ;; Lower and upper case.  Alphabetic
    IFF EITHER_ALT,NOT		       ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT		       ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE,NOT	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_UPPER        ;;
	  IFF CAPS_STATE	       ;;
	      XLATT ALPHA_LOWER        ;;
	  ELSEF 		       ;;
	      XLATT ALPHA_UPPER        ;;
	  ENDIFF		       ;;
      ELSEF			       ;;
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE 	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_LOWER        ;;
	  IFF CAPS_STATE	       ;;
	     XLATT ALPHA_UPPER	       ;;
	  ELSEF 		       ;;
	     XLATT ALPHA_LOWER	       ;;
	  ENDIFF		       ;;
      ENDIFF			       ;; Third and Fourth shifts
    ELSEF			       ;; ctl off, alt on at this point
      IFKBD XT_KB+AT_KB 	 ;; XT, AT,  keyboards. Nordics
	 IFF EITHER_SHIFT	       ;; only.
	    XLATT FOURTH_SHIFT	       ;; ALT + shift
	 ELSEF			       ;;
	    XLATT THIRD_SHIFT	       ;; ALT
	 ENDIFF 		       ;;
      ELSEF			       ;; ENHANCED keyboard
	 IFF R_ALT_SHIFT	       ;; ALTGr
	 ANDF EITHER_SHIFT,NOT	       ;;
	    XLATT THIRD_SHIFT	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
    ENDIFF			       ;;
 ENDIFF 			       ;;
;**************************************;;
 IFF EITHER_SHIFT,NOT		       ;;
   IFKBD XT_KB+AT_KB		 ;;
     IFF EITHER_CTL		       ;;
     ANDF ALT_SHIFT		       ;;
       XLATT ALT_CASE		       ;;
     ENDIFF			       ;;
   ENDIFF			       ;;
   IFKBD G_KB+P12_KB		       ;;
     IFF EITHER_CTL		       ;;
     ANDF ALT_SHIFT		       ;;
       IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ALT_CASE 	       ;;
       ENDIFF			       ;;
     ENDIFF			       ;;
   ENDIFF			       ;;
 ENDIFF 			       ;;
;**************************************;;
 IFKBD AT_KB+XT_KB		 ;;
      IFF EITHER_CTL,NOT	       ;;
	 IFF ALT_SHIFT		       ;; ALT - case
	    XLATT ALT_CASE	       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF EITHER_ALT,NOT	       ;; CTRL - case
	    XLATT CTRL_CASE	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
 ENDIFF 			       ;;
				       ;;
 IFKBD G_KB+P12_KB		       ;;
      IFF EITHER_CTL,NOT	       ;;
	 IFF ALT_SHIFT		       ;; ALT - case
	 ANDF R_ALT_SHIFT,NOT	       ;;
	    XLATT ALT_CASE	       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF EITHER_ALT,NOT	       ;; CTRL - case
	    XLATT CTRL_CASE	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
 ENDIFF 			       ;;
				       ;;
 EXIT_STATE_LOGIC		       ;;
				       ;;
LOGIC_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;**********************************************************************
;; SU Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; Some common Characters are included from 128 - 165 where appropriate.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC SU_COMMON_XLAT		       ;;
SU_COMMON_XLAT: 		       ;;
				       ;;
   DW	 COMMON_XLAT_END-$	       ;; length of section
   DW	 -1			       ;; code page
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Lower Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_LO_END-$	       ;; length of state section
   DB	 DEAD_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 13			       ;; scan code
   FLAG  ACUTE			       ;; flag bit to set
   DB	 27			       ;;
   FLAG  DIARESIS		       ;;
				       ;;
				       ;;
COM_DK_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Upper Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_UP_END-$	       ;; length of state section
   DB	 DEAD_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 13			       ;; scan code
   FLAG  GRAVE			       ;; flag bit to set
   DB	 27			       ;;
   FLAG  CIRCUMFLEX		       ;;
				       ;;
COM_DK_UP_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift Dead Key
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_TH_END-$	       ;; length of state section
   DB	 DEAD_THIRD		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 1			       ;; number of entries
   DB	 27			       ;; scan code
   FLAG  TILDE			       ;; flag bit to set
				       ;;
COM_DK_TH_END:			       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;******************************
;;***BD - ADDED FOR NUMERIC PAD (DECIMAL SEPERATOR)
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Numeric Key Pad
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_PAD_K1_END-$	       ;; length of state section
   DB	 NUMERIC_PAD		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_PAD_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 83,','                        ;; decimal seperator = ,
COM_PAD_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_PAD_K1_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;******************************
;;***BD - ADDED FOR ALT CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K1_END-$	       ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_ALT_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	 12,-1,-1		       ;;
   DB	 53,0,82H		       ;;
COM_ALT_K1_T1_END:		       ;;
					;;
    DW	  0				;; Size of xlat table - null table
				       ;;
COM_ALT_K1_END: 		       ;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;******************************
;;***BD - ADDED FOR CTRL CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: XT, , AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K1_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 XT_KB+AT_KB		 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_CTRL_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	 12,-1,-1		       ;;
   DB	 53,01FH,35h		       ;;
COM_CTRL_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CTRL_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K2_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_CTRL_K2_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 8			       ;; number of entries
   DB	  9,01BH,09H		       ;;
   DB	 10,01DH,0AH		       ;;
   DB	 12,-1,-1		       ;;
   DB	 26,-1,-1		       ;;
   DB	 27,-1,-1		       ;;
   DB	 43,-1,-1		       ;;
   DB	 53,01FH,35H			;;
   DB	 86,01CH,56H			;;
COM_CTRL_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CTRL_K2_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_LO_END-$	       ;; length of state section
   DB	 ALPHA_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 3			       ;; number of entries
   DB	 26,086H		       ;; a-overcircle
   DB	 39,094H		       ;; o-diaeresis
   DB	 40,084H		       ;; a-diaeresis
COM_AL_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_UP_END-$	       ;; length of state section
   DB	 ALPHA_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 3			       ;; number of entries
   DB	 26,08FH		       ;; A-OVERCIRCLE
   DB	 39,099H		       ;; A-DIAERESIS
   DB	 40,08EH		       ;; O-DIAERESIS
COM_AL_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_UP_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G + P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K1_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 4			       ;; number of entries
   DB	 12,"+"                        ;; + INCLUDED FOR SIMPLIC.
   DB	 43,"'"                        ;; '
   DB	 86,"<"                        ;; <
   DB	 53,"-"                        ;; -
COM_NA_LO_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K1_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K2_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K2_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 4			       ;; number of entries
   DB	 12,"+"                        ;; +
   DB	 41,"'"                        ;; '
   DB	 43,"<"                        ;; <
   DB	 53,"-"                        ;; -
COM_NA_LO_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K2_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K3_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K3_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 4			       ;; number of entries
   DB	 12,"+"                        ;; +
   DB	 41,"<"                        ;; <
   DB	 43,"'"                        ;; '
   DB	 53,"-"                        ;; -
COM_NA_LO_K3_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K3_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G + P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K1_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 13			       ;; number of entries
   DB	  3,'"'                        ;;
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 41,''                        ;;
   DB	 43,'*'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
   DB	 86,'>'                        ;;
COM_NA_UP_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K1_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K2_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 XT_KB + _KB		     ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K2_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 13			       ;; number of entries
   DB	  3,'"'                        ;;
   DB	  4,09CH		       ;; POUND STERLING
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 41,'*'                        ;;
   DB	 43,'>'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
COM_NA_UP_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K2_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K3_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K3_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 13			       ;; number of entries
   DB	  3,'"'                        ;;
   DB	  4,09CH		       ;; POUND STERLING
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 41,'>'                        ;;
   DB	 43,'*'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
COM_NA_UP_K3_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K3_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type FERRARI
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 9			       ;; number of entries
   DB	  3,'@'                        ;;
   DB	  4,09CH		       ;; 
   DB	  5,'$'                        ;;
   DB	  8,'{'                        ;;
   DB	  9,'['                        ;;
   DB	 10,']'                        ;;
   DB	 11,'}'                        ;;
   DB	 12,'\'                        ;; Broken Vertical Line
   DB	 86,'|'                        ;;
COM_THIRD_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift (ALTERNATE)
;; KEYBOARD TYPES: XT,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K1_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 9			       ;; number of entries
   DB	 12,'-','-'                    ;;
   DB	 13,'=','='                    ;;
   DB	 26,'[','['                    ;;
   DB	 27,']',']'                    ;;
   DB	 39,';',';'                    ;;
   DB	 40,027H,027H		       ;;
   DB	 41,060H,060H		       ;;
   DB	 43,'\','\'                    ;;
   DB	 53,'/','/'                    ;;
COM_THIRD_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift (ALTERNATE)
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K2_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K2_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 9			       ;; number of entries
   DB	 12,'-','-'                    ;;
   DB	 13,'=','='                    ;;
   DB	 26,'[','['                    ;;
   DB	 27,']',']'                    ;;
   DB	 39,';',';'                    ;;
   DB	 40,027H,027H		       ;;
   DB	 41,'\','\'                    ;;
   DB	 43,060H,060H		       ;;
   DB	 53,'/','/'                    ;;
COM_THIRD_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K2_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Fourth Shift (ALTERNATE+SHIFT)
;; KEYBOARD TYPES: XT,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_FOURTH_END-$	       ;; length of state section
   DB	 FOURTH_SHIFT		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_FOURTH_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 18			       ;; number of entries
   DB	  3,'@','@'                    ;;
   DB	  4,'#','#'                    ;;
   DB	  7,'^','^'                    ;;
   DB	  8,'&','&'                    ;;
   DB	  9,'*','*'                    ;;
   DB	 10,'(','('                    ;;
   DB	 11,')',')'                    ;;
   DB	 12,'_','_'                    ;;
   DB	 13,'+','+'                    ;;
   DB	 26,'{','{'                    ;;
   DB	 27,'}','}'                    ;;
   DB	 39,':',':'                    ;;
   DB	 40,'"','"'                    ;;
   DB	 41,'~','~'                    ;;
   DB	 43,'|','|'                    ;;
   DB	 51,'<','<'                    ;;
   DB	 52,'>','>'                    ;;
   DB	 53,'?','?'                    ;;
COM_FOURTH_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_FOURTH_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Fourth Shift (ALTERNATE+SHIFT)
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_FOURTH_K1_END-$	       ;; length of state section
   DB	 FOURTH_SHIFT		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_FOURTH_K1_T1_END-$        ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 18			       ;; number of entries
   DB	  3,'@','@'                    ;;
   DB	  4,'#','#'                    ;;
   DB	  7,'^','^'                    ;;
   DB	  8,'&','&'                    ;;
   DB	  9,'*','*'                    ;;
   DB	 10,'(','('                    ;;
   DB	 11,')',')'                    ;;
   DB	 12,'_','_'                    ;;
   DB	 13,'+','+'                    ;;
   DB	 26,'{','{'                    ;;
   DB	 27,'}','}'                    ;;
   DB	 39,':',':'                    ;;
   DB	 40,'"','"'                    ;;
   DB	 41,'|','|'                    ;;
   DB	 43,'~','~'                    ;;
   DB	 51,'<','<'                    ;;
   DB	 52,'>','>'                    ;;
   DB	 53,'?','?'                    ;;
COM_FOURTH_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_FOURTH_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_LO_END-$	       ;; length of state section
   DB	 GRAVE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
COM_GR_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_LO_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_SP_END-$	       ;; length of state section
   DB	 GRAVE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,96			       ;; STANDALONE GRAVE
COM_GR_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_LO_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_LOWER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
COM_CI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CI_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_SP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_SPACE	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,94			       ;; STANDALONE CIRCUMFLEX
COM_CI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  COM_TI_LO_END-$		;; length of state section
    DB	  TILDE_LOWER			;; State ID
    DW	  ANY_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  COM_TI_LO_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  1				;; number of scans
    DB	  49,0A4H			;; scan code,ASCII - 
 COM_TI_LO_T1_END:			;;
					;;
    DW	  0				;;
					;;
 COM_TI_LO_END: 			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: Common
;;; STATE: Tilde Upper Case
;;; KEYBOARD TYPES: All
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  COM_TI_UP_END-$		;; length of state section
    DB	  TILDE_UPPER			;; State ID
    DW	  ANY_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  COM_TI_UP_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  1				;; number of scans
    DB	  49,0A5H			;; scan code,ASCII - 
 COM_TI_UP_T1_END:			;;
					;;
    DW	  0				;; Size of xlat table - null table
					;;
 COM_TI_UP_END: 			;; length of state section
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_TI_SP_END-$	       ;; length of state section
   DB	 TILDE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 07EH,0 		       ;; error character = standalone accent
				       ;;
   DW	 COM_TI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,07EH		       ;; STANDALONE TILDE
COM_TI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_TI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; Last State
COMMON_XLAT_END:		       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; SU Specific Translate Section for 437
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC SU_437_XLAT		       ;;
SU_437_XLAT:			       ;;
				       ;;
   DW	  CP437_XLAT_END-$	       ;; length of section
   DW	  437			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_NA_UP_END-$		 ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP437_NA_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	  5,0			       ;; International Currency Symb
CP437_NA_UP_T1_END:		       ;;
				       ;;
    DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_NA_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_NA_K1_LO_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP437_NA_LO_K1_T1_END-$       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 41,015H		       ;; SECTION Symb
CP437_NA_LO_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_NA_K1_LO_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_AC_LO_END-$		 ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_AC_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP437_AC_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_AC_LO_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_AC_UP_END-$		 ;; length of state section
   DB	 ACUTE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_AC_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 18,''                        ;; scan code,ASCII - 
CP437_AC_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_AC_UP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_AC_SP_END-$		 ;; length of state section
   DB	 ACUTE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_AC_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,39			       ;; scan code,ASCII - SPACE
CP437_AC_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_AC_SP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_DI_LO_END-$		 ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 254,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_DI_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 21,''                        ;; scan code,ASCII - y
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP437_DI_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_DI_LO_END:			 ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_DI_UP_END-$		 ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 254,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_DI_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 22,''                        ;; scan code,ASCII - U
   DB	 24,''                        ;; scan code,ASCII - O
   DB	 30,''                        ;; scan code,ASCII - A
CP437_DI_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_DI_UP_END:			 ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				       ;;
;  DW	 CP437_DI_SP_END-$		 ;; length of state section
;  DB	 DIARESIS_SPACE 	       ;; State ID
;  DW	 ANY_KB 		       ;; Keyboard Type
;  DB	 254,0			       ;; error character = standalone accent
;				       ;;
;  DW	 CP437_DI_SP_T1_END-$		 ;; Size of xlat table
;  DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;  DB	 1			       ;; number of scans
;  DB	 57,254 		       ;; error character = standalone accent
;CP437_DI_SP_T1_END:			 ;;
;				       ;;
;  DW	 0			       ;; Size of xlat table - null table
;CP437_DI_SP_END:			 ;; length of state section
;				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	  0			       ;; LAST STATE
				       ;;
CP437_XLAT_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; SU Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC SU_850_XLAT		       ;;
SU_850_XLAT:			       ;;
				       ;;
   DW	  CP850_XLAT_END-$	       ;; length of section
   DW	  850			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Divide Sign
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DIVID_END-$	       ;; length of state section
   DB	 DIVIDE_SIGN		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DIVID_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 2			       ;; number of scans
   DB	 0E0H,0F6H,0E0H 	       ;;
   DB	 53,0F6H,0E0H		       ;; DIVIDE SIGN
CP850_DIVID_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DIVID_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Numeric Key Pad
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_PAD_K1_END-$	       ;; length of state section
   DB	 NUMERIC_PAD		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_PAD_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 55,09EH		       ;;
CP850_PAD_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_PAD_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_UP_END-$		 ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_NA_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	   5,0CFH		       ;; International Currency Symb
CP850_NA_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_UP_END:			 ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_K1_LO_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_NA_LO_K1_T1_END-$       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 41,0F5H		       ;; SECTION Symb
CP850_NA_LO_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_K1_LO_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_LO_END-$		 ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 239,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 21,0ECH		       ;; y acute
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP850_AC_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_LO_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_UP_END-$		 ;; length of state section
   DB	 ACUTE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 239,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of entries
   DB	 18,090H		       ;;    E acute
   DB	 21,0EDH		       ;;    Y acute
   DB	 22,0E9H		       ;;    U acute
   DB	 23,0D6H		       ;;    I acute
   DB	 24,0E0H		       ;;    O acute
   DB	 30,0B5H		       ;;    A acute
CP850_AC_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_UP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_SP_END-$		 ;; length of state section
   DB	 ACUTE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 239,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,239 		       ;; scan code,ASCII - SPACE
CP850_AC_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_SP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_LO_END-$		 ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 21,''                        ;; scan code,ASCII - y
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP850_DI_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_LO_END:			 ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_UP_END-$		 ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,0D3H		       ;;    E Diaeresis
   DB	 22,''                        ;;    U Diaeresis
   DB	 23,0D8H		       ;;    I Diaeresis
   DB	 24,''                        ;;    O Diaeresis
   DB	 30,''                        ;;    A Diaeresis
CP850_DI_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_UP_END:			 ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_SP_END-$		 ;; length of state section
   DB	 DIARESIS_SPACE 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,249 		       ;; error character = standalone accent
CP850_DI_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
CP850_DI_SP_END:			 ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Grave Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_GR_UP_END-$	       ;; length of state section
   DB	 GRAVE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_GR_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,0D4H		       ;;    E grave
   DB	 22,0EBH		       ;;    U grave
   DB	 23,0DEH		       ;;    I grave
   DB	 24,0E3H		       ;;    O grave
   DB	 30,0B7H		       ;;    A grave
CP850_GR_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_GR_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Tilde Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  CP850_TI_LO_END-$		;; length of state section
    DB	  TILDE_LOWER			;; State ID
    DW	  ANY_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  CP850_TI_LO_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  2				;; number of scans
    DB	  24,0E4H			;; scan code,ASCII - o tilde
    DB	  30,0C6H			;; scan code,ASCII - a tilde
 CP850_TI_LO_T1_END:			;;
					;;
    DW	  0				;;
					;;
 CP850_TI_LO_END:			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: 850
;;; STATE: Tilde Upper Case
;;; KEYBOARD TYPES: All
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  CP850_TI_UP_END-$		;; length of state section
    DB	  TILDE_UPPER			;; State ID
    DW	  ANY_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  CP850_TI_UP_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  2				;; number of scans
    DB	  24,0E5H			;; scan code,ASCII - O tilde
    DB	  30,0C7H			;; scan code,ASCII - A tilde
 CP850_TI_UP_T1_END:			;;
					;;
    DW	  0				;; Size of xlat table - null table
					;;
 CP850_TI_UP_END:			;; length of state section
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Circumflex Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_CI_UP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_UPPER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_CI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,0D2H		       ;;    E circumflex
   DB	 22,0EAH		       ;;    U circumflex
   DB	 23,0D7H		       ;;    I circumflex
   DB	 24,0E2H		       ;;    O circumflex
   DB	 30,0B6H		       ;;    A circumflex
CP850_CI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_CI_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 0			       ;; LAST STATE
				       ;;
CP850_XLAT_END: 		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CODE	 ENDS			       ;;
	 END			       ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kbd2\kdfsv.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
	PAGE	,132

	TITLE	MS-DOS 5.0 Keyboard Definition File
;LATEST CHANGE MULTIPLICATION & DIVISION SIGNS
;DOLLAR SIGN output ON P12 should be International Currency sign
;Enabled P12 Tag for CP850 UC section
;****************** CNS 12/18
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Definition File
;;
;; This file contains the keyboard tables for Swedish
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;; Updated:    MIKE SAUNDERS - WSD IBM Hursley Laboratory - August 1986
;;	       NICK SAVAGE   - ESD IBM Boca Raton Laboratory -August- December 1986
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC	       ;;
	INCLUDE POSTEQU.INC	       ;;
	INCLUDE KEYBMAC.INC	       ;;
				       ;;
	PUBLIC SV_LOGIC 	       ;;
	PUBLIC SV_437_XLAT	       ;;
	PUBLIC SV_850_XLAT	       ;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a linear search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE	    EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; SV State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
SV_LOGIC:

   DW  LOGIC_END-$		       ;; length
				       ;;
   DW  0			       ;; special features
				       ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND 	       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;  ***BD - THIS SECTION HAS BEEN UPDATED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 IFF EITHER_CTL,NOT		       ;;
    IFF EITHER_ALT,NOT		       ;;
      IFF EITHER_SHIFT		       ;;
	  SET_FLAG DEAD_UPPER	       ;;
      ELSEF			       ;;
	  SET_FLAG DEAD_LOWER	       ;;
      ENDIFF			       ;;
    ELSEF			       ;;
      IFKBD G_KB+P12_KB 	       ;; For ENHANCED keyboard some
      ANDF R_ALT_SHIFT		       ;;  dead keys are on third shift
      ANDF EITHER_SHIFT,NOT	       ;;   which is accessed via the altgr key
	 SET_FLAG DEAD_THIRD	       ;;
      ENDIFF			       ;;
    ENDIFF			       ;;
 ENDIFF 			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:			       ;;
				       ;;
   IFF ACUTE,NOT		       ;;
      GOTO DIARESIS_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ACUTE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_ACUTE:			       ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      GOTO NON_DEAD		       ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:			       ;;
				       ;;
   IFF DIARESIS,NOT		       ;;
      GOTO GRAVE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT DIARESIS_SPACE	       ;;  exist for 437 so beep for
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_DIARESIS:		       ;;
      PUT_ERROR_CHAR DIARESIS_LOWER    ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:			       ;;
				       ;;
   IFF GRAVE,NOT		       ;;
      GOTO TILDE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT GRAVE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_GRAVE:			       ;;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TILDE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TILDE_PROC:			       ;;
				       ;;
   IFF TILDE,NOT		       ;;
      GOTO CIRCUMFLEX_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT TILDE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT TILDE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT TILDE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT TILDE_UPPER        ;;
	   ELSEF		       ;;
	      XLATT TILDE_LOWER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_TILDE:			       ;;
      PUT_ERROR_CHAR TILDE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:		       ;;
				       ;;
   IFF CIRCUMFLEX,NOT		       ;;
      GOTO NON_DEAD		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CIRCUMFLEX:		       ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;; ***BD - NON_DEAD THRU LOGIC_END IS UPDATED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NON_DEAD:			       ;;
;ADDED FOR DIVIDE SIGN		       ;; ***** DIVIDE OMITTED **** CNS
    IFKBD G_KB+P12_KB			;; Avoid accidentally translating
    ANDF LC_E0				;;  the "/" on the numeric pad of the
;     IFF EITHER_CTL,NOT	       ;; country comforms with U.S. currently
;     ANDF EITHER_ALT,NOT
;	XLATT DIVIDE_SIGN	       ;;
;     ENDIFF
;BD END OF ADDITION
      EXIT_STATE_LOGIC		       ;;
    ENDIFF			       ;;
				       ;;
 IFF  EITHER_CTL,NOT		       ;; Lower and upper case.  Alphabetic
    IFF EITHER_ALT,NOT		       ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT		       ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE,NOT	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_UPPER        ;;
	  IFF CAPS_STATE	       ;;
	      XLATT ALPHA_LOWER        ;;
	  ELSEF 		       ;;
	      XLATT ALPHA_UPPER        ;;
	  ENDIFF		       ;;
      ELSEF			       ;;
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE 	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_LOWER        ;;
	  IFF CAPS_STATE	       ;;
	     XLATT ALPHA_UPPER	       ;;
	  ELSEF 		       ;;
	     XLATT ALPHA_LOWER	       ;;
	  ENDIFF		       ;;
      ENDIFF			       ;; Third and Fourth shifts
    ELSEF			       ;; ctl off, alt on at this point
      IFKBD XT_KB+AT_KB+JR_KB	       ;; XT, AT, JR keyboards. Nordics
	 IFF EITHER_SHIFT	       ;; only.
	    XLATT FOURTH_SHIFT	       ;; ALT + shift
	 ELSEF			       ;;
	    XLATT THIRD_SHIFT	       ;; ALT
	 ENDIFF 		       ;;
      ELSEF			       ;; ENHANCED keyboard
	 IFF R_ALT_SHIFT	       ;; ALTGr
	 ANDF EITHER_SHIFT,NOT	       ;;
	    XLATT THIRD_SHIFT	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
    ENDIFF			       ;;
 ENDIFF 			       ;;
;**************************************;;
 IFF EITHER_SHIFT,NOT		       ;;
   IFKBD XT_KB+AT_KB+JR_KB	       ;;
     IFF EITHER_CTL		       ;;
     ANDF ALT_SHIFT		       ;;
       XLATT ALT_CASE		       ;;
     ENDIFF			       ;;
   ENDIFF			       ;;
   IFKBD G_KB+P12_KB		       ;;
     IFF EITHER_CTL		       ;;
     ANDF ALT_SHIFT		       ;;
       IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ALT_CASE 	       ;;
       ENDIFF			       ;;
     ENDIFF			       ;;
   ENDIFF			       ;;
 ENDIFF 			       ;;
;**************************************;;
 IFKBD AT_KB+JR_KB+XT_KB	       ;;
      IFF EITHER_CTL,NOT	       ;;
	 IFF ALT_SHIFT		       ;; ALT - case
	    XLATT ALT_CASE	       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF EITHER_ALT,NOT	       ;; CTRL - case
	    XLATT CTRL_CASE	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
 ENDIFF 			       ;;
				       ;;
 IFKBD G_KB+P12_KB		       ;;
      IFF EITHER_CTL,NOT	       ;;
	 IFF ALT_SHIFT		       ;; ALT - case
	 ANDF R_ALT_SHIFT,NOT	       ;;
	    XLATT ALT_CASE	       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF EITHER_ALT,NOT	       ;; CTRL - case
	    XLATT CTRL_CASE	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
 ENDIFF 			       ;;
				       ;;
 EXIT_STATE_LOGIC		       ;;
				       ;;
LOGIC_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;**********************************************************************
;; SV Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; Some common Characters are included from 128 - 165 where appropriate.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC SV_COMMON_XLAT		       ;;
SV_COMMON_XLAT: 		       ;;
				       ;;
   DW	 COMMON_XLAT_END-$	       ;; length of section
   DW	 -1			       ;; code page
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Lower Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_LO_END-$	       ;; length of state section
   DB	 DEAD_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 13			       ;; scan code
   FLAG  ACUTE			       ;; flag bit to set
   DB	 27			       ;;
   FLAG  DIARESIS		       ;;
				       ;;
				       ;;
COM_DK_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Upper Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_UP_END-$	       ;; length of state section
   DB	 DEAD_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 13			       ;; scan code
   FLAG  GRAVE			       ;; flag bit to set
   DB	 27			       ;;
   FLAG  CIRCUMFLEX		       ;;
				       ;;
COM_DK_UP_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift Dead Key
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_TH_END-$	       ;; length of state section
   DB	 DEAD_THIRD		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 1			       ;; number of entries
   DB	 27			       ;; scan code
   FLAG  TILDE			       ;; flag bit to set
				       ;;
COM_DK_TH_END:			       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;******************************
;;***BD - ADDED FOR NUMERIC PAD (DECIMAL SEPERATOR)
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common		       ;;********* CNS ******* change
;; STATE: Numeric Key Pad
;; KEYBOARD TYPES: All except the p12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_PAD_K1_END-$	       ;; length of state section
   DB	 NUMERIC_PAD		       ;; State ID
   DW	 G_KB+AT_KB+XT_KB	       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_PAD_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 83,','                        ;; decimal seperator = ,
COM_PAD_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_PAD_K1_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;******************************
;;***BD - ADDED FOR ALT CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K1_END-$	       ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_ALT_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 0			       ;; 2 number of entries
;   DB	  12,-1,-1			;;
;   DB	  53,0,82H			;;
COM_ALT_K1_T1_END:		       ;;
					;;
    DW	  0				;; Size of xlat table - null table
				       ;;
COM_ALT_K1_END: 		       ;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;******************************
;;***BD - ADDED FOR CTRL CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: XT, JR, AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K1_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 XT_KB+JR_KB+AT_KB	       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_CTRL_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	 12,-1,-1		       ;;
   DB	 53,01FH,35h		       ;;
COM_CTRL_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CTRL_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K2_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_CTRL_K2_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 8			       ;; number of entries
   DB	  9,01BH,09H		       ;;
   DB	 10,01DH,0AH		       ;;
   DB	 12,-1,-1		       ;;
   DB	 26,-1,-1		       ;;
   DB	 27,-1,-1		       ;;
   DB	 43,-1,-1		       ;;
   DB	 53,01FH,35H			;;
   DB	 86,01CH,56H			;;
COM_CTRL_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CTRL_K2_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_LO_END-$	       ;; length of state section
   DB	 ALPHA_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 3			       ;; number of entries
   DB	 26,086H		       ;; a-overcircle
   DB	 39,094H		       ;; o-diaeresis
   DB	 40,084H		       ;; a-diaeresis
COM_AL_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_UP_END-$	       ;; length of state section
   DB	 ALPHA_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 3			       ;; number of entries
   DB	 26,08FH		       ;; A-OVERCIRCLE
   DB	 39,099H		       ;; A-DIAERESIS
   DB	 40,08EH		       ;; O-DIAERESIS
COM_AL_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_UP_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G + P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K1_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 4			       ;; number of entries
   DB	 12,"+"                        ;; + INCLUDED FOR SIMPLIC.
   DB	 43,"'"                        ;; '
   DB	 86,"<"                        ;; <
   DB	 53,"-"                        ;; -
COM_NA_LO_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K1_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: XT + JR
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K2_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 XT_KB+JR_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K2_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 4			       ;; number of entries
   DB	 12,"+"                        ;; +
   DB	 41,"'"                        ;; '
   DB	 43,"<"                        ;; <
   DB	 53,"-"                        ;; -
COM_NA_LO_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K2_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K3_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K3_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 4			       ;; number of entries
   DB	 12,"+"                        ;; +
   DB	 41,"<"                        ;; <
   DB	 43,"'"                        ;; '
   DB	 53,"-"                        ;; -
COM_NA_LO_K3_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K3_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G + P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K1_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB + P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 13			       ;; number of entries
   DB	  3,'"'                        ;;
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 41,''                        ;;
   DB	 43,'*'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
   DB	 86,'>'                        ;;
COM_NA_UP_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K1_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT + JR
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K2_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 XT_KB + JR_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K2_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 13			       ;; number of entries
   DB	  3,'"'                        ;;
   DB	  4,09CH		       ;; POUND STERLING
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 41,'*'                        ;;
   DB	 43,'>'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
COM_NA_UP_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K2_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K3_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K3_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 13			       ;; number of entries
   DB	  3,'"'                        ;;
   DB	  4,09CH		       ;; POUND STERLING
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 41,'>'                        ;;
   DB	 43,'*'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
COM_NA_UP_K3_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K3_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type FERRARI
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 9			       ;; number of entries
   DB	  3,'@'                        ;;
   DB	  4,09CH		       ;; 
   DB	  5,'$'                        ;;
   DB	  8,'{'                        ;;
   DB	  9,'['                        ;;
   DB	 10,']'                        ;;
   DB	 11,'}'                        ;;
   DB	 12,'\'                        ;; Broken Vertical Line
   DB	 86,'|'                        ;;
COM_THIRD_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift (ALTERNATE)
;; KEYBOARD TYPES: XT, JR
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K1_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 XT_KB+JR_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 9			       ;; number of entries
   DB	 12,'-','-'                    ;;
   DB	 13,'=','='                    ;;
   DB	 26,'[','['                    ;;
   DB	 27,']',']'                    ;;
   DB	 39,';',';'                    ;;
   DB	 40,027H,027H		       ;;
   DB	 41,060H,060H		       ;;
   DB	 43,'\','\'                    ;;
   DB	 53,'/','/'                    ;;
COM_THIRD_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift (ALTERNATE)
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K2_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K2_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 9			       ;; number of entries
   DB	 12,'-','-'                    ;;
   DB	 13,'=','='                    ;;
   DB	 26,'[','['                    ;;
   DB	 27,']',']'                    ;;
   DB	 39,';',';'                    ;;
   DB	 40,027H,027H		       ;;
   DB	 41,'\','\'                    ;;
   DB	 43,060H,060H		       ;;
   DB	 53,'/','/'                    ;;
COM_THIRD_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K2_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Fourth Shift (ALTERNATE+SHIFT)
;; KEYBOARD TYPES: XT, JR
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_FOURTH_END-$	       ;; length of state section
   DB	 FOURTH_SHIFT		       ;; State ID
   DW	 XT_KB+JR_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_FOURTH_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 18			       ;; number of entries
   DB	  3,'@','@'                    ;;
   DB	  4,'#','#'                    ;;
   DB	  7,'^','^'                    ;;
   DB	  8,'&','&'                    ;;
   DB	  9,'*','*'                    ;;
   DB	 10,'(','('                    ;;
   DB	 11,')',')'                    ;;
   DB	 12,'_','_'                    ;;
   DB	 13,'+','+'                    ;;
   DB	 26,'{','{'                    ;;
   DB	 27,'}','}'                    ;;
   DB	 39,':',':'                    ;;
   DB	 40,'"','"'                    ;;
   DB	 41,'~','~'                    ;;
   DB	 43,'|','|'                    ;;
   DB	 51,'<','<'                    ;;
   DB	 52,'>','>'                    ;;
   DB	 53,'?','?'                    ;;
COM_FOURTH_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_FOURTH_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Fourth Shift (ALTERNATE+SHIFT)
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_FOURTH_K1_END-$	       ;; length of state section
   DB	 FOURTH_SHIFT		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_FOURTH_K1_T1_END-$        ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 18			       ;; number of entries
   DB	  3,'@','@'                    ;;
   DB	  4,'#','#'                    ;;
   DB	  7,'^','^'                    ;;
   DB	  8,'&','&'                    ;;
   DB	  9,'*','*'                    ;;
   DB	 10,'(','('                    ;;
   DB	 11,')',')'                    ;;
   DB	 12,'_','_'                    ;;
   DB	 13,'+','+'                    ;;
   DB	 26,'{','{'                    ;;
   DB	 27,'}','}'                    ;;
   DB	 39,':',':'                    ;;
   DB	 40,'"','"'                    ;;
   DB	 41,'|','|'                    ;;
   DB	 43,'~','~'                    ;;
   DB	 51,'<','<'                    ;;
   DB	 52,'>','>'                    ;;
   DB	 53,'?','?'                    ;;
COM_FOURTH_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_FOURTH_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_LO_END-$	       ;; length of state section
   DB	 GRAVE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
COM_GR_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_LO_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_SP_END-$	       ;; length of state section
   DB	 GRAVE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,96			       ;; STANDALONE GRAVE
COM_GR_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_LO_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_LOWER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
COM_CI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CI_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_SP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_SPACE	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,94			       ;; STANDALONE CIRCUMFLEX
COM_CI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  COM_TI_LO_END-$		;; length of state section
    DB	  TILDE_LOWER			;; State ID
    DW	  ANY_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  COM_TI_LO_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  1				;; number of scans
    DB	  49,0A4H			;; scan code,ASCII - 
 COM_TI_LO_T1_END:			;;
					;;
    DW	  0				;;
					;;
 COM_TI_LO_END: 			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: Common
;;; STATE: Tilde Upper Case
;;; KEYBOARD TYPES: All
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  COM_TI_UP_END-$		;; length of state section
    DB	  TILDE_UPPER			;; State ID
    DW	  ANY_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  COM_TI_UP_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  1				;; number of scans
    DB	  49,0A5H			;; scan code,ASCII - 
 COM_TI_UP_T1_END:			;;
					;;
    DW	  0				;; Size of xlat table - null table
					;;
 COM_TI_UP_END: 			;; length of state section
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_TI_SP_END-$	       ;; length of state section
   DB	 TILDE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 07EH,0 		       ;; error character = standalone accent
				       ;;
   DW	 COM_TI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,07EH		       ;; STANDALONE TILDE
COM_TI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_TI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; Last State
COMMON_XLAT_END:		       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; SV Specific Translate Section for 437
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC SV_437_XLAT		       ;;
SV_437_XLAT:			       ;;
				       ;;
   DW	  CP437_XLAT_END-$	       ;; length of section
   DW	  437			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_NA_UP_END-$		 ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP437_NA_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	  5,0			       ;; International Currency Symb
CP437_NA_UP_T1_END:		       ;;
				       ;;
    DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_NA_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_NA_K1_LO_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP437_NA_LO_K1_T1_END-$       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 41,015H		       ;; SECTION Symb
CP437_NA_LO_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_NA_K1_LO_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_AC_LO_END-$		 ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_AC_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP437_AC_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_AC_LO_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_AC_UP_END-$		 ;; length of state section
   DB	 ACUTE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_AC_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 18,''                        ;; scan code,ASCII - 
CP437_AC_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_AC_UP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_AC_SP_END-$		 ;; length of state section
   DB	 ACUTE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_AC_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,39			       ;; scan code,ASCII - SPACE
CP437_AC_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_AC_SP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_DI_LO_END-$		 ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 254,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_DI_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 21,''                        ;; scan code,ASCII - y
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP437_DI_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_DI_LO_END:			 ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_DI_UP_END-$		 ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 254,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_DI_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 22,''                        ;; scan code,ASCII - U
   DB	 24,''                        ;; scan code,ASCII - O
   DB	 30,''                        ;; scan code,ASCII - A
CP437_DI_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_DI_UP_END:			 ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				       ;;
;  DW	 CP437_DI_SP_END-$		 ;; length of state section
;  DB	 DIARESIS_SPACE 	       ;; State ID
;  DW	 ANY_KB 		       ;; Keyboard Type
;  DB	 254,0			       ;; error character = standalone accent
;				       ;;
;  DW	 CP437_DI_SP_T1_END-$		 ;; Size of xlat table
;  DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;  DB	 1			       ;; number of scans
;  DB	 57,254 		       ;; error character = standalone accent
;CP437_DI_SP_T1_END:			 ;;
;				       ;;
;  DW	 0			       ;; Size of xlat table - null table
;CP437_DI_SP_END:			 ;; length of state section
;				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	  0			       ;; LAST STATE
				       ;;
CP437_XLAT_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; SV Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC SV_850_XLAT		       ;;
SV_850_XLAT:			       ;;
				       ;;
   DW	  CP850_XLAT_END-$	       ;; length of section
   DW	  850			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Numeric Pad - Divide Sign
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				       ;;
;  DW	 CP850_DIVID_END-$	       ;; length of state section
;  DB	 DIVIDE_SIGN		       ;; State ID
;  DW	 G_KB+P12_KB		       ;; Keyboard Type
;  DB	 -1,-1			       ;; error character = standalone accent
;				       ;;
;  DW	 CP850_DIVID_T1_END-$	       ;; Size of xlat table
;  DB	 TYPE_2_TAB		       ;; xlat options:
;  DB	 0			       ;; number of scans
;  DB	 0E0H,0F6H,0E0H 	       ;; DIVIDE SIGN omitted sv/su
;  DB	 53,0F6H,0E0H		       ;; has decidied to stick with U.S.
;  DB	 0E0H,09eH,0E0H 	       ;; standards in order to use BASIC
;  DB	 55,09eH,0E0H		       ;;
;CP850_DIVID_T1_END:			;;
;					;;
;   DW	  0				;; Size of xlat table - null table
;					;;
;CP850_DIVID_END:			;;
;					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Numeric Key Pad - Multiplication
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;					;;
;  DW	 CP850_PAD_K1_END-$	       ;; length of state section
;  DB	 NUMERIC_PAD		       ;; State ID
;  DW	 G_KB+P12_KB		       ;; Keyboard Type
;  DB	 -1,-1			       ;; Buffer entry for error character
;				       ;;
;  DW	 CP850_PAD_K1_T1_END-$	       ;; Size of xlat table
;  DB	 STANDARD_TABLE 	       ;; xlat options:
;  DB	 0			       ;; number of entries
;  DB	 55,09eH (moved *** CNS ****)  ;; MULTIPLICATION SIGN
;CP850_PAD_K1_T1_END:			;;
;					;;
;   DW	  0				;; Size of xlat table - null table
;					;;
;CP850_PAD_K1_END:			;;
;					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_UP_END-$		 ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type *** CNS 12/18
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_NA_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	   5,0CFH		       ;; International Currency Symb
CP850_NA_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_UP_END:			 ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_K1_LO_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_NA_LO_K1_T1_END-$       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 41,0F5H		       ;; SECTION Symb
CP850_NA_LO_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_K1_LO_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_LO_END-$		 ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 239,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 21,0ECH		       ;; y acute
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP850_AC_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_LO_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_UP_END-$		 ;; length of state section
   DB	 ACUTE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 239,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of entries
   DB	 18,090H		       ;;    E acute
   DB	 21,0EDH		       ;;    Y acute
   DB	 22,0E9H		       ;;    U acute
   DB	 23,0D6H		       ;;    I acute
   DB	 24,0E0H		       ;;    O acute
   DB	 30,0B5H		       ;;    A acute
CP850_AC_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_UP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_SP_END-$		 ;; length of state section
   DB	 ACUTE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 239,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,239 		       ;; scan code,ASCII - SPACE
CP850_AC_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_SP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_LO_END-$		 ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 21,''                        ;; scan code,ASCII - y
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP850_DI_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_LO_END:			 ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_UP_END-$		 ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,0D3H		       ;;    E Diaeresis
   DB	 22,''                        ;;    U Diaeresis
   DB	 23,0D8H		       ;;    I Diaeresis
   DB	 24,''                        ;;    O Diaeresis
   DB	 30,''                        ;;    A Diaeresis
CP850_DI_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_UP_END:			 ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_SP_END-$		 ;; length of state section
   DB	 DIARESIS_SPACE 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,249 		       ;; error character = standalone accent
CP850_DI_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
CP850_DI_SP_END:			 ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Grave Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_GR_UP_END-$	       ;; length of state section
   DB	 GRAVE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_GR_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,0D4H		       ;;    E grave
   DB	 22,0EBH		       ;;    U grave
   DB	 23,0DEH		       ;;    I grave
   DB	 24,0E3H		       ;;    O grave
   DB	 30,0B7H		       ;;    A grave
CP850_GR_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_GR_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Tilde Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  CP850_TI_LO_END-$		;; length of state section
    DB	  TILDE_LOWER			;; State ID
    DW	  ANY_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  CP850_TI_LO_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  2				;; number of scans
    DB	  24,0E4H			;; scan code,ASCII - o tilde
    DB	  30,0C6H			;; scan code,ASCII - a tilde
 CP850_TI_LO_T1_END:			;;
					;;
    DW	  0				;;
					;;
 CP850_TI_LO_END:			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: 850
;;; STATE: Tilde Upper Case
;;; KEYBOARD TYPES: All
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  CP850_TI_UP_END-$		;; length of state section
    DB	  TILDE_UPPER			;; State ID
    DW	  ANY_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  CP850_TI_UP_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  2				;; number of scans
    DB	  24,0E5H			;; scan code,ASCII - O tilde
    DB	  30,0C7H			;; scan code,ASCII - A tilde
 CP850_TI_UP_T1_END:			;;
					;;
    DW	  0				;; Size of xlat table - null table
					;;
 CP850_TI_UP_END:			;; length of state section
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Circumflex Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_CI_UP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_UPPER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_CI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,0D2H		       ;;    E circumflex
   DB	 22,0EAH		       ;;    U circumflex
   DB	 23,0D7H		       ;;    I circumflex
   DB	 24,0E2H		       ;;    O circumflex
   DB	 30,0B6H		       ;;    A circumflex
CP850_CI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_CI_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 0			       ;; LAST STATE
				       ;;
CP850_XLAT_END: 		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CODE	 ENDS			       ;;
	 END			       ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kbd2\kdfsl.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
       PAGE    ,132
	TITLE   MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Definition File
;;
;;
;; This file contains the keyboard tables for:
;; Czechoslovakia (Slovak)
;; Alterations created by Gyorgy Balint on behalf of IBM ROECE
;; 22.10.87 Basingstoke
;;
;;
;; Linkage Instructions:
;;      Refer to KDF.ASM.
;;
;;
;; WRITTEN:    Michael J. Saunders 2.OCTOBER 1987
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC           ;;
	INCLUDE POSTEQU.INC            ;;
	INCLUDE KEYBMAC.INC            ;;
				       ;;
	PUBLIC SL_LOGIC                ;;
	PUBLIC SL_850_XLAT             ;;
	PUBLIC SL_852_XLAT             ;;
				       ;;
CODE    SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a linear search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE      EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; SL State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
SL_LOGIC:                              ;;
				       ;;
   DW  LOGIC_END-$                     ;; length
				       ;;
   DW  0                               ;; special features
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND                ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;  ***BD - THIS SECTION HAS BEEN UPDATED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFKBD G_KB                             ;;P12_KB - ONLY VALID FOR ENHANCED KB
				       ;;
 IFF EITHER_CTL,NOT                    ;;
    IFF EITHER_ALT,NOT                 ;;
      IFF EITHER_SHIFT                 ;;
	  SET_FLAG DEAD_UPPER          ;;
      ELSEF                            ;;
	  SET_FLAG DEAD_LOWER          ;;
      ENDIFF                           ;;
    ELSEF                              ;;
      IFF R_ALT_SHIFT                  ;;
      ANDF EITHER_SHIFT,NOT            ;;
	 SET_FLAG DEAD_THIRD           ;;
      ENDIFF                           ;;
    ENDIFF                             ;;
 ENDIFF                                ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:                            ;;
				       ;;
   IFF ACUTE,NOT                       ;;
      GOTO CEDILLA_PROC                ;;
      ENDIFF                           ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT ACUTE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	 IFF EITHER_SHIFT              ;;
	    IFF CAPS_STATE             ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF                      ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF                     ;;
	 ELSEF                         ;;
	    IFF CAPS_STATE             ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF                      ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF                     ;;
	 ENDIFF                        ;;
      ENDIFF                           ;;
				       ;;
INVALID_ACUTE:                         ;;
      PUT_ERROR_CHAR ACUTE_SPACE       ;; If we get here then either the XLATT
      BEEP                             ;; failed or we are ina bad shift state.
      GOTO NON_DEAD                    ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CEDILLA ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CEDILLA_PROC:                          ;;
				       ;;
   IFF CEDILLA,NOT                     ;;
      GOTO DIARESIS_PROC               ;;
      ENDIFF                           ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT CEDILLA_SPACE           ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	 IFF EITHER_SHIFT              ;;
	    IFF CAPS_STATE             ;;
	       XLATT CEDILLA_LOWER     ;;
	    ELSEF                      ;;
	       XLATT CEDILLA_UPPER     ;;
	    ENDIFF                     ;;
	 ELSEF                         ;;
	    IFF CAPS_STATE             ;;
	       XLATT CEDILLA_UPPER     ;;
	    ELSEF                      ;;
	       XLATT CEDILLA_LOWER     ;;
	    ENDIFF                     ;;
	 ENDIFF                        ;;
      ENDIFF                           ;;
				       ;;
INVALID_CEDILLA:                       ;;
      PUT_ERROR_CHAR CEDILLA_LOWER     ;; If we get here then either the XLATT
      BEEP                             ;; failed or we are ina bad shift state.
      GOTO NON_DEAD                    ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:                         ;;
				       ;;
   IFF DIARESIS,NOT                    ;;
      GOTO GRAVE_PROC                  ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT DIARESIS_SPACE          ;;  exist for 850 so beep for
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	 IFF EITHER_SHIFT              ;;
	    IFF CAPS_STATE             ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF                      ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF                     ;;
	 ELSEF                         ;;
	    IFF CAPS_STATE             ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF                      ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF                     ;;
	 ENDIFF                        ;;
      ENDIFF                           ;;
				       ;;
INVALID_DIARESIS:                      ;;
      PUT_ERROR_CHAR DIARESIS_LOWER    ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:                            ;;
				       ;;
   IFF GRAVE,NOT                       ;;
      GOTO TILDE_PROC                  ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT GRAVE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_GRAVE:                         ;;
      PUT_ERROR_CHAR GRAVE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TILDE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TILDE_PROC:                            ;;
				       ;;
   IFF TILDE,NOT                       ;;
      GOTO CIRCUMFLEX_PROC             ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT TILDE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT TILDE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT TILDE_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE              ;;
	      XLATT TILDE_UPPER        ;;
	   ELSEF                       ;;
	      XLATT TILDE_LOWER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
INVALID_TILDE:                         ;;
      PUT_ERROR_CHAR TILDE_LOWER       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:                       ;;
				       ;;
   IFF CIRCUMFLEX,NOT                  ;;
      GOTO CARON_PROC                  ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF                       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF                       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_CIRCUMFLEX:                    ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CARON ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CARON_PROC:                            ;;
				       ;;
   IFF CARON,NOT                       ;;
      GOTO BREVE_PROC                  ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT CARON_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT CARON_LOWER        ;;
	   ELSEF                       ;;
	      XLATT CARON_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT CARON_LOWER        ;;
	   ELSEF                       ;;
	      XLATT CARON_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_CARON:                         ;;
      PUT_ERROR_CHAR CARON_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BREVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
BREVE_PROC:                            ;;
				       ;;
   IFF BREVE,NOT                       ;;
      GOTO OVERCIRCLE_PROC             ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT BREVE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT BREVE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT BREVE_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT BREVE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT BREVE_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_BREVE:                         ;;
      PUT_ERROR_CHAR BREVE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OVERCIRCLE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
OVERCIRCLE_PROC:                            ;;
				       ;;
   IFF OVERCIRCLE,NOT                       ;;
      GOTO OGONEK_PROC             ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT OVERCIRCLE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT OVERCIRCLE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT OVERCIRCLE_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT OVERCIRCLE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT OVERCIRCLE_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_OVERCIRCLE:                         ;;
      PUT_ERROR_CHAR OVERCIRCLE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OGONEK ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
OGONEK_PROC:                            ;;
				       ;;
   IFF OGONEK,NOT                       ;;
      GOTO OVERDOT_PROC             ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT OGONEK_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT OGONEK_LOWER        ;;
	   ELSEF                       ;;
	      XLATT OGONEK_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT OGONEK_LOWER        ;;
	   ELSEF                       ;;
	      XLATT OGONEK_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_OGONEK:                         ;;
      PUT_ERROR_CHAR OGONEK_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OVERDOT ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
OVERDOT_PROC:                            ;;
				       ;;
   IFF OVERDOT,NOT                       ;;
      GOTO DOUBLEACUTE_PROC             ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT OVERDOT_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT OVERDOT_LOWER        ;;
	   ELSEF                       ;;
	      XLATT OVERDOT_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT OVERDOT_LOWER        ;;
	   ELSEF                       ;;
	      XLATT OVERDOT_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_OVERDOT:                         ;;
      PUT_ERROR_CHAR OVERDOT_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DOUBLEACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DOUBLEACUTE_PROC:                            ;;
				       ;;
   IFF DOUBLEACUTE,NOT                       ;;
      GOTO NON_DEAD                  ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT DOUBLEACUTE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT DOUBLEACUTE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT DOUBLEACUTE_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT DOUBLEACUTE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT DOUBLEACUTE_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_DOUBLEACUTE:                         ;;
      PUT_ERROR_CHAR DOUBLEACUTE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;; ***BD - NON_DEAD THRU LOGIC_END IS UPDATED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NON_DEAD:                              ;;
				       ;;
   IFKBD G_KB                          ;; Avoid accidentally translating
   ANDF LC_E0                          ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC                 ;;   G keyboard
   ENDIFF                              ;;
				       ;;
 IFF  EITHER_CTL,NOT                   ;; Lower and upper case.  Alphabetic
    IFF EITHER_ALT,NOT                 ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT                 ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE,NOT            ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF                       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_UPPER        ;;
	  IFF CAPS_STATE               ;;
	      XLATT ALPHA_LOWER        ;;
	  ELSEF                        ;;
	      XLATT ALPHA_UPPER        ;;
	  ENDIFF                       ;;
      ELSEF                            ;;
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE                ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF                       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_LOWER        ;;
	  IFF CAPS_STATE               ;;
	     XLATT ALPHA_UPPER         ;;
	  ELSEF                        ;;
	     XLATT ALPHA_LOWER         ;;
	  ENDIFF                       ;;
      ENDIFF                           ;; Third and Fourth shifts
    ELSEF                              ;; ctl off, alt on at this point
	 IFF R_ALT_SHIFT               ;; ALTGr
	 ANDF EITHER_SHIFT,NOT         ;;
	    XLATT THIRD_SHIFT          ;;
	 ENDIFF                        ;;
    ENDIFF                             ;;
 ENDIFF                                ;;
;**************************************;;
 IFF EITHER_SHIFT,NOT                  ;;
     IFF EITHER_CTL                    ;;
     ANDF ALT_SHIFT                    ;;
       IFF R_ALT_SHIFT,NOT             ;;
	 XLATT ALT_CASE                ;;
       ENDIFF                          ;;
     ENDIFF                            ;;
 ENDIFF                                ;;
;**************************************;;
      IFF EITHER_CTL,NOT               ;;
	 IFF ALT_SHIFT                 ;; ALT - case
	 ANDF R_ALT_SHIFT,NOT          ;;
	    XLATT ALT_CASE             ;;
	 ENDIFF                        ;;
      ELSEF                            ;;
	 IFF EITHER_ALT,NOT            ;; CTRL - case
	    XLATT CTRL_CASE            ;;
	 ENDIFF                        ;;
      ENDIFF                           ;;
ENDIFF                                 ;;
				       ;;
 EXIT_STATE_LOGIC                      ;;
				       ;;
LOGIC_END:                             ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;**********************************************************************
;; SL Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; Some common Characters are included from 128 - 165 where appropriate.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC SL_COMMON_XLAT                 ;;
SL_COMMON_XLAT:                        ;;
				       ;;
   DW     COMMON_XLAT_END-$            ;; length of section
   DW     -1                           ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: low shift Dead_lower
;; KEYBOARD TYPES: G
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_PL_LO_END-$               ;; length of state section
   DB    DEAD_LOWER                    ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;; Set Flag Table
   DW    1                             ;; number of entries
   DB    13                            ;;
   FLAG  ACUTE                         ;;
				       ;;
COM_PL_LO_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: low shift Dead_UPPER
;; KEYBOARD TYPES: G
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_PL_UP_END-$               ;; length of state section
   DB    DEAD_UPPER                    ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;; Set Flag Table
   DW    2                             ;; number of entries
   DB    41                            ;;
   FLAG  OVERCIRCLE                    ;;
   DB    13                            ;;
   FLAG  CARON                         ;;
				       ;;
COM_PL_UP_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Third Shift Dead Key
;; KEYBOARD TYPES: G
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_SL_TH_END-$               ;; length of state section
   DB    DEAD_THIRD                    ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;; Set Flag Table
   DW    11                            ;; number of entries
;; DB    2                             ;; TILDE IS NOT AN ACCENT KEY
;; FLAG  TILDE                         ;;
   DB    3                             ;;
   FLAG  CARON                         ;;
   DB    4                             ;;
   FLAG  CIRCUMFLEX                    ;;
   DB    5                             ;;
   FLAG  BREVE                         ;;
   DB    6                             ;;
   FLAG  OVERCIRCLE                    ;;
   DB    7                             ;;
   FLAG  OGONEK                        ;;
   DB    8                             ;;
   FLAG  GRAVE                         ;;
   DB    9                             ;;
   FLAG  OVERDOT                       ;;
   DB    10                            ;;
   FLAG  ACUTE                         ;;
   DB    11                            ;;
   FLAG  DOUBLEACUTE                   ;;
   DB    12                            ;;
   FLAG  DIARESIS                      ;;
   DB    13                            ;;
   FLAG  CEDILLA                       ;;
				       ;;
COM_SL_TH_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;******************************
;;***BD - ADDED FOR NUMERIC PAD (DECIMAL SEPERATOR)
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Numeric Key Pad
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_PAD_K1_END-$              ;; length of state section
   DB    NUMERIC_PAD                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_PAD_K1_T1_END-$           ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB    83,','                        ;; decimal seperator = ,
COM_PAD_K1_T1_END:                     ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_PAD_K1_END:                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;******************************
;;***BD - ADDED FOR ALT CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Alt Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_ALT_K1_END-$              ;; length of state section
   DB    ALT_CASE                      ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_ALT_K1_T1_END-$           ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    3                             ;; number of entries
   DB    21,0,2CH                      ;;
   DB    44,0,15H                      ;;
   DB    53,0,82H                      ;;
COM_ALT_K1_T1_END:                     ;;
				       ;;
    DW    0                            ;; Size of xlat table - null table
				       ;;
COM_ALT_K1_END:                        ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CTRL_K2_END-$             ;; length of state section
   DB    CTRL_CASE                     ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_CTRL_K2_T1_END-$          ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    3                             ;; number of entries
   DB    21,01AH,2CH                   ;;
   DB    44,019H,15H                   ;;
   DB    53,01FH,0CH                   ;;
COM_CTRL_K2_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_CTRL_K2_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_AL_LO_K1_END-$            ;; length of state section
   DB    ALPHA_LOWER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_AL_LO_K1_T1_END-$         ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    2                             ;; number of entries
   DB    21,"z",2CH                    ;;
   DB    44,"y",15H                    ;;
COM_AL_LO_K1_T1_END:                   ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_AL_LO_K1_END:                      ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_AL_UP_K1_END-$            ;; length of state section
   DB    ALPHA_UPPER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_AL_UP_K1_T1_END-$         ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    2                             ;; number of entries
   DB    21,"Z",2CH                    ;;
   DB    44,"Y",15H                    ;;
COM_AL_UP_K1_T1_END:                   ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_AL_UP_K1_END:                      ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_NA_LO_K1_END-$            ;; length of state section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_NA_LO_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    6                             ;; number of entries
   DB    41,";"                        ;;      changes made!!!!!  x
   DB    02h,"+"                       ;;                         x
   DB    0ch,"="                       ;;                         x
   DB    0dh,"`"                       ;;                         x
   DB    056h,"&"                      ;;                         x
   DB    035h,"-"                      ;;                         x
COM_NA_LO_K1_T1_END:                   ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K1_END:                      ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_NA_UP_K1_END-$            ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_NA_UP_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    20                            ;; number of entries
   DB    002h,"1"                      ;;                              x
   DB    003h,"2"                      ;;                              x
   DB    004h,"3"                      ;;                              x
   DB    005h,"4"                      ;;                              x
   DB    006h,"5"                      ;;                              x
   DB    007h,"6"                      ;;                              x
   DB    008h,"7"                      ;;                              x
   DB    009h,"8"                      ;;                              x
   DB    00ah,"9"                      ;;                              x
   DB    00bh,"0"                      ;;                              x
   DB    00ch,"%"                      ;;                              x
   DB    01ah,"/"                      ;;                              x
   DB    01bh,"("                      ;;                              x
   DB    027h,'"'                      ;;                              x
   DB    028h,"!"                      ;;                              x
   DB    02Bh,")"                      ;;                              x
   DB    056h,"*"                      ;;                              x
   DB    033h,"?"                      ;;                              x
   DB    034H,":"                      ;;                              x
   DB    035H,"_"                      ;;                              x
COM_NA_UP_K1_T1_END:                   ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K1_END:                      ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Third Shift
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_THIRD_END-$               ;; length of state section
   DB    THIRD_SHIFT                   ;; State ID
   DW    G_KB                          ;; Keyboard Type FERRARI
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_THIRD_T1_END-$            ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    14                            ;; number of entries
   DB     2,'~',02H                    ;;
   DB    16,'\',10H                    ;;
   DB    17,'|',11H                    ;;
   DB    26,'',1AH                    ;;
   DB    33,"[",021h                   ;;                             x
   DB    34,"]",022h                   ;;                             x
   DB    39,"$",027H                   ;;                             x
   db    40,0e1h,028h                  ;; sharpes s                   x
   DB    86,"<",056h                   ;;                             x
   DB    44,">",02ch                   ;;                             x
   DB    45,"#",02dh                   ;;                             x
   DB    47,"@",02fh                   ;;                             x
   DB    48,"{",30h                    ;;                             x
   DB    49,"}",031h                   ;;                             x
COM_THIRD_T1_END:                      ;;
				       ;;
   DW    0                             ;; Last xlat table
COM_THIRD_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Caron Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CA_SP_END-$             ;; length of state section
   DB    CARON_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F3H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_CA_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F3H                       ;; Caron Space
COM_CA_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_CA_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Breve Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_BR_SP_END-$             ;; length of state section
   DB    BREVE_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F4H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_BR_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F4H                       ;; BREVE SPACE
COM_BR_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_BR_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Ogonek Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_OG_SP_END-$             ;; length of state section
   DB    OGONEK_SPACE                  ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F2H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_OG_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F2H                       ;; OGONEK SPACE
COM_OG_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_OG_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Double Acute Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_DC_SP_END-$             ;; length of state section
   DB    DOUBLEACUTE_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F1H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_DC_SP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of entries
   DB    57,0F1H                       ;; DOUBLEACUTE SPACE
COM_DC_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_DC_SP_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CI_LO_END-$               ;; length of state section
   DB    CIRCUMFLEX_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    94,0                          ;; error character = standalone accent
				       ;;
   DW    COM_CI_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    3                             ;; number of scans
   DB    23,''                        ;;  "    "  ,  "   - i
   DB    24,''                        ;; scan code,ASCII - o
   DB    30,''                        ;; scan code,ASCII - a
COM_CI_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;;
				       ;;
COM_CI_LO_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CI_SP_END-$               ;; length of state section
   DB    CIRCUMFLEX_SPACE              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    94,0                          ;; error character = standalone accent
				       ;;
   DW    COM_CI_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,94                         ;; STANDALONE CIRCUMFLEX
COM_CI_SP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_CI_SP_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Overcircle Space Bar
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_OC_SP_END-$               ;; length of state section
   DB    OVERCIRCLE_SPACE              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_OC_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F8H                       ;; STANDALONE OVERCIRCLE
COM_OC_SP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_OC_SP_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Grave Space Bar
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_GR_SP_END-$               ;; length of state section
   DB    GRAVE_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    96,0                          ;; error character = standalone accent
				       ;;
   DW    COM_GR_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,96                         ;; STANDALONE GRAVE
COM_GR_SP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_GR_SP_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Overdot
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW    COM_OD_SP_END-$               ;; length of state section
    DB    OVERDOT_SPACE                 ;; State ID
    DW    G_KB                          ;; Keyboard Type
    DB    0FAH,0                        ;; error character = standalone accent
					;;
    DW    COM_OD_SP_T1_END-$            ;; Size of xlat table
    DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
    DB    1                             ;; number of scans
    DB    57,0FAH                       ;; STANDALONE OVERDOT
COM_OD_SP_T1_END:                       ;;
					;;
    DW    0                             ;;
					;;
COM_OD_SP_END:                          ;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_AC_LO_END-$               ;; length of state section
   DB    ACUTE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
				       ;;
   DW    COM_AC_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    5                             ;; number of entries
   DB    18,082H                       ;;    e acute
   DB    22,0A3H                       ;;    u acute
   DB    23,0A1H                       ;;    i acute
   DB    24,0A2H                       ;;    o acute
   DB    30,0A0H                       ;;    a acute
COM_AC_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_AC_LO_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_AC_UP_END-$               ;; length of state section
   DB    ACUTE_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
				       ;;
   DW    COM_AC_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of entries
   DB    18,090H                       ;;    E acute
COM_AC_UP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_AC_UP_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_AC_SP_END-$             ;; length of state section
   DB    ACUTE_SPACE                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    027H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_AC_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,027H                        ;; error character = standalone accent
COM_AC_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
COM_AC_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Cedilla Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CE_LO_END-$               ;; length of state section
   DB    CEDILLA_LOWER                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_CE_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    46,''                        ;; scan code,ASCII - 
COM_CE_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_CE_LO_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Cedilla Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CE_UP_END-$               ;; length of state section
   DB    CEDILLA_UPPER                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_CE_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    46,''                        ;;     CEDILLA
COM_CE_UP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_CE_UP_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Cedilla Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CE_SP_END-$             ;; length of state section
   DB    CEDILLA_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_CE_SP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of entries
   DB    57,0F7H                       ;; CEDILLA SPACE
COM_CE_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_CE_SP_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_DI_LO_END-$               ;; length of state section
   DB    DIARESIS_LOWER                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
				       ;;
   DW    COM_DI_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    4                             ;; number of scans
   DB    18,''                        ;; scan code,ASCII - e
   DB    22,''                        ;; scan code,ASCII - u
   DB    24,''                        ;; scan code,ASCII - o
   DB    30,''                        ;; scan code,ASCII - a
COM_DI_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_DI_LO_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_DI_UP_END-$               ;; length of state section
   DB    DIARESIS_UPPER                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
				       ;;
   DW    COM_DI_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    3                             ;; number of scans
   DB    22,''                        ;;    U Diaeresis
   DB    24,''                        ;;    O Diaeresis
   DB    30,''                        ;;    A Diaeresis
COM_DI_UP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_DI_UP_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_DI_SP_END-$             ;; length of state section
   DB    DIARESIS_SPACE                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
				       ;;
   DW    COM_DI_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,249                        ;; error character = standalone accent
COM_DI_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
COM_DI_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW    0                             ;; Last State
COMMON_XLAT_END:                       ;;  END OF COMMON SECTION
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CODE PAGE 850 MULTILINGUAL 2  SPECIFIC TRANSLATION
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC SL_850_XLAT                    ;;
SL_850_XLAT:                           ;;
				       ;;
    DW   CP850_XLAT_END-$              ;;
    DW   850                           ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_NA_UP_K1_END-$            ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    CP850_NA_UP_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    2                             ;; number of entries
   DB     5,-1                         ;; CURRENCY SYMBOL
   DB    40,015H                       ;;
CP850_NA_UP_K1_T1_END:                   ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP850_NA_UP_K1_END:                      ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_AL_LO_END-$             ;; length of state section
   DB    ALPHA_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; error character = standalone accent
				       ;;
   DW    CP850_AL_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    2                             ;; number of entries
   DB    13,-1
   DB    27,-1                         ;; BLOT OUT CHAR UNDER 850
CP850_AL_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP850_AL_LO_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_AL_UP_END-$             ;; length of state section
   DB    ALPHA_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; error character = standalone accent
				       ;;
   DW    CP850_AL_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    2                             ;; number of entries
   DB    13,-1                         ;; BLOT OUT CHAR UNDER 850
   DB    27,-1                         ;; BLOT OUT CHAR UNDER 850
CP850_AL_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP850_AL_UP_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_CI_LO_END-$               ;; length of state section
   DB    CIRCUMFLEX_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    94,0                          ;; error character = standalone accent
				       ;;
   DW    CP850_CI_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of scans
   DB    18,88H                        ;;  e CIRCUMFLEX
   DB    23,8CH                        ;;  i CIRCUMFLEX
CP850_CI_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;;
				       ;;
CP850_CI_LO_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Overcircle Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_OC_LO_END-$               ;; length of state section
   DB    OVERCIRCLE_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
				       ;;
   DW    CP850_OC_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,86H                        ;; a OVERCIRCLE
CP850_OC_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP850_OC_LO_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Overcircle Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_OC_UP_END-$               ;; length of state section
   DB    OVERCIRCLE_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
				       ;;
   DW    CP850_OC_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,8FH                        ;; A OVERCIRCLE
CP850_OC_UP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP850_OC_UP_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Grave Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_GR_LO_END-$               ;; length of state section
   DB    GRAVE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    060H,0                        ;; error character = standalone accent
				       ;;
   DW    CP850_GR_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    5                             ;; number of scans
   DB    18,8AH                        ;; e GRAVE
   DB    22,97H                        ;; u GRAVE
   DB    23,8DH                        ;; i GRAVE
   DB    24,95H                        ;; o GRAVE
   DB    30,85H                        ;; a GRAVE
CP850_GR_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP850_GR_LO_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_DI_LO_END-$             ;; length of state section
   DB    DIARESIS_LOWER                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    0FEH,0                         ;; error character = standalone accent
				       ;;
   DW    CP850_DI_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    16,8BH                        ;; i DIARESIS
CP850_DI_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
CP850_DI_LO_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_DI_SP_END-$             ;; length of state section
   DB    DIARESIS_SPACE                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    0FEH,0                        ;; error character = standalone accent
				       ;;
   DW    CP850_DI_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0FEH,0                     ;; error character = standalone accent
CP850_DI_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
CP850_DI_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_OG_SP_END-$             ;; length of state section
   DB    OGONEK_SPACE                  ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0FEH,0                        ;; error character = standalone accent
				       ;;
   DW    CP850_OG_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0FEH                       ;; OGONEK SPACE
CP850_OG_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP850_OG_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW    0                             ;; LAST STATE
				       ;;
CP850_XLAT_END:                        ;; END OF CP850 SECTION
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CODE PAGE 852 MULTILINGUAL 2  SPECIFIC TRANSLATION
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC SL_852_XLAT                    ;;
SL_852_XLAT:                           ;;
				       ;;
    DW     CP852_XLAT_END-$            ;;
    DW     852                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;section commented out by gy.balint     ;;
;  DW    CP852_AL_LO_END-$           ;; length of state section
;  DB    ALPHA_LOWER                   ;; State ID
;  DW    G_KB                          ;; Keyboard Type
;  DB    -1,-1                         ;; Buffer entry for error character
;                                      ;;
;  DW    CP852_AL_LO_T1_END-$        ;; Size of xlat table
;  DB    STANDARD_TABLE                ;; xlat options:
;  DB    2                             ;; number of entries
;  DB    13,088H                       ;; l STROKE
;  DB    27,0D0H                       ;; d STROKE
;CP852_AL_LO_T1_END:                  ;;
				       ;;
;  DW    0                             ;; Size of xlat table - null table
				       ;;
;CP852_AL_LO_END:                     ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;section commented out by gy. balint   ;;
;  DW    CP852_AL_UP_END-$           ;; length of state section
;  DB    ALPHA_UPPER                   ;; State ID
;  DW    G_KB                          ;; Keyboard Type
;  DB    -1,-1                         ;; Buffer entry for error character
;                                      ;;
;  DW    CP852_AL_UP_T1_END-$        ;; Size of xlat table
;  DB    STANDARD_TABLE                ;; xlat options:
;  DB    2                             ;; number of entries
;  DB    13,09DH                       ;; L STROKE
;  DB    27,0D1H                       ;; D STROKE
;CP852_AL_UP_T1_END:                  ;;
				       ;;
;  DW    0                             ;; Size of xlat table - null table
				       ;;
;CP852_AL_UP_END:                     ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Third Shift
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_THIRD_END-$               ;; length of state section
   DB    THIRD_SHIFT                   ;; State ID
   DW    G_KB                          ;; Keyboard Type FERRARI
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    CP852_THIRD_T1_END-$            ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    6                             ;; number of entries
   DB    27,09eh,1bh                   ;; multiple sign               x
   DB    31,0d0h,1fh                   ;; d stroke small              x
   DB    32,0d1h,20h                   ;; D stroke capital            x
   DB    37,088h,025h                  ;; l stroke small              x
   DB    38,09dh,026h                  ;; L stroke capital
   DB    43,0cfh,02Bh                  ;; sun
CP852_THIRD_T1_END:                      ;;
				       ;;
   DW    0                             ;; Last xlat table
CP852_THIRD_END:                         ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE:CP 852
;; STATE: Non-alpha lower case
;; KEYBOARD TYPES: G
;;TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_NA_LO_K1_END-$          ;; length of section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    G_KB                          ;; Keyboard type
   DB    -1,-1                         ;; Buffer entry for error chars.
				       ;;
   DW    CP852_NA_LO_K1_T1_END-$       ;; Size of xlat table
   DB STANDARD_TABLE                   ;; xlat options:
   DB    14                            ;; NUMBER OF ENTRIES
   DB    03h,0096h                     ;;       l caron small     x
   DB    04h,0e7h                      ;;       s caron small     x
   DB    05h,09fh                      ;;       c caron small     x
   DB    06h,009ch                     ;;       t caron small     x
   DB    07h,0a7h                      ;;       z caron small     x
   DB    08h,0ech                      ;;       y acute small     x
   DB    09h,0a0h                      ;;       a acute small     x
   DB    0ah,0a1h                      ;;       i acute small     x
   DB    0bh,082h                      ;;       e acute small     x
   DB    01ah,0a3h                     ;;       u acute small     x
   DB    01bh,084h                     ;;       a diaresis small  x
   DB    027h,094h                     ;;       o diaresis small  x
   DB    028h,0f5h                     ;;       section symbol    x
   DB    02Bh,0e5h                     ;;       n caron small     x

CP852_NA_LO_K1_T1_END:
   DW   0
CP852_NA_LO_K1_END:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP852
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                     ;;
;; DW    CP852_NA_UP_K1_END-$            ;; length of state section
;; DB    NON_ALPHA_UPPER               ;; State ID
;; DW    G_KB                          ;; Keyboard Type
;; DB    -1,-1                         ;; Buffer entry for error character
				       ;;
;; DW    CP852_NA_UP_K1_T1_END-$         ;; Size of xlat table
;; DB    STANDARD_TABLE                ;; xlat options:
;; DB    2                             ;; number of entries
;; DB    029h,0f8h                     ;; overcircle
;; DB    0dh,0f3h                      ;; caron
;;CP852_NA_UP_K1_T1_END:                   ;;
				       ;;
;;   DW    0                             ;; Size of xlat table - null table
				       ;;
;;CP852_NA_UP_K1_END:                      ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_CA_LO_END-$             ;; length of state section
   DB    CARON_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F3H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_CA_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    9                             ;; number of scans
   DB    18,0D8H                       ;; e CARON
   DB    19,0FDH                       ;; r CARON
   DB    20,09CH                       ;; t CARON
   DB    21,0A7H                       ;; z CARON
   DB    31,0E7H                       ;; s CARON
   DB    32,0D4H                       ;; d CARON
   DB    38,096H                       ;; l CARON
   DB    46,09FH                       ;; c CARON
   DB    49,0E5H                       ;; n CARON
CP852_CA_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_CA_LO_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_CA_UP_END-$             ;; length of state section
   DB    CARON_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F3H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_CA_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    9                             ;; number of scans
   DB    18,0B7H                       ;; E CARON
   DB    19,0FCH                       ;; R CARON
   DB    20,09BH                       ;; T CARON
   DB    21,0A6H                       ;; Z CARON
   DB    31,0E6H                       ;; S CARON
   DB    32,0D2H                       ;; D CARON
   DB    38,095H                       ;; L CARON
   DB    46,0ACH                       ;; C CARON
   DB    49,0D5H                       ;; N CARON
CP852_CA_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_CA_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_CA_SP_END-$             ;; length of state section
;;   DB    CARON_SPACE                   ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F3H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_CA_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F3H                       ;; e CARON
;;CP852_CA_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_CA_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Circumflex Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_CI_UP_END-$             ;; length of state section
   DB    CIRCUMFLEX_UPPER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    05EH,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_CI_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    3                             ;; number of scans
   DB    23,0D7H                       ;; I CIRCUMFLEX
   DB    24,0E2H                       ;; O CIRCUMFLEX
   DB    30,0B6H                       ;; A CIRCUMFLEX
CP852_CI_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_CI_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_BR_LO_END-$             ;; length of state section
   DB    BREVE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F4H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_BR_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,0C7H                       ;; a BREVE
CP852_BR_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_BR_LO_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_BR_UP_END-$             ;; length of state section
   DB    BREVE_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F4H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_BR_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,0C6H                       ;; A BREVE
CP852_BR_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_BR_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_BR_SP_END-$             ;; length of state section
;;   DB    BREVE_SPACE                   ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F4H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_BR_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F4H                       ;; BREVE SPACE
;;CP852_BR_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_BR_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overcirle Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_OC_LO_END-$             ;; length of state section
   DB    OVERCIRCLE_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_OC_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    22,085H                       ;; u OVERCIRCLE
CP852_OC_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_OC_LO_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overcircle Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_OC_UP_END-$             ;; length of state section
   DB    OVERCIRCLE_UPPER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_OC_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    22,0DEH                       ;; O OVERCIRCLE
CP852_OC_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_OC_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_OG_LO_END-$             ;; length of state section
   DB    OGONEK_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F2H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_OG_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of scans
   DB    18,0A9H                       ;; e OGONEK
   DB    30,0A5H                       ;; a OGONEK
CP852_OG_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_OG_LO_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_OG_UP_END-$             ;; length of state section
   DB    OGONEK_UPPER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F2H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_OG_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of scans
   DB    18,0A8H                       ;; E OGONEK
   DB    30,0A4H                       ;; A OGONEK
CP852_OG_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_OG_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_OG_SP_END-$             ;; length of state section
;;   DB    OGONEK_SPACE                  ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F2H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_OG_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F2H                       ;; OGONEK SPACE
;;CP852_OG_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_OG_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overdot Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_OD_LO_END-$             ;; length of state section
   DB    OVERDOT_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0FAH,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_OD_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    21,0BEH                       ;; z OVERDOT
CP852_OD_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_OD_LO_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overdot Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_OD_UP_END-$             ;; length of state section
   DB    OVERDOT_UPPER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0FAH,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_OD_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    21,0BDH                       ;; Z OVERDOT
CP852_OD_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_OD_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_AC_LO_END-$             ;; length of state section
   DB    ACUTE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_AC_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    7                             ;; number of entries
   DB    19,0EAH                       ;; r ACUTE
   DB    21,0ABH                       ;; z ACUTE
   DB    31,098H                       ;; s ACUTE
   DB    38,092H                       ;; l ACUTE
   DB    44,0ECH                       ;; y ACUTE
   DB    46,086H                       ;; c ACUTE
   DB    49,0E4H                       ;; n ACUTE
CP852_AC_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_AC_LO_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_AC_UP_END-$             ;; length of state section
   DB    ACUTE_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_AC_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    11                            ;; number of entries
   DB    19,0E8H                       ;; R ACUTE
   DB    21,08DH                       ;; Z ACUTE
   DB    22,0E9H                       ;; U ACUTE
   DB    23,0D6H                       ;; I ACUTE
   DB    24,0E0H                       ;; O ACUTE
   DB    30,0B5H                       ;; A ACUTE
   DB    31,097H                       ;; S ACUTE
   DB    38,091H                       ;; L ACUTE
   DB    44,0EDH                       ;; Y ACUTE
   DB    46,08FH                       ;; C ACUTE
   DB    49,0E3H                       ;; N ACUTE
CP852_AC_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_AC_UP_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_AC_SP_END-$             ;; length of state section
   DB    ACUTE_SPACE                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_AC_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0EFH                       ;; error character = standalone accent
CP852_AC_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
CP852_AC_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_DC_LO_END-$             ;; length of state section
   DB    DOUBLEACUTE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F1H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_DC_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    22,0FBH                       ;; u DOUBLEACUTE
   DB    24,08BH                       ;; o DOUBLEACUTE
CP852_DC_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_DC_LO_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_DC_UP_END-$             ;; length of state section
   DB    DOUBLEACUTE_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F1H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_DC_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    22,0EBH                       ;; U DOUBLEACUTE
   DB    24,08AH                       ;; O DOUBLEACUTE
CP852_DC_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_DC_UP_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_DC_SP_END-$             ;; length of state section
;;   DB    DOUBLEACUTE_SPACE                   ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F1H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_DC_SP_T1_END-$        ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of entries
;;   DB    57,0F1H                       ;; DOUBLEACUTE SPACE
;;CP852_DC_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_DC_SP_END:                       ;;
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_DI_UP_END-$             ;; length of state section
   DB    DIARESIS_UPPER                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
				       ;;
   DW    CP852_DI_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    18,0D3H                       ;;    E Diaeresis
CP852_DI_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_DI_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_CE_LO_END-$             ;; length of state section
   DB    CEDILLA_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_CE_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    20,0EEH                       ;; t CEDILLA
   DB    31,0ADH                       ;; s CEDILLA
CP852_CE_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_CE_LO_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_CE_UP_END-$             ;; length of state section
   DB    CEDILLA_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_CE_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    20,0DDH                       ;; T CEDILLA
   DB    31,0B8H                       ;; S CEDILLA
CP852_CE_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_CE_UP_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_CE_SP_END-$             ;; length of state section
;;   DB    CEDILLA_SPACE                   ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F7H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_CE_SP_T1_END-$        ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of entries
;;   DB    57,0F7H                       ;; CEDILLA SPACE
;;CP852_CE_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_CE_SP_END:                       ;;
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    0                             ;; LAST STATE
				       ;;
CP852_XLAT_END:                        ;;  END OF CP852 SECTION
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CODE     ENDS                          ;;  END OF PROGRAM
	 END                           ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kbd2\kdfuk166.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;CODE to be deleted has a double ;; followed by actual asm code....****

;; LATEST CHANGE ALT & CTL



	PAGE	,132
	TITLE	MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Defintion File
;;
;; This file contains the keyboard tables for Spanish.
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC	       ;;
	INCLUDE POSTEQU.INC	       ;;
	INCLUDE KEYBMAC.INC	       ;;
				       ;;
	PUBLIC UK2_LOGIC		;;
	PUBLIC UK2_437_XLAT		;;
	PUBLIC UK2_850_XLAT		;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a liner search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE	    EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; UK State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
UK2_LOGIC:

   DW  LOGIC_END-$		       ;; length
				       ;;
   DW  0			       ;; special features
				       ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND 	       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   IFF	EITHER_ALT,NOT		       ;;
   ANDF EITHER_CTL,NOT		       ;;
      IFF EITHER_SHIFT		       ;;
	  SET_FLAG DEAD_UPPER	       ;;
      ELSEF			       ;;
	  SET_FLAG DEAD_LOWER	       ;;
      ENDIFF			       ;;
   ENDIFF			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:			       ;;
				       ;;
   IFF ACUTE,NOT		       ;;
      GOTO DIARESIS_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ACUTE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_ACUTE:			       ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      GOTO NON_DEAD		       ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:			       ;;
				       ;;
   IFF DIARESIS,NOT		       ;;
      GOTO GRAVE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT DIARESIS_SPACE	       ;;  exist for 437 so beep for
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_DIARESIS:		       ;;
      PUT_ERROR_CHAR DIARESIS_SPACE    ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:			       ;;
				       ;;
   IFF GRAVE,NOT		       ;;
      GOTO CIRCUMFLEX_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT GRAVE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_GRAVE:			       ;;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:		       ;;
				       ;;
   IFF CIRCUMFLEX,NOT		       ;;
      GOTO NON_DEAD		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CIRCUMFLEX:		       ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
NON_DEAD:			       ;;
				       ;;
   IFKBD G_KB+P12_KB		       ;; Avoid accidentally translating
   ANDF LC_E0			       ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC		       ;;   G keyboard
   ENDIFF			       ;;
;;***BD ADDED FOR ALT, CTRL CASES      ;;
      IFF EITHER_CTL,NOT	       ;;
	 IFF  ALT_SHIFT 	       ;; ALT - case
	 ANDF R_ALT_SHIFT,NOT	       ;;
	    XLATT ALT_CASE	       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF EITHER_ALT,NOT	       ;; CTRL - case
	    XLATT CTRL_CASE	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
;;***BD END OF ADDITION
				       ;;
   IFF	EITHER_ALT,NOT		       ;; Lower and upper case.  Alphabetic
   ANDF EITHER_CTL,NOT		       ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT		       ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE,NOT	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_UPPER        ;;
	  IFF CAPS_STATE	       ;;
	      XLATT ALPHA_LOWER        ;;
	  ELSEF 		       ;;
	      XLATT ALPHA_UPPER        ;;
	  ENDIFF		       ;;
      ELSEF			       ;;
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE 	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_LOWER        ;;
	  IFF CAPS_STATE	       ;;
	     XLATT ALPHA_UPPER	       ;;
	  ELSEF 		       ;;
	     XLATT ALPHA_LOWER	       ;;
	  ENDIFF		       ;;
      ENDIFF			       ;;
   ELSEF			       ;;
      IFF EITHER_SHIFT,NOT	       ;;
	  IFKBD XT_KB+AT_KB	 ;;
	      IFF  EITHER_CTL	       ;;
	      ANDF ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	  ELSEF 		       ;;
	      IFF EITHER_CTL,NOT       ;;
	      ANDF R_ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	   ENDIFF		       ;;
      ENDIFF			       ;;
   ENDIFF			       ;;
				       ;;
   EXIT_STATE_LOGIC		       ;;
				       ;;
LOGIC_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; UK Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC UK2_COMMON_XLAT 		;;
UK2_COMMON_XLAT:			;;
				       ;;
   DW	 COMMON_XLAT_END-$	       ;; length of section
   DW	 -1			       ;; code page
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;;***BD - ADDED FOR ALT CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K2_END-$	       ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_ALT_K2_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 0			       ;; number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB	 53,225,0		       ;; TEST ENTRY
COM_ALT_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_ALT_K2_END: 		       ;;
				       ;;
;;******************************
;;***BD - ADDED FOR CTRL CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G_KB+P12_KB+AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K2_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 G_KB+P12_KB+AT_KB	       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_CTRL_K2_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 2			       ;; number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB	 53,226,0		       ;; TEST ENTRY
   DB	 43,-1,-1		       ;; invalid slash
   DB	 41,28,41		       ;; valid slash
COM_CTRL_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CTRL_K2_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K1_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	 40,"'"                        ;; '
   DB	 43,'#'                        ;; #
COM_NA_LO_K1_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K2_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 AT_KB			      ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K2_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 3			       ;; number of entries
   DB	 41,"\"                        ;; \
   DB	 40,"'"                        ;; '
   DB	 43,'#'                        ;; #
COM_NA_LO_K2_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K2_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: XT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K3_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K3_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	 40,"'"                        ;; '
   DB	 41,'#'                        ;; #
   DB	 43,'\'                        ;; #
COM_NA_LO_K3_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K3_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G_KB+P12_KB+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 5			       ;; number of entries
   DB	 41,0AAh		       ;; 
   DB	 3,'"'                         ;; "
   DB	 4,09CH 		       ;; 
   DB	 40,'@'                        ;; at sign
   DB	 43,07EH		       ;; ~
COM_NA_UP_T1_K1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K1_END:			  ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K2_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K2_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 5			       ;; number of entries
   DB	 3,'"'                         ;; "
   DB	 4,09CH 		       ;; 
   DB	 41,07EH		       ;; ~
   DB	 40,'@'                        ;; at sign
   DB	 43,07CH		       ;; Broken vertical bar
COM_NA_UP_T1_K2_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K2_END:			  ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: AT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K3_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K3_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 5			       ;; number of entries
   DB	 41,07Ch		       ;; 
   DB	 3,'"'                         ;; "
   DB	 4,09CH 		       ;; 
   DB	 40,'@'                        ;; at sign
   DB	 43,07EH		       ;; ~
COM_NA_UP_T1_K3_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K3_END:			  ;;
				       ;;
				       ;;
   DW	 0			       ;; Last State
COMMON_XLAT_END:		       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; UK Specific Translate Section for 437
;; 437 IS COMPLETELY COVERED BY THE COMMON TABLE.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC UK2_437_XLAT			;;
UK2_437_XLAT:				;;
				       ;;
   DW	  CP437_XLAT_END-$	       ;; length of section
   DW	  437			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_THIRD_K1_END-$		 ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP437_THIRD_K1_T1_END-$	    ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 41,0DDH		       ;; Solid vertical bar - graphics block
CP437_THIRD_K1_T1_END:			    ;;
				       ;;
   DW	 0			       ;; Last xlat table
CP437_THIRD_K1_END:			    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G_KB+P12_KB+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_NA_UP_K1_END-$		    ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP437_NA_UP_T1_K1_END-$	    ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 86,07ch		       ;; vertical bar
CP437_NA_UP_T1_K1_END:			    ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_NA_UP_K1_END:			    ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	  0			       ;; LAST STATE
				       ;;
CP437_XLAT_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; UK Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC UK2_850_XLAT			;;
UK2_850_XLAT:				;;
				       ;;
   DW	  CP850_XLAT_END-$	       ;; length of section
   DW	  850			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_THIRD_K1_END-$		 ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_THIRD_K1_T1_END-$	    ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 41,07CH		       ;; Solid vertical bar - |
CP850_THIRD_K1_T1_END:			    ;;
				       ;;
   DW	 0			       ;; Last xlat table
CP850_THIRD_K1_END:			    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G_KB+P12_KB+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_UP_K1_END-$		    ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_NA_UP_T1_K1_END-$	    ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 86,0DDh		       ;; broken vertical
CP850_NA_UP_T1_K1_END:			    ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_UP_K1_END:			    ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; LAST STATE
				       ;;
CP850_XLAT_END: 		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CODE	 ENDS			       ;;
	 END			       ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kbd2\kdfuk.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;CODE to be deleted has a double ;; followed by actual asm code....****

;; LATEST CHANGE ALT & CTL



	PAGE	,132
	TITLE	MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Defintion File
;;
;; This file contains the keyboard tables for Spanish.
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC	       ;;
	INCLUDE POSTEQU.INC	       ;;
	INCLUDE KEYBMAC.INC	       ;;
				       ;;
	PUBLIC UK_LOGIC 	       ;;
	PUBLIC UK_437_XLAT	       ;;
	PUBLIC UK_850_XLAT	       ;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a liner search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE	    EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; UK State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
UK_LOGIC:

   DW  LOGIC_END-$		       ;; length
				       ;;
   DW  0			       ;; special features
				       ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND 	       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   IFF	EITHER_ALT,NOT		       ;;
   ANDF EITHER_CTL,NOT		       ;;
      IFF EITHER_SHIFT		       ;;
	  SET_FLAG DEAD_UPPER	       ;;
      ELSEF			       ;;
	  SET_FLAG DEAD_LOWER	       ;;
      ENDIFF			       ;;
   ENDIFF			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:			       ;;
				       ;;
   IFF ACUTE,NOT		       ;;
      GOTO DIARESIS_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ACUTE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_ACUTE:			       ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      GOTO NON_DEAD		       ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:			       ;;
				       ;;
   IFF DIARESIS,NOT		       ;;
      GOTO GRAVE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT DIARESIS_SPACE	       ;;  exist for 437 so beep for
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_DIARESIS:		       ;;
      PUT_ERROR_CHAR DIARESIS_SPACE    ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:			       ;;
				       ;;
   IFF GRAVE,NOT		       ;;
      GOTO CIRCUMFLEX_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT GRAVE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_GRAVE:			       ;;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:		       ;;
				       ;;
   IFF CIRCUMFLEX,NOT		       ;;
      GOTO NON_DEAD		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CIRCUMFLEX:		       ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
NON_DEAD:			       ;;
				       ;;
   IFKBD G_KB+P12_KB		       ;; Avoid accidentally translating
   ANDF LC_E0			       ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC		       ;;   G keyboard
   ENDIFF			       ;;
;;***BD ADDED FOR ALT, CTRL CASES      ;;
      IFF EITHER_CTL,NOT	       ;;
	 IFF  ALT_SHIFT 	       ;; ALT - case
	 ANDF R_ALT_SHIFT,NOT	       ;;
	    XLATT ALT_CASE	       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF EITHER_ALT,NOT	       ;; CTRL - case
	    XLATT CTRL_CASE	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
;;***BD END OF ADDITION
				       ;;
   IFF	EITHER_ALT,NOT		       ;; Lower and upper case.  Alphabetic
   ANDF EITHER_CTL,NOT		       ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT		       ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE,NOT	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_UPPER        ;;
	  IFF CAPS_STATE	       ;;
	      XLATT ALPHA_LOWER        ;;
	  ELSEF 		       ;;
	      XLATT ALPHA_UPPER        ;;
	  ENDIFF		       ;;
      ELSEF			       ;;
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE 	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_LOWER        ;;
	  IFF CAPS_STATE	       ;;
	     XLATT ALPHA_UPPER	       ;;
	  ELSEF 		       ;;
	     XLATT ALPHA_LOWER	       ;;
	  ENDIFF		       ;;
      ENDIFF			       ;;
   ELSEF			       ;;
      IFF EITHER_SHIFT,NOT	       ;;
	  IFKBD XT_KB+AT_KB	 ;;
	      IFF  EITHER_CTL	       ;;
	      ANDF ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	  ELSEF 		       ;;
	      IFF EITHER_CTL,NOT       ;;
	      ANDF R_ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	   ENDIFF		       ;;
      ENDIFF			       ;;
   ENDIFF			       ;;
				       ;;
   EXIT_STATE_LOGIC		       ;;
				       ;;
LOGIC_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; UK Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC UK_COMMON_XLAT		       ;;
UK_COMMON_XLAT: 		       ;;
				       ;;
   DW	 COMMON_XLAT_END-$	       ;; length of section
   DW	 -1			       ;; code page
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;;***BD - ADDED FOR ALT CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K2_END-$	       ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_ALT_K2_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 0			       ;; number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB	 53,225,0		       ;; TEST ENTRY
COM_ALT_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_ALT_K2_END: 		       ;;
				       ;;
;;******************************
;;***BD - ADDED FOR CTRL CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G_KB+P12_KB+AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K2_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 G_KB+P12_KB+AT_KB	       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_CTRL_K2_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 2			       ;; number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB	 53,226,0		       ;; TEST ENTRY
   DB	 43,-1,-1		       ;; invalid slash
   DB	 41,28,41		       ;; valid slash
COM_CTRL_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CTRL_K2_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K1_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	 40,"'"                        ;; '
   DB	 43,'#'                        ;; #
COM_NA_LO_K1_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K2_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 AT_KB			      ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K2_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 3			       ;; number of entries
   DB	 41,"\"                        ;; \
   DB	 40,"'"                        ;; '
   DB	 43,'#'                        ;; #
COM_NA_LO_K2_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K2_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: XT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K3_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K3_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	 40,"'"                        ;; '
   DB	 41,'#'                        ;; #
   DB	 43,'\'                        ;; #
COM_NA_LO_K3_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K3_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G_KB+P12_KB+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 5			       ;; number of entries
   DB	 41,0AAh		       ;; 
   DB	 3,'"'                         ;; "
   DB	 4,09CH 		       ;; 
   DB	 40,'@'                        ;; at sign
   DB	 43,07EH		       ;; ~
COM_NA_UP_T1_K1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K1_END:			  ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K2_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K2_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 5			       ;; number of entries
   DB	 3,'"'                         ;; "
   DB	 4,09CH 		       ;; 
   DB	 41,07EH		       ;; ~
   DB	 40,'@'                        ;; at sign
   DB	 43,07CH		       ;; Broken vertical bar
COM_NA_UP_T1_K2_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K2_END:			  ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: AT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K3_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K3_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 5			       ;; number of entries
   DB	 41,07Ch		       ;; 
   DB	 3,'"'                         ;; "
   DB	 4,09CH 		       ;; 
   DB	 40,'@'                        ;; at sign
   DB	 43,07EH		       ;; ~
COM_NA_UP_T1_K3_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K3_END:			  ;;
				       ;;
				       ;;
   DW	 0			       ;; Last State
COMMON_XLAT_END:		       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; UK Specific Translate Section for 437
;; 437 IS COMPLETELY COVERED BY THE COMMON TABLE.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC UK_437_XLAT		       ;;
UK_437_XLAT:			       ;;
				       ;;
   DW	  CP437_XLAT_END-$	       ;; length of section
   DW	  437			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_THIRD_K1_END-$		 ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP437_THIRD_K1_T1_END-$	    ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 41,0DDH		       ;; Solid vertical bar - graphics block
CP437_THIRD_K1_T1_END:			    ;;
				       ;;
   DW	 0			       ;; Last xlat table
CP437_THIRD_K1_END:			    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G_KB+P12_KB+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_NA_UP_K1_END-$		    ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP437_NA_UP_T1_K1_END-$	    ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 86,07ch		       ;; vertical bar
CP437_NA_UP_T1_K1_END:			    ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_NA_UP_K1_END:			    ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	  0			       ;; LAST STATE
				       ;;
CP437_XLAT_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; UK Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC UK_850_XLAT		       ;;
UK_850_XLAT:			       ;;
				       ;;
   DW	  CP850_XLAT_END-$	       ;; length of section
   DW	  850			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_THIRD_K1_END-$		 ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_THIRD_K1_T1_END-$	    ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 41,07CH		       ;; Solid vertical bar - |
CP850_THIRD_K1_T1_END:			    ;;
				       ;;
   DW	 0			       ;; Last xlat table
CP850_THIRD_K1_END:			    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G_KB+P12_KB+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_UP_K1_END-$		    ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_NA_UP_T1_K1_END-$	    ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 86,0DDh		       ;; broken vertical
CP850_NA_UP_T1_K1_END:			    ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_UP_K1_END:			    ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; LAST STATE
				       ;;
CP850_XLAT_END: 		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CODE	 ENDS			       ;;
	 END			       ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kbd2\keybmac.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS DOS 3.3 - NLS Support - Keyboard Definition File
;;
;; File Name:  KEYBMAC.INC
;; ----------
;;
;; Author:     Bill Devlin  - IBM Canada Laboratory - May 1986
;; -------     ???????????
;;
;; Description:
;; ------------
;;	 Include file containing macros for the Keyboard Definition File.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Dead key flags
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE		    EQU   80H	       ;; NLS_FLAG_1
GRAVE		    EQU   40H	       ;;
DIARESIS	    EQU   20H	       ;;
CIRCUMFLEX	    EQU   10H	       ;;
CEDILLA 	    EQU   08H	       ;;
TILDE		    EQU   04H	       ;;
RUS_MODE            EQU   01H          ;; added by YST for cryillic keyboard
LAT_MODE            EQU   00H          ;; 1/21/91
				       ;; NLS_FLAG_2 : nothing defined yet
CARON		    EQU   80H
BREVE		    EQU   40H
OVERCIRCLE	    EQU   20H
OGONEK		    EQU   10H
OVERDOT 	    EQU   08H
DOUBLEACUTE	    EQU   04H

				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State IDs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DEAD_LOWER	    EQU    1	       ;; dead keys on lower shift
DEAD_UPPER	    EQU    2	       ;;
ALPHA_LOWER	    EQU    3	       ;;
ALPHA_UPPER	    EQU    4	       ;;
NON_ALPHA_LOWER     EQU    5	       ;;
NON_ALPHA_UPPER     EQU    6	       ;;
THIRD_SHIFT	    EQU    7	       ;;
ACUTE_LOWER	    EQU    8	       ;;
ACUTE_UPPER	    EQU    9	       ;;
ACUTE_SPACE	    EQU   10	       ;;
GRAVE_LOWER	    EQU   11	       ;;
GRAVE_UPPER	    EQU   12	       ;;
GRAVE_SPACE	    EQU   13	       ;;
DIARESIS_LOWER	    EQU   14	       ;;
DIARESIS_UPPER	    EQU   15	       ;;
DIARESIS_SPACE	    EQU   16	       ;;
CIRCUMFLEX_LOWER    EQU   17	       ;;
CIRCUMFLEX_UPPER    EQU   18	       ;;
CIRCUMFLEX_SPACE    EQU   19	       ;;
CEDILLA_LOWER	    EQU   20	       ;;
CEDILLA_UPPER	    EQU   21	       ;;
CEDILLA_SPACE	    EQU   22	       ;;
CEDILLA_CEDILLA     EQU   23	       ;;
DEAD_THIRD	    EQU   24	       ;;
ACUTE_ACUTE	    EQU   25	       ;;
GRAVE_GRAVE	    EQU   26	       ;;
DIARESIS_DIARESIS   EQU   27	       ;;
CIRCUMFLEX_CIRCUMFLEX EQU 28	       ;;
FOURTH_SHIFT	    EQU   29	       ;;
DEAD_FOURTH	    EQU   30	       ;;
TILDE_LOWER	    EQU   31	       ;;
TILDE_UPPER	    EQU   32	       ;;
TILDE_SPACE	    EQU   33	       ;;
TILDE_TILDE	    EQU   34	       ;;
ALT_CASE	    EQU   35	       ;;
CTRL_CASE	    EQU   36	       ;;
NUMERIC_PAD	    EQU   37	       ;;
DIVIDE_SIGN	    EQU   38	       ;;
BOTLH_CAPS	    EQU   39	       ;;
BOTRH_CAPS	    EQU   40	       ;;
BOTLH_F_CAPS	    EQU   41	       ;;
BOTRH_F_CAPS	    EQU   42	       ;;
RUS_MODE_SET        EQU   143          ;;   Added for FR-CAN
LAT_MODE_SET	    EQU   144	       ;;   Added for FR-CAN


;************************************************
; Mihindu 11/30/90 - Added Eastern Europe support
;************************************************
CARON_SPACE	    EQU   43
CARON_LOWER	    EQU   44
CARON_UPPER	    EQU   45
BREVE_SPACE	    EQU   46
BREVE_LOWER	    EQU   47
BREVE_UPPER	    EQU   48
OVERCIRCLE_SPACE    EQU   49
OVERCIRCLE_LOWER    EQU   50
OVERCIRCLE_UPPER    EQU   51
OGONEK_SPACE	    EQU   52
OGONEK_LOWER	    EQU   53
OGONEK_UPPER	    EQU   54
OVERDOT_SPACE	    EQU   55
OVERDOT_LOWER	    EQU   56
OVERDOT_UPPER	    EQU   57
DOUBLEACUTE_SPACE   EQU   58
DOUBLEACUTE_LOWER   EQU   59
DOUBLEACUTE_UPPER   EQU   60

;******************************************************
;  M000 --- new state for KDFJP.ASM (Kermit)	*******
;******************************************************

DBCS_OLD_A	   EQU	 61		; M000 (JP9009)

NON_ALPHA_LOWER_SEC    EQU   62        ;;  Added for FR-CAN
NON_ALPHA_UPPER_SEC    EQU   63        ;;  For secondary keyboard on Dual Mode
ALPHA_LOWER_SEC        EQU   64        ;;  keyboard systems
ALPHA_UPPER_SEC        EQU   65        ;;
DEAD_LOWER_SEC	       EQU   66	       ;;  Added for FR-CAN

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Logic Macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;

UNKNOWN = 255

FIND_FLAG MACRO  FLAG_MASK
       IFIDN <FLAG_MASK>,<SCAN_MATCH>
	  FLAG_ID = EXT_KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<EITHER_SHIFT>
	  FLAG_ID = EXT_KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<CAPS_STATE>
	  FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<NUM_STATE>
	  FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<EITHER_CTL>
	  FLAG_ID = EXT_KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<EITHER_ALT>
	  FLAG_ID = EXT_KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<LEFT_SHIFT>
	  FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<RIGHT_SHIFT>
	  FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<ALT_SHIFT>
	  FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<CTL_SHIFT>
	  FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<R_ALT_SHIFT>
	  FLAG_ID = KB_FLAG_3_ID
       ELSE
       IFIDN <FLAG_MASK>,<R_CTL_SHIFT>
	  FLAG_ID = KB_FLAG_3_ID
       ELSE
       IFIDN <FLAG_MASK>,<TILDE>
	  FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<ACUTE>
	  FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<GRAVE>
	  FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<DIARESIS>
	  FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<CEDILLA>
	  FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<CIRCUMFLEX>
	  FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<CARON>
	  FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<BREVE>
	  FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<OVERCIRCLE>
	  FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<OGONEK>
	  FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<OVERDOT>
	  FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<DOUBLEACUTE>
	  FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<LC_E0>
	  FLAG_ID = KB_FLAG_3_ID
       ELSE
;; ============================================================
;; For FR-CAN Dual mode
;; ============================================================
       IFIDN <FLAG_MASK>,<SHIFTS_PRESSED>
          FLAG_ID = EXT_KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<RUS_MODE>
          FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<LAT_MODE>
          FLAG_ID = NLS_FLAG_1_ID
       ELSE
;; ============================================================
;; End of FR-CAN dual mode
;; ============================================================
	  FLAG_ID = UNKNOWN
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FLAG MACRO  FLAG_MASK
       FIND_FLAG FLAG_MASK
       IF (FLAG_ID EQ UNKNOWN)
	  IF2
	      %OUT Unknown parameter FLAG_MASK on FLAG MACRO
	  ENDIF
       ELSE
	  DB FLAG_ID
	  DB FLAG_MASK
       ENDIF
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFF MACRO  FLAG_MASK,MASK_TYPE
    MAC_OK = 1
    IFB  <MASK_TYPE>
	 NOT_BIT = 00000000B
    ELSE
	 IFIDN <MASK_TYPE>,<NOT>
	     NOT_BIT = 00001000B
	 ELSE
	     MAC_OK = 0
	     IF2
		 %OUT Unknown parameter MASK_TYPE on IFF MACRO
	     ENDIF
	 ENDIF
    ENDIF
    IF MAC_OK
       FIND_FLAG FLAG_MASK
       IF (FLAG_ID EQ UNKNOWN)
	  IF2
	      %OUT Unknown parameter FLAG_MASK on IFF MACRO
	  ENDIF
       ELSE
	  DB IFF_COMMAND+NOT_BIT+FLAG_ID
	  DB FLAG_MASK
       ENDIF
    ENDIF
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFKBD MACRO  SYS
       DB IFKBD_COMMAND
       DW SYS
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ANDF MACRO  FLAG_MASK,MASK_TYPE
    MAC_OK = 1
    IFB  <MASK_TYPE>
	 NOT_BIT = 00000000B
    ELSE
	 IFIDN <MASK_TYPE>,<NOT>
	     NOT_BIT = 00001000B
	 ELSE
	     MAC_OK = 0
	     IF2
		 %OUT Unknown parameter MASK_TYPE on ANDF MACRO
	     ENDIF
	 ENDIF
    ENDIF
    IF MAC_OK
       FIND_FLAG FLAG_MASK
       IF (FLAG_ID EQ UNKNOWN)
	  IF2
	      %OUT Unknown parameter FLAG_MASK on ANDF MACRO
	  ENDIF
       ELSE
	  DB ANDF_COMMAND+NOT_BIT+FLAG_ID
	  DB FLAG_MASK
       ENDIF
    ENDIF
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ELSEF  MACRO
       DB  ELSEF_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ENDIFF MACRO
       DB  ENDIFF_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
XLATT  MACRO STATE
       DB  XLATT_COMMAND
       DB  STATE
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PUT_ERROR_CHAR	MACRO STATE
       DB  PUT_ERROR_COMMAND
       DB  STATE
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPTION MACRO MASK,MASK_TYPE
    MAC_OK = 1
    IFB  <MASK_TYPE>
	 NOT_BIT = 00000000B
    ELSE
	 IFIDN <MASK_TYPE>,<NOT>
	     NOT_BIT = 00001000B
	 ELSE
	     MAC_OK = 0
	     IF2
		 %OUT Unknown parameter MASK_TYPE on OPTION MACRO
	     ENDIF
	 ENDIF
    ENDIF
    IF MAC_OK
       DB  OPTION_COMMAND+NOT_BIT
       DB  MASK
    ENDIF
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SET_FLAG  MACRO STATE
       DB  SET_FLAG_COMMAND
       DB  STATE
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RESET_NLS  MACRO
       DB  RESET_NLS_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RESET_NLS1  MACRO
       DB  RESET_NLS1_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BEEP   MACRO
       DB  BEEP_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GOTO	MACRO GOTO_OFFSET
       DB  GOTO_COMMAND
       DW  GOTO_OFFSET-$-2
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
EXIT_INT_9  MACRO
       DB  GOTO_COMMAND+EXIT_INT_9_FLAG
       DW  0
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
EXIT_STATE_LOGIC  MACRO
       DB  GOTO_COMMAND+EXIT_STATE_LOGIC_FLAG
       DW  0
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CHECK_FOR_CORE_KEY MACRO
       DB  CHECK_CORE_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kbd2\kdfuk168.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;CODE to be deleted has a double ;; followed by actual asm code....****

;; LATEST CHANGE ALT & CTL



	PAGE	,132
	TITLE	MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Defintion File
;;
;; This file contains the keyboard tables for Spanish.
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;; Author:     NICK SAVAGE  - IBM Corp. 	    - May 1987
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC	       ;;					;AN000;
	INCLUDE POSTEQU.INC	       ;;					;AN000;
	INCLUDE KEYBMAC.INC	       ;;					;AN000;
				       ;;					;AN000;
	PUBLIC UK1_LOGIC	       ;;					;AN000;
	PUBLIC UK1_437_XLAT		;;					;AN000;
	PUBLIC UK1_850_XLAT		;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE'          ;;                                       ;AN000;
	ASSUME CS:CODE,DS:CODE	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; Standard translate table options are a liner search table			;AN000;
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)				;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
STANDARD_TABLE	    EQU   TYPE_2_TAB+ASCII_ONLY 				;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;***************************************					;AN000;
;; UK State Logic								;AN000;
;;***************************************					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
UK1_LOGIC:									;AN000;
										;AN000;
   DW  LOGIC_END-$		       ;; length				;AN000;
				       ;;					;AN000;
   DW  0			       ;; special features			;AN000;
				       ;;					;AN000;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE			;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; OPTIONS:  If we find a scan match in 					;AN000;
;; an XLATT or SET_FLAG operation then						;AN000;
;; exit from INT 9.								;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   OPTION EXIT_IF_FOUND 	       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;  Dead key definitions must come before					;AN000;
;;  dead key translations to handle						;AN000;
;;  dead key + dead key.							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   IFF	EITHER_ALT,NOT		       ;;					;AN000;
   ANDF EITHER_CTL,NOT		       ;;					;AN000;
      IFF EITHER_SHIFT		       ;;					;AN000;
	  SET_FLAG DEAD_UPPER	       ;;					;AN000;
      ELSEF			       ;;					;AN000;
	  SET_FLAG DEAD_LOWER	       ;;					;AN000;
      ENDIFF			       ;;					;AN000;
   ENDIFF			       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; ACUTE ACCENT TRANSLATIONS							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
ACUTE_PROC:			       ;;					;AN000;
				       ;;					;AN000;
   IFF ACUTE,NOT		       ;;					;AN000;
      GOTO DIARESIS_PROC	       ;;					;AN000;
      ENDIFF			       ;;					;AN000;
				       ;;					;AN000;
      RESET_NLS 		       ;;					;AN000;
      IFF R_ALT_SHIFT,NOT	       ;;					;AN000;
	 XLATT ACUTE_SPACE	       ;;					;AN000;
      ENDIFF			       ;;					;AN000;
      IFF EITHER_CTL,NOT	       ;;					;AN000;
      ANDF EITHER_ALT,NOT	       ;;					;AN000;
	 IFF EITHER_SHIFT	       ;;					;AN000;
	    IFF CAPS_STATE	       ;;					;AN000;
	       XLATT ACUTE_LOWER       ;;					;AN000;
	    ELSEF		       ;;					;AN000;
	       XLATT ACUTE_UPPER       ;;					;AN000;
	    ENDIFF		       ;;					;AN000;
	 ELSEF			       ;;					;AN000;
	    IFF CAPS_STATE	       ;;					;AN000;
	       XLATT ACUTE_UPPER       ;;					;AN000;
	    ELSEF		       ;;					;AN000;
	       XLATT ACUTE_LOWER       ;;					;AN000;
	    ENDIFF		       ;;					;AN000;
	 ENDIFF 		       ;;					;AN000;
      ENDIFF			       ;;					;AN000;
				       ;;					;AN000;
INVALID_ACUTE:			       ;;					;AN000;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT	;AN000;
      BEEP			       ;; failed or we are ina bad shift state. ;AN000;
      GOTO NON_DEAD		       ;; Either is invalid so BEEP and fall	;AN000;
				       ;; through to generate the second char.	;AN000;
				       ;; Note that the dead key flag will be	;AN000;
				       ;; reset before we get here.		;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DIARESIS ACCENT TRANSLATIONS 						;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
DIARESIS_PROC:			       ;;					;AN000;
				       ;;					;AN000;
   IFF DIARESIS,NOT		       ;;					;AN000;
      GOTO GRAVE_PROC		       ;;					;AN000;
      ENDIFF			       ;;					;AN000;
				       ;;					;AN000;
      RESET_NLS 		       ;;					;AN000;
      IFF R_ALT_SHIFT,NOT	       ;;					;AN000;
	 XLATT DIARESIS_SPACE	       ;;  exist for 437 so beep for		;AN000;
      ENDIFF			       ;;					;AN000;
      IFF EITHER_CTL,NOT	       ;;					;AN000;
      ANDF EITHER_ALT,NOT	       ;;					;AN000;
	 IFF EITHER_SHIFT	       ;;					;AN000;
	    IFF CAPS_STATE	       ;;					;AN000;
	       XLATT DIARESIS_LOWER    ;;					;AN000;
	    ELSEF		       ;;					;AN000;
	       XLATT DIARESIS_UPPER    ;;					;AN000;
	    ENDIFF		       ;;					;AN000;
	 ELSEF			       ;;					;AN000;
	    IFF CAPS_STATE	       ;;					;AN000;
	       XLATT DIARESIS_UPPER    ;;					;AN000;
	    ELSEF		       ;;					;AN000;
	       XLATT DIARESIS_LOWER    ;;					;AN000;
	    ENDIFF		       ;;					;AN000;
	 ENDIFF 		       ;;					;AN000;
      ENDIFF			       ;;					;AN000;
				       ;;					;AN000;
INVALID_DIARESIS:		       ;;					;AN000;
      PUT_ERROR_CHAR DIARESIS_SPACE    ;; standalone accent			;AN000;
      BEEP			       ;; Invalid dead key combo.		;AN000;
      GOTO NON_DEAD		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; GRAVE ACCENT TRANSLATIONS							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
GRAVE_PROC:			       ;;					;AN000;
				       ;;					;AN000;
   IFF GRAVE,NOT		       ;;					;AN000;
      GOTO CIRCUMFLEX_PROC	       ;;					;AN000;
      ENDIFF			       ;;					;AN000;
				       ;;					;AN000;
      RESET_NLS 		       ;;					;AN000;
      IFF R_ALT_SHIFT,NOT	       ;;					;AN000;
	 XLATT GRAVE_SPACE	       ;;					;AN000;
      ENDIFF			       ;;					;AN000;
      IFF EITHER_CTL,NOT	       ;;					;AN000;
      ANDF EITHER_ALT,NOT	       ;;					;AN000;
	IFF EITHER_SHIFT	       ;;					;AN000;
	   IFF CAPS_STATE	       ;;					;AN000;
	      XLATT GRAVE_LOWER        ;;					;AN000;
	   ELSEF		       ;;					;AN000;
	      XLATT GRAVE_UPPER        ;;					;AN000;
	   ENDIFF		       ;;					;AN000;
	ELSEF			       ;;					;AN000;
	   IFF CAPS_STATE,NOT	       ;;					;AN000;
	      XLATT GRAVE_LOWER        ;;					;AN000;
	   ELSEF		       ;;					;AN000;
	      XLATT GRAVE_UPPER        ;;					;AN000;
	   ENDIFF		       ;;					;AN000;
	ENDIFF			       ;;					;AN000;
      ENDIFF			       ;;					;AN000;
				       ;;					;AN000;
INVALID_GRAVE:			       ;;					;AN000;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent			;AN000;
      BEEP			       ;; Invalid dead key combo.		;AN000;
      GOTO NON_DEAD		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; CIRCUMFLEX ACCENT TRANSLATIONS						;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
CIRCUMFLEX_PROC:		       ;;					;AN000;
				       ;;					;AN000;
   IFF CIRCUMFLEX,NOT		       ;;					;AN000;
      GOTO NON_DEAD		       ;;					;AN000;
      ENDIFF			       ;;					;AN000;
				       ;;					;AN000;
      RESET_NLS 		       ;;					;AN000;
      IFF R_ALT_SHIFT,NOT	       ;;					;AN000;
	 XLATT CIRCUMFLEX_SPACE        ;;					;AN000;
      ENDIFF			       ;;					;AN000;
      IFF EITHER_CTL,NOT	       ;;					;AN000;
      ANDF EITHER_ALT,NOT	       ;;					;AN000;
	IFF EITHER_SHIFT	       ;;					;AN000;
	   IFF CAPS_STATE	       ;;					;AN000;
	      XLATT CIRCUMFLEX_LOWER   ;;					;AN000;
	   ELSEF		       ;;					;AN000;
	      XLATT CIRCUMFLEX_UPPER   ;;					;AN000;
	   ENDIFF		       ;;					;AN000;
	ELSEF			       ;;					;AN000;
	   IFF CAPS_STATE,NOT	       ;;					;AN000;
	      XLATT CIRCUMFLEX_LOWER   ;;					;AN000;
	   ELSEF		       ;;					;AN000;
	      XLATT CIRCUMFLEX_UPPER   ;;					;AN000;
	   ENDIFF		       ;;					;AN000;
	ENDIFF			       ;;					;AN000;
      ENDIFF			       ;;					;AN000;
				       ;;					;AN000;
INVALID_CIRCUMFLEX:		       ;;					;AN000;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent			;AN000;
      BEEP			       ;; Invalid dead key combo.		;AN000;
      GOTO NON_DEAD		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; Upper, lower and third shifts						;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
NON_DEAD:			       ;;					;AN000;
				       ;;					;AN000;
   IFKBD G_KB+P12_KB		       ;; Avoid accidentally translating	;AN000;
   ANDF LC_E0			       ;;  the "/" on the numeric pad of the    ;AN000;
      EXIT_STATE_LOGIC		       ;;   G keyboard				;AN000;
   ENDIFF			       ;;					;AN000;
;;***BD ADDED FOR ALT, CTRL CASES      ;;					;AN000;
      IFF EITHER_CTL,NOT	       ;;					;AN000;
	 IFF  ALT_SHIFT 	       ;; ALT - case				;AN000;
	 ANDF R_ALT_SHIFT,NOT	       ;;					;AN000;
	    XLATT ALT_CASE	       ;;					;AN000;
	 ENDIFF 		       ;;					;AN000;
      ELSEF			       ;;					;AN000;
	 IFF EITHER_ALT,NOT	       ;; CTRL - case				;AN000;
	    XLATT CTRL_CASE	       ;;					;AN000;
	 ENDIFF 		       ;;					;AN000;
      ENDIFF			       ;;					;AN000;
;;***BD END OF ADDITION 							;AN000;
				       ;;					;AN000;
   IFF	EITHER_ALT,NOT		       ;; Lower and upper case.  Alphabetic	;AN000;
   ANDF EITHER_CTL,NOT		       ;; keys are affected by CAPS LOCK.	;AN000;
      IFF EITHER_SHIFT		       ;; Numeric keys are not. 		;AN000;
;;***BD ADDED FOR NUMERIC PAD							;AN000;
	  IFF NUM_STATE,NOT	       ;;					;AN000;
	      XLATT NUMERIC_PAD        ;;					;AN000;
	  ENDIFF		       ;;					;AN000;
;;***BD END OF ADDITION 							;AN000;
	  XLATT NON_ALPHA_UPPER        ;;					;AN000;
	  IFF CAPS_STATE	       ;;					;AN000;
	      XLATT ALPHA_LOWER        ;;					;AN000;
	  ELSEF 		       ;;					;AN000;
	      XLATT ALPHA_UPPER        ;;					;AN000;
	  ENDIFF		       ;;					;AN000;
      ELSEF			       ;;					;AN000;
;;***BD ADDED FOR NUMERIC PAD							;AN000;
	  IFF NUM_STATE 	       ;;					;AN000;
	      XLATT NUMERIC_PAD        ;;					;AN000;
	  ENDIFF		       ;;					;AN000;
;;***BD END OF ADDITION 							;AN000;
	  XLATT NON_ALPHA_LOWER        ;;					;AN000;
	  IFF CAPS_STATE	       ;;					;AN000;
	     XLATT ALPHA_UPPER	       ;;					;AN000;
	  ELSEF 		       ;;					;AN000;
	     XLATT ALPHA_LOWER	       ;;					;AN000;
	  ENDIFF		       ;;					;AN000;
      ENDIFF			       ;;					;AN000;
   ELSEF			       ;;					;AN000;
      IFF EITHER_SHIFT,NOT	       ;;					;AN000;
	  IFKBD XT_KB+AT_KB	 ;;						;AN000;
	      IFF  EITHER_CTL	       ;;					;AN000;
	      ANDF ALT_SHIFT	       ;;					;AN000;
		  XLATT THIRD_SHIFT    ;;					;AN000;
	      ENDIFF		       ;;					;AN000;
	  ELSEF 		       ;;					;AN000;
	      IFF EITHER_CTL,NOT       ;;					;AN000;
	      ANDF R_ALT_SHIFT	       ;;					;AN000;
		  XLATT THIRD_SHIFT    ;;					;AN000;
	      ENDIFF		       ;;					;AN000;
	   ENDIFF		       ;;					;AN000;
      ENDIFF			       ;;					;AN000;
   ENDIFF			       ;;					;AN000;
				       ;;					;AN000;
   EXIT_STATE_LOGIC		       ;;					;AN000;
				       ;;					;AN000;
LOGIC_END:			       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;***************************************					;AN000;
;; UK Common Translate Section							;AN000;
;; This section contains translations for the lower 128 characters		;AN000;
;; only since these will never change from code page to code page.		;AN000;
;; In addition the dead key "Set Flag" tables are here since the                ;AN000;
;; dead keys are on the same keytops for all code pages.			;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
 PUBLIC UK1_COMMON_XLAT 		;;					;AN000;
UK1_COMMON_XLAT:			;;					;AN000;
				       ;;					;AN000;
   DW	 COMMON_XLAT_END-$	       ;; length of section			;AN000;
   DW	 -1			       ;; code page				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;***************************************					;AN000;
;;***BD - ADDED FOR ALT CASE							;AN000;
;;******************************						;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; CODE PAGE: Common								;AN000;
;; STATE: Alt Case								;AN000;
;; KEYBOARD TYPES: All								;AN000;
;; TABLE TYPE: Translate							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   DW	 COM_ALT_K2_END-$	       ;; length of state section		;AN000;
   DB	 ALT_CASE		       ;; State ID				;AN000;
   DW	 ANY_KB 		       ;; Keyboard Type 			;AN000;
   DB	 -1,-1			       ;; Buffer entry for error character	;AN000;
				       ;;					;AN000;
   DW	 COM_ALT_K2_T1_END-$	       ;; Size of xlat table			;AN000;
   DB	 TYPE_2_TAB		       ;; xlat options: 			;AN000;
   DB	 0			       ;; number of entries			;AN000;
;;***BD THIS ENTRY IS A TEST ENTRY						;AN000;
;; DB	 53,225,0		       ;; TEST ENTRY				;AN000;
COM_ALT_K2_T1_END:		       ;;					;AN000;
				       ;;					;AN000;
   DW	 0			       ;; Size of xlat table - null table	;AN000;
				       ;;					;AN000;
COM_ALT_K2_END: 		       ;;					;AN000;
				       ;;					;AN000;
;;******************************						;AN000;
;;***BD - ADDED FOR CTRL CASE							;AN000;
;;******************************						;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; CODE PAGE: Common								;AN000;
;; STATE: Ctrl Case								;AN000;
;; KEYBOARD TYPES: G_KB+P12+AT							;AN000;
;; TABLE TYPE: Translate							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   DW	 COM_CTRL_K2_END-$	       ;; length of state section		;AN000;
   DB	 CTRL_CASE		       ;; State ID				;AN000;
   DW	 G_KB+P12_KB+AT_KB	       ;; Keyboard Type 			;AN000;
   DB	 -1,-1			       ;; Buffer entry for error character	;AN000;
				       ;;					;AN000;
   DW	 COM_CTRL_K2_T1_END-$	       ;; Size of xlat table			;AN000;
   DB	 TYPE_2_TAB		       ;; xlat options: 			;AN000;
   DB	 2			       ;; number of entries			;AN000;
;;***BD THIS ENTRY IS A TEST ENTRY						;AN000;
;; DB	 53,226,0		       ;; TEST ENTRY				;AN000;
   DB	 43,-1,-1		       ;; invalid slash 			;AN000;
   DB	 41,28,41		       ;; valid slash				;AN000;
COM_CTRL_K2_T1_END:		       ;;					;AN000;
				       ;;					;AN000;
   DW	 0			       ;; Size of xlat table - null table	;AN000;
				       ;;					;AN000;
COM_CTRL_K2_END:		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; CODE PAGE: Common								;AN000;
;; STATE: Non-Alpha Lower Case							;AN000;
;; KEYBOARD TYPES: G_KB 							;AN000;
;; TABLE TYPE: Translate							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   DW	 COM_NA_LO_K1_END-$		  ;; length of state section		;AN000;
   DB	 NON_ALPHA_LOWER	       ;; State ID				;AN000;
   DW	 G_KB			       ;; Keyboard Type 			;AN000;
   DB	 -1,-1			       ;; Buffer entry for error character	;AN000;
				       ;;					;AN000;
   DW	 COM_NA_LO_K1_T1_END-$		  ;; Size of xlat table 		;AN000;
   DB	 STANDARD_TABLE 	       ;; xlat options: 			;AN000;
   DB	 6			       ;; number of entries			;AN000;
   DB	 13,""                        ;;                                       ;AN000;
   DB	 26,"@"                        ;; '                                     ;AN000;
   DB	 27,"["                        ;; '                                     ;AN000;
   DB	 40,":"                        ;; '                                     ;AN000;
   DB	 41,"\"                        ;; '                                     ;AN000;
   DB	 43,']'                        ;; #                                     ;AN000;
COM_NA_LO_K1_T1_END:		       ;;					;AN000;
				       ;;					;AN000;
   DW	 0			       ;; Size of xlat table - null table	;AN000;
				       ;;					;AN000;
COM_NA_LO_K1_END:		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; CODE PAGE: Common								;AN000;
;; STATE: Non-Alpha Lower Case							;AN000;
;; KEYBOARD TYPES: P12_KB							;AN000;
;; TABLE TYPE: Translate							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   DW	 COM_NA_LO_PK1_END-$		   ;; length of state section		;AN000;
   DB	 NON_ALPHA_LOWER	       ;; State ID				;AN000;
   DW	 P12_KB 		       ;; Keyboard Type 			;AN000;
   DB	 -1,-1			       ;; Buffer entry for error character	;AN000;
				       ;;					;AN000;
   DW	 COM_NA_LO_PK1_T1_END-$ 	   ;; Size of xlat table		;AN000;
   DB	 STANDARD_TABLE 	       ;; xlat options: 			;AN000;
   DB	 2			       ;; number of entries			;AN000;
   DB	 40,"'"                        ;; '                                     ;AN000;
   DB	 43,'#'                        ;; #                                     ;AN000;
COM_NA_LO_PK1_T1_END:			   ;;					;AN000;
				       ;;					;AN000;
   DW	 0			       ;; Size of xlat table - null table	;AN000;
				       ;;					;AN000;
COM_NA_LO_PK1_END:			   ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; CODE PAGE: Common								;AN000;
;; STATE: Non-Alpha Lower Case							;AN000;
;; KEYBOARD TYPES: AT								;AN000;
;; TABLE TYPE: Translate							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   DW	 COM_NA_LO_K2_END-$		  ;; length of state section		;AN000;
   DB	 NON_ALPHA_LOWER	       ;; State ID				;AN000;
   DW	 AT_KB			      ;; Keyboard Type				;AN000;
   DB	 -1,-1			       ;; Buffer entry for error character	;AN000;
				       ;;					;AN000;
   DW	 COM_NA_LO_K2_T1_END-$		  ;; Size of xlat table 		;AN000;
   DB	 STANDARD_TABLE 	       ;; xlat options: 			;AN000;
   DB	 3			       ;; number of entries			;AN000;
   DB	 41,"\"                        ;; \                                     ;AN000;
   DB	 40,"'"                        ;; '                                     ;AN000;
   DB	 43,'#'                        ;; #                                     ;AN000;
COM_NA_LO_K2_T1_END:			  ;;					;AN000;
				       ;;					;AN000;
   DW	 0			       ;; Size of xlat table - null table	;AN000;
				       ;;					;AN000;
COM_NA_LO_K2_END:			  ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; CODE PAGE: Common								;AN000;
;; STATE: Non-Alpha Lower Case							;AN000;
;; KEYBOARD TYPES: XT_KB							;AN000;
;; TABLE TYPE: Translate							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   DW	 COM_NA_LO_K3_END-$		  ;; length of state section		;AN000;
   DB	 NON_ALPHA_LOWER	       ;; State ID				;AN000;
   DW	 XT_KB			 ;; Keyboard Type				;AN000;
   DB	 -1,-1			       ;; Buffer entry for error character	;AN000;
				       ;;					;AN000;
   DW	 COM_NA_LO_K3_T1_END-$		  ;; Size of xlat table 		;AN000;
   DB	 STANDARD_TABLE 	       ;; xlat options: 			;AN000;
   DB	 2			       ;; number of entries			;AN000;
   DB	 40,"'"                        ;; '                                     ;AN000;
   DB	 41,'#'                        ;; #                                     ;AN000;
   DB	 43,'\'                        ;; #                                     ;AN000;
COM_NA_LO_K3_T1_END:			  ;;					;AN000;
				       ;;					;AN000;
   DW	 0			       ;; Size of xlat table - null table	;AN000;
				       ;;					;AN000;
COM_NA_LO_K3_END:			  ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; CODE PAGE: Common								;AN000;
;; STATE: Non-Alpha Upper Case							;AN000;
;; KEYBOARD TYPES: G_KB+P							;AN000;
;; TABLE TYPE: Translate							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   DW	 COM_NA_UP_K1_END-$		  ;; length of state section		;AN000;
   DB	 NON_ALPHA_UPPER	       ;; State ID				;AN000;
   DW	 G_KB			       ;; Keyboard Type 			;AN000;
   DB	 -1,-1			       ;; Buffer entry for error character	;AN000;
				       ;;					;AN000;
   DW	 COM_NA_UP_T1_K1_END-$		  ;; Size of xlat table 		;AN000;
   DB	 STANDARD_TABLE 	       ;; xlat options: 			;AN000;
   DB	 14			       ;; number of entries			;AN000;
   DB	 3,'"'                         ;;                                       ;AN000;
   DB	 4,""                         ;;                                       ;AN000;
   DB	 7,"&"                         ;;                                       ;AN000;
   DB	 8,"'"                         ;;                                       ;AN000;
   DB	 9,"("                         ;;                                       ;AN000;
   DB	 10,")"                        ;;                                       ;AN000;
   DB	 11,"#"                        ;;                                       ;AN000;
   DB	 12,"="                        ;;                                       ;AN000;
   DB	 26,"`"                        ;;                                       ;AN000;
   DB	 27,"{"                        ;;                                       ;AN000;
   DB	 39,"+"                        ;;                                       ;AN000;
   DB	 40,"*"                        ;;                                       ;AN000;
   DB	 43,"}"                        ;;                                       ;AN000;
   DB	 86,"_"                       ;;                                        ;AN000;
COM_NA_UP_T1_K1_END:			  ;;					;AN000;
				       ;;					;AN000;
   DW	 0			       ;; Size of xlat table - null table	;AN000;
				       ;;					;AN000;
COM_NA_UP_K1_END:			  ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; CODE PAGE: Common								;AN000;
;; STATE: Non-Alpha Upper Case							;AN000;
;; KEYBOARD TYPES: P12_KB							;AN000;
;; TABLE TYPE: Translate							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   DW	 COM_NA_UP_PK1_END-$		   ;; length of state section		;AN000;
   DB	 NON_ALPHA_UPPER	       ;; State ID				;AN000;
   DW	 P12_KB 		       ;; Keyboard Type 			;AN000;
   DB	 -1,-1			       ;; Buffer entry for error character	;AN000;
				       ;;					;AN000;
   DW	 COM_NA_UP_T1_PK1_END-$ 	   ;; Size of xlat table		;AN000;
   DB	 STANDARD_TABLE 	       ;; xlat options: 			;AN000;
   DB	 5			       ;; number of entries			;AN000;
   DB	 41,0AAh		       ;; 					;AN000;
   DB	 3,'"'                         ;; "                                     ;AN000;
   DB	 4,09CH 		       ;; 					;AN000;
   DB	 40,'@'                        ;; at sign                               ;AN000;
   DB	 43,07EH		       ;; ~					;AN000;
COM_NA_UP_T1_PK1_END:			   ;;					;AN000;
				       ;;					;AN000;
   DW	 0			       ;; Size of xlat table - null table	;AN000;
				       ;;					;AN000;
COM_NA_UP_PK1_END:			   ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; CODE PAGE: Common								;AN000;
;; STATE: Non-Alpha Upper Case							;AN000;
;; KEYBOARD TYPES: XT_KB							;AN000;
;; TABLE TYPE: Translate							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   DW	 COM_NA_UP_K2_END-$		  ;; length of state section		;AN000;
   DB	 NON_ALPHA_UPPER	       ;; State ID				;AN000;
   DW	 XT_KB			 ;; Keyboard Type				;AN000;
   DB	 -1,-1			       ;; Buffer entry for error character	;AN000;
				       ;;					;AN000;
   DW	 COM_NA_UP_T1_K2_END-$		  ;; Size of xlat table 		;AN000;
   DB	 STANDARD_TABLE 	       ;; xlat options: 			;AN000;
   DB	 5			       ;; number of entries			;AN000;
   DB	 3,'"'                         ;; "                                     ;AN000;
   DB	 4,09CH 		       ;; 					;AN000;
   DB	 41,07EH		       ;; ~					;AN000;
   DB	 40,'@'                        ;; at sign                               ;AN000;
   DB	 43,07CH		       ;; Broken vertical bar			;AN000;
COM_NA_UP_T1_K2_END:			  ;;					;AN000;
				       ;;					;AN000;
   DW	 0			       ;; Size of xlat table - null table	;AN000;
				       ;;					;AN000;
COM_NA_UP_K2_END:			  ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; CODE PAGE: Common								;AN000;
;; STATE: Non-Alpha Upper Case							;AN000;
;; KEYBOARD TYPES: AT_KB							;AN000;
;; TABLE TYPE: Translate							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   DW	 COM_NA_UP_K3_END-$		  ;; length of state section		;AN000;
   DB	 NON_ALPHA_UPPER	       ;; State ID				;AN000;
   DW	 AT_KB			       ;; Keyboard Type 			;AN000;
   DB	 -1,-1			       ;; Buffer entry for error character	;AN000;
				       ;;					;AN000;
   DW	 COM_NA_UP_T1_K3_END-$		  ;; Size of xlat table 		;AN000;
   DB	 STANDARD_TABLE 	       ;; xlat options: 			;AN000;
   DB	 5			       ;; number of entries			;AN000;
   DB	 41,07Ch		       ;; 					;AN000;
   DB	 3,'"'                         ;; "                                     ;AN000;
   DB	 4,09CH 		       ;; 					;AN000;
   DB	 40,'@'                        ;; at sign                               ;AN000;
   DB	 43,07EH		       ;; ~					;AN000;
COM_NA_UP_T1_K3_END:			  ;;					;AN000;
				       ;;					;AN000;
   DW	 0			       ;; Size of xlat table - null table	;AN000;
				       ;;					;AN000;
COM_NA_UP_K3_END:			  ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; CODE PAGE: COMMON								;AN000;
;; STATE: Third Shift								;AN000;
;; KEYBOARD TYPES: G_KB+P							;AN000;
;; TABLE TYPE: Translate							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   DW	 COM_THIRD_K1_END-$	       ;; length of state section		;AN000;
   DB	 THIRD_SHIFT		       ;; State ID				;AN000;
   DW	 G_KB			       ;; Keyboard Type 			;AN000;
   DB	 -1,-1			       ;; Buffer entry for error character	;AN000;
				       ;;					;AN000;
   DW	 COM_THIRD_K1_T1_END-$		  ;; Size of xlat table 		;AN000;
   DB	 STANDARD_TABLE 	       ;; xlat options: 			;AN000;
   DB	 8			       ;; number of entries			;AN000;
   DB	 3,0FDH 		      ;; SUPERSCRPIT 2				;AN000;
   DB	 4,0FCH 		      ;; SUPERSCRIPT 3				;AN000;
   DB	 6,0ABH 		      ;; ONE HALF SYMBOL			;AN000;
   DB	10,0F1H 		      ;; PLUS OR MINUS SYMBOL			;AN000;
   DB	11,0F8H 		      ;; DEGREE SYMBOL				;AN000;
   DB	27,07EH 		      ;; TILDE					;AN000;
   DB	40,05EH 		      ;; CIRCUMFLEX CARAT			;AN000;
   DB	50,0E6H 		      ;; MU					;AN000;
COM_THIRD_K1_T1_END:			  ;;					;AN000;
				       ;;					;AN000;
   DW	 0			       ;; Last xlat table			;AN000;
COM_THIRD_K1_END:		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   DW	 0			       ;; Last State				;AN000;
COMMON_XLAT_END:		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;***************************************					;AN000;
;; UK Specific Translate Section for 437					;AN000;
;; 437 IS COMPLETELY COVERED BY THE COMMON TABLE except for vertical bars	;AN000;
;;***************************************					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
 PUBLIC UK1_437_XLAT			;;					;AN000;
UK1_437_XLAT:				;;					;AN000;
				       ;;					;AN000;
   DW	  CP437_XLAT_END-$	       ;; length of section			;AN000;
   DW	  437			       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; CODE PAGE: CP437								;AN000;
;; STATE: Third Shift								;AN000;
;; KEYBOARD TYPES: P12_KB							;AN000;
;; TABLE TYPE: Translate							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
					 ;;					;AN000;
     DW    CP437_THIRD_PK1_END-$	    ;; length of state section		;AN000;
     DB    THIRD_SHIFT			 ;; State ID				;AN000;
     DW    P12_KB			 ;; Keyboard Type			;AN000;
     DB    -1,-1			 ;; Buffer entry for error character	;AN000;
					 ;;					;AN000;
     DW    CP437_THIRD_PK1_T1_END-$	       ;; Size of xlat table		;AN000;
     DB    STANDARD_TABLE		 ;; xlat options:			;AN000;
     DB    1				 ;; number of entries			;AN000;
     DB    41,0DDH			 ;; Solid vertical bar - graphics block ;AN000;
  CP437_THIRD_PK1_T1_END:		       ;;				;AN000;
					 ;;					;AN000;
     DW    0				 ;; Last xlat table			;AN000;
  CP437_THIRD_PK1_END:			      ;;				;AN000;
					 ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; CODE PAGE: CP437								;AN000;
;; STATE: Non-Alpha Upper Case							;AN000;
;; KEYBOARD TYPES: G_KB 							;AN000;
;; TABLE TYPE: Translate							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   DW	 CP437_NA_UP_K1_END-$		    ;; length of state section		;AN000;
   DB	 NON_ALPHA_UPPER	       ;; State ID				;AN000;
   DW	 G_KB			       ;; Keyboard Type 			;AN000;
   DB	 -1,-1			       ;; Buffer entry for error character	;AN000;
				       ;;					;AN000;
   DW	 CP437_NA_UP_T1_K1_END-$	    ;; Size of xlat table		;AN000;
   DB	 STANDARD_TABLE 	       ;; xlat options: 			;AN000;
   DB	 2			       ;; number of entries			;AN000;
   DB	 41,0DDh		       ;; GRAPHICS vertical bar 		;AN000;
   DB	 13,""                        ;; may change current codepoint = 192(c4);AN000;
CP437_NA_UP_T1_K1_END:			    ;;					;AN000;
				       ;;					;AN000;
   DW	 0			       ;; Size of xlat table - null table	;AN000;
				       ;;					;AN000;
CP437_NA_UP_K1_END:			    ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; CODE PAGE: CP437								;AN000;
;; STATE: Non-Alpha Upper Case							;AN000;
;; KEYBOARD TYPES: P12_KB							;AN000;
;; TABLE TYPE: Translate							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   DW	 CP437_NA_UP_PK1_END-$		     ;; length of state section 	;AN000;
   DB	 NON_ALPHA_UPPER	       ;; State ID				;AN000;
   DW	 P12_KB 		       ;; Keyboard Type 			;AN000;
   DB	 -1,-1			       ;; Buffer entry for error character	;AN000;
				       ;;					;AN000;
   DW	 CP437_NA_UP_PT1_K1_END-$	     ;; Size of xlat table		;AN000;
   DB	 STANDARD_TABLE 	       ;; xlat options: 			;AN000;
   DB	 1			       ;; number of entries			;AN000;
   DB	 86,07ch		       ;; vertical bar				;AN000;
CP437_NA_UP_PT1_K1_END: 		     ;; 				;AN000;
				       ;;					;AN000;
   DW	 0			       ;; Size of xlat table - null table	;AN000;
				       ;;					;AN000;
CP437_NA_UP_PK1_END:			     ;; 				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; CODE PAGE: CP437								;AN000;
;; STATE: Non-Alpha LOWER Case							;AN000;
;; KEYBOARD TYPES: G_KB 							;AN000;
;; TABLE TYPE: Translate							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   DW	 CP437_NA_LO_K1_END-$		    ;; length of state section		;AN000;
   DB	 NON_ALPHA_LOWER	       ;; State ID				;AN000;
   DW	 G_KB			       ;; Keyboard Type 			;AN000;
   DB	 -1,-1			       ;; Buffer entry for error character	;AN000;
				       ;;					;AN000;
   DW	 CP437_NA_LO_T1_K1_END-$	    ;; Size of xlat table		;AN000;
   DB	 STANDARD_TABLE 	       ;; xlat options: 			;AN000;
   DB	 1			       ;; number of entries			;AN000;
   DB	 86,07Ch		       ;; SOLID(PIPING)VERTICAL bar		;AN000;
CP437_NA_LO_T1_K1_END:		       ;;					;AN000;
				       ;;					;AN000;
   DW	 0			       ;; Size of xlat table - null table	;AN000;
				       ;;					;AN000;
CP437_NA_LO_K1_END:		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
   DW	  0			       ;; LAST STATE				;AN000;
				       ;;					;AN000;
CP437_XLAT_END: 		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;***************************************					;AN000;
;; UK Specific Translate Section for 850					;AN000;
;;***************************************					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
 PUBLIC UK1_850_XLAT			;;					;AN000;
UK1_850_XLAT:				;;					;AN000;
				       ;;					;AN000;
   DW	  CP850_XLAT_END-$	       ;; length of section			;AN000;
   DW	  850			       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; CODE PAGE: CP850								;AN000;
;; STATE: Third Shift								;AN000;
;; KEYBOARD TYPES: P12_KB							;AN000;
;; TABLE TYPE: Translate							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
					 ;;					;AN000;
     DW    CP850_THIRD_PK1_END-$	    ;; length of state section		;AN000;
     DB    THIRD_SHIFT			 ;; State ID				;AN000;
     DW    P12_KB			 ;; Keyboard Type			;AN000;
     DB    -1,-1			 ;; Buffer entry for error character	;AN000;
					 ;;					;AN000;
     DW    CP850_THIRD_PK1_T1_END-$	       ;; Size of xlat table		;AN000;
     DB    STANDARD_TABLE		 ;; xlat options:			;AN000;
     DB    1				 ;; number of entries			;AN000;
     DB    41,07CH			 ;; Solid vertical bar - |		;AN000;
  CP850_THIRD_PK1_T1_END:		       ;;				;AN000;
					 ;;					;AN000;
     DW    0				 ;; Last xlat table			;AN000;
  CP850_THIRD_PK1_END:			       ;;				;AN000;
					 ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; CODE PAGE: Common								;AN000;
;; STATE: Non-Alpha Upper Case							;AN000;
;; KEYBOARD TYPES: G_KB 							;AN000;
;; TABLE TYPE: Translate							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   DW	 CP850_NA_UP_K1_END-$		    ;; length of state section		;AN000;
   DB	 NON_ALPHA_UPPER	       ;; State ID				;AN000;
   DW	 G_KB			       ;; Keyboard Type 			;AN000;
   DB	 -1,-1			       ;; Buffer entry for error character	;AN000;
				       ;;					;AN000;
   DW	 CP850_NA_UP_T1_K1_END-$	    ;; Size of xlat table		;AN000;
   DB	 STANDARD_TABLE 	       ;; xlat options: 			;AN000;
   DB	 2			       ;; number of entries			;AN000;
   DB	 41,07Ch		       ;; SOLID vertical (PIPING)		;AN000;
   DB	 13,0EEH		       ;; OVERSCORE SYMBOL			;AN000;
CP850_NA_UP_T1_K1_END:			    ;;					;AN000;
				       ;;					;AN000;
   DW	 0			       ;; Size of xlat table - null table	;AN000;
				       ;;					;AN000;
CP850_NA_UP_K1_END:			    ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; CODE PAGE: Common								;AN000;
;; STATE: Non-Alpha Upper Case							;AN000;
;; KEYBOARD TYPES: P12_KB							;AN000;
;; TABLE TYPE: Translate							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   DW	 CP850_NA_UP_PK1_END-$		     ;; length of state section 	;AN000;
   DB	 NON_ALPHA_UPPER	       ;; State ID				;AN000;
   DW	 P12_KB 		       ;; Keyboard Type 			;AN000;
   DB	 -1,-1			       ;; Buffer entry for error character	;AN000;
				       ;;					;AN000;
   DW	 CP850_NA_UP_T1_PK1_END-$	     ;; Size of xlat table		;AN000;
   DB	 STANDARD_TABLE 	       ;; xlat options: 			;AN000;
   DB	 1			       ;; number of entries			;AN000;
   DB	 86,0DDh		       ;; broken vertical			;AN000;
CP850_NA_UP_T1_PK1_END: 		     ;; 				;AN000;
				       ;;					;AN000;
   DW	 0			       ;; Size of xlat table - null table	;AN000;
				       ;;					;AN000;
CP850_NA_UP_PK1_END:			     ;; 				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; CODE PAGE: Common								;AN000;
;; STATE: Non-Alpha LOWER Case							;AN000;
;; KEYBOARD TYPES: G_KB 							;AN000;
;; TABLE TYPE: Translate							;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   DW	 CP850_NA_LO_K1_END-$		    ;; length of state section		;AN000;
   DB	 NON_ALPHA_LOWER	       ;; State ID				;AN000;
   DW	 G_KB			       ;; Keyboard Type 			;AN000;
   DB	 -1,-1			       ;; Buffer entry for error character	;AN000;
				       ;;					;AN000;
   DW	 CP850_NA_LO_T1_K1_END-$	    ;; Size of xlat table		;AN000;
   DB	 STANDARD_TABLE 	       ;; xlat options: 			;AN000;
   DB	 1			       ;; number of entries			;AN000;
   DB	 86,0DDh		       ;; broken vertical			;AN000;
CP850_NA_LO_T1_K1_END:			    ;;					;AN000;
				       ;;					;AN000;
   DW	 0			       ;; Size of xlat table - null table	;AN000;
				       ;;					;AN000;
CP850_NA_LO_K1_END:			    ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
   DW	 0			       ;; LAST STATE				;AN000;
				       ;;					;AN000;
CP850_XLAT_END: 		       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
CODE	 ENDS			       ;;					;AN000;
	 END			       ;;					;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\kkcfunc\kkcfunc.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
; device driver headder
;
CHAR_DEV	equ	1000000000000000b

;
; device driver commands
;
DEV_INIT	equ	0
DEV_REST	equ	20

;
; device driver error
;
DEV_INVALID	equ	3

DEV_ERROR	equ	10000000b
DEV_DONE	equ	00000001b

;
; device driver request headder
;
request		struc
req_len		db	?
unit		db	?
command		db	?
status		dw	?
reserve		db	8 dup (?)
count		db	?
break_adrs	dd	?
bpb_adrs	dd	?
dev_num		db	?
request		ends

;
; KKCFUNC return code
;
SUCCESS		equ	0

OVER_ERR	equ	-1
HANDLE_ERR	equ	-2

;
; dos function call definition
;
BUSY		equ	1
NOT_BUSY	equ	0

ERR		equ	-1

MAX_KKC_NUM	equ	16

DOS_SEG		equ	70h
DOS_SAVE_ST	equ	564h
DOS_SAVE_END	equ	920h
DOS_SAVE_LEN	equ	DOS_SAVE_END - DOS_SAVE_ST + 1

;
; dos function call error code
;
INVALID_FUNC	equ	1
FUNC_BUSY	equ	2
CRITICAL_ERR	equ	3


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kbd2\keybshar.inc ===
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1991
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBSHAR.INC
;; ----------
;;
;; Description:
;; ------------
;;	 Include file containing structure definitions Shared Data Area
;;	 for the Shared Data Area.
;;	 The Shared Data Area contains data which is required by
;;	 both the resident and transient KEYB code.  The Shared
;;	 Data Area is allocated in the KEYBI2F file and will be
;;	 resident following initial installation.
;;
;; Change History:
;; ---------------
;;
;; ;jwg  ; - Feb 1990 For 4.03.
;; ;AN007; -	       Add Patriot/Sebring determination code for HOT Replug
;;			so that INT 9 handler can alter keyboard Scan Code set.
;; ;M030		Merged IBM (Kermit - JP), KEYBOARD.SYS and KEYB.COM
;;			  versions of this file into one.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SHARED_DATA_STR defines the initial fixed length portion of the
;; Shared Data Area.
;; Tables are loaded beginning at TABLE_AREA in the following order:
;;  State Logic
;;  Common Translate Section
;;  Specific Translate Sections for
;;   each code page
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; SPECIAL_FEATURES equates:
TYPEWRITER_CAPS_LK  EQU    8000H	;; typewriter style caps lock
					;;
JR_HOT_KEY_1_2	equ	4000h		;; M030 Merged back for kdfcf.asm
;;========================================
;; Added for French Canadian Dual Mode
;; 3/16/93
;;========================================
SHIFTS_TO_LOGIC     EQU    2000H       ;; - transfer CTRL, SHIFT, ALT keys
                                       ;;   to LOGIC section
                                       ;;
SWITCHABLE          EQU    1000H       ;; - Driver can use NLS/Def mode
                                       ;;   switching (like Rus/Lat mode)
                                       ;;   Used for Int 2Fh, function 0AD83h answer
;;========================================
;; End of modifications for Fr-Can
;;========================================
JR_KB		equ	8000h		;; M030 Merged back for kdfcf.asm
					;; Some useful scan codes:
F1_SCAN     EQU   59			;; F1
F2_SCAN     EQU   60			;; F2
					;;
					;;	SYSTEM_FLAG / Hardware equates:
					;;   INT 16h and remote support
EXT_16		EQU	8000H		;; extended INT 16h support is there
EXT_122 	EQU	4000H		;; extended INT 16h for 122 is there
;		EQU	2000H		;;  unused
PC_NET		EQU	1000H		;; flag PC Net is installed
					;;   System type/hardware support flags
PC_81		EQU	0800H		;; flag for Original PC
PC_XT		EQU	0400H		;; code for PC, PC/XT, PORTABLE
PC_LAP		EQU	0200H		;; code for Convertiable (p-12)
PC_PAL		EQU	0080H		;; code for Model 30 (PALACE)
PC_AT		EQU	0040H		;; code for PC-AT  with 8042
PC_386		EQU	0020H		;; code for PS/2's with 8042 (WRANGLER)
PS_8042 	EQU	0010H		;; 8042 is a Patriot/Sebring type array;AN007;jwg
					;;  or system set translate OFF (SCS=01)
SECURITY_ACTIVE	EQU	0008h	; M030	;; Server password mode is active
;				; M030	;;  This bit becomes off from on when
;				; M030	;;  correct password is entered JP9010
					;;
					;; HOT_KEY_FLAG EQUATES:
US_MODE     EQU   0			;;  hot key is active => US
LANG_MODE   EQU   0FFH			;;  hot key is inactive
					;;
					;; -----------------------------------
SHARED_DATA_STR     STRUC		;; SHARED DATA AREA
					;;
OLD_INT_9	    DD	  0		;; saved int 9 vector
OLD_INT_2F	    DD	  0		;; saved int 2F vector
		    dd    0		;; reserved
KEYB_TYPE	    DW	  0		;; type of keyboard
SYSTEM_FLAG	    DW	  0		;; system configuration flags
TABLE_OK	    DB	  0		;; flag to INT 9 that table is built
		    db    5 dup (0)	;; reserved
					;;
					;; Table copy begins here:
ACTIVE_LANGUAGE     DB	  'US'          ;; language code
INVOKED_CP_TABLE    DW	  437		;; ptr to table for invoked code page
INVOKED_KBD_ID	    DW	  0		;; WGR invoked keyboard id.	       ;AN000
ACTIVE_XLAT_PTR     DW	  -1		;; ptr to active Specific Translate Sect
FIRST_XLAT_PTR	    DW	  -1		;; ptr to first Specific Translate Sect
RESIDENT_END	    DW	  0ffffh	;; offset of last byte in resident mem
LOGIC_PTR	    DW	  -1		;; ptr to State Logic
COMMON_XLAT_PTR     DW	  -1		;; ptr to Common Translate Section
SPECIAL_FEATURES    DW	  ?		;; special Features
TABLE_OVERFLOW	    DB	  0		;; overflow flag for table rebuild
HOT_KEY_ON_SCAN     DB	  ?		;; scan codes to use with ALT+CTRL
HOT_KEY_OFF_SCAN    DB	  ?		;;  to turn hot key on and off
		    DB	  4 DUP(0)	;; reserved
TABLE_AREA	    DB	  ?		;; tables loaded here:
					;;  State Logic
					;;  Common Translate Section
					;;  Specific Translate Sections for
					;;   each code page
SHARED_DATA_STR     ENDS		;;
					;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State Logic equates.
;; Contains equates for our NLS Flags and for the State Logic
;; commands.
;; State Logic command macros are defined in KEYBMAC.INC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
STATE_LOGIC_STR STRUC			;;
					;;
SL_LOGIC_LEN	DW   ?			;; length of state logic
SL_SPECIAL_FEATURES   DW   ?		;;
SL_LOGIC_CMDS	DB   0			;; state logic commands begin here
					;;
STATE_LOGIC_STR ENDS			;;
					;;
					;;
NUM_BIOS_FLAGS	    EQU   4		;;
NUM_NLS_FLAGS	    EQU   2		;; '+1' below is the EXT_KB_FLAG
NUM_FLAGS	    EQU   NUM_BIOS_FLAGS+NUM_NLS_FLAGS+1
					;;
					;;
EITHER_SHIFT	    EQU   80H		;; EXT_KB_FLAG : our own shift state
EITHER_CTL	    EQU   40H		;;  flags
EITHER_ALT	    EQU   20H		;;
SCAN_MATCH	    EQU   08H		;; set if scan code found in XLATT
					;; or SET_FLAG searches
                                        ;;
SHIFTS_PRESSED      EQU   04H           ;; set if any SHIFT, ALT, CTRL key
                                        ;; pressed (used in Frn-Can kdf)
					;;					;;
KB_FLAG_ID	    EQU   0		;; Flag ID's as coded in IFF and ANDF
KB_FLAG_1_ID	    EQU   1		;;  commands
KB_FLAG_2_ID	    EQU   2		;;
KB_FLAG_3_ID	    EQU   3		;;
EXT_KB_FLAG_ID	    EQU   4		;;
NLS_FLAG_1_ID	    EQU   5		;;
NLS_FLAG_2_ID	    EQU   6		;;
					;;
COMMAND_BITS	    EQU   0F0H		;; Mask to isolate command code
SUB_CMD_BITS	    EQU   0FH		;; mask to isolate sub command code
NOT_TEST	    EQU   08H		;; NOT bit in IFF, ANDF
COMMAND_SHIFT	    EQU   4		;; shift amount for command code
FLAG_ID_BITS	    EQU   07H		;; mask to isolate flag id in IFF, ANDF
NUM_COMMANDS	    EQU   0CH		;; number of commands
					;;
IFF_COMMAND	    EQU   00H		;;
ANDF_COMMAND	    EQU   10H		;;
ELSEF_COMMAND	    EQU   20H		;;
ENDIFF_COMMAND	    EQU   30H		;;
XLATT_COMMAND	    EQU   40H		;;
OPTION_COMMAND	    EQU   50H		;;
SET_FLAG_COMMAND    EQU   60H		;;
PUT_ERROR_COMMAND   EQU   70H		;;
IFKBD_COMMAND	    EQU   80H		;;
GOTO_COMMAND	    EQU   90H		;;
BEEP_COMMAND	    EQU   0A0H		;;
RESET_NLS_COMMAND   EQU   0B0H		;;
RESET_NLS1_COMMAND  EQU   0C0H          ;; FRN-CAN to toggle keyb state for dead keys
CHECK_CORE_COMMAND  EQU   0C0H		;;
					;;
					;;
EXIT_INT_9_FLAG 	EQU  01H	;; Special forms of GOTO.  These
EXIT_STATE_LOGIC_FLAG	EQU  02H	;;  values are in the right nibble
					;;   of the GOTO command.
					;;
					;; PROCESSING OPTIONS:
EXIT_IF_FOUND	    EQU   80H		;; exit INT 9 if a translation
					;;  match is found
					;;
ANY_KB		     EQU   0FFFFH	;;
XT_KB		     EQU   4000H	;;
AT_KB		     EQU   2000H	;;
G_KB		     EQU   1000H	;;
P_KB		     EQU   0800H	;;
P12_KB		     EQU   0400H	;;
DBCS_OLD_A_KB	     EQU   0080H ; M030	;; JP9009
DBCS_OLD_P_KB	     EQU   0040H ; M030	;; JP9009
DBCS_OLD_G_KB	     EQU   0020H ; M030	;; JP9009
DBCS_OLD_KB	     EQU   00C0H ; M030	;; JP9009
DBCS_KB		     EQU   0020H ; M030	;; JP9009
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Translate Table Sections.  Both the Specific and Common
;; Translate Sections are formatted as follows.
;;
;; The Specific Translate Sections are chained together using the
;; XS_NEXT_SECT_PTR field (-1 if last section).
;; Translate Sections contains multiple States.
;; A State contains the translate tables for a single
;; shift state (IE lower case, upper case ....)
;; Each State may contain multiple translate tables.
;;
;; The Translate Section layout is defined using several STRUCs.
;; These STRUCs are allocated in the Shared Data Area as follows:
;;
;;	 XLAT_SECT_STR		  ; header info for the section
;;	    STATE_STR		  ; header for state #1
;;	      XLAT_STR		  ;   first translate tab for state #1
;;	      XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;	      XLAT_STR		  ;   second translate tab
;;	      XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;	      ...
;;	    STATE_STR		  ; header for state #2
;;	      XLAT_STR
;;	      XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;	      ...
;;	   ...
;;
;; A State may contain a "Set_Flag" table instead of translate tables.
;; These tables are used to set the NLS flags instead of generating
;; ASCII codes (for example: to remember dead key states).
;; There can be only on Set_Flag table per state.
;; The Set_Flag table layout is defined in the SET_FLAG_STR STRUC.
;;
;; So some states will contain translate tables (to generate ASCII codes)
;; and some states will contain a Set_Flag table (to record dead key
;; status).
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
XLAT_SECT_STR	    STRUC		;;
					;;
XS_NEXT_SECT_PTR       DW    ?		;; Pointer to next Specific Translate
					;;  Section
XS_CP_ID	       DW    ?		;; code page id
XS_FIRST_STATE	       DB    ?		;;
					;;
XLAT_SECT_STR	    ENDS		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State structure.
;; The last State is a null State containing only the
;; XS_STATE_LEN field with a value of 0.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
STATE_STR	    STRUC		;;
					;;
XS_STATE_LEN	 DW    ?		;; length of state section
XS_STATE_ID	 DB    ?		;; State ID
XS_KBD_TYPE	 DW    ?		;; Keyboard Type
XS_ERROR_CHAR	 DW    ?		;; Buffer entry for error character
XS_FIRST_TAB	 DB    ?		;;
					;;
STATE_STR	    ENDS		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Translate Table structures.
;; There may be many translate tables in a State.  The last
;; table is a null table containing only the XLAT_TAB_SIZE field with
;; a value of 0.
;; The xlate table can be in one of two forms:
;;    Type 1 = Table contains buffer entries only.
;;	       Scan code is used as an index into xlat table
;;    Type 2 = Table contains pairs of SCAN/BUFFER_ENTRY.
;;	       Table must be searched for matching scan.
;; Type 1 is the default.  Type 2 tables should be identified by setting
;; the TYPE_2_TAB bit in XLAT_OPTIONS.
;; Buffer entries default to 2-bytes per entry.
;; Optionally the table may contain ASCII codes only
;; (1-byte entries).  This is specified by setting the ASCII_ONLY bit
;; in XLAT_OPTIONS.  2-byte buffer entries are coded ASCII,SCAN.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;; Translate options:
ASCII_ONLY	    EQU   80H		;; Only ASCII codes listed - use
					;;  incoming scan for buffer entry
TYPE_2_TAB	    EQU   40H		;; search xlat table for matching scan
ZERO_SCAN	    EQU   20H		;; set the scan half of the buffer
					;;  entry to 0
					;;
NULL_ASCII_CODE     EQU   -1		;;
					;;
DEFAULT_TAB_2_ENT_SZ   EQU   3		;;
ASC_ONLY_TAB_2_ENT_SZ  EQU   2		;;
					;;
					;;
XLAT_STR	    STRUC		;;
					;;
XLAT_TAB_SIZE	    DW	  ?		;; Size in bytes of this table -
					;;  includes this field, options etc.
XLAT_OPTIONS	    DB	  ?		;; xlat options
					;; XLAT TABLE IS HERE
XLAT_STR	    ENDS		;;
					;;
XLAT_TYPE_1_STR     STRUC		;; use scan code as index into table
		    DB TYPE XLAT_STR DUP(?)   ;; filler
XLAT_SCAN_LO	    DB	  ?		;; Scan code
XLAT_SCAN_HI	    DB	  ?		;;  range
XLAT_1_BUF_ENTRY    DB	  ?		;; The table itself
XLAT_TYPE_1_STR     ENDS		;;
					;;
XLAT_TYPE_2_STR     STRUC		;; search table for scan
		    DB TYPE XLAT_STR DUP(?)   ;; filler
XLAT_NUM	    DB	  ?		;; number of scans
XLAT_SCAN	    DB	  ?		;; Scan code
XLAT_2_BUF_ENTRY    DB	  ?		;; The table itself
XLAT_TYPE_2_STR     ENDS		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set_Flag Tables.
;; State Sections immediately following the LAST_ENTRYs.
;; Dead key definitions.  If the scan matches then
;; set the bit in NLS_FLAGs indicated in DK_MASK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
SF_ENT_SZ     EQU   3			;; size of entry
					;;
SET_FLAG_STR	    STRUC		;;
					;;
SF_NUM		    DB	  0		;; Number of entries
SF_SCAN_CODE	    DB	  0		;; scan code
SF_FLAG_ID	    DB	  0		;; flag id
SF_FLAG_MASK	    DB	  0		;; flag mask
					;;
SET_FLAG_STR	    ENDS		;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kbd2\kdfyu.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
       PAGE    ,132
	TITLE   MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Definition File
;;
;; This file contains the keyboard tables for Yugoslavia (ID234)
;;
;; Linkage Instructions:
;;      Refer to KDF.ASM.
;;
;;
;; WRITTEN:    MJS 22.SEPTEMBER 1987
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC           ;;
	INCLUDE POSTEQU.INC            ;;
	INCLUDE KEYBMAC.INC            ;;
				       ;;
	PUBLIC YU_LOGIC                ;;
	PUBLIC YU_850_XLAT             ;;
	PUBLIC YU_852_XLAT             ;;
				       ;;
CODE    SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a linear search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE      EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; YU State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
YU_LOGIC:                              ;;
				       ;;
   DW  LOGIC_END-$                     ;; length
				       ;;
   DW  0                               ;; special features
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND                ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;  ***BD - THIS SECTION HAS BEEN UPDATED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFKBD G_KB                             ;;P12_KB - ONLY VALID FOR ENHANCED KB
				       ;;
 IFF EITHER_CTL,NOT                    ;;
    IFF EITHER_ALT,NOT                 ;;
      IFF EITHER_SHIFT                 ;;
	  SET_FLAG DEAD_UPPER          ;;
      ELSEF                            ;;
	  SET_FLAG DEAD_LOWER          ;;
      ENDIFF                           ;;
    ELSEF                              ;;
      IFF R_ALT_SHIFT                  ;;
      ANDF EITHER_SHIFT,NOT            ;;
	 SET_FLAG DEAD_THIRD           ;;
      ENDIFF                           ;;
    ENDIFF                             ;;
 ENDIFF                                ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:                            ;;
				       ;;
   IFF ACUTE,NOT                       ;;
      GOTO CEDILLA_PROC                ;;
      ENDIFF                           ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT ACUTE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	 IFF EITHER_SHIFT              ;;
	    IFF CAPS_STATE             ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF                      ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF                     ;;
	 ELSEF                         ;;
	    IFF CAPS_STATE             ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF                      ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF                     ;;
	 ENDIFF                        ;;
      ENDIFF                           ;;
				       ;;
INVALID_ACUTE:                         ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP                             ;; failed or we are ina bad shift state.
      GOTO NON_DEAD                    ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CEDILLA ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CEDILLA_PROC:                          ;;
				       ;;
   IFF CEDILLA,NOT                     ;;
      GOTO DIARESIS_PROC               ;;
      ENDIFF                           ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT CEDILLA_SPACE           ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	 IFF EITHER_SHIFT              ;;
	    IFF CAPS_STATE             ;;
	       XLATT CEDILLA_LOWER     ;;
	    ELSEF                      ;;
	       XLATT CEDILLA_UPPER     ;;
	    ENDIFF                     ;;
	 ELSEF                         ;;
	    IFF CAPS_STATE             ;;
	       XLATT CEDILLA_UPPER     ;;
	    ELSEF                      ;;
	       XLATT CEDILLA_LOWER     ;;
	    ENDIFF                     ;;
	 ENDIFF                        ;;
      ENDIFF                           ;;
				       ;;
INVALID_CEDILLA:                       ;;
      PUT_ERROR_CHAR CEDILLA_LOWER     ;; If we get here then either the XLATT
      BEEP                             ;; failed or we are ina bad shift state.
      GOTO NON_DEAD                    ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:                         ;;
				       ;;
   IFF DIARESIS,NOT                    ;;
      GOTO GRAVE_PROC                  ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT DIARESIS_SPACE          ;;  exist for 850 so beep for
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	 IFF EITHER_SHIFT              ;;
	    IFF CAPS_STATE             ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF                      ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF                     ;;
	 ELSEF                         ;;
	    IFF CAPS_STATE             ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF                      ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF                     ;;
	 ENDIFF                        ;;
      ENDIFF                           ;;
				       ;;
INVALID_DIARESIS:                      ;;
      PUT_ERROR_CHAR DIARESIS_LOWER    ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:                            ;;
				       ;;
   IFF GRAVE,NOT                       ;;
      GOTO TILDE_PROC                  ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT GRAVE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_GRAVE:                         ;;
      PUT_ERROR_CHAR GRAVE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TILDE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TILDE_PROC:                            ;;
				       ;;
   IFF TILDE,NOT                       ;;
      GOTO CIRCUMFLEX_PROC             ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT TILDE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT TILDE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT TILDE_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE              ;;
	      XLATT TILDE_UPPER        ;;
	   ELSEF                       ;;
	      XLATT TILDE_LOWER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
INVALID_TILDE:                         ;;
      PUT_ERROR_CHAR TILDE_LOWER       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:                       ;;
				       ;;
   IFF CIRCUMFLEX,NOT                  ;;
      GOTO CARON_PROC                  ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF                       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF                       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_CIRCUMFLEX:                    ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CARON ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CARON_PROC:                            ;;
				       ;;
   IFF CARON,NOT                       ;;
      GOTO BREVE_PROC                  ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT CARON_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT CARON_LOWER        ;;
	   ELSEF                       ;;
	      XLATT CARON_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT CARON_LOWER        ;;
	   ELSEF                       ;;
	      XLATT CARON_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_CARON:                         ;;
      PUT_ERROR_CHAR CARON_LOWER       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BREVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
BREVE_PROC:                            ;;
				       ;;
   IFF BREVE,NOT                       ;;
      GOTO OVERCIRCLE_PROC             ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT BREVE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT BREVE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT BREVE_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT BREVE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT BREVE_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_BREVE:                         ;;
      PUT_ERROR_CHAR BREVE_LOWER       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OVERCIRCLE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
OVERCIRCLE_PROC:                            ;;
				       ;;
   IFF OVERCIRCLE,NOT                       ;;
      GOTO OGONEK_PROC             ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT OVERCIRCLE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT OVERCIRCLE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT OVERCIRCLE_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT OVERCIRCLE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT OVERCIRCLE_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_OVERCIRCLE:                         ;;
      PUT_ERROR_CHAR OVERCIRCLE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OGONEK ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
OGONEK_PROC:                            ;;
				       ;;
   IFF OGONEK,NOT                       ;;
      GOTO OVERDOT_PROC             ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT OGONEK_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT OGONEK_LOWER        ;;
	   ELSEF                       ;;
	      XLATT OGONEK_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT OGONEK_LOWER        ;;
	   ELSEF                       ;;
	      XLATT OGONEK_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_OGONEK:                         ;;
      PUT_ERROR_CHAR OGONEK_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OVERDOT ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
OVERDOT_PROC:                            ;;
				       ;;
   IFF OVERDOT,NOT                       ;;
      GOTO DOUBLEACUTE_PROC             ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT OVERDOT_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT OVERDOT_LOWER        ;;
	   ELSEF                       ;;
	      XLATT OVERDOT_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT OVERDOT_LOWER        ;;
	   ELSEF                       ;;
	      XLATT OVERDOT_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_OVERDOT:                         ;;
      PUT_ERROR_CHAR OVERDOT_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DOUBLEACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DOUBLEACUTE_PROC:                            ;;
				       ;;
   IFF DOUBLEACUTE,NOT                       ;;
      GOTO NON_DEAD                  ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT DOUBLEACUTE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT DOUBLEACUTE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT DOUBLEACUTE_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT DOUBLEACUTE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT DOUBLEACUTE_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_DOUBLEACUTE:                         ;;
      PUT_ERROR_CHAR DOUBLEACUTE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;; ***BD - NON_DEAD THRU LOGIC_END IS UPDATED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NON_DEAD:                              ;;
				       ;;
   IFKBD G_KB                          ;; Avoid accidentally translating
   ANDF LC_E0                          ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC                 ;;   G keyboard
   ENDIFF                              ;;
				       ;;
 IFF  EITHER_CTL,NOT                   ;; Lower and upper case.  Alphabetic
    IFF EITHER_ALT,NOT                 ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT                 ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE,NOT            ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF                       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_UPPER        ;;
	  IFF CAPS_STATE               ;;
	      XLATT ALPHA_LOWER        ;;
	  ELSEF                        ;;
	      XLATT ALPHA_UPPER        ;;
	  ENDIFF                       ;;
      ELSEF                            ;;
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE                ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF                       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_LOWER        ;;
	  IFF CAPS_STATE               ;;
	     XLATT ALPHA_UPPER         ;;
	  ELSEF                        ;;
	     XLATT ALPHA_LOWER         ;;
	  ENDIFF                       ;;
      ENDIFF                           ;; Third and Fourth shifts
    ELSEF                              ;; ctl off, alt on at this point
	 IFF R_ALT_SHIFT               ;; ALTGr
	 ANDF EITHER_SHIFT,NOT         ;;
	    XLATT THIRD_SHIFT          ;;
	 ENDIFF                        ;;
    ENDIFF                             ;;
 ENDIFF                                ;;
;**************************************;;
 IFF EITHER_SHIFT,NOT                  ;;
     IFF EITHER_CTL                    ;;
     ANDF ALT_SHIFT                    ;;
       IFF R_ALT_SHIFT,NOT             ;;
	 XLATT ALT_CASE                ;;
       ENDIFF                          ;;
     ENDIFF                            ;;
 ENDIFF                                ;;
;**************************************;;
      IFF EITHER_CTL,NOT               ;;
	 IFF ALT_SHIFT                 ;; ALT - case
	 ANDF R_ALT_SHIFT,NOT          ;;
	    XLATT ALT_CASE             ;;
	 ENDIFF                        ;;
      ELSEF                            ;;
	 IFF EITHER_ALT,NOT            ;; CTRL - case
	    XLATT CTRL_CASE            ;;
	 ENDIFF                        ;;
      ENDIFF                           ;;
ENDIFF                                 ;;
				       ;;
 EXIT_STATE_LOGIC                      ;;
				       ;;
LOGIC_END:                             ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;**********************************************************************
;; YU Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; Some common Characters are included from 128 - 165 where appropriate.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC YU_COMMON_XLAT                 ;;
YU_COMMON_XLAT:                        ;;
				       ;;
   DW     COMMON_XLAT_END-$            ;; length of section
   DW     -1                           ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Low Shift Dead Key
;; KEYBOARD TYPES: G
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_YU_LO_END-$               ;; length of state section
   DB    DEAD_LOWER                    ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;; Set Flag Table
				       ;; Set Flag Table
   DW    1                             ;; number of entries
   DB    41                            ;; scan code
   FLAG  CEDILLA                       ;; flag bit to set
				       ;;
COM_YU_LO_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Up Shift Dead Key
;; KEYBOARD TYPES: G
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_YU_UP_END-$               ;; length of state section
   DB    DEAD_UPPER                    ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;; Set Flag Table
   DW    1                             ;; number of entries
   DB    41                            ;;
   FLAG  DIARESIS                      ;; flag bit to set
				       ;;
COM_YU_UP_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Third Shift Dead Key
;; KEYBOARD TYPES: G
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_YU_TH_END-$               ;; length of state section
   DB    DEAD_THIRD                    ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;; Set Flag Table
   DW    11                            ;; number of entries
;; DB    2                             ;; TILDE IS NOT AN ACCENT KEY
;; FLAG  TILDE                         ;;
   DB    3                             ;;
   FLAG  CARON                         ;;
   DB    4                             ;;
   FLAG  CIRCUMFLEX                    ;;
   DB    5                             ;;
   FLAG  BREVE                         ;;
   DB    6                             ;;
   FLAG  OVERCIRCLE                    ;;
   DB    7                             ;;
   FLAG  OGONEK                        ;;
   DB    8                             ;;
   FLAG  GRAVE                         ;;
   DB    9                             ;;
   FLAG  OVERDOT                       ;;
   DB    10                            ;;
   FLAG  ACUTE                         ;;
   DB    11                            ;;
   FLAG  DOUBLEACUTE                   ;;
   DB    12                            ;;
   FLAG  DIARESIS                      ;;
   DB    13                            ;;
   FLAG  CEDILLA                       ;;
				       ;;
COM_YU_TH_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;******************************
;;***BD - ADDED FOR NUMERIC PAD (DECIMAL SEPERATOR)
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Numeric Key Pad
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_PAD_K1_END-$              ;; length of state section
   DB    NUMERIC_PAD                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_PAD_K1_T1_END-$           ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB    83,','                        ;; decimal seperator = ,
COM_PAD_K1_T1_END:                     ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_PAD_K1_END:                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;******************************
;;***BD - ADDED FOR ALT CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Alt Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_ALT_K1_END-$              ;; length of state section
   DB    ALT_CASE                      ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_ALT_K1_T1_END-$           ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    3                             ;; number of entries
   DB    21,0,2CH                      ;;
   DB    44,0,15H                      ;;
   DB    53,0,82H                      ;;
COM_ALT_K1_T1_END:                     ;;
				       ;;
    DW    0                            ;; Size of xlat table - null table
				       ;;
COM_ALT_K1_END:                        ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CTRL_K2_END-$             ;; length of state section
   DB    CTRL_CASE                     ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_CTRL_K2_T1_END-$          ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    3                             ;; number of entries
   DB    21,01AH,2CH                   ;;
   DB    44,019H,15H                   ;;
   DB    53,01FH,0CH                   ;;
COM_CTRL_K2_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_CTRL_K2_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_AL_LO_K1_END-$            ;; length of state section
   DB    ALPHA_LOWER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_AL_LO_K1_T1_END-$         ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    2                             ;; number of entries
   DB    21,"z",2CH                    ;;
   DB    44,"y",15H                    ;;
COM_AL_LO_K1_T1_END:                   ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_AL_LO_K1_END:                      ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_AL_UP_K1_END-$            ;; length of state section
   DB    ALPHA_UPPER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_AL_UP_K1_T1_END-$         ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    2                             ;; number of entries
   DB    21,"Z",2CH                    ;;
   DB    44,"Y",15H                    ;;
COM_AL_UP_K1_T1_END:                   ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_AL_UP_K1_END:                      ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_NA_LO_K1_END-$            ;; length of state section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_NA_LO_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    4                             ;; number of entries
   DB    12,"'"                        ;; '
   DB    13,"+"                        ;; +
   DB    86,"<"                        ;; <
   DB    53,"-"                        ;; -
COM_NA_LO_K1_T1_END:                   ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K1_END:                      ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_NA_UP_K1_END-$            ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_NA_UP_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    12                            ;; number of entries
   DB     3,'"'                        ;;
   DB     7,'&'                        ;;
   DB     8,'/'                        ;;
   DB     9,'('                        ;;
   DB    10,')'                        ;;
   DB    11,'='                        ;;
   DB    12,'?'                        ;;
   DB    13,'*'                        ;;
   DB    86,'>'                        ;;
   DB    51,';'                        ;;
   DB    52,':'                        ;;
   DB    53,'_'                        ;;
COM_NA_UP_K1_T1_END:                   ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K1_END:                      ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Third Shift
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_THIRD_END-$               ;; length of state section
   DB    THIRD_SHIFT                   ;; State ID
   DW    G_KB                          ;; Keyboard Type FERRARI
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_THIRD_T1_END-$            ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    10                            ;; number of entries
   DB     2,'~',02H                    ;;
   DB    16,'\',10H                    ;;
   DB    17,'|',11H                    ;;
   DB    26,'',1AH                    ;;
   DB    33,'[',21H                    ;;
   DB    34,']',22H                    ;;
   DB    40,0E1H,28H                    ;; Sharp S
   DB    47,'@',2FH                    ;;
   DB    48,'{',30H                    ;;
   DB    49,'}',31H                    ;;
COM_THIRD_T1_END:                      ;;
				       ;;
   DW    0                             ;; Last xlat table
COM_THIRD_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Caron Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CA_SP_END-$             ;; length of state section
   DB    CARON_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F3H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_CA_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F3H                       ;; Caron Space
COM_CA_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_CA_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Breve Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_BR_SP_END-$             ;; length of state section
   DB    BREVE_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F4H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_BR_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F4H                       ;; BREVE SPACE
COM_BR_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_BR_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Ogonek Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_OG_SP_END-$             ;; length of state section
   DB    OGONEK_SPACE                  ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F2H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_OG_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F2H                       ;; OGONEK SPACE
COM_OG_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_OG_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Double Acute Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_DC_SP_END-$             ;; length of state section
   DB    DOUBLEACUTE_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F1H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_DC_SP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of entries
   DB    57,0F1H                       ;; DOUBLEACUTE SPACE
COM_DC_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_DC_SP_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CI_LO_END-$               ;; length of state section
   DB    CIRCUMFLEX_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    94,0                          ;; error character = standalone accent
				       ;;
   DW    COM_CI_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    3                             ;; number of scans
   DB    23,''                        ;;  "    "  ,  "   - i
   DB    24,''                        ;; scan code,ASCII - o
   DB    30,''                        ;; scan code,ASCII - a
COM_CI_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;;
				       ;;
COM_CI_LO_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CI_SP_END-$               ;; length of state section
   DB    CIRCUMFLEX_SPACE              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    94,0                          ;; error character = standalone accent
				       ;;
   DW    COM_CI_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,94                         ;; STANDALONE CIRCUMFLEX
COM_CI_SP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_CI_SP_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Overcircle Space Bar
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_OC_SP_END-$               ;; length of state section
   DB    OVERCIRCLE_SPACE              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_OC_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F8H                       ;; STANDALONE OVERCIRCLE
COM_OC_SP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_OC_SP_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Grave Space Bar
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_GR_SP_END-$               ;; length of state section
   DB    GRAVE_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    96,0                          ;; error character = standalone accent
				       ;;
   DW    COM_GR_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,96                         ;; STANDALONE GRAVE
COM_GR_SP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_GR_SP_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Overdot
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW    COM_OD_SP_END-$               ;; length of state section
    DB    OVERDOT_SPACE                 ;; State ID
    DW    G_KB                          ;; Keyboard Type
    DB    0FAH,0                        ;; error character = standalone accent
					;;
    DW    COM_OD_SP_T1_END-$            ;; Size of xlat table
    DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
    DB    1                             ;; number of scans
    DB    57,0FAH                       ;; STANDALONE OVERDOT
COM_OD_SP_T1_END:                       ;;
					;;
    DW    0                             ;;
					;;
COM_OD_SP_END:                          ;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_AC_LO_END-$               ;; length of state section
   DB    ACUTE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
				       ;;
   DW    COM_AC_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    5                             ;; number of entries
   DB    18,082H                       ;;    e acute
   DB    22,0A3H                       ;;    u acute
   DB    23,0A1H                       ;;    i acute
   DB    24,0A2H                       ;;    o acute
   DB    30,0A0H                       ;;    a acute
COM_AC_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_AC_LO_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_AC_UP_END-$               ;; length of state section
   DB    ACUTE_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
				       ;;
   DW    COM_AC_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of entries
   DB    18,090H                       ;;    E acute
COM_AC_UP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_AC_UP_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_AC_SP_END-$             ;; length of state section
   DB    ACUTE_SPACE                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
				       ;;
   DW    COM_AC_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0EFH                        ;; error character = standalone accent
COM_AC_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
COM_AC_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Cedilla Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CE_LO_END-$               ;; length of state section
   DB    CEDILLA_LOWER                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_CE_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    46,''                        ;; scan code,ASCII - 
COM_CE_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_CE_LO_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Cedilla Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CE_UP_END-$               ;; length of state section
   DB    CEDILLA_UPPER                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_CE_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    46,''                        ;;     CEDILLA
COM_CE_UP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_CE_UP_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Cedilla Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CE_SP_END-$             ;; length of state section
   DB    CEDILLA_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_CE_SP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of entries
   DB    57,0F7H                       ;; CEDILLA SPACE
COM_CE_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_CE_SP_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_DI_LO_END-$               ;; length of state section
   DB    DIARESIS_LOWER                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
				       ;;
   DW    COM_DI_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    4                             ;; number of scans
   DB    18,''                        ;; scan code,ASCII - e
   DB    22,''                        ;; scan code,ASCII - u
   DB    24,''                        ;; scan code,ASCII - o
   DB    30,''                        ;; scan code,ASCII - a
COM_DI_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_DI_LO_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_DI_UP_END-$               ;; length of state section
   DB    DIARESIS_UPPER                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
				       ;;
   DW    COM_DI_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    3                             ;; number of scans
   DB    22,''                        ;;    U Diaeresis
   DB    24,''                        ;;    O Diaeresis
   DB    30,''                        ;;    A Diaeresis
COM_DI_UP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_DI_UP_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_DI_SP_END-$             ;; length of state section
   DB    DIARESIS_SPACE                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
				       ;;
   DW    COM_DI_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,249                        ;; error character = standalone accent
COM_DI_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
COM_DI_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW    0                             ;; Last State
COMMON_XLAT_END:                       ;;  END OF COMMON SECTION
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CODE PAGE 850 YUGOSLAV SPECIFIC TRANSLATION
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC YU_850_XLAT                    ;;
YU_850_XLAT:                           ;;
				       ;;
    DW   CP850_XLAT_END-$              ;;
    DW   850                           ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_AL_LO_END-$             ;; length of state section
   DB    ALPHA_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; error character = standalone accent
				       ;;
   DW    CP850_AL_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    5                             ;; number of entries
   DB    26,-1                         ;; BLOT OUT CHAR UNDER 850
   DB    27,-1                         ;; BLOT OUT CHAR UNDER 850
   DB    39,-1                         ;; BLOT OUT CHAR UNDER 850
   DB    40,-1                         ;; BLOT OUT CHAR UNDER 850
   DB    43,-1                         ;; BLOT OUT CHAR UNDER 850
CP850_AL_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP850_AL_LO_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_AL_UP_END-$             ;; length of state section
   DB    ALPHA_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; error character = standalone accent
				       ;;
   DW    CP850_AL_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    5                             ;; number of entries
   DB    26,-1                         ;; BLOT OUT CHAR UNDER 850
   DB    27,-1                         ;; BLOT OUT CHAR UNDER 850
   DB    39,-1                         ;; BLOT OUT CHAR UNDER 850
   DB    40,-1                         ;; BLOT OUT CHAR UNDER 850
   DB    43,-1                         ;; BLOT OUT CHAR UNDER 850
CP850_AL_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP850_AL_UP_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_CI_LO_END-$               ;; length of state section
   DB    CIRCUMFLEX_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    94,0                          ;; error character = standalone accent
				       ;;
   DW    CP850_CI_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of scans
   DB    18,88H                        ;;  e CIRCUMFLEX
   DB    23,8CH                        ;;  i CIRCUMFLEX
CP850_CI_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;;
				       ;;
CP850_CI_LO_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Overcircle Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_OC_LO_END-$               ;; length of state section
   DB    OVERCIRCLE_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
				       ;;
   DW    CP850_OC_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,86H                        ;; a OVERCIRCLE
CP850_OC_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP850_OC_LO_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Overcircle Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_OC_UP_END-$               ;; length of state section
   DB    OVERCIRCLE_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
				       ;;
   DW    CP850_OC_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,8FH                        ;; A OVERCIRCLE
CP850_OC_UP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP850_OC_UP_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Grave Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_GR_LO_END-$               ;; length of state section
   DB    GRAVE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    060H,0                        ;; error character = standalone accent
				       ;;
   DW    CP850_GR_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    5                             ;; number of scans
   DB    18,8AH                        ;; e GRAVE
   DB    22,97H                        ;; u GRAVE
   DB    23,8DH                        ;; i GRAVE
   DB    24,95H                        ;; o GRAVE
   DB    30,85H                        ;; a GRAVE
CP850_GR_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP850_GR_LO_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_AC_SP_END-$             ;; length of state section
   DB    ACUTE_SPACE                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    27H,0                         ;; error character = standalone accent
				       ;;
   DW    CP850_AC_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,27H                        ;; error character = standalone accent
CP850_AC_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
CP850_AC_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_DI_LO_END-$             ;; length of state section
   DB    DIARESIS_LOWER                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
				       ;;
   DW    CP850_DI_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    16,8BH                        ;; i DIARESIS
CP850_DI_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
CP850_DI_LO_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP850_DI_SP_END-$             ;; length of state section
;;   DB    DIARESIS_SPACE                ;; State ID
;;   DW    G_KB                   ;; Keyboard Type
;;   DB    249,0                         ;; error character = standalone accent
;;                                       ;;
;;   DW    CP850_DI_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,249                        ;; error character = standalone accent
;;CP850_DI_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;CP850_DI_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW    0                             ;; LAST STATE
				       ;;
CP850_XLAT_END:                        ;; END OF CP850 SECTION
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CODE PAGE 852 YUGOSLAV SPECIFIC TRANSLATION
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC YU_852_XLAT                    ;;
YU_852_XLAT:                           ;;
				       ;;
    DW     CP852_XLAT_END-$            ;;
    DW	   852			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_AL_LO_END-$           ;; length of state section
   DB    ALPHA_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    CP852_AL_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    5                             ;; number of entries
   DB    26,0E7H                       ;; s CARON
   DB    27,0D0H                       ;; d STROKE
   DB    39,09FH                       ;; c CARON
   DB    40,086H                       ;; c ACUTE
   DB    43,0A7H                       ;; z CARON
CP852_AL_LO_T1_END:                  ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_AL_LO_END:                     ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_AL_UP_END-$           ;; length of state section
   DB    ALPHA_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    CP852_AL_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    5                             ;; number of entries
   DB    26,0E6H                       ;; S CARON
   DB    27,0D1H                       ;; D STROKE
   DB    39,0ACH                       ;; C CARON
   DB    40,08FH                       ;; C ACUTE
   DB    43,0A6H                       ;; Z CARON
CP852_AL_UP_T1_END:                  ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_AL_UP_END:                     ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Third Shift
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_THIRD_END-$               ;; length of state section
   DB    THIRD_SHIFT                   ;; State ID
   DW    G_KB                          ;; Keyboard Type FERRARI
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    CP852_THIRD_T1_END-$            ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    5                             ;; number of entries
   DB    27,09EH,1BH                   ;;
   DB    37,088H,25H                   ;;
   DB    38,09DH,26H                   ;;
   DB    43,0CFH,2BH                   ;;
   DB    50,0F5H,32H                   ;;
CP852_THIRD_T1_END:                      ;;
				       ;;
   DW    0                             ;; Last xlat table
CP852_THIRD_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_CA_LO_END-$             ;; length of state section
   DB    CARON_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F3H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_CA_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    9                             ;; number of scans
   DB    18,0D8H                       ;; e CARON
   DB    19,0FDH                       ;; r CARON
   DB    20,09CH                       ;; t CARON
   DB    21,0A7H                       ;; z CARON
   DB    31,0E7H                       ;; s CARON
   DB    32,0D4H                       ;; d CARON
   DB    38,096H                       ;; l CARON
   DB    46,09FH                       ;; c CARON
   DB    49,0E5H                       ;; n CARON
CP852_CA_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_CA_LO_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_CA_UP_END-$             ;; length of state section
   DB    CARON_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F3H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_CA_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    9                             ;; number of scans
   DB    18,0B7H                       ;; E CARON
   DB    19,0FCH                       ;; R CARON
   DB    20,09BH                       ;; T CARON
   DB    21,0A6H                       ;; Z CARON
   DB    31,0E6H                       ;; S CARON
   DB    32,0D2H                       ;; D CARON
   DB    38,095H                       ;; L CARON
   DB    46,0ACH                       ;; C CARON
   DB    49,0D5H                       ;; N CARON
CP852_CA_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_CA_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_CA_SP_END-$             ;; length of state section
;;   DB    CARON_SPACE                   ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F3H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_CA_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F3H                       ;; e CARON
;;CP852_CA_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_CA_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Circumflex Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_CI_UP_END-$             ;; length of state section
   DB    CIRCUMFLEX_UPPER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    05EH,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_CI_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    3                             ;; number of scans
   DB    23,0D7H                       ;; I CIRCUMFLEX
   DB    24,0E2H                       ;; O CIRCUMFLEX
   DB    30,0B6H                       ;; A CIRCUMFLEX
CP852_CI_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_CI_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_BR_LO_END-$             ;; length of state section
   DB    BREVE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F4H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_BR_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,0C7H                       ;; a BREVE
CP852_BR_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_BR_LO_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_BR_UP_END-$             ;; length of state section
   DB    BREVE_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F4H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_BR_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,0C6H                       ;; A BREVE
CP852_BR_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_BR_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_BR_SP_END-$             ;; length of state section
;;   DB    BREVE_SPACE                   ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F4H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_BR_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F4H                       ;; BREVE SPACE
;;CP852_BR_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_BR_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overcirle Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_OC_LO_END-$             ;; length of state section
   DB    OVERCIRCLE_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_OC_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    22,085H                       ;; u OVERCIRCLE
CP852_OC_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_OC_LO_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overcircle Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_OC_UP_END-$             ;; length of state section
   DB    OVERCIRCLE_UPPER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_OC_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    22,0DEH                       ;; O OVERCIRCLE
CP852_OC_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_OC_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_OG_LO_END-$             ;; length of state section
   DB    OGONEK_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F2H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_OG_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of scans
   DB    18,0A9H                       ;; e OGONEK
   DB    30,0A5H                       ;; a OGONEK
CP852_OG_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_OG_LO_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_OG_UP_END-$             ;; length of state section
   DB    OGONEK_UPPER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F2H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_OG_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of scans
   DB    18,0A8H                       ;; E OGONEK
   DB    30,0A4H                       ;; A OGONEK
CP852_OG_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_OG_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_OG_SP_END-$             ;; length of state section
;;   DB    OGONEK_SPACE                  ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F2H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_OG_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F2H                       ;; OGONEK SPACE
;;CP852_OG_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_OG_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overdot Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_OD_LO_END-$             ;; length of state section
   DB    OVERDOT_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0FAH,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_OD_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    21,0BEH                       ;; z OVERDOT
CP852_OD_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_OD_LO_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overdot Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_OD_UP_END-$             ;; length of state section
   DB    OVERDOT_UPPER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0FAH,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_OD_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    21,0BDH                       ;; Z OVERDOT
CP852_OD_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_OD_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_AC_LO_END-$             ;; length of state section
   DB    ACUTE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_AC_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    7                             ;; number of entries
   DB    19,0EAH                       ;; r ACUTE
   DB    21,0ABH                       ;; z ACUTE
   DB    31,098H                       ;; s ACUTE
   DB    38,092H                       ;; l ACUTE
   DB    44,0ECH                       ;; y ACUTE
   DB    46,086H                       ;; c ACUTE
   DB    49,0E4H                       ;; n ACUTE
CP852_AC_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_AC_LO_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_AC_UP_END-$             ;; length of state section
   DB    ACUTE_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_AC_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    11                            ;; number of entries
   DB    19,0E8H                       ;; R ACUTE
   DB    21,08DH                       ;; Z ACUTE
   DB    22,0E9H                       ;; U ACUTE
   DB    23,0D6H                       ;; I ACUTE
   DB    24,0E0H                       ;; O ACUTE
   DB    30,0B5H                       ;; A ACUTE
   DB    31,097H                       ;; S ACUTE
   DB    38,091H                       ;; L ACUTE
   DB    44,0EDH                       ;; Y ACUTE
   DB    46,08FH                       ;; C ACUTE
   DB    49,0E3H                       ;; N ACUTE
CP852_AC_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_AC_UP_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_AC_SP_END-$             ;; length of state section
   DB    ACUTE_SPACE                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_AC_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0EFH                       ;; error character = standalone accent
CP852_AC_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
CP852_AC_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_DC_LO_END-$             ;; length of state section
   DB    DOUBLEACUTE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F1H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_DC_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    22,0FBH                       ;; u DOUBLEACUTE
   DB    24,08BH                       ;; o DOUBLEACUTE
CP852_DC_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_DC_LO_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_DC_UP_END-$             ;; length of state section
   DB    DOUBLEACUTE_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F1H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_DC_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    22,0EBH                       ;; U DOUBLEACUTE
   DB    24,08AH                       ;; O DOUBLEACUTE
CP852_DC_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_DC_UP_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_DC_SP_END-$             ;; length of state section
;;   DB    DOUBLEACUTE_SPACE                   ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F1H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_DC_SP_T1_END-$        ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of entries
;;   DB    57,0F1H                       ;; DOUBLEACUTE SPACE
;;CP852_DC_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_DC_SP_END:                       ;;
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_DI_UP_END-$             ;; length of state section
   DB    DIARESIS_UPPER                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
				       ;;
   DW    CP852_DI_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    18,0D3H                       ;;    E Diaeresis
CP852_DI_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_DI_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_CE_LO_END-$             ;; length of state section
   DB    CEDILLA_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_CE_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    20,0EEH                       ;; t CEDILLA
   DB    31,0ADH                       ;; s CEDILLA
CP852_CE_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_CE_LO_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_CE_UP_END-$             ;; length of state section
   DB    CEDILLA_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_CE_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    20,0DDH                       ;; T CEDILLA
   DB    31,0B8H                       ;; S CEDILLA
CP852_CE_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_CE_UP_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_CE_SP_END-$             ;; length of state section
;;   DB    CEDILLA_SPACE                   ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F7H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_CE_SP_T1_END-$        ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of entries
;;   DB    57,0F7H                       ;; CEDILLA SPACE
;;CP852_CE_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_CE_SP_END:                       ;;
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    0                             ;; LAST STATE
				       ;;
CP852_XLAT_END:                        ;;  END OF CP852 SECTION
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CODE     ENDS                          ;;  END OF PROGRAM
	 END                           ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\kkcfunc\kkcfunc.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	***** INT 2Fh function 4Dh for Kana Kanji Converters *****
;

include		versiona.inc
include		syscall.inc
include		kkcfunc.inc

code	segment byte public
	assume	cs:code,ds:code,es:code

	org	0

start	label	byte

dev_header	label	byte
	dd	-1
	dw	CHAR_DEV
	dw	strategy
	dw	interrupt
	db	"KKCFUNC$"

req_header	dd	?

org_int		label	word
	dd	?			; int 23h
	dd	?			; int 24h

org_int2f	dd	?
indos_flag	dd	?
org_pdp		dw	?

dos_func_flag	dw	?

dos_func_err	dw	?

crit_err_no	dw	0

kkc_ver_tbl	label	word
	dw	MAX_KKC_NUM
	dw	MAX_KKC_NUM dup (0)

kkc_func_tbl	label	word
	dw	get_func_adrs
	dw	get_err_no
	dw	regist_kkc
	dw	get_table_adrs
KKC_FUNC_MAX	equ	($ - kkc_func_tbl) / 2

kkc_dos_tbl	label	byte
	db	19h,-1			; get current disk
	db	1ah,-1			; set DTA address
	db	2fh,-1			; get DTA address
	db	3dh,-1			; open file
	db	3eh,-1			; close file
	db	3fh,-1			; read file or device
	db	40h,-1			; write file or device
	db	42h,-1			; set file pointer
	db	44h,02h			; read control data
	db	44h,0eh			; get logical drive map
	db	47h,-1			; get current directory
	db	4eh,-1			; find first file
KKC_DOS_LEN	equ	($ - kkc_dos_tbl) / 2

dos_save_buf	db	DOS_SAVE_LEN dup (0)

;------------------------------------------------------------------------------

strategy	proc	far
	mov	word ptr cs:[req_header],bx
	mov	word ptr cs:[req_header+2],es
	ret
strategy	endp

interrupt	proc	far
	push	bx
	push	es
	les	bx,cs:[req_header]
	cmp	es:[bx.command],DEV_INIT
	jz	intr_init		; if device initialize
	cmp	es:[bx.command],DEV_REST
	jz	intr_rest		; if device restore
	mov	ah,DEV_ERROR or DEV_DONE
	mov	al,DEV_INVALID
	jmp	short intr_ret
intr_init:
	call	inst_kkc
	jc	intr_ret
	not	word ptr es:[bx.bpb_adrs]	; device restore is available
	not	word ptr es:[bx.bpb_adrs+2]
	mov	word ptr es:[bx.break_adrs], offset end_off ; device end offset
	mov	word ptr es:[bx.break_adrs+2],cs
	jmp	short intr_ret
intr_rest:
	call	rest_kkc
	mov	ah,DEV_DONE
	xor	al,al
intr_ret:
	mov	es:[bx.status],ax
	pop	es
	pop	bx
	ret
interrupt	endp

inst_kkc	proc	near
	cld
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	ds
	push	es
	push	cs
	pop	ds
	mov	ah,Get_Version
	int	21h
	cmp	ax,expected_version
	jnz	ver_err			; invalid version
	mov	ah,Get_Interrupt_Vector
	mov	al,2Fh
	int	21h
	mov	word ptr org_int2f,bx	; save original address
	mov	word ptr org_int2f+2,es
	mov	ah,Get_InDOS_Flag
	int	21h
	mov	word ptr indos_flag,bx	; save indos flag address
	mov	word ptr indos_flag+2,es
	push	ds
	mov	ah,Get_Current_PDB
	int	21h
	mov	ds,bx
	mov	si,0
	lea	di,kkc_pdp
	push	cs
	pop	es
	mov	cx,256 / 2
	rep	movsw			; copy pdp
	pop	ds
	mov	ah,Set_Interrupt_Vector
	mov	al,2Fh
	lea	dx,int2f_kkc		; install KKCFUNC
	int	21h
	mov	ah,DEV_DONE
	xor	al,al
	clc
	jmp	short inst_ret
ver_err:
	xor	ax,ax
	stc
inst_ret:
	pop	es
	pop	ds
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	ret
inst_kkc	endp

;------------------------------------------------------------------------------

rest_kkc	proc	near
	cld
	push	ax
	push	si
	push	di
	push	ds
	push	es
	mov	ax,cs
	mov	ds,ax
	mov	ax,0			; int vect seg
	mov	es,ax
	lea	si,org_int2f
	mov	di,2fh*4
	cmp	word ptr es:[di],offset int2f_kkc
	jnz	@f			; if int2f has changed
	mov	ax,cs
	cmp	es:[di+2],ax
	jnz	@f
	movsw				; restore original int 2fh
	movsw
@@:
	pop	es
	pop	ds
	pop	di
	pop	si
	pop	ax
	ret
rest_kkc	endp

;------------------------------------------------------------------------------

int2f_kkc	proc	far
	cmp	ah,4dh
	jnz	not_kkc			; if not KKCFUNC
	cmp	al,KKC_FUNC_MAX
	jae	not_kkc			; if invalid sub function
	push	si
	mov	si,ax
	and	si,0ffh			; strip high byte
	shl	si,1
	call	cs:[kkc_func_tbl+si]	; execute subfunction
	pop	si
	iret
not_kkc:
	jmp	cs:org_int2f
int2f_kkc	endp

;------------------------------------------------------------------------------

get_func_adrs	proc	near
	lea	dx,kkc_dos_func
	mov	cx,cs
	mov	ax,SUCCESS
	ret
get_func_adrs	endp

get_err_no	proc	near
	mov	ax,cs:[dos_func_err]
	mov	dx,cs:[crit_err_no]
	ret
get_err_no	endp

chk_busy	proc	near
	mov	dx,cs:dos_func_flag
	mov	ax,SUCCESS
	ret
chk_busy	endp

regist_kkc	proc	near
	cld
	push	cx
	push	di
	push	es
	push	cs
	pop	es
	cmp	cx,1
	jz	rk_rel			; if release
	lea	di,kkc_ver_tbl+2
	mov	cx,es:[di-2]
	mov	ax,0
	repnz	scasw			; find null handle
	mov	ax,OVER_ERR
	jnz	rk_ret			; if full
	sub	di,2
	mov	es:[di],dx		; regist kkc version
	mov	bx,di
	sub	bx,offset kkc_ver_tbl+2
	shr	bx,1			; get handle no.
	inc	bx
	mov	ax,SUCCESS
	jmp	short rk_ret
rk_rel:
	mov	di,bx
	cmp	di,cs:[kkc_ver_tbl]
	mov	ax,HANDLE_ERR
	ja	rk_ret			; if invalid handle
	shl	di,1
	cmp	cs:[kkc_ver_tbl+di],0
	jz	rk_ret			; if not registrated
	mov	cs:[kkc_ver_tbl+di],0	; release
	mov	ax,SUCCESS
rk_ret:
	pop	es
	pop	di
	pop	cx
	ret
regist_kkc	endp

get_table_adrs	proc	near
	lea	dx,kkc_ver_tbl
	mov	cx,cs
	mov	ax,SUCCESS
	ret
get_table_adrs	endp

;------------------------------------------------------------------------------

kkc_dos_func	proc	far
	mov	cs:[dos_func_err],0
	mov	cs:[crit_err_no],-1

	call	chk_func_no
	jc	kdf_inv			; if invalid function

	cmp	cs:dos_func_flag,BUSY
	jz	kdf_busy		; if busy

	cli
	mov	cs:dos_func_flag,BUSY

	call	save_dos_data
	call	break_off
	call	set_pdp
	call	set_int

	int	21h
	pushf

	cli
	call	rest_int
	call	rest_pdp
	call	rest_dos_data

	mov	cs:dos_func_flag,NOT_BUSY

	cmp	cs:[dos_func_err],CRITICAL_ERR
	jz	kdf_crit
	popf
	sti
	jmp	short kdf_ret
kdf_crit:
	popf
	sti
	jmp	short kdf_err
kdf_inv:
	mov	cs:[dos_func_err],INVALID_FUNC
	jmp	short kdf_err
kdf_busy:
	mov	cs:[dos_func_err],FUNC_BUSY
kdf_err:
	mov	ax,ERR
	stc
kdf_ret:
	ret
kkc_dos_func	endp

chk_func_no	proc	near
	cld
	push	ax
	push	cx
	push	di
	push	es
	push	cs
	pop	es
	lea	di,kkc_dos_tbl
	mov	cx,KKC_DOS_LEN
	xchg	ah,al
cfn_loop:
	scasb				; find function no.
	jnz	cfn_next		; if not found
	cmp	byte ptr es:[di],-1
	jz	@f			; if no sub funcion no. to check
	cmp	es:[di],ah
	jnz	cfn_next		; if subfunction not found
@@:
	clc
	jmp	short cfn_ret
cfn_next:
	inc	di
	loop	cfn_loop
	stc
cfn_ret:
	pop	es
	pop	di
	pop	cx
	pop	ax
	ret
chk_func_no	endp

save_dos_data	proc	near
	cld
	push	cx
	push	si
	push	di
	push	ds
	push	es
	lds	si,cs:indos_flag
	cmp	byte ptr [si],0
	jz	sdd_ret			; if not in dos
	mov	si,DOS_SAVE_ST
	mov	cx,DOS_SEG
	mov	ds,cx
	lea	di,dos_save_buf
	push	cs
	pop	es
	mov	cx,DOS_SAVE_LEN
	rep	movsb			; save dos data
sdd_ret:
	pop	es
	pop	ds
	pop	di
	pop	si
	pop	cx
	ret
save_dos_data	endp

rest_dos_data	proc	near
	cld
	push	cx
	push	si
	push	di
	push	ds
	push	es
	lds	si,cs:indos_flag
	cmp	byte ptr [si],0
	jz	rdd_ret			; if not in dos
	lea	si,dos_save_buf
	push	cs
	pop	ds
	mov	di,DOS_SAVE_ST
	mov	cx,DOS_SEG
	mov	es,cx
	mov	cx,DOS_SAVE_LEN
	rep	movsb			; restore dos data
rdd_ret:
	pop	es
	pop	ds
	pop	di
	pop	si
	pop	cx
	ret
rest_dos_data	endp

break_off	proc	near
	push	ax
	push	dx
	mov	ah,Set_CTRL_C_Trapping
	mov	al,1			; set break
	mov	dl,0			; off
	int	21h
	pop	dx
	pop	ax
	ret
break_off	endp

set_pdp		proc	near
	push	ax
	push	bx
	mov	ah,Get_Current_PDB
	int	21h
	mov	cs:org_pdp,bx		; save original pdp addrs
	mov	bx,cs
	add	bx,KKC_PDP_SEG
	mov	ah,Set_Current_PDB
	int	21h
	pop	bx
	pop	ax
	ret
set_pdp		endp

rest_pdp	proc	near
	push	ax
	push	bx
	mov	ah,Set_Current_PDB
	mov	bx,cs:org_pdp		; original pdp addrs
	int	21h
	pop	bx
	pop	ax
	ret
rest_pdp	endp

set_int		proc	near
	cld
	push	ax
	push	cx
	push	si
	push	di
	push	ds
	push	es
	mov	ax,0			; int vector seg
	mov	ds,ax
	mov	ax,cs
	mov	es,ax
	mov	si,23h*4		; int 23h
	lea	di,org_int
	mov	cx,4
	rep	movsw			; save original int 23 & 24
	mov	ax,0
	mov	es,ax
	mov	di,23h*4		; int 23h
	lea	ax,int_23
	stosw				; set new int 23h
	mov	ax,cs
	stosw
	lea	ax,int_24
	stosw				; set new int 24h
	mov	ax,cs
	stosw
	pop	es
	pop	ds
	pop	di
	pop	si
	pop	cx
	pop	ax
	ret
set_int		endp

rest_int	proc	near
	cld
	push	ax
	push	cx
	push	si
	push	di
	push	ds
	push	es
	mov	ax,cs
	mov	ds,ax
	mov	ax,0			; int vector seg
	mov	es,ax
	lea	si,org_int
	mov	di,23h*4		; int 23h
	mov	cx,4
	rep	movsw			; restore original int 23 & 24
	pop	es
	pop	ds
	pop	di
	pop	si
	pop	cx
	pop	ax
	ret
rest_int	endp

;------------------------------------------------------------------------------

int_23		proc	far
	iret
int_23		endp

int_24		proc	far
	mov	cs:[dos_func_err],CRITICAL_ERR
	mov	cs:[crit_err_no],di
	xor	al,al
	iret
int_24		endp

;------------------------------------------------------------------------------

	db	16 - (($ - start) mod 16) dup (0)

KKC_PDP_SEG	=	($ - start) / 16

kkc_pdp		db	256 dup (0)

end_off		label	byte

code	ends

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\monoumb\vdd2.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1991
;
;   Title:	vdd2.inc - VDD definitions for Secondary VDD
;
;   Version:	1.00
;
;   Author: MDW
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   02-Aug-1989 MDW Added service definitions
;==============================================================================


Begin_Service_Table VDD2

;***************
;VDD2 services for other devices and VMM(Get_Version must be first)
;
VDD2_Service	VDD2_Get_Version, LOCAL  ; Get version number and ID string ptr
End_Service_Table VDD2
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\monoumb\monoumb.asm ===
PAGE 58,132
;******************************************************************************
TITLE MonoUMB -- Dummy VDD2 device to fool old VDDs
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1992
;
;   Title:	MonoUMB -- Dummy VDD2 device to fool old (3.00) VDDs into
;			   not claiming the MONOChrome adapter region.
;			   This allows a UMB in the MONOChrome region
;			   for LIM/UMBulators (like EMM386) that do not
;			   load the LoadHi VxD on WIN386 versions >= 3.10
;			   because they specify the UMBs using only the
;			   Paging Import to the V86MMGR.
;
;   Version:	1.00
;
;   Date:	07-Jan-1992
;
;   Author:	ARR
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;    01-07-1992 ARR Original
;
;==============================================================================
;
;   DESCRIPTION: See Title ABove
;
;******************************************************************************

	.386p


;******************************************************************************
;			      I N C L U D E S
;******************************************************************************



	.XLIST
	INCLUDE VMM.Inc
	.LIST

	Create_VDD2_Service_Table EQU TRUE
	INCLUDE .\VDD2.Inc
	MonoUMB_Service_Table EQU VDD2_Service_Table
	Num_MonoUMB_Services EQU Num_VDD2_Services

;******************************************************************************
;		 V I R T U A L	 D E V I C E   D E C L A R A T I O N
;******************************************************************************

Declare_Virtual_Device MonoUMB, 1, 0, MonoUMB_Control, VDD2_Device_ID, Undefined_Init_Order

;******************************************************************************
;				 E Q U A T E S
;******************************************************************************

;******************************************************************************
;			     S T R U C T U R E S
;******************************************************************************

;******************************************************************************
;			   F L A G   E Q U A T E S
;******************************************************************************


;******************************************************************************
;		   I N I T I A L I Z A T I O N	 D A T A
;******************************************************************************

VxD_IDATA_SEG

; define a copyright string

MS_CopyRight		db	'(C) Copyright MICROSOFT Corp., 1992',0
MonoUMB_Device_Name	 db	'MonoUMB',0,0

VxD_IDATA_ENDS

;******************************************************************************
;			    L O C A L	D A T A
;******************************************************************************

VxD_DATA_SEG

VxD_DATA_ENDS



;******************************************************************************
;	      R E A L	M O D E   I N I T I A L I Z A T I O N
;******************************************************************************

VxD_REAL_INIT_SEG

;******************************************************************************
;
;   MonoUMB_Real_Mode_Init
;
;   DESCRIPTION:
;
;	The VxD will not load if this is a duplicate load.
;
;   ENTRY:
;	CS, DS = Real mode segment
;	AX = VMM version (AH=Major, AL=Minor)
;	BX = Flags
;
;   EXIT:
;	BX = Null pointer (no pages to exclude)
;	SI = Null pointer (no instance data)
;	EDX = 0
;
;   USES:
;	AX, BX, DX, SI, Flags
;
;==============================================================================

BeginProc MonoUMB_Real_Mode_Init

; check for duplicate device load.

	test	bx, Duplicate_From_INT2F OR Duplicate_Device_ID
	jnz	SHORT MU_RMI_Fail_Load
MU_RMI_Loading_Ok:
	mov	ax, Device_Load_Ok
	jmp	SHORT MU_RMI_Exit

MU_RMI_Fail_Load:

; fail this device load without any error message.

	mov	ax, Abort_Device_Load + No_Fail_Message
MU_RMI_Exit:
	xor	bx,bx				;no pages to exclude
	xor	si,si				;no instance data
	xor	edx,edx 			;Ref data 0
	ret

EndProc MonoUMB_Real_Mode_Init

VxD_REAL_INIT_ENDS

;******************************************************************************
;	       D E V I C E   C O N T R O L   P R O C E D U R E
;******************************************************************************

VxD_CODE_SEG

;******************************************************************************
;
;   MonoUMB_Control
;
;   DESCRIPTION:
;
;   ENTRY:
;	EAX = Control call ID
;
;   EXIT:
;	If carry clear then
;	    Successful
;	else
;	    Control call failed
;
;   USES:
;	EAX, EBX, ECX, EDX, ESI, EDI, Flags
;
;==============================================================================

BeginProc MonoUMB_Control,PUBLIC

	clc					; Ignore other control calls
	ret

EndProc MonoUMB_Control

;----------------------------------------------------------------------------;
; VDD2_Get_Version:							     ;
;									     ;
;   DESCRIPTION:							     ;
;	MonoUMB VxD acts like a secondary VDD. This prevents the VGA and     ;
;	EGA VDDs from getting upset about the fact that someone has	     ;
;	grabbed the ownership of the MONO video pages.			     ;
;									     ;
;   ENTRY:								     ;
;	None								     ;
;									     ;
;   EXIT:								     ;
;	If UMBs in MONO region, carry clear				     ;
;	    EAX != 0							     ;
;	    ESI -> device name string					     ;
;	else, carry set 						     ;
;	    EAX = ESI = 0						     ;
;									     ;
;   USES:								     ;
;	FLAGS,EAX,ESI							     ;
;									     ;
;----------------------------------------------------------------------------;
BeginProc VDD2_Get_Version, Service

	mov	esi,OFFSET32 MonoUMB_Device_Name
	mov	eax, 200h
	clc
	ret

EndProc VDD2_Get_Version

VxD_CODE_ENDS

END MonoUMB_Real_Mode_Init
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\power\lmul.asm ===
page	,132
	title	lmul - long multiply routine
;***
;lmul.asm - long multiply routine
;
;	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Defines long multiply routines
;	Both signed and unsigned routines are the same, since multiply's
;	work out the same in 2's complement
;
;Revision History:
;	11-29-83  DFW	initial version
;	06-01-84  RN	modified to use cmacros
;	04-17-85  TC	ignore signs since they take care of themselves
;			do a fast multiply if both hiwords of arguments are 0
;	10-10-86  MH	slightly faster implementation, for 0 in upper words
;	03-20-89  SKS	Remove redundant "MOV SP,BP" from epilogs
;	05-18-89  SKS	Preserve BX
;	11-28-89  GJF	Fixed copyright
;
;       06-05-91  MD    Stolen from C runtime for use with POWER.EXE
;
;*******************************************************************************


.xlist
include mm.inc
.list

Trans_Code      segment word public 'CODE'
Trans_Code      ends

Trans_Data      segment word public 'DATA'
Trans_Data      ends

;***
;lmul - long multiply routine
;
;Purpose:
;	Does a long multiply (same for signed/unsigned)
;	Parameters are not changed.
;
;Entry:
;	Parameters are passed on the stack:
;		1st pushed: multiplier (DWORD)
;		2nd pushed: multiplicand (DWORD)
;
;Exit:
;	DX:AX - product of multiplier and multiplicand
;	NOTE: parameters are removed from the stack
;
;Uses:
;	CX
;
;Exceptions:
;
;*******************************************************************************

Trans_Code      segment
        assume cs:Trans_Code, ds:Trans_Data

lmul    proc    near
        public  lmul

A	equ	BPARGBAS[bp]	; stack address of a
B	equ	BPARGBAS+4[bp]	; stack address of b

;
;	AHI, BHI : upper 16 bits of A and B
;	ALO, BLO : lower 16 bits of A and B
;
;	      ALO * BLO
;	ALO * BHI
; +	BLO * AHI
; ---------------------

        push    bp
        mov     bp,sp

	mov	ax,HIWORD(A)
	mov	cx,HIWORD(B)
	or	cx,ax		;test for both hiwords zero.
	mov	cx,LOWORD(B)
	jnz	hard		;both are zero, just mult ALO and BLO

	mov	ax,LOWORD(A)
	mul	cx

	pop	bp
	ret

hard:
	push	bx

	mul	cx		;ax has AHI, cx has BLO, so AHI * BLO
	mov	bx,ax		;save result

	mov	ax,LOWORD(A)
	mul	word ptr HIWORD(B) ;ALO * BHI
	add	bx,ax		;bx = ((ALO * BHI) + (AHI * BLO))

	mov	ax,LOWORD(A)	;cx = BLO
	mul	cx		;so dx:ax = ALO*BLO
	add	dx,bx		;now dx has all the LO*HI stuff

	pop	bx
        mov     bp,sp
        pop     bp
        ret
lmul    endp

Trans_Code      ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\power\mm.inc ===
;***
;mm.inc - macros to write memory model dependent code
;
;	Copyright (c) 1987-1990, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	This file contains definitions of a number of macros which
;	make the writing of memory model dependent code for the
;	8086 a little easier and more portable.
;
;Revision History:
;	05-18-89  SKS	Removed ES references from pointer macros -- DS is used
;	09-01-89  GJF	Fixed copyright date.
;
;*******************************************************************************

; the macro below is used by the assigning long arithmetic routines (almul,
; etc) to handle the model dependent data addressing - in small and middle
; models data addresses default to short (2 byte) addresses. in large model,
; data address are long (4 bytes).

LOAD	macro	to,from
	mov	to,from
	endm


; general code & data size constants & macros

DAT_ADDR_SZ =	2
BDAT_ADDR_SZ =	4

TXT_ADDR_SZ =	2


; Big/Little Endian Definitions for Long Integers

LOWORD	equ	[0]
HIWORD	equ	[2]

; All Model Definitions

BPARGBAS equ	TXT_ADDR_SZ+2	; offset from BP to first argument


; macro for windows fixup with retf #

return	macro	n
	org	$-1
	db	0c2h
	dw	n
	endm
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\monoumb\vmm.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1990
;
;   Title:	VMM.INC - Include file for Virtual Machine Manager
;
;   Version:	1.00
;
;   Date:	05-May-1988
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   05-May-1988 RAL Original
;
;==============================================================================


; NON Windows/386 Virtual Device sources can include this file to get some
; useful equates by declaring the symbol "Not_VxD"  If this symbol is defined,
; then everything that has to do with the specifics of the 32 bit environment
; for virtual devices is removed.  Useful equates include:  device ID's, pushad
; structure, BeginDoc/EndDoc/BeginMsg/EndMsg equates, page table equates, etc.



False	EQU	0
True	EQU	NOT False

;
;   These null macros are recognized by a utility program that produces
;   documentation files.
;
BeginDoc EQU <>
EndDoc EQU <>

BeginMsg EQU <>
EndMsg EQU <>


BeginDoc
;******************************************************************************
;
;			EQUATES FOR REQUIRED DEVICES
;
;   Device ID formulation note:
;
;	Device ID's are a combination of OEM # and device # in the form:
;
;		xOOOOOOOOOODDDDD
;
;	The high bit of the device ID is reserved for future use.  The next
;	10 bits are the OEM # which is assigned by Microsoft.  The last 5 bits
;	are the device #.  This allows each OEM to create 32 unique devices.
;	If an OEM is creating a replacement for a standard device, then it
;	should re-use the standard ID listed below.  Microsoft reserves the
;	first 16 OEM #'s (0 thru 0Fh)
;
;==============================================================================

Undefined_Device_ID		EQU	00000h
VMM_Device_ID			EQU	00001h	; Used for dynalink table
Debug_Device_ID 		EQU	00002h
VPICD_Device_ID 		EQU	00003h
VDMAD_Device_ID 		EQU	00004h
VTD_Device_ID			EQU	00005h
V86MMGR_Device_ID		EQU	00006h
PageSwap_Device_ID		EQU	00007h
Parity_Device_ID		EQU	00008h
Reboot_Device_ID		EQU	00009h
VDD_Device_ID			EQU	0000Ah
VSD_Device_ID			EQU	0000Bh
VMD_Device_ID			EQU	0000Ch
VKD_Device_ID			EQU	0000Dh
VCD_Device_ID			EQU	0000Eh
VPD_Device_ID			EQU	0000Fh
BlockDev_Device_ID		EQU	00010h
VMCPD_Device_ID 		EQU	00011h
EBIOS_Device_ID 		EQU	00012h
BIOSXlat_Device_ID		EQU	00013h
VNETBIOS_Device_ID		EQU	00014h
DOSMGR_Device_ID		EQU	00015h
WINLOAD_Device_ID		EQU	00016h
SHELL_Device_ID 		EQU	00017h
VMPoll_Device_ID		EQU	00018h
VPROD_Device_ID 		EQU	00019h
DOSNET_Device_ID		EQU	0001Ah
VFD_Device_ID			EQU	0001Bh
VDD2_Device_ID			EQU	0001Ch	; Secondary display adapter
WINDEBUG_Device_ID		EQU	0001Dh
TSRLoad_Device_ID		EQU	0001Eh	; TSR instance utility ID
BiosHook_Device_ID		EQU	0001Fh	; Bios interrupt hooker VxD
Int13_Device_ID 		EQU	00020h
PageFile_Device_ID		EQU	00021h	; Paging File device
SCSI_Device_ID			EQU     00022h  ; SCSI device
MCA_POS_Device_ID		EQU     00023h  ; MCA_POS device
SCSIFD_Device_ID		EQU	00024h	; SCSI FastDisk device
VPEND_Device_ID 		EQU	00025h	; Pen device
APM_Device_ID			EQU	00026h	; Power Management device

;
;   Initialization order equates.  Devices are initialized in order from
;   LOWEST to HIGHEST.	If 2 or more devices have the same initialization
;   order value, then they are initialized in order of occurance, so a
;   specific order is not guaranteed.  Holes have been left to allow maximum
;   flexibility in ordering devices.
;

VMM_Init_Order			EQU	000000000h
APM_Init_Order			EQU	001000000h
Debug_Init_Order		EQU	004000000h
BiosHook_Init_Order		EQU	006000000h
VPROD_Init_Order		EQU	008000000h
VPICD_Init_Order		EQU	00C000000h
VTD_Init_Order			EQU	014000000h
PageFile_Init_Order		EQU	018000000h
PageSwap_Init_Order		EQU	01C000000h
Parity_Init_Order		EQU	020000000h
Reboot_Init_Order		EQU	024000000h
EBIOS_Init_Order		EQU	026000000h
VDD_Init_Order			EQU	028000000h
VSD_Init_Order			EQU	02C000000h
VCD_Init_Order			EQU	030000000h
VMD_Init_Order			EQU	034000000h
VKD_Init_Order			EQU	038000000h
VPD_Init_Order			EQU	03C000000h
BlockDev_Init_Order		EQU	040000000h
MCA_POS_Init_Order		EQU	041000000h
SCSIFD_Init_Order		EQU	041400000h
SCSIMaster_Init_Order	        EQU     041800000h
Int13_Init_Order		EQU	042000000h
VFD_Init_Order			EQU	044000000h
VMCPD_Init_Order		EQU	048000000h
BIOSXlat_Init_Order		EQU	050000000h
VNETBIOS_Init_Order		EQU	054000000h
DOSMGR_Init_Order		EQU	058000000h
DOSNET_Init_Order		EQU	05C000000h
WINLOAD_Init_Order		EQU	060000000h
VMPoll_Init_Order		EQU	064000000h

Undefined_Init_Order		EQU	080000000h

WINDEBUG_Init_Order		EQU	081000000h
VDMAD_Init_Order		EQU	090000000h
V86MMGR_Init_Order		EQU	0A0000000h

Undef_Touch_Mem_Init_Order	EQU	0A8000000h  ; Device that must touch
						    ; memory in 1st Mb at
						    ; crit init (after V86mmgr)
SHELL_Init_Order		EQU	0B0000000h
EndDoc

;******************************************************************************
;
;   Macro to cause a delay in between I/O accesses to the same device.
;
;------------------------------------------------------------------------------

IO_Delay    macro
jmp $+2
ENDM

Pushad_Struc	STRUC
Pushad_EDI	dd	?		; Client's EDI
Pushad_ESI	dd	?		; Client's ESI
Pushad_EBP	dd	?		; Client's EBP
Pushad_ESP	dd	?		; ESP at pushall
Pushad_EBX	dd	?		; Client's EBX
Pushad_EDX	dd	?		; Client's EDX
Pushad_ECX	dd	?		; Client's ECX
Pushad_EAX	dd	?		; Client's EAX
Pushad_Struc	ENDS



IFNDEF Not_VxD

??_CUR_CODE_SEG = 0


??_CODE  = 1
??_ICODE = 2
??_LCODE = 3
??_RCODE = 4

?_CODE	equ <(??_CUR_CODE_SEG MOD 8) - ??_CODE>
?_ICODE equ <(??_CUR_CODE_SEG MOD 8) - ??_ICODE>
?_LCODE equ <(??_CUR_CODE_SEG MOD 8) - ??_LCODE>
?_RCODE equ <(??_CUR_CODE_SEG MOD 8) - ??_RCODE>

;
;  SEGMENT definitions and order
;

;*	32 Bit locked code
_LTEXT		SEGMENT DWORD USE32 PUBLIC 'CODE'
_LTEXT		ENDS

;*	32 Bit code
_TEXT		SEGMENT DWORD USE32 PUBLIC 'PCODE'
_TEXT		ENDS

;*	32 Bit initialization code
_ITEXT		SEGMENT DWORD USE32 PUBLIC 'ICODE'
_ITEXT		ENDS

;*	Contains 32 Bit locked data
_LDATA		SEGMENT DWORD PUBLIC 'CODE'
_LDATA		ENDS

;*	Contains 32 Bit data
_DATA		SEGMENT DWORD PUBLIC 'PCODE'
_DATA		ENDS

;*	Contains 32 Bit initialization data
_IDATA		SEGMENT DWORD PUBLIC 'ICODE'
_IDATA		ENDS

;*	Real Mode initialization code/data for devices
_RCODE		SEGMENT WORD USE16 PUBLIC 'RCODE'
_RCODE		ENDS


_LGROUP GROUP _LTEXT, _LDATA
_PGROUP GROUP _TEXT, _DATA
_IGROUP GROUP _ITEXT, _IDATA

	ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT


OFFSET32 EQU <OFFSET FLAT:>


BeginDoc
;==============================================================================
; The following macros are used in defining the routines
;   in a VxD which are going to be registered with VMM as callable entry
;   points. Once registered, the entry points can be called by any other
;   devices via the "VxDCall" macro, defined below. In the comments below,
;   replace "VxD" with the appropriate device name.
;
;*******
;   In the VxD.INC file, put the following lines, replacing <function_name>
;	with an appropriate name describing the function of the routine.
;
;	Begin_Service_Table VxD[,<segname>]
;	VxD_Service <function_name>[,<local segname>]
;	VxD_Service <function_name>[,<local segname>]
;		. . .
;	VxD_Service <function_name>[,<local segname>]
;	End_Service_Table   VxD[,<segname>]
;
;   Note that <segname> is an optional argument and, if specified, the
;	table is put in the segment defined by the macro "yyy_Data_Seg",
;	where yyy=segname. Otherwise the segment is defined by the
;	"VxD_Data_Seg" macro, defined below.
;   Note that <local segname> is an optional argument and, if specified,
;	the procedure's segment is defined by the macro "zzz_Code_Seg",
;	where zzz=segname. Otherwise the segment is defined by the
;	"VxD_Code_Seg" macro, defined below.
;
;*******
; One VxD module should have the following in order to define the entry points:
;Create_VxD_Service_Table = 1			; Only in module where table is
;	INCLUDE     VxD.INC			; Include the table definition
;
;*******
; All modules that want to call the services defined in the table should include
;   VxD.INC, but not define the label "Create_VxD_Service_Table". This
;   will define the service names to be used with the VxDCall macro.
;
EndDoc

Begin_Service_Table MACRO Device_Name, Def_Segment
IFB <Def_Segment>
	BST2 Device_Name, VxD
ELSE
	BST2 Device_Name, Def_Segment
ENDIF
	ENDM


BST2 MACRO Device_Name, Def_Segment

Num_&Device_Name&_Services = 0

IFDEF Create_&Device_Name&_Service_Table
Def_Segment&_LOCKED_DATA_SEG
Device_Name&_Service_Table LABEL DWORD

Device_Name&_Service MACRO Procedure, Local_Seg, Condition
LOCAL $$&&Procedure
  IFNB <Condition>
  $$&&Procedure MACRO extern
    IFDEF &Condition
      IFNB <extern>
	EXTRN	@&&Procedure:NEAR
      ELSE
	dd	OFFSET32 @&&Procedure
      ENDIF
    ELSE
      IFB <extern>
      dd      0
      ENDIF
    ENDIF
    ENDM
  ENDIF

  IFDIFI <Procedure>, <RESERVED>
    PUBLIC $&&Procedure
    IF1
    $&&Procedure LABEL DWORD
    ENDIF
    IFDIFI <Local_Seg>, <LOCAL>
	IFNB <Local_Seg>
Local_Seg&&_SEG
	ELSE
Def_Segment&_CODE_SEG
	ENDIF
	IFNB <Condition>
	$$&&Procedure extern
	ELSE
	EXTRN	@&&Procedure:NEAR
	ENDIF
	IFNB <Local_Seg>
Local_Seg&&_ENDS
	ELSE
Def_Segment&_CODE_ENDS
	ENDIF
    ENDIF
	IFNB <Condition>
	$$&&Procedure
	ELSE
	dd	OFFSET32 @&&Procedure
	ENDIF
	Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
  ELSE
	dd  0
  ENDIF
	Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
  IFNB <Condition>
    Purge $$&&Procedure
  ENDIF
	ENDM

ELSE

Device_Name&_Service MACRO Procedure
  IFDIFI <Procedure>, <RESERVED>
	Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
	Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
	ENDM

ENDIF
	ENDM

;------------------------------------------------------------------------------

End_Service_Table MACRO Device_Name, Def_Segment

	PURGE	Device_Name&_Service

IFDEF Create_&Device_Name&_Service_Table
IFB <Def_Segment>
VxD_LOCKED_DATA_ENDS
ELSE
Def_Segment&_LOCKED_DATA_ENDS
ENDIF
ENDIF

	ENDM


;******************************************************************************
;
;   Dword_Align -- Aligns code to dword boundry by inserting nops
;
;------------------------------------------------------------------------------

Dword_Align MACRO Seg_Name
	LOCAL segn
IFNB <Seg_Name>
	segn equ Seg_Name
ELSE
IFE ?_CODE
	segn equ <_TEXT>
ELSE
IFE ?_ICODE
	segn equ <_ITEXT>
ELSE
IFE ?_LCODE
	segn equ <_LTEXT>
ELSE
.err Dword_Align not supported
ENDIF
ENDIF
ENDIF
ENDIF
IF (($-OFFSET segn:0) MOD 4)
db 4 - (($-OFFSET segn:0) MOD 4) DUP (90h)
ENDIF
	    ENDM


BeginDoc
;******************************************************************************
;
;   Fatal_Error
;
;   DESCRIPTION:
;	This macro is used to crash Windows/386 when an unrecoverable error
;	is detected.  If Msg_Ptr is ommitted then no error message will be
;	displayed, otherwise Msg_Ptr is the address
;	when the
;
;   PARAMETERS:
;	Msg_Ptr (OPTIONAL) - Points to an ASCIIZ string to display.
;
;   EXIT:
;	To DOS (hopefully).  This macro never returns.
;
;==============================================================================
EndDoc

Fatal_Error MACRO Msg_Ptr, Exit_Flags
	pushad
IFB <Msg_Ptr>
	xor	esi, esi
ELSE
	mov	esi, Msg_Ptr
IFB <Exit_Flags>
	xor	eax, eax
ELSE
	mov	eax, Exit_Flags
ENDIF
ENDIF
	VMMcall Fatal_Error_Handler
	ENDM

EF_Hang_On_Exit     EQU     1h


;******************************************************************************
;==============================================================================
;------------------------------------------------------------------------------

BeginDoc
;******************************************************************************
;   The following are control block offsets of items that can be of interest
;	to VxDs.
;*******
; VM status indicates globally interesting VM states
CB_VM_Status		EQU	DWORD PTR 00h

VMStat_Exclusive	EQU	000000000000000000001b	; VM is exclusive mode
VMStat_Exclusive_Bit	EQU	0
VMStat_Background	EQU	000000000000000000010b	; VM runs in background
VMStat_Background_Bit	EQU	1
VMStat_Creating 	EQU	000000000000000000100b	; In process of creating
VMStat_Creating_Bit	EQU	2
VMStat_Suspended	EQU	000000000000000001000b	; VM not scheduled
VMStat_Suspended_Bit	EQU	3
VMStat_Not_Executeable	EQU	000000000000000010000b	; VM partially destroyed
VMStat_Not_Executeable_Bit  EQU 4
VMStat_PM_Exec		EQU	000000000000000100000b	; Currently in PM app
VMStat_PM_Exec_Bit	EQU	5
VMStat_PM_App		EQU	000000000000001000000b	; PM app present in VM
VMStat_PM_App_Bit	EQU	6
VMStat_PM_Use32 	EQU	000000000000010000000b	; PM app is 32-bit
VMStat_PM_Use32_Bit	EQU	7
VMStat_VxD_Exec 	EQU	000000000000100000000b	; Call from VxD
VMStat_VxD_Exec_Bit	EQU	8
VMStat_High_Pri_Back	EQU	000000000001000000000b	; High pri background
VMStat_High_Pri_Back_Bit    EQU 9
VMStat_Blocked		EQU	000000000010000000000b	; Blocked on semaphore
VMStat_Blocked_Bit	EQU	0Ah
VMStat_Awakening	EQU	000000000100000000000b	; Woke up after blocked
VMStat_Awakening_Bit	EQU	0Bh
VMStat_PageableV86	EQU	000000001000000000000b	; part of V86 is pageable (PM app)
VMStat_PageableV86Bit	EQU	0Ch
VMStat_V86IntsLocked	EQU	000000010000000000000b	; Rest of V86 is locked
VMStat_V86IntsLockedBit EQU	0Dh			;  regardless of pager type
VMStat_TS_Sched 	EQU	000000100000000000000b	; Scheduled by time-slicer
VMStat_TS_Sched_Bit	EQU	0Eh
VMStat_Idle		EQU	000001000000000000000b	; VM has released time
VMStat_Idle_Bit 	EQU	0Fh			; slice
VMStat_Closing		EQU	000010000000000000000b	; Close_VM called for VM
VMStat_Closing_Bit	EQU	10h

VMStat_Use32_Mask	EQU	VMStat_PM_Use32 OR VMStat_VxD_Exec


;*******
; Add this value to a V86 linear address to get address of VM's memory in
;	the VMM linear address space
CB_High_Linear		EQU	DWORD PTR 04h

;*******
CB_Client_Pointer	EQU	DWORD PTR 08h

CB_VMID 		EQU	DWORD PTR 0Ch

;
;   Equates for protected mode application control blocks
;
PMCB_Flags		EQU	DWORD PTR 00h
PMCB_Parent		EQU	DWORD PTR 04h
EndDoc

;******************************************************************************
;			    V M M   S E R V I C E S
;******************************************************************************

Begin_Service_Table VMM, VMM

VMM_Service	Get_VMM_Version, LOCAL		; MUST REMAIN SERVICE 0!

VMM_Service	Get_Cur_VM_Handle
VMM_Service	Test_Cur_VM_Handle
VMM_Service	Get_Sys_VM_Handle
VMM_Service	Test_Sys_VM_Handle
VMM_Service	Validate_VM_Handle

VMM_Service	Get_VMM_Reenter_Count
VMM_Service	Begin_Reentrant_Execution
VMM_Service	End_Reentrant_Execution

VMM_Service	Install_V86_Break_Point
VMM_Service	Remove_V86_Break_Point
VMM_Service	Allocate_V86_Call_Back
VMM_Service	Allocate_PM_Call_Back

VMM_Service	Call_When_VM_Returns


VMM_Service	Schedule_Global_Event
VMM_Service	Schedule_VM_Event
VMM_Service	Call_Global_Event
VMM_Service	Call_VM_Event
VMM_Service	Cancel_Global_Event
VMM_Service	Cancel_VM_Event
VMM_Service	Call_Priority_VM_Event
VMM_Service	Cancel_Priority_VM_Event

VMM_Service	Get_NMI_Handler_Addr
VMM_Service	Set_NMI_Handler_Addr
VMM_Service	Hook_NMI_Event

VMM_Service	Call_When_VM_Ints_Enabled
VMM_Service	Enable_VM_Ints
VMM_Service	Disable_VM_Ints

VMM_Service	Map_Flat
VMM_Service	Map_Lin_To_VM_Addr

;
;   Scheduler services
;
VMM_Service	Adjust_Exec_Priority
VMM_Service	Begin_Critical_Section
VMM_Service	End_Critical_Section
VMM_Service	End_Crit_And_Suspend
VMM_Service	Claim_Critical_Section
VMM_Service	Release_Critical_Section
VMM_Service	Call_When_Not_Critical
VMM_Service	Create_Semaphore
VMM_Service	Destroy_Semaphore
VMM_Service	Wait_Semaphore
VMM_Service	Signal_Semaphore
VMM_Service	Get_Crit_Section_Status
VMM_Service	Call_When_Task_Switched
VMM_Service	Suspend_VM
VMM_Service	Resume_VM
VMM_Service	No_Fail_Resume_VM
VMM_Service	Nuke_VM
VMM_Service	Crash_Cur_VM

VMM_Service	Get_Execution_Focus
VMM_Service	Set_Execution_Focus
VMM_Service	Get_Time_Slice_Priority
VMM_Service	Set_Time_Slice_Priority
VMM_Service	Get_Time_Slice_Granularity
VMM_Service	Set_Time_Slice_Granularity
VMM_Service	Get_Time_Slice_Info
VMM_Service	Adjust_Execution_Time
VMM_Service	Release_Time_Slice
VMM_Service	Wake_Up_VM
VMM_Service	Call_When_Idle

VMM_Service	Get_Next_VM_Handle

;
;   Time-out and system timer services
;
VMM_Service	Set_Global_Time_Out
VMM_Service	Set_VM_Time_Out
VMM_Service	Cancel_Time_Out
VMM_Service	Get_System_Time
VMM_Service	Get_VM_Exec_Time

VMM_Service	Hook_V86_Int_Chain
VMM_Service	Get_V86_Int_Vector
VMM_Service	Set_V86_Int_Vector
VMM_Service	Get_PM_Int_Vector
VMM_Service	Set_PM_Int_Vector

VMM_Service	Simulate_Int
VMM_Service	Simulate_Iret
VMM_Service	Simulate_Far_Call
VMM_Service	Simulate_Far_Jmp
VMM_Service	Simulate_Far_Ret
VMM_Service	Simulate_Far_Ret_N
VMM_Service	Build_Int_Stack_Frame

VMM_Service	Simulate_Push
VMM_Service	Simulate_Pop

;
; Heap Manager
;
VMM_Service	_HeapAllocate
VMM_Service	_HeapReAllocate
VMM_Service	_HeapFree
VMM_Service	_HeapGetSize

; ---------------------------------------------------
;
;	 Flags for heap allocator calls
;
; ---------------------------------------------------


HeapZeroInit	equ	00000000000000000000000000000001B
HeapZeroReInit	equ	00000000000000000000000000000010B
HeapNoCopy	equ	00000000000000000000000000000100B

; NOTE: HIGH 8 BITS (bits 24-31) are reserved


;
; Page Manager
;
VMM_Service	_PageAllocate
VMM_Service	_PageReAllocate
VMM_Service	_PageFree
VMM_Service	_PageLock
VMM_Service	_PageUnLock
VMM_Service	_PageGetSizeAddr
VMM_Service	_PageGetAllocInfo
VMM_Service	_GetFreePageCount
VMM_Service	_GetSysPageCount
VMM_Service	_GetVMPgCount
VMM_Service	_MapIntoV86
VMM_Service	_PhysIntoV86
VMM_Service	_TestGlobalV86Mem
VMM_Service	_ModifyPageBits
VMM_Service	_CopyPageTable
VMM_Service	_LinMapIntoV86
VMM_Service	_LinPageLock
VMM_Service	_LinPageUnLock
VMM_Service	_SetResetV86Pageable
VMM_Service	_GetV86PageableArray
VMM_Service	_PageCheckLinRange
VMM_Service	_PageOutDirtyPages
VMM_Service	_PageDiscardPages

; ---------------------------------------------------
;
;	 Flags for other page allocator calls
;
; ---------------------------------------------------
PageZeroInit		equ	00000000000000000000000000000001B
PageUseAlign		equ	00000000000000000000000000000010B
PageContig		equ	00000000000000000000000000000100B
PageFixed		equ	00000000000000000000000000001000B
PageDEBUGNulFault	equ	00000000000000000000000000010000B
PageZeroReInit		equ	00000000000000000000000000100000B
PageNoCopy		equ	00000000000000000000000001000000B
PageLocked		equ	00000000000000000000000010000000B
PageLockedIfDP		equ	00000000000000000000000100000000B
PageSetV86Pageable	equ	00000000000000000000001000000000B
PageClearV86Pageable	equ	00000000000000000000010000000000B
PageSetV86IntsLocked	equ	00000000000000000000100000000000B
PageClearV86IntsLocked	equ	00000000000000000001000000000000B
PageMarkPageOut 	equ	00000000000000000010000000000000B
PagePDPSetBase		equ	00000000000000000100000000000000B
PagePDPClearBase	equ	00000000000000001000000000000000B
PageDiscard		equ	00000000000000010000000000000000B
PagePDPQueryDirty	equ	00000000000000100000000000000000B
;
; New for 3.10
;
PageMapFreePhysReg	equ	00000000000001000000000000000000B



; NOTE: HIGH 8 BITS (bits 24-31) are reserved

;
; Informational services
;
VMM_Service	_GetNulPageHandle
VMM_Service	_GetFirstV86Page
VMM_Service	_MapPhysToLinear
VMM_Service	_GetAppFlatDSAlias
VMM_Service	_SelectorMapFlat
VMM_Service	_GetDemandPageInfo
;
; Data structure for _GetDemandPageInfo
;
DemandInfoStruc struc
DILin_Total_Count     dd	      ?       ; # pages in linear address space
DIPhys_Count	      dd	      ?       ; Count of phys pages
DIFree_Count	      dd	      ?       ; Count of free phys pages
DIUnlock_Count	      dd	      ?       ; Count of unlocked Phys Pages
DILinear_Base_Addr    dd	      ?       ; Base of pageable address space
DILin_Total_Free      dd	      ?       ; Total Count of free linear pages
DIReserved	      dd      10 dup (?)      ; Resvd for expansion
DemandInfoStruc ends

VMM_Service	_GetSetPageOutCount
;
; Flags bits for _GetSetPageOutCount
;
GSPOC_F_Get	equ	00000000000000000000000000000001B

;
; Device VM page manager
;
VMM_Service	Hook_V86_Page
VMM_Service	_Assign_Device_V86_Pages
VMM_Service	_DeAssign_Device_V86_Pages
VMM_Service	_Get_Device_V86_Pages_Array
VMM_Service	MMGR_SetNULPageAddr

;
; GDT/LDT management
;
VMM_Service	_Allocate_GDT_Selector
VMM_Service	_Free_GDT_Selector
VMM_Service	_Allocate_LDT_Selector
VMM_Service	_Free_LDT_Selector
VMM_Service	_BuildDescriptorDWORDs
;
; Flag equates for _BuildDescriptorDWORDs
;
BDDExplicitDPL	EQU	00000000000000000000000000000001B
;
; Flag equates for _Allocate_LDT_Selector
;
ALDTSpecSel	EQU	00000000000000000000000000000001B

VMM_Service	_GetDescriptor
VMM_Service	_SetDescriptor


VMM_Service	_MMGR_Toggle_HMA
;
; Flag equates for _MMGR_Toggle_HMA
;
MMGRHMAPhysical EQU	00000000000000000000000000000001B
MMGRHMAEnable	EQU	00000000000000000000000000000010B
MMGRHMADisable	EQU	00000000000000000000000000000100B
MMGRHMAQuery	EQU	00000000000000000000000000001000B


VMM_Service	Get_Fault_Hook_Addrs
VMM_Service	Hook_V86_Fault
VMM_Service	Hook_PM_Fault
VMM_Service	Hook_VMM_Fault
VMM_Service	Begin_Nest_V86_Exec
VMM_Service	Begin_Nest_Exec
VMM_Service	Exec_Int
VMM_Service	Resume_Exec
VMM_Service	End_Nest_Exec

VMM_Service	Allocate_PM_App_CB_Area, VMM_ICODE
VMM_Service	Get_Cur_PM_App_CB

VMM_Service	Set_V86_Exec_Mode
VMM_Service	Set_PM_Exec_Mode

VMM_Service	Begin_Use_Locked_PM_Stack
VMM_Service	End_Use_Locked_PM_Stack

VMM_Service	Save_Client_State
VMM_Service	Restore_Client_State

VMM_Service	Exec_VxD_Int

VMM_Service	Hook_Device_Service

VMM_Service	Hook_Device_V86_API
VMM_Service	Hook_Device_PM_API

VMM_Service	System_Control

;
;   I/O and software interrupt hooks
;
VMM_Service	Simulate_IO
VMM_Service	Install_Mult_IO_Handlers
VMM_Service	Install_IO_Handler
VMM_Service	Enable_Global_Trapping
VMM_Service	Enable_Local_Trapping
VMM_Service	Disable_Global_Trapping
VMM_Service	Disable_Local_Trapping


;
;   Linked List Abstract Data Type Services
;
VMM_Service	List_Create
VMM_Service	List_Destroy
VMM_Service	List_Allocate
VMM_Service	List_Attach
VMM_Service	List_Attach_Tail
VMM_Service	List_Insert
VMM_Service	List_Remove
VMM_Service	List_Deallocate
VMM_Service	List_Get_First
VMM_Service	List_Get_Next
VMM_Service	List_Remove_First

;
;   Flags used by List_Create
;
LF_Async		EQU	00000001b
LF_Async_Bit		EQU	0
LF_Use_Heap		EQU	00000010b
LF_Use_Heap_Bit 	EQU	1
LF_Alloc_Error		EQU	00000100b
LF_Alloc_Error_Bit	EQU	2


;==============================================================================
;	I N I T I A L I Z A T I O N   P R O C E D U R E S
;------------------------------------------------------------------------------


;
; Instance data manager
;
VMM_Service	_AddInstanceItem
;
; Data structure for _AddInstanceItem
;
InstDataStruc struc
InstLinkF	      dd	      0       ; RESERVED SET TO 0
InstLinkB	      dd	      0       ; RESERVED SET TO 0
InstLinAddr	      dd	      ?       ; Linear address of start of block
InstSize	      dd	      ?       ; Size of block in bytes
InstType	      dd	      ?       ; Type of block
InstDataStruc ends
;
; Values for InstType
;
INDOS_Field	equ	100h	; Bit indicating INDOS switch requirements
ALWAYS_Field	equ	200h	; Bit indicating ALWAYS switch requirements

;
; System structure data manager
;
VMM_Service	_Allocate_Device_CB_Area, VMM_ICODE
VMM_Service	_Allocate_Global_V86_Data_Area, VMM_ICODE
VMM_Service	_Allocate_Temp_V86_Data_Area, VMM_ICODE
VMM_Service	_Free_Temp_V86_Data_Area, VMM_ICODE

;
; Flag bits for _Allocate_Global_V86_Data_Area
;
GVDAWordAlign		EQU		00000000000000000000000000000001B
GVDADWordAlign		EQU		00000000000000000000000000000010B
GVDAParaAlign		EQU		00000000000000000000000000000100B
GVDAPageAlign		EQU		00000000000000000000000000001000B
GVDAInstance		EQU		00000000000000000000000100000000B
GVDAZeroInit		EQU		00000000000000000000001000000000B
GVDAReclaim		EQU		00000000000000000000010000000000B
;
; New for 3.10
;
GVDAInquire		EQU		00000000000000000000100000000000B
GVDAHighSysCritOK	EQU		00000000000000000001000000000000B

;
; Initialization information calls (win.ini and environment parameters)
;
VMM_Service	Get_Profile_Decimal_Int, VMM_ICODE
VMM_Service	Convert_Decimal_String, VMM_ICODE
VMM_Service	Get_Profile_Fixed_Point, VMM_ICODE
VMM_Service	Convert_Fixed_Point_String, VMM_ICODE
VMM_Service	Get_Profile_Hex_Int, VMM_ICODE
VMM_Service	Convert_Hex_String, VMM_ICODE
VMM_Service	Get_Profile_Boolean, VMM_ICODE
VMM_Service	Convert_Boolean_String, VMM_ICODE
VMM_Service	Get_Profile_String, VMM_ICODE
VMM_Service	Get_Next_Profile_String, VMM_ICODE
VMM_Service	Get_Environment_String, VMM_ICODE
VMM_Service	Get_Exec_Path, VMM_ICODE
VMM_Service	Get_Config_Directory, VMM_ICODE
VMM_Service	OpenFile, VMM_ICODE
VMM_Service	Get_PSP_Segment, VMM_ICODE
VMM_Service	GetDOSVectors, VMM_ICODE
VMM_Service	Get_Machine_Info

GMIF_80486	EQU	00010000h
GMIF_80486_Bit	EQU	10h
GMIF_PCXT	EQU	00020000h
GMIF_PCXT_Bit	EQU	11h
GMIF_MCA	EQU	00040000h
GMIF_MCA_Bit	EQU	12h
GMIF_EISA	EQU	00080000h
GMIF_EISA_Bit	EQU	13h


;
; Following service is not restricted to initialization
;
VMM_Service	GetSet_HMA_Info
VMM_Service	Set_System_Exit_Code

VMM_Service	Fatal_Error_Handler
VMM_Service	Fatal_Memory_Error

;
;   Called by VTD only
;
VMM_Service	Update_System_Clock

;==============================================================================
;		    D E B U G G I N G	E X T E R N S
;==============================================================================

VMM_Service	Test_Debug_Installed		; Valid call in retail also

VMM_Service	Out_Debug_String		; Valid in DEBLEVEL=1
VMM_Service	Out_Debug_Chr
VMM_Service	In_Debug_Chr
VMM_Service	Debug_Convert_Hex_Binary
VMM_Service	Debug_Convert_Hex_Decimal

VMM_Service	Debug_Test_Valid_Handle
VMM_Service	Validate_Client_Ptr
VMM_Service	Test_Reenter
VMM_Service	Queue_Debug_String
VMM_Service	Log_Proc_Call
VMM_Service	Debug_Test_Cur_VM

VMM_Service	Get_PM_Int_Type
VMM_Service	Set_PM_Int_Type

VMM_Service	Get_Last_Updated_System_Time
VMM_Service	Get_Last_Updated_VM_Exec_Time

; for DBCS Enabling
VMM_Service	Test_DBCS_Lead_Byte

.errnz	Test_DBCS_Lead_Byte - 100D1h   ; VMM service table changed above this service

;*************************************************************************
;*************************************************************************
;*************************************************************************
;
; END OF 3.00 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
;	FOR COMPATIBILITY.
;

VMM_Service	_AddFreePhysPage, VMM_ICODE
VMM_Service	_PageResetHandlePAddr
VMM_Service	_SetLastV86Page, VMM_ICODE
VMM_Service	_GetLastV86Page
VMM_Service	_MapFreePhysReg
VMM_Service	_UnmapFreePhysReg
VMM_Service	_XchgFreePhysReg
VMM_Service	_SetFreePhysRegCalBk, VMM_ICODE
VMM_Service	Get_Next_Arena, VMM_ICODE
VMM_Service	Get_Name_Of_Ugly_TSR, VMM_ICODE
VMM_Service	Get_Debug_Options, VMM_ICODE

;
; Bits for the ECX return of Get_Next_Arena
;
GNA_HiDOSLinked  equ	 0000000000000010B	; High DOS arenas were linked in
						;   when WIN386 was started
GNA_IsHighDOS	 equ	 0000000000000100B	; High DOS arenas do exist

VMM_Service	Set_Physical_HMA_Alias, VMM_ICODE
VMM_Service	_GetGlblRng0V86IntBase, VMM_ICODE
VMM_Service	_Add_Global_V86_Data_Area, VMM_ICODE

VMM_Service	GetSetDetailedVMError
;
; Error code values for the GetSetDetailedVMError service. PLEASE NOTE
;   that all of these error code values need to have bits set in the high
;   word. This is to prevent collisions with other VMDOSAPP standard errors.
;   Also, the low word must be non-zero.
;
; First set of errors (high word = 0001) are intended to be used
;   when a VM is CRASHED (VNE_Crashed or VNE_Nuked bit set on
;   VM_Not_Executeable).
;
; PLEASE NOTE that each of these errors (high word == 0001) actually
;   has two forms:
;
;	0001xxxxh
;	8001xxxxh
;
;   The device which sets the error initially always sets the error with
;   the high bit CLEAR. The system will then optionally set the high bit
;   depending on the result of the attempt to "nicely" crash the VM. This
;   bit allows the system to tell the user whether the crash is likely or
;   unlikely to destabalize the system.
;
GSDVME_PrivInst 	equ	00010001h	; Privledged instruction
GSDVME_InvalInst	equ	00010002h	; Invalid instruction
GSDVME_InvalPgFlt	equ	00010003h	; Invalid page fault
GSDVME_InvalGpFlt	equ	00010004h	; Invalid GP fault
GSDVME_InvalFlt 	equ	00010005h	; Invalid fault, not any of abv
GSDVME_UserNuke 	equ	00010006h	; User requested NUKE of running
						;    VM
GSDVME_DevNuke		equ	00010007h	; Device specific problem
GSDVME_DevNukeHdwr	equ	00010008h	; Device specific problem,
						;   invalid hardware fiddling
						;   by VM (invalid I/O)
GSDVME_NukeNoMsg	equ	00010009h	; Supress standard messgs,
						;   SHELL_Message used for
						;   custom msg.

GSDVME_OkNukeMask	equ	80000000h	; "Nice nuke" bit

;
; Second set of errors (high word = 0002) are intended to be used
;   when a VM start up is failed (VNE_CreateFail, VNE_CrInitFail, or
;   VNE_InitFail bit set on VM_Not_Executeable).
;
GSDVME_InsMemV86	equ	00020001h	; base V86 mem	   - V86MMGR
GSDVME_InsV86Space	equ	00020002h	; Kb Req too large - V86MMGR
GSDVME_InsMemXMS	equ	00020003h	; XMS Kb Req	   - V86MMGR
GSDVME_InsMemEMS	equ	00020004h	; EMS Kb Req	   - V86MMGR
GSDVME_InsMemV86Hi	equ	00020005h	; Hi DOS V86 mem   - DOSMGR
						;		     V86MMGR
GSDVME_InsMemVid	equ	00020006h	; Base Video mem   - VDD
GSDVME_InsMemVM 	equ	00020007h	; Base VM mem	   - VMM
						;   CB, Inst Buffer
GSDVME_InsMemDev	equ	00020008h	; Couldn't alloc base VM
						;   memory for device.
GSDVME_CrtNoMsg 	equ	00020009h	; Supress standard messgs,
						;   SHELL_Message used for
						;   custom msg.
VMM_Service	Is_Debug_Chr
;
; Mono_Out services
;
VMM_Service	Clear_Mono_Screen
VMM_Service	Out_Mono_Chr
VMM_Service	Out_Mono_String
VMM_Service	Set_Mono_Cur_Pos
VMM_Service	Get_Mono_Cur_Pos
VMM_Service	Get_Mono_Chr

;
;   Service locates a byte in ROM
;
VMM_Service	Locate_Byte_In_ROM, VMM_ICODE

VMM_Service	Hook_Invalid_Page_Fault
VMM_Service	Unhook_Invalid_Page_Fault
;
; This is the structure of the "invalid page fault information"
; which is pointed to by EDI when Invalid page fault hookers
; are called.
;
; page faults can occur on a VM which is not current by touching the VM at
;   its high linear address. In this case, IPF_FaultingVM may not = the
;   current VM, it will be set to the VM whos high linear address was touched.
;
IPF_Data	struc

  IPF_LinAddr	    dd	    ?	; CR2 address of fault
  IPF_MapPageNum    dd	    ?	; Possible converted page # of fault
  IPF_PTEEntry	    dd	    ?	; Contents of PTE that faulted
  IPF_FaultingVM    dd	    ?	; May not = Current VM (IPF_V86PgH set)
  IPF_Flags	    dd	    ?	; Flags

IPF_Data	ends
;
; Flag bits of IPF_Flags
;
			; Page directory entry not-present (not pres page table)
IPF_PgDir	equ	000000000000000000000000000000001b
			; Unexpected not present Page in V86
IPF_V86Pg	equ	000000000000000000000000000000010b
			; Unexpected not present Page in V86 at high linear
IPF_V86PgH	equ	000000000000000000000000000000100b
			; page has invalid not present type
IPF_InvTyp	equ	000000000000000000000000000001000b
			; pageswap device couldn't page for some reason
IPF_PgErr	equ	000000000000000000000000000010000b
			; re-entrant page fault
IPF_ReFlt	equ	000000000000000000000000000100000b
			; Page fault caused by a VxD
IPF_VMM 	equ	000000000000000000000000001000000b
			; Page fault caused by VM running in Prot Mode
IPF_PM		equ	000000000000000000000000010000000b
			; Page fault caused by VM running in V86 Mode
IPF_V86 	equ	000000000000000000000000100000000b

VMM_Service	Set_Delete_On_Exit_File

VMM_Service	Close_VM
;
;   Flags for Close_VM service
;
CVF_Continue_Exec   equ 00000001b
CVF_Continue_Exec_Bit equ 0

VMM_Service	Enable_Touch_1st_Meg		; Debugging only
VMM_Service	Disable_Touch_1st_Meg		; Debugging only

VMM_Service	Install_Exception_Handler
VMM_Service	Remove_Exception_Handler

Exception_Handler_Struc STRUC
EH_Reserved	dd	?
EH_Start_EIP	dd	?
EH_End_EIP	dd	?
EH_Handler	dd	?
Exception_Handler_Struc ENDS

VMM_Service	Get_Crit_Status_No_Block

.errnz	 Get_Crit_Status_No_Block - 100F1h   ; VMM service table changed above this service

;*************************************************************************
;*************************************************************************
;*************************************************************************
;
; END OF 3.10 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
;	FOR COMPATIBILITY.
;


End_Service_Table VMM, VMM


;******************************************************************************

IFDEF DEBUG
DebFar	EQU	NEAR PTR
ELSE
DebFar	EQU	SHORT
ENDIF

BeginDoc

;******************************************************************************
;
;		     EQUATES FOR SYSTEM_CONTROL CALLS
;
;==============================================================================

;
; Sys_Critical_Init is a device init call. Devices that have a critical
;   function that needs initializing before interrupts are enabled should
;   do it at Sys_Critical_Init. Devices which REQUIRE a certain range of
;   V86 pages to operate (such as the VDD video memory) should claim them
;   at Sys_Critical_Init. SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT
;   ALLOWED. Returning carry aborts device load only.
;
Sys_Critical_Init	EQU	0000h		; Devices required for virt mode
;
; Device init is where most devices do the bulk of their initialization.
;   SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
;   aborts device load only.
;
Device_Init		EQU	0001h		; All other devices init
;
; Init_Complete is the final phase of device init called just before the
;   WIN386 INIT pages are released and the Instance snapshot is taken.
;   Devices which wish to search for a region of V86 pages >= A0h to use
;   should do it at Init_Complete.
;   SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
;   aborts device load only.
;
Init_Complete		EQU	0002h		; All devices have initialized

;----------------- INITIALIZATION CODE AND DATA DISCARDED ---------------------

;
; Same as VM_Init, except for SYS VM.
;
Sys_VM_Init		EQU	0003h		; Execute the system VM (Win86)
;
; Same as VM_Terminate, except for SYS VM (Normal WIN386 exit ONLY, on a crash
;   exit this call is not made). SYS VM Simulate_Int, Exec_Int activity is
;   allowed.
;
Sys_VM_Terminate	EQU	0004h		; System VM terminted (exiting)

;------------------------------------------------------------------------------

;
; System_Exit call is made when WIN386 is exiting either normally or via
;   a crash. INTERRUPS ARE ENABLED. Instance snapshot has been restored.
;   SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT ALLOWED.
;
System_Exit		EQU	0005h		; Devices prepare to exit
;
; System_Exit call is made when WIN386 is exiting either normally or via
;   a crash. INTERRUPS ARE DISABLED. SYS VM Simulate_Int, Exec_Int ACTIVITY
;   IS NOT ALLOWED.
;
Sys_Critical_Exit	EQU	0006h		; System critical devices reset

;
; Create_VM creates a new VM. EBX = VM handle of new VM. Returning Carry will
;   fail the Create_VM.
;
Create_VM		EQU	0007h
;
; Second phase of Create_VM. EBX = VM handle of new VM. Returning Carry will
;   cause the VM to go Not_Executeable, then be destroyed. VM Simulate_Int,
;   Exec_Int activity is NOT allowed.
;
VM_Critical_Init	EQU	0008h
;
; Third phase of Create_VM. EBX = VM handle of new VM. Returning Carry will
;   cause the VM to go Not_Executeable, then be destroyed. VM Simulate_Int,
;   Exec_Int activity is allowed.
;
VM_Init 		EQU	0009h

;
; NORMAL (First phase) of Destroy_VM. EBX = VM Hanlde. This occurs on normal
;   termination of the VM. Call cannot be failed. VM Simulate_Int, Exec_Int
;   activity is allowed.
;
VM_Terminate		EQU	000Ah		; Still in VM -- About to die
;
; Second phase of Destroy_VM. EBX = VM Handle, EDX = Flags (see below). Note
;   that in the case of destroying a running VM, this is the first call made
;   (VM_Terminate call does not occur). Call cannot be failed. VM Simulate_Int,
;   Exec_Int activity is NOT allowed.
;
VM_Not_Executeable	EQU	000Bh		; Most devices die (except VDD)
;
; Final phase of Destroy_VM. EBX = VM Handle. Note that considerable time
;   can elaps between the VM_Not_Executeable call and this call. Call cannot
;   be failed. VM Simulate_Int, Exec_Int activity is NOT allowed.
;
Destroy_VM		EQU	000Ch		; VM's control block about to go

;
;   Flags for VM_Not_Executeable control call (passed in EDX)
;
VNE_Crashed		EQU	0000000000000000000000001b
VNE_Crashed_Bit 	EQU	0		; VM was crashed
VNE_Nuked		EQU	0000000000000000000000010b
VNE_Nuked_Bit		EQU	1		; VM was destroyed while active
VNE_CreateFail		EQU	0000000000000000000000100b
VNE_CreateFail_Bit	EQU	2		; Some device failed Create_VM
VNE_CrInitFail		EQU	0000000000000000000001000b
VNE_CrInitFail_Bit	EQU	3		; Some device failed VM_Critical_Init
VNE_InitFail		EQU	0000000000000000000010000b
VNE_InitFail_Bit	EQU	4		; Some device failed VM_Init
VNE_Closed		EQU	0000000000000000000100000b
VNE_Closed_Bit		EQU	5

;------------------------------------------------------------------------------

;
; EBX = VM Handle. Call cannot be failed.
;
VM_Suspend		EQU	000Dh		; VM not runnable until resume
;
; EBX = VM Handle. Returning carry fails and backs out the resume.
;
VM_Resume		EQU	000Eh		; VM is leaving suspended state

;------------------------------------------------------------------------------

;
; EBX = VM Handle to set device focus to. EDX = Device ID if device specific
;   setfocus. == 0 if device critical setfocus (all devices). THIS CALL CANNOT
;   BE FAILED.
;
;   NOTE: In case where EDX == 0, ESI is a FLAG word that indicates special
;	  functions. Currently Bit 0 being set indicates that this Device
;	  critical set focus is also "VM critical". It means that we do not
;	  want some other VM to take the focus from this app now. This is
;	  primarily used when doing a device critical set focus to Windows
;	  (the SYS VM) it is interpreted by the SHELL to mean "if an old app
;	  currently has the Windows activation, set the activation to the
;	  Windows Shell, not back to the old app". ALSO in the case where
;	  Bit 0 is set, EDI = The VM handle of the VM that is "having trouble".
;	  Set this to 0 if there is no specific VM associated with the problem.
;
Set_Device_Focus	EQU	000Fh

;------------------------------------------------------------------------------

;
; EBX = VM Handle going into message mode. THIS CALL CANNOT BE FAILED.
;
Begin_Message_Mode	EQU	0010h
;
; EBX = VM Handle leaving message mode. THIS CALL CANNOT BE FAILED.
;
End_Message_Mode	EQU	0011h

;------------------------- SPECIAL CONTROL CALLS ------------------------------

;
; Request for reboot. Call cannot be failed.
;
Reboot_Processor	EQU	0012h		; Request a machine reboot
;
; Query_Destroy is an information call made by the SHELL device before an
;   attempt is made to initiate a destroy VM sequence on a running VM which
;   has not exited normally. EBX = VM Handle. Returning carry indicates that
;   a device "has a problem" with allowing this. THE DESTROY SEQUENCE CANNOT
;   BE ABORTED HOWEVER, this decision is up to the user. All this does is
;   indicate that there is a "problem" with allowing the destroy. The device
;   which returns carry should call the SHELL_Message service to post an
;   informational dialog about the reason for the problem.
;
Query_Destroy		EQU	0013h		; OK to destroy running VM?

;------------------------- DEBUGGING CONTROL CALL -----------------------------

;
; Special call for device specific DEBUG information display and activity.
;
Debug_Query		EQU	0014h

;---------- CALLS FOR BEGIN/END OF PROTECTED MODE VM EXECUTION ----------------

;
;   About to run a protected mode application.
;   EBX = Current VM handle.
;   EDX = Flags
;   EDI -> Application Control Block
;   Returning with carry set fails the call.
;
Begin_PM_App		EQU	0015h

;
;   Flags for Begin_PM_App (passed in EDX)
;
BPA_32_Bit		EQU	00000001b
BPA_32_Bit_Flag 	EQU	1

;
;   Protected mode application is terminating.
;   EBX = Current VM handle.  THIS CALL CAN NOT FAIL.
;   EDI -> Application Control Block
;
End_PM_App		EQU	0016h

;
;   Called whenever system is about to be rebooted.  Allows VxDs to clean
;   up in preperation for reboot.
;
Device_Reboot_Notify	EQU	0017h
Crit_Reboot_Notify	EQU	0018h

;
;   Called when VM is about to be termintate using the Close_VM service
;	EBX = Current VM handle (Handle of VM to close)
;	EDX = Flags
;	      CVNF_Crit_Close = 1 if VM is in critical section while closing
;
Close_VM_Notify 	EQU	0019h

CVNF_Crit_Close 	EQU	00000001b
CVNF_Crit_Close_Bit	EQU	0

;
;   Power management event notification.
;   EBX = 0
;   ESI = event notification message
;   EDI -> DWORD return value; VxD's modify the DWORD to return info, not EDI
;   EDX is reserved
;
Power_Event		EQU	001Ah


EndDoc

BeginDoc
;******************************************************************************
; BeginProc is a macro for defining entry points to routines in VMM and in the
;   VxDs. It correctly defines the procedure name for VxD services(it prepends
;   a "@" to the procedure name), DWORD aligns the procedure, takes care of
;   public declaration and does some calling verification for debug versions
;   of the software. EndProc is a macro which defines the end of the procedure.
;
; Valid parameters to the BeginProc macro are:
;	PUBLIC				; Routine used outside this module
;	HIGH_FREQ			; DWORD align procedure
;	SERVICE 			; Routine is called via VxDCall
;	ASYNC_SERVICE			; Same as "SERVICE" plus routine can
;					;	be called under interrupt.
; After the routine header in which the routine entry conditions, exit
;   conditions, side affects and functionality are specified, the BeginProc
;   macro should be used to define the routine's entry point. It has up to
;   four parameters as specified below. For example:
;
;BeginProc  <Function_Name>,PUBLIC, HIGH_FREQ, ASYNC_SERVICE
;
;	<code>
;
;EndProc    <Function_Name>
;==============================================================================
EndDoc

BeginProc MACRO Name, P1, P2, P3, P4
	LOCAL	Profile_Data, Skip_Data

IF ?_RCODE

Process_Param MACRO P
IFNB <P>
IFIDNI <P>, <HIGH_FREQ>
Dword_Align
ELSE
IFIDNI <P>, <SERVICE>
??_SERVICE = 1
ELSE
IFIDNI <P>, <ASYNC_SERVICE>
??_ASYNC_SERVICE = 1
IF ?_LCODE
%OUT ERROR:  ASYNC_SERVICE's must be in LOCKED code
;;.err
ENDIF
ELSE
IFIDNI <P>, <NO_LOG>
??_NO_LOG = 1
ELSE
IFDIFI <P>, <PUBLIC>
%OUT ERROR:  Bad para "&P" to BeginProc
.ERR
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM


??_SERVICE = 0
??_ASYNC_SERVICE = 0
??_NO_LOG = 0

Process_Param P1
Process_Param P2
Process_Param P3
Process_Param P4


IFE ??_SERVICE + ??_ASYNC_SERVICE

PUBLIC Name
Name PROC NEAR
IFDEF DEBUG
IFE ??_NO_LOG
IFNDEF VMMSYS
	VMMcall Log_Proc_Call
ENDIF
ENDIF
ENDIF

ELSE

IFDEF DEBUG
	jmp	SHORT Skip_Data
Profile_Data LABEL DWORD
	dd	0
Skip_Data:
ENDIF

PUBLIC @&Name
@&Name PROC NEAR

IFDEF DEBUG
IFE ??_NO_LOG
;;;;IFNDEF VMMSYS
	VMMcall Log_Proc_Call
;;;;ENDIF
ENDIF
	pushfd
	inc	[Profile_Data]
IFE ??_ASYNC_SERVICE
	VMMcall Test_Reenter
ENDIF
	popfd
ENDIF
ENDIF

ELSE
IFIDNI <P1>, <PUBLIC>
PUBLIC Name
ENDIF
Name PROC NEAR
ENDIF


	ENDM



EndProc MACRO Name
IFDEF @&Name
@&Name ENDP
ELSE
IFDEF Name
Name ENDP
ELSE
.ERR
%OUT EndProc for &Name does not match BeginProc
ENDIF
ENDIF
	ENDM


;******************************************************************************
;	       S C H E D U L E R   B O O S T   V A L U E S
;==============================================================================

Reserved_Low_Boost	EQU	00000000000000000000000000000001b
Cur_Run_VM_Boost	EQU	00000000000000000000000000000100b
Low_Pri_Device_Boost	EQU	00000000000000000000000000010000b
High_Pri_Device_Boost	EQU	00000000000000000001000000000000b
Critical_Section_Boost	EQU	00000000000100000000000000000000b
Time_Critical_Boost	EQU	00000000010000000000000000000000b
Reserved_High_Boost	EQU	01000000000000000000000000000000b


;******************************************************************************
;	 F L A G S   F O R   C A L L _ P R I O R I T Y _ V M _ E V E N T
;==============================================================================

PEF_Wait_For_STI	EQU	0000001b
PEF_Wait_For_STI_Bit	EQU	0
PEF_Wait_Not_Crit	EQU	0000010b
PEF_Wait_Not_Crit_Bit	EQU	1
PEF_Dont_Unboost	EQU	0000100b
PEF_Dont_Unboost_Bit	EQU	2
PEF_Always_Sched	EQU	0001000b
PEF_Always_Sched_Bit	EQU	3
PEF_Time_Out		EQU	0010000b
PEF_Time_Out_Bit	EQU	4

;******************************************************************************
;	 F L A G S   F O R   B E G I N _ C R I T I C A L _ S E C T I O N
;		       A N D   W A I T _ S E M A P H O R E
;==============================================================================

Block_Svc_Ints			EQU	0000001b
Block_Svc_Ints_Bit		EQU	0
Block_Svc_If_Ints_Locked	EQU	0000010b
Block_Svc_If_Ints_Locked_Bit	EQU	1
Block_Enable_Ints		EQU	0000100b
Block_Enable_Ints_Bit		EQU	2
Block_Poll			EQU	0001000b
Block_Poll_Bit			EQU	3



BeginDoc
;******************************************************************************
; The following structures are pointed to by EBP when VxD routines are entered,
;   both for VxD control calls and traps(I/O traps, software INT traps, etc.).
;   The first structure as DWORD values, the second WORD values and the last
;   has BYTE values.
;
Client_Reg_Struc   struc
Client_EDI	dd	?		; Client's EDI
Client_ESI	dd	?		; Client's ESI
Client_EBP	dd	?		; Client's EBP
		dd	?		; ESP at pushall
Client_EBX	dd	?		; Client's EBX
Client_EDX	dd	?		; Client's EDX
Client_ECX	dd	?		; Client's ECX
Client_EAX	dd	?		; Client's EAX
Client_Error	dd	?		; Dword error code
Client_EIP	dd	?		; EIP
Client_CS	dw	?		; CS
		dw	?		;   (padding)
Client_EFlags	dd	?		; EFLAGS
Client_ESP	dd	?		; ESP
Client_SS	dw	?		; SS
		dw	?		;   (padding)
Client_ES	dw	?		; ES
		dw	?		;   (padding)
Client_DS	dw	?		; DS
		dw	?		;   (padding)
Client_FS	dw	?		; FS
		dw	?		;   (padding)
Client_GS	dw	?		; GS
		dw	?		;   (padding)
Client_Alt_EIP	dd	?
Client_Alt_CS	dw	?
		dw	?
Client_Alt_EFlags  dd	?
Client_Alt_ESP	dd	?
Client_Alt_SS	dw	?
		dw	?
Client_Alt_ES	dw	?
		dw	?
Client_Alt_DS	dw	?
		dw	?
Client_Alt_FS	dw	?
		dw	?
Client_Alt_GS	dw	?
		dw	?
Client_Reg_Struc   ends


Client_Word_Reg_Struc	struc
Client_DI	dw	?		; Client's DI
		dw	?		;   (padding)
Client_SI	dw	?		; Client's SI
		dw	?		;   (padding)
Client_BP	dw	?		; Client's BP
		dw	?		;   (padding)
		dd	?		; ESP at pushall
Client_BX	dw	?		; Client's BX
		dw	?		;   (padding)
Client_DX	dw	?		; Client's DX
		dw	?		;   (padding)
Client_CX	dw	?		; Client's CX
		dw	?		;   (padding)
Client_AX	dw	?		; Client's AX
		dw	?		;   (padding)
		dd	?		; Dword error code
Client_IP	dw	?		; Client's IP
		dw	?		;   (padding)
		dd	?		; CS
Client_Flags	dw	?		; Client's flags (low)
		dw	?		;   (padding)
Client_SP	dw	?		; SP
		dw	?
		dd	5 dup (?)
Client_Alt_IP	dw	?
		dw	?
		dd	?
Client_Alt_Flags    dw	?
		dw	?
Client_Alt_SP	dw	?
Client_Word_Reg_Struc	ends



Client_Byte_Reg_Struc	struc
		dd	4 dup (?)	; EDI, ESI, EBP, ESP at pushall
Client_BL	db	?		; Client's BL
Client_BH	db	?		; Client's BH
		dw	?		;   (padding)
Client_DL	db	?		; Client's DL
Client_DH	db	?		; Client's DH
		dw	?		;   (padding)
Client_CL	db	?		; Client's CL
Client_CH	db	?		; Client's CH
		dw	?		;   (padding)
Client_AL	db	?		; Client's AL
Client_AH	db	?		; Client's AH
Client_Byte_Reg_Struc	ends

;==============================================================================
EndDoc

.ERRNZ Client_SP - Client_ESP
.ERRNZ Client_AL - Client_EAX



PushCParams MACRO P1, P2, P3, P4, P5, P6, P7, P8, P9, P10
	IRP Param, <P10, P9, P8, P7, P6, P5, P4, P3, P2, P1>
	IFNB <Param>
	push	Param
	ENDIF
	ENDM
	ENDM

ClearCParams MACRO Count, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10
IFNB <P1>
	ClearCParams %(Count+1), <P2>, <P3>, <P4>, <P5>, <P6>, <P7>, <P8>, <P9>, <P10>
ELSE
IF Count
	add	esp, Count*4
ENDIF
ENDIF
	ENDM



Dyna_Link_Int	EQU 20h

;
;
BeginDoc
;******************************************************************************
; The VMMCall and VxDCall macros provide a dynamic link to the VMM and VxD
;   service routines. For example:
;
;   VMMCall Enable_VM_Ints		; Equivalent to STI in VM code
;
;   mov     eax,[My_IRQ_Handle]
;   VxDCall VPICD_Set_Int_Request	; Set IRQ for my device's interrupt
;
; Note that Enable_VM_Ints is defined in VMM.INC and VPICD_Set_Int_Request is
;	defined in VPICD.INC
;
;==============================================================================
EndDoc


BeginDoc
;******************************************************************************
; VxDCall
;==============================================================================
EndDoc
VxDcall MACRO P, Param
	PushCParams Param
	int	Dyna_Link_Int
	dd	P
	ClearCParams 0, Param
	ENDM

VxDjmp	MACRO P, Param
IFNB <Param>
%OUT ERROR:  Parameters may not be passed to VxDjmp or VMMjmp macros
.ERR
ENDIF
	int	Dyna_Link_Int
IFDEF DEBUG
	dd	P
	ret
ELSE
	dd	P OR DL_Jmp_Mask
ENDIF
	ENDM

DL_Jmp_Mask	EQU	8000h
DL_Jmp_Bit	EQU	0Fh


VMMcall MACRO P, Param
	.ERRNZ (P SHR 16) - VMM_Device_ID
	VxDcall <P>, <Param>
	ENDM

VMMjmp MACRO P, Param
	.ERRNZ (P SHR 16) - VMM_Device_ID
	VxDjmp <P>, <Param>
	ENDM

cCall MACRO P, Param
	PushCParams Param
	call	P
	ClearCParams 0, Param
	ENDM


BeginDoc
;******************************************************************************
; Segment definition macros
;
; The segment definition macros are a convenience used in defining the
;	segments used by the device driver. They are:
;VxD_ICODE_SEG	 defines start of initialization code segment
;VxD_ICODE_ENDS  defines end of initialization code segment
;VxD_IDATA_SEG	 defines start of initialization data segment
;VxD_IDATA_ENDS  defines end of initialization data segment
;VxD_CODE_SEG	 defines start of always present code segment
;VxD_CODE_ENDS	 defines end of always present code segment
;VxD_DATA_SEG	 defines start of always present data segment
;VxD_DATA_ENDS	 defines end of always present data segment
;==============================================================================
EndDoc


;   Protected mode code
VxD_CODE_SEG	EQU <VxD_LOCKED_CODE_SEG>
VxD_CODE_ENDS	EQU <VxD_LOCKED_CODE_ENDS>


VxD_LOCKED_CODE_SEG MACRO
_LTEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 3 + ??_LCODE
	ASSUME	cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
		ENDM

VxD_LOCKED_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 3
_LTEXT	 ENDS
		ENDM



;   Protected mode initialization code
VxD_ICODE_SEG	MACRO
_ITEXT	SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 3 + ??_ICODE
	ASSUME	cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
		ENDM

VxD_ICODE_ENDS	MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 3
_ITEXT	ENDS
		ENDM


;   Protected mode data
VxD_DATA_SEG	EQU <VxD_LOCKED_DATA_SEG>
VxD_DATA_ENDS	EQU <VxD_LOCKED_DATA_ENDS>



VxD_LOCKED_DATA_SEG MACRO NO_ALIGN
_LDATA	 SEGMENT
IFB <NO_ALIGN>
	ALIGN 4
ENDIF
		ENDM

VxD_LOCKED_DATA_ENDS MACRO
_LDATA	 ENDS
		ENDM




;   Protected mode initialization data
VxD_IDATA_SEG	MACRO
_IDATA	SEGMENT
		ENDM
VxD_IDATA_ENDS	MACRO
_IDATA	ENDS
		ENDM

VxD_REAL_INIT_SEG  MACRO
_RCODE SEGMENT
ASSUME CS:_RCODE, DS:_RCODE, ES:_RCODE, SS:_RCODE
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 3 + ??_RCODE
		  ENDM

VxD_REAL_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 3
_RCODE ENDS
		   ENDM

ENDIF

DDK_Version equ 30Ah		; 3.10

VxD_Desc_Block STRUC
DDB_Next		dd  ?			; VMM RESERVED FIELD
DDB_SDK_Version 	dw  DDK_Version 	; VMM RESERVED FIELD
DDB_Req_Device_Number	dw  Undefined_Device_ID ; Required device number
DDB_Dev_Major_Version	db  0			; Major device number
DDB_Dev_Minor_Version	db  0			; Minor device number
DDB_Flags		dw  0			; Flags for init calls complete
DDB_Name		db  "        "		; Device name
DDB_Init_Order		dd  Undefined_Init_Order; Initialization Order
DDB_Control_Proc	dd  ?			; Offset of control procedure
DDB_V86_API_Proc	dd  0			; Offset of API procedure (or 0)
DDB_PM_API_Proc 	dd  0			; Offset of API procedure (or 0)
DDB_V86_API_CSIP	dd  0			; CS:IP of API entry point
DDB_PM_API_CSIP 	dd  0			; CS:IP of API entry point
DDB_Reference_Data	dd  ?			; Reference data from real mode
DDB_Service_Table_Ptr	dd  0			; Pointer to service table
DDB_Service_Table_Size	dd  0			; Number of services
VxD_Desc_Block ENDS


IFNDEF Not_VxD

; flag values for DDB_Flags

DDB_Sys_Crit_Init_Done	    EQU 00000001b
DDB_Sys_Crit_Init_Done_Bit  EQU        0
DDB_Device_Init_Done	    EQU 00000010b
DDB_Device_Init_Done_Bit    EQU       1

BeginDoc
;******************************************************************************
;
;   Declare_Virtual_Device macro
;
; ???? Write something here ????
;
;==============================================================================
EndDoc
Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc
	LOCAL	V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len

dev_id_err MACRO
%OUT Device ID required when providing services
.ERR
	ENDM

IFB <V86_Proc>
	V86_API_Offset EQU 0
ELSE
IFB <Device_Num>
	dev_id_err
ENDIF
	V86_API_Offset EQU <OFFSET32 V86_Proc>
ENDIF
IFB <PM_Proc>
	PM_API_Offset EQU 0
ELSE
IFB <Device_Num>
	dev_id_err
ENDIF
	PM_API_Offset EQU <OFFSET32 PM_Proc>
ENDIF
IFDEF Name&_Service_Table
IFB <Device_Num>
	dev_id_err
ELSE
IFE Device_Num - Undefined_Device_ID
	dev_id_err
ENDIF
ENDIF
	Serv_Tab_Offset EQU <OFFSET32 Name&_Service_Table>
	Serv_Tab_Len	EQU Num_&Name&_Services
ELSE
	Serv_Tab_Offset EQU 0
	Serv_Tab_Len	EQU 0
ENDIF


VxD_LOCKED_DATA_SEG
PUBLIC Name&_DDB
Name&_DDB VxD_Desc_Block <,,Device_Num,Major_Ver,Minor_Ver,,"&Name",Init_Order,\
			 OFFSET32 Ctrl_Proc, V86_API_Offset, PM_API_Offset, \
			 ,,,Serv_Tab_Offset, Serv_Tab_Len>
VxD_LOCKED_DATA_ENDS
	ENDM


BeginDoc
;******************************************************************************
; The Begin_Control_Dispatch macro is used for building a table for dispatching
; messages passed to the VxD_Control procedure.  It is used with
; Control_Dispatch and End_Control_Dispatch.  The only parameter is used to
; contruct the procedure label by adding "_Control" to the end (normally the
; device name is used i.e. VKD results in creating the procedure VKD_Control,
; this created procedure label must be included in Declare_Virtual_Device)
;
; An example of building a complete dispatch table:
;
; Begin_Control_Dispatch MyDevice
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
; Control_Dispatch  Sys_VM_Init, MyDeviceSysInitProcedure
; Control_Dispatch  Create_VM,	 MyDeviceCreateVMProcedure
; End_Control_Dispatch MyDevice
;
; (NOTE: Control_Dispatch can be used without Begin_Control_Dispatch, but
;	 then it is the programmer's responsibility for declaring a procedure
;	 in locked code (VxD_LOCKED_CODE_SEG) and returning Carry clear for
;	 any messages not processed.  The advantage in using
;	 Begin_Control_Dispatch is when a large # of messages are processed by
;	 a device, because a jump table is built which will usually require
;	 less code space then the compares and jumps that are done when
;	 Control_Dispatch is used alone.
;
;==============================================================================
EndDoc
Begin_Control_Dispatch MACRO VxD_Name
??_cd_low = 0FFFFFFFFh
??_cd_high = 0

BeginProc VxD_Name&_Control
ENDM

End_Control_Dispatch   MACRO VxD_Name
	LOCAL ignore, table

jmpproc MACRO num
	jmp	??_cd_&&num
ENDM

procoff MACRO num
IFDEF ??_cd_&&num
	dd	OFFSET32 ??_cd_&&num
ELSE
	dd	OFFSET32 ignore
ENDIF
ENDM

IF ??_cd_low EQ ??_cd_high
	cmp	eax, ??_cd_low
	jne	short ignore
	jmpproc %(??_cd_low)
ignore:
	clc
	ret
ELSE
	cmp	eax, ??_cd_high
	ja	short ignore
	sub	eax, ??_cd_low
	jb	short ignore
	jmp	cs:[eax*4+table]
ignore:
	clc
	ret

table label dword
	REPT   ??_cd_high - ??_cd_low + 1
	procoff %(??_cd_low)
	??_cd_low = ??_cd_low + 1
	ENDM
ENDIF

EndProc VxD_Name&_Control

PURGE jmpproc
PURGE procoff
PURGE Begin_Control_Dispatch
PURGE Control_Dispatch
PURGE End_Control_Dispatch
ENDM

BeginDoc
;******************************************************************************
; The Control_Dispatch macro is used for dispatching based on message
;	passed to the VxD_Control procedure. E.G.:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
;
; (NOTE: Control_Dispatch can be used with Begin_Control_Dispatch and
;	 End_Control_Dispatch to create a jump table for dispatching messages,
;	 when a large # of messages are processed.)
;
;==============================================================================
EndDoc
Control_Dispatch MACRO Service, Procedure
	LOCAL Skip_Interseg_Jump

IFE ?_lcode
IFDEF ??_cd_low
Equate_Service MACRO Serv
??_cd_&&Serv equ Procedure
ENDM

Equate_Service %(Service)

IF Service LT ??_cd_low
??_cd_low = Service
ENDIF
IF Service GT ??_cd_high
??_cd_high = Service
ENDIF

PURGE Equate_Service

ELSE
	cmp	eax, Service
	jne	SHORT Skip_Interseg_Jump
	jmp	Procedure
Skip_Interseg_Jump:
ENDIF
ELSE
%OUT ERROR:  The Control proc should be in LOCKED code.
%OUT	     Control_Dispatch can only be used inside of VxD_LOCKED_CODE_SEG.
.err
ENDIF
	ENDM


BeginDoc
;******************************************************************************
; The following are the definitions for the "type of I/O" parameter passed
;   to a I/O trap routine
Byte_Input	EQU	000h
Byte_Output	EQU	004h
Word_Input	EQU	008h
Word_Output	EQU	00Ch
Dword_Input	EQU	010h
Dword_Output	EQU	014h

Output		EQU	0000000000000100b
Output_Bit	EQU	2
Word_IO 	EQU	0000000000001000b
Word_IO_Bit	EQU	3
Dword_IO	EQU	0000000000010000b
Dword_IO_Bit	EQU	4

String_IO	EQU	00000020h
String_IO_Bit	EQU	5
Rep_IO		EQU	00000040h
Rep_IO_Bit	EQU	6
Addr_32_IO	EQU	00000080h
Addr_32_IO_Bit	EQU	7
Reverse_IO	EQU	00000100h
Reverse_IO_Bit	EQU	8

IO_Seg_Mask	EQU	0FFFF0000h		; Use these bits to get segment
IO_Seg_Shift	EQU	10h			; Must shift right this many

;==============================================================================
EndDoc

BeginDoc
;******************************************************************************
;
;   Dispatch_Byte_IO macro
;
; Dispatch_Byte_IO Byte_In_Proc, Byte_Out_Proc
;==============================================================================
EndDoc
Dispatch_Byte_IO MACRO In_Proc, Out_Proc
	LOCAL	Byte_IO
	cmp	ecx, Byte_Output
	jbe	SHORT Byte_IO
	VMMjmp	Simulate_IO
Byte_IO:
IFIDNI <In_Proc>, <Fall_Through>
	je	Out_Proc
ELSE
IFIDNI <Out_Proc>, <Fall_Through>
	jb	In_Proc
ELSE
	je	Out_Proc
	jmp	In_Proc
ENDIF
ENDIF
	ENDM

BeginDoc
;******************************************************************************
;
;   Emulate_Non_Byte_IO
;
; Emulate_Non_Byte_IO
;
;==============================================================================
EndDoc
Emulate_Non_Byte_IO MACRO
	LOCAL	Byte_IO
	cmp	ecx, Byte_Output
	jbe	SHORT Byte_IO
	VMMjmp	Simulate_IO
Byte_IO:
	ENDM


VxD_IOT_Hdr STRUC
VxD_IO_Ports	dw  ?
VxD_IOT_Hdr ENDS

VxD_IO_Struc STRUC
VxD_IO_Port	dw  ?
VxD_IO_Proc	dd  ?
VxD_IO_Struc ENDS


BeginDoc
;******************************************************************************
;
; Begin_VxD_IO_Table
;
;   Example:
; Begin_VxD_IO_Table MyTableName
;
;==============================================================================
EndDoc
.ERRNZ SIZE VxD_IOT_Hdr - 2	; Begin_VxD_IO_Table creates a 1 word count hdr
Begin_VxD_IO_Table MACRO Table_Name
PUBLIC Table_Name
Table_Name LABEL WORD
IF2
IFNDEF Table_Name&_Entries
%OUT ERROR:  No End_VxD_IO_Table for &Table_Name
.ERR
ENDIF
	dw	Table_Name&_Entries
ELSE
	dw	?
ENDIF

	ENDM

.ERRNZ SIZE VxD_IO_Struc - 6	; VxD_IO creates 6 byte I/O port entries
VxD_IO MACRO Port, Proc_Name
	dw	Port
	dd	OFFSET32 Proc_Name
	ENDM

End_VxD_IO_Table MACRO Table_Name

IFNDEF Table_Name
%OUT ERROR:  No Begin_VxD_IO_Table for &Table_Name
.ERR
ELSE
	Table_Name&_Entries EQU (($-Table_Name)-2) / (SIZE VxD_IO_Struc)
IF Table_Name&_Entries LE 0
%OUT ERROR:  Invalid number of port traps in &Table_Name
.ERR
ENDIF
ENDIF
	    ENDM


;******************************************************************************
;******************************************************************************

Push_Client_State MACRO
	sub	esp, SIZE Client_Reg_Struc
	push	edi
	lea	edi, [esp+4]
	VMMcall Save_Client_State
	pop	edi
	ENDM

Pop_Client_State MACRO
	push	esi
	lea	esi, [esp+4]
	VMMcall Restore_Client_State
	pop	esi
	add	esp, SIZE Client_Reg_Struc
	ENDM

BeginDoc
;******************************************************************************
;
;   CallRet -- Call procedure and return.  For debugging purposes only.
;	       If compiled with debugging then this will generate a call
;	       followed by a return.  If non-debugging version then the
;	       specified label will be jumped to.
;
;   PARAMETERS:
;	Label_Name = Procedure to be called
;
;   EXIT:
;	Return from current procedure
;
;------------------------------------------------------------------------------
EndDoc

CallRet MACRO P1, P2
IFDEF DEBUG
IFIDNI <P1>, <SHORT>
	call	P2
ELSE
	call	P1
ENDIF
	ret
ELSE
	jmp	P1 P2
ENDIF
	ENDM


; ebp offsets to segments pushed by PMode_Fault in Fault_Dispatch
PClient_DS equ WORD PTR -4
PClient_ES equ WORD PTR -8
PClient_FS equ WORD PTR -12
PClient_GS equ WORD PTR -16


Client_Ptr_Flat MACRO Reg_32, Cli_Seg, Cli_Off

IFDIFI <Reg_32>, <EAX>
	push	eax
ENDIF
IFB <Cli_Off>
	mov	ax, (Client_&Cli_Seg * 100h) + 0FFh
ELSE
	mov	ax, (Client_&Cli_Seg * 100h) + Client_&Cli_Off
ENDIF
	VMMcall Map_Flat

IFDIFI <Reg_32>, <EAX>
	mov	Reg_32, eax
	pop	eax
ENDIF

	ENDM

;------------------------------------------------------------------------------

VxDint	MACRO	Int_Number
	push	DWORD PTR Int_Number
	VMMcall Exec_VxD_Int
	ENDM


ENDIF	; Not_VxD


BeginDoc
;******************************************************************************
;
;   The following equates are for flags sent to the real mode
;   initialization portion of a device driver:
;
Duplicate_Device_ID	    equ 0000000000000001b   ; duplicate device ID already
Duplicate_Device_ID_Bit     equ 	       0    ; loaded
Duplicate_From_INT2F	    equ 0000000000000010b   ; duplicate device ID already
Duplicate_From_INT2F_Bit    equ 	      1     ; loaded as part of INT 2F
						    ; device list
Loading_From_INT2F	    equ 0000000000000100b   ; this device was specified
Loading_From_INT2F_Bit	    equ 	     2	    ; in the INT 2F device list

EndDoc

BeginDoc
;******************************************************************************
;
;   The following equates are used to indicate the result of the real mode
;   initialization portion of a device driver:
;

Device_Load_Ok	    equ 0		; protected mode portion of device
					; should be loaded
Abort_Device_Load   equ 1		; don't load any protected mode portion
					; of this device, but continue loading
					; the rest of the devices
Abort_Win386_Load   equ 2		; fatal-error: abort the load of Win386

No_Fail_Message     equ 8000h		; The high bit is set in the return
No_Fail_Message_Bit equ 15		; code, if the loader should not print
					; any message for results
					; Abort_Device_Load or Abort_Win386_Load
;==============================================================================
EndDoc


;==============================================================================

; CR0 bit assignments
PE_Mask 	EQU	0001h	; 1 = Protected Mode
PE_Bit		EQU	0
MP_Mask 	EQU	0002h	; 1 = Monitor Coprocessor
MP_Bit		EQU	1
EM_Mask 	EQU	0004h	; 1 = Emulate Math Coprocessor
EM_Bit		EQU	2
TS_Mask 	EQU	0008h	; 1 = Task Switch occured
TS_Bit		EQU	3
ET_Mask 	EQU	0010h	; 1 = 387 present, 0 = 287 present
ET_Bit		EQU	4
PG_Mask 	EQU 80000000h	; 1 = paging enabled, 0 = paging disabled
PG_Bit		EQU	31


; EFLAGs bit assignments
CF_Mask 	EQU	000000000000000001b	; Carry flag
CF_Bit		EQU	0
PF_Mask 	EQU	000000000000000100b	; Parity flag
PF_Bit		EQU	2
AF_Mask 	EQU	000000000000010000b	; Aux flag
AF_Bit		EQU	4
ZF_Mask 	EQU	000000000001000000b	; Zero flag
ZF_Bit		EQU	6
SF_Mask 	EQU	000000000010000000b	; Sign flag
SF_Bit		EQU	7
TF_Mask 	EQU	000000000100000000b	; Trace flag
TF_Bit		EQU	8
IF_Mask 	EQU	000000001000000000b	; Int flag
IF_Bit		EQU	9
DF_Mask 	EQU	000000010000000000b	; Direction flag
DB_Bit		EQU	10
OF_Mask 	EQU	000000100000000000b	; Overflow flag
OF_Bit		EQU	11
IOPL_Mask	EQU	000011000000000000b	; IOPL flags
IOPL_Bit0	EQU	12
IOPL_Bit1	EQU	13
NT_Mask 	EQU	000100000000000000b	; Nested task flag
NT_Bit		EQU	14
RF_Mask 	EQU	010000000000000000b	; Resume flag
RF_Bit		EQU	16
VM_Mask 	EQU	100000000000000000b	; Virtual Mode flag
VM_Bit		EQU	17


;------------------------------------------------------------------------------
;
;	  Temporary MASM macros (to be removed when supported by MASM)
;
;------------------------------------------------------------------------------

loopd EQU <loop>
loopde EQU <loope>
loopdne EQU <loopne>
loopdz EQU <loopz>
loopdnz EQU <loopnz>


;******************************************************************************
; PAGE TABLE EQUATES
;******************************************************************************


P_SIZE		equ	1000h		; page size

; ---------------------------------------------------
;
;	Page table entry bits
;
; ---------------------------------------------------

P_PRES		equ	01h		; page present bit
P_PRESBit	equ	0
P_WRITE 	equ	02h		; write access bit
P_WRITEBit	equ	1
P_USER		equ	04h		; access bit for User mode
P_USERBit	equ	2
P_ACC		equ	20h		; page accessed bit
P_ACCBit	equ	5
P_DIRTY 	equ	40h		; page dirty bit
P_DIRTYBit	equ	6

P_AVAIL 	equ	(P_PRES+P_WRITE+P_USER) ; avail to everyone & present

; ---------------------------------------------------
;
;  Page types - definition of the OS reserved bits in the page table
;		entry.
; ---------------------------------------------------

PG_TYPE 	equ	0E00h		; TYPE bits in PTE

; ---------------------------------------------------
;
;	 Page types for page allocator calls
;
; ---------------------------------------------------
PG_VM		equ	0
PG_SYS		equ	1
PG_RESERVED1	equ	2
PG_PRIVATE	equ	3
PG_RESERVED2	equ	4
PG_RELOCK	equ	5		; PRIVATE to MMGR
PG_INSTANCE	equ	6
PG_HOOKED	equ	7
PG_IGNORE	equ	0FFFFFFFFh


; ---------------------------------------------------
;
;	 Types for page table entries
;
; ---------------------------------------------------
PgT_VM		equ	PG_VM SHL 9
PgT_SYS 	equ	PG_SYS SHL 9
PgT_RESERVED1	equ	PG_RESERVED1 SHL 9
PgT_PRIVATE	equ	PG_PRIVATE SHL 9
PgT_RESERVED2	equ	PG_RESERVED2 SHL 9
PgT_RELOCK	equ	PG_RELOCK SHL 9
PgT_INSTANCE	equ	PG_INSTANCE SHL 9
PgT_HOOKED	equ	PG_HOOKED SHL 9



;******************************************************************************

; ---------------------------------------------------
;
; Definitions for the access byte in a descriptor
;
; ---------------------------------------------------


; Following fields are common to segment and control descriptors

D_PRES		equ	080h		; present in memory
D_NOTPRES	equ	0		; not present in memory

D_DPL0		equ	0		; Ring 0
D_DPL1		equ	020h		; Ring 1
D_DPL2		equ	040h		; Ring 2
D_DPL3		equ	060h		; Ring 3

D_SEG		equ	010h		; Segment descriptor
D_CTRL		equ	0		; Control descriptor

D_GRAN_BYTE	equ	000h		; Segment length is byte granular
D_GRAN_PAGE	equ	080h		; Segment length is page granular
D_DEF16 	equ	000h		; Default operation size is 16 bits
D_DEF32 	equ	040h		; Default operation size is 32 bits


; Following fields are specific to segment descriptors

D_CODE		equ	08h		; code
D_DATA		equ	0		; data

D_RX		equ	02h		; if code, readable
D_X		equ	0		; if code, exec only
D_W		equ	02h		; if data, writable
D_R		equ	0		; if data, read only

D_ACCESSED	equ	1		; segment accessed bit


; Useful combination access rights bytes

RW_Data_Type equ (D_PRES+D_SEG+D_DATA+D_W)
R_Data_Type  equ (D_PRES+D_SEG+D_DATA+D_R)
Code_Type    equ (D_PRES+D_SEG+D_CODE+D_RX)

D_PAGE32	equ	(D_GRAN_PAGE+D_DEF32)		  ; 32 bit Page granular

; Masks for selector fields

SELECTOR_MASK	equ	0fff8h		; selector index
SEL_LOW_MASK	equ	0f8h		; mask for low byte of sel indx
TABLE_MASK	equ	04h		; table bit
RPL_MASK	equ	03h		; privilige bits
RPL_CLR 	equ	not 03h 	; clear ring bits
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\power\lpc.asm ===
PAGE    ,132
        TITLE   'Power Control Transient Portion'

;-----------------------------------------------------------------------------
;       Power control transient module for POWER.EXE
;
;       This file contains the transient code used to turn power
;       monitoring on and off from the command line.
;
;       Microsoft Confidential
;       Copyright (C) 1991 Microsoft Corporation 
;       All Rights Reserved.
;
; This code is bound to the device driver image of POWER.EXE.  This
; transient program can be used to turn power control on and off.
; POWER has the following options:
;
; Command line syntax
;       POWER [ADV[:{MAX|REG|MIN}] | STD |OFF |SOUND |/?] 
;               ADV   - Monitors applications and devices
;			MAX = max.power savings switch
;			REG = default (medium) power savings switch
;			MIN = Minimum power savings
;               STD   - Monitors devices only
;		OFF   - turns off all pw. management
;               SOUND - activate speaker during idle (debug version only) - toggle
;               /? - print help message
;
; MODIFICATIONS:
;	M004	9/5/91	NSM	power status from APM in BL reg. was trashed
;				and so we were skipping call to get and print
;				APM stats. Fixed by storing status and
;				using it whenever we need to look at current
;				POWER status
;	M007	09/11/91 SMR	B#2669. Registered POWER's 2f channels
;					in mult.inc
;	M009	09/11/91 SMR	Build non-debug version.
;
;  	M010	09/12/91 SMR	PWR_API returns 0 in AX instead of no carry flag
;				in case of no error
;	M011	09/17/91 NSM	PWR_API returns the version no in AX for the
;				install_chk call and so we shouldn't chk for
;				AX==0 for install-chk call.
;	M087	09/23/91 NSM	Install_chk returns 504d in BX and not 4d50
;				B#2756
;
;	M089	09/25/91 NSM	UI changes.	
;
;	M092	10/18/91 NSM	B#2872(5.1) Clear out BH
;				(correction for a typo: xor was entered as or)
;
;	M012	12/04/91 SMR	Match lengths before comparing tokens
;
;-----------------------------------------------------------------------------

Bios_Code       segment word public 'Bios_Code'
		extrn	SecondCopy:byte
Bios_Code       ends

Bios_Data       segment word public 'Bios_Data'
Bios_Data       ends

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends

Trans_Code      segment word public 'CODE'
Trans_Code      ends

Trans_Data      segment word public 'DATA'
Trans_Data      ends

Trans_Stack     segment para stack 'STACK'
        db      512 dup (?)
Trans_Stack     ends

break		macro		; satisfy mult.inc & pdb.inc		; M009
		endm							; M009

include		mult.inc				; M007
include         power.inc
include         pdb.inc

; DOS calls used
GET_VERSION	equ	30h
EXIT            equ     4Ch
OUT_STRING      equ     09h
OUT_CHAR        equ     02h

; miscellaneous equates
BLANK		equ	20h

Trans_Data      segment
include         powermsg.inc

psp             dw      0,0             ; stores our PSP address 

digit_buf       db      8 dup (0)       ; stores chars generated by get_dec

idle_data	IDLE_INFO	<>

pow_status	db	0		; M004 ; to store current POWER
					; enabled/disabled state
;NSM1 BEGIN

MAXTOKENSIZE	equ	12		; max limit for token size ; may
					; change for INTERNATIONAL

Token	db	MAXTOKENSIZE dup (0)	;

PW_Mode_Set	db	0		; flag ; set if we see a cmdline mode
					; keywords (ADV/STD/OFF)

		public	PW_Savings_Value,PW_Mode,PW_Low	; M104
PW_Savings_Value	dw	0	;
PW_Mode		db	0ffh		; OFF/STD/ADV = 0/2/3
PW_Low		db	0

IFDEF		DEBUG
		public	PW_Debug	; M104
PW_Debug	db	0
ENDIF

PW_LOADLOW	equ	10
PW_MODE_STD	equ	2
PW_MODE_OFF	equ	1

;NSM1 END


;NSM1 END


Trans_Data      ends

Trans_Code      segment
        assume  cs:Trans_Code, ds:nothing, es:nothing

        extrn   get_dec:near, uldiv:near, lmul:near        
        
start:
        public  start
        mov     ax,Trans_Data
        mov     ds,ax                   ; set up data segment
        assume  ds:Trans_Data

	mov	ah, GET_VERSION
	int	21h
	cmp	ax, 0005
	jae	@f			; Run on DOS 5.0 and above

	lea	dx, BadDOSMsg
	jmp	err_exit

@@:
        mov     [psp]+2,es              ; save our PSP address for later
        
; look at the command line and determine what we are supposed to be
; doing.  

        les     bx,dword ptr [psp]      ; recover our PSP address
        lea     di,es:[bx].PDB_TAIL
        cmp     es:[bx].PDB_TAIL,0      ; is there a command line?
	je	not_help		; no tail; go display stats
look_at_tail:
	inc	di			; skip the first blank in tail

clear_spaces:
        cmp     es:byte ptr [bx+di],' ' ; scan past any spaces
        jne     get_command_option      ; not a space, load it and check it
        inc     di
        jmp     short clear_spaces      ; assume we will stop on CR terminator

get_command_option:
        mov     ax,es:word ptr [bx+di]  ; get start of command line,
        cmp     ax,'?/'                 ; looks like /?
	jne	not_help
	jmp	display_help

not_help:

; We've established this is not /?.  Now check for other options        
; before proceeding, detect the presence of POWER by power detect call

	push	bx
	mov	ax,(MultPWR_API*256)+00h; POWER detect mult.call ; M007
	int	2fh
	cmp	ax,(MultPWR_API*256)+00h; MultAPI code unchanged ? ; M011
	jnz	chk_signature		; M011
to_open_fail:
	jmp	open_failed
chk_signature:
	cmp	bx,504dh		; M087 signature correct ?
	jne	to_open_fail

IFDEF	DEBUG
	push	di
        lea     dx,rev_msg      	; Display current rev. no & date
        mov     ah,OUT_STRING		;
        int     21h                     
	pop	di
ENDIF
	pop	bx

        mov     ax,es:word ptr [bx+di]  ; get start of command line,

        cmp     al,13                   ; is it the CR terminator?
        je      display_info            ; yes, just go display status
	cmp	al,0			; no tail at all
	je	display_info		; just display status

	add	di,bx			; es:di -> ptr to cmd line

	call	far ptr ParseCmdLine	; NSM1 - parse cmdline options
	call	SetPowerMode		; and set POWER's mode

display_info:   ; Print current state and idle stats
	mov	ax,(MultPWR_API*256)+I2F_PW_GET_SET_PWSTATE	; M007
	mov	bx,0			; get pw state
	int	2fh
	or	ax, ax			; M010
	jz	chk_status		; M010
	jmp	stats_failed		; error in get pw state ? just quit
chk_status:
	mov	[pow_status],bl		; M004
        lea     dx,power_stat1_msg      ; Display current POWER status
        mov     ah,OUT_STRING		; Whether "ADV/STD/OFF"
        int     21h                     

	or	bl,bl			; all pow.mgmt off ?
        lea     dx,power_off_msg         ; assume power control is off
	jz	got_msg			
	cmp	bl,2
	lea	dx,power_noid_msg
	je	got_msg
	xor	bx,bx
	mov	ax,(MultPWR_API * 256)+I2F_PW_GETSET_SAVINGS
	int	2fh			; get current savings value in bx
	lea	dx,power_advmax_msg
	cmp	bx,PW_ADV_REG
	ja	got_msg
	lea	dx,power_advreg_msg
	je	got_msg
	lea	dx,power_advmin_msg
got_msg:
        mov     ah,OUT_STRING		
        int     21h                     
	lea	dx,power_stat2_msg	; complete the above stat msg
        mov     ah,OUT_STRING		
        int     21h                     

; Compute percentage of time idle if idle detection is on
	test	[pow_status],1		;M004; is idle detection on ?
	jz	Print_APM_Stats
        lea     dx,cpu_idle_msg1
        mov     ah,OUT_STRING
        int     21h

	lea	si,idle_data
	mov	cx,size IDLE_INFO
	mov	ax,(MultPWR_API*256)+I2F_PW_GET_STATS	; M007
	mov	bx,PW_GET_IDLE_STATS	; get only idle detection stats
	int	2fh			; get stats
	or	ax, ax			; M010
	jnz	stats_failed		; M010

	lea	bx,idle_data
        push    word ptr [bx].CPU_IDLE_TIME+2
        push    word ptr [bx].CPU_IDLE_TIME   ; get total idle time
        xor     ax,ax
        push    ax
        mov     ax,100
        push    ax
        call    lmul                    ; returns result in DX:AX
        add     sp,8
        push    word ptr [bx].CPU_ON_TIME+2
        push    word ptr [bx].CPU_ON_TIME
        push    dx
        push    ax
        call    uldiv                   ; returns result in DX:AX
        add     sp,8

	call	calc_and_print_no
        
        lea     dx,cpu_idle_msg2
        mov     ah,OUT_STRING
        int     21h

Print_APM_Stats:
IFDEF	INCL_APM
	test	[pow_status],2		;M004; is APM enabled ?
	jz	good_exit		; no, all stats display over
	call	Display_APM_Stats
ENDIF
	

good_exit:      ; And exit

        xor     al,al
        mov     ah,EXIT
        int     21h


; Help message display

display_help:
        lea     dx,help_text
        mov     ah,OUT_STRING
        int     21h
        jmp     short good_exit


; Various error exits

open_failed:
        
        lea     dx,open_failed_msg
        jmp     short err_exit

stats_failed:
        lea     dx,stats_failed_msg
err_exit:
        mov     ah,OUT_STRING
        int     21h                     ; display error message
        mov     ah,EXIT
        mov     al,1                    ; signal error on exit 
        int     21h                     

; END OF Main (of transient POWER.EXE)

calc_and_print_no	proc	near
;dx:ax = no to print
;
        lea     di,digit_buf
        call    get_dec                 ; convert result to ASCII

        lea     bx,digit_buf

PrintASCIIZ	label	near
; ENTRY: bx = points to asciiz string

        mov     ah,OUT_CHAR
next_digit:
        mov     dl,[bx]                 ; reached end of string?
        or      dl,dl
        jz      capn_end              ; yes, go wrap up
        int     21h                     ; print the character
        inc     bx                      ; point to next char in string
        jmp     short next_digit
capn_end:
	ret

calc_and_print_no	endp

; NSM1 BEGIN
; ParseCmdLine:
; input:	es:di -> ptr to command line
; output:	CY    -> invalid cmd line option
;
; parses cmdline switches and does the necessary actions on them.
; If there are more than one switch specified in a given group, first one
; is taken and the second is flagged as an error and ignored.

		public	ParseCmdLine

ParseCmdLine	proc	far

	push	ds
	mov	ax, Trans_Data
	mov	ds, ax

PCL_NxtSwitch:
	call	GetNxtToken		; get next arg to be processed
					; [Token] filled in with current token
	jc	PCL_Ret			; end of cmd line ?

	call	GetTokenValue
	jc	PCL_Inv_CmdLine

IFDEF	DEBUG
	or	ax,ax
	jz	PCL_Toggle_Sound		;
ENDIF

	cmp	ax, PW_LOADLOW		; is it arequest for loadlow ?
	jne	PCL_ChkMode
	mov	PW_Low, 1
	jmp	PCL_NxtSwitch

PCL_ChkMode:
	test	PW_Mode_Set,1		; more than one mode switch ?
	jnz	PCL_Inv_CmdLine		; yes ,ignore this switch

	cmp	ax,PW_MODE_STD		;
	jbe	PCL_SetModes
	sub	ax,PW_MODE_STD		; ax = savings value
					; 1 = low, 2 med, 4 high
	mov	PW_Savings_Value,ax	
	mov	PW_Mode_Set,1		; mode is already set
	jmp	short turn_on_all	; go set ADV. mode

PCL_SetModes:
	mov	PW_Mode_Set,1		; mode is already set
	je	turn_on_FW		; Zr set if STD mode chosen
;
; else POWER OFF
turn_off:       ; User requests power control be deactivated
	xor	bl,bl		; turn off all pw mgmt
	jmp	short change_pw_state


; M089 END

IFDEF DEBUG
PCL_Toggle_Sound:
; User requests we toggle control of speaker on at idle
;
; SMR
;
IF	0
	mov	ax,(MultPWR_API*256)+02h; change allocation strategy ; M007
	mov	bl,80h			; special value for SOUND toggle
	int	2fh
ENDIF
	mov	PW_Debug, 1

	jmp	PCL_NxtSwitch
ENDIF

turn_on_all:        ; User requested power control be activated
	mov	bl,3			; set both F/W and S/W
;
change_pw_state:			; issue mult.int to turn on/off PW mgmt.

;
; SMR
;
IF	0

	mov	bh,1			; set  power state
	mov	ax,(MultPWR_API*256)+I2F_PW_GET_SET_PWSTATE	; M007
	int	2fh
	cmp	[PW_Savings_Value],0
	je	PCL_NxtSwitch
	mov	bx,[PW_Savings_Value]
	mov	ax,(MultPWR_API * 256)+I2F_PW_GETSET_SAVINGS
	int	2fh

ENDIF

	mov	[PW_Mode], bl
	
;
; SMR
;
        jmp     short PCL_NxtSwitch

turn_on_FW:
	mov	bl,2			; turn on only F/W
	jmp	short change_pw_state

PCL_Ret:
	mov	ax, PW_Savings_Value
	mov	bl, PW_Mode
	mov	dl, PW_Low
IFDEF	DEBUG
	mov	dh, PW_Debug
ENDIF
	pop	ds
	ret

PCL_Inv_CmdLine:
; print out Invalid command line and print the corresponding token
	push	ds
	mov	dx, Bios_Code
	mov	ds, dx
	assume	ds:Bios_Code
	cmp	SecondCopy, 0
	pop	ds
	assume	ds:Trans_Data
	jne	PCL_SkipErr

	lea	dx,bad_command_msg	
	mov	ah,OUT_STRING
	int	21h
	lea	bx,Token
	call	PrintASCIIZ		; print out the invalid token
	lea	dx,crlf_msg
	mov	ah,OUT_STRING
	int	21h
PCL_SkipErr:
        jmp     PCL_NxtSwitch

ParseCmdLine	endp

SetPowerMode	proc	near
;
	push	dx

	cmp	bl, 0ffh
	je	SPM_SkipMode

	push	ax
	mov	bh,1			; set  power state
	mov	ax,(MultPWR_API*256)+I2F_PW_GET_SET_PWSTATE	; M007
	int	2fh

	pop	ax
	or	ax, ax
	jz	SPM_SkipMode

	mov	bx,ax
	mov	ax,(MultPWR_API * 256)+I2F_PW_GETSET_SAVINGS
	int	2fh

SPM_SkipMode:

IFDEF	DEBUG
	pop	dx
	push	dx
	or	dh, dh
	jz	SPM_SkipDbg

	mov	ax,(MultPWR_API*256)+02h; change allocation strategy ; M007
	mov	bl,80h			; special value for SOUND toggle
	int	2fh
SPM_SkipDbg:
ENDIF
	pop	dx
	or	dl, dl
	jz	SPM_Exit
	lea	dx, PW_Low_ErrMsg
	mov	ah, OUT_STRING
	int	21h
SPM_Exit:
	ret
	
SetPowerMode	endp

GetNxtToken	proc	near
; es:di -> nxt token	
; regs used: AX,CX,SI,DI
GNT_SkipBlank:
	mov	al,es:[di]
	inc	di
	cmp	al,BLANK
	je	GNT_SkipBlank
;  leading blanks removed; copy the token
	lea	si,Token
	xor	cx,cx			; token size
GNT_NxtChar:
	cmp	al,0dh			; end of line ?
	je	GNT_EOLine
	cmp	al,0ah			; end of line ?
	je	GNT_EOLine
	or	al,al
	jz	GNT_EOLine
	cmp	al,BLANK
	je	GNT_EOToken
;****************************************************************************
; INTERNATIONAL : Here we have to get the lower case value for the current
; token into [Token] so that comparing against the standard Token_table entries
; in powermsg.inc will be easy.
	cmp	al, 'Z'
	ja	GNT_SkipCaseChng
	cmp	al, 'A'
	jb	GNT_SkipCaseChng

	or	al,20h			; CONVERT TO LOWER CASE
GNT_SkipCaseChng:
;****************************************************************************
	cmp	cx,MAXTOKENSIZE		; is the current string more than
					; max token size ?
	jae	GNT_NoStore		; if so, ignore the rest
	mov	ds:[si],al
	inc	si
	inc	cx
GNT_NoStore:
	mov	al,es:[di]
	inc	di
	jmp	GNT_NxtChar

GNT_EOToken:
	clc
GNT_Ret:
	mov	byte ptr ds:[si],0	; null terminate token
	ret
GNT_EOLine:
	jcxz	GNT_NoToken		; was there a token before EOL ? 
; token was terminated by a CR or NULL
	dec	di			; point to termination char
	jmp	short GNT_EOToken	
GNT_NoToken:
	stc				; CY to indicate end of cmdline args
	jmp	short GNT_Ret

GetNxtToken	endp
	

GetTokenValue	proc	near
; Entry:	
; 		[Token] = current token
;		es:di = command line switches
;		cl    = length of token
; EXIT:
;	CY	= invalid token
;	else
;	ax	= Token value from Token_Table
;
; Regs used:	AX,BX,CX,DX,SI
	
	push	es
	push	di

	push	ds
	pop	es

	lea	si,Token_Table
	lodsw
	mov	dx,ax 		;dx = no of tokens in token list
	mov	bh,cl		;bh = length of token			; M012
GTV_NxtToken:
	lea	di,Token
	lodsw			; get token length + token value
	mov	bl,al		; token value
	mov	cl,ah		; length of token
	xor	ch,ch
	cmp	bh, cl		; do lengths match?			; M012
	jne	GTV_LenMismatch	; no, try next key word			; M012
	rep	cmpsb		; compare given token with our list of tokens
	jz	GTV_Ret		; token matched
GTV_LenMismatch:							; M012
	add	si,cx		; skip to next entry in our list
	dec	dx		; end of all tokens ?
	jnz	GTV_NxtToken	; no, go for next token compar
; all tokens compared, but none matched ; fail
	stc
GTV_Ret:
	mov	bh, 0		; do not xor OR sub flags are being passed back
				; M012

	mov	ax,bx		; get token value from bx
	pop	di
	pop	es
	ret

GetTokenValue	endp

        
IFDEF	INCL_APM
	
batt_stat_table	label	word
	dw	battery_high
	dw	battery_low
	dw	battery_critical
	dw	battery_charging

;***************************************** Display_APM_Stats
; display APM statistics (ACLine status, Battery status and battery life)
;

Display_APM_Stats	proc	near
	mov	ax,530ah		; get power status
	mov	bx,1
	int	15h			;
	jc	APM_stats_End
	push	cx
	push	bx
	cmp	bh,-1
	je	go_chk_batt_stat
        lea     dx,ACLine_Stat1
        mov     ah,OUT_STRING
        int     21h
	pop	bx
	push	bx
        lea     dx,AC_Offline_str
	or	bh,bh
	je	go_print_acstat
	lea	dx,AC_Online_str
go_print_acstat:
        mov     ah,OUT_STRING
        int     21h
        lea     dx,ACLine_Stat2
        mov     ah,OUT_STRING
        int     21h

go_chk_batt_stat:
	pop	bx
	cmp	bl,-1
	je	go_print_batt_life
	xor	bh,bh		; M092
	push	bx
	lea	dx,battery_status1
        mov     ah,OUT_STRING
        int     21h
	pop	bx
	shl	bx,1		; word offset
	mov	dx,cs:batt_stat_table[bx]
        mov     ah,OUT_STRING
        int     21h

	lea	dx,battery_status2
        mov     ah,OUT_STRING
        int     21h

go_print_batt_life:
	pop	cx
	cmp	cl,-1
	je	APM_stats_End
	mov	ax,cx
	xor	ah,ah
	push	ax
	lea	dx,battery_life_str1
        mov     ah,OUT_STRING
        int     21h
	pop	ax
	xor	dx,dx
	call	calc_and_print_no
	lea	dx,battery_life_str2
        mov     ah,OUT_STRING
        int     21h
APM_stats_END:
	ret

Display_APM_Stats	endp

ENDIF

Trans_Code      ends

        end     start


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\power\uldiv.asm ===
page	,132
	title	uldiv - unsigned long divide routine
;***
;uldiv.asm - unsigned long divide routine
;
;	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines the unsigned long divide routine
;
;Revision History:
;	11-29-83  DFW	initial version
;	06-01-84  RN	modified to use cmacros
;	10-23-87  SKS	fixed off-by-1 error for dividend close to 2**32.
;	05-18-89  SKS	Remove redundant "MOV SP,BP" from epilog
;	11-28-89  GJF	Fixed copyright
;
;       06-05-91  MD    Stolen from C runtime library for use with POWER.EXE
;
;*******************************************************************************

.xlist
include mm.inc
.list

Trans_Code      segment word public 'CODE'
Trans_Code      ends

Trans_Data      segment word public 'DATA'
Trans_Data      ends

;***
;uldiv - unsigned long divide
;
;Purpose:
;	Does a unsigned long divide of the arguments.  Arguments are
;	not changed.
;
;Entry:
;	Arguments are passed on the stack:
;		1st pushed: divisor (DWORD)
;		2nd pushed: dividend (DWORD)
;
;Exit:
;	DX:AX contains the quotient (dividend/divisor)
;	NOTE: this routine removes the parameters from the stack.
;
;Uses:
;	CX
;
;Exceptions:
;
;*******************************************************************************
Trans_Code      segment
        assume  cs:Trans_Code, ds:Trans_Data

uldiv   proc    near
        public  uldiv

        push    bp
        mov     bp,sp

	push	bx
	push	si

; Set up the local stack and save the index registers.	When this is done
; the stack frame will look as follows (assuming that the expression a/b will
; generate a call to uldiv(a, b)):
;
;		-----------------
;		|		|
;		|---------------|
;		|		|
;		|--divisor (b)--|
;		|		|
;		|---------------|
;		|		|
;		|--dividend (a)-|
;		|		|
;		|---------------|
;		| return addr** |
;		|---------------|
;	BP----->|    old BP	|
;		|---------------|
;		|      BX	|
;		|---------------|
;	SP----->|      SI	|
;		-----------------
;
; ** - 2 bytes if small/compact model; 4 bytes if medium/large model

DVND	equ	BPARGBAS[bp]	; stack address of dividend (a)
DVSR	equ	BPARGBAS+4[bp]	; stack address of divisor (b)

;
; Now do the divide.  First look to see if the divisor is less than 64K.
; If so, then we can use a simple algorithm with word divides, otherwise
; things get a little more complex.
;

	mov	ax,HIWORD(DVSR) ; check to see if divisor < 64K
	or	ax,ax
	jnz	L1		; nope, gotta do this the hard way
	mov	cx,LOWORD(DVSR) ; load divisor
	mov	ax,HIWORD(DVND) ; load high word of dividend
	xor	dx,dx
	div	cx		; get high order bits of quotient
	mov	bx,ax		; save high bits of quotient
	mov	ax,LOWORD(DVND) ; dx:ax <- remainder:lo word of dividend
	div	cx		; get low order bits of quotient
	mov	dx,bx		; dx:ax <- quotient hi:quotient lo
	jmp	short L2	; restore stack and return

;
; Here we do it the hard way.  Remember, ax contains DVSRHI
;

L1:
	mov	cx,ax		; cx:bx <- divisor
	mov	bx,LOWORD(DVSR)
	mov	dx,HIWORD(DVND) ; dx:ax <- dividend
	mov	ax,LOWORD(DVND)
L3:
	shr	cx,1		; shift divisor right one bit; hi bit <- 0
	rcr	bx,1
	shr	dx,1		; shift dividend right one bit; hi bit <- 0
	rcr	ax,1
	or	cx,cx
	jnz	L3		; loop until divisor < 64K
	div	bx		; now divide, ignore remainder
	mov	si,ax		; save quotient

;
; We may be off by one, so to check, we will multiply the quotient
; by the divisor and check the result against the orignal dividend
; Note that we must also check for overflow, which can occur if the
; dividend is close to 2**32 and the quotient is off by 1.
;

	mul	word ptr HIWORD(DVSR) ; QUOT * HIWORD(DVSR)
	xchg	cx,ax		; "mov cx,ax" but only 1 byte
	mov	ax,LOWORD(DVSR)
	mul	si		; QUOT * LOWORD(DVSR)
	add	dx,cx		; DX:AX = QUOT * DVSR
	jc	L4		; carry means Quotient is off by 1

;
; do long compare here between original dividend and the result of the
; multiply in dx:ax.  If original is larger or equal, we are ok, otherwise
; subtract one (1) from the quotient.
;

	cmp	dx,HIWORD(DVND) ; compare hi words of result and original
	ja	L4		; if result > original, do subtract
	jb	L5		; if result < original, we are ok
	cmp	ax,LOWORD(DVND) ; hi words are equal, compare lo words
	jbe	L5		; if less or equal we are ok, else subtract
L4:
	dec	si		; subtract 1 from quotient
L5:
	xor	dx,dx		; dx:ax <- quotient
	xchg	ax,si		; "mov ax,si" but only 1 byte

;
; Just the cleanup left to do.	dx:ax contains the quotient.
; Restore the saved registers and return.
;

L2:

	pop	si
	pop	bx

        mov     sp,bp
        pop     bp
        ret

uldiv   endp

Trans_Code      ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\printer\cpspequ.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

	PAGE	,132

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  FILENAME:	  CPS Printer Device Driver EQUAL Include
;;  MODULE NAME:  CPSEQU
;;  TYPE:	  Include File
;;
;;  LINK PROCEDURE:  See CPSPx.ASM
;;
;;  INCLUDE FILES:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	Request Header (Common portion)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
RH	EQU	ES:[DI] 		;; addressability to Request Header
					;;
RHC	STRUC				;; fields common to all request types
RHC_LEN DB	?			;; length of Request Header
	DB	?			;; unit code (subunit)
RHC_CMD DB	?			;; command code
RHC_STA DW	?			;; status
	DQ	?			;; reserved for DOS
RHC	ENDS				;; end of common portion
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;; Command in the Request Header
					;; (see CMD_CODES table)
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
CMD_INI EQU	0			;; init  command
CMD_WRT EQU	8			;; write command
CMD_GIO EQU	19			;; generic IOCTL command
					;; (see major/minor GIO functions)
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;; status values for RHC_STA
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
STAT_DONE EQU	01H			;; function complete - high order byte
STAT_CMDERR EQU 8003H			;; invalid command code error
STAT_ERROR EQU	8000H			;; error returned by normal driver
					;;
;; see Generic IOCTL Request Header section
;; for more errorneous status.		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	Request Header for INIT
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;;
RH0	STRUC				;;
	DB	(TYPE RHC) DUP (?)	;; common portion
					;;
	DB	?			;; not used for CHAR devices
RH0_ENDO DW	?			;; offset  of ending address
RH0_ENDS DW	?			;; segment of ending address
RH0_BPBA DD	?			;; pointer to BPBA
	db	?
RH0_CONFIG_ERRMSG dw 0			;DCR D493 "Error in CONFIG.SYS..." msg flag.
RH0	ENDS				;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	Request Header for IOCTL
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
RH3	STRUC				;;
	DB	(TYPE RHC) DUP (?)	;; common portion
					;;
					;;
	DB	?			;; media descriptor
RH3_DTAO DW	?			;; offset  of transfer address
RH3_DTAS DW	?			;; segment of transfer address
RH3_CNT DW	?			;; byte count
RH3	ENDS				;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	Request Header for GENERIC IOCTL
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
GIH	STRUC				;;
	DB	(TYPE RHC) DUP (?)	;; common portion
					;;
					;;
GIH_MAF DB	?			;; major function
GIH_MIF DB	?			;; minor function
GIH_SI	DW	?			;; content of SI
GIH_DI	DW	?			;; content of DI
GIH_GBA DD	?			;; Address of Generic Buffer
GIH	ENDS				;;
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;; GIO major/minor functions
					;; (see GIO_CODES table)
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
MAF_CON EQU	03			;; major function for CON  device
MAF_PTR EQU	05			;; major function for LPTX device
					;;
MIF_DST EQU	4CH			;; minor function : designate start
MIF_DEN EQU	4DH			;;		    designate end
MIF_IVK EQU	4AH			;;		    invoke
MIF_QIV EQU	6AH			;;		    query-invoked
MIF_QLS EQU	6BH			;;		    query-list
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; Designate Start (MIF_DST)Flags
					;; see GBIS structure
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
DSF_FIFOCP EQU	08000H			;; Single code page FIFO command
DSF_CARTCP EQU	00001H			;; Code page for Cartridge/semi-
					;; hardware RAM
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; Generic IOCTL errorneous status
					;; upon return
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
STAT_DELETE EQU 08000H			;; previous degignate deleted (DST)
					;; STAT_DELETE : only for FIFO
STAT_NOFIND EQU 08008H			;; codepage,device not found  (DST)
STAT_DEVERR EQU 0800AH			;; Device error (DST,IVK,QIV,QLS,WRT)
STAT_BADATA EQU 0800CH			;; bad font file (DST)
STAT_NOBUFF EQU 0800CH			;; no font buffer for (REFRESH)
STAT_BADDEN EQU 0800CH			;; no DST (DEN)
STAT_bffDEN EQU 08000H			;; bad font file (DEN)
STAT_TOMANY EQU 0800aH			;; too manay codepages (DST)
STAT_DUPLCP EQU 0800aH			;; too manay codepages (DST)
STAT_NOCPIV EQU 08007H			;; no codepage designated/invoked
STAT_NOCP EQU	08007H			;; no codepage designated/invoked
					;; (IVK, QIV, QLS)
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	Generic IOCTL Buffer   DS:[SI]
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GIOB	EQU	DS:[SI] 		;;
					;;
GB1S	STRUC				;;
GB1_FLAG DW	?			;; flag
GB1_LEN DW	?			;; length
GB1_NUM DW	?			;; length
GB1_CP	DW	?			;;
GB1S	ENDS				;;
					;;
					;;
GB2S	STRUC				;;
GB2_LEN DW	?			;; length
GB2_CP	DW	?			;;
GB2S	ENDS				;;
					;;
					;;
GB3S	STRUC				;;
GB3_LEN DW	?			;; length
GB3_GBL DW	?			;; hardware code page number
GB3S	ENDS				;;
					;;
GB3_MINILEN EQU 4			;; minimium length of GB3
					;;
GBLS	STRUC				;;
GBL_LEN DW	?			;; length
GBL_CP	DW	?			;; hardware code page number
GBLS	ENDS				;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	DEVICE	Header	   DS:[SI]	-- to locate the next LPTn header
;;	NEXT device header ES:[DI]
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
HP	EQU	DS:[SI] 		;;
NHD	EQU	ES:[DI] 		;;
					;;
NAME_LEN EQU	8			;;
					;;
DHS	STRUC				;;
DH_NEXTO DW	?			;; offset of pointer to next header
DH_NEXTS DW	?			;; segment of pointer to next header
	DW	?			;; attribute
DH_STRAO DW	?			;; offset to strategy routine
DH_INTRO DW	?			;; offset to interrupt routine
DH_NAME DB	NAME_LEN DUP(0) 	;; device name in this header
DHS	ENDS				;; end of common portion
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	FONT_PARSER data
;;
;;	-- Interface table : FTABLE
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
FPKT	EQU	DS:[SI] 		;;
					;;
FTP	EQU	ES:[BX] 		;;
					;; ( I=Input  O=Output )
FTBLK	STRUC				;;
FTB_LENGTH DW	TYPE FTBLK		;; (NOT TO BE CHANGED)
FTB_STATUS DW	0FFFFH			;; (O) parsing compelte
FTB_TYPE DW	0			;; (O)
FTB_TID DB	8   DUP(?)		;; (I)
FTB_CP	DW	0FFFFH			;; (I)
FTB_MOD DW	0			;; (O)
FTB_FONTS DW	0			;; (O)
FTB_ROWS  DB	0			;; (O) DISPLAY TYPE DEVICE
FTB_COLS  DB	0			;; (O) DISPLAY TYPE DEVICE
FTB_X	  DB	0			;; (O) DISPLAY TYPE DEVICE
FTB_Y	  DB	0			;; (O) DISPLAY TYPE DEVICE
FTB_COUNT DW	0			;; (O) DISPLAY TYPE DEVICE
FTB_SELECT DW	0			;; (O) PRINTER TYPE DEVICE
FTB_SELLEN DW	0			;; (O) PRINTER TYPE DEVICE
FTB_DLEFT DW	0			;; (O)	=0, none to come
FTB_DLEN DW	0			;; (O)	=0, not in this packet
FTB_DALO DW	0			;; (O)	in the DOS "packet" buffer
FTB_DAHI DW	0			;; (O)	"  "   "    "       "
TARGET_LO DW	0			;;  internal registers
TARGET_HI DW	0			;;  internal registers
FTBLK	ENDS				;;
					;;
TYPE_DISPLAY EQU 01H			;; display type device
TYPE_PRINTER EQU 02H			;; printer type device
					;;
FBUFS	STRUC				;;
FLAG	DW	0			;;
BUFFER_LEN DW	0			;;
BUFFER_ADDR DD	0			;;
NUM_FTBLK DW	0			;; no. of FTBKL entries
FBUFS	ENDS				;;
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; FLAGS :
FLAG_RESTART EQU 000001H		;; bit 1 = restart the parsing
					;;
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; STATUS : (in FTB_STATUS)
					;;
FSTAT_COMPLETE EQU 0FFFFH		;; parsing compeleted. (good status)
FSTAT_FONT  EQU 0FFFEH			;; font data is defined and returned
FSTAT_FOUND EQU 0FFFDH			;; informations including font-length
FSTAT_MATCH EQU 0FFFCH			;; font header matches	FTBLK
FSTAT_SEARCH EQU 0FFFBH 		;; seraching for header & font
FSTAT_BOTTOM EQU 0FFF0H 		;; below this are the DOS_STATUS.
					;;
;; the FSTAT with value lower than 0FFF0H is to be returned to the DOS
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	DEVICE Command Parser Table   ES:[DI]
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
table_len	equ	290		;;
					;;
PSE	EQU	ES:[DI] 		;;
					;;
PAR_OT	STRUC				;;
PAR_DEV_NUM DW	?			;;
PAR_OFF DW	?			;;
PAR_OT	ENDS				;;
					;;
PAR_DEVOT STRUC 			;; OFFSET to the parameters of a device
PAR_onum DW	?			;; number of offsets in the table
PAR_DNMO DW	?			;; device-name table offset
PAR_DIDO DW	?			;; device-id table offset
PAR_HWCPO DW	?			;; hwcp table offset
PAR_DESGO DW	?			;; designate table offset
PAR_PARMO DW	?			;; parameter table offset
PAR_DEVOT ENDS				;;
					;;
PAR_DNMT STRUC				;; DEVICE NAME table
PAR_DNML DW	?			;; length of device name
PAR_DNM DB	?			;; device name
PAR_DNMT ENDS				;;
					;;
PAR_DIDT STRUC				;; DEVICE ID table
PAR_DIDL DW	?			;; device ID length
PAR_DID DB	?			;; device ID
PAR_DIDT ENDS				;;
					;;
PAR_HWCPT STRUC 			;; hwcp table
PAR_HWCPL DW	?			;; hwcp entry number
PAR_HWCP DW	?			;; hwcp
PAR_HWCPT ENDS				;;
					;;
					;;
PAR_DESGT STRUC 			;; DESIGNATE table
PAR_DESGL DW	?			;; entry number
PAR_DESG DW	?			;; designate
PAR_FONT DW	?			;; fonts
PAR_DESGT ENDS				;;
					;;
					;;
PAR_PARMT STRUC 			;; parameter table
PAR_PARML DW	?			;; length
PAR_PARM DW	?			;;
PAR_PARMT ENDS				;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; LPTn	printer data structure	CS:[BX]
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
BUF	EQU	CS:[BX] 		;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; STATES
					;;
NORMAL	EQU	0			;; normal state
CPSW	EQU	1			;;
DESG_WR EQU	2			;; designate write
DESG_END EQU	3			;; designate end
LOCKED	 EQU	4			;; WGR locked
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GOOD	EQU	0			;; STATUS :
REPLX	EQU	8000H			;; codepage replaced in DST
FAIL	EQU	4000H			;; fail in designate
LOADED	EQU	2000H			;; the font has just been loaded to
REFRESH EQU	0800H			;; there was a refresh via DST
					;;
					;; also
					;; -- DSF_CARTCP
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;; for BFLAG :
BF_PRN	EQU	0			;;  0 = PRN  initialized (interrupt)
BF_LPT1 EQU	1			;;  1 = LPT1 initialized (interrupt)
BF_LPT2 EQU	2			;;  2 = LPT2 initialized (interrupt)
BF_LPT3 EQU	3			;;  3 = LPT3 initialized (interrupt)
BF_MEM_DONE  EQU 08000H 		;;  memory done for this device
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; BUFFER DATA structure
BUF_DATA STRUC				;;.................................
BFLAG	 DW	-1			;; buf flag for initialisation
					;; -1 = buf not yet initialised
					;; (see BF_PRN, BF_LPT's)
					;;
DEV_HDRO DW	-1			;; device driver n header offset
DEV_HDRS DW	-1			;;
LPT_STRAO DW	-1			;; dos lptn strategy offset
LPT_STRAS DW	-1			;;
LPT_INTRO DW	-1			;; dos lptn strategy offset
LPT_INTRS DW	-1			;;
RH_PTRO DW	-1			;; request header offset
RH_PTRS DW	-1			;; segment ....................(unique)
					;;
					;; (following is replicated for LPT1 )
					;;
RNORMO	DW	-1			;; request-normal driver header offset
prn_bufo dw	-1			;; offset to prn buffer
did_prn  dw	 0			;; where PRN is in the DID order
PCLASS	 DW	 0			;;
STATE	DW	NORMAL			;;
STATUS	DW	GOOD			;;
					;; (the followings should be used
					;;  IFF BUT.STATE <> NORMAL : )
					;;
PDESCO	DW	-1			;; offset to printer description table.
					;;
					;;===== hwcp and designated slots ====
HSLMX	DW	0			;; HSLMX is the size of HARDslot (at
					;; HARDSO) and the buffer(at HRBUFO)
					;;
HARDMX	DW	0			;; no. of HWCP+cart slots supported
					;; (less than or equal to .HSLOTS)
HARDSO	DW	-1			;; offset to hardware slots n
					;;
HCARMX	DW	0			;; no. of cart slots supported
HRBUFO	DW	-1			;; offset to cart slots' buffer
					;;
					;;===== physical and designated RAM ===
					;;
RSLMX	DW	0			;; RSLMX is the size of RAMslot (at
					;; RAMSO) and the RAM buffer(at RMBUFO)
					;;
					;;
RAMMX	DW	0			;; no. of physical RAM slots(max.=1)
RAMSO	DW	-1			;; offset to RAM slots(incl. designated
					;;
RBUFMX	DW	0			;; no. of designated RAM slots supported
RMBUFO	DW	-1			;; offset to RAM slots's buffer
					;;
FTSZPA	DW	-1			;; font buffer in paragraph = FONTSZ
FTSIZE	DW	0			;; font buffer size = FTSZPA x 16
FTSTART DW	-1			;; start of font buffer
FTSLOTO DW	-1			;; segment address of font buffer
					;; -- of the one to be designated to
FTDLO	DW	-1			;; offset to where the FTSTART:OFFSET
					;; (next destination = total length
					;;		       so far)
FSELEN	DW	0			;; length of selection control copied
					;; to the selection buffer
					;; (USED BY SELECT TYPE = 1 ONLY)
					;; -- initialized to 0, if selection
					;;    is not 0, copied the selection
					;;    from the font file until the
					;;    length is reached. After copying
					;;    to selection buffer, reset to 0
FSELMAX DW	0			;; max. room reserved for selection
					;; controls.
					;;
PAR_EXTRACTO DB (TYPE PAR_DEVOT) DUP (-1);; Offset to parameter extracts
SAVED_CP    DW	-1			;; WGR saved code page during lock	    ;AN000;
BUFEND	DW	0			;; END OF BUFFER, for LPT1 copy.
BUF_DATA ENDS				;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	Printer Description Table
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
DEVN_LEN EQU	8			;; device name (type-id) length
					;;
PDSH	STRUC				;;
PD_LEN	DW	30			;; length of each entry
TYPEID	DB	'        '              ;; device name (id), length DEVN_LEN
VMINOR	DB	0			;; version :  .00
VMAJOR	DB	1			;; version : 1.
CLASS	DW	?			;; reserved
FONTSZ	DW	?			;; font buffer size in paragraph (max)
HSLOTS	DW	?			;; hard-slots number (max # of Hslots)
HWCPMIN DW	?			;; what left by min_hwcp can be cart.
RSLOTS	DW	?			;; ram-slots number  (max # of Rslots)
PDSH	ENDS				;; the SELH_O, and SELR_O are defined
					;; in the next two entries in PDS
					;;
					;;
PDS	STRUC				;;
	DB	(TYPE PDSH) DUP (?)	;; common portion
SELH_O	DW	?			;; offset to select controls on Hslots
SELR_O	DW	?			;; offset to select controls on Rslots
SELB_O	DW	?			;; offset to buffered select controls
PDS	ENDS				;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	HARD / RAM slots table structure/constants
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; NOTE : must be only FOUR bytes for
					;;	  codepage positioning
					;;	  calculation as compared
					;;	  with each entry in FTDL_OFF
					;;
SLTS	STRUC				;; slots-table structure
SLT_CP	DW	-1			;; code page : no code page
SLT_AT	DW	0			;; attribute : empty
SLTS	ENDS				;;
					;;
					;; ATTRIBUTES :
AT_RAM1 EQU	 00001H 		;; in the 1st physical RAM slot
AT_RAM2 EQU	 00002H 		;; in the 2nd physical RAM slot
AT_RAM3 EQU	 00004H 		;; in the 3rd physical RAM slot
AT_RAM4 EQU	 00008H 		;; in the 4th physical RAM slot
AT_RAMS EQU	 0000FH 		;;(note the current logic supports
					;; only ONE physical RAM slot)
					;;
AT_OCC	EQU	 01000H 		;; slot occupied
AT_ACT	EQU	 02000H 		;; slot active
AT_HWCP EQU	 04000H 		;; slot is hwcp
AT_OLD	EQU	 08000H 		;; codepage in buffer is not newly
					;; designated.
AT_LOAD EQU	 00100H 		;; slot with font to be loaded
AT_FONT EQU	 00200H 		;; font in this slot has been loaded
AT_NO_LOAD	EQU	NOT  AT_LOAD	;; to reset the bit
AT_NO_FONT	EQU	NOT  AT_FONT	;; to reset the bit
AT_SELECT EQU	 00400H 		;; for SELECT TYPE = 1
					;; -- mark the FTBLK where control is
					;;    copied from.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; constants on SLOTS
HARDSL_MAX EQU   6                      ;;
					;;
RAMSL_MAX EQU    6                      ;;
					;;
CTL_MAX 	EQU	32		;; max.length of each selection control
CTL5202_OFFS	EQU	8		;; offset to CTL5202_H for codepage
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	General Constants
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
STACK_SIZE	EQU	28H		;; in paragraph, total 200H bytes
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
; STRUCS AND EQUATES
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
PARSE_NAME    STRUC			;;					    ;AN000;
N_LENGTH      DW    ?			;;					    ;AN000;
FNAME	      DB    "        "          ;;                                          ;AN000;
PARSE_NAME    ENDS			;;					    ;AN000;
					;;
PARSE_OFFSETS STRUC			;;					    ;AN000;
	      DW    ?			;;					    ;AN000;
DN_OFFSET     DW    ?			;;					    ;AN000;
DI_OFFSET     DW    ?			;;					    ;AN000;
DCP_OFFSET    DW    ?			;;					    ;AN000;
DD_OFFSET     DW    ?			;;					    ;AN000;
	      DW    ?			;;					    ;AN000;
PARSE_OFFSETS ENDS			;;					    ;AN000;
					;;
PARSE_HWCP    STRUC			;;					    ;AN000;
NUM_HWCPS     DW    ?			;;					    ;AN000;
HWCP_1	      DW    ?			;;					    ;AN000;
HWCP_2	      DW    ?			;;					    ;AN000;
HWCP_3	      DW    ?			;;					    ;AN000;
HWCP_4	      DW    ?			;;					    ;AN000;
HWCP_5	      DW    ?			;;					    ;AN000;
HWCP_6	      DW    ?			;;					    ;AN000;
HWCP_7	      DW    ?			;;					    ;AN000;
HWCP_8	      DW    ?			;;					    ;AN000;
HWCP_9	      DW    ?			;;					    ;AN000;
HWCP_10       DW    ?			;;					    ;AN000;
PARSE_HWCP    ENDS			;;					    ;AN000;
					;;
PARSE_DESG    STRUC			;;					    ;AN000;
NUM_VALUES    DW    ?			;;					    ;AN000;
NUM_DESGS     DW    ?			;;					    ;AN000;
NUM_FONTS     DW    ?			;;					    ;AN000;
PARSE_DESG    ENDS			;;					    ;AN000;
					;;
					;;
ZERO	EQU	0H			;;					    ;AN000;
ONE	EQU	1H			;;					    ;AN000;
TWO	EQU	2H			;;					    ;AN000;
THREE	EQU	3H			;;					    ;AN000;
FOUR	EQU	4H			;;					    ;AN000;
FIVE	EQU	5H			;;					    ;AN000;
SIX	EQU	6H			;;					    ;AN000;
SEVEN	EQU	7H			;;					    ;AN000;
EIGHT	EQU	8H			;;					    ;AN000;
NINE	EQU	9H			;;					    ;AN000;
TEN	EQU    0AH			;;					    ;AN000;
NUMBER	      EQU    1			;;					    ;AN000;
STRING	      EQU    3			;;					    ;AN000;
COMPLEX       EQU    4			;;					    ;AN000;
RC_EOL	      EQU    -1 		;;					    ;AN000;
RC_NO_ERROR   EQU    0			;;					    ;AN000;
RC_OP_MISSING EQU    2			;;					    ;AN000;
ON	      EQU    1			;;					    ;AN000;
OFF	      EQU    0			;;					    ;AN000;
BAD_SYNTAX_MSG EQU   12 		;;					    ;AN000;
BAD_DEVICE_MSG EQU   2			;;					    ;AN000;
;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\power\xtoa.asm ===
page	,132
	title	xtoa - convert integers/longs to ASCII string
;***
;xtoa.asm - convert integers/longs to ASCII string
;
;	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	The module has code to convert integers/longs to ASCII strings.
;
;Revision History:
;	01-06-85  GFW	initial version
;	02-01-85  RN	fixed itoa so not sign-extended to 32 bits if radix
;			is not 10 (-1 in base 16 should be "ffff", not
;			"ffffffff")
;	02-05-85  RN	split itoa, ltoa, and ultoa out into separate modules
;			so user can redefine any or all of them without
;			running into 'bundling' problems and naming conflicts
;			when s/he links
;	11-22-89  GJF	Fixed copyright
;
;       06-05-91  MD    Stolen from C runtime for use with POWER.EXE
;
;*******************************************************************************


Trans_Code      segment word public 'CODE'
Trans_Code      ends

Trans_Data      segment word public 'DATA'
Trans_Data      ends

Trans_Code      segment
        assume  cs:Trans_Code, ds:Trans_Data

get_dec       proc    near
        public  get_dec

	mov	cx,10
        xor     bl,bl

;	ds:di = buffer
;	dx:ax = value
;	cx = radix
;	bl = 1 if signed, 0 if unsigned

	push	di			; save start of buffer
	push	ds
	pop	es			; ds = es = segment of buffer
	cld
	xchg	bx,ax			; dx:bx = number , ax = signed
	or	al,al
	jz	uxtoa			; unsigned conversion

	cmp	cx,10			; check for radix = 10
	jne	uxtoa			;   no - treat as unsigned

	or	dx,dx			; test for negative number
	jns	uxtoa

	mov	al,'-'
	stosb				; stuff out -
	neg	bx			; negate dx:bx
	adc	dx,0
	neg	dx

uxtoa:
	mov	si,di			; save start of number

divdown:
	xchg	ax,dx			; divide hi
	xor	dx,dx
	or	ax,ax
	jz	nohigh			; save a divide
	div	cx			; dx = rem, ax = hi div

nohigh:
	xchg	ax,bx			; ax = lo, bx = hi div
	div	cx			; dx = rem, bx:ax = div
	xchg	ax,dx			; ax = rem, bx:dx = div
	xchg	dx,bx			; ax = rem, dx:bx = div (tight!!!!)
	add	al,'0'
	cmp	al,'9'
	jbe	isadig			; is a digit already
	add	al,'a'-'0'-10		; convert to letter

isadig:
	stosb
	mov	ax,dx
	or	ax,bx
	jnz	divdown 		; crack out next digit

;	reverse digits

	mov	[di],al 		; stuff string terminator

revloop:
	dec	di			; point back to last char
	lodsb				; exchange bytes
	xchg	[di],al
	mov	[si-1],al
; The following is equivalent to "cmp si,(di-1)"
; but avoids segment wrap in case DI == 0
	lea	ax,[si+1]
	cmp	ax,di			; are we halfway?
	jb	revloop 		;   no

	pop	ax			; buffer offset
        ret

get_dec endp

Trans_Code      ends


	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\printer\cpspi.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

	PAGE	,132

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  FILENAME:		CPS Printer Device Driver INIT module (CPSPInn)
;;  MODULE NAME:
;;  TYPE:		Assemble file  (non-resident code)
;;  LINK PROCEDURE:	Link CPSPMnn+CPSFONT+CPSPInn into .EXE format. CPSPM01
;;			must be first.	CPSPInn must be last.  Everything
;;			before CPSPInn will be resident.
;;  INCLUDE FILES:
;;			CPSPEQU.INC
;;
;;  LAYOUT :		This file is divided into two main section :
;;			  ++++++++++++++++++++++++
;;			  ++	DEVICE Parser	++
;;			  ++++++++++++++++++++++++
;;
;;			  ++++++++++++++++++++++++
;;			  ++	INIT Command	++
;;			  ++++++++++++++++++++++++
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
INCLUDE CPSPEQU.INC			;;
					;;
PUBLIC	INIT				;;
PUBLIC	CODE_END			;; for MAP listing only
PUBLIC	RESIDENT_END			;;
PUBLIC	STACK_ALLOCATED 		;;
					;;
					;;
EXTRN	PRINTER_DESC_NUM:WORD		;;
EXTRN	PRINTER_DESC_TBL:WORD		;;
EXTRN	INIT_CHK:WORD,TABLE:WORD	;;
EXTRN	HARD_SL1:BYTE,RAM_SL1:BYTE	;;
EXTRN	HARD_SL2:BYTE,RAM_SL2:BYTE	;;
EXTRN	HARD_SL3:BYTE,RAM_SL3:BYTE	;;
EXTRN	HARD_SL4:BYTE,RAM_SL4:BYTE	;;
EXTRN	RESERVED1:WORD,RESERVED2:WORD	;;
					;;
EXTRN	MSG_NO_INIT_P:BYTE		;;
EXTRN	MSG_NO_INIT:BYTE		;;
EXTRN	MSG_BAD_SYNTAX:BYTE		;;
EXTRN	MSG_INSUFF_MEM:BYTE		;;
					;;
					;;
CSEG	SEGMENT PARA PUBLIC 'CODE'      ;;
	ASSUME	CS:CSEG 		;;
					;;
					;;
CODE_END     EQU $			;; end of resident code
					;;
	     DW  0			;; -- there are 16 bytes kept,
					;;    including this word
					;;
RESIDENT_END DW  0FFFH			;; end of extended resident area
STACK_ALLOCATED  DW -1			;; end of extended resident area
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	End of resident code
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Incorporating Device Command Parser :
;;
;; -- extracted from PARSE4E.ASM, size 49582 bytes
;;
;; (some modifications have to be made in the section right after the parser's
;;  document and before the GET_PARMS_A, one of them is :)
;;
;; -- move the TABLE to the printer device driver's main module
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;			  ++++++++++++++++++++++++
;;			  ++	DEVICE Parser	++
;;			  ++++++++++++++++++++++++
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;
;;   PARSER's code -- non resident
;;
;;	-- set ES:[DI] pointing to the Request Header before calling PARSER
;;
;;	to be called as PARSER with ES:[DI] defined as Request Header
;;	If there is any syntax error in the DEVICE command line, the
;;	Parser return a 0 in the first word (NUMBER)of the first table.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;
; Description: A command parser for DEVICE command in the CONFIG.SYS file.
; ------------
;
; Procedures contained in the file:
; ---------------------------------
;	       PARSER:	Main routine for command processing.
;	       GET_CHAR:  Gets a character from command line.
;	       IS_ALPH:  Checks if character is an alpha character.
;	       IS_DIGIT:  Checks if character is a digit.
;	       IS_DELIM:  Checks if character is a DOS delimiter.
;	       DEVICE_PARSE:  Pulls device name from command line and
;			      inserts in table.
;	       ID_PARSE:  Pulls id name from command line and insers in table
;	       HWCP_PARMS:  Extract HWCP number, converts it to binary and
;			    inserts it in table.
;	       HWCP_PARSE:  Extracts HWCP number if only one number is given.
;	       MUL_HWCP:  Extracts multiple HWCP's numbers, if they are given
;			  in a list.
;	       DESG_PARMS:  Extracts designate number, converts it to binary
;			    and inserts it in table.
;	       DESG_FONT:  Extracts the designate and the font if both were
;			   given in command line.
;	       DESG_PARSE:  Pulls designate number if it is the only one given.
;	       GET_NUMBER:  Converts a number to binary.
;	       OFFSET_TABLE:  Updates the counter in table #1.
;	       FIND_RIGHT_BR:  Looks for a right bracket.
;
;
; Change history:
; ---------------
;
;
;LOGIC:
;------
;	 Establish addressability to parameters.
;	 Skip until end of path and file name -first delimiter
;
;   Loop:
;	 Isolate the first non-delimiter or non delimeter characters.
;	  If End_of_Line_Delimiter then
;	    return an error_code
;	  Else
;	    If first non-delimiter is ALPHA then
;	      (assume a device name)
;	      Extracts device name
;	  Update offset counter
;
;	 Isolate the first non-delimiter characters after id name.
;	  If End_of_Line_Delimiter then
;	    return an error_code
;	  Else
;	    If first non-delimiter is ALPHA-NUMARIC or
;	     If character is '(' then
;	      (assume an id name)
;	      Extracts id name
;	  Update offset counter
;
;	  Pull out HWCP
;	    If error flag is set then exit
;	    Else if end of line flag is set then exit
;
;	  Pull out DESG parms
;	    If error_flag is set then exit.
;	    Else if end of line flag is set then exit
;	    Else if Number of devices is four then Exit
;	 Else Loop
;
;
;Subroutines Logic:
;------------------
;
;  GET_CHAR:
;  ---------
;	       Load character in AL
;	       If character less than 20h then
;		 turn Z-flag on
;
;  IS_ALPHA:
;  ---------
;	       Save character
;	       'Convert character to upper case'
;	       If character >=A and <=Z then
;		 turn Z-flag on
;		 exit
;	       Else
;		 Restore character
;		 exit.
;
;  IS_DIGIT:
;  ---------   If Character >=0 and <=9 then
;		 turn Z-flag on
;
;  IS_DELIMITER:
;  -------------
;	       If character a dos delimiter (' ','=',',',';',TAB)
;		  then turn Z-flag on
;
;  DEVICE_PARSE:
;  -------------
;	       Set device name length counter.
;	       Loop
;		 If a dos delimiter then
;		   add spaces to name (if require)
;		 Else if char is ALPHA-NUM then
;		   save in table
;		   If name >8 character thne
;		     error; exit
;		 Else
;		   error; exit
;
;  ID_PARSE:
;  ---------   Set id name length counter.
;	       Loop
;		 If a dos delimiter then
;		   add spaces to name (if require)
;		 Else if char is ALPHA-NUM then
;		   save in table
;		   If name >8 character then
;		     error; exit
;		 Else if char is ')' or '(' then
;		   set flags
;		 Else
;		   error; exit
;
;  HWCP_PARMS:
;  -----------
;	Loop:	Set flags off
;		If char is a DIGIT then
;		  convert number to binary
;		  update table
;		Else if char is ',' then
;		  no HWCP was given
;		  exit
;		Else if char is '(' then
;		  assume multiple HWCP
;		Else if char is ')' then
;		  end of parms, exit
;		Else if not a delimiter then
;		  error, exit set carry flag set carry flag
;		Loop
;
;  HWCP_PARSE:
;  -----------	Increment counter
;		Get number and convert to binary
;		Update the table
;		Set table_5 pointer
;
;  MUL_HWCP:
;  ---------
;      Loop:	If char is ')' then
;		  end of list, exit
;		If char is a DIGIT
;		  Get number and convert to binary
;		  Update table.
;		If char is not a delimiter then
;		  error, exit set carry flag
;		Loop
;
;  DESG_PARMS:
;  -----------
;	 Loop:	If char is a DIGIT then
;		  Get number and convert to binary
;		  Update table.
;		If char is a ')' then
;		  end of parms, exit
;		If char is a '(' then
;		  assume given desg. and font
;		If char is a ',' then
;		  no desg ginven
;		  scane for ')'
;		If char is not a delimiter then
;		  error, exit set carry flag
;		Loop
;
;  DESG_FONT:
;  ----------
;	Loop:	If char is a ',' then
;		  no desg number was given
;		  update table
;		If char is a ')' then
;		  end of desg-font pair, exit
;		If char is a DIGIT then
;		  Get number and convert to binary
;		  Update table
;		If char not a delimiter then
;		  error, exit set carry flag
;		Loop
;
;  DESG_PARSE:
;  -----------	Get number and conver to binary
;		Update table
;
;  GET_NUMBER:
;  -----------	Get ASCII number from parms
;		conver to binary
;		add to total
;
;  OFFSET_TABLE:
;  -------------
;		Increment the number of parms
;
;  FIND_RIGHT_BR:
;  --------------
;	  Loop: If char is ')' then
;		  found bracket exit
;		If char is not ' ' then
;		  error, exit set carry flag
;		Loop
; END
;------------------------------------------------------
;
; The following is the table structure of the parser.	All fields are
; two bytes field (accept for the device and id name)
;
; TABLE HEADER :
; 
;    Ŀ
;     N = Number of devices.	  
;    Ĵ
;    	 Device  # 1  offset	 >Ŀ
;    Ĵ		  			     
;    	 Device  # 2  offset	  		  	 Table_1  (a)	     
;    Ĵ		  			     
;    	 Device  # 3  offset	  		  
;    Ĵ
;    	 Device  # 4  offset	  
;    
;
;
; N = 1,2,3 or 4.  A two bytes number indicating the number of device specified.
; DEVICE # N OFFSET : a two bytes offset address to table_1. (ie. Device #1 offset
; is a pointer to table_1 (a). Device #2 offset is a pointer to table_1
; (b)...etc.).	 If an error was detected in the command N is set to zero.
;
;
;
; TABLE_1 :
; 
;
;    Ŀ	      Ŀ
;     N = Number of Offsets.	  	       			 
;    Ĵ    ĳ      Table_2  (a)	 
;    	 Device Name  offset	        			 
;    Ĵ	      
;    	 Device  Id   offset	 Ŀ
;    Ĵ	     Ŀ
;    	 Device  HWCP offset	 Ŀ      			 
;    Ĵ     ĳ      Table_3  (a)	 
;    	 Device  Desg offset	 Ŀ        			 
;    Ĵ         
;    	    "Reserved"               
;             Ŀ
;				             			 
;				      ĳ      Table_4  (a)	 
;				     	       			 
;				     	      
;				     	      Ŀ
;				     	       			 
;				     ĳ      Table_5  (a)	 
;					       			 
;					      
;
;
;  N=Length of table_1, or the number of offsets contained in table_1.
;  The offsets are pointers (two bytes) to the parameters value of the device.
;  "Reserved" : a two byte memory reserved for future use of the "PARMS" option.
;
;
; TABLE_2 :
; 
;
;    Ŀ
;     N = Length of devices name 
;    Ĵ
;    	  Device   name 	  
;    
;
; N = Length of device name.  Device length is always 8 byte long.
; Device Name : the name of the device (eg. LPT1, CON, PRN).  The name
; is paded with spaces to make up the rest of the 8 characters.
;
;
;
; TABLE_3 :
; 
;
;    Ŀ
;     N = Length of Id name.	  
;    Ĵ
;    	   Id	Name		  
;    
;
; N = Length of id name.  Id name length is always 8 byte long.
; Id Name : the name of the id (eg. EGA, VGA, 3812).  The name
; is paded with spaces to make up the rest of the 8 character.
;
;
;
; TABLE_4 :
; 
;
;    Ŀ
;     N = Length of table.	  
;    Ĵ
;    	  HWCP	#  1		  
;    Ĵ
;    	  HWCP	#  2		  
;    Ĵ
;    		.		  
;    		.		  
;    		.		  
;    Ĵ
;    	  HWCP	#  10		  
;    
;
;
; N = Length of table in words. Or the number of HWCP's.
; HWCP # N : a hardware code page number converted to binary.  The maximum
; number of pages allowed is 10.
;
;
;
; TABLE_5 :
; 
;
;    Ŀ
;     N = Length of table.	  
;    Ĵ
;    	  Designate		  
;    Ĵ
;    	  Font			  
;    
;
; N = Lenght of table.	0 - nothing was specified
;			1 - Only a designate was specified.
;			2 - Designate and font were given.  If the Desg field
;			    was left empty in the DEVICE command then the
;			    Designate field is filled with 0FFFFH.
; Designate, Font : Are the Desg. and Font binary numbers.
;
;------------------------------------------------------
;

;RESERVED MEMORY:
TABLE_1 	DW	?			; Pointer at offsets.
TABLE_2 	DW	?			; Pointer at device name.
TABLE_3 	DW	?			; Pointer at id name.
TABLE_4 	DW	?			; Pointer at hwcp.
TABLE_5 	DW	?			; Pointer at desg and font.
;TABLE		 DB	 290 DUP (?)		 ; Table of parsed parms. Max 4 devices.
DEVNUM		DW	?			; Counter to number of devices.
RIGHT_FLAG	DB	?			; Flag to indicate a left bracket.
DEV_ERR_FLG	DB	?			; Device name error flag.
ID_ERR_FLG	DB	?			; Id name error flag.
ERROR_FLAG	DB	?			; Error flag_terminate program if set to 1.
COMMA_FLAG	DB	?			; Indicate the number of commas incounterd.
HWCP_FLAG	DB	?			; Flag for multiple hwcps.
DESG_FLAG	DB	?			; Flag indicates desg. and font.

;Main part of program-links different sumbroutines together

PARSER		PROC

		PUSH	AX			; ;;;;;;;;;;;;;;;;;;
		PUSH	BX			; ;
		PUSH	CX			; ; SAVE
		PUSH	DX			; ; ALL
		PUSH	DS			; ; REGISTERS.
		PUSH	ES			; ;
		PUSH	DI			; ;
		PUSH	SI			; ;;;;;;;;;;;;;;;;;;

		LES	SI,RH.RH0_BPBA	       ; Point at all after DEVICE=
						; in the CONFIG.SYS file.


;Skip to end of file name, to the first DOS delimiter.

		MOV	DEVNUM,02H		; Number of devices counter.

GET_PARMS_A:	CALL	GET_CHAR		; Get command character in AL .
		JZ	EXIT_B			; No parms found.
		CALL	IS_DELIM		; If not a delimiter then.
		JNE	GET_PARMS_A		; Check next character.

		MOV	DI,OFFSET TABLE 	; Get the table address.
		ADD	DI,02H			; Point at devices offsets.
		MOV	BX,DI			;
		ADD	BX,08H			; Point BX at parms offsets.
TAB2:		CALL	UPDATE_TABLE		; Update table pointers value.

CLR_DELIM:	CALL	GET_CHAR		; Get character into AL.
		JZ	EXIT_B			; No parms found.
		CALL	IS_ALPHA		; If alpha then assume.
		JZ	DEVICE			; A device name.
		CALL	IS_DELIM		; Is it a delimiter
		JNE	EXIT_A			; If not then error.
		JMP	CLR_DELIM		; Get next character.

DEVICE: 	MOV	DEV_ERR_FLG,00H 	; Set device error flag off;
		CALL	DEVICE_PARSE		; Call routine to parse device name.
		CMP	DEV_ERR_FLG,01H 	; If error flag is
		JZ	EXIT_A			; set then exit.
		CALL	OFFSET_TABLE		; Update table.

ID_PARMS:	CALL	GET_CHAR		; Load a character in AL.
		JZ	EXIT_A			; Exit if end of line (error).
		CMP	AL,'('                  ; If AL is a '(' then
		JE	ID			; Parse ID name.
		CALL	IS_ALPHA		; If an Alpha
		JE	ID			; Then parse ID name.
		CALL	IS_DIGIT		; If a digit
		JE	ID			; Then parse ID name.
		CALL	IS_DELIM		; If not a delimiter
		JNE	EXIT_A			; Then error, exit
		JMP	ID_PARMS		; Get another number

EXIT_B: 	CMP	DEVNUM,02H		; If device number above 2 then
		JA	EXIT_C			; Exit parse.
		JMP	EXIT_A			; Else error, exit

ID:		MOV	ID_ERR_FLG,00H		; Set id error flag off.
		CALL	ID_PARSE		; Parse ID name.
		CMP	ID_ERR_FLG,01H		; Was error flag set, then
		JE	EXIT_A			; Print error message.
		CALL	OFFSET_TABLE		; Update table of offsets.

		CALL	HWCP_PARMS		; Get code page number
		CMP	ERROR_FLAG,01H		; If error, then
		JE	EXIT_A			; Print error message and exit
		CMP	ERROR_FLAG,02H		; If end of string
		JE	EXIT_H			; Then exit.

		CALL	DESG_PARMS		; Get designate number
		CMP	ERROR_FLAG,01H		; If error, then
		JE	EXIT_A			; Print error message and exit
		JMP	EXIT_H			; Then exit.

EXIT_A: 	MOV	DI,OFFSET TABLE 	; Load table offset
		MOV	DS:WORD PTR [DI],00H	; Set error to on.
		STC				; Set carry flag
		JMP	EXIT_P			; Exit parse.

EXIT_H: 	MOV	DI,OFFSET TABLE 	; Load table offset.
		ADD	DS:WORD PTR [DI],01H	; Increment number of devices.
		CMP	DEVNUM,08H		; If 4 devices loaded
		JE	EXIT_C			; Then exit parse.
		ADD	DEVNUM,02H		; Increment the number of devices
		ADD	DI,DEVNUM		; Point at next devices offset.
		MOV	BX,TABLE_5		; BX point at
		ADD	BX,06H			; end of previous table.
		JMP	TAB2			; Get next device.

EXIT_C: 	CLC

EXIT_P: 	POP	SI			; ;;;;;;;;;;;;;;;;;;
		POP	DI			; ;
		POP	ES			; ;  RESTORE
		POP	DS			; ;  ALL
		POP	DX			; ;  REGISTERS.
		POP	CX			; ;
		POP	BX			; ;
		POP	AX			; ;;;;;;;;;;;;;;;;;;
		RET

PARSER		ENDP


;********************************************************
;** GET_CHAR : a routine to get next character pointed **
;** to by ES:SI into AL.			       **
;********************************************************

GET_CHAR	PROC

		MOV	AL,ES:BYTE PTR [SI]	; Load character pointed to
		CMP	AL,09H			; by ES:[SI] in AL.
		JE	ZOFF			; If tab then O.K
		CMP	AL,20H			; Turn Z-flag on
		JL	TURN_Z_ON		; if character
ZOFF:		INC	SI			; is below
		JMP	GET_CHAR_X		; 20h.
						; ( End of line
TURN_Z_ON:	CMP	AL,AL			;   delimiters ).
GET_CHAR_X:	RET

GET_CHAR	ENDP


;********************************************************
;** IS_ALPHA : a routine to check the character in     **
;** AL if it is an alpha character (a...z,A...Z).      **
;** If character is lower case, convert to upper case. **
;********************************************************

IS_ALPHA	PROC

		PUSH	AX			; Save value of AL
		AND	AL,0DFH 		; Convert to upper case
		CMP	AL,'A'                  ; If <'A', then
		JB	IS_ALPHA_X		; NZ-flag is set, exit
		CMP	AL,'Z'                  ; If >'Z', then
		JA	IS_ALPHA_X		; NZ-flag is set, exit
		CMP	AL,AL			; Force Z-flag
		POP	DX			; Discard lower case.
		JMP	IA_X			; Exit.
IS_ALPHA_X:	POP	AX			; Restore value of AL
IA_X:		RET

IS_ALPHA	ENDP


;********************************************************
;** IS_DIGIT : a routine to check if the character in  **
;** AL register is a digit (i.e. 1..9). 	       **
;********************************************************

IS_DIGIT	PROC

		CMP	AL,'0'                  ; If < '0' then
		JB	IS_NUM_X		; NZ-flag is set, exit
		CMP	AL,'9'                  ; If > '9' then
		JA	IS_NUM_X		; NZ-flag is set, exit
		CMP	AL,AL			; Set Z-flag to indecate digit
IS_NUM_X:	RET

IS_DIGIT	ENDP


;********************************************************
;** IS_DELIM : This routine check if the character in  **
;** AL is a delimiter. ('+',' ',';',',','=',tab)       **
;********************************************************

IS_DELIM	PROC

		CMP	AL,' '                  ; Test for space.
		JE	IS_DELIM_X		; Z-flag is set, exit
		CMP	AL,','                  ; Test for comma.
		JE	IS_DELIM_X		; Z-flag is set, exit
		CMP	AL,';'                  ; Test for semicolon.
		JE	IS_DELIM_X		; Z-flag is set, exit
		CMP	AL,'='                  ; Test for equal sign.
		JE	IS_DELIM_X		; Z-flag is set, exit
		CMP	AL,09h			; Test for TAB.

IS_DELIM_X:	RET				; Exit

IS_DELIM	ENDP


;********************************************************
;** DEVICE_PARSE : Parse the device driver name and    **
;** store in table.  Update offset.		       **
;********************************************************

DEVICE_PARSE	PROC

		MOV	DI,TABLE_2
		MOV	DS:WORD PTR [DI],0008H	; Save dev name size.
		ADD	DI,02H			; Increment DI.
		MOV	CX,9			; Set counter.
NEXT_C: 	CALL	IS_ALPHA		; if Check then.
		JZ	SAVE_C			; Save it.
		CALL	IS_DIGIT		; if Digit then.
		JZ	SAVE_C			; Save it.
		CMP	AL,'-'                  ; If '-' then.
		JZ	SAVE_C			; Save it.
		CALL	IS_DELIM		; If a delimiter then.
		JZ	ADD_SPACE1		; Pad with spaces.
		CMP	AL,':'                  ; If a colon
		JE	ADD_SPACE1		; then end device parse
		JMP	ERR_DEV_PAR		; Else an error.

SAVE_C: 	DEC	CX			; Decrement counter.
		CMP	CX,0			; If counter zero then.
		JE	ERR_DEV_PAR		; Error.
		MOV	DS:BYTE PTR [DI],AL	; Save char in table.
		INC	DI			; Increment pointer.
		CALL	GET_CHAR		; Get another char.
		JZ	ERR_DEV_PAR
		JMP	NEXT_C			; Check char.

ERR_DEV_PAR:	MOV	DEV_ERR_FLG,01H 	; Set error flag.
		JMP	DEV_PAR_X		; Exit.

ADD_SPACE1:	DEC	CX			; Check counter.
		CMP	CX,1
		JL	DEV_PAR_X		; Exit if already 8.
LL1:		MOV	DS:BYTE PTR [DI],' '    ; Pad name with spaces.
		INC	DI			; Increment pointer.
		LOOP	LL1			; Loop again.
DEV_PAR_X:	RET

DEVICE_PARSE	ENDP


;********************************************************
;** ID_PARSE : Parse the id driver name and	       **
;** store in table.  Update offset.		       **
;********************************************************

ID_PARSE	PROC

		MOV	DI,TABLE_3
		MOV	DS:WORD PTR [DI],0008H	; Save dev name size.
		ADD	DI,02H			; Increment DI.
		MOV	RIGHT_FLAG,00H		; Clear flag.
		MOV	CX,9			; Set counter.

NEXT_I: 	CALL	IS_ALPHA		; If Check then.
		JZ	SAVE_I			; Save it.
		CALL	IS_DIGIT		; if Digit then.
		JZ	SAVE_I			; Save it.
		CMP	AL,'-'                  ; If '-' then.
		JZ	SAVE_I			; Save it.
		CMP	AL,'('                  ; If '(' then.
		JE	RIG_BR_FLG		; Set flag.
		CMP	AL,')'                  ; If ')' then
		JE	BR_FLG_LEF		; Pad with spaces.
		CALL	IS_DELIM		; If a delimiter then.
		JZ	ADD_SPACE2		; Pad with spaces.
		JMP	ERR_ID_PAR		; Else an error.

SAVE_I: 	DEC	CX			; Decrement counter.
		CMP	CX,0			; If counter zero then.
		JLE	ERR_ID_PAR		; Error.
		MOV	DS:BYTE PTR [DI],AL	; Save char in table.
		INC	DI			; Increment pointer.
		CALL	GET_CHAR		; Get another char.
		JZ	ADD_SPACE2		; Exit routine.
		JMP	NEXT_I			; Check char.

ERR_ID_PAR:	MOV	ID_ERR_FLG,01H		; Set error falg on.
		JMP	ID_PAR_X		; Exit.

BR_FLG_LEF:	CMP	RIGHT_FLAG,01H		; If left bracket was
		JNE	ERR_ID_PAR		; found and no previous
		JMP	ADD_SPACE2		; Bracket found, then error

RIG_BR_FLG:	CMP	RIGHT_FLAG,01H		; If more than one bracket
		JE	ERR_ID_PAR		; then error.
		CMP	CX,09			; If '(' and already id
		JB	ERR_ID_PAR		; then error.
		MOV	RIGHT_FLAG,01H		; Set flag for.
		CALL	GET_CHAR		; Left brackets.
		JZ	ERR_ID_PAR		; If end of line,exit.
		JMP	NEXT_I			; Check character.

ADD_SPACE2:	DEC	CX			; Check counter.
		CMP	CX,1
		JL	ID_PAR_X		; Exit if already 8.

LL2:		MOV	DS:BYTE PTR [DI],' '    ; Pad name with spaces.
		INC	DI			; Increment pointer.
		LOOP	LL2			; Loop again.

ID_PAR_X:	RET

ID_PARSE	ENDP

;********************************************************
;** HWCP_PARMS : Scane for the hardware code page, and **
;** parse it if found.	Flag  codes set to:	       **
;** ERROR_FLAG = 0 - parsing completed. No error.      **
;** ERROR_FLAG = 1 - error found exit parse.	       **
;** ERROR_FLAG = 2 - end of line found, exit parse.    **
;********************************************************


HWCP_PARMS	PROC

		MOV	COMMA_FLAG,00H		; Set the comma flag off.
		MOV	ERROR_FLAG,00H		; Set the error flag off.
		DEC	SI			; Point at current char in Al.
		CMP	RIGHT_FLAG,01H		; If no left brackets then
		JNE	LEFT_BR 		; Exit parse.

HWCP_1: 	CALL	GET_CHAR		; Load character in AL.
		JZ	LEFT_BR 		; Exit, if end of line.
		CALL	IS_DIGIT		; Check if digit, then
		JE	HP1			; Parse hwcp parms.
		CMP	AL,','                  ; If a comma
		JE	COMMA_1 		; Jump to comma_1
		CMP	AL,')'                  ; If a ')' then
		JE	RIGHT_BR		; end of current dev parms.
		CMP	AL,'('                  ; If a '(' then
		JE	HWCP_2			; There are multible hwcp.
		CALL	IS_DELIM		; Else, if not a delimiter
		JNE	EXIT_2			; Then error, exit
		JMP	HWCP_1			; Get another character.

LEFT_BR:	CMP	RIGHT_FLAG,01H		; If no left bracket
		JE	EXIT_2			; Then error, exit
		JMP	RB1			; Jump to rb1

COMMA_1:	CMP	COMMA_FLAG,01H		; If comma flag set
		JE	COM_2_HC		; Then exit hwcp parse.
		MOV	COMMA_FLAG,01H		; Else set comma flag.
JMP HWCP_1 ; Get another character.

HWCP_2: 	CMP	RIGHT_FLAG,01H		; If left bracket not set
		JNE	EXIT_2			; then error.
		CALL	MUL_HWCP		; else call multiple hwcp
		ADD	DI,02H			; routine.  Increment DI
		MOV	TABLE_5,DI		; Desg. Table starts at end
		CALL	OFFSET_TABLE		; Update table of offsets.
		JMP	HP_X			; Exit.

HP1:		JMP	HWCP			; Jump too long.

COM_2_HC:	MOV	DI,TABLE_4		; DI points at hwcp table
		MOV	DS:WORD PTR [DI],0000H	; Set number of pages to
		MOV	COMMA_FLAG,00H		; Zero and reset comma flag.
		ADD	DI,02H			; Increment DI.
		MOV	TABLE_5,DI		; Desg. Table starts at end
		CALL	OFFSET_TABLE		; Update table of offsets.
		JMP	HP_X			; of hwcp table.  Exit.

RIGHT_BR:	CMP	RIGHT_FLAG,01H		; If left brackets not
		JNE	EXIT_2			; Found then error.
RB1:		MOV	ERROR_FLAG,02H		; Set end of line flag.
		MOV	BX,TABLE_4		; Point at hwcp table
		ADD	BX,02H			; Adjust pointer to  desg
		MOV	TABLE_5,BX		; table, and save in table_5
		MOV	DI,TABLE_1		; Point at table of offsets
		ADD	DI,08H			; Set at DESG offset
		MOV	DS:WORD PTR [DI],BX	; Update table.
		JMP	HP_X			; Exit



EXIT_2: 	MOV	ERROR_FLAG,01H		; Set error flag.
		JMP	HP_X			; and exit.

HWCP:		CMP	RIGHT_FLAG,01H		; If left brackets not
		JNE	EXIT_2			; Found then error.
		CALL	HWCP_PARSE		; Call parse one hwcp.
		CMP	ERROR_FLAG,01H		; If error flag set
		JE	HP_X			; Then exit,  else
		CALL	OFFSET_TABLE		; Update table of offsets.

HP_X:		RET

HWCP_PARMS	ENDP


;********************************************************
;** HWCP_PARSE : Parse the hardware code page page     **
;** number and change it from hex to binary.	       **
;********************************************************

HWCP_PARSE	PROC

		MOV	DI,TABLE_4		; Load address of hwcpages.
		ADD	DS:WORD PTR [DI],0001H	; Set count to 1

		CALL	GET_NUMBER		; Convert number to binary.
		CMP	ERROR_FLAG,01H		; If error then
		JE	HWCP_X			; Exit.
		MOV	DS:WORD PTR [DI+2],BX	; Else, save binary page number
		ADD	DI,04H			; Increment counter
		MOV	TABLE_5,DI		; Set pointer of designate num

HWCP_X: 	RET

HWCP_PARSE	ENDP


;********************************************************
;** MUL_HWCP : Parse multiple hardware code pages      **
;** and convert them from hex to binary numbers.       **
;********************************************************

MUL_HWCP	PROC

		MOV	DI,TABLE_4		; Load offset of table_4
		MOV	BX,DI			; in DI and Bx.
		MOV	HWCP_FLAG,00H		; Set hwcp flag off.

MH1:		CALL	GET_CHAR		; Load character in AL.
		JZ	MH3			; Exit if end of line.
		CMP	AL,')'                  ; If ')' then exit
		JE	MH2			; end of parms.
		CALL	IS_DIGIT		; If a digit, then
		JE	MH4			; Convert number to binary.
		CALL	IS_DELIM		; If not a delimiter
		JNE	MH3			; then error, exit
		JMP	MH1			; get another character.

MH2:		CALL	GET_CHAR		; Get next character
		JMP	MH_X			; and exit.

MH3:		MOV	ERROR_FLAG,01H		; Set error flag on.
		JMP	MH_X			; Exit.

MH4:		ADD	HWCP_FLAG,01H		; Set hwcp flag on (0 off)
		ADD	DI,02H			; Increment table pointer
		PUSH	BX			; Save Bx
		CALL	GET_NUMBER		; Convert number to binary.
		MOV	DS:WORD PTR [DI],BX	; Add number to table
		POP	BX			; Restore BX.
		CMP	ERROR_FLAG,01H		; If error then
		JE	MH_X			; Exit.
		ADD	DS:WORD PTR [BX],01H	; Increment hwcp count.
		DEC	SI			; Point at character in AL
		JMP	MH1			;   (delimeter or ')').
MH_X:		RET

MUL_HWCP	ENDP



;********************************************************
;** DESG_PARMS : Scane for the designate numbers, and  **
;** parse it if found.	Flag  codes set to:	       **
;** ERROR_FLAG = 0 - parsing completed. No error.      **
;** ERROR_FLAG = 1 - error found exit parse.	       **
;** ERROR_FLAG = 2 - end of line found, exit parse.    **
;********************************************************


DESG_PARMS	PROC

		MOV	DI,TABLE_1		; Get offset of dev in DI
		MOV	BX,TABLE_5		; & offset of desg. in BX.
		ADD	DI,08			; Location of desg offset in table.
		MOV	DS:WORD PTR [DI],BX	; Update table.
		MOV	COMMA_FLAG,00H		; Set comma flag off.

		cmp	al,'('
		je	df
		cmp	al,')'
		je	right_br2

		cmp	al,','
		jne	desg_parm1
		mov	comma_flag,01h

DESG_PARM1:	CALL	GET_CHAR		; Get character in AL.
		JZ	EXIT_3			; Error, if end of line
		CALL	IS_DIGIT		; If character is a digit
		JE	DESG			; Then convert to binary.
		CMP	AL,')'                  ; If a ')', then
		JE	RIGHT_BR2		; end of parameters.
		CMP	AL,'('                  ; If a '(' then
		JE	DF			; parse desg and font.
		CMP	AL,','                  ; If a comma then
		JE	DP3			; set flag.
		CALL	IS_DELIM		; If not a delimiter
		JNE	EXIT_3			; then error.
		JMP	DESG_PARM1		; Get another character.

RIGHT_BR2:	CMP	RIGHT_FLAG,01H		; IF no '(' encountered,
		JNE	EXIT_3			; then error, exit
		JMP	DP_x			; Jump to DP1.

EXIT_3: 	MOV	ERROR_FLAG,01H		; Set error flag on
		JMP	DP_X			; Exit.

DF:		CMP	RIGHT_FLAG,01H		; If no '(' encountered
		JB	EXIT_3			; then error, exit
		CALL	DESG_FONT		; Parse desg and font.
		JMP	DP1			; Jump to DP1.

DP2:		CALL	FIND_RIGHT_BR		; Check for ')'
		JMP	DP_X			; Exit.

DP3:		CMP	COMMA_FLAG,01H		; If comma flag set
		JE	DP2			; then error
		MOV	COMMA_FLAG,01H		; Else set comma flag on.
		JMP	DESG_PARM1		; Get another character.

DESG:		MOV	ERROR_FLAG,00H		; Set error flag off.
		CALL	DESG_PARSE		; Parse desg.
DP1:		CMP	ERROR_FLAG,01H		; If error flag on then
		JE	DP_X			; Exit,
		CALL	FIND_RIGHT_BR		; Else check for ')'
		CALL	OFFSET_TABLE		; Update table

DP_X:		RET

DESG_PARMS	ENDP



;********************************************************
;** DESG_FONT : Parse the designate and font numbers & **
;** change them from decimal to binary. 	       **
;********************************************************


DESG_FONT	PROC


		MOV	DI,TABLE_5		; Get desg font table.
		MOV	COMMA_FLAG,00H		; Set comma flag off.
DF1:		CALL	GET_CHAR		; Load a character in AL.
		JZ	DF3			; Error if end of line.
		CMP	AL,','                  ; Check if a comma.
		JE	DF2			; Set flag.
		CALL	IS_DIGIT		; If a digit, then
		JE	DF5			; Convert number to binary.
		CMP	AL,')'                  ; If a ')' then
		JE	DF4			; Exit.
		CALL	IS_DELIM		; If not a delimiter
		JNE	DF3			; then error, exit
		JMP	DF1			; Get another character.

DF2:		CMP	COMMA_FLAG,01H		; If comma flag on
		JE	DF3			; then error, exit
		MOV	COMMA_FLAG,01H		; Set comma flag on
		ADD	DS:WORD PTR [DI],01H	  ; Increment desg counter.
		MOV	DS:WORD PTR [DI+2],0FFFFH ; Load ffffh for desg empty
		JMP	DF1			  ; field.

DF3:		MOV	ERROR_FLAG,01H		; Set error flag on.
		JMP	DF_X			; Exit.

DF4:		CMP	DESG_FLAG,00H		; If desg flag off
		JE	DF3			; then error, exit
		JMP	DF_X			; Else exit.

DF5:		ADD	DS:WORD PTR [DI],01H	; Increment desg font count.
		CMP	DESG_FLAG,01H		; If desg flag is on
		JE	DF6			; then get font.
		CMP	COMMA_FLAG,01H		; if comma flag is on
		JE	DF6			; then get font.
		MOV	DESG_FLAG,01H		; Set desg flag on
		JMP	DF7			; Get desg number.

DF6:		ADD	DI,02H			; adjust pointer to font.
		MOV	DESG_FLAG,02H		; Set desg and font flag.
DF7:		CALL	GET_NUMBER		; Get a number & convert to
		CMP	ERROR_FLAG,01H		; binary.
		JE	DF_X			; If error flag set, Exit.
		MOV	DS:WORD PTR [DI+2],BX	; Store number in table.
		CMP	DESG_FLAG,02H		; If desg and font flag
		JNE	DF1			; not set, then get char.
		CALL	FIND_RIGHT_BR		; Check for right bracket.

DF_X:		RET

DESG_FONT	ENDP


;********************************************************
;** DESG_PARSE : Parse the designate number and        **
;** change it from decimal to binary.		       **
;********************************************************

DESG_PARSE	PROC

		MOV	DI,TABLE_5		; Load designate location
		ADD	DS:WORD PTR [DI],0001H	; Update table count.

		CALL	GET_NUMBER		; Get the ascii number and
		CMP	ERROR_FLAG,01H		; conver it to binary
		JE	DESG_X			; If error then exit

		MOV	DS:WORD PTR [DI+2],BX	; Else, save desg number


DESG_X: 	RET

DESG_PARSE	ENDP


;********************************************************
;** GET_NUMBER : Convert the number pointed to by  SI  **
;** to a binary number and store it in BX	       **
;********************************************************

GET_NUMBER	PROC

		MOV	CX,0AH			; Set multiplying factor
		XOR	BX,BX			; Clear DX

NEXT_NUM:	SUB	AL,30H			; Conver number to binary
		CBW				; Clear AH
		XCHG	AX,BX			; Switch ax and bx to mul
		MUL	CX			; already converted number by 10.
		JO	ERR_NUM 		; On over flow jump to error.
		ADD	BX,AX			; Add number to total.
		JC	ERR_NUM 		; On over flow jump to error.
		XOR	AX,AX			; Clear AX (clear if al=0a).
		CALL	GET_CHAR		; Get next character
		JZ	GET_NUM_X		; Exit, if end of line.
		CALL	IS_DIGIT		; Call is digit.
		JNZ	GET_NUM_X		; Exit if not a number.
		JMP	NEXT_NUM		; Loop.

ERR_NUM:	MOV	ERROR_FLAG,01H		; Set error code to 1.

GET_NUM_X:	RET

GET_NUMBER	ENDP


;********************************************************
;** UPDATE_TABLE : This routine set up pointers to the **
;** different offsets of the different tables	       **
;********************************************************

UPDATE_TABLE	PROC

		MOV	DS:WORD PTR [DI],BX	; Offset of offsets
		MOV	TABLE_1,BX		; Table_1 points at offsets

		MOV	DI,BX			;
		ADD	BX,0CH			;
		MOV	DS:WORD PTR [DI+2],BX	; Offset of DEVICE name.
		MOV	TABLE_2,BX		; Table_2 point at device name.

		ADD	BX,0AH			;
		MOV	DS:WORD PTR [DI+4],BX	; Offset of ID name.
		MOV	TABLE_3,BX		; Table_3 point at ID name.

		ADD	BX,0AH			;
		MOV	DS:WORD PTR [DI+6],BX	; Offset of HWCP pages.
		MOV	TABLE_4,BX		; Table_4 point at HWCP pages.

		RET

UPDATE_TABLE	ENDP


;********************************************************
;** OFFSET_TABLE : This routine set up pointers of     **
;** tables number one and two.			       **
;********************************************************

OFFSET_TABLE	PROC

		MOV	DI,TABLE_1		; Increment the number
		ADD	DS:WORD PTR [DI],01H	; of parms foun. (ie. id,hwcp
		RET				; and desg)

OFFSET_TABLE	ENDP


;********************************************************
;** FIND_RIGHT_BR :This routine scane the line for a   **
;** ')' if cannot find it turns error flag on          **
;********************************************************

FIND_RIGHT_BR	PROC

FBR1:		CMP	AL,')'                  ; If a right bracket
		JE	FBR_X			; then exit.
		CMP	AL,' '                  ; If not a space
		JNE	FBR2			; Then error.
		CALL	GET_CHAR		; Get a character
		JZ	FBR2			; If end of line then exit.
		JMP	FBR1			; Else get another character.

FBR2:		MOV	ERROR_FLAG,01H		; Set error flag on
FBR_X:		MOV	AL,20H			; Erase character from AL.
		RET

FIND_RIGHT_BR	ENDP

;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;;
;;			  ++++++++++++++++++++++++
;;			  ++	INIT Command	++
;;			  ++++++++++++++++++++++++
;;
;;====	Command Code 0 - Initialization  ======
;;
;; messages returned :
;;
;; msg_bad_syntax  -- syntax error from parser, no driver installation
;; msg_no_init	   -- device cannot be initialised
;; msg_insuff_mem  -- insufficient memory
;;
;; layout :	the initialization is done in two stages :
;;
;;		  ++++++++++++++++++++++++
;;		  ++   INIT Stage 1	++	to examine and extract the
;;		  ++++++++++++++++++++++++	parameters defined for the
;;						device_id in DEVICE command,
;;						according to the printer
;;						description table for the
;;						device_id.
;;
;;		  ++++++++++++++++++++++++
;;		  ++   INIT Stage 2	++	to set the BUFfer for the LPTn
;;		  ++++++++++++++++++++++++	or PRN according to device_id's
;;						parameters
;;
;;
;;
;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
					;;
DEV_NUM dw	?			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;     Tables for the deivce_id parameters in the order of device_id in the
;     PARSE table
;     === the tables serves as the link between LPTn to be defined in the 2nd
;	  stage, and the device_id that is processed in the first stage.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; device ID indicators :
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DID_MAX EQU	4			;; device entris exepcted in PARSE
;; not more than 16.			;; table
					;;
DID_STATUS DW	0			;; status of parsing device id
					;;  =  0 : all Device-ID bad
					;;  -- see DID_BIT
					;;
DID_MATCH  DW	0			;; this DID has device_name matched
					;;
DID_FAIL   DW	0			;; to fail the good DID_STATUS and
					;; the matched name. (due to
					;; inconsistency among the same LPTn
					;; or between PRN and LPT1.)
					;;
;; (DID_STATUS) AND (DID_MATCH) XOR (DID_FAIL) determines the success of DID
					;;		       initialization
					;;
DID_ONE EQU	00001H			;; first device-ID
DID_TWO EQU	00002H			;; second "
DID_THREE EQU	  00004H		;; third  "
DID_FOUR  EQU	  00008H		;; fourth "
;;maximun number of device_id = 16	;;
					;;
DID_BIT LABEL WORD			;;
	DW	DID_ONE 		;;
	DW	DID_TWO 		;;
	DW	DID_THREE		;;
	DW	DID_FOUR		;;
;;maximun number of device_id = 16	;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; device paramters according to the
					;; device_id defined in DEVICE and the
					;; parameters defined for the device_id
					;; in the printer description table.
					;;
HRMAX	LABEL	word			;; number of hwcp+cart slots supported
	DW	0			;;  did = 1
	DW	0			;;  did = 2
	DW	0			;;  did = 3
	DW	0			;;  did = 4
;upto max  DID_MAX			;;
					;;
CTMAX	LABEL	word			;; number of cart slots supported
	DW	0			;;  did = 1
	DW	0			;;  did = 2
	DW	0			;;  did = 3
	DW	0			;;  did = 4
;upto max  DID_MAX			;;
					;;
RMMAX	LABEL	word			;; number of ram-slots supported
	DW	0			;;  did = 1
	DW	0			;;  did = 2
	DW	0			;;  did = 3
	DW	0			;;  did = 4
;upto max  DID_MAX			;;
					;;
RBUMAX	LABEL	word			;; number of ram-designate slots
	DW	0			;;  did = 1
	DW	0			;;  did = 2
	DW	0			;;  did = 3
	DW	0			;;  did = 4
;upto max  DID_MAX			;;
					;;
DESCO	LABEL	word			;; offset to the description table
					;; where the device_id is defined.
	DW	-1			;;  did = 1
	DW	-1			;;  did = 2
	DW	-1			;;  did = 3
	DW	-1			;;  did = 4
;upto max  DID_MAX			;;
					;;
FSIZE	LABEL	word			;; font size of the device
	DW	 0			;;  did = 1
	DW	 0			;;  did = 2
	DW	 0			;;  did = 3
	DW	 0			;;  did = 4
;upto max  DID_MAX			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Hard/RAM slots table in the order of DEVICE parameters
;
;   number of entries in all HARD_SLn is determined by the max. {HSLOTS}, and
;   number of entries in all RAM_SLn  is determined by the max. {RSLOTS}
;
;   -- they are initialized according to the device_id defined in the DEVICE.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
HARD_SLA LABEL	word			;; index in the order of device in
	DW	OFFSET	(HARD_SL1)	;; the PARSE-talbes
	DW	OFFSET	(HARD_SL2)	;;
	DW	OFFSET	(HARD_SL3)	;;
	DW	OFFSET	(HARD_SL4)	;;
; up to DID_MAX 			;;
					;;
RAM_SLA LABEL	word			;;
	DW	OFFSET (RAM_SL1)	;;
	DW	OFFSET (RAM_SL2)	;;
	DW	OFFSET (RAM_SL3)	;;
	DW	OFFSET (RAM_SL4)	;;
; up to DID_MAX 			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	 ++++++++++++++++++++++++
;;	 ++    INIT Command    ++
;;	 ++++++++++++++++++++++++
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
INIT	PROC	NEAR			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; parse the initialization parameters in DEVICE command
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
					;;
	CMP	BUF.BFLAG,BF_PRN	;; since PRN is the FIRST device header
	JNE	NOT_PRN 		;;
					;;
					;;
	MOV	AX,OFFSET CODE_END	;; defined only once for each DEVICE
	XOR	CX,CX			;;
	MOV	CL,4			;;
	SHR	AX,CL			;;
	PUSH	CS			;;
	POP	CX			;;
	ADD	AX,CX			;;
	INC	AX			;; leave 16 bytes,room for resident_end
	MOV	RESIDENT_END,AX 	;;
					;;
	CALL	PARSER			;; call only once, for PRM
					;;
	JMP	PROCESS_TABLE		;;
					;;
NOT_PRN :				;;
	CMP	DEV_NUM,1		;;
					;;
	JNB	PROCESS_TABLE		;;
					;;
	JMP	SYNTAX_ERROR		;;
					;;
					;;
					;;
;;
;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;;
;;	 ++++++++++++++++++++++++
;;	 ++   INIT Stage 1     ++
;;	 ++++++++++++++++++++++++
;;
;;  INIT - FIRST STAGE :
;;
;;    == test and extract if the parameters on device-id is valid
;;    == determine the DID_STATUS according to the validity of the parameters
;;    == procedure(s) called -- DID_EXTRACT
;;
;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
					;;
PROCESS_TABLE : 			;;
					;;
	PUSH	CS			;;
	POP	ES			;; PSE points to Device offsets
	MOV	DI,OFFSET(table)	;; ES:[DI]
	MOV	DX,PSE.PAR_DEV_NUM	;;
	MOV	DEV_NUM,DX		;;
					;;
	CMP	DEV_NUM,0		;;
	JNZ	NO_SYNTAX_ERR		;;
					;;
	XOR	AX,AX			;;
	MOV	AH,09H			;;
	MOV	DX,OFFSET MSG_BAD_SYNTAX;;
	INT	21H			;;
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SYNTAX_ERROR :				;; set the request header status
					;; according to the STATE
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	MOV	AX, RESIDENT_END	;;
	PUSH	CS			;;
	POP	CX			;; CX=CS
	SUB	AX,Cx			;; additional segment required.
CS_LOOP1:				;;
	CMP	AX,1000H		;;
	JB	CS_LPEND1		;;
	ADD	CX,1000H		;;
	SUB	AX,1000H		;;
	JMP	CS_LOOP1		;;
					;;
CS_LPEND1:				;;
	SHL	AX,1			;;
	SHL	AX,1			;;
	SHL	AX,1			;;
	SHL	AX,1			;;
					;;
	LES	DI,dword ptr buf.rh_ptro ;; get Request Header address
;	MOV	RH.RH0_ENDO,AX		;;
	MOV	RH.RH0_ENDO,0		;;
	MOV	RH.RH0_ENDS,CX		;;
	MOV	RH.RHC_STA,stat_cmderr	;; set status in request header
					;;
	JMP	INIT_RETurn		;;
					;;
					;;
NO_SYNTAX_ERR : 			;;
					;;
	CMP	DX,DID_MAX		;;
	JNA	NEXT_DID		;;
					;;
	MOV	INIT_CHK,0001H		;; ERROR 0001
	JMP	BAD_DID 		;; more than supported no. of device
					;;
NEXT_DID:				;;
	PUSH	DI			;; pointer to PAR_OT (table 1)
	AND	DX,DX			;;
	JNZ	SCAN_DESC		;;
	JMP	END_DID 		;; DI = offset to the 1st PARSE table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SCAN_DESC:				;;
	MOV	DI,PSE.PAR_OFF		;; points to the nth device
					;;
					;; find the description for the
					;;device-id
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	MOV	CX,PRINTER_DESC_NUM	;;
	MOV	SI, OFFSET(PRINTER_DESC_TBL); offset to the description table
	PUSH	CS			;;
	POP	DS			;;
;	$SEARCH 			;;
$$DO1:
	    PUSH    CX			;; save device count
	    PUSH    SI			;; pointer to printer-descn's offset
	    MOV     SI,CS:WORD PTR[SI]	;;
	    AND     CX,CX		;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	$LEAVE	Z			;; LEAVE if no more device description
	JZ $$EN1
	    PUSH    DI			;; save offset to PAR_DEVOT
	    MOV     DI,PSE.PAR_DIDO	;;
	    MOV     CX,PSE.PAR_DIDL	;; length of parsed device name
	    LEA     DI,PSE.PAR_DID	;; pointer to parse device name
					;;
	    PUSH    SI			;;
	    LEA     SI,[SI].TYPEID	;; offset to name of device-id
	    REPE    CMPSB		;;
	    POP     SI			;;
	    POP     DI			;; get back offset to PAR_DEVOT
					;;;;;;;;;;;;;;;;;;;;;;;;
;	$EXITIF Z			;; EXIT if name matched
	JNZ $$IF1
					;;
	    CALL    DID_EXTRACT 	;; get the parameters
					;;
	    POP     SI			;; balance push-pop
	    POP     CX			;;
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	$ORELSE 			;; try next description :
	JMP SHORT $$SR1
$$IF1:
					;;
	    POP     SI			;; of printer_descn offset table
	    INC     SI			;;
	    INC     SI			;; next offset to PRINTER_DESCn
					;;
	    POP     CX			;; one description less
	    DEC     CX			;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	$ENDLOOP			;; DEVICE-ID not defined in
	JMP SHORT $$DO1
$$EN1:
					;; printer_desc;
					;;
	    MOV     AX,INIT_CHK 	;;
	    AND     AX,AX		;;
	    JNZ     UNCHANGED		;;
	    MOV     INIT_CHK,0004H	;; ERROR 0004
UNCHANGED:				;;
	    POP     SI			;; balance push-pop
	    POP     CX			;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	$ENDSRCH			;; End of scanning printer_desc
$$SR1:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	POP	DI			;;
	INC	DI			;;
	INC	DI			;; points to next device in PART_OT
	DEC	DX			;;
					;;
	JMP	NEXT_DID		;;
					;;
END_DID :				;;
	POP	DI			;;
BAD_DID :				;;
					;;
	MOV	AX,DID_STATUS		;;
	AND	AX,AX			;;
	JNZ	DEF_BUFFER		;;
					;;
	JMP	END_LPT 		;;
					;;
;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;;
;;	++++++++++++++++++++++++
;;	++   INIT Stage 2     ++
;;	++++++++++++++++++++++++
;;
;; INIT -- SECOND STAGE :
;;
;;	== match the device_name extracted in stage 1 with the name of PRN or
;;	   LPTn
;;
;;	== if the PRN/LPTn has never been defined before, then set up the BUF
;;	   for the PRN/LPTn if the DID_STATUS is good; otherwise message will
;;	   be generated indicating it cannot be initilized.
;;
;;	== if there is PRN, LPT1 is also setup, and vice vera. IF both PRN and
;;	   LPT1 are on the DEVICE command, or there are multiple entries for
;;	   the same LPTn, the consistency is checked. It they are inconsistent
;;	   the associated LPTn or PRN is forced to fail by : DID_FAIL.
;;
;;	== if the device_name on the DEVICE command is not one of the supported
;;	   PRN or LPTn, then DID_MATCH bit will not be set. An error message
;;	   will be generated for the device_name indicating it cannot be
;;	   initialized.
;;
;;	== procedure(s) called : CHK_DID   .. check DID parameters for device
;;					      whose name matched.
;;				 DEV_CHECK .. if device-name duplicated, or
;;					      there are both PRN/LPT1 : check
;;					      for consistent parameters.
;;
;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DEF_BUFFER :				;;
	PUSH	CS			;;
	POP	ES			;; PSE points to Device offsets
	MOV	DI,OFFSET(table)	;; ES:[DI]
	xor	cx,cx			;; device order in parse table
;SEARCH 				;;
$$DO7:
	    PUSH    DI			;; pointer to PAR_OT
	    PUSH    CX			;; save device count
	    MOV     DI,PSE.PAR_OFF	;;   "     "  PAR_DEVOT
	    cmp     cx,dev_num		;;
					;;
;LEAVE NB				;; LEAVE if no more device entry
	   jb	    MORE_DEVICE 	;;
	   JMP	    $$EN7
MORE_DEVICE :				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; more parsed_device to be checked
	    PUSH    DI			;; save offset to PAR_DEVOT
	    MOV     DI,PSE.PAR_DNMO	;;
	    MOV     CX,PSE.PAR_DNML	;; length of parsed device name
	    LEA     DI,PSE.PAR_DNM	;; pointer to parse device name
					;;
	    LDS     SI,DWORD PTR BUF.DEV_HDRO ; get the offset to device-n header
	    LEA     SI,HP.DH_NAME	;; "       offset to name of device-n
	    REPE    CMPSB		;;
	    POP     DI			;; get back offset to PAR_DEVOT
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;
;EXITIF Z				;; EXIT if name matched
	JZ  NAME_MATCHED		;;
					;;
	JMP MORE_PARSED_DEVICE		;;
					;;
NAME_MATCHED :				;;
					;;
	    POP     CX			;; the DID order
	    PUSH    BX			;;
	    MOV     BX,CX		;;
	    ADD     BX,BX		;;
	    MOV     AX,DID_BIT[BX]	;;
	    OR	    DID_MATCH,AX	;; this DID matched
	    POP     BX			;;
	    PUSH    CX			;;
					;;
	    LEA     SI,BUF.PAR_EXTRACTO ;; was the LPT1/PRN defined before ?
	    MOV     AX,CS:[SI].PAR_DNMO ;;
	    CMP     AX,0FFFFH		;;
					;;
	    JNE     DEV_COMPARE 	;; DI = PAR_DEVOT
					;;-----------------------------------
					;;
					;; no device previousely defined
	    MOV     AX,PSE.PAR_DNMO	;;
	    MOV     CS:[SI].PAR_DNMO,AX ;; define device parameters for LPTn
					;;
	    MOV     AX,PSE.PAR_DIDO	;;
	    MOV     CS:[SI].PAR_DIDO,AX ;;
					;;
	    MOV     AX,PSE.PAR_HWCPO	;;
	    MOV     CS:[SI].PAR_HWCPO,AX ;;
					;;
	    MOV     AX,PSE.PAR_DESGO	;;
	    MOV     CS:[SI].PAR_DESGO,AX ;;
					;;
	    MOV     AX,PSE.PAR_PARMO	;;
	    MOV     CS:[SI].PAR_PARMO,AX ;;
					;;
					;;---------------------------------
	    CALL    CHK_DID		;; define the STATE according to
					;; DID_STATUS
	    JMP     MORE_PARSED_DEVICE	;;
					;;
DEV_COMPARE :				;;-------------------------------
					;; e.g. LPT1 and PRN shares one BUF.
					;;	or duplicated device name
	    CALL    DEV_CHECK		;;
					;;
	    CMP     BUF.STATE,CPSW	;;
	    JNE     DEV_COMPARE_FAIL	;;
					;;
	    JMP     MORE_PARSED_DEVICE	;;
					;;
DEV_COMPARE_FAIL :			;;
					;;
	    POP     CX			;;
	    POP     DI			;; balance push-pop
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;$ORELSE				;;
	JMP	  END_LPT
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
MORE_PARSED_DEVICE :			;; name does not match
					;;
	    POP     CX			;;
	    INC     CX			;;
	    POP     DI			;;
	    INC     DI			;;
	    INC     DI			;; points to next device in PART_OT
					;;
	    jmp     $$DO7		;;
;$ENDLOOP				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
$$EN7:					;; no device found for LPTn
					;;
	    POP     CX			;;
	    POP     DI			;; balance push-pop
					;;
	    CMP     BUF.STATE,CPSW	;;
	    JE	    END_LPT		;; for LPT1/PRN pair
					;;
	    MOV     BUF.STATE,NORMAL	;; no device defined for the LPTn
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; End of defining LPTn Buffer
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;$ENDSRCH				;;
END_LPT :				;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; set the request header status
					;; according to the STATE
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	MOV	AX, RESIDENT_END	;;
	PUSH	CS			;;
	POP	CX			;; CX=CS
	SUB	AX,Cx			;; additional segment required.
CS_LOOP2:				;;
	CMP	AX,1000H		;;
	JB	CS_LPEND2		;;
	ADD	CX,1000H		;;
	SUB	AX,1000H		;;
	JMP	CS_LOOP2		;;
					;;
CS_LPEND2:				;;
	SHL	AX,1			;;
	SHL	AX,1			;;
	SHL	AX,1			;;
	SHL	AX,1			;;
					;;
	LES	DI,dword ptr buf.rh_ptro ;; get Request Header address
	MOV	RH.RH0_ENDO,AX		;;
	MOV	RH.RH0_ENDS,CX		;;
	XOR	AX,AX			;; clear error code to be returned
	MOV	CX,BUF.STATE		;;
	CMP	CX,CPSW 		;;
	JE	MATCH_GOOD		;;
	MOV	AX,STAT_CMDERR		;;
					;;
MATCH_GOOD :				;;
	MOV	RH.RHC_STA,AX		;; set status in request header
					;;
BUF_END :				;;
					;;
	CMP	BUF.BFLAG,BF_LPT1	;;
	JNE	BUF_MESSAGES		;;
					;;
	CMP	BUF.STATE,CPSW		;;
	JNE	BUF_MESSAGES		;;
					;; set PRN to the same setting as LPT1
	PUSH	BX			;;
					;;
	LEA	SI,BUF.RNORMO		;;
	LEA	CX,BUF.BUFEND		;;
	SUB	CX,SI			;;
	MOV	BX,BUF.PRN_BUFO 	;; where PRN buffer is
	LEA	DI,BUF.RNORMO		;;
	PUSH	CS			;;
	POP	ES			;;
	PUSH	CS			;;
	POP	DS			;;
	REP	MOVSB			;;
					;;
	POP	BX			;;
					;;
BUF_MESSAGES :				;;
	CMP	BUF.BFLAG,BF_LPT3	;; generate error message is this is
	je	last_round		;; the last LPTn
	Jmp	INIT_RETURN		;;
					;; ERROR messages will be generated
					;; at the end of initialization of all
					;; the LPT devices
last_round :				;;
	MOV	AX,RESIDENT_END 	;;
	ADD	AX,STACK_SIZE		;;
	MOV	RESIDENT_END,AX 	;;
	PUSH	CS			;;
	POP	CX			;; CX=CS
	SUB	AX,Cx			;; additional segment required.
CS_LOOP3:				;;
	CMP	AX,1000H		;;
	JB	CS_LPEND3		;;
	ADD	CX,1000H		;;
	SUB	AX,1000H		;;
	JMP	CS_LOOP3		;;
					;;
CS_LPENd3:				;;
	SHL	AX,1			;;
	SHL	AX,1			;;
	SHL	AX,1			;;
	SHL	AX,1			;;
					;;
	MOV	RH.RH0_ENDO,AX		;; STACK !!!!!
	MOV	STACK_ALLOCATED,0	;; from now on, internal stack is used
					;;
	MOV	AX,DID_STATUS		;; what is the DID combination ?
	AND	AX,DID_MATCH		;;
	XOR	AX,DID_FAIL		;;
					;;
	AND	AX,AX			;;
	JNZ	CODE_STAYED		;;
;	MOV	RH.RH0_ENDO,0		;; none of the devices are good
					;;
					;;
CODE_STAYED :				;;
	MOV	DI,OFFSET TABLE 	;;
	push	CS			;;
	POP	ES			;;
					;;
	XOR	CX,CX			;;
MSG_LOOP :				;;
	CMP	CX,DEV_NUM		;;
	JNB	INIT_RETURN		;;
	SHR	AX,1			;;
	JC	MSG_NEXT		;;
					;; this device in parse table is bad
	PUSH	DI			;;
	PUSH	CX			;;
	PUSH	AX			;;
					;;
	MOV	DI,PSE.PAR_OFF		;;
	MOV	SI,PSE.PAR_DNMO 	;;
					;;
	PUSH	CS			;;
	POP	ES			;;
	PUSH	CS			;;
	POP	DS			;;
					;;
	MOV	CX,8			;;
	LEA	SI,[SI].PAR_DNM 	;;
					;;
	MOV	DI,SI			;;
	ADD	DI,7			;; skip backward the blanks
	MOV	AL,20H			;;
	STD				;;
	REPE	SCASB			;;
	CLD				;;
					;;
	MOV	DI, OFFSET MSG_NO_INIT_P;;
	MOV	DX,DI			;; for INT 21H
	XOR	AX,AX			;;
	MOV	AH,09H			;;
	INT	21H			;;
					;;
					;;
	MOV	DI, OFFSET MSG_NO_INIT	;;
	MOV	DX,DI			;; for INT 21H
					;;
	INC	CX			;;
					;;
	PUSH	CX			;; remaining name that is non blank
	MOV	AX,CX			;;
	MOV	CX,8			;;
	SUB	CX,AX			;;
	ADD	DI,CX			;;
	MOV	DX,DI			;;
	POP	CX			;;
	REP	MOVSB			;;
					;;
					;;
	XOR	AX,AX			;;
	MOV	AH,09H			;;
	INT	21H			;;
					;;
	POP	AX			;;
	POP	CX			;;
	POP	DI			;;
					;;
MSG_NEXT :				;;
	INC	CX			;;
	INC	DI			;;
	INC	DI			;;
	JMP	MSG_LOOP		;;
					;;
					;;
INIT_RETURN :				;;
					;;
					;;
	RET				;;
					;;
INIT	ENDP				;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Call by INIT to extract parameters for the deivce_id
;;
;; on rntry :
;;	ES:[DI]  PARSE Table 2, offsets of all parameters
;;	DS:[SI]  Printer Description table whose TYPEID matched
;;	DX	 "inverse" order of devices in the PARSE tables
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;;
DID_EXTRACT PROC			;;
					;;
	PUSH	DX			;;
					;;-----------------------------
					;; define the DID_parameters
	PUSH	BX			;;
					;;
	MOV	BX,DEV_NUM		;;
	SUB	BX,DX			;; order in the Parse table
	add	bx,bx			;; double to index [bx]
	MOV	DX,BX			;;
					;;
	MOV	AX,DS:[SI].FONTSZ	;;
	MOV	FSIZE[BX],AX		;; size of font buffer to be created
					;;
	MOV	AX,DS:[SI].HSLOTS	;;
	CMP	AX,HARDSL_MAX		;;
	JNA	LESS_HARDSL		;;
	MOV	INIT_CHK, 0010H 	;; ERROR 0010H
	POP	BX			;;
	JMP	END_MATCH_BAD		;;
LESS_HARDSL :				;;
	CMP	AX,DS:[SI].HWCPMIN	;;
	JNB	VALID_HARDSL		;;
	MOV	INIT_CHK, 0012H 	;; ERROR 0012H
	POP	BX			;;
	JMP	END_MATCH_BAD		;;
VALID_HARDSL :				;;
	MOV	HRMAX[BX],AX		;;
	MOV	CTMAX[BX],AX		;; will be reduced by the no. of hwcp
					;;
	MOV	AX,DS:[SI].RSLOTS	;;
	CMP	AX,RAMSL_MAX		;;
	JNA	LESS_RAMSL		;;
	MOV	INIT_CHK, 0011H 	;; ERROR 0011H
	POP	BX			;;
	JMP	END_MATCH_BAD		;;
LESS_RAMSL :				;;
	MOV	RMMAX[BX],AX		;;	see also designate
					;;
	MOV	DESCO[BX],SI		;;
					;;
	POP	BX			;;
					;;----------------------------------
					;;
	PUSH	CX			;;
					;;
HWCPgt: PUSH	DI			;; get the hwcp
					;;
	MOV	DI,PSE.PAR_HWCPO	;;
	MOV	CX,PSE.PAR_HWCPL	;; no. of hwcp
	AND	CX,CX			;;
	JNZ	chk_hwcp		;;
	push	bx			;;
	mov	bx,dx			;;
	MOV	HRMAX[BX],CX		;;
	MOV	CX,DS:[SI].HWCPMIN	;;
	SUB	CTMAX[BX],CX		;; what is left becomes cartridge slot
	pop	bx			;;
	JMP	DESIGN			;;
					;; hwcp to be defined
chk_hwcp: MOV	AX,DS:[SI].HSLOTS	;; defined in printer_desc
	CMP	CX,AX			;;
	JA	BAD_MATCH2		;;
	CMP	CX,HARDSL_MAX		;;
	JNA	HWCP_GOOD		;; jump if system error
	MOV	INIT_CHK,0003H		;; ERROR 0003
	JMP	END_MATCH		;;
BAD_MATCH2:				;;
	MOV	INIT_CHK,0002H		;; ERROR 0002
	JMP	END_MATCH		;;
					;;
HWCP_GOOD:				;; there are sufficient hard-slot for
					;; HWCP
	PUSH	SI			;; printer description table of TYPEID
	PUSH	BX			;;
					;;
	MOV	BX,DX			;;
	MOV	AX,CTMAX[BX]		;;
					;;
	PUSH	CX			;; calculate what is left for cart_slot
	CMP	CX,DS:[SI].HWCPMIN	;;
	JNB	MORE_THAN_HWCPMIN	;;
	MOV	CX,DS:[SI].HWCPMIN	;;
MORE_THAN_HWCPMIN :			;;
	SUB	AX,CX			;;
	POP	CX			;;
	mov	HRMAX[BX],CX		;;
					;;
	MOV	CTMAX[BX],AX		;; no of cart-slot for designate
	MOV	SI,HARD_SLA[BX] 	;; get the corresponding hard-slots
					;;
	POP	BX			;;
					;;
	push	bx			;;
	push	dx			;;
	mov	bx,si			;;
	mov	dx,cx			;;
	mov	reserved1,dx		;; IF THERE IS ANY REPETITIVE HWCP
	mov	reserved2,bx		;; IF THERE IS ANY REPETITIVE HWCP
					;;
FILL_HWCP:				;;
	AND	CX,CX			;;
	JZ	DESIGN_P		;;
	INC	DI			;; next code page in PARSE table
	INC	DI			;;
	MOV	AX,ES:[DI]		;; get code page value
					;;
					;; IF THERE IS ANY REPETITIVE HWCP
	push	dx			;;
	push	bx			;;
hwcp_norep :				;;
	cmp	ax,cs:[bx].slt_cp	;;
	jne	hwcp_repnext		;;
	pop	bx			;;
	pop	dx			;;
	pop	dx			;;
	pop	bx			;;
	pop	si			;;
	jmp	end_match		;;
					;;
hwcp_repnext:				;;
	inc	bx			;;
	inc	bx			;;
	inc	bx			;;
	inc	bx			;;
	dec	dx			;;
	jnz	hwcp_norep		;;
	pop	bx			;;
	pop	dx			;;
					;;
	MOV	CS:[SI].SLT_CP,AX	;;
	MOV	AX,CS:[SI].SLT_AT	;; get the attributes
	OR	AX,AT_OCC		;; occupied
	OR	AX,AT_HWCP		;; hwcp slot
	MOV	CS:[SI].SLT_AT,AX	;;
	INC	SI			;;
	INC	SI			;; next slot
	INC	SI			;; next slot
	INC	SI			;; next slot
	DEC	CX			;;
	JMP	FILL_HWCP		;;
DESIGN_P:				;;
	pop	dx			;;
	pop	bx			;;
	POP	SI			;;
					;;---------------------
DESIGN: POP	DI			;; get the designate no.
	PUSH	DI			;;
					;;
	MOV	DI,PSE.PAR_DESGO	;;
	MOV	AX,PSE.PAR_DESGL	;;
	CMP	AX,1			;;
	JA	END_MATCH		;; there should have no font entry
	AND	AX,AX			;;
	JZ	DEF_RBUFMAX		;;
					;;
	MOV	AX,PSE.PAR_DESG 	;;
	AND	AX,AX			;;
	JZ	DEF_RBUFMAX		;;
					;;
	CMP	CS:[SI].CLASS,1 	;;
	JNE	DESIG_NOt_CLASS1	;;
					;;
	PUSH	BX			;; if there is any cartridge slot ?
	PUSH	AX			;;
	MOV	BX,DX			;;
	MOV	AX,ctmax[BX]		;;
	AND	AX,AX			;;
	POP	AX			;;
	POP	BX			;;
	JZ	END_MATCH		;; fail, as there is no physical RAM.
					;;
	CMP	AX,HARDSL_MAX		;; is the designate more than max ?
	JA	END_MATCH		;;
					;;
					;;
	JMP	DEF_RBUFMAX		;;
					;;
					;;
					;;
DESIG_NOT_CLASS1 :			;;
	PUSH	BX			;; if there is any physical RAM slot ?
	PUSH	AX			;;
	MOV	BX,DX			;;
	MOV	AX,RMMAX[BX]		;;
	AND	AX,AX			;;
	POP	AX			;;
	POP	BX			;;
	JZ	END_MATCH		;; fail, as there is no physical RAM.
					;;
					;;
	CMP	AX,RAMSL_MAX		;; is the designate more than max ?
	JA	END_MATCH		;;
					;;
DEF_RBUFMAX :				;;
	PUSH	BX			;;
	MOV	BX,DX			;;
	MOV	RBUMAX[BX],AX		;;
	POP	BX			;;
					;;
					;;
PARAM : 				;;
;PARM:	    POP     DI			;;
;	    PUSH    DI			;;
;;	    MOV     DI,PSE.PAR_PARMO	;;
					;;
					;,--------------------------
					;; GOOD device_id parameters
	shr	dx,1			;;
	MOV	AX,DID_ONE		;;
	MOV	CX,DX			;;
	AND	CX,CX			;;
	JZ	NO_SHL			;;
	SHL	AX,CL			;;
NO_SHL: OR	DID_STATUS,AX		;; is defined
					;;-------------------------
END_MATCH: POP	DI			;; end of extract
	POP	CX			;;
END_MATCH_BAD : 			;;
	POP	DX			;;
					;;
	RET				;;
					;;
DID_EXTRACT ENDP			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Called by INIT to define the STATE and BUF for the LPTn according to
;; the DID_STATUS. Create font buffer if requested through the "desi*nate"
;;
;; at entry :  CX = device order in parse table
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CHK_DID PROC				;;
					;;
	push	cx			;;
	push	di			;;
	push	dx			;;
					;;
	MOV	AX,DID_STATUS		;;
					;;
	PUSH	CX			;; order 0 to m
	POP	DI			;;
	ADD	DI,DI			;; indexing : [DI]
					;;
	INC	CX			;;
	SHR	AX,CL			;; is the device parameter valid ?
					;;
	JC	DEFINE_BUFFER		;;
	JMP	LPT_FAIL		;;--------------------------
					;;
DEFINE_BUFFER : 			;;
					;; good device parameters as determined
	MOV	AX,DESCO[DI]		;;
	MOV	BUF.PDESCO,AX		;;
					;;
	PUSH	DI			;;
	MOV	DI,AX			;;
	MOV	AX,CS:[DI].CLASS	;;
	MOV	BUF.PCLASS,AX		;;
	POP	DI			;;
					;;
	MOV	AX,HARD_SLA[DI] 	;;  in the DID_EXTRACT
	MOV	BUF.HARDSO,AX		;;
					;;
	MOV	AX,RAM_SLA[DI]		;;
	MOV	BUF.RAMSO,AX		;;
					;;
	MOV	AX,HRMAX[DI]		;;
	MOV	BUF.HARDMX,AX		;;
					;;
	MOV	AX,CTMAX[DI]		;;
	MOV	BUF.HCARMX,AX		;;
					;;
	ADD	AX,HRMAX[DI]		;; defore "designate"
	MOV	BUF.HSLMX,AX		;;
					;;
					;;
	MOV	AX,RMMAX[DI]		;;
	MOV	BUF.RAMMX,AX		;;
					;;
	XOR	AX,AX			;;
	PUSH	CX			;; calculate the max. length of control
	MOV	CX,2			;; sequence that is allowed for the
	CMP	BUF.PCLASS,1		;; room reserved for physical slots.
	JNE	CTL_LOOP		;;
	MOV	CX,1			;; class 1 printer has one control seq.
CTL_LOOP :				;;
	ADD	AX,CTL_MAX		;;
	DEC	AX			;; leave one byte for the length
	DEC	CX			;;
	JNZ	CTL_LOOP		;;
	MOV	BUF.FSELMAX,AX		;;
	POP	CX			;;
					;;
	MOV	AX,FSIZE[DI]		;;
	MOV	BUF.FTSZPA,AX		;; FTSIZE in paragraph
					;;
	PUSH	AX			;;
					;;
	MOV	DX,4			;;
FT_PARA:				;;
	ADD	AX,AX			;;
	DEC	DX			;;
	JNZ	FT_PARA 		;; font size
	MOV	BUF.FTSIZE,AX		;; font size in bytes (used with.RBUFMX)
					;;
	POP	DX			;; FTSIZE in paragraph
					;;
	MOV	CX,RBUMAX[DI]		;; create font buffer per .RBUFMX and
	MOV	BUF.RBUFMX,CX		;; assume sufficient memory for all the
					;; "designate request"
	PUSH	CX			;;
					;;
	CMP	BUF.PCLASS,1		;; always create font buffer for class1
	JNE	CLASS_NOT_1		;;
					;;
	AND	CX,CX			;;
	JZ	CLASS1_NOCX		;;
	ADD	CX,BUF.HARDMX		;;
	MOV	BUF.HSLMX,CX		;;
	JMP	CLASS_NOT_1		;;
					;;
CLASS1_NOCX:				;;
	MOV	CX,BUF.HSLMX		;;
					;;
CLASS_NOT_1 :				;;
	AND	CX,CX			;;
	JZ	MULTIPLE_DONE		;;
	MOV	AX,RESIDENT_END 	;;
MULTIPLE_FT :				;;
	ADD	AX,DX			;; allocate the font buffers at the end
	DEC	CX			;; of the resident codes
	JNZ	MULTIPLE_FT		;;
					;;
					;;
	MOV	CX,RESIDENT_END 	;;
	MOV	BUF.FTSTART,CX		;;
	MOV	RESIDENT_END,AX 	;;
					;;
					;;
MULTIPLE_DONE : 			;;
	POP	CX			;; designate requested
					;;
	CMP	BUF.PCLASS,1		;;
	JNE	DEF_RBUF		;;
					;; CLASS 1
	CMP	BUF.HARDMX,0		;;
	JE	DEFBUF_DONE		;;
					;;
	PUSH	CX			;; STACKS...
	PUSH	SI			;;
	PUSH	DS			;;
	PUSH	ES			;;
	PUSH	DI			;;
	PUSH	DX			;;
					;;
	MOV	DX,BUF.HARDMX		;;
	PUSH	DX			;; STACK +1 -- # of HWCP
					;;
	PUSH	CS			;;
	POP	DS			;;
	MOV	BUF.RBUFMX,0		;;
	MOV	SI,BUF.PDESCO		;;
	MOV	SI,CS:[SI].SELH_O	;;
	XOR	CX,CX			;;
	MOV	CL,CS:BYTE PTR [SI]	;;
	INC	CX			;; including the length byte
					;;
	MOV	DI,BUF.FTSTART		;; control template
DEF_FTBUF:				;; fill the  font buffer with the
	PUSH	DI			;;
	POP	ES			;;
	XOR	DI,DI			;;
					;;
	PUSH	CX			;;
	PUSH	SI			;;
	REP	MOVSB			;;
	POP	SI			;;
	POP	CX			;;
					;;
	PUSH	ES			;;
	POP	DI			;;
	ADD	DI,BUF.FTszpa		;;
	DEC	DX			;;
	JNZ	DEF_FTBUF		;;
					;;
	POP	DX			;; STACK -1
					;;
	MOV	SI,BUF.HARDSO		;;
	MOV	DI,BUF.FTSTART		;; define the HWCP values
DEF_FThwcp :				;;
	PUSH	DI			;;
	POP	ES			;;
	MOV	DI,CTL5202_OFFS 	;; offset to the HWCP words
					;;
	MOV	AX,CS:[SI].SLT_CP	;;
	MOV	ES:WORD PTR [DI],AX	;;
					;;
	INC	SI			;;
	INC	SI			;;
	INC	SI			;;
	INC	SI			;;
					;;
	PUSH	ES			;;
	POP	DI			;;
	ADD	DI,BUF.FTSZPA		;;
	DEC	DX			;;
	JNZ	DEF_FThwcp		;;
					;;
	POP	DX			;;
	POP	DI			;;
	POP	ES			;;
	POP	DS			;;
	POP	SI			;;
	POP	CX			;;
					;;
	JMP	DEFBUF_DONE		;;
					;;
					;;
DEF_RBUF :				;;
	MOV	BUF.RSLMX,CX		;; the no. of ram slots supported
	CMP	CX,RMMAX[DI]		;;
	JNB	DEFBUF_DONE		;;
	MOV	AX,RMMAX[DI]		;;
	MOV	BUF.RSLMX,AX		;; the max. of .RAMMX and .RBUFMX
					;;
DEFBUF_DONE :				;;
	MOV	BUF.STATE,CPSW		;; the LPTn is CPSW ----- STATE
					;;
	CMP	BUF.BFLAG,BF_PRN	;;
	JNE	RET_CHK_DID		;;
	MOV	AX,DID_BIT[DI]		;;
	MOV	BUF.DID_PRN,AX		;;
					;;
					;;
	JMP	RET_CHK_DID		;;
					;;
LPT_FAIL:				;;
					;;
	MOV	BUF.STATE,NORMAL	;; the LPTn is NORMAL --- STATE
					;;
					;;
RET_CHK_DID:				;;
					;;
	pop	dx			;;
	pop	di			;;
	pop	cx			;;
					;;
	RET				;;
					;;
CHK_DID ENDP				;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Called by INIT to check for consistency between duplicated device name and
;;	between PRN and LPT1
;;
;; at entry :  DI = pointer to PAR_DEVOT
;;	       BUF.STATE = any state
;;	       CX = DID order
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
DEV_CHECK PROC				;;
					;;
	LEA	SI,BUF.PAR_EXTRACTO	;;
					;;
	PUSH	CX			;;
					;;
	PUSH	SI			;; compare device id
	PUSH	DI			;;
	mov	SI,[SI].PAR_DIDO	;;
	MOV	DI,PSE.PAR_DIDO 	;;
	MOV	CX,PSE.PAR_DNML 	;;
	INC	CX			;; including length
	INC	CX			;;
	REPE	CMPSB			;;
	POP	DI			;;
	POP	SI			;;
	Jz	hwcp_check		;;
	mov	init_chk,0021h		;; error 0021h
	Jmp	FORCE_LPT_BAD		;;
					;;
hwcp_check :				;;
	PUSH	SI			;; compare HWCP
	PUSH	DI			;;
	mov	SI,[SI].PAR_HWCPO	;;
	MOV	DI,PSE.PAR_HWCPO	;;
	MOV	AX,PSE.PAR_HWCPL	;;
	MOV	CX,2			;;
	SHL	AX,CL			;; multiply by two
	INC	AX			;; including length
	INC	AX			;;
	MOV	CX,AX			;;
	REPE	CMPSB			;;
	POP	DI			;;
	POP	SI			;;
	Jz	desig_check		;;
	mov	init_chk,0022h		;; error 0022h
	Jmp	FORCE_LPT_BAD		;;
					;;
desig_check :				;;
	PUSH	SI			;; compare DESIGNATE
	PUSH	DI			;;
	mov	SI,[SI].PAR_DESGO	;;
	MOV	DI,PSE.PAR_DESGO	;;
	MOV	AX,PSE.PAR_DESGL	;;
	MOV	CX,2			;;
	SHL	AX,CL			;; multiply by two
	INC	AX			;; including length
	INC	AX			;;
	MOV	CX,AX			;;
	REPE	CMPSB			;;
	POP	DI			;;
	POP	SI			;;
	Jz	param_check		;;
	mov	init_chk,0023h		;; error 0023h
	Jmp	FORCE_LPT_BAD		;;
					;;
param_check :				;;
	PUSH	SI			;; compare parameters
	PUSH	DI			;;
	mov	SI,[SI].PAR_PARMO	;;
	MOV	DI,PSE.PAR_PARMO	;;
	MOV	CX,PSE.PAR_PARML	;;
	INC	CX			;; including length
	INC	CX			;;
	REPE	CMPSB			;;
	POP	DI			;;
	POP	SI			;;
	JZ	M_END			;;
	mov	init_chk,0024h		;; error 0024h
					;;
FORCE_LPT_BAD : 			;; the second set of parameters is
	MOV	BUF.STATE,NORMAL	;; bad
					;;
	CMP	BUF.BFLAG,BF_LPT1	;;
	JNE	M_END			;;
					;;
					;; since LPT1 is bad, force PRN to bad
	push	bx			;; force prn to be bad too
	mov	bx,buf.prn_bufo 	;;
	MOV	BUF.STATE,NORMAL	;;
	pop	bx			;;
					;;
	mov	AX,BUF.DID_PRN		;; if PRN was not good, DID_PRN = 0
	OR	DID_FAIL,AX		;;
					;;
					;;
M_END:					;; force the good did_status to fail if
					;; STATE is bad
	POP	CX			;;
	PUSH	CX			;; order 0 to m
	MOV	AX,DID_STATUS		;;
					;;
	INC	CX			;;
	SHR	AX,CL			;;
	POP	CX			;;
	JNC	DEV_CHECK_RET		;; already failed
					;;
	CMP	BUF.STATE,CPSW		;;
	JE	DEV_CHECK_RET		;;
					;;
	    PUSH    BX			;;
	    MOV     BX,CX		;;
	    ADD     BX,BX		;;
	    MOV     AX,DID_BIT[BX]	;;
	    OR	    DID_FAIL,AX 	;; force DID to fail
	    POP     BX			;;
					;;
					;;
DEV_CHECK_RET : 			;;
					;;
	RET				;;
					;;
					;;
DEV_CHECK ENDP				;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
CSEG	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\printer\cpsfont3.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

	PAGE	,132

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  FILENAME:	  CPS Device Driver -- Font Parser
;;  MODULE NAME:  CPSFONT
;;  TYPE:	  Font Parser Module
;;  LINK PROCEDURE:  Link CPS+CPSSUB+CPSINT9+...+CPSINIT into .EXE format
;;		     CPS must be first.  CPSINIT must be last.	Everything
;;		     before CPSINIT will be resident.
;;  INCLUDE FILES:
;;			CPSPEQU.INC
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
INCLUDE CPSPEQU.INC			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
CSEG	SEGMENT PUBLIC 'CODE'           ;;
	ASSUME	CS:CSEG 		;;
	ASSUME	DS:NOTHING		;;
					;;
PUBLIC	FTABLE,FONT_PARSER		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  ************************************
;;  **				      **
;;  **	     Resident Code	      **
;;  **				      **
;;  ************************************
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	FONT_PARSER data
;;
;;	-- Interface table : FTABLE
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FTABLE: FBUFS	<0FFFFH,,,>		;; for temporary testing
FTB1	FTBLK	<,,,,,,,,,,,,>		;; -- at most 12 entries
FTB2	FTBLK	<,,,,,,,,,,,,>		;;
FTB3	FTBLK	<,,,,,,,,,,,,>		;;
FTB4	FTBLK	<,,,,,,,,,,,,>		;;
FTB5	FTBLK	<,,,,,,,,,,,,>		;;
FTB6	FTBLK	<,,,,,,,,,,,,>		;;
;FTB7    FTBLK   <,,,,,,,,,,,,>          ;;
;FTB8    FTBLK   <,,,,,,,,,,,,>          ;;
;FTB9    FTBLK   <,,,,,,,,,,,,>          ;;
;FTBa    FTBLK   <,,,,,,,,,,,,>          ;;
;FTBb    FTBLK   <,,,,,,,,,,,,>          ;;
;FTBc    FTBLK   <,,,,,,,,,,,,>          ;;
					;;
FP_ERROR	DW   0000H		;; internal error register
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; the followings are bytes accumulated
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FTAG_LEN	EQU	8		;; FILE TAGE in the font file header
FTAG_COUNT	DW	0000H		;;
					;;
FTAG_PATTERN	LABEL	BYTE		;;
	DB	0FFH			;;
	DB	'FONT   '               ;;
					;;
					;;
					;; POINTER in the font file header
fptr_LOW LABEL	WORD			;;
fptr_LOL DB	00H			;; NEXT
fptr_LOH DB	00H			;;
fptr_HIGH LABEL WORD			;;
fptr_HIL DB	00H			;;
fptr_HIH DB	00H			;;
					;;
					;;
					;;
ENTRY_WORD LABEL WORD			;;
ENTRY_LOB DB	00H			;; ENTRY COUNT
ENTRY_HIB DB	00H			;;
NEXT_LOW LABEL	WORD			;;
NEXT_LOL DB	00H			;; NEXT
NEXT_LOH DB	00H			;;
NEXT_HIGH LABEL WORD			;;
NEXT_HIL DB	00H			;;
NEXT_HIH DB	00H			;;
TYPE_WORD LABEL WORD			;;
TYPE_LOB DB	00H			;; TYPE
TYPE_HIB DB	00H			;;
TID_CNT DW	00000H			;; TYPEID COUNT(0 to 8)
TYPE_ID :	DB '        '           ;; TYPEID
CPG_WORD LABEL	WORD			;;
CPG_LOB DB	00H			;; CODE PAGE
CPG_HIB DB	00H			;;
FONT_LOW LABEL	WORD			;;
FONT_LOL DB	00H			;; FONT ADDRESS
FONT_LOH DB	00H			;;
FONT_HIGH LABEL WORD			;;
FONT_HIL DB	00H			;;
FONT_HIH DB	00H			;;
;; the followings are contained in the font-block in the exact order & length
MOD_WORD LABEL	WORD			;;
MOD_LOB DB	00H			;; MODIFIER
MOD_HIB DB	00H			;;
FONTS_WORD LABEL WORD			;;
FONTS_LOB DB	00H			;; FONTS
FONTS_HIB DB	00H			;;
FDLEN_WORD LABEL WORD			;;
FDLEN_LOB DB	00H			;; FONT DATA LENGTH
FDLEN_HIB DB	00H			;;
PRE_FONT_ND	EQU ($-MOD_WORD)	;; used to update target for font data
					;; to follow. -- for NON-DISPLAY
DISP_ROWS DB	00H			;; DISPLAY's parameters :
DISP_COLS DB	00H			;; BOX SIZE
DISP_X	  DB	00H			;; ASPECT RATIO
DISP_Y	  DB	00H			;;
COUNT_WORD    LABEL WORD		;; NO. OF DISPLAY CHARACTERS
COUNT_LOB DB	00H			;;
COUNT_HIB DB	00H			;;
PRE_FONT_D	EQU ($-MOD_WORD)	;; used to update target for font data
					;; to follow. -- for DISPLAY
					;;
PTR_SEL_WORD	LABEL WORD		;;
PTR_SELOB DB	00H			;;
PTR_SEHIB DB	00H			;;
PRE_FONT_P0	EQU ($-PTR_SELOB+PRE_FONT_ND) ;; to update target for font data
					;; to follow -- for PRINTER with
					;; selection type = 0.
					;;
PTR_LEN_WORD	LABEL WORD		;;
PTR_LNLOB DB	00H			;;
PTR_LNHIB DB	00H			;;
PRE_FONT_P	EQU ($-PTR_SELOB+PRE_FONT_ND) ;; to update target for font data
					;; to follow -- for PRINTER with
					;; selection type <> 0.
					;;
					;;
;; also update STAGE_CASES and indexing constants
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; the stage the parsing is in :  ;;;;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
STAGE_CASES LABEL WORD			;; the stage the parsing is in :
					;;
					;; *** INDEXED BY  STAGE-INDEX
					;;
	DW	OFFSET ENTRYLO		;; 0
	DW	OFFSET ENTRYHI		;; 1
	DW	OFFSET NEXTLOL		;; 2
	DW	OFFSET NEXTLOH		;; 3
	DW	OFFSET NEXTHIL		;; 4
	DW	OFFSET NEXTHIH		;; 5
	DW	OFFSET TYPELO		;; 6
	DW	OFFSET TYPEHI		;; 7
	DW	OFFSET TYPEIDS		;; 8
	DW	OFFSET CPGLO		;; 9
	DW	OFFSET CPGHI		;; A
	DW	OFFSET FONTLOL		;; B
	DW	OFFSET FONTLOH		;; C
	DW	OFFSET FONTHIL		;; D
	DW	OFFSET FONTHIH		;; E
	DW	00H			;; MATCH case -- end of SEARCH stages
	DW	00H			;; SCAN  case -- before PRE-FOUND stage
	DW	OFFSET MODLO		;; 11
	DW	OFFSET MODHI		;; 12
	DW	OFFSET FONTSLO		;; 13
	DW	OFFSET FONTSHI		;; 14
	DW	OFFSET FDLENLO		;; 15
	DW	OFFSET FDLENHI		;; 16 -- lead to FONT case,NON- DISPLAY
	DW	OFFSET DSPROWS		;; 17 -- DISPLAY only
	DW	OFFSET DSPCOLS		;; 18
	DW	OFFSET DSPX		;; 19
	DW	OFFSET DSPY		;; 1A
	DW	OFFSET DSPCOUNTLO	;; 1B
	DW	OFFSET DSPCOUNTHI	;; 1C -- lead to FONT case, DISPLAY
	DW	OFFSET PTRSELLO        ;;  1D -- PRINTER only
	DW	OFFSET PTRSELHI        ;;  1E
	DW	OFFSET PTRLENLO        ;;  1F
	DW	OFFSET PTRLENHI        ;;  20 -- lead to FONT case, PRINTER
	DW	00H			;; FOUND    case
	DW	00H			;; GET_FONT case
	DW	00H			;; PASS special stage
	DW	OFFSET FILETAG		;; 24
	DW	OFFSET fptrLOL		;; 25
	DW	OFFSET fptrLOH		;; 26
	DW	OFFSET fptrHIL		;; 27
	DW	OFFSET fptrHIH		;; 28
	DW	00H			;; FPTR_SKIP_CASE
					;;
					;; The followings are individual stage
STAGE_MAX EQU	($-STAGE_CASES)/2	;;  number of stages
					;;
					;; STAGE-INDEX
					;;
					;; **** INDEX TO STAGE_CASES  ****
ENTRY_LOX EQU	00H			;;
ENTRY_HIX EQU	01H			;;
NEXT_LOLX EQU	02H			;; NEXT
NEXT_LOHX EQU	03H			;;
NEXT_HILX EQU	04H			;;
NEXT_HIHX EQU	05H			;;
TYPE_LOBX EQU	06H			;; TYPE
TYPE_HIBX EQU	07H			;;
TYPE_IDX EQU	08H			;; TYPEID
CPG_LOBX EQU	09H			;; CODE PAGE
CPG_HIBX EQU	0AH			;;
FONT_LOLX EQU	0BH			;; FONT ADDRESS
FONT_LOHX EQU	0CH			;;
FONT_HILX EQU	0DH			;;
FONT_HIHX EQU	0EH			;;
					;; ------------------------------
MATCHX	EQU	0FH			;; MATCH is the end of SEARCH's stages
SCANX	EQU	10H			;; SCANX is before the PRE-FOUND stages
					;; ------------------------------
MOD_LOBX EQU	11H			;; MODIFIER
MOD_HIBX EQU	12H			;;
FONTS_LOBX EQU	13H			;; FONTS
FONTS_HIBX EQU	14H			;;
FDLEN_LOBX EQU	15H			;; FONT DATA LENGTH
FDLEN_HIBX EQU	16H			;;
DISP_ROWSX EQU	17H			;; DISPLAY -- CHAR. SIZE
DISP_COLSX EQU	18H			;;
DISP_XX    EQU	19H			;; DISPLAY -- ASPECT RATIO
DISP_YX    EQU	1AH			;;
COUNT_LOBX EQU	1BH			;; DISPLAY -- COUNT
COUNT_HIBX EQU	1CH			;;
PTRSELLOX  EQU	1DH			;;
PTRSELHIX  EQU	1EH			;;
PTRLENLOX  EQU	1FH			;;
PTRLENHIX  EQU	20H			;;
					;;
					;; ------------------------------
FOUNDX	EQU	21H			;; GET_FX is the end of PRE-FOUND stage
GET_FX	EQU	22H			;;
					;; ------------------------------
PASSX	EQU	23H			;; see pass_brk table
					;; ------------------------------
FTAGX	EQU	24H			;; RESTART ==> FILE TAG
					;;
fptr_LOLX EQU	25H			;; POINTER in font file header
fptr_LOHX EQU	26H			;;
fptr_HILX EQU	27H			;;
fptr_HIHX EQU	28H			;; ---------------------------------
					;;
fptr_SKIPX EQU	29H			;; ==> ENTRY_LOX
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; PASS -- to skip some bytes ;;;;;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; the PASS mechanism is used to skip
					;; a number of bytes between two fields
					;; The numbers are tabulated in
					;; PASS_BRK table in the accumulative
					;; sum. The PASS_POSTX(and PASS_POSTXX)
					;; are used to tell what is the stage
					;; after all the bytes have skipped.
					;;
PASS_POSTX  DW	 STAGE_MAX		;; the stage after pass-stage
					;;
FILE_OFFSET    EQU     0BH	       ;; spaces to be skipped in font file :
					;; ( after TAG, before POINTER)
					;;
PASS_CNT DW	0			;;
PASS_BRK LABEL	WORD			;;
	DW	FILE_OFFSET		;; skip in the font file header
	DW	FILE_OFFSET+2		;; pass header-length, needs to reset
					;; PASS_CNT for each of the font_header
	DW	FILE_OFFSET+8		;; pass header-reserved bytes
PASS_INDX EQU	($-PASS_BRK)/2		;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; the control variables :  ;;;;;;;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
STAGE	DW	STAGE_MAX		;; of the STAGE-INDEX
					;;
Pre_font_len	DW	00000H		;; no. of bytes before the FONT DATA
					;;
					;;
COUNT_LO DW	00000H			;; no. of bytes parsed so far
COUNT_hI DW	00000H			;;
					;;
HIT_LO	DW	00000H			;; the next byte that is addressed by :
HIT_HI	DW	00000H			;; either NEXT or TARGET in FTBLK.
					;;
HIT_FLAG DW	00000H			;; IF ZERO, the NEXT is approaching
HIT_BX	DW	00000H			;; where FTB is found for nearest hit
					;;
NUM_FTB DW	00000H			;; as defined in the FP_BUFFER
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	FONT_PARSER routine
;;
;;	-- to be called at every packet received to extract informations
;;	   from Font File on byte basis.
;;
;;	-- Interface though FTABLE
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
FONT_PARSER PROC			;;
	PUSH	DS			;; save all registers Revised
	PUSH	ES			;;
	PUSH	AX			;;
	PUSH	BX			;;
	PUSH	CX			;;
	PUSH	DX			;;
	PUSH	DI			;;
	PUSH	SI			;;
					;; BP isn't used, so it isn't saved
	LEA	BX,FTABLE		;;
	PUSH	CS			;;
	POP	ES			;; ES:[BX]
	LDS	SI,FTP.BUFFER_ADDR	;; DS:[SI]
	MOV	CX,FTP.BUFFER_LEN	;; CX = length of packet
	MOV	DX,FTP.NUM_FTBLK	;; DX = number of FTB
	MOV	cs:num_ftb,DX		   ;;
	AND	DX,DX			;;
	JNZ	VALID_BUFFER		;;
	MOV	cs:fp_error,0020H	   ;; ERROR 0020H
	JMP	FP_RET			;;
VALID_BUFFER :				;;
	MOV	AX,FTP.FLAG		;;
	AND	AX,FLAG_RESTART 	;;
	Jnz	has_RESTART		;;
	JMP	NO_RESTART		;;
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
has_restart :				;;
	PUSH	BX			;; reset all the output fields
	ADD	BX,TYPE FBUFS		;; FTP = FONT BLOCK
	XOR	AX,AX			;;
					;;
	MOV	cs:ftag_count,AX	   ;;
	MOV	cs:fptr_low,AX		   ;;
	MOV	cs:fptr_high,AX 	   ;;
	MOV	cs:pre_font_len,AX	  ;;
	MOV	cs:count_lo,AX		   ;;
	MOV	cs:count_hi,AX		   ;;
	MOV	cs:next_low,AX		   ;;
	MOV	cs:next_high,AX 	   ;;
	MOV	cs:hit_lo,AX		   ;;
	MOV	cs:hit_hi,AX		   ;;
	MOV	cs:hit_flag,AX		   ;;
	MOV	cs:pass_cnt,AX		   ;;
	MOV	cs:pass_postx,STAGE_MAX    ;;
					;;
	MOV	cs:stage,STAGE_MAX	   ;;
					;;
RESET_FTB :				;;
	MOV	FTP.FTB_STATUS,FSTAT_SEARCH
	MOV	FTP.FTB_TYPE,AX 	;;
	MOV	FTP.FTB_MOD,AX		;;
	MOV	FTP.FTB_FONTS,AX	;;
	MOV	FTP.FTB_ROWS,AL 	;;
	MOV	FTP.FTB_COLS,AL 	;;
	MOV	FTP.FTB_X,AL		;;
	MOV	FTP.FTB_Y,AL		;;
	MOV	FTP.FTB_COUNT,AX	;;
	MOV	FTP.FTB_DLEFT,AX	;;
	MOV	FTP.FTB_DLEN,AX 	;;
	MOV	FTP.FTB_DALO,AX 	;;
	MOV	FTP.FTB_DAHI,AX 	;;
	MOV	FTP.TARGET_LO,AX	;;
	MOV	FTP.TARGET_HI,AX	;;
					;;
	ADD	BX, TYPE FTBLK		;;
					;;
	DEC	DX			;;
	AND	DX,DX			;;
	JNZ	RESET_FTB		;;
					;;
	POP	BX			;;
NO_RESTART :				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; any FTBLKs have their data all
					;; returned ? if so set their status
					;; from FOUND to COMPLETE
	PUSH	BX			;;
	ADD	BX,TYPE FBUFS		;; FTP = FONT BLOCK
					;;
	MOV	DX,cs:num_ftb		   ;;
					;;
SET_COMPLETE :				;;
	MOV	AX,FTP.FTB_STATUS	;;
	CMP	AX,FSTAT_FONT		;;
	JNE	SET_NEXT		;;
					;;
	MOV	AX,FTP.FTB_DLEFT	;;
	AND	AX,AX			;;
	JNZ	SET_NEXT		;;
					;;
	MOV	FTP.FTB_STATUS,FSTAT_COMPLETE
					;;
SET_NEXT :				;;
					;;
	ADD	BX,TYPE FTBLK		;;
					;;
	DEC	DX			;;
	AND	DX,DX			;;
	JNZ	SET_COMPLETE		;;
					;;
	POP	BX			;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ADD	BX,TYPE FBUFS		;; FTP = FONT BLOCK
					;;
	PUSH	CX			;; STACK 1 = CX
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; DO WHILE CX is not zero :
;;
;; -- on each loop, the CX, COUNTs are updated
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;;
FTB_LOOP :				;;
	POP	AX			;; STACK -1
	SUB	AX,CX			;;
	ADD	cs:count_lo,AX		   ;;
	JNC	NO_CARRY		;;
	ADD	cs:count_hi,1000H	   ;;
NO_CARRY :				;;
	PUSH	CX			;; STACK 1 = CX
	AND	CX,CX			;;
	JNZ	FTB_CONT		;;
	JMP	FTB_LPEND		;;
					;; DO CASES :
FTB_CONT :				;; ==========
					;;
	MOV	AX,cs:stage		   ;;
					;;
	CMP	AX,STAGE_MAX		;;
	JNE	FTB_010 		;;
	JMP	START_CASE		;; ** RESTART **
					;;
FTB_010 :				;;
	CMP	AX,MATCHX		;;
	JAE	FTB_020 		;;
	JMP	SEARCH_CASE		;; ** SEARCH **
					;;
FTB_020 :				;;
	CMP	AX,MATCHX		;;
	JNE	FTB_030 		;;
	JMP	MATCH_CASE		;; ** MATCH **
					;;
FTB_030 :				;;
	CMP	AX,SCANX		;;
	JNE	FTB_040 		;;
	JMP	SCAN_CASE		;; ** SCAN **
					;;
FTB_040 :				;;
	CMP	AX,FOUNDX		;;
	JAE	FTB_050 		;;
	JMP	PRE_FOUND_CASE		;; ** PRE-FOUND **
					;;
FTB_050 :				;;
	CMP	AX,FOUNDX		;;
	JNE	FTB_060 		;;
	JMP	FOUND_CASE		;; ** FOUND  **
					;;
FTB_060 :				;;
	CMP	AX,GET_FX		;;
	JNE	FTB_070 		;;
	JMP	GETFONT_CASE		;; ** GET_FONT **
					;;
FTB_070 :				;;
	CMP	AX,PASSX		;;
	JNE	FTB_080 		;;
	JMP	PASS			;; ** PASS **
					;;
FTB_080 :				;;
	CMP	AX,FPTR_SKIPX		;;
	JAE	FTB_090 		;;
	JMP	SEARCH_CASE		;; ** SEARCH **
					;;
FTB_090 :				;;
	CMP	AX,FPTR_SKIPX		;;
	JNE	FTB_FFF 		;;
	JMP	FPTR_SKIP_CASE		;; ** SEARCH **
					;;
FTB_FFF :				;;
	MOV	FTP.FTB_STATUS,STAT_DEVERR
	JMP	FTB_LPEND		;; ** DEVICE ERROR **
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; at the entry of each STAGES /CASES
;;
;; --	DS:[SI]  (FPKT) points to PACKET, of DOS's buffer
;; --	CX	 remaining packet length
;; --	ES:[BX]  points to the first FTBLK
;; --	COUNT_LO, COUNT_HI, upto but and including the address pointed by FPKT
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
;============================================================================
START_CASE :				;; pass the FILE leading bytes
					;;
	MOV	cs:ftag_count,0 	   ;;
	MOV	cs:stage,ftagx		   ;;
	JMP	FTB_LOOP		;;
					;;
;=============================================================================
FPTR_SKIP_CASE :			;; skip until the ENTRY pointed by
					;; POINTER (in FPTR) is reached.
					;;
					;; **************
	MOV	AX,cs:fptr_low		   ;; * HIT = FPTR *
	MOV	cs:hit_lo,AX		   ;; **************
	MOV	DX,cs:fptr_high 	   ;;
	MOV	cs:hit_hi,DX		   ;;
					;;
	CMP	AX,0FFFFH		;;
	JNE	FPTR_SKIP_VALID 	;;
	CMP	DX,0FFFFH		;;
	JNE	FPTR_SKIP_VALID 	;;
					;;
	MOV	FTP.FTB_STATUS,STAT_BADATA ;; returned at the first FTBLK
	JMP	FPTR_SKIP_MORE		;;
					;;
FPTR_SKIP_VALID :			;;
					;; normalised HIT_HI, HIT_LO
	MOV	AX,DX			;;
	AND	AX,00FFFH		;;
	PUSH	CX			;;
	MOV	CX,4			;;
	SHL	AX,CL			;;
	POP	CX			;;
	AND	DX,0F000H		;;
	ADD	AX,cs:hit_lo		   ;;
	JNC	NO_CARRY10		;;
	ADD	DX,01000H		;;
NO_CARRY10:				;;
	MOV	cs:hit_lo,AX		   ;;
	MOV	cs:hit_hi,DX		   ;;
					;; **************************
					;; * compare FPTR and COUNT *
					;; **************************
					;; DX:AX = HIT_HI:HIT_LO (normalised)
					;;
	SUB	AX,cs:count_lo		   ;;
	Jnc	more_fptrlo		;;
	sub	dx,01000h		;;
	jc	fptr_bad		;;
					;;
more_fptrlo :				;;
	SUB	DX,cs:count_hi		   ;;
	JC	fptr_BAD		;;
					;;
	INC	AX			;; COUNT can be at the HIT, then AX=0
	JNC	NO_CARRY11		;; INC AX to make AX comparable to CX
	ADD	DX,01000H		;; i.e. AX = offset + 1
					;;
NO_CARRY11:				;;
	CMP	AX,CX			;;
	JA	fptr_skip_more		;; AX > CX, whole CX to be skipped
					;;
	PUSH	DX			;;  normalise dx:ax
	AND	DX,00FFFH		;;
	PUSH	CX			;;
	MOV	CX,4			;;
	SHL	DX,CL			;;
	POP	CX			;;
	ADD	AX,DX			;;
	POP	DX			;;
	JNC	NO_CARRY13		;;
	ADD	DX,01000H		;;
NO_CARRY13:				;;
	AND	DX,0F000H		;;
					;;
	PUSH	AX			;;
	PUSH	DX			;; STACK +1 : normalosed DX:AX
	SUB	AX,CX			;;
	JNC	NO_BORROW11		;;
	SUB	DX,1000H		;;
	JC	fptr_MORE_CXp		;; dx:ax < cx
NO_BORROW11:				;;
					;; dx:ax >= cx
	AND	AX,AX			;;
	JNE	fptr_skip_MOREP 	;;
	AND	DX,DX			;;
	JNE	fptr_skip_MOREP 	;;
					;; dx:ax = cx, or
					;; offset + 1 = CX
					;;
					;; ************************************
					;; * POINTER is within the current CX *
					;; ************************************
fptr_MORE_CXP : 			;;
	POP	DX			;;
	POP	AX			;; STACK -1
					;;
fptr_MORE_CX :				;; DX = 0,to have more CX than offset+1
	DEC	AX			;; = offset : 0 and above
	SUB	CX,AX			;;
	ADD	SI,AX			;; where the first byte is
					;;
	MOV	cs:stage,entry_lox	   ;; ENTRIES in the font file
					;;
	JMP	FTB_LOOP		;;  ******  RETURN  *******
					;;
					;; ***********************************
					;; * more to skip ==> FPTR_SKIP_CASE *
					;; ***********************************
fptr_skip_morep:			;;
	POP	DX			;;
	POP	AX			;; STACK -1
					;;
fptr_skip_more :			;;
	ADD	SI,CX			;;
	SUB	CX,CX			;;
	JMP	FTB_LOOP		;; ******  RETURN  *****
					;;
					;; ***********************************
					;; * bad POINTER in font file header *
					;; ***********************************
					;;
fptr_bad :				;;
	MOV	cs:fptr_low,0FFFFH	   ;;
	MOV	cs:fptr_high,0FFFFH	   ;;
					;;
	MOV	FTP.FTB_STATUS,STAT_BADATA ;; returned at the first FTBLK
					;;
	JMP	FPTR_SKIP_MORE		;;
					;;
;=============================================================================
SEARCH_CASE :				;;
					;; still looking for header to match
					;; the input : codepage and typeid
					;;
	MOV	DI,cs:stage		   ;;
					;;
	ADD	DI,DI			;; double to index to WORD-offset
					;;
	JMP	CS:STAGE_CASES[DI]	;; call routine to process the stage
					;;
					;;
;===========================================================================
MATCH_CASE :				;;
					;;
	PUSH	BX			;;
	MOV	DX,cs:num_ftb		   ;;
					;;
					;;
MATCH_LOOP :				;;
	MOV	AX,FTP.FTB_STATUS	;;
	CMP	AX,FSTAT_SEARCH 	;;
	JE	MATCH_SEARCH		;;
	JMP	MATCH_NEXT		;;
					;;
MATCH_SEARCH :				;;
	MOV	AX,FTP.FTB_CP		;; check the FTB with SEARCH status
	CMP	AX,cs:cpg_word		   ;;
	JNE	MATCH_MORE		;;
	PUSH	DS			;; code page matched
	PUSH	SI			;;
	PUSH	CX			;;
					;;
	PUSH	CS			;;
	POP	DS			;;
	MOV	SI,OFFSET TYPE_ID	;;
	LEA	DI,[BX].FTB_TID 	;;
	MOV	CX,8			;;
	REPE	CMPSB			;;
					;;
	POP	CX			;;
	POP	SI			;;
	POP	DS			;;
					;;
	JNE	MATCH_MORE		;;
					;; MATCH !!!!!	(type_id matched)
	MOV	FTP.FTB_STATUS,FSTAT_MATCH
	MOV	AX,cs:type_word 	   ;;
	MOV	FTP.FTB_TYPE,AX 	;;
	MOV	AX,cs:font_low		   ;;
	MOV	FTP.TARGET_LO,AX	;;
	MOV	AX,cs:font_high 	   ;;
	MOV	FTP.TARGET_HI,AX	;;
					;;
	JMP	MATCH_NEXT		;;
					;;
MATCH_MORE :				;; if this is the last rounf ?
					;;
	MOV	AX,cs:next_low		   ;; NEXT = FFFF:FFFF means no more
	CMP	AX,-1			;;	  header to come.
	JNE	MATCH_NEXT		;;
					;;
	MOV	AX,cs:next_high 	   ;;
	CMP	AX,-1			;;
	JNE	MATCH_NEXT		;;
					;;
	MOV	FTP.FTB_STATUS,STAT_NOFIND ;; ERROR : no match
					;;
MATCH_NEXT :				;;
	ADD	BX,FTP.FTB_LENGTH	;;
	DEC	DX			;;
	AND	DX,DX			;;
	JZ	MATCH_ALL		;;
	JMP	MATCH_LOOP		;;
					;;
MATCH_ALL :				;;
	MOV	cs:stage,SCANX		   ;;
					;;
MATCH_DONE :				;;
	POP	BX			;;
	JMP	FTB_LOOP		;;
					;;
;===========================================================================
SCAN_CASE :				;;
					;; **********************************
					;; * determine whether it the font  *
					;; * data(TARGET),or the next font  *
					;; * header(NEXT) that is approaching
					;; **********************************
					;;
	MOV	AX,cs:next_low		   ;;
	MOV	cs:hit_lo,AX		   ;;
	MOV	AX,cs:next_high 	   ;;
	MOV	cs:hit_hi,AX		   ;;
	XOR	AX,AX			;;
	MOV	cs:hit_flag,AX		   ;;
					;;
	MOV	DI,cs:hit_hi		   ;; normalised HIT_HI, HIT_LO
	MOV	AX,DI			;;
	AND	AX,00FFFH		;;
	PUSH	CX			;;
	MOV	CX,4			;;
	SHL	AX,CL			;;
	POP	CX			;;
	AND	DI,0F000H		;;
	ADD	AX,cs:hit_lo		   ;;
	JNC	NO_CARRY2		;;
	ADD	DI,01000H		;;
NO_CARRY2 :				;;
	MOV	cs:hit_lo,AX		   ;;
	MOV	cs:hit_hi,DI		   ;;
					;;
	MOV	DX,cs:num_ftb		   ;;
					;;
	PUSH	BX			;;
SCAN_LOOP :				;;
	MOV	AX,FTP.FTB_STATUS	;;
	CMP	AX,FSTAT_MATCH		;;
	JNE	SCAN_NEXT		;;
					;;
					;;
	MOV	DI,FTP.TARGET_HI	;; NORMALISED TARGET
	MOV	AX,DI			;;
	AND	AX,00FFFH		;;
	PUSH	CX			;;
	MOV	CX,4			;;
	SHL	AX,CL			;;
	POP	CX			;;
	AND	DI,0F000H		;;
	ADD	AX,FTP.TARGET_LO	;;
	JNC	NO_CARRY1		;;
	ADD	DI,01000H		;;
NO_CARRY1 :				;; DI:AX = NORMALISED TARGET
					;;
					;; ** compare the TARGET and the NEXT
					;;
	CMP	DI,cs:hit_hi		   ;;
	JA	SCAN_NEXT		;;
					;;
	JE	SCAN_EQU		;;
	JMP	NEAR_FONT		;;
					;;
SCAN_EQU :				;;
	CMP	AX,cs:hit_lo		   ;;
	JA	SCAN_NEXT		;;
	JE	SCAN_ERROR_CHK		;;
					;; **********************************
					;; * the font data is approaching   *
					;; **********************************
NEAR_FONT :				;;
	MOV	cs:hit_flag,-1		   ;;
	MOV	cs:hit_lo,AX		   ;;
	MOV	cs:hit_hi,DI		   ;;
	MOV	cs:hit_bx,BX		   ;; used for BAD_BX and in FOUND_CASE
	JMP	SCAN_NEXT		;;
					;;
					;; **********************************
					;; * the NEXT header is approaching *
					;; **********************************
SCAN_ERROR_CHK :			;;
	MOV	AX,cs:hit_flag		   ;;
	AND	AX,AX			;;
	JNZ	SCAN_NEXT		;;
	MOV	FTP.FTB_STATUS,STAT_BADATA ;; next header and font cannot be the
					;; same
					;;
SCAN_NEXT :				;;
	DEC	DX			;;
	AND	DX,DX			;;
	JZ	SCAN_DONE		;;
					;;
	ADD	BX,FTP.FTB_LENGTH	;;
	JMP	SCAN_LOOP		;; ** is there any closer font data ?
					;;
					;; ************************************
					;; * the HIT is either font data(TARGET
					;; * or the font block (NEXT).	      *
					;; ************************************
SCAN_DONE :				;;
	POP	BX			;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	MOV	DX,cs:hit_hi		   ;; HIT_FLAG, HIT_LO, HIT_HI defined
	MOV	AX,cs:hit_lo		   ;;
					;;
	CMP	AX,0FFFFH		;;
	JNE	NOT_FFFF_HIT		;;
	CMP	DX,0FFFFH		;;
	JNE	NOT_FFFF_HIT		;;
	JMP	SCAN_MORE		;; stage remained as SCAN, discard data
					;;
NOT_FFFF_HIT :				;;
					;; DX:AX = HIT_HI:HIT_LO (normalised)
	SUB	AX,cs:count_lo		   ;;
	JNC	NO_BORROW		;;
	SUB	DX,01000H		;;
	JC	SCAN_BAD		;;
NO_BORROW:				;;
	SUB	DX,cs:count_hi		   ;;
	JC	SCAN_BAD		;;
					;;
	INC	AX			;; COUNT can be at the HIT, then AX=0
	JNC	NO_CARRYX		;; INC AX to make AX comparable to CX
	ADD	DX,01000H		;; i.e. AX = offset + 1
					;;
NO_CARRYX :				;;
	CMP	AX,CX			;;
	JA	SCAN_MORE		;;
					;;
	PUSH	DX			;;
	AND	DX,00FFFH		;;
	PUSH	CX			;;
	MOV	CX,4			;;
	SHL	DX,CL			;;
	POP	CX			;;
	ADD	AX,DX			;;
	POP	DX			;;
	JNC	NO_CARRY3		;;
	ADD	DX,01000H		;;
NO_CARRY3 :				;;
	AND	DX,0F000H		;;
					;;
					;;
	PUSH	AX			;;
	PUSH	DX			;;
	SUB	AX,CX			;;
	JNC	NO_BORROW1		;;
	SUB	DX,1000H		;;
	JC	MORE_CXp		;;
NO_BORROW1 :				;;
					;; dx:ax >= cx
	AND	AX,AX			;;
	JNE	SCAN_MOREP		;;
	AND	DX,DX			;;
	JNE	SCAN_MOREP		;;
					;;
					;; offset + 1 = CX
					;;
MORE_CXP :				;;
	POP	DX			;;
	POP	AX			;;
					;;
MORE_CX :				;; DX = 0,to have more CX than offset+1
	DEC	AX			;; = offset : 0 and above
	SUB	CX,AX			;;
	ADD	SI,AX			;; where the first byte is
	MOV	AX,cs:hit_flag		   ;;
	AND	AX,AX			;;
	JE	NEXT_REACHED		;;
					;;
	MOV	cs:stage,MOD_LOBX	   ;; font-data reached,
					;;
	JMP	FTB_LOOP		;;  ****** RETURN   *******
					;;
NEXT_REACHED :				;;
	MOV	cs:stage,PASSX		   ;;
	MOV	cs:pass_postx,next_lolX    ;;
	MOV	cs:pass_cnt,FILE_OFFSET    ;;
					;;
					;;
	JMP	FTB_LOOP		;; ******  RETURN   *******
					;;
					;; ***********************************
SCAN_MOREP :				;; * scan more FTBLK for the nearest *
					;; * font data			     *
					;; ***********************************
	POP	DX			;;
	POP	AX			;;
					;;
SCAN_MORE :				;;
	ADD	SI,CX			;;
	SUB	CX,CX			;;
	JMP	FTB_LOOP		;; more SCAN stage
					;;
SCAN_BAD:				;; *************************
	MOV	AX,cs:hit_flag		   ;; * scan is bad	      *
	AND	AX,AX			;; *************************
	JNZ	BAD_BX			;;
	MOV	AX,-1			;; NEXT is pointing backwards
	MOV	cs:next_low,AX		   ;;
	MOV	cs:next_high,AX 	   ;; no more NEXT
	MOV	FTP.FTB_STATUS,STAT_BADATA ;; returned at the first FTBLK
	JMP	FTB_LOOP		;;
					;;
BAD_BX	:				;;
	PUSH	BX			;; FONT is pointing backwards
	MOV	BX,cs:hit_bx		   ;;
	MOV	FTP.FTB_STATUS,STAT_BADATA
	POP	BX			;;
	JMP	FTB_LOOP		;;
					;;
;===========================================================================
PRE_FOUND_CASE :			;;
					;; extract informations from the font
					;; block until font_length is defined
					;;
	MOV	DI,cs:stage		   ;;
					;;
	ADD	DI,DI			;; double to index to WORD-offset
					;;
	JMP	CS:STAGE_CASES[DI]	;; call routine to process the stage
					;;
;===========================================================================
FOUND_CASE :				;;
	MOV	DI,OFFSET FTB_LOOP	;; as FOUND has two places to return to
	PUSH	DI			;;
;===========================================================================
FOUND_DO :				;;
					;; define informations into FTBLK of
					;; HIT_BX defined in the SCAN case
	PUSH	BX			;;
	MOV	BX,cs:hit_bx		   ;;
					;; FTBLK :
	MOV	AX,cs:mod_word		   ;;
	MOV	FTP.FTB_MOD,AX		;;
	MOV	AX,cs:fonts_word	   ;;
	MOV	FTP.FTB_FONTS,AX	;;
					;;
	MOV	AX,cs:fdlen_word	   ;;
	MOV	FTP.FTB_DLEFT,AX	;;
	MOV	FTP.FTB_DLEN,0		;;
	MOV	FTP.FTB_DALO,0		;;
	MOV	FTP.FTB_DAHI,0		;;
					;;
	MOV	FTP.FTB_STATUS,FSTAT_FOUND
					;;
	CMP	FTP.FTB_TYPE,TYPE_DISPLAY;
	JNE	CHECK_PTR_TYPE		;;
	CMP	cs:pre_font_len,PRE_FONT_D ;;
	JNE	DISPLAY_BAD		;;
	JMP	DISPLAY_DONE		;;
					;;
CHECK_PTR_TYPE :			;;
	CMP	FTP.FTB_TYPE,TYPE_PRINTER;
	JNE	SET_STAGE		;;
	CMP	cs:ptr_sel_word,0	   ;;
	JNE	PRINTER_HAS_SEL 	;;
	CMP	cs:pre_font_len,PRE_FONT_P0;;
	JNE	PRINTER_BAD		;;
	JMP	PRINTER_DONE		;;
					;;
PRINTER_HAS_SEL :			;;
	CMP	cs:pre_font_len,PRE_FONT_P ;;
	JNE	PRINTER_BAD		;;
	JMP	PRINTER_DONE		;;
					;;
DISPLAY_BAD :				;;
					;;
	MOV	FTP.FTB_STATUS,STAT_BADATA ;the FDLEN_WORD should be 0.
					;;
DISPLAY_DONE :				;;
	MOV	AL,cs:disp_rows 	   ;;
	MOV	FTP.FTB_ROWS,AL 	;;
	MOV	AL,cs:disp_cols 	   ;;
	MOV	FTP.FTB_COLS,AL 	;;
	MOV	AL,cs:disp_x		   ;;
	MOV	FTP.FTB_X,AL		;;
	MOV	AL,cs:disp_y		   ;;
	MOV	FTP.FTB_Y,AL		;;
	MOV	AX,cs:count_word	   ;;
	MOV	FTP.FTB_COUNT,AX	;;
	JMP	SET_STAGE		;;
					;;
PRINTER_BAD :				;;
					;;
	MOV	FTP.FTB_STATUS,STAT_BADATA ;the FDLEN_WORD should be 0.
					;;
PRINTER_DONE :				;;
	MOV	AX,cs:ptr_sel_word	   ;;
	MOV	FTP.FTB_SELECT,AX	;;
	MOV	AX,cs:ptr_len_word	   ;;
	MOV	FTP.FTB_SELLEN,AX	;;
					;;
SET_STAGE :				;; STAGE :
	MOV	AX,cs:fdlen_word	   ;; if no font data to follow
	AND	AX,AX			;;
	JNZ	GET_FDATA		;;
	MOV	cs:stage,SCANX		   ;; then scan for next header or font
	JMP	FONT_RET		;;
					;;
GET_FDATA :				;; update the moving target
	MOV	cs:stage,GET_FX 	   ;;
	MOV	AX,cs:pre_font_len	   ;;
	ADD	FTP.TARGET_LO,AX	;;
	JNC	FONT_RET		;;
	ADD	FTP.TARGET_HI,01000H	;;
					;;
FONT_RET :				;;
	POP	BX			;;
	RET				;;
					;;
;===========================================================================
GETFONT_CASE :				;; as ES:[SI], at COUNT, there is font
					;; data
	MOV	DX,cs:num_ftb		   ;;
	PUSH	BX			;;
					;;
	MOV	cs:hit_hi,0		   ;; temp. register
	MOV	cs:hit_flag,0		   ;; assumed can be changed to SCAN stage
					;;
	MOV	DI,cs:count_hi		   ;; normalised COUNT_HI,COUNT_LO
	MOV	AX,DI			;;
	AND	AX,00FFFH		;;
	PUSH	CX			;;
	MOV	CX,4			;;
	SHL	AX,CL			;;
	POP	CX			;;
	AND	DI,0F000H		;;
	ADD	AX,cs:count_lo		   ;;
	JNC	NO_CARRY4		;;
	ADD	DI,01000H		;;
NO_CARRY4 :				;;
	MOV	cs:count_lo,AX		   ;;
	MOV	cs:count_hi,DI		   ;;
					;;
					;;
GETFONT_LOOP :				;;
	MOV	AX,FTP.FTB_STATUS	;;
	CMP	AX,FSTAT_FONT		;;
	JE	GETFONT_CONT		;;
					;;
	CMP	AX,FSTAT_FOUND		;;
	JE	GETFONT_FOUND		;;
					;;
	JMP	NEXT_GETFONT		;;
					;;
GETFONT_FOUND : 			;;
	MOV	AX,FTP.FTB_DLEFT	;;
	AND	AX,AX			;;
	JZ	NEXT_GF 		;;
	MOV	FTP.FTB_STATUS,FSTAT_FONT;
	JMP	GETFONT_CONT1		;;
					;;
					;;
GETFONT_CONT :				;;
	MOV	AX,FTP.FTB_DLEFT	;;
	AND	AX,AX			;;
	JNZ	GETFONT_CONT1		;;
NEXT_GF :				;;
	JMP	NEXT_GETFONT		;;
					;; only on FOUND and DLEFT <> 0
GETFONT_CONT1:				;;
	MOV	DI,FTP.TARGET_HI	;; normalised TARGET
	MOV	AX,DI			;;
	AND	AX,00FFFH		;;
	PUSH	CX			;;
	MOV	CX,4			;;
	SHL	AX,CL			;;
	POP	CX			;;
	AND	DI,0F000H		;;
	ADD	AX,FTP.TARGET_LO	;;
	JNC	NO_CARRY5		;;
	ADD	DI,01000H		;;
NO_CARRY5 :				;; DI:AX = TARGET (normalised)
					;;
	CMP	DI,cs:count_hi		   ;;
	JB	GETFONT_BAD		;;
	JNE	NEXT_GETFONT		;;
	CMP	AX,cs:count_lo		   ;;
	JB	GETFONT_BAD		;;
	JNE	NEXT_GETFONT		;;
					;;
	MOV	FTP.FTB_DALO,SI 	;; where the font data is in the packet
	MOV	FTP.FTB_DAHI,DS 	;;
					;;
	MOV	AX,FTP.FTB_DLEFT	;;
	CMP	AX,CX			;;
	JAE	UPTO_CX 		;;
					;; upto FDLEFT
	MOV	FTP.FTB_DLEFT,0 	;;
	MOV	FTP.FTB_DLEN,AX 	;;
	CMP	cs:hit_hi,AX		   ;;
	JNB	NOT_HIGHER0		;;
	MOV	cs:hit_hi,AX		   ;;
NOT_HIGHER0 :				;;
	ADD	FTP.TARGET_LO,AX	;;
	JNC	NEXT_GETFONT		;;
	ADD	FTP.TARGET_HI,01000H	;;
	JMP	NEXT_GETFONT		;;
					;;
GETFONT_BAD :				;;
	MOV	FTP.FTB_STATUS,STAT_BADATA ;; pointing backwards
	JMP	NEXT_GETFONT		;;
					;;
UPTO_CX :				;;
	SUB	AX,CX			;;
	MOV	FTP.FTB_DLEFT,AX	;;
	MOV	FTP.FTB_DLEN,CX 	;;
	MOV	cs:hit_hi,CX		   ;;
	ADD	FTP.TARGET_LO,CX	;;
	JNC	NO_CARRYOVER		;;
	ADD	FTP.TARGET_HI,01000H	;;
NO_CARRYOVER :				;;
	AND	AX,AX			;; all data have been returned ?
	JZ	NEXT_GETFONT		;;
					;;
	MOV	cs:hit_flag,-1		   ;; no ! stay in the GET_FONT stage
					;;
NEXT_GETFONT :				;;
	ADD	BX,FTP.FTB_LENGTH	;;
	DEC	DX			;;
	AND	DX,DX			;;
	JZ	GETFONT_END		;;
	JMP	GETFONT_LOOP		;;
					;;
GETFONT_END :				;;
	MOV	AX,cs:hit_hi		   ;;
	ADD	SI,AX			;;
	SUB	CX,AX			;;
					;;
	CMP	cs:hit_flag,0		   ;;
	Jne	GETFONT_DONE		;;
	MOV	cs:stage,SCANX		   ;; no more in the GET_FONT stage
					;;
					;;
GETFONT_DONE :				;;
	POP	BX			;;
	JMP	FTB_LOOP		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; STAGES --  "called by" SERACH_CASE
;;
;; --	DS:[SI]  (FPKT) points to PACKET, of DOS's buffer
;; --	CX	 remaining packet length
;; --	ES:[BX]  points to the first FTBLK
;; --	COUNT_LO, COUNT_HI, upto but not including the address pointed by FPKT
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;+++++++++++++++++++++++++++++++++
filetag :				;;
					;;
;	mov	ax,ftag_len		;;
	cmp	cs:ftag_count,ftag_len	   ;;
	jB	valid_ftag		;;
	JE	FTAG_FAILED		;;
					;;
	mov	ftp.ftb_status,stat_deverr
	mov	cs:fp_error,00022H	   ;; ERROR 0022H
					;;
FTAG_FAILED :				;; discard all the bytes, while
	ADD	SI,CX			;; stage stays as FTAGX
	SUB	CX,CX			;;
	JMP	FTB_LOOP		;; **** RETURN (bytes discarded) ****
					;;
VALID_FTAG :				;;
	MOV	AX,FPKT 		;;
	INC	SI			;;
	DEC	CX			;;
					;;
	MOV	DI,cs:ftag_count	   ;;
	CMP	AL,cs:ftag_pattern[DI]	   ;;
	JE	FTAG_NEXTB		;;
					;;
	mov	ftp.ftb_status,stat_badata
	MOV	ax,ftag_len		;; stays in FTAGX to consume all bytes
	MOV	cs:ftag_count,ax	   ;; stays in FTAGX to consume all bytes
	JMP	FTB_LOOP		;; **** RETURN (FAILED !)  ****
					;;
FTAG_NEXTB :				;;
	INC	DI			;;
	MOV	cs:ftag_count,DI	   ;;
					;;
	CMP	DI,ftag_len		;;
	JE	FTAG_DONE		;;
					;;
	JMP	FTB_LOOP		;; **** RETURN ( MORE TO COME) ****
					;;
FTAG_DONE :				;;
	MOV	cs:pass_cnt,0		   ;;
	MOV	cs:stage,PASSX		   ;;
	MOV	cs:pass_postx,fptr_lolx    ;;
					;;
	JMP	FTB_LOOP		;; **** NEXT STAGE ****
					;;
					;;+++++++++++++++++++++++++++++++++
fptrLOL :				;; STAGE the low byte of the low fptr
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_fptrLO		;;
	MOV	cs:fptr_lol,AL		   ;;
	MOV	cs:stage,fptr_lohX	   ;;
	JMP	FTB_LOOP		;;
WORD_fptrLO :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:fptr_low,AX		   ;;
	MOV	cs:stage,fptr_HILX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
fptrLOH :				;; STAGE the high byte of the low fptr
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:fptr_loh,AL		   ;;
	MOV	cs:stage,fptr_HILX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
fptrHIL :				;; STAGE the low byte of the high fptr
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_fptrHI		;;
	MOV	cs:fptr_hil,AL		   ;;
	MOV	cs:stage,fptr_hihX	   ;;
	JMP	FTB_LOOP		;;
WORD_fptrHI :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:fptr_high,AX 	   ;;
	MOV	cs:stage,FPTR_SKIPX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
fptrHIH :				;; STAGE the high byte of the high fptr
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:fptr_hih,AL		   ;;
	MOV	cs:stage,FPTR_SKIPX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
ENTRYLO :				;; STAGE - ENTRY LOW BYTE
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_ENTRY		;;
	MOV	cs:entry_lob,AL 	   ;;
	MOV	cs:stage,ENTRY_HIX	   ;;
	JMP	FTB_LOOP		;;
WORD_ENTRY :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:entry_word,AX	   ;;
	MOV	cs:stage,PASSX		   ;; 2 bytes to be passed
	MOV	cs:pass_postx,NEXT_LOLX    ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
ENTRYHI :				;; stage - ENTRY HIGN BYTE
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:entry_hib,AL 	   ;;
	MOV	cs:stage,PASSX		   ;; 2 bytes to be passed
	MOV	cs:pass_postx,NEXT_LOLX    ;;
	AND	CX,CX			;;
	JNZ	ENTHI_PASS1		;;
	JMP	FTB_LOOP		;;
ENTHI_PASS1 :				;;
	INC	SI			;;
	INC	cs:pass_cnt		   ;;
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	ENTHI_PASS2		;;
	JMP	FTB_LOOP		;;
ENTHI_PASS2 :				;;
	INC	SI			;;
	INC	cs:pass_cnt		   ;;
	DEC	CX			;;
	MOV	cs:stage,NEXT_LOLX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
NEXTLOL :				;; STAGE the low byte of the low NEXT
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_NEXTLO		;;
	MOV	cs:next_lol,AL		   ;;
	MOV	cs:stage,NEXT_LOHX	   ;;
	JMP	FTB_LOOP		;;
WORD_NEXTLO :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:next_low,AX		   ;;
	MOV	cs:stage,next_hilX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
NEXTLOH :				;; STAGE the high byte of the low NEXT
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:next_loh,AL		   ;;
	MOV	cs:stage,next_hilX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
NEXTHIL :				;; STAGE the low byte of the high NEXT
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_NEXTHI		;;
	MOV	cs:next_hil,AL		   ;;
	MOV	cs:stage,NEXT_HIHX	   ;;
	JMP	FTB_LOOP		;;
WORD_NEXTHI :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:next_high,AX 	   ;;
	MOV	cs:stage,type_lobX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
NEXTHIH :				;; STAGE the high byte of the high NEXT
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:next_hih,AL		   ;;
	MOV	cs:stage,type_lobX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
TYPELO	:				;; STAGE the low byte of the TYPE
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_TYPE		;;
	MOV	cs:type_lob,AL		   ;;
	MOV	cs:stage,type_hibX	   ;;
	JMP	FTB_LOOP		;;
WORD_TYPE :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:type_word,AX 	   ;;
	MOV	cs:stage,type_idX	   ;;
	MOV	cs:tid_cnt,0		   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
TYPEHI	:				;; STAGE the high byte of the TYPE
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:type_hib,AL		   ;;
	MOV	cs:stage,TYPE_IDX	   ;;
	MOV	cs:tid_cnt,0		   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
TYPEIDS :				;; STAGE the type id
	CMP	cs:tid_cnt,8		   ;;
	JNA	VALID_TID		;;
	MOV	FTP.FTB_STATUS,STAT_DEVERR
	MOV	cs:fp_error,00021H	   ;; ERROR 0021H
	ADD	SI,CX			;;
	SUB	CX,CX			;;
	JMP	FTB_LOOP		;;
					;;
VALID_TID :				;;
	MOV	AX,8			;;
	SUB	AX,cs:tid_cnt		   ;;
	CMP	CX,AX			;;
	JNB	TID_ALL 		;;
					;; all data in FPKT are stored
	PUSH	ES			;;
	PUSH	CS			;;
	POP	ES			;;
					;;
	MOV	DI,OFFSET TYPE_ID	;;
	ADD	DI,cs:tid_cnt		   ;;
	ADD	cs:tid_cnt,CX		   ;;
	REP	MOVSB			;; SI is incremented accordingly
	POP	ES			;;
					;;
	MOV	CX,0			;; STAGE remained
	JMP	FTB_LOOP		;;
TID_ALL :				;;
	PUSH	CX			;;
					;;
	PUSH	ES			;;
	PUSH	CS			;;
	POP	ES			;;
					;;
	MOV	DI,OFFSET TYPE_ID	;;
	ADD	DI,cs:tid_cnt		   ;;
	MOV	CX,AX			;;
	REP	MOVSB			;; SI is incremented accordingly
	POP	ES			;;
					;;
	ADD	cs:tid_cnt,AX		   ;;
	POP	CX			;;
	SUB	CX,AX			;;
					;;
	MOV	cs:stage,CPG_LOBX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
CPGLO	:				;; STAGE the low byte of the CODE PAGE
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_CPG		;;
	MOV	cs:cpg_lob,AL		   ;;
	MOV	cs:stage,CPG_HIBX	   ;;
	JMP	FTB_LOOP		;;
WORD_CPG :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:cpg_word,AX		   ;;
	MOV	cs:stage,PASSX		   ;;
	MOV	cs:pass_postx,font_lolX    ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
CPGHI	:				;; STAGE the high byte of the CODE PAGE
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:cpg_hib,AL		   ;;
	MOV	cs:stage,PASSX		   ;;
	MOV	cs:pass_postx,font_lolX    ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
FONTLOL :				;; STAGE the low byte of the low FONT
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_FONTLO		;;
	MOV	cs:font_lol,AL		   ;;
	MOV	cs:stage,FONT_LOHX	   ;;
	JMP	FTB_LOOP		;;
WORD_FONTLO :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:font_low,AX		   ;;
	MOV	cs:stage,FONT_HILX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
FONTLOH :				;; STAGE the high byte of the low FONT
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:font_loh,AL		   ;;
	MOV	cs:stage,FONT_HILX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
FONTHIL :				;; STAGE the low byte of the high FONT
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_FONTHI		;;
	MOV	cs:font_hil,AL		   ;;
	MOV	cs:stage,FONT_HIHX	   ;;
	JMP	FTB_LOOP		;;
WORD_FONTHI :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:font_high,AX 	   ;;
;;;;;;	MOV	cs:stage,MOD_LOBX	   ;; end of SCAN
					;; anymore headers to be processed ?
	MOV	cs:stage,MATCHX 	   ;;
	MOV	AX,cs:entry_word	   ;;
	DEC	AX			;;
	MOV	cs:entry_word,AX	   ;;
	AND	AX,AX			;;
	JNZ	CHECK_NEXT		;;
					;; no more header to be processed !
	MOV	AX,-1			;;
	MOV	cs:next_low,AX		   ;;
	MOV	cs:next_high,AX 	   ;; as ENTRY has been consumed
	JMP	FTB_LOOP		;;
					;;
CHECK_NEXT :				;;
	MOV	AX,cs:next_low		   ;;
	AND	AX,AX			;;
	JNZ	MORE_HEADER		;;
	MOV	AX,cs:next_high 	   ;;
	AND	AX,AX			;;
	JNZ	MORE_HEADER		;;
					;; no more header to be processed !
	MOV	AX,-1			;;
	MOV	cs:next_low,AX		   ;; as NEXT is nil
	MOV	cs:next_high,AX 	   ;;
					;;
MORE_HEADER :				;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
FONTHIH :				;; STAGE the high byte of the high FONT
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:font_hih,AL		   ;;
;;;;;	MOV	cs:stage,MOD_LOBX	   ;; end of SCAN
					;;
	MOV	cs:stage,MATCHX 	   ;;
					;; anymore headers to be processed ?
	MOV	AX,cs:entry_word	   ;;
	DEC	AX			;;
	MOV	cs:entry_word,AX	   ;;
	AND	AX,AX			;;
	JNZ	CHECK_NEXT0		;;
					;; no more header to be processed !
	MOV	AX,-1			;;
	MOV	cs:next_low,AX		   ;;
	MOV	cs:next_high,AX 	   ;; as ENTRY has been consumed
	JMP	FTB_LOOP		;;
					;;
CHECK_NEXT0 :				;;
	MOV	AX,cs:next_low		   ;;
	AND	AX,AX			;;
	JNZ	MORE_HEADER0		;;
	MOV	AX,cs:next_high 	   ;;
	AND	AX,AX			;;
	JNZ	MORE_HEADER0		;;
					;; no more header to be processed !
	MOV	AX,-1			;;
	MOV	cs:next_low,AX		   ;; as NEXT is nil
	MOV	cs:next_high,AX 	   ;;
					;;
MORE_HEADER0 :				;;
	JMP	FTB_LOOP		;;
					;;
					;;+++++++++++++++++++++++++++++++++
MODLO	:				;; STAGE the low byte of the MODIFIER
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_MOD		;;
	MOV	MOD_LOB,AL		;;
	MOV	cs:stage,MOD_HIBX	   ;;
	JMP	FTB_LOOP		;;
WORD_MOD :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:mod_word,AX		   ;;
	MOV	cs:stage,fonts_lobX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
MODHI	:				;; STAGE the high byte of the MODIFIER
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:mod_hib,AL		   ;;
	MOV	cs:stage,FONTS_LOBX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
FONTSLO :				;; STAGE the low byte of the FONTS
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_FONTS		;;
	MOV	cs:fonts_lob,AL 	   ;;
	MOV	cs:stage,FONTS_HIBX	   ;;
	JMP	FTB_LOOP		;;
WORD_FONTS :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:fonts_word,AX	   ;;
	MOV	cs:stage,FDLEN_LOBX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
FONTSHI :				;; STAGE the high byte of the FONTS
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:fonts_hib,AL 	   ;;
	MOV	cs:stage,FDLEN_LOBX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
FDLENLO :				;; the low byte of the FONT-LENGTH
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_FDLEN		;;
	MOV	cs:fdlen_lob,AL 	   ;;
	MOV	cs:stage,FDLEN_HIBX	   ;;
	JMP	FTB_LOOP		;;
WORD_FDLEN :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:pre_font_len,PRE_FONT_ND;;
	MOV	cs:fdlen_word,AX	   ;;
	AND	AX,AX			;;
	JZ	NO_DISP_PTR		;;
	CMP	cs:type_word,TYPE_DISPLAY  ;;
	JE	DISPLAY_TYPE1		;;
	CMP	cs:type_word,TYPE_PRINTER  ;;
	JE	PRINTER_TYPE1		;;
					;;
NO_DISP_PTR :				;;
	MOV	cs:stage,FOUNDX 	   ;; FSTAT is to be changed
	JMP	FTB_LOOP		;;
DISPLAY_TYPE1 : 			;;
	MOV	cs:stage,DISP_ROWSX	   ;;
	JMP	FTB_LOOP		;;
PRINTER_TYPE1 : 			;;
	MOV	cs:stage,PTRSELLOX	   ;;
	JMP	FTB_LOOP		;;
					;;
					;;+++++++++++++++++++++++++++++++++
FDLENHI :				;; STAGE the high byte of the F-LENGTH
	MOV	cs:pre_font_len,PRE_FONT_ND
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:fdlen_hib,AL 	   ;;
	MOV	AX,cs:fdlen_word	   ;;
	AND	AX,AX			;;
	JZ	NO_DISP_PTR2		;;
	CMP	cs:type_word,TYPE_DISPLAY  ;;
	JE	DISPLAY_TYPE2		;;
	CMP	cs:type_word,TYPE_PRINTER  ;;
	JE	PRINTER_TYPE2		;;
NO_DISP_PTR2:				;;
	MOV	cs:stage,FOUNDX 	   ;; FSTAT is to be changed
	JMP	FTB_LOOP		;;
DISPLAY_TYPE2 : 			;;
	MOV	cs:stage,DISP_ROWSX	   ;;
	JMP	FTB_LOOP		;;
PRINTER_TYPE2 : 			;;
	MOV	cs:stage,PTRSELLOX	   ;;
	JMP	FTB_LOOP		;;
					;;
					;;+++++++++++++++++++++++++++++++++
DSPROWS :				;; STAGE : get the rows
	XOR	AX,AX			;;
	MOV	cs:disp_rows,AL 	   ;;
	MOV	cs:disp_cols,AL 	   ;;
	MOV	cs:DISP_X,AL		   ;;
	MOV	cs:disp_y,AL		   ;;
	MOV	cs:count_word,AX	   ;;
					;;
	INC	cs:pre_font_len 	  ;;
	MOV	AX,FPKT 		;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:disp_rows,AL 	   ;;
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	JZ	NO_DISP_FONT3		;;
	MOV	cs:stage,disp_colsX	   ;;
	JMP	FTB_LOOP		;;
NO_DISP_FONT3 : 			;;
	MOV	cs:stage,FOUNDX 	   ;; FSTAT is to be changed
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
DSPCOLS :				;; STAGE : get the COLS
	INC	cs:pre_font_len 	  ;;
	MOV	AX,FPKT 		;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:disp_cols,AL 	   ;;
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	JZ	NO_DISP_FONT3		;;
	MOV	cs:stage,DISP_XX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
DSPX :					;; STAGE : get the aspect X
	INC	cs:pre_font_len 	  ;;
	MOV	AX,FPKT 		;;
	INC	SI			;;
	DEC	CX			;;
	MOV	DISP_X,AL		;;
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	JZ	NO_DISP_FONT3		;;
	MOV	cs:stage,DISP_YX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
DSPY :					;; STAGE : get the aspect Y
	INC	cs:pre_font_len 	  ;;
	MOV	AX,FPKT 		;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:disp_y,AL		   ;;
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	JZ	NO_DISP_FONT3		;;
	MOV	cs:stage,COUNT_LOBX	   ;;
	JMP	FTB_LOOP		;;
					;;
					;;+++++++++++++++++++++++++++++++++
DSPCOUNTLO :				;; the low byte of the FONT-LENGTH
	INC	cs:pre_font_len 	  ;;
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	PUSH	AX			;; check if length is enough
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	POP	AX			;;
	JNZ	A_WORD_COUNT		;;
	JMP	NO_DISP_FONT3		;;
A_WORD_COUNT :				;;
	AND	CX,CX			;;
	JNZ	WORD_COUNT		;;
	MOV	cs:count_lob,AL 	   ;;
	MOV	cs:stage,COUNT_HIBX	   ;;
	JMP	FTB_LOOP		;;
WORD_COUNT :				;;
	INC	cs:pre_font_len 	  ;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:count_word,AX	   ;;
;	MOV	cs:pre_font_len,PRE_FONT_D;
					;;
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	MOV	cs:stage,FOUNDX 	   ;; FSTAT is to be changed
	JMP	FTB_LOOP		;;
					;;
					;;+++++++++++++++++++++++++++++++++
DSPCOUNTHI :				;; STAGE the high byte of the F-LENGTH
	INC	cs:pre_font_len 	  ;;
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:count_hib,AL 	   ;;
;	MOV	cs:pre_font_len,PRE_FONT_D;
					;;
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	MOV	cs:stage,FOUNDX 	   ;; FSTAT is to be changed
	JMP	FTB_LOOP		;;
					;;
					;;
					;;+++++++++++++++++++++++++++++++++
PTRSELLO :				;; the low byte of the SELECTION_TYPE
	INC	cs:pre_font_len 	  ;;
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	PUSH	AX			;; check if length is enough
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	POP	AX			;;
	JNZ	A_WORD_SEL		;;
	JMP	NO_PTR_FONT3		;;
A_WORD_SEL :				;;
	AND	CX,CX			;;
	JNZ	WORD_SEL		;;
	MOV	cs:ptr_selob,AL 	   ;;
	MOV	cs:stage,PTRSELHIX	   ;;
	JMP	FTB_LOOP		;;
WORD_SEL :				;;
	INC	cs:pre_font_len 	   ;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:ptr_sel_word,AX	   ;;
					;;
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
					;;
	CMP	cs:ptr_sel_word,0	   ;;
	JNE	PTR_SEL_NOT0		;;
					;;
					;;
	MOV	cs:stage,FOUNDX 	   ;; FSTAT is to be changed
	JMP	FTB_LOOP		;;
					;;
PTR_SEL_NOT0 :				;;
	MOV	cs:stage,PTRLENLOX	   ;;
	JMP	FTB_LOOP		;;
					;;
					;;+++++++++++++++++++++++++++++++++
PTRSELHI:				;; STAGE the high byte of SELECT_TYPE
	INC	cs:pre_font_len 	  ;;
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:ptr_sehib,AL 	   ;;
					;;
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
					;;
	CMP	cs:ptr_sel_word,0	   ;;
	JNE	PTR_SEL_NOT0		;;
					;;
					;;
	MOV	cs:stage,FOUNDX 	   ;; FSTAT is to be changed
	JMP	FTB_LOOP		;;
					;;
					;;
					;;+++++++++++++++++++++++++++++++++
PTRLENLO :				;; the low byte of SELECTION_LENGTH
	INC	cs:pre_font_len 	  ;;
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	PUSH	AX			;; check if length is enough
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	POP	AX			;;
	JNZ	A_WORD_SELEN		;;
	JMP	NO_PTR_FONT3		;;
A_WORD_SELEN :				;;
	AND	CX,CX			;;
	JNZ	WORD_SELEN		;;
	MOV	cs:ptr_lnlob,AL 	   ;;
	MOV	cs:stage,PTRLENHIX	   ;;
	JMP	FTB_LOOP		;;
WORD_SELEN :				;;
	INC	cs:pre_font_len 	   ;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:ptr_len_word,AX	   ;;
					;;
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	MOV	cs:stage,FOUNDX 	   ;; FSTAT is to be changed
	JMP	FTB_LOOP		;;
					;;
					;;+++++++++++++++++++++++++++++++++
PTRLENHI :				;; STAGE the high byte of SELECT_LENGTH
	INC	cs:pre_font_len 	  ;;
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:ptr_lnhib,AL 	   ;;
					;;
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	MOV	cs:stage,FOUNDX 	   ;; FSTAT is to be changed
	JMP	FTB_LOOP		;;
					;;
NO_PTR_FONT3 :				;;
	MOV	cs:stage,FOUNDX 	   ;; FSTAT is to be changed
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
PASS	:				;; STAGE - PASS DUMMY BYTES
					;;
	PUSH	DX			;;
	PUSH	ES			;;
	PUSH	DI			;;
					;;
	PUSH	CS			;;
	POP	ES			;;
	MOV	DI,OFFSET PASS_BRK	;;
	MOV	DX,PASS_INDX		;;
	MOV	AX,cs:pass_cnt		   ;;
					;;
NEXT_BRK:				;; find the next pass-break
	CMP	AX,ES:[DI]		;;
					;;
	JB	UPTO_BRK		;;
					;;
	DEC	DX			;;
	JZ	PASS_ERR		;;
	INC	DI			;;
	INC	DI			;;
	JMP	NEXT_BRK		;;
					;;
UPTO_BRK :				;; next break point found
	MOV	DX,ES:[DI]		;;
	SUB	DX,AX			;; bytes to be skipped
	CMP	CX,DX			;; all to be skipped ?
	JAE	PASS_ALL		;;
					;;
	ADD	cs:pass_cnt,CX		   ;;
	ADD	SI,CX			;;
	SUB	CX,CX			;;
	JMP	PASS_END		;;
					;;
PASS_ALL :				;;
	ADD	cs:pass_cnt,DX		   ;;
	ADD	SI,DX			;;
	SUB	CX,DX			;;
					;;
	MOV	AX,cs:pass_postx	   ;;
	MOV	cs:stage,AX		   ;;
					;;
;	cmp	ax,passx		;; is the next stage a pass-stage ?
;	jne	not_passx		;;
;	mov	ax,pass_postxx		;;
;	mov	pass_postx,ax		;;
;	mov	pass_postxx,stage_max	;; can support only 2 consecutive pass
					;;
;not_passx :				 ;;
					;;
	JMP	PASS_END		;;
					;;
PASS_ERR :				;; DEVICE ERROR, wrong stage
	POP	DI			;;
	POP	ES			;;
	POP	DX			;;
	MOV	FTP.FTB_STATUS,STAT_DEVERR
	SUB	CX,CX			;; ignore all the input string
	JMP	PASS_DONE		;;
					;;
PASS_END :				;;
	POP	DI			;;
	POP	ES			;;
	POP	DX			;;
PASS_DONE :				;;
	JMP	FTB_LOOP		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
FTB_LPEND :				;;
					;;
	CMP	cs:stage,FOUNDX 	   ;;
	JNE	NOT_FOUNDX		;;
					;;
	CALL	FOUND_DO		;;
					;;
NOT_FOUNDX :				;;
					;;
	POP	CX			;; STACK -1
					;;
FP_RET	:				;;
	POP	SI			;; restore registers
	POP	DI			;;
	POP	DX			;;
	POP	CX			;;
	POP	BX			;;
	POP	AX			;;
	POP	ES			;;
	POP	DS			;;
					;;
	RET				;;
FONT_PARSER ENDP			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CSEG	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\printer\cpspm10.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
PAGE	,132
TITLE	DOS - Code Page Switching - Printer Device Driver
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  FILENAME:		CPS Printer Device Driver Main Code
;;  MODULE NAME:
;;  TYPE:		Assemble file  (resident code)
;;  LINK PROCEDURE:	Link CPSPMnn+CPSFONT+CPSPInn into .EXE format. CPSPM01
;;			must be first.	CPSPInn must be last.  Everything
;;			before CPSPInn will be resident.
;;  INCLUDE FILES:
;;			CPSPEQU.INC
;;
;;
;;  This routine is structured as a DOS Device Driver.
;;  IE it is installed via the CONFIG.SYS command:
;;
;;  The following device commands are supported:
;;
;;  0 - INIT
;;  --------
;;
;;  8 - OUTPUT
;;  9 - OUTPUT
;;  --------
;;  Supported in between Designate-start and the Designate_end commands.
;;
;;
;;  12 - IOCTL OUTPUT
;;  -----------------
;;  CPS Function request :  Major function =	05	-- printer device
;;			    Minor functions =	4CH	-- designate start
;;						4DH	-- designate end
;;						4AH	-- invoke
;;						6AH	-- query-invoked
;;						6BH	-- query-list
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;*Modification history ********************************************************
;AN001; p2685  Long delay on CHCP before failure message	   12/10/87 J.K.
;******************************************************************************
					;;
INCLUDE CPSPEQU.INC			;;
					;;
PUBLIC	PRINTER_DESC_NUM		;;
PUBLIC	PRINTER_DESC_TBL		;;
PUBLIC	INIT_CHK,TABLE,DEVICE_NUM	;; WGR						 ;AN000;
PUBLIC	INVOKE				;; WGR						 ;AN000;
PUBLIC	BUF0,BUF1,BUF2,BUF3		;; WGR						 ;AN000;
PUBLIC	HARD_SL1,RAM_SL1		;;
PUBLIC	HARD_SL2,RAM_SL2		;;
PUBLIC	HARD_SL3,RAM_SL3		;;
PUBLIC	HARD_SL4,RAM_SL4		;;
PUBLIC	RESERVED1,RESERVED2		;;
					;;
EXTRN	RESIDENT_END:WORD		;;
EXTRN	STACK_ALLOCATED:WORD		;;
EXTRN	FONT_PARSER:NEAR,FTABLE:WORD	;;
EXTRN	INIT:NEAR			;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;;
CSEG	SEGMENT PARA PUBLIC 'CODE'      ;;
	ASSUME	CS:CSEG 		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  ************************************
;;  **				      **
;;  **	     Resident Code	      **
;;  **				      **
;;  ************************************
;;
;;
;; DEVICE HEADER - must be at offset zero within device driver
;;		   (DHS is defined according to this structure)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
DEV_HDR0: DW	OFFSET DEV_HDR1 	;; becomes pointer to next device header
	DW	0			;; must be zero for no link
	DW	0e040H			;; attribute (Char device)
					;; supports IOCTL calls
	DW	OFFSET STRATEGY0	;; pointer to device "strategy" routine
	DW	OFFSET INTERRUPT0	;; pointer to device "interrupt handler"
DEV_NAME0: DB	'PRN     '              ;; device name( length : NAME_LEN)
					;;
DEV_HDR1: DW	OFFSET DEV_HDR2 	;; becomes pointer to next device header
	DW	0			;; must be zero for no link
	DW	0e040H			;; attribute (Char device)
					;; supports IOCTL calls
	DW	OFFSET STRATEGY1	;; pointer to device "strategy" routine
	DW	OFFSET INTERRUPT1	;; pointer to device "interrupt handler"
DEV_NAME1: DB	'LPT1    '              ;; device name( length : NAME_LEN)
					;;
DEV_HDR2: DW	OFFSET DEV_HDR3 	;; becomes pointer to next device header
	DW	0			;; must be zero for no link
	DW	0e040H			;; attribute (Char device)
					;; supports IOCTL calls
	DW	OFFSET STRATEGY2	;; pointer to device "strategy" routine
	DW	OFFSET INTERRUPT2	;; pointer to device "interrupt handler"
DEV_NAME2: DB	'LPT2    '              ;; device name( length : NAME_LEN)
					;;
					;;
DEV_HDR3: DD	-1			;; becomes pointer to next device header
	DW	0e040H			;; attribute (Char device)
					;; supports IOCTL calls
	DW	OFFSET STRATEGY3	;; pointer to device "strategy" routine
	DW	OFFSET INTERRUPT3	;; pointer to device "interrupt handler"
DEV_NAME3: DB	'LPT3    '              ;; device name( length : NAME_LEN)
					;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; *****************************
;; **  Resident Data Areas    **
;; *****************************
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PRN/LPTn  printer data based on BUF
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
INIT_CHK DW	0			;; internal flag : error loc. in INIT
					;;
BUF0:	BUF_DATA <,,,,,,,,,,>		;; PRN
					;;
BUF1:	BUF_DATA <,,,,,,,,,,>		;; LPT1
					;;
BUF2:	BUF_DATA <,,,,,,,,,,>		;; LPT2
					;;
BUF3:	BUF_DATA <,,,,,,,,,,>		;; LPT3
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Hard/RAM slots table in the order of DEVICE parameters
;
;   number of entries in all HARD_SLn is determined by the max. {HSLOTS}
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
HARD_SL1 :	SLTS <,>		;; 1st hardware slots
HARD_SL1B:	SLTS <,>		;;
HARD_SL1C:	SLTS <,>		;;
HARD_SL1D:	SLTS <,>		;;
HARD_SL1E:	SLTS <,>		;;
HARD_SL1F:	SLTS <,>		;;
HARD_SL1G:	SLTS <,>		;;
HARD_SL1H:	SLTS <,>		;;
HARD_SL1I:	SLTS <,>		;;
HARD_SL1J:	SLTS <,>		;;
HARD_SL1K:	SLTS <,>		;;
HARD_SL1L:	SLTS <,>		;;
HARD_SL1M:	SLTS <,>		;; -- max. no. of code pages allowed
;;upto	hardsl_max + 1			;;
					;;
HARD_SL2 :	SLTS <,>		;; 2nd hardware slots
HARD_SL2B:	SLTS <,>		;;
HARD_SL2C:	SLTS <,>		;;
HARD_SL2D:	SLTS <,>		;;
HARD_SL2E:	SLTS <,>		;;
HARD_SL2F:	SLTS <,>		;;
HARD_SL2G:	SLTS <,>		;;
HARD_SL2H:	SLTS <,>		;;
HARD_SL2I:	SLTS <,>		;;
HARD_SL2J:	SLTS <,>		;;
HARD_SL2K:	SLTS <,>		;;
HARD_SL2L:	SLTS <,>		;;
HARD_SL2M:	SLTS <,>		;; -- max. no. of code pages allowed
;;upto	hardsl_max + 1			;;
					;;
HARD_SL3 :	SLTS <,>		;; 3rd hardware slots
HARD_SL3B:	SLTS <,>		;;
HARD_SL3C:	SLTS <,>		;;
HARD_SL3D:	SLTS <,>		;;
HARD_SL3E:	SLTS <,>		;;
HARD_SL3F:	SLTS <,>		;;
HARD_SL3G:	SLTS <,>		;;
HARD_SL3H:	SLTS <,>		;;
HARD_SL3I:	SLTS <,>		;;
HARD_SL3J:	SLTS <,>		;;
HARD_SL3K:	SLTS <,>		;;
HARD_SL3L:	SLTS <,>		;;
HARD_SL3M:	SLTS <,>		;; -- max. no. of code pages allowed
;;upto	hardsl_max + 1			;;
					;;
HARD_SL4 :	SLTS <,>		;; 4TH hardware slots
HARD_SL4B:	SLTS <,>		;;
HARD_SL4C:	SLTS <,>		;;
HARD_SL4D:	SLTS <,>		;;
HARD_SL4E:	SLTS <,>		;;
HARD_SL4F:	SLTS <,>		;;
HARD_SL4G:	SLTS <,>		;;
HARD_SL4H:	SLTS <,>		;;
HARD_SL4I:	SLTS <,>		;;
HARD_SL4J:	SLTS <,>		;;
HARD_SL4K:	SLTS <,>		;;
HARD_SL4L:	SLTS <,>		;;
HARD_SL4M:	SLTS <,>		;; -- max. no. of code pages allowed
;;upto	hardsl_max + 1			;;
					;;
					;;
RAM_SL1 :	SLTS <,>		;; 1st ram slots
RAM_SL1B:	SLTS  <,>		;; NOTE : must be only FOUR bytes for
RAM_SL1C:	SLTS  <,>		;;	  codepage positioning
RAM_SL1D:	SLTS  <,>		;;	  calculation as compared
RAM_SL1E:	SLTS  <,>		;;	  with each entry in FTDL_OFF
RAM_SL1F:	SLTS  <,>		;;
RAM_SL1G:	SLTS  <,>		;;
RAM_SL1H:	SLTS  <,>		;;
RAM_SL1I:	SLTS  <,>		;;
RAM_SL1J:	SLTS  <,>		;;
RAM_SL1K:	SLTS  <,>		;;
RAM_SL1L:	SLTS  <,>		;; -- max. no. of code pages allowed
;;upto	ramsl_max,			;;
					;;
RAM_SL2 :	SLTS <,>		;; 2nd ram slots
RAM_SL2B:	SLTS  <,>		;;
RAM_SL2C:	SLTS  <,>		;;
RAM_SL2D:	SLTS  <,>		;;
RAM_SL2E:	SLTS  <,>		;;
RAM_SL2F:	SLTS  <,>		;;
RAM_SL2G:	SLTS  <,>		;;
RAM_SL2H:	SLTS  <,>		;;
RAM_SL2I:	SLTS  <,>		;;
RAM_SL2J:	SLTS  <,>		;;
RAM_SL2K:	SLTS  <,>		;;
RAM_SL2L:	SLTS  <,>		;; -- max. no. of code pages allowed
;;upto	ramsl_max,			;;
					;;
RAM_SL3 :	SLTS <,>		;; 3rd ram slots
RAM_SL3B:	SLTS  <,>		;;
RAM_SL3C:	SLTS  <,>		;;
RAM_SL3D:	SLTS  <,>		;;
RAM_SL3E:	SLTS  <,>		;;
RAM_SL3F:	SLTS  <,>		;;
RAM_SL3G:	SLTS  <,>		;;
RAM_SL3H:	SLTS  <,>		;;
RAM_SL3I:	SLTS  <,>		;;
RAM_SL3J:	SLTS  <,>		;;
RAM_SL3K:	SLTS  <,>		;;
RAM_SL3L:	SLTS  <,>		;; -- max. no. of code pages allowed
;;upto	ramsl_max,			;;
					;;
RAM_SL4 :	SLTS <,>		;; 4th ram slots
RAM_SL4B:	SLTS  <,>		;;
RAM_SL4C:	SLTS  <,>		;;
RAM_SL4D:	SLTS  <,>		;;
RAM_SL4E:	SLTS  <,>		;;
RAM_SL4F:	SLTS  <,>		;;
RAM_SL4G:	SLTS  <,>		;;
RAM_SL4H:	SLTS  <,>		;;
RAM_SL4I:	SLTS  <,>		;;
RAM_SL4J:	SLTS  <,>		;;
RAM_SL4K:	SLTS  <,>		;;
RAM_SL4L:	SLTS  <,>		;; -- max. no. of code pages allowed
;;upto	ramsl_max,			;;
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; hard/RAM buffered slots on codepages
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
HBUF_SL1 LABEL	WORD			;; hardware slots' buffer for LPT1/PRN
	DW	0FFFFH			;; ---- only for CART-SLOTS
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
;;upto	hardsl_max+1, there are as many HARD_SLn
					;;
HBUF_SL2 LABEL	WORD			;; hardware slots' buffer for LPT2
	DW	0FFFFH			;; ---- only for CART-SLOTS
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
;;upto	hardsl_max+1, there are as many HARD_SLn
					;;
HBUF_SL3 LABEL	WORD			;; hardware slots' buffer for LPT3
	DW	0FFFFH			;; ---- only for CART-SLOTS
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
;;upto	hardsl_max+1, there are as many HARD_SLn
					;;
					;;
RBUF_SL1 LABEL	WORD			;; ram slots' buffer for LPT1/PRN
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
;;upto ramsl_max, there are as many RAM_SLn
					;;
RBUF_SL2 LABEL	WORD			;; ram slots' buffer for LPT2
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
;;upto ramsl_max, there are as many RAM_SLn
					;;
RBUF_SL3 LABEL	WORD			;; ram slots' buffer for LPT3
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
	DW	0FFFFH			;;
;;upto ramsl_max, there are as many RAM_SLn
					;;
FTDL_OFF1 LABEL WORD			;; offset of FTSTART for PRN/LPT1
	DW	0			;; NOTE : must be only two bytes for
	DW	0			;;	  codepage positioning
	DW	0			;;	  calculation as compared
	DW	0			;;	  with each entry in RAM_SLOT
	DW	0			;;	  or CART_SLOT
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
;;upto the max. of {ramsl_max,hardsl_max}
					;;
FTDL_OFF2 LABEL WORD			;; offset of FTSTART for LPT2
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
;;upto the max. of {ramsl_max,hardsl_max}
					;;
FTDL_OFF3 LABEL WORD			;; offset of FTSTART for LPT3
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
	DW	0			;;
;;upto the max. of {ramsl_max,hardsl_max}
					;;
					;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	Printer Description Tables
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
ESC_CHAR	EQU	27		;;
					;;
db	'PRINTER_DESC'                  ;;
					;;
PRINTER_DESC_NUM DW 3			;; number of PRINTER_DESCn
					;;
PRINTER_DESC_TBL LABEL WORD		;;
	DW	OFFSET(PRINTER_DESC1)	;;
	DW	OFFSET(PRINTER_DESC2)	;;
	DW	OFFSET(PRINTER_DESC3)	;;
	DW	OFFSET(PRINTER_DESC4)	;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	Printer Description Table for Proprinter (4201)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRINTER_DESC1 : 			;;
					;;
	PDSH	<,'4201    ',,,0,212,1,1,1> ;; followed by the rest in PDS
					;; CLASS  = 0
					;; FTSZPA = 212 ==> 212 x 16=3008 bytes
					;;		    of font buffer
					;; HSLOTS  = 1 (check CTL4201_B)
					;; HWCPMIN = 1
					;; RSLOTS  = 1 (check CTL4201_B)
					;;
	DW	OFFSET(CTL4201_H)
	DW	OFFSET(CTL4201_R)
	DW	OFFSET(CTL4201_B)
					;; (CTL_MAX = 32)
					;; (32 bytes for each control)
					;; (MUST BE ADJACENT...no blanks bet.:)
CTL4201_H :	DB  5,ESC_CHAR,'I',0,ESC_CHAR,"6" ;;  selection control 1
CTL4201_R :	DB  5,ESC_CHAR,'I',4,ESC_CHAR,"6" ;;  selection control 2
		db  26	dup (0) 	;;  for CTL4201_H
		db  26	dup (0) 	;;  for CTL4201_R
					;;
CTL4201_B	DB  CTL_MAX	DUP (0) ;; max. two selection
		DB  CTL_MAX	DUP (0) ;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	Printer Description Table for 5202
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
PRINTER_DESC2 : 			;;
	PDSH	<,'5202    ',,,1,2,2,1,0> ;; followed by the rest in PDS
					;; CLASS  = 1 (font buffers allowed
					;;	       if there is cart-slot)
					;; FTSZPA = 2 ==> 2 x 16 = 32 bytes
					;;		    of font buffer
					;; HSLOTS  = 2 (check CTL5202_B)
					;; HWCPMIN = 1
					;; RSLOTS  = 0 (check CTL5202_B)
					;;
	DW	OFFSET(CTL5202_H)
	DW	OFFSET(CTL5202_R)
	DW	OFFSET(CTL5202_B)
					;;
					;; (CTL_MAX = 32)
					;; (SEE CTL5202_OFFS)
					;; (32 bytes for each control)
CTL5202_H :	DB  12,ESC_CHAR,91,84,5,0,00,00,0FFH,0FFH,00   ;; selection control 1
		 dB  ESC_CHAR,"6"             ;;
		DB  12,ESC_CHAR,91,84,5,0,00,00,0FFH,0FFH,00   ;; selection control 2
		 dB  ESC_CHAR,"6"             ;;
		db  19 dup (0)		;;  for CTL5202_H selection 1
		db  19 dup (0)		;;  for CTL5202_H selection 2
CTL5202_R :	DB  0			;;
					;;
CTL5202_B	DB  CTL_MAX	DUP (0) ;; max. two selection
		DB  CTL_MAX	DUP (0) ;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	Printer Description Table for RESERVED PRINTER (res1)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRINTER_DESC3 : 			;;
					;;
	PDSH	<,'4208    ',,,1,2,2,1,0> ;; followed by the rest in PDS
					;; CLASS  = 1
					;; FTSZPA = 2
					;; HSLOTS  = 2
					;; HWCPMIN = 1
					;; RSLOTS  = 0
					;;
	DW	OFFSET(CTL4208_H)
	DW	OFFSET(CTL4208_R)
	DW	OFFSET(CTL4208_B)
					;; (CTL_MAX = 32)
					;; (32 bytes for each control)
					;; (MUST BE ADJACENT...no blanks bet.:)
CTL4208_H :	DB  0Bh,ESC_CHAR,49h,0Ah    ;;	selection control 1
		DB  ESC_CHAR,49h,03
		DB  ESC_CHAR,49h,02
		DB  ESC_CHAR,36h
		db  20	dup (0)
CTL4208_R :	DB  0Bh,ESC_CHAR,49h,0Eh    ;;	selection control 2
		DB  ESC_CHAR,49h,7
		DB  ESC_CHAR,49h,6
		DB  ESC_CHAR,36h
		db  20	dup (0) 	;;  for CTLres1_H and CTRLres1_R
					;;
CTL4208_B	DB  CTL_MAX	DUP (0) ;; max. two selection
		DB  CTL_MAX	DUP (0) ;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	Printer Description Table for RESERVED PRINTER (res2)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRINTER_DESC4 : 			;;
					;;
	PDSH	<,'nnnnnnnn',,,0,0,1,1,1> ;; followed by the rest in PDS
					;; CLASS  = 0
					;; FTSZPA = 0
					;; HSLOTS  = 1
					;; HWCPMIN = 1
					;; RSLOTS  = 1
					;;
	DW	OFFSET(CTLres2_H)
	DW	OFFSET(CTLres2_R)
	DW	OFFSET(CTLres2_B)
					;; (CTL_MAX = 32)
					;; (32 bytes for each control)
					;; (MUST BE ADJACENT...no blanks bet.:)
CTLres2_H :	DB  0			;;  selection control 1
CTLres2_R :	DB  32	dup (0) 	;;  selection control 2
		db  32	dup (0) 	;;  for CTLres2_H and CTRLres2_R
					;;
CTLres2_B	DB  CTL_MAX	DUP (0) ;; max. two selection
		DB  CTL_MAX	DUP (0) ;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;;
TEMP_SI 	DW	?		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; The request header for IOCTL call
;; to the Normal device driver
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
REQ_NORM1 GIH	<,,,,,> 		;; for LPT1/PRN
	  GB2S	<,>			;;
REQ_NORM2 GIH	<,,,,,> 		;; for LPT2
	  GB2S	<,>			;;
REQ_NORM3 GIH	<,,,,,> 		;; for LPT3
	  GB2S	<,>			;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;
;;
;;   PARSER'S TABLES
;;
;;	-- TABLE  is the first table of the results of the parsing.
;;	   The first word (number of devices) will be set to 0 if
;;	   syntax error is detected in the DEVICE command line.
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; TABLE STRUCTURE FOR RETURNING VALUES TO THE INIT MODULE	    WGR
;  (ADAPTED FROM VERSION 1.0 DISPLAY.SYS)			    WGR
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TABLE	       LABEL	BYTE		   ; table header				 ;AN000;
DEVICE_NUM     DW	ZERO		   ; initialized to zero devices		 ;AN000;
	       DW	TABLE1_1	   ; pointer to table 2 for device 1		 ;AN000;
	       DW	TABLE2_1	   ; pointer to table 2 for device 2		 ;AN000;
	       DW	TABLE3_1	   ; pointer to table 2 for device 3		 ;AN000;
	       DW	TABLE4_1	   ; pointer to table 2 for device 4		 ;AN000;
											 ;AN000;
TABLE1_1       LABEL	WORD								 ;AN000;
	       DW	FOUR		   ; 4 pointer follow				 ;AN000;
	       DW	TABLE1_2	   ; pointer to table 3 (device name)		 ;AN000;
	       DW	TABLE1_3	   ; pointer to table 4 (device id)		 ;AN000;
	       DW	TABLE1_4	   ; pointer to table 5 (hwcp's)                 ;AN000;
	       DW	TABLE1_5	   ; pointer to table 6 (num desg's and fonts)   ;AN000;
	       DW	-1		   ; reserved					 ;AN000;
											 ;AN000;
TABLE1_2       LABEL	WORD		   ; device name (ie. PRN)			 ;AN000;
	       DW	ZERO		   ; length					 ;AN000;
	       DB	"        "         ; value                                       ;AN000;
											 ;AN000;
TABLE1_3       LABEL	WORD		   ; device id. (eg. 4201,5202..)		 ;AN000;
	       DW	ZERO		   ; length					 ;AN000;
	       DB	"        "         ; value                                       ;AN000;
											 ;AN000;
TABLE1_4       LABEL	WORD		   ; hardware code pages (10 max.)		 ;AN000;
	       DW	ZERO		   ; number					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
											 ;AN000;
TABLE1_5       LABEL	WORD		   ; Designates and fonts			 ;AN000;
	       DW	ZERO		   ; values given (0 - 2 valid) 		 ;AN000;
	       DW	-1		   ; n value					 ;AN000;
	       DW	-1		   ; m value					 ;AN000;
											 ;AN000;
TABLE2_1       LABEL	WORD								 ;AN000;
	       DW	FOUR		   ; 4 pointer follow				 ;AN000;
	       DW	TABLE2_2	   ; pointer to table 3 (device name)		 ;AN000;
	       DW	TABLE2_3	   ; pointer to table 4 (device id)		 ;AN000;
	       DW	TABLE2_4	   ; pointer to table 5 (hwcp's)                 ;AN000;
	       DW	TABLE2_5	   ; pointer to table 6 (num desg's and fonts)   ;AN000;
	       DW	-1		   ; reserved					 ;AN000;
											 ;AN000;
TABLE2_2       LABEL	WORD		   ; device name (ie. PRN)			 ;AN000;
	       DW	ZERO		   ; length					 ;AN000;
	       DB	"        "         ; value                                       ;AN000;
											 ;AN000;
TABLE2_3       LABEL	WORD		   ; device id. (eg. 4201,5202..)		 ;AN000;
	       DW	ZERO		   ; length					 ;AN000;
	       DB	"        "         ; value                                       ;AN000;
											 ;AN000;
TABLE2_4       LABEL	WORD		   ; hardware code pages (10 max.)		 ;AN000;
	       DW	ZERO		   ; number					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
											 ;AN000;
TABLE2_5       LABEL	WORD		   ; Designates and fonts			 ;AN000;
	       DW	ZERO		   ; values given (0 - 2 valid) 		 ;AN000;
	       DW	-1		   ; n value					 ;AN000;
	       DW	-1		   ; m value					 ;AN000;
											 ;AN000;
TABLE3_1       LABEL	WORD								 ;AN000;
	       DW	FOUR		   ; 4 pointer follow				 ;AN000;
	       DW	TABLE3_2	   ; pointer to table 3 (device name)		 ;AN000;
	       DW	TABLE3_3	   ; pointer to table 4 (device id)		 ;AN000;
	       DW	TABLE3_4	   ; pointer to table 5 (hwcp's)                 ;AN000;
	       DW	TABLE3_5	   ; pointer to table 6 (num desg's and fonts)   ;AN000;
	       DW	-1		   ; reserved					 ;AN000;
											 ;AN000;
TABLE3_2       LABEL	WORD		   ; device name (ie. PRN)			 ;AN000;
	       DW	ZERO		   ; length					 ;AN000;
	       DB	"        "         ; value                                       ;AN000;
											 ;AN000;
TABLE3_3       LABEL	WORD		   ; device id. (eg. 4201,5202..)		 ;AN000;
	       DW	ZERO		   ; length					 ;AN000;
	       DB	"        "         ; value                                       ;AN000;
											 ;AN000;
TABLE3_4       LABEL	WORD		   ; hardware code pages (10 max.)		 ;AN000;
	       DW	ZERO		   ; number					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
											 ;AN000;
TABLE3_5       LABEL	WORD		   ; Designates and fonts			 ;AN000;
	       DW	ZERO		   ; values given (0 - 2 valid) 		 ;AN000;
	       DW	0		   ; n value					 ;AN000;
	       DW	0		   ; m value					 ;AN000;
											 ;AN000;
TABLE4_1       LABEL	WORD								 ;AN000;
	       DW	FOUR		   ; 4 pointer follow				 ;AN000;
	       DW	TABLE4_2	   ; pointer to table 3 (device name)		 ;AN000;
	       DW	TABLE4_3	   ; pointer to table 4 (device id)		 ;AN000;
	       DW	TABLE4_4	   ; pointer to table 5 (hwcp's)                 ;AN000;
	       DW	TABLE4_5	   ; pointer to table 6 (num desg's and fonts)   ;AN000;
	       DW	-1		   ; reserved					 ;AN000;
											 ;AN000;
TABLE4_2       LABEL	WORD		   ; device name (ie. PRN)			 ;AN000;
	       DW	ZERO		   ; length					 ;AN000;
	       DB	"        "         ; value                                       ;AN000;
											 ;AN000;
TABLE4_3       LABEL	WORD		   ; device id. (eg. 4201,5202..)		 ;AN000;
	       DW	ZERO		   ; length					 ;AN000;
	       DB	"        "         ; value                                       ;AN000;
											 ;AN000;
TABLE4_4       LABEL	WORD		   ; hardware code pages (10 max.)		 ;AN000;
	       DW	ZERO		   ; number					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
	       DW	-1		   ; value					 ;AN000;
											 ;AN000;
TABLE4_5       LABEL	WORD		   ; Designates and fonts			 ;AN000;
	       DW	ZERO		   ; values given (0 - 2 valid) 		 ;AN000;
	       DW	0		   ; n value					 ;AN000;
	       DW	0		   ; m value					 ;AN000;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
reserved1 DW	?			;; reserved for debugging used
reserved2 dw	?			;;
					;;
;;;;;;;;ASSUME	DS:NOTHING		;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PRN  Device "strategy" entry point
;;
;;	Retain the Request Header address for use by Interrupt routine
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
STRATEGY0 PROC	FAR			;;
	PUSH	BX			;;
	PUSH	BX			;;
	LEA	BX, BUF0		;; BUF = BUF0  CS:[BX]
	POP	buf.RH_PTRO		;; offset of request header
	MOV	buf.RH_PTRS,ES		;; segment
	POP	BX			;;
	RET				;;
STRATEGY0 ENDP				;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	LPT1 Device "strategy" entry point
;;
;;	Retain the Request Header address for use by Interrupt routine
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
STRATEGY1 PROC	FAR			;;
	PUSH	BX			;;
	PUSH	BX			;;
	LEA	BX, BUF1		;; BUF = BUF1  CS:[BX]
	POP	buf.RH_PTRO		;; offset of request header
	MOV	buf.RH_PTRS,ES		;; segment
	POP	BX			;;
	RET				;;
STRATEGY1 ENDP				;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	LPT2 Device "strategy" entry point
;;
;;	Retain the Request Header address for use by Interrupt routine
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
STRATEGY2 PROC	FAR			;;
	PUSH	BX			;;
	PUSH	BX			;;
	LEA	BX, BUF2		;; BUF = BUF2  CS:[BX]
	POP	buf.RH_PTRO		;; offset of request header
	MOV	buf.RH_PTRS,ES		;; segment
	POP	BX			;;
	RET				;;
STRATEGY2 ENDP				;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	LPT3 Device "strategy" entry point
;;
;;	Retain the Request Header address for use by Interrupt routine
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
STRATEGY3 PROC	FAR			;;
	PUSH	BX			;;
	PUSH	BX			;;
	LEA	BX, BUF3		;; BUF = BUF3  CS:[BX]
	POP	buf.RH_PTRO		;; offset of request header
	MOV	buf.RH_PTRS,ES		;; segment
	POP	BX			;;
	RET				;;
STRATEGY3 ENDP				;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	Table of command / functions supported by LPTn
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; CMD_CODES code supported by LPTn
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CMD_CODES LABEL BYTE			;;
	DB	CMD_INI 		;;  Initialization
	DB	CMD_WRT 		;;  output
	DB	09			;;  output
	DB	12			;;  output
CMD_INDX EQU	($-CMD_CODES)		;;  number of entries in CMD_CODES
					;;
					;;  Write (CMD_WRT) has exceptional
					;;  support by LPTn
					;;
					;;  Generic IOCTL (CMD_GIO) leads to
					;;  GIO_CODES
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; GIO_CODES code supported by LPTn
					;;   -- command = CMD_GIO and
					;;	major function = MAF_PTR
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GIO_CODES LABEL BYTE			;; minor GIO functions supported :
	DB	MIF_DST 		;; - designate start
	DB	MIF_DEN 		;; - designate end
	DB	MIF_IVK 		;; - invoke
	DB	MIF_QIV 		;; - query-invoked
	DB	MIF_QLS 		;; - query-list
GIO_INDX EQU	($-GIO_CODES)		;;  number of entries in GIO_CODES
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; Cases supported by LPTn
					;; -- first section matched with
					;;    CMD_CODES upto CMD_INDX
					;;
					;; -- 2nd section matched with
					;;    GIO_CODES for GIO_INDEX more
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CASES	LABEL	WORD			;;  in CMD_CODES order
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
	DW	OFFSET INIT		;;  0 - Initialization
	DW	OFFSET WRITE		;;
	DW	OFFSET WRITE		;;
	DW	OFFSET WRITE		;;
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;  in GIO_CODES order
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
	DW	OFFSET DESIGNATE_START	;;
	DW	OFFSET DESIGNATE_END	;;
	DW	OFFSET INVOKE		;;
	DW	OFFSET Q_INVOKED	;;
	DW	OFFSET Q_LIST		;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	Memory Allocation
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;;
					;;
MEM_REQUEST  DW    -1			;; flag used for first time memory
					;; allocation for each device
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; PRN	Device "interrupt" entry point
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
INTERRUPT0 PROC FAR			;; device interrupt entry point
					;;
	PUSH	DS			;; save all registers Revised
	PUSH	ES			;;
	PUSH	AX			;;
	PUSH	BX			;;
	PUSH	CX			;;
	PUSH	DX			;;
	PUSH	DI			;;
	PUSH	SI			;;
					;; BP isn't used, so it isn't saved
	push	cs			;;
	pop	ds			;;
					;;
	CMP	STACK_ALLOCATED,0AAH	;;
	JNE	PRN_NO_STACK		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	STACK RECODING SEPT 28/86
;
;	GORDON GIDDINGS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	MOV	AX,STACK_SIZE		;G;
	SHL	AX,1			;G;
	SHL	AX,1			;G;
	SHL	AX,1			;G;
	SHL	AX,1			;G;
	MOV	CS:TEMP_SI,SI		;G;
	MOV	SI,RESIDENT_END 	;G;
	SUB	SI,STACK_SIZE		;G;
					;G;
	mov	reserved1,AX		;G;
	mov	reserved2,SI		;G;
					;G;
	CLI				;G;
	MOV	DX,SS			;G;
	MOV	CX,SP			;G;
	MOV	SS,SI			;G;
	MOV	SP,AX			;G;
	STI				;G;
	MOV	SI,CS:TEMP_SI		;G;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	PUSH	DX			;; SAVE OLD SS ONTO STACK
	PUSH	CX			;; "    "   SP "    "
					;;
PRN_NO_STACK :				;;
					;;
					;;
	MOV	DI,OFFSET IRPT_CMD_EXIT ;; return addr from command processor
					;;
	PUSH	DI			;; push return address onto stack
					;; command routine issues "RET"
					;;
	LEA	BX, BUF0		;; PRN	BUF = BUF0 , CS:BX
					;;
	MOV	MEM_REQUEST,-1		;; to be set to zero only once
					;;
	CMP	BUF.BFLAG,-1		;;
	JNE	PRN_INITED		;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	MOV	BUF.BFLAG,BF_PRN	;; INITIALIZE PRN BUFFER
					;;
	MOV	DI,OFFSET DEV_HDR0	;; PRN	Device header
	MOV	BUF.DEV_HDRO,DI 	;;
	MOV	BUF.DEV_HDRS,CS 	;; must be CS
					;;
	MOV	DI,OFFSET HBUF_SL1	;; PRN/LPT1 buffer for Hardware-slots
	MOV	BUF.HRBUFO,DI		;;
					;;
	MOV	DI,OFFSET RBUF_SL1	;; PRN/LPT1 buffer for RAM-slots
	MOV	BUF.RMBUFO,DI		;;
					;;
	MOV	DI,OFFSET FTDL_OFF1	;;
	MOV	BUF.FTDLO,DI		;;
					;;
	MOV	DI,OFFSET REQ_NORM1	;; PRN/LPT1 request header
	MOV	BUF.RNORMO,DI		;;
					;;
	MOV	BUF.FSELEN,0		;; selection control length
					;;
	mov	buf.prn_bufo,offset buf0;;
					;;
	JMP	COMMON_INTR		;; common interrupt handler
					;;
PRN_INITED :				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; FONT BUFFER TO BE CREATED ?
	CMP	BUF.BFLAG,BF_PRN	;;
	JNE	PRN_MEM_DONE		;;
					;;
	OR	BUF.BFLAG,BF_MEM_DONE	;; do it only once.
					;;
	CMP	BUF.STATE,CPSW		;;
	JNE	PRN_MEM_DONE		;; create only if state is CPSW
					;;
PRN_MEM_CREATE :			;;
	XOR	AX,AX			;; THEN CREATE
	MOV	MEM_REQUEST,AX		;; to set to zero only once for each
					;; LPTn or PRN
PRN_MEM_DONE :				;;
	JMP	COMMON_INTR		;; common interrupt handler
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; LPT1 Device "interrupt" entry point
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
INTERRUPT1 PROC FAR			;; device interrupt entry point
					;;
	PUSH	DS			;; save all registers Revised
	PUSH	ES			;;
	PUSH	AX			;;
	PUSH	BX			;;
	PUSH	CX			;;
	PUSH	DX			;;
	PUSH	DI			;;
	PUSH	SI			;;
					;; BP isn't used, so it isn't saved
	push	cs			;;
	pop	ds			;;
					;;
	CMP	STACK_ALLOCATED,0AAH	;;
	JNE	LPT1_NO_STACK		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	STACK RECODING SEPT 28/86
;
;	GORDON GIDDINGS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	MOV	AX,STACK_SIZE		;G;
	SHL	AX,1			;G;
	SHL	AX,1			;G;
	SHL	AX,1			;G;
	SHL	AX,1			;G;
	MOV	CS:TEMP_SI,SI		;G;
	MOV	SI,RESIDENT_END 	;G;
	SUB	SI,STACK_SIZE		;G;
					;G;
	mov	reserved1,AX		;G;
	mov	reserved2,SI		;G;
					;G;
	CLI				;G;
	MOV	DX,SS			;G;
	MOV	CX,SP			;G;
	MOV	SS,SI			;G;
	MOV	SP,AX			;G;
	STI				;G;
	MOV	SI,CS:TEMP_SI		;G;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	PUSH	DX			;; SAVE OLD SS ONTO STACK
	PUSH	CX			;; "    "   SP "    "
					;;
LPT1_NO_STACK : 			;;
					;;
	MOV	DI,OFFSET IRPT_CMD_EXIT ;; return addr from command processor
					;;
	PUSH	DI			;; push return address onto stack
					;; command routine issues "RET"
	LEA	BX, BUF1		;; LPT1 BUF = BUF1 , CS:BX
					;;
	MOV	MEM_REQUEST,-1		;; to be set to zero only once
					;;
	CMP	BUF.BFLAG,-1		;;
	JNE	LPT1_INITED		;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	MOV	BUF.BFLAG,BF_LPT1	;; INITIALIZE LPT1 BUFFER
					;;
	MOV	DI,OFFSET DEV_HDR1	;; LPT1 Device header
	MOV	BUF.DEV_HDRO,DI 	;;
	MOV	BUF.DEV_HDRS,CS 	;; must be CS
					;;....................................
	LEA	DI,BUF.RNORMO		;; duplicate common infor. between
	PUSH	CS			;; PRN and LPT1
	POP	ES			;;
	LEA	CX,BUF.BUFEND		;;
	SUB	CX,DI			;;
	LEA	SI, BUF0		;;
	LEA	SI,[SI].RNORMO		;;
	REP	MOVS ES:BYTE PTR[DI],CS:[SI]
					;;
	JMP	COMMON_INTR		;; common interrupt handler
					;;
LPT1_INITED :				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; FONT MEMORY TO BE CREATED ?
	CMP	BUF.BFLAG,BF_LPT1	;;
	JNE	LPT1_MEM_DONE		;;
					;;
	OR	BUF.BFLAG,BF_MEM_DONE	;; no more next time
					;;
	CMP	BUF.STATE,CPSW		;;
	JNE	LPT1_MEM_DONE		;; do it only if state is CPSW
					;;
LPT1_MEM_CREATE :			;;
	XOR	AX,AX			;; THEN CREATE MEMORY
	MOV	MEM_REQUEST,AX		;; to set to zero only once for each
					;;
LPT1_MEM_DONE : 			;;
					;;
	JMP	COMMON_INTR		;; common interrupt handler
					;;
INTERRUPT1 ENDP 			;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; LPT2 Device "interrupt" entry point
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
INTERRUPT2 PROC FAR			;; device interrupt entry point
					;;
	PUSH	DS			;; save all registers Revised
	PUSH	ES			;;
	PUSH	AX			;;
	PUSH	BX			;;
	PUSH	CX			;;
	PUSH	DX			;;
	PUSH	DI			;;
	PUSH	SI			;;
					;; BP isn't used, so it isn't saved
	push	cs			;;
	pop	ds			;;
					;;
	CMP	STACK_ALLOCATED,0AAH	;;
	JNE	LPT2_NO_STACK		;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	STACK RECODING SEPT 28/86
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	MOV	AX,STACK_SIZE		;G;
	SHL	AX,1			;G;
	SHL	AX,1			;G;
	SHL	AX,1			;G;
	SHL	AX,1			;G;
	MOV	CS:TEMP_SI,SI		;G;
	MOV	SI,RESIDENT_END 	;G;
	SUB	SI,STACK_SIZE		;G;
					;G;
	mov	reserved1,AX		;G;
	mov	reserved2,SI		;G;
					;G;
	CLI				;G;
	MOV	DX,SS			;G;
	MOV	CX,SP			;G;
	MOV	SS,SI			;G;
	MOV	SP,AX			;G;
	STI				;G;
	MOV	SI,CS:TEMP_SI		;G;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	PUSH	DX			;; SAVE OLD SS ONTO STACK
	PUSH	CX			;; "    "   SP "    "
					;;
LPT2_NO_STACK : 			;;
					;;
	MOV	DI,OFFSET IRPT_CMD_EXIT ;; return addr from command processor
					;;
	PUSH	DI			;; push return address onto stack
					;; command routine issues "RET"
					;;
	LEA	BX, BUF2		;; LPT2 BUF = BUF2 , CS:BX
					;;
	MOV	MEM_REQUEST,-1		;; to be set to zero only once
					;;
	CMP	BUF.BFLAG,-1		;;
	JNE	LPT2_INITED		;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	MOV	BUF.BFLAG,BF_LPT2	;; initialise LPT2 buffer
					;;
	MOV	DI,OFFSET DEV_HDR2	;; LPT2 Device header
	MOV	BUF.DEV_HDRO,DI 	;;
	MOV	BUF.DEV_HDRS,CS 	;; must be CS
					;;
	MOV	DI,OFFSET HBUF_SL2	;; LPT2 buffer for Hardware-slots
	MOV	BUF.HRBUFO,DI		;;
					;;
	MOV	DI,OFFSET RBUF_SL2	;; LPT2 buffer for RAM-slots
	MOV	BUF.RMBUFO,DI		;;
					;;
	MOV	DI,OFFSET FTDL_OFF2	;;
	MOV	BUF.FTDLO,DI		;;
					;;
					;;
	MOV	DI,OFFSET REQ_NORM2	;; LPT2 request header
	MOV	BUF.RNORMO,DI		;;
					;;
	MOV	BUF.FSELEN,0		;; selection control length
					;;
	mov	buf.prn_bufo,offset buf2;;
					;;
	JMP	COMMON_INTR		;; common interrupt handler
					;;
LPT2_INITED :				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; FONT BUFFER TO BE CREATED ?
	CMP	BUF.BFLAG,BF_LPT2	;;
	JNE	LPT2_MEM_DONE		;;
					;;
	OR	BUF.BFLAG,BF_MEM_DONE	;;
					;;
	CMP	BUF.STATE,CPSW		;;
	JNE	LPT2_MEM_DONE		;;
					;;
	XOR	AX,AX			;;
	MOV	MEM_REQUEST,AX		;; to set to zero only once for each
					;; LPTn or PRN
LPT2_MEM_DONE : 			;;
					;;
	JMP	COMMON_INTR		;; common interrupt handler
					;;
INTERRUPT2 ENDP 			;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; LPT3 Device "interrupt" entry point
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
INTERRUPT3 PROC FAR			;; device interrupt entry point
					;;
	PUSH	DS			;; save all registers Revised
	PUSH	ES			;;
	PUSH	AX			;;
	PUSH	BX			;;
	PUSH	CX			;;
	PUSH	DX			;;
	PUSH	DI			;;
	PUSH	SI			;;
					;; BP isn't used, so it isn't saved
	push	cs			;;
	pop	ds			;;
					;;
	CMP	STACK_ALLOCATED,0AAH	;;
	JNE	LPT3_NO_STACK		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	STACK RECODING SEPT 28/86
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	MOV	AX,STACK_SIZE		;G;
	SHL	AX,1			;G;
	SHL	AX,1			;G;
	SHL	AX,1			;G;
	SHL	AX,1			;G;
	MOV	CS:TEMP_SI,SI		;G;
	MOV	SI,RESIDENT_END 	;G;
	SUB	SI,STACK_SIZE		;G;
					;G;
	mov	reserved1,AX		;G;
	mov	reserved2,SI		;G;
					;G;
	CLI				;G;
	MOV	DX,SS			;G;
	MOV	CX,SP			;G;
	MOV	SS,SI			;G;
	MOV	SP,AX			;G;
	STI				;G;
	MOV	SI,CS:TEMP_SI		;G;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	PUSH	DX			;; SAVE OLD SS ONTO STACK
	PUSH	CX			;; "    "   SP "    "
					;;
LPT3_NO_STACK : 			;;
					;;
	MOV	DI,OFFSET IRPT_CMD_EXIT ;; return addr from command processor
					;;
	PUSH	DI			;; push return address onto stack
					;; command routine issues "RET"
					;;
	LEA	BX, BUF3		;; LPT3 BUF = BUF3 , CS:BX
					;;
	MOV	MEM_REQUEST,-1		;; to be set to zero only once
					;;
	CMP	BUF.BFLAG,-1		;;
	JNE	LPT3_INITED		;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	MOV	BUF.BFLAG,BF_LPT3	;; INITIALIZE LPT3 BUFFER
					;;
	MOV	DI,OFFSET DEV_HDR3	;; LPT3 Device header
	MOV	BUF.DEV_HDRO,DI 	;;
	MOV	BUF.DEV_HDRS,CS 	;; must be CS
					;;
	MOV	DI,OFFSET HBUF_SL3	;; LPT3 buffer for Hardware-slots
	MOV	BUF.HRBUFO,DI		;;
					;;
	MOV	DI,OFFSET RBUF_SL3	;; LPT3 buffer for RAM-slots
	MOV	BUF.RMBUFO,DI		;;
					;;
	MOV	DI,OFFSET FTDL_OFF3	;;
	MOV	BUF.FTDLO,DI		;;
					;;
					;;
	MOV	DI,OFFSET REQ_NORM3	;; LPT3 request header
	MOV	BUF.RNORMO,DI		;;
					;;
	MOV	BUF.FSELEN,0		;; selection control length
					;;
	mov	buf.prn_bufo,offset buf3;;
					;;
	JMP	COMMON_INTR		;; common interrupt handler
					;;
LPT3_INITED :				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; FONT BUFFER TO BE CREATED ?
	CMP	BUF.BFLAG,BF_LPT3	;;
	JNE	LPT3_MEM_DONE		;;
					;;
	OR	BUF.BFLAG,BF_MEM_DONE	;; no more next time
					;;
	CMP	BUF.STATE,CPSW		;;
	JNE	LPT3_MEM_DONE		;;
					;;
	XOR	AX,AX			;;
	MOV	MEM_REQUEST,AX		;; to set to zero only once for each
					;; LPTn or PRN
LPT3_MEM_DONE : 			;;
					;;
	JMP	COMMON_INTR		;; common interrupt handler
					;;
INTERRUPT3 ENDP 			;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Common interrupt entry :
;     at entry, BUFn (CS:BX) of LPTn is defined
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMON_INTR :				;;
	CLD				;; all moves forward
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Check if header link has to be set
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	LDS	SI,DWORD PTR BUF.DEV_HDRO ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;  device header :  DS:[SI]
	CMP	BUF.LPT_STRAO, -1	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	JNE	DOSLPT_FOUND		;; has been linked to DOS LPTn
	CMP	BUF.LPT_STRAS, -1	;;
	JNE	DOSLPT_FOUND		;; has been linked to DOS LPTn
	LDS	SI,DWORD PTR BUF.DEV_HDRO ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;  next device header :  ES:[DI]
	LES	DI,DWORD PTR HP.DH_NEXTO ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
	PUSH	ES			;;
	POP	AX			;;
	AND	AX,AX			;;
	JNZ	L1			;;
	JMP	DOSLPT_FOUND		;; link not yet set up
					;;
;$SEARCH WHILE				 ;;  pointer to next device header is NOT
L1:
	PUSH	ES			;;  -1
	POP	AX			;;
	CMP	AX,-1			;;
;$LEAVE  E,	 AND			 ;; leave if both offset and segment are
	JNE	NOT0FFFF

	CMP	DI,-1			;;  0FFFFH
;$LEAVE  E				 ;;
	JE	L2

NOT0FFFF:				;;
	PUSH	DI			;;
	PUSH	SI			;;
	MOV	CX,NAME_LEN		;;
	LEA	DI,NHD.DH_NAME		;;
	LEA	SI,HP.DH_NAME		;;
	REPE	CMPSB			;;
	POP	SI			;;
	POP	DI			;;
	AND	CX,CX			;;

;$EXITIF Z				 ;; exit if name is found in linked hd.
	JNZ	L3			;; name is not found
					;;
					;; name is found in the linked header
	MOV	AX,NHD.DH_STRAO 	;;  get the STRATEGY address
;	ADD	AX,DI			;;
	MOV	BUF.LPT_STRAO,AX	;;
	MOV	AX,ES			;;
;	JNC	X1			;;
;	ADD	AX,1000H		;;  carrier overflow
X1:	MOV	BUF.LPT_STRAS,AX	;;
					;;
	MOV	AX,NHD.DH_INTRO 	;;  get the INTERRUPT address
;	ADD	AX,DI			;;
	MOV	BUF.LPT_INTRO,AX	;;
	MOV	AX,ES			;;
;	JNC	X2			;;
;	ADD	AX,1000H		;;  carrier overflow
X2:	MOV	BUF.LPT_INTRS,AX	;;
					;;
					;;
;$ORELSE				;; find next header to have the same
					;; device name
	JMP	L4			;;
L3:					;;
	LES	DI,DWORD PTR NHD.DH_NEXTO ;
					;;
;$ENDLOOP				;;
	JMP	L1			;;
L2:					;;
;$ENDSRCH				;;
L4:					;;
					;;
DOSLPT_FOUND :				;; device header link has been
					;; established
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; COMMAND REQUEST
;      ES:DI  Request Header , and
;
;	      CMD_CODES,  GIO_CODES
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;;
	LES	DI,dword ptr buf.rh_ptro ;; get RH address passed to
					;;
	MOV	AL,RH.RHC_CMD		;;
	CMP	AL,CMD_GIO		;;
	JE	GIO_COMMAND		;;
					;;
	PUSH	CS			;;  non-GIO command
	POP	ES			;;
	MOV	DI,OFFSET CMD_CODES	;;
	MOV	CX,CMD_INDX		;;
					;; find if command is in CMD_CODES ?
	REPNE	SCASB			;;
	JNE	UN_SUP			;;
	MOV	SI,CMD_INDX		;; the command is supported :
	SUB	SI,CX			;;
	DEC	SI			;; index to CASES
	JMP	SUPPORTED		;;
					;;
UN_SUP: JMP	NORM_DRIVER		;; to be handled by DOS normal driver
					;;
GIO_COMMAND :				;; Check if it is valid GIO
					;;
GIO_CASES :				;; supported GIO command
	MOV	AL,RH.GIH_MIF		;;
					;; use minor function to locate
	PUSH	CS			;;
	POP	ES			;;
	MOV	DI,OFFSET GIO_CODES	;;
	MOV	CX,GIO_INDX		;;
					;; find if command is in GIO_CODES ?
	REPNE	SCASB			;;
	JNE	NORM_DRIVER		;;
	MOV	SI,GIO_INDX		;; the command is supported :
	SUB	SI,CX			;;
	DEC	SI			;; index to CASES
	ADD	SI,CMD_INDX		;;
					;;
SUPPORTED :				;; command/functions supported by LPTn
					;;
	ADD	SI,SI			;; double to index to WORD-offset
					;;
	XOR	AX,AX			;; initialize return to "no error"
					;;
	LES	DI,dword ptr buf.rh_ptro ;; get RH address again
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  At entry to command processing routine:
;
;      ES:DI   = Request Header address
;      CS:BX   = Buffer for lptn
;      CS      = code segment address
;      AX      = 0
;
;      top of stack is return address, IRPT_CMD_EXIT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
	JMP	CS:CASES[SI]		;; call routine to handle the command
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
IRPT_CMD_EXIT:				;; return from command routine
					;; AX = value to OR into status word
	LES	DI,dword ptr buf.rh_ptro ;; restore ES:DI as Request Header ptr
	MOV	AX,RH.RHC_STA		;;
	OR	AH,STAT_DONE		;; add "done" bit to status word
	MOV	RH.RHC_STA,AX		;; store status into request header
					;;
					;;
					;; *** USING INTERNATL STACK ? ***
					;;
	CMP	STACK_ALLOCATED,-1	;;
	JE	RET0_NO_STACK		;;
					;;
	CMP	STACK_ALLOCATED,0	;;
	JNE	RET0_IN_STACK		;;
					;;
	MOV	STACK_ALLOCATED,0AAH	;; NEXT interrupt will start using
	JMP	RET0_NO_STACK		;; internal STACK
					;;
RET0_IN_STACK : 			;; use internal STACK !!!!
	POP	CX		;get old SP from stack
	POP	DX		;get old SS from stack
	CLI			;disable interrupts while changing SS:SP
	MOV	SS,DX		;restore stack segment register
	MOV	SP,CX		;restore stack pointer register
	STI			;enable interrupts
					;;
					;;
RET0_NO_STACK : 			;;
					;;
	POP	SI			;; restore registers
	POP	DI			;;
	POP	DX			;;
	POP	CX			;;
	POP	BX			;;
	POP	AX			;;
	POP	ES			;;
	POP	DS			;;
	RET				;;
					;;
INTERRUPT0 ENDP 			;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;====	Command not supported by CPSW device driver
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
NORM_DRIVER PROC			;; LPT OUTPUT to the DOS LPTn
					;;
	PUSH	BX			;; **** BUF. is changed ****
	PUSH	BX			;;
	POP	SI			;;
	LES	BX,DWORD PTR BUF.RH_PTRO ;; pass the request header to the
	CALL	DWORD PTR CS:[SI].LPT_STRAO ;; LPTn strategy routine.
					;;
	POP	BX			;;
	CALL	DWORD PTR BUF.LPT_INTRO ;; interrupt the DOS LPTn
	RET				;;
					;;
NORM_DRIVER ENDP			;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;====	Command Code  - lpt_output  =======
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
WRITE	    PROC			;; LPT OUTPUT to the DOS LPTn
					;;
					;;
					;;
	LES	DI,dword ptr buf.rh_ptro ;; restore ES:DI as Request Header ptr
					;;
	MOV	AX,BUF.STATE		;;
	CMP	AX,NORMAL		;;
	JNE	WRT_NOT_NORMAL		;;
	JMP	WRT_NORMAL		;;
					;;
WRT_NOT_NORMAL :			;;
	CMP	AX,DESG_END		;;
	JNE	WRT_FONT		;;
	JMP	NO_MORE_FTBLK		;; ignore the write
					;;
WRT_FONT :				;;
	CMP	AX,DESG_WR		;;
	JE	WRT_DESIGNATE		;;
	JMP	WRT_NORMAL		;;
					;;-------------------------
WRT_DESIGNATE : 			;; DESIGNATE WRITE
	MOV	AX,BUF.STATUS		;;
	AND	AX,FAIL 		;;
	JZ	WRT_DESG_GOOD		;;
	JMP	WRT_IGNORE		;; already failed
					;;
WRT_DESG_GOOD : 			;;
	MOV	SI,OFFSET FTABLE	;;
	PUSH	CS			;;
	POP	DS			;;
					;;
	MOV	DS:[SI].FLAG,0		;; no restart
	MOV	AX,RH.RH3_CNT		;;
	MOV	DS:[SI].BUFFER_LEN,AX	;; length of request packet
					;;
	PUSH	SI			;;
	LEA	SI,[SI].BUFFER_ADDR	;; packet address
	MOV	AX,RH.RH3_DTAO		;;
	MOV	DS:[SI],AX		;;
	INC	SI			;;
	INC	SI			;;
	MOV	AX,RH.RH3_DTAS		;;
	MOV	DS:[SI],AX		;;
	POP	SI			;;
					;;
FP_CALL :				;;   **************************
	CALL	FONT_PARSER		;;   ** Parse the Font File  **
FP_RETURN :				;;   **************************
					;;
					;; -- only for the RAM slot --
					;;
					;; PROCESS THE RETURNED FONT :
					;; SI = FTABLE
	MOV	ES,BUF.FTSTART		;; ES = the start of the font buffer,
					;;	its entry corresponds to the
					;;	positioning of codepage in slot
	MOV	DI,BUF.FTSLOTO		;; DI = start of the slot of codepages
					;; CX = slot size of the font downloaded
	MOV	CX,BUF.RBUFMX		;;     --- if there is no designate
	MOV	AX,BUF.STATUS		;;
	AND	AX,DSF_CARTCP		;;
	JZ	CHECK_RETURN		;;
	MOV	CX,BUF.HSLMX		;;     -- with/without designate, <>0
					;;
CHECK_RETURN :				;;
					;;
	MOV	DX,CS:[SI].NUM_FTBLK	;; DX = number fo code pages loaded
					;;
	ADD	SI,TYPE FBUFS		;; SI = points to FTBLK
					;;...................................
PARSE_FTBLK :				;; **** LOOP ****
					;;
					;;
	AND	DX,DX			;;
	JNZ	SKIP_SLOT		;;
	JMP	NO_MORE_FTBLK		;; **** LOOP EXIT (FTBLK end) ****
					;;...................................
					;; **** LOOP (on each FTBLK)  ****
					;;
					;; skip on the slot until the codepage
SKIP_SLOT :				;; is one of the downloaded.
	AND	CX,CX			;;
	JNZ	LOCATE_SLOT		;;
	XOR	AX,AX			;;
	PUSH	AX			;;
	POP	ES			;; ES = 0, no font storage(less buffer)
	JMP	SLOT_FOUND		;;
					;;
LOCATE_SLOT:				;;
	MOV	AX,CS:[DI].SLT_AT	;;
	AND	AX,AT_load		;;
	Jnz	SLOT_FOUND		;;
	INC	DI			;;########   NEXT SLOT	 ############
	INC	DI			;;
	INC	DI			;;
	INC	DI			;; next slot
	PUSH	ES			;;
	POP	AX			;;
	ADD	AX,BUF.FTSZPA		;;
	PUSH	AX			;;
	POP	ES			;; next buffer
	DEC	CX			;;####################################
	JMP	SKIP_SLOT		;;
					;;
SLOT_FOUND :				;;
	MOV	AX,CS:[SI].FTB_STATUS	;;
	CMP	AX,0FFF0H		;;
	JNB	CHECK_FSTAT		;;
					;;
	OR	BUF.STATUS,FAIL 	;;
					;;
	LES	DI,dword ptr buf.rh_ptro ;;
	MOV	RH.RHC_STA,AX		;;
	JMP	WRITE_RET		;; **** LOOP EXIT (fail)  ****
					;;
CHECK_FSTAT :				;;
	CMP	AX,FSTAT_FONT		;;
	JNE	NEXT_FTBLK		;;
					;;
	MOV	AX,CS:[SI].FTB_DLEN	;;
	AND	AX,AX			;;
	JNZ	FONT_RETURNED		;;
					;;
NEXT_FTBLK :				;; **** NEXT IN LOOP ****
					;;
	ADD	SI,TYPE FTBLK		;;  SI = points to FTBLK
	DEC	DX			;;
	INC	DI			;;########   NEXT SLOT	 ############
	INC	DI			;;
	INC	DI			;;
	INC	DI			;; next slot
	PUSH	ES			;;
	POP	AX			;;
	ADD	AX,BUF.FTSZPA		;;
	PUSH	AX			;;
	POP	ES			;; next buffer
	DEC	CX			;;####################################
	JMP	PARSE_FTBLK		;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FONT_RETURNED : 			;;
					;;  *********************************
					;;  * ANY SELECTION CONTROL TO BE   *
					;;  * STORED ?			    *
					;;  *********************************
					;;
					;;
					;; SI = points to FTBLK
					;; ES = font buffer segment / 0
					;; BX = LPT buffer
					;; DI = SLOT pointer
	PUSH	CX			;;
					;;
					;;
	MOV	AX,CS:[SI].FTB_SELECT	;;
	AND	AX,AX			;;
	JNZ	SELECT_NOT0		;;
	CMP	BUF.PCLASS,1		;;
	JNE	SELECT_0		;;
	JMP	SELECT_BAD		;; CLASS 1 printer CANNOT have SELECT=0
					;;
SELECT_0:				;;
					;;
	POP	CX			;;
	JMP	STORE_FONT		;;
					;;
SELECT_NOT0 :				;;
					;;
	CMP	BUF.PCLASS,1		;;
	JNE	NOT_CLASS1		;;
	JMP	SELECT_CLASS1		;;
					;;
not_class1 :				;;
	MOV	AX,CS:[SI].FTB_SELLEN	    ;; has this FTBLK already passed the
	AND	AX,AX			;; select ?
	JNZ	SELECT_NOT_PASSED	;;
					;;
	POP	CX			;;
	JMP	STORE_FONT		;;
					;;
SELECT_NOT_PASSED :			;;
	CMP	AX,BUF.FSELMAX		;;
	JNA	SELECT_NOT_LONG 	;;
	JMP	SELECT_BAD		;; cannot be more than buffer size
					;;
					;;
SELECT_NOT_LONG :			;;
	MOV	AX,CS:[SI].FTB_SELECT	    ;;
	CMP	AX,1			;;
	JE	SELECT_1		;;
	JMP	SELECT_BAD		;;
					;;
SELECT_1 :				;;
	MOV	CX,BUF.FSELEN		;; +++ SELECT = 1 +++
	AND	CX,CX			;;
	JZ	CTL_NOT_COPIED		;;
	MOV	AX,CS:[DI].SLT_AT	;; == copy control only from one FTBLK
	AND	AX,AT_SELECT		;;
	JNZ	CTL_NOT_COPIED		;;
	JMP	SKIP_SELECT		;;
					;;
CTL_NOT_COPIED :			;;
					;;
	OR	CS:[DI].SLT_AT,AT_SELECT;; the FTBLK where control is copied
					;; from
					;;
	MOV	CX,CS:[SI].FTB_SELLEN	    ;;
	CMP	CX,CS:[SI].FTB_DLEN	    ;;
	JNA	STORE_SELECT		;;
					;;
	MOV	CX,CS:[SI].FTB_DLEN	    ;;
					;;
STORE_SELECT:				;;
	PUSH	CX			;; CX is the length to be copied.
					;;
	PUSH	ES			;;
	PUSH	DS			;;
	PUSH	SI			;;
	PUSH	DI			;;
					;;
	MOV	AX,CS:[SI].FTB_DAHI	    ;;
	PUSH	AX			;;
	POP	DS			;;
	MOV	SI,CS:[SI].FTB_DALO	    ;;
					;;
	PUSH	CS			;;
	POP	ES			;;
					;;
	MOV	DI,BUF.PDESCO		;;
	MOV	DI,CS:[DI].SELB_O	;;
	ADD	DI,BUF.FSELEN		;;
					;;
	REP	MOVSB			;;
					;;
					;;
	POP	DI			;;
	POP	SI			;;
	POP	DS			;;
	POP	ES			;;
					;;
	POP	CX			;;
	SUB	CS:[SI].FTB_DLEN,CX	    ;;
	SUB	CS:[SI].FTB_SELLEN,CX	    ;; == less control bytes to be copied
	ADD	CS:[SI].FTB_DALO,CX	;;
	ADD	BUF.FSELEN,CX		;;
					;;
	POP	CX			;;
					;;
					;; any data left for font ?
	CMP	BUF.PCLASS,1		;;
	JNE	MORE_FONT		;;
					;;
	JMP	NEXT_FTBLK		;; == CLASS 1 printer ingnores fonts
					;;
MORE_FONT :				;; more font data ?
					;;
	JMP	STORE_FONT		;;
					;;
SELECT_CLASS1:				;;  +++ PRINTER CLASS = 1
					;;
	MOV	AX,CS:[SI].FTB_SELECT	    ;;
	CMP	AX,2			;;
	JE	GOOD_CLASS1		;;
	JMP	SELECT_BAD		;;
					;;  select type = 2 only
GOOD_CLASS1 :				;;
	POP	CX			;;
					;;
	PUSH	ES			;; STACKS...
	PUSH	DX			;;
	PUSH	DI			;;
	MOV	AX,DI			;;
	SUB	AX,BUF.FTSLOTO		;;
	SHR	AX,1			;;
	PUSH	AX			;; stack 1 -- offest
	MOV	DI,BUF.FTDLO		;;
	ADD	DI,AX			;;
					;;
	MOV	AX,CS:WORD PTR [DI]	;; length copied to font buffer
					;;
	POP	DX			;; stack -1
	SHR	DX,1			;;
	PUSH	DI			;; STACK +1 -- to font buffer length
	MOV	DI,BUF.FTSTART		;;
CTL_ADDR :				;;
	AND	DX,DX			;;
	JZ	CTL_LOCATED		;;
	ADD	DI,BUF.FTSZPA		;;
	DEC	DX			;;
	JNZ	CTL_ADDR		;;
					;;
CTL_LOCATED :				;;
	PUSH	DI			;;
	POP	ES			;;
	XOR	DI,DI			;; start of the font buffer
	MOV	CX,CS:[SI].FTB_SELLEN	;;
	AND	AX,AX			;;
	JNZ	HASBEEN_COPIED		;;
	MOV	ES:BYTE PTR [DI],CL	;; 1st byte is the length
	INC	AX			;;
					;;
HASBEEN_COPIED :			;;
					;;
	ADD	DI,AX			;;
	DEC	AX			;;
	CMP	AX,CX			;; all copied ?
	JB	COPY_SELECT		;;
					;;
	POP	DI			;; STACK -1
					;;
	POP	DI			;; STACKS...
	POP	DX			;;
	POP	ES			;;
	MOV	CX,CS:[SI].FTB_DLEN	;; all font data for this code page is
	SUB	CS:[SI].FTB_DLEN,CX	;; discarded
	ADD	CS:[SI].FTB_DALO,CX	;;
					;;
	JMP	NEXT_FTBLK		;;
					;;
COPY_SELECT :				;;
					;;
	SUB	CX,AX			;;
	CMP	CX,CS:[SI].FTB_DLEN	;;
	JNA	FONT_SELECT		;;
					;;
	MOV	CX,CS:[SI].FTB_DLEN	;;
					;;
FONT_SELECT :				;;
					;;
	PUSH	CX			;;  STACK +2
					;;
	PUSH	DS			;;  STACK +3
	PUSH	SI			;;  STACK +4
					;;
	MOV	AX,CS:[SI].FTB_DAHI	;;
	PUSH	AX			;;
	POP	DS			;;
	MOV	SI,CS:[SI].FTB_DALO	;;
					;;
	PUSH	DI			;; STACK +5
					;;
	REP	MOVSB			;;
					;;
	POP	DI			;; STACK -5
	POP	SI			;; STACK -4
	POP	DS			;; STACK -3
					;;
	POP	CX			;; STACK -2
	ADD	CX,DI			;;
	POP	DI			;; STACK -1
	MOV	CS:WORD PTR [DI],CX	;;
					;;
	MOV	CX,CS:[SI].FTB_DLEN	;; all font data for this code page is
	SUB	CS:[SI].FTB_DLEN,CX	;; discarded
	ADD	CS:[SI].FTB_DALO,CX	;;
					;;
	POP	DI			;;
	POP	DX			;;
	POP	ES			;;
					;;
	JMP	NEXT_FTBLK		;;
					;;
					;;
SKIP_SELECT :				;; ++ SKIP SELECT ++
					;;
	MOV	CX,CS:[SI].FTB_SELLEN	;;
	CMP	CX,CS:[SI].FTB_DLEN	;;
	JNA	SKIP_ALL_SELLEN 	;;
	MOV	CX,CS:[SI].FTB_DLEN	;;
					;;
SKIP_ALL_SELLEN :			;;
	SUB	CS:[SI].FTB_DLEN,CX	;;
	SUB	CS:[SI].FTB_SELLEN,CX	;; == less control bytes to be skipped
	ADD	CS:[SI].FTB_DALO,CX	;;
					;;
	POP	CX			;;
	JMP	STORE_FONT		;;
					;;
SELECT_BAD :				;; ++ BAD SELECT ++
					;;
	POP	CX			;;
					;;
	LES	DI,dword ptr buf.rh_ptro ;;
	MOV	RH.RHC_STA,STAT_BADATA	;;
					;;
	OR	BUF.STATUS,FAIL 	;;
					;;
	JMP	WRITE_RET		;;
					;;
					;;
					;; *************************************
					;; * FONT TO BE STORED OR DOWNLOADED ? *
					;; *************************************
					;;
					;; SI = points to FTBLK
					;; ES = font buffer segment / 0
					;; BX = LPT buffer
					;; DI = SLOT pointer
STORE_FONT :				;;
					;;
	CMP	CS:[SI].FTB_DLEN,0	;; any font data left ?
	JNZ	HAS_FONT_DATA		;;
	JMP	NEXT_FTBLK		;;
					;;
HAS_FONT_DATA : 			;;
	PUSH	ES			;;
	POP	AX			;;
	AND	AX,AX			;;
	JNZ	STORE_FONT_BUFFER	;;
	JMP	FONT_DOWNLOAD		;;
					;;
					;;
					;;
STORE_FONT_BUFFER :			;; *****************************
	PUSH	DI			;; **  STORE TO FONT BUFFER   **
					;; *****************************
	PUSH	CX			;;
	PUSH	DS			;;  ES = font buffer segment
					;;
					;; -- determine where is the infor :
	MOV	AX,DI			;;
	SUB	AX,BUF.FTSLOTO		;; relative to the start of the slot
	SHR	AX,1			;; ''       ''  '' "     of FTDL_OFF
					;;
					;;
	ADD	AX,BUF.FTDLO		;;
	MOV	DI,AX			;;
					;;
					;;...................................
	MOV	CX,CS:[SI].FTB_DLEN	;; length of font data
					;;
	MOV	AX,CS:WORD PTR [DI]	;; current destination
					;;
	ADD	AX,CX			;;
	PUSH	AX			;; STACK A (next destination)
					;;
	ADD	AX,CS:[SI].FTB_DLEFT	;; enough room in font buffer ?
	CMP	AX,BUF.FTSIZE		;;
	JNA	ROOM_FOR_FONT		;;
					;;
	POP	AX			;; STACK A
	POP	DS			;;
	POP	CX			;; **** LOOP EXIT (no room) ****
	POP	DI			;;
					;;
	LES	DI,dword ptr buf.rh_ptro ;;
	MOV	RH.RHC_STA,STAT_BADATA	;;
					;;
	OR	BUF.STATUS,FAIL 	;;
					;;
	JMP	WRITE_RET		;;
					;;
ROOM_FOR_FONT : 			;;
					;;
	PUSH	DI			;; STACK B
					;;
	MOV	DI,CS:WORD PTR [DI]	;; current destination
					;;
	PUSH	SI			;; STACK C
	PUSH	DS			;; STACK D
					;;
	MOV	AX,CS:[SI].FTB_DAHI	;;
	PUSH	AX			;;
	POP	DS			;; source : FTB_DA
	MOV	SI,CS:[SI].FTB_DALO	;;
					;;
	REP	MOVSB			;;
					;;
	POP	DS			;; STACK D
	POP	SI			;; STACK C
	POP	DI			;; STACK B
	POP	AX			;; STACK A
	MOV	CS:WORD PTR [DI],AX	;; next detination/current length
					;;
	POP	DS			;;
	POP	CX			;;
	POP	DI			;;
					;;
	OR	CS:[DI].SLT_AT,AT_FONT	;; font buffer has been overwritten
					;;
	JMP	NEXT_FTBLK		;;
					;;
FONT_DOWNLOAD : 			;; ***********************************
					;; *  DOWNLOAD FONT TO THE DEVICE :  *
	PUSH	ES			;; ***********************************
	PUSH	DI			;;
	LES	DI,dword ptr buf.rh_ptro ;; -- the logic can only support one
					;;     physical device slot that can be
					;;     downloaded.)
	MOV	AX,CS:[SI].FTB_DLEN	;;
	MOV	RH.RH3_CNT,AX		;;
	MOV	AX,CS:[SI].FTB_DALO	;;
	MOV	RH.RH3_DTAO,AX		;;
	MOV	AX,CS:[SI].FTB_DAHI	;;
	MOV	RH.RH3_DTAS,AX		;;
					;;
	MOV	RH.RHC_CMD,CMD_WRT	;; 06/25 MODE.COM
					;;
	PUSH	SI			;;
	PUSH	ES			;;
	PUSH	BX			;; **** BUF. is changed ****
	PUSH	BX			;;
	POP	SI			;;
	LES	BX,DWORD PTR BUF.RH_PTRO ;; pass the request header to the
					;;
FDL_CALL_STR :				;;
	CALL	DWORD PTR CS:[SI].LPT_STRAO ;; LPTn strategy routine.
	POP	BX			;;
	POP	ES			;;
	POP	SI			;;
					;;
FDL_CALL_ITR :				;;
	CALL	DWORD PTR BUF.LPT_INTRO ;; interrupt the DOS LPTn
					;;
FDL_ITR_RETURN :			;;
	MOV	AX,rh.RHC_STA		;;
					;;
	and	ax,stat_error		;;
	jz	fdl_good1		;;
	mov	ax,stat_deverr		;;
	mov	rh.rhc_sta,ax		;;
					;;
fdl_good1 :				;;
	POP	DI			;;
	POP	ES			;;
					;;
	AND	AX,STAT_ERROR		;; any error returned by normal device?
	JNZ	FDL_BAD 		;;
	OR	CS:[DI].SLT_AT,AT_RAM1	;;
	JMP	NEXT_FTBLK		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
FDL_BAD :				;; **** LOOP EXIT (bad) ****
	OR	BUF.STATUS,FAIL 	;;
					;;
	JMP	WRITE_RET		;;
					;;
WRT_NORMAL :				;;
					;;
	JMP	NORM_DRIVER		;;
					;;
WRT_ignore :				;;
					;;
	LES	DI,dword ptr buf.rh_ptro ;;
	MOV	RH.RHC_STA,STAT_DEVERR	;;
	JMP	WRITE_RET		;;
					;;
NO_MORE_FTBLK : 			;;
					;;
	LES	DI,dword ptr buf.rh_ptro ;;
	MOV	RH.RHC_STA,0		;;
					;;
WRITE_RET :				;;
	RET				;;
					;;
WRITE	    ENDP			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;====	Generic IOCTL Designate Start  ======
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DESIGNATE_START PROC			;;
	MOV	AX,BUF.STATE		;;
	CMP	AX,NORMAL		;;
	JNE	DS_00			;G; ALL OF THESE EXTRA JUMPS ARE
	JMP	DST_NORMAL		;;  DUE TO SIZE OF FOLLOWING CODE!!!!!
DS_00:	CMP	AX,CPSW 		;; WGR						 ;AN000;
	JE	DS_01			;G;
	CMP	AX,LOCKED		;; WGR						 ;AN000;
	JE	DS_03			;; WGR						 ;AN000;
	JMP	DST_CMDERR		;G;

DS_01:	CALL	CHECK_PRINT_ACTIVE	;G; THIS WILL FIND OUT IF THE
	JNC	DS_02			;G;
DS_03:					;; WGR						 ;AN000;
	JMP	DST_DEVERR		;G; PRINT.COM IS ACTIVE, CY=1 MEANS YES
					;G;
DS_02:	LDS	SI,RH.GIH_GBA		;; GIOB = DS:[SI]
	MOV	AX,GIOB.GB1_FLAG	;;
	AND	AX,DSF_CARTCP		;;
	JNZ	dst_deverr		;; DO NOT SUPPORT CARTRIDGE FLAG !!!!
					;;
					;; ******************************
					;; **  DESIGNATE / REFRESH  ?  **
					;; ******************************
					;; check the LENGTH in BUFFER1
					;;
	MOV	CX,GIOB.GB1_LEN 	;;
	AND	CX,CX			;;
	JNZ	DST_NOT_NULL		;;
					;;
	mov  cs:init_chk,0fefeh 	;;
					;;
	JMP	DST_REFRESH		;; null lenght ==> refresh
					;;
DST_NOT_NULL :				;;
	MOV	AX,CX			;;
	SHR	AX,1			;; divide by 2
	MOV	CX,AX			;;
	MOV	AX,STAT_CMDERR		;; error if LEN < 2
	AND	CX,CX			;;
	JZ	DST_RET 		;;
	DEC	CX			;;
	JNZ	NO_REFRESH		;;
					;;
	MOV	AX,GIOB.GB1_NUM 	;;
	AND	AX,AX			;;
	MOV	AX,STAT_BADATA		;;
	JNZ	DST_RET 		;; error, as no code pages followed
					;;
	mov  cs:init_chk,0ffeeh 	;;
					;;
					;;
	JMP	DST_REFRESH		;; null length => REFRESH font from
					;;		  font buffer to device
					;; *********************************
					;; **  DESIGNATE FOR CARTRIDGE ?  **
NO_REFRESH :				;; *********************************
					;; CX = number of codepages designated
	CMP	BUF.PCLASS,1		;;  CLASS 1 Printer ?
	JNE	DST_RAM 		;;
	JMP	DST_CART		;;
					;;
DST_RAM :				;;
					;;
	MOV	AX,DSF_CARTCP		;; RAM-code pages
	NOT	AX			;;
	AND	BUF.STATUS,AX		;; not CARTCP
	MOV	DI,BUF.RMBUFO		;; DI
	MOV	DX,BUF.RSLMX		;; DX = number of designate allowed
					;;	(limited by available slots)
	MOV	AX,STAT_TOMANY		;;
	CMP	CX,DX			;; more codepages than supported ?
	JA	DST_RET 		;;
					;;
	JMP	DST_DESIGNATE		;;
					;;
DST_NORMAL :				;;
	push	cs			;;
	pop	ds			;;
	JMP	NORM_DRIVER		;;
					;;
DST_DEVERR :				;;
	MOV	AX,STAT_DEVERR		;;
	JMP	DST_RET 		;G;
					;;
DST_CMDERR :				;G;
	MOV	AX,STAT_CMDERR		;G;
DST_RET :				;;
	JMP	DST_RETURN		;;
					;;
DST_CART:				;;
	MOV	AX,DSF_CARTCP		;; Hardware code pages
	OR	BUF.STATUS,AX		;;
	MOV	DI,BUF.HRBUFO		;; DI
	MOV	DX,BUF.HSLMX		;; DX = number of slots available
	MOV	AX,DX			;;
	SUB	AX,BUF.HARDMX		;; no. of designate allowed
					;;
	CMP	CX,AX			;; more codepages than supported ?
	MOV	AX,STAT_TOMANY		;;
	JA	DST_RET 		;;
;;---------------------------------------------------------------------------
					;; *************************************
DST_DESIGNATE : 			;; * any duplicated codepages in MODE ?*
					;; * define the slot-buffer	       *
					;; *************************************
					;;
					;; -- Use the buffer to hold the code
					;;    page value in the MODE with the
					;;    position correspondence :
					;; 1. reset the buffer to all 0FFFFH
					;; 2. if the code page in MODE does not
					;;    replicate with any in the buffer,
					;;    then store the code page value in
					;;    the buffer.
					;; 3. proceed to the next code page in
					;;    the MODE to check with what is
					;;    already copied to the buffer.
					;; 4. designate will fail if there is a
					;;    replication : i.e. a repetition
					;;    in the MODE command.
					;; 5. skip the buffer corresponding to
					;;    HWCP codepages
					;;-------------------------------------
					;;
	PUSH	DI			;; (the start of RAM/Hardware buffer)
	PUSH	DX			;; count of buffer size
	MOV	AX,0FFFFH		;;
RESET_BUF:				;;
	MOV	CS:[DI],AX		;; reset all buffer to 0FFFFH
	INC	DI			;;
	INC	DI			;;
	DEC	DX			;;
	JNZ	RESET_BUF		;;
	POP	DX			;;
	POP	DI			;;
					;;
	PUSH	BX			;;
	PUSH	DI			;; (the start of RAM/Hardware buffer)
	PUSH	DX			;; count of buffer size
	PUSH	SI			;; first code page in GB1
	PUSH	CX			;; number of codepages in GB1
					;;
	PUSH	SI			;;
					;;
	MOV	AX,BUF.STATUS		;;
	AND	AX,DSF_CARTCP		;;
	JZ	FILL_BUFFER		;;
					;;  for cartridge designation
	MOV	SI,BUF.HARDSO		;;
SKIP_HWCP:				;;
	MOV	AX,CS:[SI].SLT_AT	;;
	AND	AX,AT_HWCP		;;
	JZ	FILL_BUFFER		;;
	INC	SI			;; skip the hwcp slots, they cannot be
	INC	SI			;; designated
	INC	SI			;;
	INC	SI			;;
	INC	DI			;;
	INC	DI			;;
	JMP	SKIP_HWCP		;;
					;;
FILL_BUFFER :				;;
					;;
	POP	SI			;;
					;;
	PUSH	DI			;;
	POP	BX			;; BX = the positioned buffer
					;;
DST_BUFLP :				;; **** LOOP ****
	MOV	AX,GIOB.GB1_CP		;; (use GIOB only for codepages)
	CMP	AX,0FFFFH		;;
	JZ	DST_BUFNXT		;;
					;;
	PUSH	CX			;;
					;; compare code page with SLOT-BUFFER
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; SCAN THE BUFFER FOR DUPLICATION
	PUSH	DX			;;
	POP	CX			;; no. of buffer entries
					;;
	PUSH	ES			;;
	PUSH	DI			;;
	PUSH	CS			;;
	POP	ES			;;
	REPNE	SCASW			;; scan codepage vs. buffer
	POP	DI			;;
	POP	ES			;;
					;;
	POP	CX			;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
	JNE	BUF_DEFINE		;;
					;;
					;; **** EXIT FROM LOOP ****
					;;
	POP	CX			;; number of codepages in GB1
	POP	SI			;; first code page in GB1
	POP	DX			;; count of buffer size
	POP	DI			;; (the start of RAM/Hardware buffer)
	POP	BX			;;
					;;
	MOV	AX,STAT_DUPLCP		;; Duplicated code page
	JMP	DST_RETURN		;;
					;;
					;;
BUF_DEFINE :				;;
	MOV	CS:[BX],AX		;; no duplicated cp in MODE list
					;;
					;;
					;; **** NEXT IN LOOP ****
DST_BUFNXT:				;;
	INC	SI			;; (use GIOB only for codepages)
	INC	SI			;;
	INC	BX			;;
	INC	BX			;;
	XOR	AX,AX			;;
	DEC	CX			;;
	JNZ	DST_BUFLP		;;
					;;
					;;
	POP	CX			;; number of codepages in GB1
	POP	SI			;; first code page in GB1
	POP	DX			;; count of buffer size
	POP	DI			;; (the start of RAM/Hardware buffer)
	POP	BX			;;
					;;
					;;
;;-----------------------------------------------------------------------------
					;;*************************************
					;;* any duplicated codepages bet MODE *
					;;* and code pages in the slot ?      *
					;;*************************************
					;; -- for each code page in the slot,
					;;    check for any duplication to
					;;    code pages in buffer, if the code
					;;    page in the slot is not to be
					;;    replaced.
					;; -- the designate fails if there is
					;;    duplication.
					;; -- copy the codepage in the slot to
					;;    the buffer if is not to be
					;;    replaced. Mark the slot to be
					;;    AT_OLD.
					;; -- if the code page is tobe replaced
					;;    mark the STATUS with REPLX.
					;;-------------------------------------
					;;
	MOV	CX,DX			;; both slots & buffer of same size
					;; --exclude the hwcp which is not
					;;   designatable
	MOV	SI,BUF.HARDSO		;; SI = hardware slot
					;;
	MOV	AX,BUF.STATUS		;;
	AND	AX,DSF_CARTCP		;;
	JNZ	CMP_CP			;;
	MOV	SI,BUF.RAMSO		;; SI = RAM slot
CMP_CP: 				;;
	MOV	BUF.FTSLOTO,SI		;;
					;;
	PUSH	DI			;; (the start of RAM/Hardware buffer)
	PUSH	DX			;; count of buffer size
	PUSH	SI			;; first entry in RAM/hardware slot
	PUSH	CX			;; slot size
	PUSH	BX			;;
					;;
	PUSH	DI			;;
	POP	BX			;; BX = the positioned buffer
DST_SLTLP :				;;
					;; **** LOOP ****
					;;
	MOV	AX,AT_OLD		;; =**=
	NOT	AX			;; assumed the codepage in slot is new,
	AND	CS:[SI].SLT_AT,AX	;; to be downloaded if buffer <> 0FFFFH
					;;
	AND	CS:[SI].SLT_AT,AT_NO_LOAD; -- codepage not to be loaded
	AND	CS:[SI].SLT_AT,AT_NO_font; -- no font has been loaded
					;;
	MOV	AX,CS:[SI].SLT_CP	;;
	CMP	AX,0FFFFH		;;
	JZ	DST_SLTNXT		;;
					;;
	PUSH	CX			;;
	MOV	CX,CS:[BX]		;;
	CMP	CX,0FFFFH		;; if this slot to be replaced ?
	POP	CX			;;
	JNZ	DST_SLTREPLACED 	;; YES, the buffer is not empty
					;;
					;; compare code page with SLOT-BUFFER
	PUSH	CX			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; SCAN THE BUFFER FOR DUPLICATION
	PUSH	DX			;;
	POP	CX			;; no. of buffer entries
					;;
	PUSH	ES			;;
	PUSH	DI			;;
	PUSH	CS			;;
	POP	ES			;;
	REPNE	SCASW			;; scan codepage vs. buffer
	POP	DI			;;
	POP	ES			;;
					;;
	POP	CX			;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
	JNE	SLT_BUF_DEF		;;
					;;
					;; **** LOOP EXIT ****
					;;
	POP	BX			;;
	POP	CX			;; number of codepages in slots
	POP	SI			;; first entry in RAM/hardware slots
	POP	DX			;; count of buffer size
	POP	DI			;; (the start of RAM/Hardware buffer)
					;;
	MOV	AX,STAT_DUPLCP		;; Duplicated code page
	JMP	DST_RETURN		;;
					;;
					;;
SLT_BUF_DEF:				;;
	MOV	CS:[BX],AX		;; no duplicated cp, there was no cp in
					;; =**=
	OR	CS:[SI].SLT_AT,AT_OLD	;; mark old so as no new font download
					;;
	JMP	DST_SLTNXT		;; the MODE command for this position
					;;
DST_SLTREPLACED :			;;
	PUSH	BX			;;
	POP	AX			;; save the buffer slot-position
	POP	BX			;;
	OR	BUF.STATUS,REPLX	;; there are codepage in slots replaced
	PUSH	BX			;;
	PUSH	AX			;;
	POP	BX			;; gets back the buffer position
					;;
					;; **** NEXT IN LOOP ****
					;;
DST_SLTNXT:				;;
	INC	SI			;; will take whatever is in buffer
	INC	SI			;;
	INC	SI			;;
	INC	SI			;;
	INC	BX			;; position slot in buffer
	INC	BX			;;
	XOR	AX,AX			;;
	DEC	CX			;;
	JNZ	DST_SLTLP		;;
					;;
					;;
	POP	BX			;;
	POP	CX			;; slot size
	POP	SI			;; first entry in RAM/hardware slots
	POP	DX			;; count of buffer size
	POP	DI			;; (the start of RAM/Hardware buffer)
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;************************************
					;;* prepare the FTABLE		     *
					;;************************************
					;;
					;; -- CX slot / buffer size
					;;    SI slot
					;;    DI buffer
					;;------------------------------------
	PUSH	BX			;; STACK +1
	PUSH	SI			;; STACK +2
					;; =**=
	MOV	AX,FAIL 		;;
	NOT	AX			;;
	AND	BUF.STATUS,AX		;; assume it is successful
					;;
					;;
PREPARE_FTB :				;; Prepare for Font Parser
	LEA	BX,FTABLE		;;
	MOV	CS:[BX].FLAG,FLAG_RESTART;
	MOV	CS:[BX].BUFFER_LEN,0	;; no data packet
	MOV	CS:[BX].NUM_FTBLK,0	;;
					;;
	ADD	BX,TYPE FBUFS		;; points to the first FTBLK.
	XOR	DX,DX			;; DX = FTBLK entries (no code page yet)
					;;
					;;
GET_CODEPAGE :				;; **** LOOP ****
	AND	CX,CX			;;
	JZ	NO_MORE_SLOT		;;
	MOV	AX,CS:[SI].SLT_AT	;;
	AND	AX,AT_OLD		;;
	JZ	NEW_CODEPAGE		;;
					;;
	MOV	AX,CS:[SI].SLT_AT	;;
	AND	AX,AT_HWCP		;;
	JZ	GET_NEXT		;; not NEW and not HWCP
	AND	CS:[SI].SLT_AT, NOT AT_OLD  ;; also load for HWCP
					;;
NEW_CODEPAGE :				;;
	MOV	AX,CS:[DI]		;; -- SLOT_AT is not old
					;; -- code page in buffer is not 0FFFFH
	CMP	AX,0FFFFH		;;
	JE	GET_NEXT		;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	INC	DX			;; LOAD FONT as :
	MOV	AX,CS:[DI]		;; codepage in buffer is new code page
					;;
	OR	CS:[SI].SLT_AT,AT_LOAD	;; set the attribute indicating load
					;;
	MOV	CS:[BX].FTB_CP,AX	;;
					;;
	ADD	BX,type ftblk		;; next FTBLK
					;;
					;;
GET_NEXT :				;; **** NEXT IN LOOP ****
	INC	DI			;;
	INC	DI			;; next in buffer
	INC	SI			;;
	INC	SI			;;
	INC	SI			;;
	INC	SI			;; next in slot
	DEC	CX			;;
	JMP	GET_CODEPAGE		;;
					;;
NO_MORE_SLOT :				;; **** EXIT LOOP ****
	AND	DX,DX			;;
	JNZ	DEFINE_DID		;;
	JMP	NO_FONT_DOWNL		;;
					;;
					;; **********************************
					;; ** NEXT STATE = DESIGNATE_WRITE **
					;; **********************************
					;;
DEFINE_DID :				;;
	POP	SI			;; STACK -2
	POP	BX			;; STACK -1
					;;
	PUSH	BX			;; STACK +1
	PUSH	SI			;; STACK +2
					;;
	PUSH	DI			;; STACK +3
	PUSH	CX			;; STACK +4
	PUSH	ES			;; STACK +5
	PUSH	DS			;; STACK +6
					;;
	PUSH	CS			;;
	POP	ES			;;
	PUSH	CS			;;
	POP	DS			;;
					;;
	MOV	SI,BX			;; GET THE DEVICE_ID FROM LPTn BUFFER
	LEA	SI,[SI].PAR_EXTRACTO	;;
	MOV	SI,CS:[SI].PAR_DIDO	;;
	LEA	SI,[SI].PAR_DID 	;;
					;;
	LEA	DI,FTABLE		;;
	MOV	CS:[DI].NUM_FTBLK,DX	;;
					;;
	ADD	DI,TYPE FBUFS		;;
	LEA	DI,[DI].FTB_TID 	;;
					;;
SET_DID :				;;
	MOV	CX,8			;;
	PUSH	SI			;;
	PUSH	DI			;;
					;;
	REP	MOVSB			;;
					;;
	POP	DI			;;
	POP	SI			;;
					;;
	ADD	DI,TYPE FTBLK		;; next DID
	DEC	DX			;;
	JNZ	SET_DID 		;;
					;;
	POP	DS			;; STACK -6
	POP	ES			;; STACK -5
	POP	CX			;; STACK -4
	POP	DI			;; STACK -3
					;;
	CALL	FONT_PARSER		;; restart font parser
					;;
	LEA	BX,FTABLE		;;
	ADD	BX,TYPE FBUFS		;;
	CMP	CS:[BX].FTB_STATUS,FSTAT_SEARCH
					;;
	JE	FONT_DOWNL		;;
	MOV	AX,STAT_DEVERR		;;
	POP	SI			;; STACK -2
	POP	BX			;; STACK -1
	JMP	DST_RETURN		;; there is no designate_end if fails
					;;
FONT_DOWNL :				;;
	POP	SI			;; STACK -2
	POP	BX			;; STACK -1
	MOV	BUF.STATE,DESG_WR	;; enter DESIGNATE_WRITE state
	MOV	BUF.FSELEN,0		;; for font selection control loading
					;;
	PUSH	CX			;; init the font buffer address of
	PUSH	DI			;; each codepage
	PUSH	SI			;;
	MOV	DI,BUF.FTDLO		;;
					;;
	MOV	CX,BUF.RSLMX		;;
	MOV	AX,BUF.STATUS		;;
	AND	AX,DSF_CARTCP		;;
	JZ	FTDL_LOOP		;;
	MOV	CX,BUF.HSLMX		;;
					;;
FTDL_LOOP :				;;
	AND	CX,CX			;;
	JZ	FTDL_DONE		;;
	mov	ax,cs:[si].slt_at	;;
	and	ax,at_load		;;
	jz	ftdl_next		;;
					;;
	MOV	CS:WORD PTR[DI],0	;; the font length in font buffer is 0
					;;
ftdl_next :				;;
	INC	SI			;;
	INC	SI			;;
	INC	SI			;;
	INC	SI			;;
	INC	DI			;;
	INC	DI			;;
	DEC	CX			;;
	JMP	FTDL_LOOP		;;
FTDL_DONE :				;;
	POP	SI			;;
	POP	DI			;;
	POP	CX			;;
					;;
	JMP	CHECK_OTHER		;;
					;;
					;;  *******************************
					;;  ** NEXT STATE = DSIGNATE_END **
					;;  *******************************
NO_FONT_DOWNL : 			;;
	POP	SI			;; STACK -2
	POP	BX			;; STACK -1
	MOV	BUF.STATE,DESG_END	;; proper designate end, ignore write
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CHECK_OTHER :				;;
					;;
	MOV	DX,BUF.STATUS		;;
	MOV	AX,REPLX		;;
	NOT	AX			;;
	AND	AX,DX			;; reset the bit for "replaced"
	MOV	BUF.STATUS,AX		;;
					;;
	XOR	AX,AX			;;
	AND	DX,REPLX		;;
	JMP	DST_RETURN		;;
					;; only for the FIFO
	JMP	DST_RETURN		;;
					;;
					;;
DST_REFRESH:				;;  ******************************
					;;  **	REFRESH FONT TO DEVICE	**
					;;  ******************************
					;;  -- if there is RAM buffer on device
					;;  -- if there is font assumed to be
					;;     on the device, then
					;;  -- load the font to the device,
					;;     but no change in slot attributes
					;;
	OR	BUF.STATUS,REFRESH	;;  -- STATE = CPSW (for Designate_end)
					;;
	MOV	CX,BUF.RSLMX		;;
	AND	CX,CX			;;
	JNZ	DST_CHECK_FBUFFER	;;
	JMP	DST_REF_INVK		;; invoke any active code page
					;;
DST_CHECK_FBUFFER:			;;
	MOV	DI,BUF.RAMSO		;;
					;;
DST_RAMLP:				;;
	MOV	AX,CS:[DI].SLT_AT	;;
	AND	AX,AT_RAM1		;;
	JNZ	DST_RAM_LOCATED 	;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	DEC	CX			;;
	JNZ	DST_RAMLP		;;
	JMP	DST_REF_INVK		;; there was no font loaded
					;;
DST_RAM_LOCATED:			;;
	CMP	BUF.RBUFMX,0		;; ANY FONT BUFFER TO BE COPIED FROM ?
	JA	DST_HAS_BUFFER		;;
	MOV	AX,STAT_NOBUFF		;;
	mov  cs:init_chk,ax		;;
	JMP	DST_RETURN		;; ERROR !!!
					;;
DST_HAS_BUFFER :			;;
	SUB	DI,BUF.RAMSO		;; relative to .RAMSO
	SHR	DI,1			;; relative to .FTLDO
	PUSH	DI			;;
					;;
	SHR	DI,1			;; the nth
	MOV	CX,DI			;;
	MOV	AX,BUF.FTSTART		;;
					;;
DST_LOCATE_FT:				;;
	AND	CX,CX			;;
	JZ	DST_FT_LOCATED		;;
	ADD	AX,BUF.FTSZPA		;;
	DEC	CX			;;
	JNZ	DST_LOCATE_FT		;;
					;;
DST_FT_LOCATED: 			;;
					;;
	POP	DI			;;
	ADD	DI,BUF.FTDLO		;;
	MOV	CX,CS:WORD PTR [DI]	;;
					;;....................................
					;; DOWNLOAD THE FONT TO DEVICE
	MOV	SI,BUF.RNORMO		;;
	MOV	CS:[SI].RHC_LEN,20	;;
	MOV	CS:[SI].RHC_CMD,CMD_WRT ;;
	MOV	CS:[SI].RH3_CNT,CX	;;
	MOV	CS:[SI].RH3_DTAO,0	;;
	MOV	CS:[SI].RH3_DTAS,AX	;;
					;;
	PUSH	BX			;;
					;;
	PUSH	BX			;;
	POP	DI			;; save BX in DI
	PUSH	CS			;;
	POP	ES			;;
	MOV	BX,SI			;; ES:BX = REQ_NORMn (CS:[SI])
					;;
	CALL	DWORD PTR CS:[DI].LPT_STRAO
					;;
	CALL	DWORD PTR CS:[DI].LPT_INTRO
					;;
	POP	BX			;;
					;;
	MOV	AX,CS:[SI].RHC_STA	;;
					;;
	and	ax,stat_error		;;
	jz	fdl_good2		;;
	mov	ax,stat_deverr		;;
					;;
fdl_good2 :				;;
	PUSH	AX			;;
	AND	AX,STAT_ERROR		;;
	POP	AX			;;
	JZ	DST_REF_INVK		;;
					;;
					;;
DST_RETURN :				;;
	LES	DI,dword ptr buf.rh_ptro ;;
	MOV	RH.RHC_STA,AX		;;
					;;
	push	cs			;;
	pop	ds			;;
					;;
	RET				;;
					;;
					;;
DST_REF_INVK :				;; INVOKE FOR REFRESH
					;;
					;; ************************************
					;; * INVOKE HIERIECHY : RAM, HARDWARE *
					;; ************************************
					;;
	MOV	DI,BUF.RAMSO		;; check with the ram-slots  (DI)
	MOV	CX,BUF.RSLMX		;; CX = size
	AND	CX,CX			;;
	JZ	DST_HWCP_CHK		;;
					;;
DST_RAM_CMP:				;; there are RAM-slots
DST_RAM_LP:				;;
	MOV	AX,CS:[DI].SLT_AT	;;
	AND	AX,AT_ACT		;;
	JNZ	DST_IVK_CP		;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	DEC	CX			;;
	JNZ	DST_RAM_LP		;;
					;;
DST_HWCP_CHK :				;;
	MOV	DI,BUF.HARDSO		;; check with the HWCP-slots  (DI)
	MOV	CX,BUF.Hslmx		;; CX = size
	AND	CX,CX			;;
	JNZ	dst_HWCP_cmp		;;
	JMP	DST_NO_IVK		;;
					;;
DST_HWCP_CMP :				;;
DST_HWCP_LP:				;;
	MOV	AX,CS:[DI].SLT_AT	;;
	AND	AX,AT_ACT		;;
	JZ	DST_HWCP_NEXT		;;
	JMP	DST_IVK_CP		;;
					;;
DST_HWCP_NEXT : 			;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	DEC	CX			;;
	JNZ	DST_HWCP_LP		;;
					;;
DST_NO_IVK:				;;
	XOR	AX,AX			;;
	JMP	DST_RETURN		;;
					;;
DST_IVK_CP :				;;
	PUSH	SI			;;
					;;
	MOV	SI,BUF.RNORMO		;;
	MOV	AX,SI			;;
	ADD	AX,TYPE GIH		;; points to buffer
					;;
	PUSH	AX			;;
	LEA	SI,[SI].GIH_GBA 	;;
	MOV	CS:WORD PTR [SI],AX
	INC	SI			;;
	INC	SI			;;
	MOV	CS:WORD PTR [SI],CS	;;
	POP	SI			;;
	MOV	CS:[SI].GB2_LEN,2	;;
	MOV	AX,CS:[DI].SLT_CP	;;
	MOV	CS:[SI].GB2_CP,AX	;;
					;;
	POP	SI			;;
	PUSH	CS			;; define RH = ES:[DI]
	POP	ES			;;
	MOV	DI,BUF.RNORMO		;;
					;;
	push	cs			;;
	pop	ds			;;
					;;
	JMP	INVOKE			;;
					;;
DESIGNATE_START ENDP			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;====	Generic IOCTL Designate End  ======
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DESIGNATE_END PROC			;;
					;;
	MOV	AX,BUF.STATE		;;
	CMP	AX,LOCKED		;; WGR						 ;AN000;
	JNE	DE_01			;; WGR						 ;AN000;
	MOV	AX,STAT_BADDEN		;; WGR						 ;AN000;
	JMP	DE_11			;; WGR						 ;AN000;
DE_01:					;; WGR						 ;AN000;
	CMP	AX,CPSW 		;;
	JNE	DEN_NOT_CPSW		;;
	MOV	AX,BUF.STATUS		;; any refresh ?
	AND	AX,REFRESH		;;
	JNZ	DEN_REFRESH		;;
	MOV	AX,STAT_BADDEN		;;
	JMP	DEN_FAIL		;;
					;;
DEN_REFRESH :				;;
	AND	BUF.STATUS,NOT REFRESH	;;
	XOR	AX,AX			;;
	JMP	DEN_RET 		;;
					;;
DEN_NOT_CPSW :				;;
	CMP	AX,NORMAL		;;
	JNE	den_NOT_NORMAL		;;
	JMP	NORM_DRIVER		;; not in the code page switching stage
					;;
den_NOT_NORMAL :			;;
	CMP	AX,DESG_END		;;
	JNE	den_other		;;
	JMP	den_ENDED		;;  end with no error check
					;;
den_other :				;;
	CMP	AX,DESG_WR		;;
	JE	den_write		;;
	MOV	AX,STAT_BADDEN		;;
	JMP	DEN_FAIL		 ;; no designate start
					;;-------------------------
den_write :				;; DESIGNATE WRITE ended
					;;
	MOV	AX,BUF.STATUS		;;
	AND	AX,FAIL 		;;
	JZ	DEN_FTABLE		;; failed in the middle of desig-write
	XOR	AX,AX			;;
	JMP	DEN_FAIL		 ;; ignore the DEN
					;;
DEN_FTABLE :				;;
					;;
	LEA	DI,FTABLE		;;
	ADD	DI,TYPE FBUFS		;;
	MOV	AX,CS:[DI].FTB_STATUS	;;
	CMP	AX,FSTAT_COMPLETE	;;
	JE	DEN_ENDED		;;
					;;
	CMP	AX,FSTAT_FONT		;;
	JE	DEN_FONT		;;
	MOV	AX,STAT_bffDEN		;; bad font file
	JMP	DEN_FAIL		 ;; the font data was not complete
					;;
DEN_FONT :				;;
	MOV	AX,CS:[DI].FTB_DLEFT	;;
	AND	AX,AX			;;
	JZ	DEN_ENDED		;;
	MOV	AX,STAT_BffDEN		;;
	JMP	DEN_FAIL		 ;;
					;;
DEN_ENDED :				;; good designate-end
					;;
	MOV	DI,BUF.HARDSO		;; to hardware slot
	MOV	SI,BUF.HRBUFO		;; to hardware-buffer
HARD_HWCPE:				;;
	MOV	AX,CS:[DI].SLT_AT	;; skip the HWCP
	AND	AX,AT_HWCP		;;
	JZ	HARD_CARTE		;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	INC	SI			;;
	INC	SI			;;
	JMP	HARD_HWCPE		;;
HARD_CARTE:				;;
	MOV	CX,BUF.HSLMX		;; size of both hardware slot/buffer
	SUB	CX,BUF.HARDMX		;; slots that can be designated????????
	MOV	AX,BUF.STATUS		;;
	AND	AX,DSF_CARTCP		;;
	JZ	ASSIGN_RAM		;;
					;;
					;;
	MOV	AX,STAT_TOMANY		;;
	AND	CX,CX			;; any cart-slot to be designated ?
	JNZ	ASSIGN_CP_CART		 ;;
	JMP	DEN_FAIL		 ;;
					;;
					;;
ASSIGN_CP_CART :			;;
	JMP	ASSIGN_CP		;;
					;;
ASSIGN_RAM:				;;
	MOV	DI,BUF.RAMSO		;; to RAM slot
	MOV	SI,BUF.RMBUFO		;; to RAM-buffer
	MOV	CX,BUF.RSLMX		;; size of both RAM slot/buffer
					;;
	MOV	AX,STAT_TOMANY		;;
	AND	CX,CX			;; any cart-slot to be designated ?
	JNZ	ASSIGN_CP		 ;;
	JMP	DEN_FAIL		 ;;
					;;
ASSIGN_CP:				;;
	MOV	AX,AT_LOAD		;;
	OR	AX,AT_FONT		;;
	OR	AX,AT_SELECT		;;
	NOT	AX			;;
	AND	CS:[DI].SLT_AT,AX	;; reset load, font, select attributes
					;;
	MOV	AX,CS:[SI]		;; code page assigned
	MOV	CS:[DI].SLT_CP,AX	;;
					;;
	CMP	AX,0FFFFH		;;
	JNE	SLOT_OCC		;;
	MOV	AX,AT_OCC		;;
	NOT	AX			;; empty
	AND	CS:[DI].SLT_AT,AX	;;
	JMP	ASSIGN_NEXT		;;
SLOT_OCC:				;;
	OR	CS:[DI].SLT_AT,AT_OCC	;; occupied
					;;
	MOV	AX,CS:[DI].SLT_AT	;;
	AND	AX,AT_OLD		;;
	JNZ	ASSIGN_NEXT		;;
					;;
NOT_ACTIVE:				;; this newly designated is not active
	MOV	AX,AT_ACT		;;
	NOT	AX			;;
	AND	CS:[DI].SLT_AT,AX	;;    not active
	CMP	BUF.RBUFMX,0		;;
	JE	ASSIGN_NEXT		;;
	AND	CS:[DI].SLT_AT,NOT AT_RAM1;;  not loaded to physical RAM until
					;;    the code page is selected
ASSIGN_NEXT :				;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	INC	SI			;;
	INC	SI			;;
	DEC	CX			;;
	AND	CX,CX			;;
	JNE	ASSIGN_CP		;;
					;;
	MOV	CX,BUF.FSELEN		;; COPY SELECT-CONTROL for CLASS 0
	AND	CX,CX			;;
	JZ	DEN_NO_SELECT		;;
					;;
	PUSH	ES			;;
	PUSH	DS			;;
	PUSH	SI			;;
	PUSH	DI			;;
					;;
	PUSH	CS			;;
	POP	ES			;;
	PUSH	CS			;;
	POP	DS			;;
					;;
	PUSH	DX			;;
	MOV	DI,BUF.PDESCO		;;
	MOV	SI,CS:[DI].SELB_O	;;
	PUSH	DI			;;
	MOV	DI,CS:[DI].SELH_O	;;
	XOR	DX,DX			;;
	MOV	DL,CS:BYTE PTR [SI]	;;
	ADD	DX,DI			;;
	INC	DX			;; of the length byte
					;;
	REP	MOVSB			;;
					;;
	POP	DI			;;
	MOV	CS:[DI].SELR_O,DX	;;
	POP	DX			;;
					;;
	POP	DI			;;
	POP	SI			;;
	POP	DS			;;
	POP	ES			;;
					;;
	MOV	BUF.FSELEN,0		;;
					;;
DEN_NO_SELECT : 			;;
	XOR	AX,AX			;; clear status
	JMP	DEN_RET 		;;
					;;
DEN_FAIL :				;;------------------------------------
	PUSH	AX			;; ANY FONT BUFFER DESTROYED ?
					;;
	MOV	AX,BUF.STATUS		;;
	AND	AX,DSF_CARTCP		;;
	JZ	DEN_RAM_FAIL		;;
					;;
	MOV	DI,BUF.FTSLOTO		;;
	MOV	CX,BUF.HSLMX		;;
	JMP	DEN_FAIL_LOOP		;;
					;;
DEN_RAM_FAIL :				;;
	MOV	DI,BUF.RAMSO		;; to RAM slot
	MOV	CX,BUF.RSLMX		;; size of both RAM slot/buffer
	MOV	DX,BUF.RBUFMX		;;
					;;
	AND	DX,DX			;;
	JZ	DEN_FAIL_RET		;;
					;;
DEN_FAIL_LOOP : 			;;
	AND	CX,CX			;;
	JZ	DEN_FAIL_RET		;;
					;;
	MOV	AX,CS:[DI].SLT_AT	;;
	AND	AX,AT_LOAD		;;
	JZ	DEN_FAIL_NEXT		;;
					;;
	MOV	AX,CS:[DI].SLT_AT	;;
	AND	AX,AT_HWCP		;;
	JNZ	DEN_FAIL_NEXT		;;
					;;
	MOV	CS:[DI].SLT_CP,0FFFFH	;; those slot whose font has been or
	MOV	CS:[DI].SLT_AT,0	;; to be loaded will be wiped out by
					;; a failing designate
DEN_FAIL_NEXT : 			;;
					;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	DEC	CX			;;
	JNE	DEN_FAIL_LOOP		;;
					;;
DEN_FAIL_RET :				;;
					;;
	POP	AX			;;
					;;
	MOV	BUF.FSELEN,0		;;
					;;
					;;-------------------------------------
DEN_RET :				;;
	MOV	BUF.STATE,CPSW		;; end of designate cycle
					;;
DE_11:					;; WGR						 ;AN000;
	LES	DI,dword ptr buf.rh_ptro ;;
	MOV	RH.RHC_STA,AX		;;
					;;
	RET				;;
					;;
DESIGNATE_END ENDP			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;====	Generic IOCTL Invoke  ==========
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
INVOKE	PROC				;; ALSO JUMP FROM REFRESH
					;;
	MOV	AX,BUF.STATE		;;
	CMP	AX,CPSW 		;;
	JE	IVK_PROCESS		;;
	CMP	AX,LOCKED		;; WGR						 ;AN000;
	JE	IVK_PROCESS		;; WGR						 ;AN000;
	JMP	IVK_CMDERR		;G;
IVK_PROCESS:				;;-------------------------
					;G;
	CALL	CHECK_PRINT_ACTIVE	;G; THIS WILL FIND OUT IF THE
	JNC	IVK_PROCESS_CONT	;G; PRINT.COM IS PRESENTLY ACTIVE!
	JMP	IVK_DEVERR		;G; If so, THEN DEVICE_ERROR
					;G;
IVK_PROCESS_CONT:			;G;
	push	ds			;;
	LDS	SI,RH.GIH_GBA		;;
	MOV	CX,GIOB.GB2_LEN 	;;
	MOV	AX,STAT_CMDERR		;;
	CMP	CX,2			;;
	JE	IVK_GOODN		;;
	pop	ds			;;
	JMP	IVK_RET 		;;
IVK_GOODN:				;;
	MOV	DX,GIOB.GB2_CP		;; DX = the codepage to be invoked
	CMP	DX,0FFFFH		;;
	JNE	IVK_GOODCP		;;
	pop	ds			;;
	JMP	IVK_RET 		;;
IVK_GOODCP:				;;
					;; ************************************
					;; * INVOKE HIERIECHY : RAM, HARDWARE *
					;; ************************************
	pop	ds			;;
					;;
	MOV	DI,BUF.RAMSO		;; check with the ram-slots  (DI)
	MOV	CX,BUF.RSLMX		;; CX = size
	AND	CX,CX			;;
	JZ	HWCP_CHK		;;
					;;
RAM_CMP:				;; there are RAM-slots
	PUSH	CX			;; stack 1 = size
	PUSH	DI			;;
	POP	SI			;; start of the slot compared with (SI)
RAM_LP: 				;;
	MOV	AX,CS:[DI].SLT_CP	;;
	CMP	AX,DX			;;
	JE	IVK_RAMCP		;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	DEC	CX			;;
	JNZ	RAM_LP			;;
					;;
	POP	CX			;; stack -1
					;; code page not found in ram-slots
HWCP_CHK :				;;
	MOV	DI,BUF.HARDSO		;; check with the HWCP-slots  (DI)
	MOV	CX,BUF.Hslmx		;; CX = size
	AND	CX,CX			;;
	JNZ	HWCP_cmp		;;
	JMP	NO_INVOKE		;;
					;;
HWCP_CMP :				;;
	PUSH	CX			;; stack 1 = size of HWCP
	PUSH	DI			;;
	POP	SI			;; start of the slot compared with (SI)
HWCP_LP:				;;
	MOV	AX,CS:[DI].SLT_CP	;;
	CMP	AX,DX			;;
	JNE	HWCP_NEXT		;;
	JMP	IVK_HWCPCP		;;
					;;
HWCP_NEXT :				;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	DEC	CX			;;
	JNZ	HWCP_LP 		;;
	POP	CX			;; stack -1
					;;
	JMP	NO_INVOKE		;;
					;; **********************************
					;; **  RAM CODEPAGE TO BE INVOKED  **
					;; **********************************
					;; -- determine if any font to be
					;;    downloaded for the first time
					;;    select of the font.
					;; -- send selection control to invoke
					;;
					;; CX = inverse order of slot cp found
IVK_RAMCP :				;; code page found in RAM slots
					;; set up the pointer to first controls
					;; DI = where slot found
					;;
					;;-------------------------------------
					;; **** LOAD THE FONT FIRST  if ****
					;; -- there are font buffers created
					;; -- the slot's font has not been
					;;    loaded
	CMP	CS:[BX].STATE,LOCKED	;; WGR are we locked?				 ;AN000;
	JNE	IR_0			;; WGR no..continue				 ;AN000;
	MOV	CS:[BX].SAVED_CP,DX	;; WGR yes...save the code page 		 ;AN000;
	CMP	BX,OFFSET BUF1		;; WGR if this is lpt1..then			 ;AN000;
	JNE	NEXT_1			;; WGR						 ;AN000;
	LEA	SI,BUF0 		;; WGR copy to PRN buffer.			 ;AN000;
	MOV	CS:[SI].SAVED_CP,DX	;; WGR						 ;AN000;
	JMP	ALL_RESET		;; WGR						 ;AN000;
NEXT_1: 				;; WGR						 ;AN000;
	CMP	BX,OFFSET BUF0		;; WGR if this is PRN..then..			 ;AN000;
	JNE	NEXT_2			;; WGR						 ;AN000;
	LEA	SI,BUF1 		;; WGR copy to lpt1 buffer.			 ;AN000;
	MOV	CS:[SI].SAVED_CP,DX	;; WGR						 ;AN000;
NEXT_2: 				;; WGR						 ;AN000;
	JMP	ALL_RESET		;; WGR exit invoke with good status		 ;AN000;
IR_0:					;; WGR						 ;AN000;
;	 test	 cs:[di].SLT_AT, AT_ACT  ;AN001;If it is currently active, then do nothing
;	 jnz	 Next_2 		 ;AN001;
	CMP	BUF.RBUFMX,0		;;
	JE	INVK_RAM_PHYSICAL	;;
					;;
	MOV	AX,CS:[DI].SLT_AT	;;
	AND	AX,AT_RAM1		;; supports only ONE physical ram
	JNZ	INVK_RAM_PHYSICAL	;;
					;;
	OR	BUF.STATUS,LOADED	;; font has not been loaded
					;;
					;;
	POP	DX			;; stack -1
	PUSH	DX			;; stack  1  (size)
					;;
					;;
	PUSH	CX			;;
	PUSH	SI			;;
	PUSH	DI			;;
					;;
	SUB	DX,CX			;;
	MOV	AX,BUF.FTSTART		;;
LOCATE_FONT :				;;
	AND	DX,DX			;;
	JZ	FONT_LOCATED		;;
	ADD	AX,BUF.FTSZPA		;;
	DEC	DX			;;
	JMP	LOCATE_FONT		;;
					;;
FONT_LOCATED :				;;
					;; AX = FONT LOCATION (AX:0)
	SUB	DI,BUF.RAMSO		;;
	SHR	DI,1			;; offset to the start of .FTDLEN
					;;
	add	DI,buf.ftdlo		;; length of font data
	mov	cx,cs:word ptr [di]	;;


;Before sending data, let's check the status of the printer
	call	Prt_status_check	;AN001;Check the printer status
	jz	Send_Ram_Data		;AN001;O.K.?
	pop	di			;AN001;Balance the stack
	pop	si			;AN001;
	pop	cx			;AN001;
	jmp	Ram_Prt_Status_Err	;AN001;return with error.
Send_Ram_Data:
	MOV	SI,BUF.RNORMO		;;
	MOV	CS:[SI].RHC_LEN,20	;;
	MOV	CS:[SI].RHC_CMD,CMD_WRT ;;
	MOV	CS:[SI].RH3_CNT,CX	;;
	MOV	CS:[SI].RH3_DTAO,0	;;
	MOV	CS:[SI].RH3_DTAS,AX	;;
					;;
	PUSH	BX			;;
					;;
	PUSH	BX			;;
	POP	DI			;; save BX in DI
	PUSH	CS			;;
	POP	ES			;;
	MOV	BX,SI			;; ES:BX = REQ_NORMn (CS:[SI])
					;;
	CALL	DWORD PTR CS:[DI].LPT_STRAO
					;;
	CALL	DWORD PTR CS:[DI].LPT_INTRO
					;;
	POP	BX			;;
					;;
	MOV	AX,CS:[SI].RHC_STA	;;
					;;
	POP	DI			;;
	POP	SI			;;
	POP	CX			;;
					;;
	AND	AX,STAT_ERROR		;; any error returned by normal device?
	JZ	INVK_RAM_PHYSICAL	;;
					;;
Ram_Prt_Status_err:
	POP	CX			;; stack -1
	JMP	IVK_DEVERR		;;
					;;-------------------------------------
					;; **** SEND THE SELECTION CONTROL ****
					;;
INVK_RAM_PHYSICAL :			;;
					;;
	POP	DX			;; stack -1
	PUSH	DX			;; stack  1  (size)
					;;
	PUSH	DI			;; stack 2
	PUSH	SI			;; stack 3
	PUSH	ES			;; stack 4
					;;
					;;
					;; **** SUPPORT ONLY ONE PHYSICAL RAM
					;;
	MOV	DI,BUF.PDESCO		;;
	MOV	DI,CS:[DI].SELR_O	;; the RAM-select controls
	XOR	AX,AX			;;
	JMP	CTL_DEF 		;;
					;;
					;; *******************************
					;; ** INVOKE HARDWARE CODEPAGE	**
					;; *******************************
					;; -- check if it is CLASS 1 device,
					;;    If so then send slection control
					;;    from the font buffer at FTSTART
					;;
					;; CX=inverse order of slot cp found
IVK_HWCPCP:				;; code page found in HWCP slots
					;; set up the pointer to first controls
	CMP	CS:[BX].STATE,LOCKED	;; WGR are we locked?				 ;AN000;
	JNE	IR_1			;; WGR no..continue				 ;AN000;
	MOV	CS:[BX].SAVED_CP,DX	;; WGR yes...save the code page 		 ;AN000;
	CMP	BX,OFFSET BUF1		;; WGR if this is lpt1..then			 ;AN000;
	JNE	NEXT_3			;; WGR						 ;AN000;
	LEA	SI,BUF0 		;; WGR copy to PRN buffer.			 ;AN000;
	MOV	CS:[SI].SAVED_CP,DX	;; WGR						 ;AN000;
	JMP	ALL_RESET		;; WGR						 ;AN000;
NEXT_3: 				;; WGR						 ;AN000;
	CMP	BX,OFFSET BUF0		;; WGR if this is PRN..then..			 ;AN000;
	JNE	NEXT_4			;; WGR						 ;AN000;
	LEA	SI,BUF1 		;; WGR copy to lpt1 buffer.			 ;AN000;
	MOV	CS:[SI].SAVED_CP,DX	;; WGR						 ;AN000;
NEXT_4: 				;; WGR						 ;AN000;
	JMP	ALL_RESET		;; WGR exit invoke with good status		 ;AN000;
IR_1:					;; WGR						 ;AN000;
;	 test	 cs:[di].SLT_AT, AT_ACT  ;AN001;If it is currently active, then do nothing
;	 jnz	 Next_4 		 ;AN001;
	POP	DX			;; stack -1
	PUSH	DX			;; stack  1  (size)
					;;
	PUSH	DI			;; stack 2
	PUSH	SI			;; stack 3
	PUSH	ES			;; stack 4
					;;
	SUB	DX,CX			;; the slot's order in HWCP-slots(0-n)
					;;
	CMP	BUF.PCLASS,1		;;
	JNE	SELECT_SLOT		;;
					;;
	MOV	AX,BUF.FTSTART		;; ***** CLASS 1 CODEPAGE SELECT  ****
	AND	DX,DX			;;
	JZ	ADJUST_DI		;;
					;;
SELECTCP_LP :				;;
	ADD	AX,BUF.FTSZPA		;;
					;;
	DEC	DX			;;
	JNZ	SELECTCP_LP		;;
					;;
ADJUST_DI :				;;
	mov	DI,AX			;;
	PUSH	CS			;;
	POP	AX			;;
	SUB	DI,AX			;;
	SHL	DI,1			;;
	SHL	DI,1			;;
	SHL	DI,1			;;
	SHL	DI,1			;;
	JMP	CTL_DEF 		;;
					;;
					;; ** SELECT HARDWARE PHYSICAL SLOT **
SELECT_SLOT :				;;
	MOV	DI,BUF.PDESCO		;;
	MOV	DI,CS:[DI].SELH_O	;; the HARDWARE-select controls
	XOR	AX,AX			;;
	JMP	RCTL_NXT		;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RCTL_NXT:				;; locate the right control sequence
	AND	DX,DX			;;
	JZ	CTL_DEF 		;;
	MOV	AL,CS:[DI]		;;
	ADD	DI,AX			;;
	DEC	DX			;;
	JMP	RCTL_NXT		;;
					;;
					;; ********************************
					;; ** SEND OUT SELECTION CONTROL **
					;; ********************************
					;;
					;; code page is to be invoked
CTL_DEF :				;; DI points to the control sequence
;Check the status of the printer before writing.
	call	Prt_status_check	;AN001;Check the printer status
	jz	Ctl_Def_Send		;AN001;O.K.?
	jmp	Ctl_Dev_Err		;AN001;Error.

Ctl_Def_Send:
	MOV	SI,BUF.RNORMO		;;
	MOV	CS:[SI].RHC_LEN,20	;;
	MOV	CS:[SI].RHC_CMD,CMD_WRT ;;
					;;
	XOR	CX,CX			;;
	MOV	CL,CS:[DI]		;;
					;;
CTL_NEXT_BYTE : 			;;
					;;
	CMP	BUF.PCLASS,1		;;
	JE	CTL_CLASS1		;;
					;;
	MOV	CS:[SI].RH3_CNT,CX	;; send all at once
	MOV	CX,1			;; sent only once.
	JMP	CTL_COMMON		;;
					;;
CTL_CLASS1 :				;; sent byte by byte to overcome
	MOV	CS:[SI].RH3_CNT,1	;; DOS timeout on kingman printer
CTL_COMMON :				;;
	INC	DI			;;
	MOV	CS:[SI].RH3_DTAO,DI	;;
	PUSH	CS			;;
	POP	AX			;;
	MOV	CS:[SI].RH3_DTAS,AX	;;
					;;
	PUSH	DI			;;
	PUSH	BX			;;
					;;
	PUSH	BX			;;
	POP	DI			;; save BX in DI
	PUSH	CS			;;
	POP	ES			;;
	MOV	BX,SI			;; ES:BX = REQ_NORMn (CS:[SI])
					;;
	CALL	DWORD PTR CS:[DI].LPT_STRAO
					;;
	CALL	DWORD PTR CS:[DI].LPT_INTRO
					;;
	POP	BX			;;
	POP	DI			;;
					;;
	MOV	AX,CS:[SI].RHC_STA	;;
					;;
	AND	AX,STAT_ERROR		;; any error returned by normal device?
	JNZ	CTL_DEV_ERR		;;
	DEC	CX			;;
	JNZ	CTL_NEXT_BYTE		;;
					;;
	POP	ES			;; stack -4
	POP	SI			;; stack -3
	POP	DI			;; stack -2
	JMP	IVK_CP			;;
					;;
CTL_DEV_ERR :				;;
	POP	ES			;; stack -4
	POP	SI			;; stack -3
	POP	DI			;; stack -2
	POP	CX			;; stack -1
	JMP	IVK_DEVERR		;;
					;;
					;; **********************************
					;; ** ADJUST WHICH CODEPAGE TO BE  **
					;; ** ACTIVE			   **
					;; **********************************
					;;
					;; -- set the attribute bit of the
					;;    slot (SLT_AT) to active for
					;;    the code page just invoked.
					;; -- reset others to non-active.
					;;
					;;
IVK_CP: 				;; SI = start of the slots compared
					;; DI = where code page was found
	POP	CX			;; stack -1
	PUSH	SI			;; stack 1 = start of slots compared
	mov	AX,BUF.STATUS		;;
	AND	AX,LOADED		;;
	MOV	AX,AT_ACT		;;
	JZ	NO_LOAD 		;;
	OR	AX,AT_RAM1		;; reset loaded to physical RAM #1,
					;; this is reset only when there is
					;; font loading in this round of invoke
NO_LOAD:				;; (for RAM codepages only)
	NOT	AX			;;
NXT_CP: 				;;
	AND	CS:[SI].SLT_AT,AX	;; not active (and not loaded)
	INC	SI			;;
	INC	SI			;;
	INC	SI			;;
	INC	SI			;;
	DEC	CX			;;
	JNZ	NXT_CP			;;
	OR	CS:[DI].SLT_AT,AT_ACT	;; the codepage found becomes active
	MOV	AX,BUF.STATUS		;;
	AND	AX,LOADED		;;
	JZ	HWCP_RESET		;;
	OR	CS:[DI].SLT_AT,AT_RAM1	;; the font has just been loaded
	AND	BUF.STATUS,NOT LOADED	;;
					;;
HWCP_RESET :				;;
					;;
	POP	SI			;; stack -1 (slot : ATs adjusted )
	PUSH	SI			;; stack 1 = start of slots compared
					;;
	MOV	DI,BUF.HARDSO		;;
	CMP	SI,DI			;;
	JE	RAM_RESET		;;
					;; HWCP's AT to be reset
	MOV	CX,BUF.HSLMX		;;
	AND	CX,CX			;;
	JZ	RAM_RESET		;;
	MOV	AX,AT_ACT		;;
	NOT	AX			;;
RESET_HWCP :				;;
	AND	CS:[DI].SLT_AT,AX	;; HWCP is not active
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	DEC	CX			;;
	JNZ	RESET_HWCP		;;
					;;
					;;
RAM_RESET:				;;
					;;
	POP	SI			;; stack -1 (slot : ATs adjusted )
	PUSH	SI			;; stack 1 = start of slots compared
					;;
	MOV	DI,BUF.RAMSO		;;
	CMP	SI,DI			;;
	JE	ALL_RESET		;;
					;; HWCP's AT to be reset
	MOV	CX,BUF.RSLMX		;;
	AND	CX,CX			;; HWCP's no.
	JZ	ALL_RESET		;;
	MOV	AX,AT_ACT		;;
	NOT	AX			;;
RESET_RAM :				;;
	AND	CS:[DI].SLT_AT,AX	;; HWCP is not active
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	DEC	CX			;;
	JNZ	RESET_RAM		;;
					;;
ALL_RESET :				;;
	POP	SI			;; stack -1
					;;
	XOR	AX,AX			;;
	JMP	IVK_RET 		;;
					;;
NO_INVOKE :				;;
					;;
	MOV	AX,STAT_NOCPIV		;;
	JMP	IVK_RET 		;;
					;;
IVK_DEVERR :				;;
	MOV	AX,STAT_DEVERR		;;
	JMP	IVK_RET 		;G;
					;;
IVK_CMDERR :				;G;
	MOV	AX,STAT_CMDERR		;G;
					;;
IVK_RET :				;;
	LES	DI,dword ptr buf.rh_ptro;;
	MOV	RH.RHC_STA,AX		;;
					;;
	RET				;;
					;;
INVOKE	ENDP				;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Prt_Status_Check	proc	near		;AN001;
;Check the printer device status
;Out) if Zero flag set - Ok.
;     All registers saved.

	push	es				;AN001;
	push	si				;AN001;

	mov	si, BUF.RNORMO			;AN001;
	mov	cs:[si].RHC_LEN, 13		;AN001;
	mov	cs:[si].RHC_CMD, 10		;AN001;device driver status check

	push	di				;AN001;
	push	bx				;AN001;

	push	bx				;AN001;
	pop	di				;AN001;
	push	cs				;AN001;
	pop	es				;AN001;ES:BX -> REQ_NORMn (was cs:si)
	mov	bx, si				;AN001;

	call	dword ptr cs:[di].LPT_STRAO	;AN001;Strategy
	call	dword ptr cs:[di].LPT_INTRO	;AN001;Intrrupt
	test	cs:[si].RHC_STA, STAT_ERROR	;AN001;
	pop	bx				;AN001;
	pop	di				;AN001;

	pop	si				;AN001;
	pop	es				;AN001;
	ret					;AN001;
Prt_Status_Check	endp			;AN001;



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;====	Generic IOCTL Query Invoked  =======
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
Q_INVOKED PROC				;;
	push	ds			;;
					;;
	MOV	AX,BUF.STATE		;; ???????????????
	CMP	AX,LOCKED		;; WGR						 ;AN000;
	JNE	QI_0			;; WGR						 ;AN000;
	MOV	AX,BUF.SAVED_CP 	;; WGR						 ;AN000;
	LDS	SI,RH.GIH_GBA		;; WGR						 ;AN000;
	CMP	AX,-1			;; WGR						 ;AN000;
	JE	QIV_NOACT		;; WGR						 ;AN000;
	JMP	QI_1			;; WGR						 ;AN000;
QI_0:					;; WGR						 ;AN000;
	CMP	AX,CPSW 		;; reject only in NORMAL !!!!
	JNE	QIV_CMDERR		;G;
					;;-------------------------
	LDS	SI,RH.GIH_GBA		;;
					;;
	MOV	DI,BUF.RAMSO		;;
	MOV	CX,BUF.RSLMX		;;
	AND	CX,CX			;;
	JZ	QIV_HARD		;;
					;;
QIV_RAMLP :				;;
	MOV	AX,CS:[DI].SLT_AT	;; check the RAM slots
	AND	AX,AT_ACT		;;
	JNZ	QIV_FOUND		;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	DEC	CX			;;
	JNZ	QIV_RAMLP		;;
					;;
QIV_HARD :				;;
	MOV	DI,BUF.HARDSO		;;
	MOV	CX,BUF.HSLMX		;;
	AND	CX,CX			;;
	JZ	QIV_NOACT		;;
					;;
QIV_HARDLP :				;;
	MOV	AX,CS:[DI].SLT_AT	;; check the RAM slots
	AND	AX,AT_ACT		;;
	JNZ	QIV_FOUND		;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	DEC	CX			;;
	JNZ	QIV_HARDLP		;;
					;;
QIV_NOACT :				;;
					;;
	MOV	AX,STAT_NOCPIV		;;
	JMP	QIV_RET 		;;
					;;
					;;
QIV_FOUND :				;;
	MOV	AX,CS:[DI].SLT_CP	;;
QI_1:					;; WGR						 ;AN000;
	MOV	GIOB.GB2_LEN,2		;;
	MOV	GIOB.GB2_CP,AX		;;
					;;
	XOR	AX,AX			;;
	JMP	QIV_RET 		;;
					;;
QIV_DEVERR :				;;
	MOV	AX,STAT_DEVERR		;;
	JMP	QIV_RET 		;G;
					;;
QIV_CMDERR :				;G;
	MOV	AX,STAT_CMDERR		;G;
					;;
QIV_RET :				;;
	LES	DI,dword ptr buf.rh_ptro ;;
	MOV	RH.RHC_STA,AX		;;
					;;
	pop	ds			;;
					;;
	RET				;;
					;;
Q_INVOKED ENDP				;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;====	Generic IOCTL Query List  =======
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Q_LIST	PROC				;;
					;;
	push	ds			;;
					;;
	MOV	AX,BUF.STATE		;;  ????????????????
	CMP	AX,CPSW 		;; reject only in NORMAL
	JE	QLS_CPSW		;;
	CMP	AX,LOCKED		;; WGR						 ;AN000;
	JE	QLS_CPSW		;; WGR						 ;AN000;
	JMP	QLS_CMDERR		;G;
QLS_CPSW :				;;-------------------------
	LDS	SI,RH.GIH_GBA		;;
	PUSH	SI			;; stack 1 -- GB3 (SI)
					;;
	MOV	DI,BUF.HARDSO		;;
	MOV	CX,BUF.HARDMX		;;
	MOV	DX,BUF.HSLMX		;; DX = number of entries
	LEA	SI,[SI].GB3_GBL 	;;
	MOV	GIOB.GBL_LEN,CX 	;;
					;;
QL_HARDLP:				;;
	AND	CX,CX			;;
	JZ	QL_PREPARE		;;
	MOV	AX,CS:[DI].SLT_CP	;;
	MOV	GIOB.GBL_CP,AX		;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	INC	SI			;;
	INC	SI			;;
	DEC	CX			;;
	JMP	QL_HARDLP		;;
					;;
QL_PREPARE:				;;
	MOV	CX,BUF.HSLMX		;;
	SUB	CX,BUF.HARDMX		;; less the no. of HWCP
	MOV	DX,BUF.RSLMX		;;
	ADD	DX,CX			;; DX = total number of entries
	INC	SI			;;
	INC	SI			;;
	MOV	GIOB.GBL_LEN,DX 	;;
QL_CARTLP:				;;
	AND	CX,CX			;;
	JZ	QL_RAM_PREP		;;
	MOV	AX,CS:[DI].SLT_CP	;;
	MOV	GIOB.GBL_CP,AX		;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	INC	SI			;;
	INC	SI			;;
	DEC	CX			;;
	JMP	QL_CARTLP		;;
					;;
					;;
QL_RAM_PREP:				;;
	MOV	DI,BUF.RAMSO		;;
	MOV	CX,BUF.RSLMX		;;
					;;
QL_RAMLP :				;;
	AND	CX,CX			;;
	JZ	QL_DONE 		;;
	MOV	AX,CS:[DI].SLT_CP	;;
	MOV	GIOB.GBL_CP,AX		;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	INC	DI			;;
	INC	SI			;;
	INC	SI			;;
	DEC	CX			;;
	JMP	QL_RAMLP		;;
					;;
QL_DONE:				;;
	POP	SI			;; stack -1
	mov	dx,buf.hslmx		;;
	add	DX,BUF.RSLMX		;;
	INC	DX			;;
	INC	DX			;;
	MOV	CX,1			;;
	SHL	DX,CL			;;
	MOV	GIOB.GB3_LEN,DX 	;;
					;;
	XOR	AX,AX			;;
	CMP	DX,GB3_MINILEN		;; min. GBL length
	JA	QLS_RET 		;;
	MOV	AX,STAT_NOCP		;;
	JMP	QLS_RET 		;;
					;;
QLS_DEVERR :				;;
	MOV	AX,STAT_DEVERR		;;
	JMP	QLS_RET 		;G;
					;;
QLS_CMDERR :				;G;
	MOV	AX,STAT_CMDERR		;G;
					;;
QLS_RET :				;;
	LES	DI,dword ptr buf.rh_ptro ;;
	MOV	RH.RHC_STA,AX		;;
					;;
	pop	ds			;;
	RET				;;
					;;
Q_LIST	ENDP				;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	CHECK_PRINT_ACTIVE
;
;	THIS ROUTINE IS CALLED BEFORE THE INVOKE, DESIGNATE
;	COMMANDS ARE OPERATED ON.  THIS IS TO PREVENT CONFLICT
;	BETWEEN THE BACKGROUND PRINTING AND THE DOWNLOAD SEQUENCE.
;
;	INPUT:
;		CS:[BX].DEV_HDRO  OFFSET AND SEGMENT OF ACTIVE DEVICE
;		CS:[BX].DEV_HDRS
;
;	WARNING:  IF ANOTHER DEVICE DRIVER IS TO TAKE THE LPTx, THEN
;		  THIS WILL not FIND OUT THAT THE PRINTER.SYS IS ACTIVE.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CHECK_PRINT_ACTIVE	PROC		;G;
	PUSH	AX			;G; SAVE THE REGISTERS............
	PUSH	SI			;G;
	PUSH	DI			;G;
	PUSH	DS			;G;
	PUSH	ES			;G;
					;G;
	MOV	DI,BUF.DEV_HDRS 	;G; SETUP ES: = ACTIVE DEVICE SEGMENT
	MOV	ES,DI			;G;		  &
	MOV	DI,BUF.DEV_HDRO 	;G; SETUP DI: = ACTIVE DEVICE OFFSET
					;G;
	MOV	AX,0106H		;G; PRINT (GET LIST DEVICE)
	CLC				;G;
	JNC	CPA_5			;G; CY=0 IF NOT LOADED/NOT ACTIVE
					;G;
	CMP	SI,DI			;G; ES:DI POINTS TO THE ACTIVE DEVICE
	JNE	CPA_5			;G;
	MOV	SI,DS			;G;
	MOV	DI,ES			;G;
	CMP	SI,DI			;G;
	JNE	CPA_5			;G;
	STC				;G; OTHERWISE, THIS DEVICE IS PRESENTLY
	JMP	CPA_6			;G; UNDER PRINT!!!  PREVENT DATASTREAM
					;G; CONFLICT IN THIS CASE.
					;G;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;G; PRINT.COM IS ASLEEP OR IS NOT
					;G; PRESENTLY LOADED.  THE PRINTER.SYS
CPA_5:	CLC				;G; CAN CONTINUE IT PROCESS!
CPA_6:	POP	ES			;G; RESTORE REGISTERS.....
	POP	DS			;G;
	POP	DI			;G;
	POP	SI			;G;
	POP	AX			;G;
	RET				;G;
CHECK_PRINT_ACTIVE	ENDP		;G;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



CSEG	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\printer\cpspi07.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

	PAGE	,132

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  FILENAME:		CPS Printer Device Driver INIT module (CPSPInn)
;;  MODULE NAME:
;;  TYPE:		Assemble file  (non-resident code)
;;  LINK PROCEDURE:	Link CPSPMnn+CPSFONT+CPSPInn into .EXE format. CPSPM01
;;			must be first.	CPSPInn must be last.  Everything
;;			before CPSPInn will be resident.
;;  INCLUDE FILES:
;;			CPSPEQU.INC
;;
;;  LAYOUT :		This file is divided into two main section :
;;			  ++++++++++++++++++++++++
;;			  ++	DEVICE Parser	++
;;			  ++++++++++++++++++++++++
;;
;;			  ++++++++++++++++++++++++
;;			  ++	INIT Command	++
;;			  ++++++++++++++++++++++++
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
INCLUDE CPSPEQU.INC			;;
INT2F_LOW	EQU	(4*2FH) 	;; WGR interrupt 2F vector location	    ;AN000;
INT2F_HI	EQU	(4*2FH)+2	;; WGR					    ;AN000;
					;;
.XLIST					;;
INCLUDE SYSMSG.INC			;; WGR					    ;AN000;
.LIST					;;
					;;
MSG_UTILNAME <PRINTER>			;; WGR					    ;AN000;
					;;
PUBLIC	INIT				;;
PUBLIC	CODE_END			;; for MAP listing only
PUBLIC	RESIDENT_END			;;
PUBLIC	STACK_ALLOCATED 		;;
					;;
					;;
EXTRN	PRINTER_DESC_NUM:WORD		;;
EXTRN	PRINTER_DESC_TBL:WORD		;;
EXTRN	INIT_CHK:WORD,TABLE:WORD	;;
EXTRN	HARD_SL1:BYTE,RAM_SL1:BYTE	;;
EXTRN	HARD_SL2:BYTE,RAM_SL2:BYTE	;;
EXTRN	HARD_SL3:BYTE,RAM_SL3:BYTE	;;
EXTRN	HARD_SL4:BYTE,RAM_SL4:BYTE	;;
EXTRN	RESERVED1:WORD,RESERVED2:WORD	;;
					;;
					;;
					;;
CSEG	SEGMENT PARA PUBLIC 'CODE'      ;;
	ASSUME	CS:CSEG 		;;
					;;
					;;
EXTRN	PARSER:NEAR			;; WGR					    ;AN000;
EXTRN	ROM_INT2F:WORD			;; WGR					    ;AN000;
EXTRN	INT2F_COM:NEAR			;; WGR					    ;AN000;
EXTRN	ABORT:BYTE			;; WGR					    ;AN000;

CODE_END     EQU $			;; end of resident code
					;;
	     DW  0			;; -- there are 16 bytes kept,
					;;    including this word
					;;
RESIDENT_END DW  0FFFH			;; end of extended resident area
STACK_ALLOCATED  DW -1			;; end of extended resident area
					;;
	     DW  150 DUP(0)		;; need some space here.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	End of resident code
;;
;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;;
;;			  ++++++++++++++++++++++++
;;			  ++	INIT Command	++
;;			  ++++++++++++++++++++++++
;;
;;====	Command Code 0 - Initialization  ======
;;
;; messages returned :
;;
;; msg_bad_syntax  -- syntax error from parser, no driver installation
;; msg_no_init	   -- device cannot be initialised
;; msg_insuff_mem  -- insufficient memory
;;
;; layout :	the initialization is done in two stages :
;;
;;		  ++++++++++++++++++++++++
;;		  ++   INIT Stage 1	++	to examine and extract the
;;		  ++++++++++++++++++++++++	parameters defined for the
;;						device_id in DEVICE command,
;;						according to the printer
;;						description table for the
;;						device_id.
;;
;;		  ++++++++++++++++++++++++
;;		  ++   INIT Stage 2	++	to set the BUFfer for the LPTn
;;		  ++++++++++++++++++++++++	or PRN according to device_id's
;;						parameters
;;
;;
;;
;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
					;;
DEV_NUM dw	?			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;     Tables for the deivce_id parameters in the order of device_id in the
;     PARSE table
;     === the tables serves as the link between LPTn to be defined in the 2nd
;	  stage, and the device_id that is processed in the first stage.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; device ID indicators :
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DID_MAX EQU	4			;; device entris exepcted in PARSE
;; not more than 16.			;; table
					;;
DID_STATUS DW	0			;; status of parsing device id
					;;  =  0 : all Device-ID bad
					;;  -- see DID_BIT
					;;
DID_MATCH  DW	0			;; this DID has device_name matched
					;;
DID_FAIL   DW	0			;; to fail the good DID_STATUS and
					;; the matched name. (due to
					;; inconsistency among the same LPTn
					;; or between PRN and LPT1.)
					;;
;; (DID_STATUS) AND (DID_MATCH) XOR (DID_FAIL) determines the success of DID
					;;		       initialization
					;;
DID_ONE EQU	00001H			;; first device-ID
DID_TWO EQU	00002H			;; second "
DID_THREE EQU	  00004H		;; third  "
DID_FOUR  EQU	  00008H		;; fourth "
;;maximun number of device_id = 16	;;
					;;
DID_BIT LABEL WORD			;;
	DW	DID_ONE 		;;
	DW	DID_TWO 		;;
	DW	DID_THREE		;;
	DW	DID_FOUR		;;
;;maximun number of device_id = 16	;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; device paramters according to the
					;; device_id defined in DEVICE and the
					;; parameters defined for the device_id
					;; in the printer description table.
					;;
HRMAX	LABEL	word			;; number of hwcp+cart slots supported
	DW	0			;;  did = 1
	DW	0			;;  did = 2
	DW	0			;;  did = 3
	DW	0			;;  did = 4
;upto max  DID_MAX			;;
					;;
CTMAX	LABEL	word			;; number of cart slots supported
	DW	0			;;  did = 1
	DW	0			;;  did = 2
	DW	0			;;  did = 3
	DW	0			;;  did = 4
;upto max  DID_MAX			;;
					;;
RMMAX	LABEL	word			;; number of ram-slots supported
	DW	0			;;  did = 1
	DW	0			;;  did = 2
	DW	0			;;  did = 3
	DW	0			;;  did = 4
;upto max  DID_MAX			;;
					;;
RBUMAX	LABEL	word			;; number of ram-designate slots
	DW	0			;;  did = 1
	DW	0			;;  did = 2
	DW	0			;;  did = 3
	DW	0			;;  did = 4
;upto max  DID_MAX			;;
					;;
DESCO	LABEL	word			;; offset to the description table
					;; where the device_id is defined.
	DW	-1			;;  did = 1
	DW	-1			;;  did = 2
	DW	-1			;;  did = 3
	DW	-1			;;  did = 4
;upto max  DID_MAX			;;
					;;
FSIZE	LABEL	word			;; font size of the device
	DW	 0			;;  did = 1
	DW	 0			;;  did = 2
	DW	 0			;;  did = 3
	DW	 0			;;  did = 4
;upto max  DID_MAX			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Hard/RAM slots table in the order of DEVICE parameters
;
;   number of entries in all HARD_SLn is determined by the max. {HSLOTS}, and
;   number of entries in all RAM_SLn  is determined by the max. {RSLOTS}
;
;   -- they are initialized according to the device_id defined in the DEVICE.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
HARD_SLA LABEL	word			;; index in the order of device in
	DW	OFFSET	(HARD_SL1)	;; the PARSE-talbes
	DW	OFFSET	(HARD_SL2)	;;
	DW	OFFSET	(HARD_SL3)	;;
	DW	OFFSET	(HARD_SL4)	;;
; up to DID_MAX 			;;
					;;
RAM_SLA LABEL	word			;;
	DW	OFFSET (RAM_SL1)	;;
	DW	OFFSET (RAM_SL2)	;;
	DW	OFFSET (RAM_SL3)	;;
	DW	OFFSET (RAM_SL4)	;;
; up to DID_MAX 			;;
					;;
SUB_SIZE	EQU	11		;; WGR sublist size			    ;AN000;
LEFT_ASCIIZ	EQU	00010000B	;; WGR left-aligned asciiz string	    ;AN000;
UNLIMITED	EQU	0		;; WGR unlimited message size.		    ;AN000;
					;; WGR					    ;AN000;
SUBLIST LABEL	DWORD			;; WGR					    ;AN000;
	DB	SUB_SIZE		;; WGR					    ;AN000;
	DB	0			;; WGR					    ;AN000;
MSG_PTR DW	?			;; WGR					    ;AN000;
MSG_SEG DW	SEG CSEG		;; WGR					    ;AN000;
	DB	1			;; WGR					    ;AN000;
	DB	LEFT_ASCIIZ		;; WGR					    ;AN000;
	DB	UNLIMITED		;; WGR					    ;AN000;
	DB	1			;; WGR					    ;AN000;
	DB	" "                     ;; WGR                                      ;AN000;
					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	 ++++++++++++++++++++++++
;;	 ++    INIT Command    ++
;;	 ++++++++++++++++++++++++
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
INIT	PROC	NEAR			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; parse the initialization parameters in DEVICE command
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
	PUSH	BX			;; WGR					    ;AN000;
	CALL	SYSLOADMSG		;; WGR load messages			    ;AN000;
	JNC	CONT_1			;; WGR if no error then continue	    ;AN000;
	CALL	SYSDISPMSG		;; WGR error (DOS version)..display	    ;AN000;
	POP	BX			;; WGR message....			    ;AN000;
	JMP	SYNTAX_ERROR		;; WGR ...and exit with error code.	    ;AN000;
					;; WGR					    ;AN000;
CONT_1: 				;; WGR					    ;AN000;
	POP	BX			;; WGR					    ;AN000;
	CMP	BUF.BFLAG,BF_PRN	;; since PRN is the FIRST device header
	JNE	NOT_PRN 		;;
					;;
					;;
	MOV	AX,OFFSET CODE_END	;; defined only once for each DEVICE
	XOR	CX,CX			;;
	MOV	CL,4			;;
	SHR	AX,CL			;;
	PUSH	CS			;;
	POP	CX			;;
	ADD	AX,CX			;;
	INC	AX			;; leave 16 bytes,room for resident_end
	MOV	RESIDENT_END,AX 	;;
					;;
	CALL	PARSER			;; call only once, for PRM
					;;
	JMP	PROCESS_TABLE		;;
					;;
NOT_PRN :				;;
	CMP	DEV_NUM,1		;;
					;;
	JNB	PROCESS_TABLE		;;
					;;
	JMP	SYNTAX_ERROR		;;
					;;
					;;
					;;
;;
;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;;
;;	 ++++++++++++++++++++++++
;;	 ++   INIT Stage 1     ++
;;	 ++++++++++++++++++++++++
;;
;;  INIT - FIRST STAGE :
;;
;;    == test and extract if the parameters on device-id is valid
;;    == determine the DID_STATUS according to the validity of the parameters
;;    == procedure(s) called -- DID_EXTRACT
;;
;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
					;;
PROCESS_TABLE : 			;;
					;;
	PUSH	CS			;;
	POP	ES			;; PSE points to Device offsets
	MOV	DI,OFFSET(table)	;; ES:[DI]
	MOV	DX,PSE.PAR_DEV_NUM	;;
	MOV	DEV_NUM,DX		;;
					;;
	CMP	DEV_NUM,0		;;
	JNZ	NO_SYNTAX_ERR		;;
					;;
					;; WGR					    ;AN000;
	PUSH	BX			;; WGR					    ;AN000;
	MOV	AX,BAD_SYNTAX_MSG	;; WGR 'bad syntax' message                 ;AN000;
	MOV	BX,STDERR		;; WGR	to standard error		    ;AN000;
	XOR	CX,CX			;; WGR					    ;AN000;
	XOR	DL,DL			;; WGR					    ;AN000;
	MOV	DH,UTILITY_MSG_CLASS	;; WGR class = parse error		    ;AN000;
	CALL	SYSDISPMSG		;; WGR display message. 		    ;AN000;
	POP	BX			;; WGR					    ;AN000;
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SYNTAX_ERROR :				;; set the request header status
					;; according to the STATE
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	MOV	AX, RESIDENT_END	;;
	PUSH	CS			;;
	POP	CX			;; CX=CS
	SUB	AX,Cx			;; additional segment required.
CS_LOOP1:				;;
	CMP	AX,1000H		;;
	JB	CS_LPEND1		;;
	ADD	CX,1000H		;;
	SUB	AX,1000H		;;
	JMP	CS_LOOP1		;;
					;;
CS_LPEND1:				;;
	SHL	AX,1			;;
	SHL	AX,1			;;
	SHL	AX,1			;;
	SHL	AX,1			;;
					;;
	LES	DI,dword ptr buf.rh_ptro ;; get Request Header address
;	MOV	RH.RH0_ENDO,AX		;;
	MOV	RH.RH0_ENDO,0		;;
	MOV	RH.RH0_ENDS,CX		;;
	mov	rh.RH0_CONFIG_ERRMSG, -1  ;DCR D493 2/25/88 "Error in CONFIG.SYS..." msg flag.
	MOV	RH.RHC_STA,stat_cmderr	;; set status in request header
					;;
	JMP	INIT_RETurn		;;
					;;
					;;
NO_SYNTAX_ERR : 			;;
					;;
	CMP	DX,DID_MAX		;;
	JNA	NEXT_DID		;;
					;;
	MOV	INIT_CHK,0001H		;; ERROR 0001
	JMP	BAD_DID 		;; more than supported no. of device
					;;
NEXT_DID:				;;
	PUSH	DI			;; pointer to PAR_OT (table 1)
	AND	DX,DX			;;
	JNZ	SCAN_DESC		;;
	JMP	END_DID 		;; DI = offset to the 1st PARSE table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SCAN_DESC:				;;
	MOV	DI,PSE.PAR_OFF		;; points to the nth device
					;;
					;; find the description for the
					;;device-id
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	MOV	CX,PRINTER_DESC_NUM	;;
	MOV	SI, OFFSET(PRINTER_DESC_TBL); offset to the description table
	PUSH	CS			;;
	POP	DS			;;
;	$SEARCH 			;;
$$DO1:
	    PUSH    CX			;; save device count
	    PUSH    SI			;; pointer to printer-descn's offset
	    MOV     SI,CS:WORD PTR[SI]	;;
	    AND     CX,CX		;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	$LEAVE	Z			;; LEAVE if no more device description
	JZ $$EN1
	    PUSH    DI			;; save offset to PAR_DEVOT
	    MOV     DI,PSE.PAR_DIDO	;;
	    MOV     CX,PSE.PAR_DIDL	;; length of parsed device name
	    LEA     DI,PSE.PAR_DID	;; pointer to parse device name
					;;
	    PUSH    SI			;;
	    LEA     SI,[SI].TYPEID	;; offset to name of device-id
	    REPE    CMPSB		;;
	    POP     SI			;;
	    POP     DI			;; get back offset to PAR_DEVOT
					;;;;;;;;;;;;;;;;;;;;;;;;
;	$EXITIF Z			;; EXIT if name matched
	JNZ $$IF1
					;;
	    CALL    DID_EXTRACT 	;; get the parameters
					;;
	    POP     SI			;; balance push-pop
	    POP     CX			;;
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	$ORELSE 			;; try next description :
	JMP SHORT $$SR1
$$IF1:
					;;
	    POP     SI			;; of printer_descn offset table
	    INC     SI			;;
	    INC     SI			;; next offset to PRINTER_DESCn
					;;
	    POP     CX			;; one description less
	    DEC     CX			;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	$ENDLOOP			;; DEVICE-ID not defined in
	JMP SHORT $$DO1
$$EN1:
					;; printer_desc;
					;;
	    MOV     AX,INIT_CHK 	;;
	    AND     AX,AX		;;
	    JNZ     UNCHANGED		;;
	    MOV     INIT_CHK,0004H	;; ERROR 0004
UNCHANGED:				;;
	    POP     SI			;; balance push-pop
	    POP     CX			;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	$ENDSRCH			;; End of scanning printer_desc
$$SR1:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	POP	DI			;;
	INC	DI			;;
	INC	DI			;; points to next device in PART_OT
	DEC	DX			;;
					;;
	JMP	NEXT_DID		;;
					;;
END_DID :				;;
	POP	DI			;;
BAD_DID :				;;
					;;
	MOV	AX,DID_STATUS		;;
	AND	AX,AX			;;
	JNZ	DEF_BUFFER		;;
					;;
	JMP	END_LPT 		;;
					;;
;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;;
;;	++++++++++++++++++++++++
;;	++   INIT Stage 2     ++
;;	++++++++++++++++++++++++
;;
;; INIT -- SECOND STAGE :
;;
;;	== match the device_name extracted in stage 1 with the name of PRN or
;;	   LPTn
;;
;;	== if the PRN/LPTn has never been defined before, then set up the BUF
;;	   for the PRN/LPTn if the DID_STATUS is good; otherwise message will
;;	   be generated indicating it cannot be initilized.
;;
;;	== if there is PRN, LPT1 is also setup, and vice vera. IF both PRN and
;;	   LPT1 are on the DEVICE command, or there are multiple entries for
;;	   the same LPTn, the consistency is checked. It they are inconsistent
;;	   the associated LPTn or PRN is forced to fail by : DID_FAIL.
;;
;;	== if the device_name on the DEVICE command is not one of the supported
;;	   PRN or LPTn, then DID_MATCH bit will not be set. An error message
;;	   will be generated for the device_name indicating it cannot be
;;	   initialized.
;;
;;	== procedure(s) called : CHK_DID   .. check DID parameters for device
;;					      whose name matched.
;;				 DEV_CHECK .. if device-name duplicated, or
;;					      there are both PRN/LPT1 : check
;;					      for consistent parameters.
;;
;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DEF_BUFFER :				;;
	PUSH	CS			;;
	POP	ES			;; PSE points to Device offsets
	MOV	DI,OFFSET(table)	;; ES:[DI]
	xor	cx,cx			;; device order in parse table
;SEARCH 				;;
$$DO7:
	    PUSH    DI			;; pointer to PAR_OT
	    PUSH    CX			;; save device count
	    MOV     DI,PSE.PAR_OFF	;;   "     "  PAR_DEVOT
	    cmp     cx,dev_num		;;
					;;
;LEAVE NB				;; LEAVE if no more device entry
	   jb	    MORE_DEVICE 	;;
	   JMP	    $$EN7
MORE_DEVICE :				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; more parsed_device to be checked
	    PUSH    DI			;; save offset to PAR_DEVOT
	    MOV     DI,PSE.PAR_DNMO	;;
	    MOV     CX,PSE.PAR_DNML	;; length of parsed device name
	    LEA     DI,PSE.PAR_DNM	;; pointer to parse device name
					;;
	    LDS     SI,DWORD PTR BUF.DEV_HDRO ; get the offset to device-n header
	    LEA     SI,HP.DH_NAME	;; "       offset to name of device-n
	    REPE    CMPSB		;;
	    POP     DI			;; get back offset to PAR_DEVOT
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;
;EXITIF Z				;; EXIT if name matched
	JZ  NAME_MATCHED		;;
					;;
	JMP MORE_PARSED_DEVICE		;;
					;;
NAME_MATCHED :				;;
					;;
	    POP     CX			;; the DID order
	    PUSH    BX			;;
	    MOV     BX,CX		;;
	    ADD     BX,BX		;;
	    MOV     AX,DID_BIT[BX]	;;
	    OR	    DID_MATCH,AX	;; this DID matched
	    POP     BX			;;
	    PUSH    CX			;;
					;;
	    LEA     SI,BUF.PAR_EXTRACTO ;; was the LPT1/PRN defined before ?
	    MOV     AX,CS:[SI].PAR_DNMO ;;
	    CMP     AX,0FFFFH		;;
					;;
	    JNE     DEV_COMPARE 	;; DI = PAR_DEVOT
					;;-----------------------------------
					;;
					;; no device previousely defined
	    MOV     AX,PSE.PAR_DNMO	;;
	    MOV     CS:[SI].PAR_DNMO,AX ;; define device parameters for LPTn
					;;
	    MOV     AX,PSE.PAR_DIDO	;;
	    MOV     CS:[SI].PAR_DIDO,AX ;;
					;;
	    MOV     AX,PSE.PAR_HWCPO	;;
	    MOV     CS:[SI].PAR_HWCPO,AX ;;
					;;
	    MOV     AX,PSE.PAR_DESGO	;;
	    MOV     CS:[SI].PAR_DESGO,AX ;;
					;;
	    MOV     AX,PSE.PAR_PARMO	;;
	    MOV     CS:[SI].PAR_PARMO,AX ;;
					;;
					;;---------------------------------
	    CALL    CHK_DID		;; define the STATE according to
					;; DID_STATUS
	    JMP     MORE_PARSED_DEVICE	;;
					;;
DEV_COMPARE :				;;-------------------------------
					;; e.g. LPT1 and PRN shares one BUF.
					;;	or duplicated device name
	    CALL    DEV_CHECK		;;
					;;
	    CMP     BUF.STATE,CPSW	;;
	    JNE     DEV_COMPARE_FAIL	;;
					;;
	    JMP     MORE_PARSED_DEVICE	;;
					;;
DEV_COMPARE_FAIL :			;;
					;;
	    POP     CX			;;
	    POP     DI			;; balance push-pop
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;$ORELSE				;;
	JMP	  END_LPT
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
MORE_PARSED_DEVICE :			;; name does not match
					;;
	    POP     CX			;;
	    INC     CX			;;
	    POP     DI			;;
	    INC     DI			;;
	    INC     DI			;; points to next device in PART_OT
					;;
	    jmp     $$DO7		;;
;$ENDLOOP				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
$$EN7:					;; no device found for LPTn
					;;
	    POP     CX			;;
	    POP     DI			;; balance push-pop
					;;
	    CMP     BUF.STATE,CPSW	;;
	    JE	    END_LPT		;; for LPT1/PRN pair
					;;
	    MOV     BUF.STATE,NORMAL	;; no device defined for the LPTn
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; End of defining LPTn Buffer
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;$ENDSRCH				;;
END_LPT :				;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; set the request header status
					;; according to the STATE
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	MOV	AX, RESIDENT_END	;;
	PUSH	CS			;;
	POP	CX			;; CX=CS
	SUB	AX,Cx			;; additional segment required.
CS_LOOP2:				;;
	CMP	AX,1000H		;;
	JB	CS_LPEND2		;;
	ADD	CX,1000H		;;
	SUB	AX,1000H		;;
	JMP	CS_LOOP2		;;
					;;
CS_LPEND2:				;;
	SHL	AX,1			;;
	SHL	AX,1			;;
	SHL	AX,1			;;
	SHL	AX,1			;;
					;;
	LES	DI,dword ptr buf.rh_ptro ;; get Request Header address
	MOV	RH.RH0_ENDO,AX		;;
	MOV	RH.RH0_ENDS,CX		;;
	XOR	AX,AX			;; clear error code to be returned
	MOV	CX,BUF.STATE		;;
	CMP	CX,CPSW 		;;
	JE	MATCH_GOOD		;;
	MOV	AX,STAT_CMDERR		;;
					;;
MATCH_GOOD :				;;
	MOV	RH.RHC_STA,AX		;; set status in request header
	CALL	LOAD_INT2F		;; WGR load INT2f handler		    ;AN000;
					;;
BUF_END :				;;
					;;
	CMP	BUF.BFLAG,BF_LPT1	;;
	JNE	BUF_MESSAGES		;;
					;;
	CMP	BUF.STATE,CPSW		;;
	JNE	BUF_MESSAGES		;;
					;; set PRN to the same setting as LPT1
	PUSH	BX			;;
					;;
	LEA	SI,BUF.RNORMO		;;
	LEA	CX,BUF.BUFEND		;;
	SUB	CX,SI			;;
	MOV	BX,BUF.PRN_BUFO 	;; where PRN buffer is
	LEA	DI,BUF.RNORMO		;;
	PUSH	CS			;;
	POP	ES			;;
	PUSH	CS			;;
	POP	DS			;;
	REP	MOVSB			;;
					;;
	POP	BX			;;
					;;
BUF_MESSAGES :				;;
	CMP	BUF.BFLAG,BF_LPT3	;; generate error message is this is
	je	last_round		;; the last LPTn
	Jmp	INIT_RETURN		;;
					;; ERROR messages will be generated
					;; at the end of initialization of all
					;; the LPT devices
last_round :				;;
	MOV	AX,RESIDENT_END 	;;
	ADD	AX,STACK_SIZE		;;
	MOV	RESIDENT_END,AX 	;;
	PUSH	CS			;;
	POP	CX			;; CX=CS
	SUB	AX,Cx			;; additional segment required.
CS_LOOP3:				;;
	CMP	AX,1000H		;;
	JB	CS_LPEND3		;;
	ADD	CX,1000H		;;
	SUB	AX,1000H		;;
	JMP	CS_LOOP3		;;
					;;
CS_LPENd3:				;;
	SHL	AX,1			;;
	SHL	AX,1			;;
	SHL	AX,1			;;
	SHL	AX,1			;;
					;;
	MOV	RH.RH0_ENDO,AX		;; STACK !!!!!
	MOV	STACK_ALLOCATED,0	;; from now on, internal stack is used
					;;
	MOV	AX,DID_STATUS		;; what is the DID combination ?
	AND	AX,DID_MATCH		;;
	XOR	AX,DID_FAIL		;;
					;;
	AND	AX,AX			;;
	JNZ	CODE_STAYED		;;
;	MOV	RH.RH0_ENDO,0		;; none of the devices are good
					;;
					;;
CODE_STAYED :				;;
	MOV	DI,OFFSET TABLE 	;;
	push	CS			;;
	POP	ES			;;
					;;
	XOR	CX,CX			;;
MSG_LOOP :				;;
	CMP	CX,DEV_NUM		;;
	JNB	INIT_RETURN		;;
	SHR	AX,1			;;
	JC	MSG_NEXT		;;
					;; this device in parse table is bad
	PUSH	DI			;;
	PUSH	CX			;;
	PUSH	AX			;;
	PUSH	BX			;; WGR					    ;AN000;
	PUSH	DX			;; WGR					    ;AN000;
					;;
	MOV	DI,PSE.PAR_OFF		;;
	MOV	SI,PSE.PAR_DNMO 	;;
					;;
	PUSH	CS			;;
	POP	ES			;;
	PUSH	CS			;;
	POP	DS			;;
					;;
	MOV	CX,8			;;
	LEA	SI,[SI].PAR_DNM 	;;
	MOV	DI,SI			;;
	MOV	AL,' '                  ;; WGR                                      ;AN000;
	CLD				;; WGR					    ;AN000;
	REPNE	SCASB			;; WGR					    ;AN000;
	DEC	DI			;; WGR					    ;AN000;
	MOV	BYTE PTR ES:[DI],ZERO	;; WGR					    ;AN000;
					;; WGR					    ;AN000;
	MOV	MSG_SEG,CS		;; WGR					    ;AN000;
	MOV	MSG_PTR,SI		;; WGR					    ;AN000;
	MOV	AX,BAD_DEVICE_MSG	;; WGR					    ;AN000;
	MOV	BX,STDERR		;; WGR					    ;AN000;
	LEA	SI,SUBLIST		;; WGR					    ;AN000;
	MOV	CX,ONE			;; WGR					    ;AN000;
	XOR	DL,DL			;; WGR					    ;AN000;
	MOV	DH,UTILITY_MSG_CLASS	;; WGR					    ;AN000;
	CALL	SYSDISPMSG		;; WGR					    ;AN000;
					;;					    ;AN000;
	POP	DX			;; WGR					    ;AN000;
	POP	BX			;; WGR					    ;AN000;
	POP	AX			;;
	POP	CX			;;
	POP	DI			;;
					;;
MSG_NEXT :				;;
	INC	CX			;;
	INC	DI			;;
	INC	DI			;;
	JMP	MSG_LOOP		;;
					;;
					;;
INIT_RETURN :				;;
					;;
					;;
	RET				;;
					;;
INIT	ENDP				;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Call by INIT to extract parameters for the deivce_id
;;
;; on rntry :
;;	ES:[DI]  PARSE Table 2, offsets of all parameters
;;	DS:[SI]  Printer Description table whose TYPEID matched
;;	DX	 "inverse" order of devices in the PARSE tables
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;;
DID_EXTRACT PROC			;;
					;;
	PUSH	DX			;;
					;;-----------------------------
					;; define the DID_parameters
	PUSH	BX			;;
					;;
	MOV	BX,DEV_NUM		;;
	SUB	BX,DX			;; order in the Parse table
	add	bx,bx			;; double to index [bx]
	MOV	DX,BX			;;
					;;
	MOV	AX,DS:[SI].FONTSZ	;;
	MOV	FSIZE[BX],AX		;; size of font buffer to be created
					;;
	MOV	AX,DS:[SI].HSLOTS	;;
	CMP	AX,HARDSL_MAX		;;
	JNA	LESS_HARDSL		;;
	MOV	INIT_CHK, 0010H 	;; ERROR 0010H
	POP	BX			;;
	JMP	END_MATCH_BAD		;;
LESS_HARDSL :				;;
	CMP	AX,DS:[SI].HWCPMIN	;;
	JNB	VALID_HARDSL		;;
	MOV	INIT_CHK, 0012H 	;; ERROR 0012H
	POP	BX			;;
	JMP	END_MATCH_BAD		;;
VALID_HARDSL :				;;
	MOV	HRMAX[BX],AX		;;
	MOV	CTMAX[BX],AX		;; will be reduced by the no. of hwcp
					;;
	MOV	AX,DS:[SI].RSLOTS	;;
	CMP	AX,RAMSL_MAX		;;
	JNA	LESS_RAMSL		;;
	MOV	INIT_CHK, 0011H 	;; ERROR 0011H
	POP	BX			;;
	JMP	END_MATCH_BAD		;;
LESS_RAMSL :				;;
	MOV	RMMAX[BX],AX		;;	see also designate
					;;
	MOV	DESCO[BX],SI		;;
					;;
	POP	BX			;;
					;;----------------------------------
					;;
	PUSH	CX			;;
					;;
HWCPgt: PUSH	DI			;; get the hwcp
					;;
	MOV	DI,PSE.PAR_HWCPO	;;
	MOV	CX,PSE.PAR_HWCPL	;; no. of hwcp
	AND	CX,CX			;;
	JNZ	chk_hwcp		;;
	push	bx			;;
	mov	bx,dx			;;
	MOV	HRMAX[BX],CX		;;
	MOV	CX,DS:[SI].HWCPMIN	;;
	SUB	CTMAX[BX],CX		;; what is left becomes cartridge slot
	pop	bx			;;
	JMP	DESIGN			;;
					;; hwcp to be defined
chk_hwcp: MOV	AX,DS:[SI].HSLOTS	;; defined in printer_desc
	CMP	CX,AX			;;
	JA	BAD_MATCH2		;;
	CMP	CX,HARDSL_MAX		;;
	JNA	HWCP_GOOD		;; jump if system error
	MOV	INIT_CHK,0003H		;; ERROR 0003
	JMP	END_MATCH		;;
BAD_MATCH2:				;;
	MOV	INIT_CHK,0002H		;; ERROR 0002
	JMP	END_MATCH		;;
					;;
HWCP_GOOD:				;; there are sufficient hard-slot for
					;; HWCP
	PUSH	SI			;; printer description table of TYPEID
	PUSH	BX			;;
					;;
	MOV	BX,DX			;;
	MOV	AX,CTMAX[BX]		;;
					;;
	PUSH	CX			;; calculate what is left for cart_slot
	CMP	CX,DS:[SI].HWCPMIN	;;
	JNB	MORE_THAN_HWCPMIN	;;
	MOV	CX,DS:[SI].HWCPMIN	;;
MORE_THAN_HWCPMIN :			;;
	SUB	AX,CX			;;
	POP	CX			;;
	mov	HRMAX[BX],CX		;;
					;;
	MOV	CTMAX[BX],AX		;; no of cart-slot for designate
	MOV	SI,HARD_SLA[BX] 	;; get the corresponding hard-slots
					;;
	POP	BX			;;
					;;
	push	bx			;;
	push	dx			;;
	mov	bx,si			;;
	mov	dx,cx			;;
	mov	reserved1,dx		;; IF THERE IS ANY REPETITIVE HWCP
	mov	reserved2,bx		;; IF THERE IS ANY REPETITIVE HWCP
					;;
FILL_HWCP:				;;
	AND	CX,CX			;;
	JZ	DESIGN_P		;;
	INC	DI			;; next code page in PARSE table
	INC	DI			;;
	MOV	AX,ES:[DI]		;; get code page value
					;;
					;; IF THERE IS ANY REPETITIVE HWCP
	push	dx			;;
	push	bx			;;
hwcp_norep :				;;
	cmp	ax,cs:[bx].slt_cp	;;
	jne	hwcp_repnext		;;
	pop	bx			;;
	pop	dx			;;
	pop	dx			;;
	pop	bx			;;
	pop	si			;;
	jmp	end_match		;;
					;;
hwcp_repnext:				;;
	inc	bx			;;
	inc	bx			;;
	inc	bx			;;
	inc	bx			;;
	dec	dx			;;
	jnz	hwcp_norep		;;
	pop	bx			;;
	pop	dx			;;
					;;
	MOV	CS:[SI].SLT_CP,AX	;;
	MOV	AX,CS:[SI].SLT_AT	;; get the attributes
	OR	AX,AT_OCC		;; occupied
	OR	AX,AT_HWCP		;; hwcp slot
	MOV	CS:[SI].SLT_AT,AX	;;
	INC	SI			;;
	INC	SI			;; next slot
	INC	SI			;; next slot
	INC	SI			;; next slot
	DEC	CX			;;
	JMP	FILL_HWCP		;;
DESIGN_P:				;;
	pop	dx			;;
	pop	bx			;;
	POP	SI			;;
					;;---------------------
DESIGN: POP	DI			;; get the designate no.
	PUSH	DI			;;
					;;
	MOV	DI,PSE.PAR_DESGO	;;
	MOV	AX,PSE.PAR_DESGL	;;
	CMP	AX,1			;;
	JA	END_MATCH		;; there should have no font entry
	AND	AX,AX			;;
	JZ	DEF_RBUFMAX		;;
					;;
	MOV	AX,PSE.PAR_DESG 	;;
	AND	AX,AX			;;
	JZ	DEF_RBUFMAX		;;
					;;
	CMP	CS:[SI].CLASS,1 	;;
	JNE	DESIG_NOt_CLASS1	;;
					;;
	PUSH	BX			;; if there is any cartridge slot ?
	PUSH	AX			;;
	MOV	BX,DX			;;
	MOV	AX,ctmax[BX]		;;
	AND	AX,AX			;;
	POP	AX			;;
	POP	BX			;;
	JZ	END_MATCH		;; fail, as there is no physical RAM.
					;;
	CMP	AX,HARDSL_MAX		;; is the designate more than max ?
	JA	END_MATCH		;;
					;;
					;;
	JMP	DEF_RBUFMAX		;;
					;;
					;;
					;;
DESIG_NOT_CLASS1 :			;;
	PUSH	BX			;; if there is any physical RAM slot ?
	PUSH	AX			;;
	MOV	BX,DX			;;
	MOV	AX,RMMAX[BX]		;;
	AND	AX,AX			;;
	POP	AX			;;
	POP	BX			;;
	JZ	END_MATCH		;; fail, as there is no physical RAM.
					;;
					;;
	CMP	AX,RAMSL_MAX		;; is the designate more than max ?
	JA	END_MATCH		;;
					;;
DEF_RBUFMAX :				;;
	PUSH	BX			;;
	MOV	BX,DX			;;
	MOV	RBUMAX[BX],AX		;;
	POP	BX			;;
					;;
					;;
PARAM : 				;;
;PARM:	    POP     DI			;;
;	    PUSH    DI			;;
;;	    MOV     DI,PSE.PAR_PARMO	;;
					;;
					;,--------------------------
					;; GOOD device_id parameters
	shr	dx,1			;;
	MOV	AX,DID_ONE		;;
	MOV	CX,DX			;;
	AND	CX,CX			;;
	JZ	NO_SHL			;;
	SHL	AX,CL			;;
NO_SHL: OR	DID_STATUS,AX		;; is defined
					;;-------------------------
END_MATCH: POP	DI			;; end of extract
	POP	CX			;;
END_MATCH_BAD : 			;;
	POP	DX			;;
					;;
	RET				;;
					;;
DID_EXTRACT ENDP			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Called by INIT to define the STATE and BUF for the LPTn according to
;; the DID_STATUS. Create font buffer if requested through the "desi*nate"
;;
;; at entry :  CX = device order in parse table
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CHK_DID PROC				;;
					;;
	push	cx			;;
	push	di			;;
	push	dx			;;
					;;
	MOV	AX,DID_STATUS		;;
					;;
	PUSH	CX			;; order 0 to m
	POP	DI			;;
	ADD	DI,DI			;; indexing : [DI]
					;;
	INC	CX			;;
	SHR	AX,CL			;; is the device parameter valid ?
					;;
	JC	DEFINE_BUFFER		;;
	JMP	LPT_FAIL		;;--------------------------
					;;
DEFINE_BUFFER : 			;;
					;; good device parameters as determined
	MOV	AX,DESCO[DI]		;;
	MOV	BUF.PDESCO,AX		;;
					;;
	PUSH	DI			;;
	MOV	DI,AX			;;
	MOV	AX,CS:[DI].CLASS	;;
	MOV	BUF.PCLASS,AX		;;
	POP	DI			;;
					;;
	MOV	AX,HARD_SLA[DI] 	;;  in the DID_EXTRACT
	MOV	BUF.HARDSO,AX		;;
					;;
	MOV	AX,RAM_SLA[DI]		;;
	MOV	BUF.RAMSO,AX		;;
					;;
	MOV	AX,HRMAX[DI]		;;
	MOV	BUF.HARDMX,AX		;;
					;;
	MOV	AX,CTMAX[DI]		;;
	MOV	BUF.HCARMX,AX		;;
					;;
	ADD	AX,HRMAX[DI]		;; defore "designate"
	MOV	BUF.HSLMX,AX		;;
					;;
					;;
	MOV	AX,RMMAX[DI]		;;
	MOV	BUF.RAMMX,AX		;;
					;;
	XOR	AX,AX			;;
	PUSH	CX			;; calculate the max. length of control
	MOV	CX,2			;; sequence that is allowed for the
	CMP	BUF.PCLASS,1		;; room reserved for physical slots.
	JNE	CTL_LOOP		;;
	MOV	CX,1			;; class 1 printer has one control seq.
CTL_LOOP :				;;
	ADD	AX,CTL_MAX		;;
	DEC	AX			;; leave one byte for the length
	DEC	CX			;;
	JNZ	CTL_LOOP		;;
	MOV	BUF.FSELMAX,AX		;;
	POP	CX			;;
					;;
	MOV	AX,FSIZE[DI]		;;
	MOV	BUF.FTSZPA,AX		;; FTSIZE in paragraph
					;;
	PUSH	AX			;;
					;;
	MOV	DX,4			;;
FT_PARA:				;;
	ADD	AX,AX			;;
	DEC	DX			;;
	JNZ	FT_PARA 		;; font size
	MOV	BUF.FTSIZE,AX		;; font size in bytes (used with.RBUFMX)
					;;
	POP	DX			;; FTSIZE in paragraph
					;;
	MOV	CX,RBUMAX[DI]		;; create font buffer per .RBUFMX and
	MOV	BUF.RBUFMX,CX		;; assume sufficient memory for all the
					;; "designate request"
	PUSH	CX			;;
					;;
	CMP	BUF.PCLASS,1		;; always create font buffer for class1
	JNE	CLASS_NOT_1		;;
					;;
	AND	CX,CX			;;
	JZ	CLASS1_NOCX		;;
	ADD	CX,BUF.HARDMX		;;
	MOV	BUF.HSLMX,CX		;;
	JMP	CLASS_NOT_1		;;
					;;
CLASS1_NOCX:				;;
	MOV	CX,BUF.HSLMX		;;
					;;
CLASS_NOT_1 :				;;
	AND	CX,CX			;;
	JZ	MULTIPLE_DONE		;;
	MOV	AX,RESIDENT_END 	;;
MULTIPLE_FT :				;;
	ADD	AX,DX			;; allocate the font buffers at the end
	DEC	CX			;; of the resident codes
	JNZ	MULTIPLE_FT		;;
					;;
					;;
	MOV	CX,RESIDENT_END 	;;
	MOV	BUF.FTSTART,CX		;;
	MOV	RESIDENT_END,AX 	;;
					;;
					;;
MULTIPLE_DONE : 			;;
	POP	CX			;; designate requested
					;;
	CMP	BUF.PCLASS,1		;;
	JNE	DEF_RBUF		;;
					;; CLASS 1
	CMP	BUF.HARDMX,0		;;
	JE	DEFBUF_DONE		;;
					;;
	PUSH	CX			;; STACKS...
	PUSH	SI			;;
	PUSH	DS			;;
	PUSH	ES			;;
	PUSH	DI			;;
	PUSH	DX			;;
					;;
	MOV	DX,BUF.HARDMX		;;
	PUSH	DX			;; STACK +1 -- # of HWCP
					;;
	PUSH	CS			;;
	POP	DS			;;
	MOV	BUF.RBUFMX,0		;;
	MOV	SI,BUF.PDESCO		;;
	MOV	SI,CS:[SI].SELH_O	;;
	XOR	CX,CX			;;
	MOV	CL,CS:BYTE PTR [SI]	;;
	INC	CX			;; including the length byte
					;;
	MOV	DI,BUF.FTSTART		;; control template
DEF_FTBUF:				;; fill the  font buffer with the
	PUSH	DI			;;
	POP	ES			;;
	XOR	DI,DI			;;
					;;
	PUSH	CX			;;
	PUSH	SI			;;
	REP	MOVSB			;;
	POP	SI			;;
	POP	CX			;;
					;;
	PUSH	ES			;;
	POP	DI			;;
	ADD	DI,BUF.FTszpa		;;
	DEC	DX			;;
	JNZ	DEF_FTBUF		;;
					;;
	POP	DX			;; STACK -1
					;;
	MOV	SI,BUF.HARDSO		;;
	MOV	DI,BUF.FTSTART		;; define the HWCP values
DEF_FThwcp :				;;
	PUSH	DI			;;
	POP	ES			;;
	MOV	DI,CTL5202_OFFS 	;; offset to the HWCP words
					;;
	MOV	AX,CS:[SI].SLT_CP	;;
	MOV	ES:WORD PTR [DI],AX	;;
					;;
	INC	SI			;;
	INC	SI			;;
	INC	SI			;;
	INC	SI			;;
					;;
	PUSH	ES			;;
	POP	DI			;;
	ADD	DI,BUF.FTSZPA		;;
	DEC	DX			;;
	JNZ	DEF_FThwcp		;;
					;;
	POP	DX			;;
	POP	DI			;;
	POP	ES			;;
	POP	DS			;;
	POP	SI			;;
	POP	CX			;;
					;;
	JMP	DEFBUF_DONE		;;
					;;
					;;
DEF_RBUF :				;;
	MOV	BUF.RSLMX,CX		;; the no. of ram slots supported
	CMP	CX,RMMAX[DI]		;;
	JNB	DEFBUF_DONE		;;
	MOV	AX,RMMAX[DI]		;;
	MOV	BUF.RSLMX,AX		;; the max. of .RAMMX and .RBUFMX
					;;
DEFBUF_DONE :				;;
	MOV	BUF.STATE,CPSW		;; the LPTn is CPSW ----- STATE
					;;
	CMP	BUF.BFLAG,BF_PRN	;;
	JNE	RET_CHK_DID		;;
	MOV	AX,DID_BIT[DI]		;;
	MOV	BUF.DID_PRN,AX		;;
					;;
					;;
	JMP	RET_CHK_DID		;;
					;;
LPT_FAIL:				;;
					;;
	MOV	BUF.STATE,NORMAL	;; the LPTn is NORMAL --- STATE
					;;
					;;
RET_CHK_DID:				;;
					;;
	pop	dx			;;
	pop	di			;;
	pop	cx			;;
					;;
	RET				;;
					;;
CHK_DID ENDP				;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Called by INIT to check for consistency between duplicated device name and
;;	between PRN and LPT1
;;
;; at entry :  DI = pointer to PAR_DEVOT
;;	       BUF.STATE = any state
;;	       CX = DID order
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
DEV_CHECK PROC				;;
					;;
	LEA	SI,BUF.PAR_EXTRACTO	;;
					;;
	PUSH	CX			;;
					;;
	PUSH	SI			;; compare device id
	PUSH	DI			;;
	mov	SI,[SI].PAR_DIDO	;;
	MOV	DI,PSE.PAR_DIDO 	;;
	MOV	CX,PSE.PAR_DNML 	;;
	INC	CX			;; including length
	INC	CX			;;
	REPE	CMPSB			;;
	POP	DI			;;
	POP	SI			;;
	Jz	hwcp_check		;;
	mov	init_chk,0021h		;; error 0021h
	Jmp	FORCE_LPT_BAD		;;
					;;
hwcp_check :				;;
	PUSH	SI			;; compare HWCP
	PUSH	DI			;;
	mov	SI,[SI].PAR_HWCPO	;;
	MOV	DI,PSE.PAR_HWCPO	;;
	MOV	AX,PSE.PAR_HWCPL	;;
	MOV	CX,2			;;
	SHL	AX,CL			;; multiply by two
	INC	AX			;; including length
	INC	AX			;;
	MOV	CX,AX			;;
	REPE	CMPSB			;;
	POP	DI			;;
	POP	SI			;;
	Jz	desig_check		;;
	mov	init_chk,0022h		;; error 0022h
	Jmp	FORCE_LPT_BAD		;;
					;;
desig_check :				;;
	PUSH	SI			;; compare DESIGNATE
	PUSH	DI			;;
	mov	SI,[SI].PAR_DESGO	;;
	MOV	DI,PSE.PAR_DESGO	;;
	MOV	AX,PSE.PAR_DESGL	;;
	MOV	CX,2			;;
	SHL	AX,CL			;; multiply by two
	INC	AX			;; including length
	INC	AX			;;
	MOV	CX,AX			;;
	REPE	CMPSB			;;
	POP	DI			;;
	POP	SI			;;
	Jz	param_check		;;
	mov	init_chk,0023h		;; error 0023h
	Jmp	FORCE_LPT_BAD		;;
					;;
param_check :				;;
	PUSH	SI			;; compare parameters
	PUSH	DI			;;
	mov	SI,[SI].PAR_PARMO	;;
	MOV	DI,PSE.PAR_PARMO	;;
	MOV	CX,PSE.PAR_PARML	;;
	INC	CX			;; including length
	INC	CX			;;
	REPE	CMPSB			;;
	POP	DI			;;
	POP	SI			;;
	JZ	M_END			;;
	mov	init_chk,0024h		;; error 0024h
					;;
FORCE_LPT_BAD : 			;; the second set of parameters is
	MOV	BUF.STATE,NORMAL	;; bad
					;;
	CMP	BUF.BFLAG,BF_LPT1	;;
	JNE	M_END			;;
					;;
					;; since LPT1 is bad, force PRN to bad
	push	bx			;; force prn to be bad too
	mov	bx,buf.prn_bufo 	;;
	MOV	BUF.STATE,NORMAL	;;
	pop	bx			;;
					;;
	mov	AX,BUF.DID_PRN		;; if PRN was not good, DID_PRN = 0
	OR	DID_FAIL,AX		;;
					;;
					;;
M_END:					;; force the good did_status to fail if
					;; STATE is bad
	POP	CX			;;
	PUSH	CX			;; order 0 to m
	MOV	AX,DID_STATUS		;;
					;;
	INC	CX			;;
	SHR	AX,CL			;;
	POP	CX			;;
	JNC	DEV_CHECK_RET		;; already failed
					;;
	CMP	BUF.STATE,CPSW		;;
	JE	DEV_CHECK_RET		;;
					;;
	    PUSH    BX			;;
	    MOV     BX,CX		;;
	    ADD     BX,BX		;;
	    MOV     AX,DID_BIT[BX]	;;
	    OR	    DID_FAIL,AX 	;; force DID to fail
	    POP     BX			;;
					;;
					;;
DEV_CHECK_RET : 			;;
					;;
	RET				;;
					;;
					;;
DEV_CHECK ENDP				;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: LOAD_INT2F
;
; FUNCTION:
; THIS PROCEDURE LOADS THE INTERRUPT HANDLER FOR INT2FH
;
; AT ENTRY:
;
; AT EXIT:
;    NORMAL: INTERRUPT 2FH VECTOR POINTS TO INT2F_COM. OLD INT 2FH
;	     VECTOR STORED.
;
;    ERROR:  N/A
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SEMAPHORE  DB	  0								    ;AN000;
										    ;AN000;
LOAD_INT2F PROC   NEAR								    ;AN000;
	   CMP	  CS:SEMAPHORE,0		   ; already loaded?		    ;AN000;
	   JNE	  LI_1				   ; yes.....exit		    ;AN000;
	   PUSH   ES				   ; no...load. 		    ;AN000;
	   PUSH   CX				   ;				    ;AN000;
	   PUSH   AX				   ;				    ;AN000;
	   XOR	  AX,AX 			   ; point ES to low..		    ;AN000;
	   MOV	  ES,AX 			   ; memory.			    ;AN000;
	   MOV	  AX,ES:WORD PTR INT2F_LOW	   ; store original..		    ;AN000;
	   MOV	  CS:ROM_INT2F,AX		   ; interrupt 2Fh..		    ;AN000;
	   MOV	  CX,ES:WORD PTR INT2F_HI	   ; location.. 		    ;AN000;
	   MOV	  CS:ROM_INT2F+2,CX		   ;				    ;AN000;
	   OR	  AX,CX 			   ; check if old int2F..	    ;AN000;
	   JNZ	  LI_0				   ; is 0.			    ;AN000;
	   MOV	  AX,OFFSET ABORT		   ; yes....point to..		    ;AN000;
	   MOV	  CS:ROM_INT2F,AX		   ; IRET.			    ;AN000;
	   MOV	  AX,CS 			   ;				    ;AN000;
	   MOV	  CS:ROM_INT2F+2,AX		   ;				    ;AN000;
LI_0:						   ;				    ;AN000;
	   CLI					   ;				    ;AN000;
	   MOV	  ES:WORD PTR INT2F_LOW,OFFSET INT2F_COM ; replace vector..	    ;AN000;
	   MOV	  ES:WORD PTR INT2F_HI,CS	   ; with our own..		    ;AN000;
	   STI					   ;				    ;AN000;
	   POP	  AX				   ;				    ;AN000;
	   POP	  CX				   ;				    ;AN000;
	   POP	  ES				   ;				    ;AN000;
	   MOV	  CS:SEMAPHORE,1		   ; now loaded.		    ;AN000;
LI_1:	   RET					   ;				    ;AN000;
LOAD_INT2F ENDP

.XLIST
MSG_SERVICES <MSGDATA>			  ; WGR 				    ;AN000;
MSG_SERVICES <DISPLAYmsg,LOADmsg,CHARmsg> ; WGR 				    ;AN000;
MSG_SERVICES <PRINTER.CL1>		  ; WGR 				    ;AN000;
MSG_SERVICES <PRINTER.CL2>		  ; WGR 				    ;AN000;
MSG_SERVICES <PRINTER.CLA>		  ; WGR 				    ;AN000;
.LIST

include msgdcl.inc

CSEG	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\printer\cpsfont.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

	PAGE	,132

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  FILENAME:	  CPS Device Driver -- Font Parser
;;  MODULE NAME:  CPSFONT
;;  TYPE:	  Font Parser Module
;;  LINK PROCEDURE:  Link CPS+CPSSUB+CPSINT9+...+CPSINIT into .EXE format
;;		     CPS must be first.  CPSINIT must be last.	Everything
;;		     before CPSINIT will be resident.
;;  INCLUDE FILES:
;;			CPSPEQU.INC
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
INCLUDE CPSPEQU.INC			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
CSEG	SEGMENT PUBLIC 'CODE'           ;;
	ASSUME	CS:CSEG 		;;
	ASSUME	DS:NOTHING		;;
					;;
PUBLIC	FTABLE,FONT_PARSER		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  ************************************
;;  **				      **
;;  **	     Resident Code	      **
;;  **				      **
;;  ************************************
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	FONT_PARSER data
;;
;;	-- Interface table : FTABLE
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FTABLE: FBUFS	<0FFFFH,,,>		;; for temporary testing
FTB1	FTBLK	<,,,,,,,,,,,,>		;; -- at most 12 entries
FTB2	FTBLK	<,,,,,,,,,,,,>		;;
FTB3	FTBLK	<,,,,,,,,,,,,>		;;
FTB4	FTBLK	<,,,,,,,,,,,,>		;;
FTB5	FTBLK	<,,,,,,,,,,,,>		;;
FTB6	FTBLK	<,,,,,,,,,,,,>		;;
FTB7	FTBLK	<,,,,,,,,,,,,>		;;
FTB8	FTBLK	<,,,,,,,,,,,,>		;;
FTB9	FTBLK	<,,,,,,,,,,,,>		;;
FTBa	FTBLK	<,,,,,,,,,,,,>		;;
FTBb	FTBLK	<,,,,,,,,,,,,>		;;
FTBc	FTBLK	<,,,,,,,,,,,,>		;;
					;;
FP_ERROR	DW   0000H		;; internal error register
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; the followings are bytes accumulated
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FTAG_LEN	EQU	8		;; FILE TAGE in the font file header
FTAG_COUNT	DW	0000H		;;
					;;
FTAG_PATTERN	LABEL	BYTE		;;
	DB	0FFH			;;
	DB	'FONT   '               ;;
					;;
					;;
					;; POINTER in the font file header
fptr_LOW LABEL	WORD			;;
fptr_LOL DB	00H			;; NEXT
fptr_LOH DB	00H			;;
fptr_HIGH LABEL WORD			;;
fptr_HIL DB	00H			;;
fptr_HIH DB	00H			;;
					;;
					;;
					;;
ENTRY_WORD LABEL WORD			;;
ENTRY_LOB DB	00H			;; ENTRY COUNT
ENTRY_HIB DB	00H			;;
NEXT_LOW LABEL	WORD			;;
NEXT_LOL DB	00H			;; NEXT
NEXT_LOH DB	00H			;;
NEXT_HIGH LABEL WORD			;;
NEXT_HIL DB	00H			;;
NEXT_HIH DB	00H			;;
TYPE_WORD LABEL WORD			;;
TYPE_LOB DB	00H			;; TYPE
TYPE_HIB DB	00H			;;
TID_CNT DW	00000H			;; TYPEID COUNT(0 to 8)
TYPE_ID :	DB '        '           ;; TYPEID
CPG_WORD LABEL	WORD			;;
CPG_LOB DB	00H			;; CODE PAGE
CPG_HIB DB	00H			;;
FONT_LOW LABEL	WORD			;;
FONT_LOL DB	00H			;; FONT ADDRESS
FONT_LOH DB	00H			;;
FONT_HIGH LABEL WORD			;;
FONT_HIL DB	00H			;;
FONT_HIH DB	00H			;;
;; the followings are contained in the font-block in the exact order & length
MOD_WORD LABEL	WORD			;;
MOD_LOB DB	00H			;; MODIFIER
MOD_HIB DB	00H			;;
FONTS_WORD LABEL WORD			;;
FONTS_LOB DB	00H			;; FONTS
FONTS_HIB DB	00H			;;
FDLEN_WORD LABEL WORD			;;
FDLEN_LOB DB	00H			;; FONT DATA LENGTH
FDLEN_HIB DB	00H			;;
PRE_FONT_ND	EQU ($-MOD_WORD)	;; used to update target for font data
					;; to follow. -- for NON-DISPLAY
DISP_ROWS DB	00H			;; DISPLAY's parameters :
DISP_COLS DB	00H			;; BOX SIZE
DISP_X	  DB	00H			;; ASPECT RATIO
DISP_Y	  DB	00H			;;
COUNT_WORD    LABEL WORD		;; NO. OF DISPLAY CHARACTERS
COUNT_LOB DB	00H			;;
COUNT_HIB DB	00H			;;
PRE_FONT_D	EQU ($-MOD_WORD)	;; used to update target for font data
					;; to follow. -- for DISPLAY
					;;
PTR_SEL_WORD	LABEL WORD		;;
PTR_SELOB DB	00H			;;
PTR_SEHIB DB	00H			;;
PRE_FONT_P0	EQU ($-PTR_SELOB+PRE_FONT_ND) ;; to update target for font data
					;; to follow -- for PRINTER with
					;; selection type = 0.
					;;
PTR_LEN_WORD	LABEL WORD		;;
PTR_LNLOB DB	00H			;;
PTR_LNHIB DB	00H			;;
PRE_FONT_P	EQU ($-PTR_SELOB+PRE_FONT_ND) ;; to update target for font data
					;; to follow -- for PRINTER with
					;; selection type <> 0.
					;;
					;;
;; also update STAGE_CASES and indexing constants
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; the stage the parsing is in :  ;;;;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
STAGE_CASES LABEL WORD			;; the stage the parsing is in :
					;;
					;; *** INDEXED BY  STAGE-INDEX
					;;
	DW	OFFSET ENTRYLO		;; 0
	DW	OFFSET ENTRYHI		;; 1
	DW	OFFSET NEXTLOL		;; 2
	DW	OFFSET NEXTLOH		;; 3
	DW	OFFSET NEXTHIL		;; 4
	DW	OFFSET NEXTHIH		;; 5
	DW	OFFSET TYPELO		;; 6
	DW	OFFSET TYPEHI		;; 7
	DW	OFFSET TYPEIDS		;; 8
	DW	OFFSET CPGLO		;; 9
	DW	OFFSET CPGHI		;; A
	DW	OFFSET FONTLOL		;; B
	DW	OFFSET FONTLOH		;; C
	DW	OFFSET FONTHIL		;; D
	DW	OFFSET FONTHIH		;; E
	DW	00H			;; MATCH case -- end of SEARCH stages
	DW	00H			;; SCAN  case -- before PRE-FOUND stage
	DW	OFFSET MODLO		;; 11
	DW	OFFSET MODHI		;; 12
	DW	OFFSET FONTSLO		;; 13
	DW	OFFSET FONTSHI		;; 14
	DW	OFFSET FDLENLO		;; 15
	DW	OFFSET FDLENHI		;; 16 -- lead to FONT case,NON- DISPLAY
	DW	OFFSET DSPROWS		;; 17 -- DISPLAY only
	DW	OFFSET DSPCOLS		;; 18
	DW	OFFSET DSPX		;; 19
	DW	OFFSET DSPY		;; 1A
	DW	OFFSET DSPCOUNTLO	;; 1B
	DW	OFFSET DSPCOUNTHI	;; 1C -- lead to FONT case, DISPLAY
	DW	OFFSET PTRSELLO        ;;  1D -- PRINTER only
	DW	OFFSET PTRSELHI        ;;  1E
	DW	OFFSET PTRLENLO        ;;  1F
	DW	OFFSET PTRLENHI        ;;  20 -- lead to FONT case, PRINTER
	DW	00H			;; FOUND    case
	DW	00H			;; GET_FONT case
	DW	00H			;; PASS special stage
	DW	OFFSET FILETAG		;; 24
	DW	OFFSET fptrLOL		;; 25
	DW	OFFSET fptrLOH		;; 26
	DW	OFFSET fptrHIL		;; 27
	DW	OFFSET fptrHIH		;; 28
	DW	00H			;; FPTR_SKIP_CASE
					;;
					;; The followings are individual stage
STAGE_MAX EQU	($-STAGE_CASES)/2	;;  number of stages
					;;
					;; STAGE-INDEX
					;;
					;; **** INDEX TO STAGE_CASES  ****
ENTRY_LOX EQU	00H			;;
ENTRY_HIX EQU	01H			;;
NEXT_LOLX EQU	02H			;; NEXT
NEXT_LOHX EQU	03H			;;
NEXT_HILX EQU	04H			;;
NEXT_HIHX EQU	05H			;;
TYPE_LOBX EQU	06H			;; TYPE
TYPE_HIBX EQU	07H			;;
TYPE_IDX EQU	08H			;; TYPEID
CPG_LOBX EQU	09H			;; CODE PAGE
CPG_HIBX EQU	0AH			;;
FONT_LOLX EQU	0BH			;; FONT ADDRESS
FONT_LOHX EQU	0CH			;;
FONT_HILX EQU	0DH			;;
FONT_HIHX EQU	0EH			;;
					;; ------------------------------
MATCHX	EQU	0FH			;; MATCH is the end of SEARCH's stages
SCANX	EQU	10H			;; SCANX is before the PRE-FOUND stages
					;; ------------------------------
MOD_LOBX EQU	11H			;; MODIFIER
MOD_HIBX EQU	12H			;;
FONTS_LOBX EQU	13H			;; FONTS
FONTS_HIBX EQU	14H			;;
FDLEN_LOBX EQU	15H			;; FONT DATA LENGTH
FDLEN_HIBX EQU	16H			;;
DISP_ROWSX EQU	17H			;; DISPLAY -- CHAR. SIZE
DISP_COLSX EQU	18H			;;
DISP_XX    EQU	19H			;; DISPLAY -- ASPECT RATIO
DISP_YX    EQU	1AH			;;
COUNT_LOBX EQU	1BH			;; DISPLAY -- COUNT
COUNT_HIBX EQU	1CH			;;
PTRSELLOX  EQU	1DH			;;
PTRSELHIX  EQU	1EH			;;
PTRLENLOX  EQU	1FH			;;
PTRLENHIX  EQU	20H			;;
					;;
					;; ------------------------------
FOUNDX	EQU	21H			;; GET_FX is the end of PRE-FOUND stage
GET_FX	EQU	22H			;;
					;; ------------------------------
PASSX	EQU	23H			;; see pass_brk table
					;; ------------------------------
FTAGX	EQU	24H			;; RESTART ==> FILE TAG
					;;
fptr_LOLX EQU	25H			;; POINTER in font file header
fptr_LOHX EQU	26H			;;
fptr_HILX EQU	27H			;;
fptr_HIHX EQU	28H			;; ---------------------------------
					;;
fptr_SKIPX EQU	29H			;; ==> ENTRY_LOX
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; PASS -- to skip some bytes ;;;;;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; the PASS mechanism is used to skip
					;; a number of bytes between two fields
					;; The numbers are tabulated in
					;; PASS_BRK table in the accumulative
					;; sum. The PASS_POSTX(and PASS_POSTXX)
					;; are used to tell what is the stage
					;; after all the bytes have skipped.
					;;
PASS_POSTX  DW	 STAGE_MAX		;; the stage after pass-stage
					;;
FILE_OFFSET    EQU     0BH	       ;; spaces to be skipped in font file :
					;; ( after TAG, before POINTER)
					;;
PASS_CNT DW	0			;;
PASS_BRK LABEL	WORD			;;
	DW	FILE_OFFSET		;; skip in the font file header
	DW	FILE_OFFSET+2		;; pass header-length, needs to reset
					;; PASS_CNT for each of the font_header
	DW	FILE_OFFSET+8		;; pass header-reserved bytes
PASS_INDX EQU	($-PASS_BRK)/2		;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; the control variables :  ;;;;;;;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
STAGE	DW	STAGE_MAX		;; of the STAGE-INDEX
					;;
Pre_font_len	DW	00000H		;; no. of bytes before the FONT DATA
					;;
					;;
COUNT_LO DW	00000H			;; no. of bytes parsed so far
COUNT_hI DW	00000H			;;
					;;
HIT_LO	DW	00000H			;; the next byte that is addressed by :
HIT_HI	DW	00000H			;; either NEXT or TARGET in FTBLK.
					;;
HIT_FLAG DW	00000H			;; IF ZERO, the NEXT is approaching
HIT_BX	DW	00000H			;; where FTB is found for nearest hit
					;;
NUM_FTB DW	00000H			;; as defined in the FP_BUFFER
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	FONT_PARSER routine
;;
;;	-- to be called at every packet received to extract informations
;;	   from Font File on byte basis.
;;
;;	-- Interface though FTABLE
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
FONT_PARSER PROC			;;
	PUSH	DS			;; save all registers Revised
	PUSH	ES			;;
	PUSH	AX			;;
	PUSH	BX			;;
	PUSH	CX			;;
	PUSH	DX			;;
	PUSH	DI			;;
	PUSH	SI			;;
					;; BP isn't used, so it isn't saved
	LEA	BX,FTABLE		;;
	PUSH	CS			;;
	POP	ES			;; ES:[BX]
	LDS	SI,FTP.BUFFER_ADDR	;; DS:[SI]
	MOV	CX,FTP.BUFFER_LEN	;; CX = length of packet
	MOV	DX,FTP.NUM_FTBLK	;; DX = number of FTB
	MOV	cs:num_ftb,DX		   ;;
	AND	DX,DX			;;
	JNZ	VALID_BUFFER		;;
	MOV	cs:fp_error,0020H	   ;; ERROR 0020H
	JMP	FP_RET			;;
VALID_BUFFER :				;;
	MOV	AX,FTP.FLAG		;;
	AND	AX,FLAG_RESTART 	;;
	Jnz	has_RESTART		;;
	JMP	NO_RESTART		;;
					;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
has_restart :				;;
	PUSH	BX			;; reset all the output fields
	ADD	BX,TYPE FBUFS		;; FTP = FONT BLOCK
	XOR	AX,AX			;;
					;;
	MOV	cs:ftag_count,AX	   ;;
	MOV	cs:fptr_low,AX		   ;;
	MOV	cs:fptr_high,AX 	   ;;
	MOV	cs:pre_font_len,AX	  ;;
	MOV	cs:count_lo,AX		   ;;
	MOV	cs:count_hi,AX		   ;;
	MOV	cs:next_low,AX		   ;;
	MOV	cs:next_high,AX 	   ;;
	MOV	cs:hit_lo,AX		   ;;
	MOV	cs:hit_hi,AX		   ;;
	MOV	cs:hit_flag,AX		   ;;
	MOV	cs:pass_cnt,AX		   ;;
	MOV	cs:pass_postx,STAGE_MAX    ;;
					;;
	MOV	cs:stage,STAGE_MAX	   ;;
					;;
RESET_FTB :				;;
	MOV	FTP.FTB_STATUS,FSTAT_SEARCH
	MOV	FTP.FTB_TYPE,AX 	;;
	MOV	FTP.FTB_MOD,AX		;;
	MOV	FTP.FTB_FONTS,AX	;;
	MOV	FTP.FTB_ROWS,AL 	;;
	MOV	FTP.FTB_COLS,AL 	;;
	MOV	FTP.FTB_X,AL		;;
	MOV	FTP.FTB_Y,AL		;;
	MOV	FTP.FTB_COUNT,AX	;;
	MOV	FTP.FTB_DLEFT,AX	;;
	MOV	FTP.FTB_DLEN,AX 	;;
	MOV	FTP.FTB_DALO,AX 	;;
	MOV	FTP.FTB_DAHI,AX 	;;
	MOV	FTP.TARGET_LO,AX	;;
	MOV	FTP.TARGET_HI,AX	;;
					;;
	ADD	BX, TYPE FTBLK		;;
					;;
	DEC	DX			;;
	AND	DX,DX			;;
	JNZ	RESET_FTB		;;
					;;
	POP	BX			;;
NO_RESTART :				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; any FTBLKs have their data all
					;; returned ? if so set their status
					;; from FOUND to COMPLETE
	PUSH	BX			;;
	ADD	BX,TYPE FBUFS		;; FTP = FONT BLOCK
					;;
	MOV	DX,cs:num_ftb		   ;;
					;;
SET_COMPLETE :				;;
	MOV	AX,FTP.FTB_STATUS	;;
	CMP	AX,FSTAT_FONT		;;
	JNE	SET_NEXT		;;
					;;
	MOV	AX,FTP.FTB_DLEFT	;;
	AND	AX,AX			;;
	JNZ	SET_NEXT		;;
					;;
	MOV	FTP.FTB_STATUS,FSTAT_COMPLETE
					;;
SET_NEXT :				;;
					;;
	ADD	BX,TYPE FTBLK		;;
					;;
	DEC	DX			;;
	AND	DX,DX			;;
	JNZ	SET_COMPLETE		;;
					;;
	POP	BX			;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ADD	BX,TYPE FBUFS		;; FTP = FONT BLOCK
					;;
	PUSH	CX			;; STACK 1 = CX
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; DO WHILE CX is not zero :
;;
;; -- on each loop, the CX, COUNTs are updated
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;;
FTB_LOOP :				;;
	POP	AX			;; STACK -1
	SUB	AX,CX			;;
	ADD	cs:count_lo,AX		   ;;
	JNC	NO_CARRY		;;
	ADD	cs:count_hi,1000H	   ;;
NO_CARRY :				;;
	PUSH	CX			;; STACK 1 = CX
	AND	CX,CX			;;
	JNZ	FTB_CONT		;;
	JMP	FTB_LPEND		;;
					;; DO CASES :
FTB_CONT :				;; ==========
					;;
	MOV	AX,cs:stage		   ;;
					;;
	CMP	AX,STAGE_MAX		;;
	JNE	FTB_010 		;;
	JMP	START_CASE		;; ** RESTART **
					;;
FTB_010 :				;;
	CMP	AX,MATCHX		;;
	JAE	FTB_020 		;;
	JMP	SEARCH_CASE		;; ** SEARCH **
					;;
FTB_020 :				;;
	CMP	AX,MATCHX		;;
	JNE	FTB_030 		;;
	JMP	MATCH_CASE		;; ** MATCH **
					;;
FTB_030 :				;;
	CMP	AX,SCANX		;;
	JNE	FTB_040 		;;
	JMP	SCAN_CASE		;; ** SCAN **
					;;
FTB_040 :				;;
	CMP	AX,FOUNDX		;;
	JAE	FTB_050 		;;
	JMP	PRE_FOUND_CASE		;; ** PRE-FOUND **
					;;
FTB_050 :				;;
	CMP	AX,FOUNDX		;;
	JNE	FTB_060 		;;
	JMP	FOUND_CASE		;; ** FOUND  **
					;;
FTB_060 :				;;
	CMP	AX,GET_FX		;;
	JNE	FTB_070 		;;
	JMP	GETFONT_CASE		;; ** GET_FONT **
					;;
FTB_070 :				;;
	CMP	AX,PASSX		;;
	JNE	FTB_080 		;;
	JMP	PASS			;; ** PASS **
					;;
FTB_080 :				;;
	CMP	AX,FPTR_SKIPX		;;
	JAE	FTB_090 		;;
	JMP	SEARCH_CASE		;; ** SEARCH **
					;;
FTB_090 :				;;
	CMP	AX,FPTR_SKIPX		;;
	JNE	FTB_FFF 		;;
	JMP	FPTR_SKIP_CASE		;; ** SEARCH **
					;;
FTB_FFF :				;;
	MOV	FTP.FTB_STATUS,STAT_DEVERR
	JMP	FTB_LPEND		;; ** DEVICE ERROR **
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; at the entry of each STAGES /CASES
;;
;; --	DS:[SI]  (FPKT) points to PACKET, of DOS's buffer
;; --	CX	 remaining packet length
;; --	ES:[BX]  points to the first FTBLK
;; --	COUNT_LO, COUNT_HI, upto but and including the address pointed by FPKT
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
;============================================================================
START_CASE :				;; pass the FILE leading bytes
					;;
	MOV	cs:ftag_count,0 	   ;;
	MOV	cs:stage,ftagx		   ;;
	JMP	FTB_LOOP		;;
					;;
;=============================================================================
FPTR_SKIP_CASE :			;; skip until the ENTRY pointed by
					;; POINTER (in FPTR) is reached.
					;;
					;; **************
	MOV	AX,cs:fptr_low		   ;; * HIT = FPTR *
	MOV	cs:hit_lo,AX		   ;; **************
	MOV	DX,cs:fptr_high 	   ;;
	MOV	cs:hit_hi,DX		   ;;
					;;
	CMP	AX,0FFFFH		;;
	JNE	FPTR_SKIP_VALID 	;;
	CMP	DX,0FFFFH		;;
	JNE	FPTR_SKIP_VALID 	;;
					;;
	MOV	FTP.FTB_STATUS,STAT_BADATA ;; returned at the first FTBLK
	JMP	FPTR_SKIP_MORE		;;
					;;
FPTR_SKIP_VALID :			;;
					;; normalised HIT_HI, HIT_LO
	MOV	AX,DX			;;
	AND	AX,00FFFH		;;
	PUSH	CX			;;
	MOV	CX,4			;;
	SHL	AX,CL			;;
	POP	CX			;;
	AND	DX,0F000H		;;
	ADD	AX,cs:hit_lo		   ;;
	JNC	NO_CARRY10		;;
	ADD	DX,01000H		;;
NO_CARRY10:				;;
	MOV	cs:hit_lo,AX		   ;;
	MOV	cs:hit_hi,DX		   ;;
					;; **************************
					;; * compare FPTR and COUNT *
					;; **************************
					;; DX:AX = HIT_HI:HIT_LO (normalised)
					;;
	SUB	AX,cs:count_lo		   ;;
	Jnc	more_fptrlo		;;
	sub	dx,01000h		;;
	jc	fptr_bad		;;
					;;
more_fptrlo :				;;
	SUB	DX,cs:count_hi		   ;;
	JC	fptr_BAD		;;
					;;
	INC	AX			;; COUNT can be at the HIT, then AX=0
	JNC	NO_CARRY11		;; INC AX to make AX comparable to CX
	ADD	DX,01000H		;; i.e. AX = offset + 1
					;;
NO_CARRY11:				;;
	CMP	AX,CX			;;
	JA	fptr_skip_more		;; AX > CX, whole CX to be skipped
					;;
	PUSH	DX			;;  normalise dx:ax
	AND	DX,00FFFH		;;
	PUSH	CX			;;
	MOV	CX,4			;;
	SHL	DX,CL			;;
	POP	CX			;;
	ADD	AX,DX			;;
	POP	DX			;;
	JNC	NO_CARRY13		;;
	ADD	DX,01000H		;;
NO_CARRY13:				;;
	AND	DX,0F000H		;;
					;;
	PUSH	AX			;;
	PUSH	DX			;; STACK +1 : normalosed DX:AX
	SUB	AX,CX			;;
	JNC	NO_BORROW11		;;
	SUB	DX,1000H		;;
	JC	fptr_MORE_CXp		;; dx:ax < cx
NO_BORROW11:				;;
					;; dx:ax >= cx
	AND	AX,AX			;;
	JNE	fptr_skip_MOREP 	;;
	AND	DX,DX			;;
	JNE	fptr_skip_MOREP 	;;
					;; dx:ax = cx, or
					;; offset + 1 = CX
					;;
					;; ************************************
					;; * POINTER is within the current CX *
					;; ************************************
fptr_MORE_CXP : 			;;
	POP	DX			;;
	POP	AX			;; STACK -1
					;;
fptr_MORE_CX :				;; DX = 0,to have more CX than offset+1
	DEC	AX			;; = offset : 0 and above
	SUB	CX,AX			;;
	ADD	SI,AX			;; where the first byte is
					;;
	MOV	cs:stage,entry_lox	   ;; ENTRIES in the font file
					;;
	JMP	FTB_LOOP		;;  ******  RETURN  *******
					;;
					;; ***********************************
					;; * more to skip ==> FPTR_SKIP_CASE *
					;; ***********************************
fptr_skip_morep:			;;
	POP	DX			;;
	POP	AX			;; STACK -1
					;;
fptr_skip_more :			;;
	ADD	SI,CX			;;
	SUB	CX,CX			;;
	JMP	FTB_LOOP		;; ******  RETURN  *****
					;;
					;; ***********************************
					;; * bad POINTER in font file header *
					;; ***********************************
					;;
fptr_bad :				;;
	MOV	cs:fptr_low,0FFFFH	   ;;
	MOV	cs:fptr_high,0FFFFH	   ;;
					;;
	MOV	FTP.FTB_STATUS,STAT_BADATA ;; returned at the first FTBLK
					;;
	JMP	FPTR_SKIP_MORE		;;
					;;
;=============================================================================
SEARCH_CASE :				;;
					;; still looking for header to match
					;; the input : codepage and typeid
					;;
	MOV	DI,cs:stage		   ;;
					;;
	ADD	DI,DI			;; double to index to WORD-offset
					;;
	JMP	CS:STAGE_CASES[DI]	;; call routine to process the stage
					;;
					;;
;===========================================================================
MATCH_CASE :				;;
					;;
	PUSH	BX			;;
	MOV	DX,cs:num_ftb		   ;;
					;;
					;;
MATCH_LOOP :				;;
	MOV	AX,FTP.FTB_STATUS	;;
	CMP	AX,FSTAT_SEARCH 	;;
	JE	MATCH_SEARCH		;;
	JMP	MATCH_NEXT		;;
					;;
MATCH_SEARCH :				;;
	MOV	AX,FTP.FTB_CP		;; check the FTB with SEARCH status
	CMP	AX,cs:cpg_word		   ;;
	JNE	MATCH_MORE		;;
	PUSH	DS			;; code page matched
	PUSH	SI			;;
	PUSH	CX			;;
					;;
	PUSH	CS			;;
	POP	DS			;;
	MOV	SI,OFFSET TYPE_ID	;;
	LEA	DI,[BX].FTB_TID 	;;
	MOV	CX,8			;;
	REPE	CMPSB			;;
					;;
	POP	CX			;;
	POP	SI			;;
	POP	DS			;;
					;;
	JNE	MATCH_MORE		;;
					;; MATCH !!!!!	(type_id matched)
	MOV	FTP.FTB_STATUS,FSTAT_MATCH
	MOV	AX,cs:type_word 	   ;;
	MOV	FTP.FTB_TYPE,AX 	;;
	MOV	AX,cs:font_low		   ;;
	MOV	FTP.TARGET_LO,AX	;;
	MOV	AX,cs:font_high 	   ;;
	MOV	FTP.TARGET_HI,AX	;;
					;;
	JMP	MATCH_NEXT		;;
					;;
MATCH_MORE :				;; if this is the last rounf ?
					;;
	MOV	AX,cs:next_low		   ;; NEXT = FFFF:FFFF means no more
	CMP	AX,-1			;;	  header to come.
	JNE	MATCH_NEXT		;;
					;;
	MOV	AX,cs:next_high 	   ;;
	CMP	AX,-1			;;
	JNE	MATCH_NEXT		;;
					;;
	MOV	FTP.FTB_STATUS,STAT_NOFIND ;; ERROR : no match
					;;
MATCH_NEXT :				;;
	ADD	BX,FTP.FTB_LENGTH	;;
	DEC	DX			;;
	AND	DX,DX			;;
	JZ	MATCH_ALL		;;
	JMP	MATCH_LOOP		;;
					;;
MATCH_ALL :				;;
	MOV	cs:stage,SCANX		   ;;
					;;
MATCH_DONE :				;;
	POP	BX			;;
	JMP	FTB_LOOP		;;
					;;
;===========================================================================
SCAN_CASE :				;;
					;; **********************************
					;; * determine whether it the font  *
					;; * data(TARGET),or the next font  *
					;; * header(NEXT) that is approaching
					;; **********************************
					;;
	MOV	AX,cs:next_low		   ;;
	MOV	cs:hit_lo,AX		   ;;
	MOV	AX,cs:next_high 	   ;;
	MOV	cs:hit_hi,AX		   ;;
	XOR	AX,AX			;;
	MOV	cs:hit_flag,AX		   ;;
					;;
	MOV	DI,cs:hit_hi		   ;; normalised HIT_HI, HIT_LO
	MOV	AX,DI			;;
	AND	AX,00FFFH		;;
	PUSH	CX			;;
	MOV	CX,4			;;
	SHL	AX,CL			;;
	POP	CX			;;
	AND	DI,0F000H		;;
	ADD	AX,cs:hit_lo		   ;;
	JNC	NO_CARRY2		;;
	ADD	DI,01000H		;;
NO_CARRY2 :				;;
	MOV	cs:hit_lo,AX		   ;;
	MOV	cs:hit_hi,DI		   ;;
					;;
	MOV	DX,cs:num_ftb		   ;;
					;;
	PUSH	BX			;;
SCAN_LOOP :				;;
	MOV	AX,FTP.FTB_STATUS	;;
	CMP	AX,FSTAT_MATCH		;;
	JNE	SCAN_NEXT		;;
					;;
					;;
	MOV	DI,FTP.TARGET_HI	;; NORMALISED TARGET
	MOV	AX,DI			;;
	AND	AX,00FFFH		;;
	PUSH	CX			;;
	MOV	CX,4			;;
	SHL	AX,CL			;;
	POP	CX			;;
	AND	DI,0F000H		;;
	ADD	AX,FTP.TARGET_LO	;;
	JNC	NO_CARRY1		;;
	ADD	DI,01000H		;;
NO_CARRY1 :				;; DI:AX = NORMALISED TARGET
					;;
					;; ** compare the TARGET and the NEXT
					;;
	CMP	DI,cs:hit_hi		   ;;
	JA	SCAN_NEXT		;;
					;;
	JE	SCAN_EQU		;;
	JMP	NEAR_FONT		;;
					;;
SCAN_EQU :				;;
	CMP	AX,cs:hit_lo		   ;;
	JA	SCAN_NEXT		;;
	JE	SCAN_ERROR_CHK		;;
					;; **********************************
					;; * the font data is approaching   *
					;; **********************************
NEAR_FONT :				;;
	MOV	cs:hit_flag,-1		   ;;
	MOV	cs:hit_lo,AX		   ;;
	MOV	cs:hit_hi,DI		   ;;
	MOV	cs:hit_bx,BX		   ;; used for BAD_BX and in FOUND_CASE
	JMP	SCAN_NEXT		;;
					;;
					;; **********************************
					;; * the NEXT header is approaching *
					;; **********************************
SCAN_ERROR_CHK :			;;
	MOV	AX,cs:hit_flag		   ;;
	AND	AX,AX			;;
	JNZ	SCAN_NEXT		;;
	MOV	FTP.FTB_STATUS,STAT_BADATA ;; next header and font cannot be the
					;; same
					;;
SCAN_NEXT :				;;
	DEC	DX			;;
	AND	DX,DX			;;
	JZ	SCAN_DONE		;;
					;;
	ADD	BX,FTP.FTB_LENGTH	;;
	JMP	SCAN_LOOP		;; ** is there any closer font data ?
					;;
					;; ************************************
					;; * the HIT is either font data(TARGET
					;; * or the font block (NEXT).	      *
					;; ************************************
SCAN_DONE :				;;
	POP	BX			;;
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	MOV	DX,cs:hit_hi		   ;; HIT_FLAG, HIT_LO, HIT_HI defined
	MOV	AX,cs:hit_lo		   ;;
					;;
	CMP	AX,0FFFFH		;;
	JNE	NOT_FFFF_HIT		;;
	CMP	DX,0FFFFH		;;
	JNE	NOT_FFFF_HIT		;;
	JMP	SCAN_MORE		;; stage remained as SCAN, discard data
					;;
NOT_FFFF_HIT :				;;
					;; DX:AX = HIT_HI:HIT_LO (normalised)
	SUB	AX,cs:count_lo		   ;;
	JNC	NO_BORROW		;;
	SUB	DX,01000H		;;
	JC	SCAN_BAD		;;
NO_BORROW:				;;
	SUB	DX,cs:count_hi		   ;;
	JC	SCAN_BAD		;;
					;;
	INC	AX			;; COUNT can be at the HIT, then AX=0
	JNC	NO_CARRYX		;; INC AX to make AX comparable to CX
	ADD	DX,01000H		;; i.e. AX = offset + 1
					;;
NO_CARRYX :				;;
	CMP	AX,CX			;;
	JA	SCAN_MORE		;;
					;;
	PUSH	DX			;;
	AND	DX,00FFFH		;;
	PUSH	CX			;;
	MOV	CX,4			;;
	SHL	DX,CL			;;
	POP	CX			;;
	ADD	AX,DX			;;
	POP	DX			;;
	JNC	NO_CARRY3		;;
	ADD	DX,01000H		;;
NO_CARRY3 :				;;
	AND	DX,0F000H		;;
					;;
					;;
	PUSH	AX			;;
	PUSH	DX			;;
	SUB	AX,CX			;;
	JNC	NO_BORROW1		;;
	SUB	DX,1000H		;;
	JC	MORE_CXp		;;
NO_BORROW1 :				;;
					;; dx:ax >= cx
	AND	AX,AX			;;
	JNE	SCAN_MOREP		;;
	AND	DX,DX			;;
	JNE	SCAN_MOREP		;;
					;;
					;; offset + 1 = CX
					;;
MORE_CXP :				;;
	POP	DX			;;
	POP	AX			;;
					;;
MORE_CX :				;; DX = 0,to have more CX than offset+1
	DEC	AX			;; = offset : 0 and above
	SUB	CX,AX			;;
	ADD	SI,AX			;; where the first byte is
	MOV	AX,cs:hit_flag		   ;;
	AND	AX,AX			;;
	JE	NEXT_REACHED		;;
					;;
	MOV	cs:stage,MOD_LOBX	   ;; font-data reached,
					;;
	JMP	FTB_LOOP		;;  ****** RETURN   *******
					;;
NEXT_REACHED :				;;
	MOV	cs:stage,PASSX		   ;;
	MOV	cs:pass_postx,next_lolX    ;;
	MOV	cs:pass_cnt,FILE_OFFSET    ;;
					;;
					;;
	JMP	FTB_LOOP		;; ******  RETURN   *******
					;;
					;; ***********************************
SCAN_MOREP :				;; * scan more FTBLK for the nearest *
					;; * font data			     *
					;; ***********************************
	POP	DX			;;
	POP	AX			;;
					;;
SCAN_MORE :				;;
	ADD	SI,CX			;;
	SUB	CX,CX			;;
	JMP	FTB_LOOP		;; more SCAN stage
					;;
SCAN_BAD:				;; *************************
	MOV	AX,cs:hit_flag		   ;; * scan is bad	      *
	AND	AX,AX			;; *************************
	JNZ	BAD_BX			;;
	MOV	AX,-1			;; NEXT is pointing backwards
	MOV	cs:next_low,AX		   ;;
	MOV	cs:next_high,AX 	   ;; no more NEXT
	MOV	FTP.FTB_STATUS,STAT_BADATA ;; returned at the first FTBLK
	JMP	FTB_LOOP		;;
					;;
BAD_BX	:				;;
	PUSH	BX			;; FONT is pointing backwards
	MOV	BX,cs:hit_bx		   ;;
	MOV	FTP.FTB_STATUS,STAT_BADATA
	POP	BX			;;
	JMP	FTB_LOOP		;;
					;;
;===========================================================================
PRE_FOUND_CASE :			;;
					;; extract informations from the font
					;; block until font_length is defined
					;;
	MOV	DI,cs:stage		   ;;
					;;
	ADD	DI,DI			;; double to index to WORD-offset
					;;
	JMP	CS:STAGE_CASES[DI]	;; call routine to process the stage
					;;
;===========================================================================
FOUND_CASE :				;;
	MOV	DI,OFFSET FTB_LOOP	;; as FOUND has two places to return to
	PUSH	DI			;;
;===========================================================================
FOUND_DO :				;;
					;; define informations into FTBLK of
					;; HIT_BX defined in the SCAN case
	PUSH	BX			;;
	MOV	BX,cs:hit_bx		   ;;
					;; FTBLK :
	MOV	AX,cs:mod_word		   ;;
	MOV	FTP.FTB_MOD,AX		;;
	MOV	AX,cs:fonts_word	   ;;
	MOV	FTP.FTB_FONTS,AX	;;
					;;
	MOV	AX,cs:fdlen_word	   ;;
	MOV	FTP.FTB_DLEFT,AX	;;
	MOV	FTP.FTB_DLEN,0		;;
	MOV	FTP.FTB_DALO,0		;;
	MOV	FTP.FTB_DAHI,0		;;
					;;
	MOV	FTP.FTB_STATUS,FSTAT_FOUND
					;;
	CMP	FTP.FTB_TYPE,TYPE_DISPLAY;
	JNE	CHECK_PTR_TYPE		;;
	CMP	cs:pre_font_len,PRE_FONT_D ;;
	JNE	DISPLAY_BAD		;;
	JMP	DISPLAY_DONE		;;
					;;
CHECK_PTR_TYPE :			;;
	CMP	FTP.FTB_TYPE,TYPE_PRINTER;
	JNE	SET_STAGE		;;
	CMP	cs:ptr_sel_word,0	   ;;
	JNE	PRINTER_HAS_SEL 	;;
	CMP	cs:pre_font_len,PRE_FONT_P0;;
	JNE	PRINTER_BAD		;;
	JMP	PRINTER_DONE		;;
					;;
PRINTER_HAS_SEL :			;;
	CMP	cs:pre_font_len,PRE_FONT_P ;;
	JNE	PRINTER_BAD		;;
	JMP	PRINTER_DONE		;;
					;;
DISPLAY_BAD :				;;
					;;
	MOV	FTP.FTB_STATUS,STAT_BADATA ;the FDLEN_WORD should be 0.
					;;
DISPLAY_DONE :				;;
	MOV	AL,cs:disp_rows 	   ;;
	MOV	FTP.FTB_ROWS,AL 	;;
	MOV	AL,cs:disp_cols 	   ;;
	MOV	FTP.FTB_COLS,AL 	;;
	MOV	AL,cs:disp_x		   ;;
	MOV	FTP.FTB_X,AL		;;
	MOV	AL,cs:disp_y		   ;;
	MOV	FTP.FTB_Y,AL		;;
	MOV	AX,cs:count_word	   ;;
	MOV	FTP.FTB_COUNT,AX	;;
	JMP	SET_STAGE		;;
					;;
PRINTER_BAD :				;;
					;;
	MOV	FTP.FTB_STATUS,STAT_BADATA ;the FDLEN_WORD should be 0.
					;;
PRINTER_DONE :				;;
	MOV	AX,cs:ptr_sel_word	   ;;
	MOV	FTP.FTB_SELECT,AX	;;
	MOV	AX,cs:ptr_len_word	   ;;
	MOV	FTP.FTB_SELLEN,AX	;;
					;;
SET_STAGE :				;; STAGE :
	MOV	AX,cs:fdlen_word	   ;; if no font data to follow
	AND	AX,AX			;;
	JNZ	GET_FDATA		;;
	MOV	cs:stage,SCANX		   ;; then scan for next header or font
	JMP	FONT_RET		;;
					;;
GET_FDATA :				;; update the moving target
	MOV	cs:stage,GET_FX 	   ;;
	MOV	AX,cs:pre_font_len	   ;;
	ADD	FTP.TARGET_LO,AX	;;
	JNC	FONT_RET		;;
	ADD	FTP.TARGET_HI,01000H	;;
					;;
FONT_RET :				;;
	POP	BX			;;
	RET				;;
					;;
;===========================================================================
GETFONT_CASE :				;; as ES:[SI], at COUNT, there is font
					;; data
	MOV	DX,cs:num_ftb		   ;;
	PUSH	BX			;;
					;;
	MOV	cs:hit_hi,0		   ;; temp. register
	MOV	cs:hit_flag,0		   ;; assumed can be changed to SCAN stage
					;;
	MOV	DI,cs:count_hi		   ;; normalised COUNT_HI,COUNT_LO
	MOV	AX,DI			;;
	AND	AX,00FFFH		;;
	PUSH	CX			;;
	MOV	CX,4			;;
	SHL	AX,CL			;;
	POP	CX			;;
	AND	DI,0F000H		;;
	ADD	AX,cs:count_lo		   ;;
	JNC	NO_CARRY4		;;
	ADD	DI,01000H		;;
NO_CARRY4 :				;;
	MOV	cs:count_lo,AX		   ;;
	MOV	cs:count_hi,DI		   ;;
					;;
					;;
GETFONT_LOOP :				;;
	MOV	AX,FTP.FTB_STATUS	;;
	CMP	AX,FSTAT_FONT		;;
	JE	GETFONT_CONT		;;
					;;
	CMP	AX,FSTAT_FOUND		;;
	JE	GETFONT_FOUND		;;
					;;
	JMP	NEXT_GETFONT		;;
					;;
GETFONT_FOUND : 			;;
	MOV	AX,FTP.FTB_DLEFT	;;
	AND	AX,AX			;;
	JZ	NEXT_GF 		;;
	MOV	FTP.FTB_STATUS,FSTAT_FONT;
	JMP	GETFONT_CONT1		;;
					;;
					;;
GETFONT_CONT :				;;
	MOV	AX,FTP.FTB_DLEFT	;;
	AND	AX,AX			;;
	JNZ	GETFONT_CONT1		;;
NEXT_GF :				;;
	JMP	NEXT_GETFONT		;;
					;; only on FOUND and DLEFT <> 0
GETFONT_CONT1:				;;
	MOV	DI,FTP.TARGET_HI	;; normalised TARGET
	MOV	AX,DI			;;
	AND	AX,00FFFH		;;
	PUSH	CX			;;
	MOV	CX,4			;;
	SHL	AX,CL			;;
	POP	CX			;;
	AND	DI,0F000H		;;
	ADD	AX,FTP.TARGET_LO	;;
	JNC	NO_CARRY5		;;
	ADD	DI,01000H		;;
NO_CARRY5 :				;; DI:AX = TARGET (normalised)
					;;
	CMP	DI,cs:count_hi		   ;;
	JB	GETFONT_BAD		;;
	JNE	NEXT_GETFONT		;;
	CMP	AX,cs:count_lo		   ;;
	JB	GETFONT_BAD		;;
	JNE	NEXT_GETFONT		;;
					;;
	MOV	FTP.FTB_DALO,SI 	;; where the font data is in the packet
	MOV	FTP.FTB_DAHI,DS 	;;
					;;
	MOV	AX,FTP.FTB_DLEFT	;;
	CMP	AX,CX			;;
	JAE	UPTO_CX 		;;
					;; upto FDLEFT
	MOV	FTP.FTB_DLEFT,0 	;;
	MOV	FTP.FTB_DLEN,AX 	;;
	CMP	cs:hit_hi,AX		   ;;
	JNB	NOT_HIGHER0		;;
	MOV	cs:hit_hi,AX		   ;;
NOT_HIGHER0 :				;;
	ADD	FTP.TARGET_LO,AX	;;
	JNC	NEXT_GETFONT		;;
	ADD	FTP.TARGET_HI,01000H	;;
	JMP	NEXT_GETFONT		;;
					;;
GETFONT_BAD :				;;
	MOV	FTP.FTB_STATUS,STAT_BADATA ;; pointing backwards
	JMP	NEXT_GETFONT		;;
					;;
UPTO_CX :				;;
	SUB	AX,CX			;;
	MOV	FTP.FTB_DLEFT,AX	;;
	MOV	FTP.FTB_DLEN,CX 	;;
	MOV	cs:hit_hi,CX		   ;;
	ADD	FTP.TARGET_LO,CX	;;
	JNC	NO_CARRYOVER		;;
	ADD	FTP.TARGET_HI,01000H	;;
NO_CARRYOVER :				;;
	AND	AX,AX			;; all data have been returned ?
	JZ	NEXT_GETFONT		;;
					;;
	MOV	cs:hit_flag,-1		   ;; no ! stay in the GET_FONT stage
					;;
NEXT_GETFONT :				;;
	ADD	BX,FTP.FTB_LENGTH	;;
	DEC	DX			;;
	AND	DX,DX			;;
	JZ	GETFONT_END		;;
	JMP	GETFONT_LOOP		;;
					;;
GETFONT_END :				;;
	MOV	AX,cs:hit_hi		   ;;
	ADD	SI,AX			;;
	SUB	CX,AX			;;
					;;
	CMP	cs:hit_flag,0		   ;;
	Jne	GETFONT_DONE		;;
	MOV	cs:stage,SCANX		   ;; no more in the GET_FONT stage
					;;
					;;
GETFONT_DONE :				;;
	POP	BX			;;
	JMP	FTB_LOOP		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; STAGES --  "called by" SERACH_CASE
;;
;; --	DS:[SI]  (FPKT) points to PACKET, of DOS's buffer
;; --	CX	 remaining packet length
;; --	ES:[BX]  points to the first FTBLK
;; --	COUNT_LO, COUNT_HI, upto but not including the address pointed by FPKT
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;+++++++++++++++++++++++++++++++++
filetag :				;;
					;;
;	mov	ax,ftag_len		;;
	cmp	cs:ftag_count,ftag_len	   ;;
	jB	valid_ftag		;;
	JE	FTAG_FAILED		;;
					;;
	mov	ftp.ftb_status,stat_deverr
	mov	cs:fp_error,00022H	   ;; ERROR 0022H
					;;
FTAG_FAILED :				;; discard all the bytes, while
	ADD	SI,CX			;; stage stays as FTAGX
	SUB	CX,CX			;;
	JMP	FTB_LOOP		;; **** RETURN (bytes discarded) ****
					;;
VALID_FTAG :				;;
	MOV	AX,FPKT 		;;
	INC	SI			;;
	DEC	CX			;;
					;;
	MOV	DI,cs:ftag_count	   ;;
	CMP	AL,cs:ftag_pattern[DI]	   ;;
	JE	FTAG_NEXTB		;;
					;;
	mov	ftp.ftb_status,stat_badata
	MOV	ax,ftag_len		;; stays in FTAGX to consume all bytes
	MOV	cs:ftag_count,ax	   ;; stays in FTAGX to consume all bytes
	JMP	FTB_LOOP		;; **** RETURN (FAILED !)  ****
					;;
FTAG_NEXTB :				;;
	INC	DI			;;
	MOV	cs:ftag_count,DI	   ;;
					;;
	CMP	DI,ftag_len		;;
	JE	FTAG_DONE		;;
					;;
	JMP	FTB_LOOP		;; **** RETURN ( MORE TO COME) ****
					;;
FTAG_DONE :				;;
	MOV	cs:pass_cnt,0		   ;;
	MOV	cs:stage,PASSX		   ;;
	MOV	cs:pass_postx,fptr_lolx    ;;
					;;
	JMP	FTB_LOOP		;; **** NEXT STAGE ****
					;;
					;;+++++++++++++++++++++++++++++++++
fptrLOL :				;; STAGE the low byte of the low fptr
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_fptrLO		;;
	MOV	cs:fptr_lol,AL		   ;;
	MOV	cs:stage,fptr_lohX	   ;;
	JMP	FTB_LOOP		;;
WORD_fptrLO :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:fptr_low,AX		   ;;
	MOV	cs:stage,fptr_HILX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
fptrLOH :				;; STAGE the high byte of the low fptr
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:fptr_loh,AL		   ;;
	MOV	cs:stage,fptr_HILX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
fptrHIL :				;; STAGE the low byte of the high fptr
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_fptrHI		;;
	MOV	cs:fptr_hil,AL		   ;;
	MOV	cs:stage,fptr_hihX	   ;;
	JMP	FTB_LOOP		;;
WORD_fptrHI :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:fptr_high,AX 	   ;;
	MOV	cs:stage,FPTR_SKIPX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
fptrHIH :				;; STAGE the high byte of the high fptr
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:fptr_hih,AL		   ;;
	MOV	cs:stage,FPTR_SKIPX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
ENTRYLO :				;; STAGE - ENTRY LOW BYTE
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_ENTRY		;;
	MOV	cs:entry_lob,AL 	   ;;
	MOV	cs:stage,ENTRY_HIX	   ;;
	JMP	FTB_LOOP		;;
WORD_ENTRY :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:entry_word,AX	   ;;
	MOV	cs:stage,PASSX		   ;; 2 bytes to be passed
	MOV	cs:pass_postx,NEXT_LOLX    ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
ENTRYHI :				;; stage - ENTRY HIGN BYTE
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:entry_hib,AL 	   ;;
	MOV	cs:stage,PASSX		   ;; 2 bytes to be passed
	MOV	cs:pass_postx,NEXT_LOLX    ;;
	AND	CX,CX			;;
	JNZ	ENTHI_PASS1		;;
	JMP	FTB_LOOP		;;
ENTHI_PASS1 :				;;
	INC	SI			;;
	INC	cs:pass_cnt		   ;;
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	ENTHI_PASS2		;;
	JMP	FTB_LOOP		;;
ENTHI_PASS2 :				;;
	INC	SI			;;
	INC	cs:pass_cnt		   ;;
	DEC	CX			;;
	MOV	cs:stage,NEXT_LOLX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
NEXTLOL :				;; STAGE the low byte of the low NEXT
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_NEXTLO		;;
	MOV	cs:next_lol,AL		   ;;
	MOV	cs:stage,NEXT_LOHX	   ;;
	JMP	FTB_LOOP		;;
WORD_NEXTLO :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:next_low,AX		   ;;
	MOV	cs:stage,next_hilX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
NEXTLOH :				;; STAGE the high byte of the low NEXT
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:next_loh,AL		   ;;
	MOV	cs:stage,next_hilX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
NEXTHIL :				;; STAGE the low byte of the high NEXT
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_NEXTHI		;;
	MOV	cs:next_hil,AL		   ;;
	MOV	cs:stage,NEXT_HIHX	   ;;
	JMP	FTB_LOOP		;;
WORD_NEXTHI :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:next_high,AX 	   ;;
	MOV	cs:stage,type_lobX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
NEXTHIH :				;; STAGE the high byte of the high NEXT
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:next_hih,AL		   ;;
	MOV	cs:stage,type_lobX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
TYPELO	:				;; STAGE the low byte of the TYPE
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_TYPE		;;
	MOV	cs:type_lob,AL		   ;;
	MOV	cs:stage,type_hibX	   ;;
	JMP	FTB_LOOP		;;
WORD_TYPE :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:type_word,AX 	   ;;
	MOV	cs:stage,type_idX	   ;;
	MOV	cs:tid_cnt,0		   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
TYPEHI	:				;; STAGE the high byte of the TYPE
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:type_hib,AL		   ;;
	MOV	cs:stage,TYPE_IDX	   ;;
	MOV	cs:tid_cnt,0		   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
TYPEIDS :				;; STAGE the type id
	CMP	cs:tid_cnt,8		   ;;
	JNA	VALID_TID		;;
	MOV	FTP.FTB_STATUS,STAT_DEVERR
	MOV	cs:fp_error,00021H	   ;; ERROR 0021H
	ADD	SI,CX			;;
	SUB	CX,CX			;;
	JMP	FTB_LOOP		;;
					;;
VALID_TID :				;;
	MOV	AX,8			;;
	SUB	AX,cs:tid_cnt		   ;;
	CMP	CX,AX			;;
	JNB	TID_ALL 		;;
					;; all data in FPKT are stored
	PUSH	ES			;;
	PUSH	CS			;;
	POP	ES			;;
					;;
	MOV	DI,OFFSET TYPE_ID	;;
	ADD	DI,cs:tid_cnt		   ;;
	ADD	cs:tid_cnt,CX		   ;;
	REP	MOVSB			;; SI is incremented accordingly
	POP	ES			;;
					;;
	MOV	CX,0			;; STAGE remained
	JMP	FTB_LOOP		;;
TID_ALL :				;;
	PUSH	CX			;;
					;;
	PUSH	ES			;;
	PUSH	CS			;;
	POP	ES			;;
					;;
	MOV	DI,OFFSET TYPE_ID	;;
	ADD	DI,cs:tid_cnt		   ;;
	MOV	CX,AX			;;
	REP	MOVSB			;; SI is incremented accordingly
	POP	ES			;;
					;;
	ADD	cs:tid_cnt,AX		   ;;
	POP	CX			;;
	SUB	CX,AX			;;
					;;
	MOV	cs:stage,CPG_LOBX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
CPGLO	:				;; STAGE the low byte of the CODE PAGE
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_CPG		;;
	MOV	cs:cpg_lob,AL		   ;;
	MOV	cs:stage,CPG_HIBX	   ;;
	JMP	FTB_LOOP		;;
WORD_CPG :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:cpg_word,AX		   ;;
	MOV	cs:stage,PASSX		   ;;
	MOV	cs:pass_postx,font_lolX    ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
CPGHI	:				;; STAGE the high byte of the CODE PAGE
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:cpg_hib,AL		   ;;
	MOV	cs:stage,PASSX		   ;;
	MOV	cs:pass_postx,font_lolX    ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
FONTLOL :				;; STAGE the low byte of the low FONT
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_FONTLO		;;
	MOV	cs:font_lol,AL		   ;;
	MOV	cs:stage,FONT_LOHX	   ;;
	JMP	FTB_LOOP		;;
WORD_FONTLO :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:font_low,AX		   ;;
	MOV	cs:stage,FONT_HILX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
FONTLOH :				;; STAGE the high byte of the low FONT
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:font_loh,AL		   ;;
	MOV	cs:stage,FONT_HILX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
FONTHIL :				;; STAGE the low byte of the high FONT
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_FONTHI		;;
	MOV	cs:font_hil,AL		   ;;
	MOV	cs:stage,FONT_HIHX	   ;;
	JMP	FTB_LOOP		;;
WORD_FONTHI :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:font_high,AX 	   ;;
;;;;;;	MOV	cs:stage,MOD_LOBX	   ;; end of SCAN
					;; anymore headers to be processed ?
	MOV	cs:stage,MATCHX 	   ;;
	MOV	AX,cs:entry_word	   ;;
	DEC	AX			;;
	MOV	cs:entry_word,AX	   ;;
	AND	AX,AX			;;
	JNZ	CHECK_NEXT		;;
					;; no more header to be processed !
	MOV	AX,-1			;;
	MOV	cs:next_low,AX		   ;;
	MOV	cs:next_high,AX 	   ;; as ENTRY has been consumed
	JMP	FTB_LOOP		;;
					;;
CHECK_NEXT :				;;
	MOV	AX,cs:next_low		   ;;
	AND	AX,AX			;;
	JNZ	MORE_HEADER		;;
	MOV	AX,cs:next_high 	   ;;
	AND	AX,AX			;;
	JNZ	MORE_HEADER		;;
					;; no more header to be processed !
	MOV	AX,-1			;;
	MOV	cs:next_low,AX		   ;; as NEXT is nil
	MOV	cs:next_high,AX 	   ;;
					;;
MORE_HEADER :				;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
FONTHIH :				;; STAGE the high byte of the high FONT
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:font_hih,AL		   ;;
;;;;;	MOV	cs:stage,MOD_LOBX	   ;; end of SCAN
					;;
	MOV	cs:stage,MATCHX 	   ;;
					;; anymore headers to be processed ?
	MOV	AX,cs:entry_word	   ;;
	DEC	AX			;;
	MOV	cs:entry_word,AX	   ;;
	AND	AX,AX			;;
	JNZ	CHECK_NEXT0		;;
					;; no more header to be processed !
	MOV	AX,-1			;;
	MOV	cs:next_low,AX		   ;;
	MOV	cs:next_high,AX 	   ;; as ENTRY has been consumed
	JMP	FTB_LOOP		;;
					;;
CHECK_NEXT0 :				;;
	MOV	AX,cs:next_low		   ;;
	AND	AX,AX			;;
	JNZ	MORE_HEADER0		;;
	MOV	AX,cs:next_high 	   ;;
	AND	AX,AX			;;
	JNZ	MORE_HEADER0		;;
					;; no more header to be processed !
	MOV	AX,-1			;;
	MOV	cs:next_low,AX		   ;; as NEXT is nil
	MOV	cs:next_high,AX 	   ;;
					;;
MORE_HEADER0 :				;;
	JMP	FTB_LOOP		;;
					;;
					;;+++++++++++++++++++++++++++++++++
MODLO	:				;; STAGE the low byte of the MODIFIER
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_MOD		;;
	MOV	MOD_LOB,AL		;;
	MOV	cs:stage,MOD_HIBX	   ;;
	JMP	FTB_LOOP		;;
WORD_MOD :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:mod_word,AX		   ;;
	MOV	cs:stage,fonts_lobX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
MODHI	:				;; STAGE the high byte of the MODIFIER
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:mod_hib,AL		   ;;
	MOV	cs:stage,FONTS_LOBX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
FONTSLO :				;; STAGE the low byte of the FONTS
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_FONTS		;;
	MOV	cs:fonts_lob,AL 	   ;;
	MOV	cs:stage,FONTS_HIBX	   ;;
	JMP	FTB_LOOP		;;
WORD_FONTS :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:fonts_word,AX	   ;;
	MOV	cs:stage,FDLEN_LOBX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
FONTSHI :				;; STAGE the high byte of the FONTS
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:fonts_hib,AL 	   ;;
	MOV	cs:stage,FDLEN_LOBX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
FDLENLO :				;; the low byte of the FONT-LENGTH
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	AND	CX,CX			;;
	JNZ	WORD_FDLEN		;;
	MOV	cs:fdlen_lob,AL 	   ;;
	MOV	cs:stage,FDLEN_HIBX	   ;;
	JMP	FTB_LOOP		;;
WORD_FDLEN :				;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:pre_font_len,PRE_FONT_ND;;
	MOV	cs:fdlen_word,AX	   ;;
	AND	AX,AX			;;
	JZ	NO_DISP_PTR		;;
	CMP	cs:type_word,TYPE_DISPLAY  ;;
	JE	DISPLAY_TYPE1		;;
	CMP	cs:type_word,TYPE_PRINTER  ;;
	JE	PRINTER_TYPE1		;;
					;;
NO_DISP_PTR :				;;
	MOV	cs:stage,FOUNDX 	   ;; FSTAT is to be changed
	JMP	FTB_LOOP		;;
DISPLAY_TYPE1 : 			;;
	MOV	cs:stage,DISP_ROWSX	   ;;
	JMP	FTB_LOOP		;;
PRINTER_TYPE1 : 			;;
	MOV	cs:stage,PTRSELLOX	   ;;
	JMP	FTB_LOOP		;;
					;;
					;;+++++++++++++++++++++++++++++++++
FDLENHI :				;; STAGE the high byte of the F-LENGTH
	MOV	cs:pre_font_len,PRE_FONT_ND
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:fdlen_hib,AL 	   ;;
	MOV	AX,cs:fdlen_word	   ;;
	AND	AX,AX			;;
	JZ	NO_DISP_PTR2		;;
	CMP	cs:type_word,TYPE_DISPLAY  ;;
	JE	DISPLAY_TYPE2		;;
	CMP	cs:type_word,TYPE_PRINTER  ;;
	JE	PRINTER_TYPE2		;;
NO_DISP_PTR2:				;;
	MOV	cs:stage,FOUNDX 	   ;; FSTAT is to be changed
	JMP	FTB_LOOP		;;
DISPLAY_TYPE2 : 			;;
	MOV	cs:stage,DISP_ROWSX	   ;;
	JMP	FTB_LOOP		;;
PRINTER_TYPE2 : 			;;
	MOV	cs:stage,PTRSELLOX	   ;;
	JMP	FTB_LOOP		;;
					;;
					;;+++++++++++++++++++++++++++++++++
DSPROWS :				;; STAGE : get the rows
	XOR	AX,AX			;;
	MOV	cs:disp_rows,AL 	   ;;
	MOV	cs:disp_cols,AL 	   ;;
	MOV	cs:DISP_X,AL		   ;;
	MOV	cs:disp_y,AL		   ;;
	MOV	cs:count_word,AX	   ;;
					;;
	INC	cs:pre_font_len 	  ;;
	MOV	AX,FPKT 		;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:disp_rows,AL 	   ;;
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	JZ	NO_DISP_FONT3		;;
	MOV	cs:stage,disp_colsX	   ;;
	JMP	FTB_LOOP		;;
NO_DISP_FONT3 : 			;;
	MOV	cs:stage,FOUNDX 	   ;; FSTAT is to be changed
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
DSPCOLS :				;; STAGE : get the COLS
	INC	cs:pre_font_len 	  ;;
	MOV	AX,FPKT 		;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:disp_cols,AL 	   ;;
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	JZ	NO_DISP_FONT3		;;
	MOV	cs:stage,DISP_XX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
DSPX :					;; STAGE : get the aspect X
	INC	cs:pre_font_len 	  ;;
	MOV	AX,FPKT 		;;
	INC	SI			;;
	DEC	CX			;;
	MOV	DISP_X,AL		;;
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	JZ	NO_DISP_FONT3		;;
	MOV	cs:stage,DISP_YX	   ;;
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
DSPY :					;; STAGE : get the aspect Y
	INC	cs:pre_font_len 	  ;;
	MOV	AX,FPKT 		;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:disp_y,AL		   ;;
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	JZ	NO_DISP_FONT3		;;
	MOV	cs:stage,COUNT_LOBX	   ;;
	JMP	FTB_LOOP		;;
					;;
					;;+++++++++++++++++++++++++++++++++
DSPCOUNTLO :				;; the low byte of the FONT-LENGTH
	INC	cs:pre_font_len 	  ;;
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	PUSH	AX			;; check if length is enough
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	POP	AX			;;
	JNZ	A_WORD_COUNT		;;
	JMP	NO_DISP_FONT3		;;
A_WORD_COUNT :				;;
	AND	CX,CX			;;
	JNZ	WORD_COUNT		;;
	MOV	cs:count_lob,AL 	   ;;
	MOV	cs:stage,COUNT_HIBX	   ;;
	JMP	FTB_LOOP		;;
WORD_COUNT :				;;
	INC	cs:pre_font_len 	  ;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:count_word,AX	   ;;
;	MOV	cs:pre_font_len,PRE_FONT_D;
					;;
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	MOV	cs:stage,FOUNDX 	   ;; FSTAT is to be changed
	JMP	FTB_LOOP		;;
					;;
					;;+++++++++++++++++++++++++++++++++
DSPCOUNTHI :				;; STAGE the high byte of the F-LENGTH
	INC	cs:pre_font_len 	  ;;
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:count_hib,AL 	   ;;
;	MOV	cs:pre_font_len,PRE_FONT_D;
					;;
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	MOV	cs:stage,FOUNDX 	   ;; FSTAT is to be changed
	JMP	FTB_LOOP		;;
					;;
					;;
					;;+++++++++++++++++++++++++++++++++
PTRSELLO :				;; the low byte of the SELECTION_TYPE
	INC	cs:pre_font_len 	  ;;
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	PUSH	AX			;; check if length is enough
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	POP	AX			;;
	JNZ	A_WORD_SEL		;;
	JMP	NO_PTR_FONT3		;;
A_WORD_SEL :				;;
	AND	CX,CX			;;
	JNZ	WORD_SEL		;;
	MOV	cs:ptr_selob,AL 	   ;;
	MOV	cs:stage,PTRSELHIX	   ;;
	JMP	FTB_LOOP		;;
WORD_SEL :				;;
	INC	cs:pre_font_len 	   ;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:ptr_sel_word,AX	   ;;
					;;
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
					;;
	CMP	cs:ptr_sel_word,0	   ;;
	JNE	PTR_SEL_NOT0		;;
					;;
					;;
	MOV	cs:stage,FOUNDX 	   ;; FSTAT is to be changed
	JMP	FTB_LOOP		;;
					;;
PTR_SEL_NOT0 :				;;
	MOV	cs:stage,PTRLENLOX	   ;;
	JMP	FTB_LOOP		;;
					;;
					;;+++++++++++++++++++++++++++++++++
PTRSELHI:				;; STAGE the high byte of SELECT_TYPE
	INC	cs:pre_font_len 	  ;;
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:ptr_sehib,AL 	   ;;
					;;
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
					;;
	CMP	cs:ptr_sel_word,0	   ;;
	JNE	PTR_SEL_NOT0		;;
					;;
					;;
	MOV	cs:stage,FOUNDX 	   ;; FSTAT is to be changed
	JMP	FTB_LOOP		;;
					;;
					;;
					;;+++++++++++++++++++++++++++++++++
PTRLENLO :				;; the low byte of SELECTION_LENGTH
	INC	cs:pre_font_len 	  ;;
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	PUSH	AX			;; check if length is enough
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	POP	AX			;;
	JNZ	A_WORD_SELEN		;;
	JMP	NO_PTR_FONT3		;;
A_WORD_SELEN :				;;
	AND	CX,CX			;;
	JNZ	WORD_SELEN		;;
	MOV	cs:ptr_lnlob,AL 	   ;;
	MOV	cs:stage,PTRLENHIX	   ;;
	JMP	FTB_LOOP		;;
WORD_SELEN :				;;
	INC	cs:pre_font_len 	   ;;
	INC	SI			;;
	DEC	CX			;;
	MOV	cs:ptr_len_word,AX	   ;;
					;;
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	MOV	cs:stage,FOUNDX 	   ;; FSTAT is to be changed
	JMP	FTB_LOOP		;;
					;;
					;;+++++++++++++++++++++++++++++++++
PTRLENHI :				;; STAGE the high byte of SELECT_LENGTH
	INC	cs:pre_font_len 	  ;;
	MOV	AX,FPKT 		;;
	INC	SI			;; byte by byte
	DEC	CX			;;
	MOV	cs:ptr_lnhib,AL 	   ;;
					;;
	MOV	AX,cs:fdlen_word	   ;;
	DEC	AX			;;
	MOV	cs:fdlen_word,AX	   ;;
	MOV	cs:stage,FOUNDX 	   ;; FSTAT is to be changed
	JMP	FTB_LOOP		;;
					;;
NO_PTR_FONT3 :				;;
	MOV	cs:stage,FOUNDX 	   ;; FSTAT is to be changed
	JMP	FTB_LOOP		;;
					;;+++++++++++++++++++++++++++++++++
PASS	:				;; STAGE - PASS DUMMY BYTES
					;;
	PUSH	DX			;;
	PUSH	ES			;;
	PUSH	DI			;;
					;;
	PUSH	CS			;;
	POP	ES			;;
	MOV	DI,OFFSET PASS_BRK	;;
	MOV	DX,PASS_INDX		;;
	MOV	AX,cs:pass_cnt		   ;;
					;;
NEXT_BRK:				;; find the next pass-break
	CMP	AX,ES:[DI]		;;
					;;
	JB	UPTO_BRK		;;
					;;
	DEC	DX			;;
	JZ	PASS_ERR		;;
	INC	DI			;;
	INC	DI			;;
	JMP	NEXT_BRK		;;
					;;
UPTO_BRK :				;; next break point found
	MOV	DX,ES:[DI]		;;
	SUB	DX,AX			;; bytes to be skipped
	CMP	CX,DX			;; all to be skipped ?
	JAE	PASS_ALL		;;
					;;
	ADD	cs:pass_cnt,CX		   ;;
	ADD	SI,CX			;;
	SUB	CX,CX			;;
	JMP	PASS_END		;;
					;;
PASS_ALL :				;;
	ADD	cs:pass_cnt,DX		   ;;
	ADD	SI,DX			;;
	SUB	CX,DX			;;
					;;
	MOV	AX,cs:pass_postx	   ;;
	MOV	cs:stage,AX		   ;;
					;;
;	cmp	ax,passx		;; is the next stage a pass-stage ?
;	jne	not_passx		;;
;	mov	ax,pass_postxx		;;
;	mov	pass_postx,ax		;;
;	mov	pass_postxx,stage_max	;; can support only 2 consecutive pass
					;;
;not_passx :				 ;;
					;;
	JMP	PASS_END		;;
					;;
PASS_ERR :				;; DEVICE ERROR, wrong stage
	POP	DI			;;
	POP	ES			;;
	POP	DX			;;
	MOV	FTP.FTB_STATUS,STAT_DEVERR
	SUB	CX,CX			;; ignore all the input string
	JMP	PASS_DONE		;;
					;;
PASS_END :				;;
	POP	DI			;;
	POP	ES			;;
	POP	DX			;;
PASS_DONE :				;;
	JMP	FTB_LOOP		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
FTB_LPEND :				;;
					;;
	CMP	cs:stage,FOUNDX 	   ;;
	JNE	NOT_FOUNDX		;;
					;;
	CALL	FOUND_DO		;;
					;;
NOT_FOUNDX :				;;
					;;
	POP	CX			;; STACK -1
					;;
FP_RET	:				;;
	POP	SI			;; restore registers
	POP	DI			;;
	POP	DX			;;
	POP	CX			;;
	POP	BX			;;
	POP	AX			;;
	POP	ES			;;
	POP	DS			;;
					;;
	RET				;;
FONT_PARSER ENDP			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CSEG	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\printer\4208\4208-cpy.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

CODE	segment public 'code'
ASSUME	CS:CODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
	org	0

	include copyrigh.inc

code	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\printer\4208\4208.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
	db	0FFH,046H,04FH,04EH,054H,020H,020H,020H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	001H,000H,001H,017H,000H,000H,000H,009H
	db	000H,01AH,000H,035H,000H,000H,000H,002H
	db	000H,034H,032H,030H,038H,020H,020H,020H
	db	020H,0B5H,001H,000H,000H,000H,000H,000H
	db	000H,015H,001H,000H,000H,01AH,000H,051H
	db	000H,000H,000H,002H,000H,034H,032H,030H
	db	038H,020H,020H,020H,020H,05EH,003H,000H
	db	000H,000H,000H,000H,000H,02BH,001H,000H
	db	000H,01AH,000H,06DH,000H,000H,000H,002H
	db	000H,034H,032H,030H,038H,020H,020H,020H
	db	020H,060H,003H,000H,000H,000H,000H,000H
	db	000H,041H,001H,000H,000H,01AH,000H,089H
	db	000H,000H,000H,002H,000H,034H,032H,030H
	db	038H,020H,020H,020H,020H,052H,003H,000H
	db	000H,000H,000H,000H,000H,057H,001H,000H
	db	000H,01AH,000H,0A5H,000H,000H,000H,002H
	db	000H,034H,032H,030H,038H,020H,020H,020H
	db	020H,053H,003H,000H,000H,000H,000H,000H
	db	000H,06DH,001H,000H,000H,01AH,000H,0C1H
	db	000H,000H,000H,002H,000H,034H,032H,030H
	db	038H,020H,020H,020H,020H,055H,003H,000H
	db	000H,000H,000H,000H,000H,083H,001H,000H
	db	000H,01AH,000H,0DDH,000H,000H,000H,002H
	db	000H,034H,032H,030H,038H,020H,020H,020H
	db	020H,057H,003H,000H,000H,000H,000H,000H
	db	000H,099H,001H,000H,000H,01AH,000H,000H
	db	000H,000H,000H,002H,000H,034H,032H,030H
	db	038H,020H,020H,020H,020H,05FH,003H,000H
	db	000H,000H,000H,000H,000H,0AFH,001H,000H
	db	000H,01AH,000H,000H,000H,000H,000H,002H
	db	000H,034H,032H,030H,038H,020H,020H,020H
	db	020H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,001H,000H,001H
	db	000H,010H,000H,002H,000H,00CH,000H,01BH
	db	049H,002H,000H,000H,000H,000H,000H,000H
	db	000H,01BH,036H,001H,000H,001H,000H,010H
	db	000H,002H,000H,00CH,000H,01BH,049H,00EH
	db	01BH,049H,007H,01BH,049H,006H,000H,01BH
	db	036H,001H,000H,001H,000H,010H,000H,002H
	db	000H,00CH,000H,01BH,049H,00EH,01BH,049H
	db	007H,01BH,049H,006H,000H,01BH,036H,001H
	db	000H,001H,000H,010H,000H,002H,000H,00CH
	db	000H,01BH,049H,00EH,01BH,049H,007H,01BH
	db	049H,006H,000H,01BH,036H,001H,000H,001H
	db	000H,010H,000H,002H,000H,00CH,000H,01BH
	db	049H,00EH,01BH,049H,007H,01BH,049H,006H
	db	000H,01BH,036H,001H,000H,001H,000H,010H
	db	000H,002H,000H,00CH,000H,01BH,049H,00EH
	db	01BH,049H,007H,01BH,049H,006H,000H,01BH
	db	036H,001H,000H,001H,000H,010H,000H,002H
	db	000H,00CH,000H,01BH,049H,00EH,01BH,049H
	db	007H,01BH,049H,006H,000H,01BH,036H,001H
	db	000H,001H,000H,010H,000H,002H,000H,00CH
	db	000H,01BH,049H,00EH,01BH,049H,007H,01BH
	db	049H,006H,000H,01BH,036H,001H,000H,001H
	db	000H,010H,000H,002H,000H,00CH,000H,01BH
	db	049H,00EH,01BH,049H,007H,01BH,049H,006H
	db	000H,01BH,036H,00AH,00DH,054H,068H,065H
	db	020H,049H,042H,04DH,020H,050H,065H,072H
	db	073H,06FH,06EH,061H,06CH,020H,043H,06FH
	db	06DH,070H,075H,074H,065H,072H,020H,050H
	db	072H,069H,06EH,074H,065H,072H,020H,043H
	db	06FH,064H,065H,020H,050H,061H,067H,065H
	db	020H,044H,072H,069H,076H,065H,072H,00AH
	db	00DH,056H,065H,072H,073H,069H,06FH,06EH
	db	020H,033H,02EH,033H,030H,020H,028H,043H
	db	029H,020H,043H,06FH,070H,079H,072H,069H
	db	067H,068H,074H,020H,049H,042H,04DH,020H
	db	043H,06FH,072H,070H,020H,031H,039H,038H
	db	037H,00AH,00DH,04CH,069H,063H,065H,06EH
	db	073H,065H,064H,020H,04DH,061H,074H,065H
	db	072H,069H,061H,06CH,020H,02DH,020H,050H
	db	072H,06FH,067H,072H,061H,06DH,020H,050H
	db	072H,06FH,070H,065H,072H,074H,079H,020H
	db	06FH,066H,020H,049H,042H,04DH,01AH,01AH
	db	040H,040H,040H,023H,023H,023H,020H,044H
	db	04FH,053H,020H,033H,02EH,033H,030H,020H
	db	044H,072H,069H,076H,065H,072H,020H,044H
	db	052H,056H,030H,035H,048H,02CH,020H,031H
	db	030H,02FH,032H,031H,02FH,038H,036H,00DH
	db	00AH,01AH,000H,020H,020H,020H,020H,020H
	db	020H,020H,020H,020H,020H,020H,020H,020H
	db	020H,020H,020H,020H,020H,020H,020H,020H
	db	020H,020H,020H,020H,020H,020H,020H,020H
	db	020H,020H,020H,020H,020H,020H,020H,020H
	db	020H,020H,020H,020H,020H,020H,020H,020H
	db	020H,020H,020H,020H,020H,020H,020H,020H
	db	020H,020H,020H,020H,020H,020H,020H,020H

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\printer\prtint2f.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
PAGE	,132
TITLE	PRINTER.SYS INT2FH Code

;****************** START OF SPECIFICATIONS **************************
;
;  MODULE NAME: PRTINT2F.ASM
;
;  DESCRIPTIVE NAME: PERFORM THE INT2FH FUNCTION OF PRINTER.SYS
;
;  FUNCTION: THE INT2FH FUNCTION OF PRINTER.SYS WILL LOCK THE PRINTER
;	     DEVICE AND LOAD THE CODE PAGE SPECIFIED.  WHEN AN UNLOCK
;	     IS ENCOUNTERED, THE SAVED CODE PAGE WILL BE ACTIVATED.
;	     ATTACHED.
;
;  ENTRY POINT: INT2F_COM
;
;  INPUT: AX = AD40H (CALL IDENTIFIER)
;	  BX = REQUESTED CODE PAGE (-1 FOR UNLOCK)
;	  DX = 0 - LPT1
;	       1 - LPT2
;	       2 - LPT3
;
;  AT EXIT:
;     NORMAL: CARRY CLEAR
;
;     ERROR: CARRY SET - CODE PAGE NOT AVAILABLE OR DEVICE IS NOT CPSW.
;
;  INTERNAL REFERENCES:
;
;     ROUTINES: CHECK_FOR_CP - CHECKS TO SEE IF CODE PAGE REQUESTED IS
;			       AVAILABLE ON DEVICE REQUESTED.
;		FIND_ACTIVE_CP - FINDS THE ACTIVE CODE PAGE ON SPECIFIED
;				 DEVICE; IF AVAILABLE.
;		LOCK_CP - VERIFIES, LOADS, AND LOCKS DEVICE CODE PAGE.
;		UNLOCK_CP - UNLOCKS DEVICE.
;
;     DATA AREAS: INVOKE_BLOCK - PARAMETER BLOCK PASSED TO INVOKE PROC.
;
;
;  EXTERNAL REFERENCES:
;
;     ROUTINES: INVOKE - ACTIVATES FONT REQUESTED.
;
;     DATA AREAS: BUF1 - BUFFER FOR LPT1
;		  BUF2 - BUFFER FOR LPT2
;		  BUF3 - BUFFER FOR LPT3
;
;  NOTES:
;
;  REVISION HISTORY:
;	 A000 - DOS Version 4.00
;
;      Label: "DOS PRINTER.SYS Device Driver"
;	      "Licensed Material - Program Property of Microsoft"
;
;****************** END OF SPECIFICATIONS ****************************

.XLIST
INCLUDE  STRUC.INC								    ;AN000;
.LIST


INCLUDE   CPSPEQU.INC								    ;AN000;
PRIV_LK_CP   EQU    0AD40H	       ; multiplex number and function		    ;AN000;
LPT1	     EQU    0		       ;					    ;AN000;
LPT2	     EQU    1		       ;					    ;AN000;
LPT3	     EQU    2		       ;					    ;AN000;
UNLOCK	     EQU    -1		       ; unlock the device			    ;AN000;
UNDEFINED    EQU    -1		       ; undefined code page			    ;AN000;
NOT_CY	     EQU    0FFFEH	       ; clear the carry in flag register	    ;AN000;
CY	     EQU    1		       ; set the carry in flag register 	    ;AN000;
FOUND	     EQU    1		       ; search flag				    ;AN000;
NOT_FOUND    EQU    0		       ;					    ;AN000;


PUBLIC	INT2F_COM								    ;AN000;
PUBLIC	ROM_INT2F								    ;AN000;
PUBLIC	ABORT									    ;AN000;


CSEG	SEGMENT PARA PUBLIC 'CODE'                                                  ;AN000;
	ASSUME CS:CSEG								    ;AN000;


EXTRN	INVOKE:NEAR								    ;AN000;
EXTRN	BUF0:BYTE								    ;AN000;
EXTRN	BUF1:BYTE								    ;AN000;
EXTRN	BUF2:BYTE								    ;AN000;
EXTRN	BUF3:BYTE								    ;AN000;

ROM_INT2F    DW     ?		       ; chaining point for INT2FH		    ;AN000;
	     DW     ?								    ;AN000;

COPY_BUF0    DW     0								    ;AN000;
PREV_LOCK    DB     OFF 							    ;AN000;

INVOKE_BLOCK LABEL  BYTE	       ; parameter block passed to INVOKE	    ;AN000;
	     DB     3 DUP(0)	       ;					    ;AN000;
RET_STAT     DW     0		       ; returned status from INVOKE		    ;AN000;
	     DQ     0		       ;					    ;AN000;
	     DB     6 DUP(0)	       ;					    ;AN000;
	     DW     OFFSET PARA_BLOCK  ;					    ;AN000;
CODE_SEGB    DW     SEG CSEG	       ;					    ;AN000;
				       ;
PARA_BLOCK   LABEL  WORD	       ;					    ;AN000;
	     DW     TWO 	       ;					    ;AN000;
REQ_CP	     DW     ?		       ; requested code page to load		    ;AN000;
				       ;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: INT2F_COM
;
; FUNCTION:
; THIS IS THE INTERRUPT 2FH HANDLER TO CAPTURE THE FOLLOWING FUNCTIONS:
;
;   AX=AD40H PRIVELEGED LOCK CP SWITCHING
;
; AT ENTRY: AX = AD40H
;	    BX = CODEPAGE REQUESTED DURING LOCK.
;		 -1 = UNLOCK
;	    DX = 0 - LPT1
;		 1 - LPT2
;		 2 - LPT3
;
;
; AT EXIT:
;    NORMAL: CARRY CLEAR - DEVICE LOADED AND LOCKED
;
;    ERROR: CARRY SET - CODE PAGE NOT AVAILABLE OR DEVICE NOT CPSW.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


INT2F_COM  PROC   NEAR								    ;AN000;
	   STI									    ;AN000;
	   .IF <AX NE PRIV_LK_CP>		; is this for PRINTER?		    ;AN000;
	     JMP    DWORD PTR CS:ROM_INT2F	; no....jump to old INT2F	    ;AN000;
	   .ENDIF				;				    ;AN000;
	   PUSH   AX				;				    ;AN000;
	   PUSH   BP				;				    ;AN000;
	   PUSH   BX				; s    r			    ;AN000;
	   PUSH   CX				;  a	e			    ;AN000;
	   PUSH   DX				;   v	 g			    ;AN000;
	   PUSH   DI				;    e	  s			    ;AN000;
	   PUSH   SI				;				    ;AN000;
	   PUSH   DS				;				    ;AN000;
	   PUSH   ES				;				    ;AN000;
	   MOV	  CS:COPY_BUF0,ZERO		;				    ;AN000;
	   MOV	  CS:CODE_SEGB,CS		;				    ;AN000;
	   MOV	  BP,BX 			; move req. cp to bp		    ;AN000;
	   .SELECT				; depending on the lptx..	    ;AN000;
	   .WHEN <DX EQ LPT1>			; point to the appropriate	    ;AN000;
	     LEA   BX,BUF1			; buffer..			    ;AN000;
	     LEA   SI,BUF0			;				    ;AN000;
	     MOV   CS:COPY_BUF0,SI		;				    ;AN000;
	   .WHEN <DX EQ LPT2>			;				    ;AN000;
	     LEA   BX,BUF2			;				    ;AN000;
	   .WHEN <DX EQ LPT3>			;				    ;AN000;
	     LEA   BX,BUF3			;				    ;AN000;
	   .OTHERWISE				;				    ;AN000;
	     STC				; not a valid lptx..set flag	    ;AN000;
	   .ENDSELECT				;				    ;AN000;
	   .IF NC				; process			    ;AN000;
	     .IF <BP EQ UNLOCK> 		; if unlock requested		    ;AN000;
	       CALL   UNLOCK_CP 		; unlock code page.		    ;AN000;
	     .ELSE				; must be a lock request..	    ;AN000;
	       CALL   LOCK_CP			;				    ;AN000;
	     .ENDIF				;				    ;AN000;
	   .ENDIF				;				    ;AN000;
	   MOV	  SI,CS:COPY_BUF0		;				    ;AN000;
	   PUSHF				;				    ;AN000;
	   .IF <SI NE ZERO>			; if this is lpt1...		    ;AN000;
	     MOV    AX,CS:[BX].STATE		; copy data into prn		    ;AN000;
	     MOV    CS:[SI].STATE,AX		; buffer as well.		    ;AN000;
	     MOV    AX,CS:[BX].SAVED_CP 	;				    ;AN000;
	     MOV    CS:[SI].SAVED_CP,AX 	;				    ;AN000;
	   .ENDIF				;				    ;AN000;
	   POPF 				;				    ;AN000;
	   POP	  ES				;				    ;AN000;
	   POP	  DS				; restore			    ;AN000;
	   POP	  SI				;				    ;AN000;
	   POP	  DI				;    registers			    ;AN000;
	   POP	  DX				;				    ;AN000;
	   POP	  CX				;				    ;AN000;
	   POP	  BX				;				    ;AN000;
	   MOV	  BP,SP 			;				    ;AN000;
	   MOV	  AX,[BP+8]			; load flag onto..		    ;AN000;
	   .IF NC				;				    ;AN000;
	     AND    AX,NOT_CY			;				    ;AN000;
	   .ELSE				;    stack flags		    ;AN000;
	     OR     AX,CY			;				    ;AN000;
	   .ENDIF				;				    ;AN000;
	   MOV	  [BP+8],AX			;				    ;AN000;
	   POP	  BP				;				    ;AN000;
	   POP	  AX				;				    ;AN000;
	   XCHG   AH,AL 			; exchange ah and al to show that.. ;AN000;
ABORT:	   IRET 				; printer.sys is present.	    ;AN000;
INT2F_COM  ENDP 								    ;AN000;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: UNLOCK_CP
;
; FUNCTION:
; THIS FUNCTION UNLOCKS THE DEVICE THAT IS LOCKED.
;
; AT ENTRY:
;	    BX - POINTS TO LPTx BUFFER
;
;
; AT EXIT:
;    NORMAL: CARRY CLEAR - DEVICE UNLOCKED.
;
;    ERROR: CARRY SET - ERROR DURING UNLOCK, ACTIVE CODE PAGE SET TO INACTIVE
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

UNLOCK_CP      PROC  NEAR							    ;AN000;
	       .IF <CS:[BX].STATE EQ LOCKED> NEAR ; is device locked?		    ;AN000;
		 MOV   CS:[BX].STATE,CPSW	  ; change status to unlocked..     ;AN000;
		 MOV   BP,CS:[BX].SAVED_CP	  ; get saved code page 	    ;AN000;
		 .IF <BP NE UNDEFINED>		  ; valid?..... 		    ;AN000;
		   XOR	  AX,AX 		  ;				    ;AN000;
		   CALL   FIND_ACTIVE_CP	  ; find the active code page.	    ;AN000;
		   .IF <BP NE DX>		  ; are they the same..?	    ;AN000;
		     MOV    CS:REQ_CP,BP	  ; no...invoke the saved code page ;AN000;
		     PUSH   CS			  ;				    ;AN000;
		     POP    ES			  ;				    ;AN000;
		     LEA    DI,INVOKE_BLOCK	  ;				    ;AN000;
		     MOV    CS:[BX].RH_PTRO,DI	  ;				    ;AN000;
		     MOV    CS:[BX].RH_PTRS,ES	  ;				    ;AN000;
		     CALL   INVOKE		  ;				    ;AN000;
		     .IF <AL NE ZERO>		  ; error on invoke?		    ;AN000;
		       MOV    AX,ONE		  ; yes...change the active..	    ;AN000;
		       CALL   FIND_ACTIVE_CP	  ; to inactive.		    ;AN000;
		       .IF <CS:COPY_BUF0 NE ZERO> ; do likewise to PRN if this	    ;AN000;
			 PUSH	 BX		  ; is lpt1.			    ;AN000;
			 MOV	 BX,CS:COPY_BUF0  ;				    ;AN000;
			 CALL	 FIND_ACTIVE_CP   ;				    ;AN000;
			 POP	 BX		  ;				    ;AN000;
		       .ENDIF			  ;				    ;AN000;
		       STC			  ; set error flag.		    ;AN000;
		     .ELSE			  ;				    ;AN000;
		       CLC			  ; invoke ok...clear error flag    ;AN000;
		     .ENDIF			  ;				    ;AN000;
		   .ELSE			  ;				    ;AN000;
		     CLC			  ; active = saved ..no invoke...   ;AN000;
		   .ENDIF			  ; clear error 		    ;AN000;
		 .ELSE				  ;				    ;AN000;
		   MOV	  AX,ONE		  ; saved cp was inactive...change..;AN000;
		   CALL   FIND_ACTIVE_CP	  ; active to inactive. 	    ;AN000;
		   .IF <CS:COPY_BUF0 NE ZERO>	  ; do likewise to PRN if this	    ;AN000;
		     PUSH    BX 		  ; is lpt1.			    ;AN000;
		     MOV     BX,CS:COPY_BUF0	  ;				    ;AN000;
		     CALL    FIND_ACTIVE_CP	  ;				    ;AN000;
		     POP     BX 		  ;				    ;AN000;
		   .ENDIF			  ;				    ;AN000;
		   CLC				  ;				    ;AN000;
		 .ENDIF 			  ;				    ;AN000;
		 MOV	CS:[BX].SAVED_CP,UNDEFINED; reset the saved cp		    ;AN000;
	       .ENDIF				  ;				    ;AN000;
	       RET								    ;AN000;
UNLOCK_CP      ENDP								    ;AN000;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: LOCK_CP
;
; FUNCTION:
; THIS FUNCTION LOCKS THE DEVICE WITH THE CODE PAGE REQUESTED.
;
; AT ENTRY: BP - REQUESTED CODE PAGE
;	    BX - POINTS TO LPTx BUFFER
;
;
; AT EXIT:
;    NORMAL: CARRY CLEAR - DEVICE LOCKED.
;
;    ERROR: CARRY SET - ERROR, CODE PAGE NOT LOCKED.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LOCK_CP        PROC   NEAR							    ;AN000;
	       .IF <CS:[BX].STATE EQ LOCKED>	; if this was previously locked..   ;AN000;
		 MOV	CS:PREV_LOCK,ON 	; then...set flag and...	    ;AN000;
		 MOV	CS:[BX].STATE,CPSW	; change to unlock for this proc    ;AN000;
	       .ELSEIF <CS:[BX].STATE EQ CPSW>	; if this is unlocked...	    ;AN000;
		 MOV	CS:PREV_LOCK,OFF	; then set flag off.		    ;AN000;
	       .ELSE				;				    ;AN000;
		 STC				; neither...set error		    ;AN000;
	       .ENDIF				;				    ;AN000;
	       .IF NC				;				    ;AN000;
		 CALL	CHECK_FOR_CP		; yes..see if req cp is available.  ;AN000;
		 .IF NC 			; yes...			    ;AN000;
		   XOR	   AX,AX		;				    ;AN000;
		   CALL    FIND_ACTIVE_CP	; find the active code page	    ;AN000;
		   .IF <BP NE DX>		; is it the same as requested?..    ;AN000;
		     MOV    CS:REQ_CP,BP	; no..invoke the requested cp	    ;AN000;
		     PUSH   CS			;				    ;AN000;
		     POP    ES			;				    ;AN000;
		     LEA    DI,INVOKE_BLOCK	;				    ;AN000;
		     MOV    CS:[BX].RH_PTRO,DI	;				    ;AN000;
		     MOV    CS:[BX].RH_PTRS,ES	;				    ;AN000;
		     PUSH   DX			;				    ;AN000;
		     CALL   INVOKE		;				    ;AN000;
		     POP    DX			;				    ;AN000;
		     .IF <AL NE ZERO>		; error on invoke?		    ;AN000;
		       STC			; yes...set error flag. 	    ;AN000;
		     .ELSE			;				    ;AN000;
		       MOV    CS:[BX].STATE,LOCKED ; no, 'lock' the printer device  ;AN000;
		       .IF <CS:PREV_LOCK EQ OFF> ; if we were not locked..	    ;AN000;
			 MOV	CS:[BX].SAVED_CP,DX ; and..save the old code page.  ;AN000;
		       .ENDIF			;				    ;AN000;
		       CLC			; clear error flag.		    ;AN000;
		     .ENDIF			;				    ;AN000;
		   .ELSE			;				    ;AN000;
		     MOV    CS:[BX].STATE,LOCKED ; 'lock' the printer device        ;AN000;
		     .IF <CS:PREV_LOCK EQ OFF>	; if we were not locked..	    ;AN000;
		       MOV    CS:[BX].SAVED_CP,DX ; and..save the old code page.    ;AN000;
		     .ENDIF			;				    ;AN000;
		     CLC			; clear the error flag		    ;AN000;
		   .ENDIF			;				    ;AN000;
		 .ENDIF 			;				    ;AN000;
	       .ENDIF				;				    ;AN000;
	       RET								    ;AN000;
LOCK_CP        ENDP								    ;AN000;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: CHECK_FOR_CP
;
; FUNCTION:
; THIS FUNCTION SEARCHES FOR THE CODE PAGE REQUESTED TO SEE IF IT HAS
; BEEN PREPARED OR IS A HARDWARE CODE PAGE
;
;
; AT ENTRY: BP = CODE PAGE REQUESTED
;	    BX - POINTS TO LPTx BUFFER
;
;
; AT EXIT:
;    NORMAL: CARRY CLEAR - CODE PAGE IS VALID.
;
;    ERROR: CARRY SET - CODE PAGE NOT AVAILABLE.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


CHECK_FOR_CP  PROC   NEAR							    ;AN000;
	      PUSH   DX 							    ;AN000;
	      MOV    DX,NOT_FOUND		; initialize flag		    ;AN000;
	      MOV    CX,CS:[BX].RSLMX		; load number of RAM slots	    ;AN000;
	      MOV    DI,CS:[BX].RAMSO		; load DI with table offset	    ;AN000;
	      .WHILE <DX EQ NOT_FOUND> AND	; whil not found and....	    ;AN000;
	      .WHILE <CX NE ZERO>		; while  still slots to check..     ;AN000;
		.IF <CS:[DI].SLT_CP EQ BP>	; is it this one??		    ;AN000;
		  MOV	 DX,FOUND		; yes....set flag		    ;AN000;
		.ELSE				;				    ;AN000;
		  ADD	 DI,TYPE SLTS		; no..point to next entry	    ;AN000;
		  DEC	 CX			; decrement the count		    ;AN000;
		.ENDIF				;				    ;AN000;
	      .ENDWHILE 			;				    ;AN000;
	      .IF <DX EQ NOT_FOUND>		; if we didn't find it then..       ;AN000;
		MOV    CX,CS:[BX].HSLMX 	; check hardware		    ;AN000;
		MOV    DI,CS:[BX].HARDSO	; load regs as before.		    ;AN000;
		.WHILE <DX EQ NOT_FOUND> AND	; while not found and.. 	    ;AN000;
		.WHILE <CX NE ZERO>		; still have slots to check..	    ;AN000;
		  .IF <CS:[DI].SLT_CP EQ BP>	; is it this one?		    ;AN000;
		    MOV    DX,FOUND		; yes...set flag.		    ;AN000;
		  .ELSE 			;				    ;AN000;
		    ADD    DI,TYPE SLTS 	; no ..point to next entry	    ;AN000;
		    DEC    CX			; and decrement count.		    ;AN000;
		  .ENDIF			;				    ;AN000;
		.ENDWHILE			;				    ;AN000;
	      .ENDIF				;				    ;AN000;
	      .IF <DX EQ NOT_FOUND>		;				    ;AN000;
		STC				; set flag appropriately	    ;AN000;
	      .ELSE				;				    ;AN000;
		CLC				;				    ;AN000;
	      .ENDIF				;				    ;AN000;
	      POP    DX 			;				    ;AN000;
	      RET				;				    ;AN000;
CHECK_FOR_CP  ENDP								    ;AN000;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: FIND_ACTIVE_CP
;
; FUNCTION:
; THIS FUNCTION SEARCHES FOR THE ACTIVE CODE PAGE. IF REQUESTED, THE
; CODE PAGE IS MADE INACTIVE.
;
;
; AT ENTRY:
;	    BX - POINTS TO LPTx BUFFER
;	    AX = 0 - LEAVE AS ACTIVE
;	    AX = 1 - DE-ACTIVATE
;
;
; AT EXIT:
;    NORMAL: DX - ACTIVE CODE PAGE.  (NO ACTIVE = -1)
;
;    ERROR: N/A
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


FIND_ACTIVE_CP PROC   NEAR							    ;AN000;
	       MOV    DX,UNDEFINED		 ; initialize register		    ;AN000;
	       MOV    CX,CS:[BX].RSLMX		 ; load number of RAM slots	    ;AN000;
	       MOV    DI,CS:[BX].RAMSO		 ; load DI with table offset	    ;AN000;
	       .WHILE <DX EQ UNDEFINED> AND	 ; whil not found and....	    ;AN000;
	       .WHILE <CX NE ZERO>		 ; while still slots to check..     ;AN000;
		 .IF <BIT CS:[DI].SLT_AT AND AT_ACT> ; is it this one?? 	    ;AN000;
		   MOV	  DX,CS:[DI].SLT_CP	 ; yes....load value		    ;AN000;
		   .IF <AX EQ ONE>		 ; is deactivate requested?	    ;AN000;
		     MOV    CS:[DI].SLT_AT,AT_OCC; yes...change attrib. to occupied ;AN000;
		   .ENDIF			 ;				    ;AN000;
		 .ELSE				 ;				    ;AN000;
		   ADD	  DI,TYPE SLTS		 ; no..point to next entry	    ;AN000;
		   DEC	  CX			 ; decrement the count		    ;AN000;
		 .ENDIF 			 ;				    ;AN000;
	       .ENDWHILE			 ;				    ;AN000;
	       .IF <DX EQ UNDEFINED>		 ; if we didn't find it then..      ;AN000;
		 MOV	CX,CS:[BX].HSLMX	 ; check hardware		    ;AN000;
		 MOV	DI,CS:[BX].HARDSO	 ; load regs as before. 	    ;AN000;
		 .WHILE <DX EQ UNDEFINED> AND	 ; while not found and..	    ;AN000;
		 .WHILE <CX NE ZERO>		 ; still have slots to check..	    ;AN000;
		   .IF <BIT CS:[DI].SLT_AT AND AT_ACT> ; is it this one??	    ;AN000;
		     MOV    DX,CS:[DI].SLT_CP	 ; yes....load value		    ;AN000;
		     .IF <AX EQ ONE>		 ; is deactivate requested?	    ;AN000;
		       MOV    CS:[DI].SLT_AT,AT_OCC; yes...change attrib to occupied;AN000;
		     .ENDIF			 ;				    ;AN000;
		   .ELSE			 ;				    ;AN000;
		     ADD    DI,TYPE SLTS	 ; no ..point to next entry	    ;AN000;
		     DEC    CX			 ; and decrement count. 	    ;AN000;
		   .ENDIF			 ;				    ;AN000;
		 .ENDWHILE			 ;				    ;AN000;
	       .ENDIF				 ;				    ;AN000;
	       RET				 ;				    ;AN000;
FIND_ACTIVE_CP ENDP								    ;AN000;

CSEG	   ENDS
	   END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\printer\4201\4201.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
	db	0FFH,046H,04FH,04EH,054H,020H,020H,020H 
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	001H,000H,001H,017H,000H,000H,000H,005H
	db	000H,01CH,000H,035H,000H,000H,000H,002H
	db	000H,034H,032H,030H,031H,020H,020H,020H
	db	020H,05FH,003H,000H,000H,000H,000H,000H
	db	000H,0A5H,000H,000H,000H,01CH,000H,051H
	db	000H,000H,000H,002H,000H,034H,032H,030H
	db	031H,020H,020H,020H,020H,0B5H,001H,000H
	db	000H,000H,000H,000H,000H,064H,006H,000H
	db	000H,01CH,000H,06DH,000H,000H,000H,002H
	db	000H,034H,032H,030H,031H,020H,020H,020H
	db	020H,05CH,003H,000H,000H,000H,000H,000H
	db	000H,087H,006H,000H,000H,01CH,000H,089H
	db	000H,000H,000H,002H,000H,034H,032H,030H
	db	031H,020H,020H,020H,020H,061H,003H,000H
	db	000H,000H,000H,000H,000H,045H,00BH,000H
	db	000H,01CH,000H,000H,000H,000H,000H,002H
	db	000H,034H,032H,030H,031H,020H,020H,020H
	db	020H,052H,003H,000H,000H,000H,000H,000H
	db	000H,04FH,00CH,000H,000H,001H,000H,001H
	db	000H,0B9H,005H,001H,000H,00CH,000H,005H
	db	01BH,049H,000H,01BH,036H,005H,01BH,049H
	db	004H,01BH,036H,01BH,03DH,001H,000H,015H
	db	01BH,03DH,000H,000H,01BH,049H,004H,000H
	db	01BH,03DH,029H,000H,014H,084H,000H,009H
	db	04EH,014H,084H,0A4H,0A4H,0A4H,084H,014H
	db	04EH,000H,000H,000H,009H,004H,00AH,02AH
	db	0AAH,06AH,02AH,02AH,01CH,002H,000H,000H
	db	000H,009H,0C0H,0A0H,0A0H,0FEH,080H,080H
	db	080H,080H,0FEH,000H,000H,000H,000H,01BH
	db	03DH,077H,000H,014H,08DH,000H,009H,00AH
	db	00AH,00AH,00AH,00AH,00AH,00AH,00AH,00AH
	db	000H,000H,000H,009H,00EH,014H,024H,0A4H
	db	064H,024H,024H,014H,00EH,000H,000H,000H
	db	017H,000H,050H,0AAH,0AAH,0AAH,0AAH,0AAH
	db	014H,000H,000H,000H,000H,009H,03EH,02AH
	db	02AH,02AH,06AH,0AAH,02AH,022H,022H,000H
	db	000H,000H,009H,03EH,02AH,02AH,0AAH,06AH
	db	02AH,02AH,022H,022H,000H,000H,000H,009H
	db	03EH,02AH,06AH,0AAH,0AAH,0AAH,06AH,022H
	db	022H,000H,000H,000H,008H,04CH,012H,092H
	db	092H,092H,012H,052H,00CH,000H,000H,000H
	db	000H,009H,03EH,0AAH,0AAH,02AH,02AH,02AH
	db	0AAH,0A2H,022H,000H,000H,000H,017H,000H
	db	000H,0A2H,0A2H,03EH,022H,0A2H,080H,000H
	db	000H,000H,000H,000H,01BH,03DH,01CH,000H
	db	014H,098H,000H,008H,05DH,022H,022H,022H
	db	022H,022H,022H,05DH,000H,000H,000H,000H
	db	009H,01CH,022H,062H,0A2H,0A2H,0A2H,062H
	db	022H,01CH,000H,000H,000H,000H,01BH,03DH
	db	01CH,000H,014H,09DH,000H,009H,03CH,002H
	db	002H,082H,042H,002H,002H,002H,03CH,000H
	db	000H,000H,009H,05CH,002H,082H,082H,082H
	db	082H,082H,002H,05CH,000H,000H,000H,000H
	db	01BH,03DH,01CH,000H,014H,0A0H,000H,025H
	db	000H,000H,000H,000H,0EEH,000H,000H,000H
	db	000H,000H,000H,000H,025H,000H,000H,000H
	db	000H,040H,080H,000H,000H,000H,000H,000H
	db	000H,000H,01BH,03DH,043H,000H,014H,0A4H
	db	000H,016H,000H,080H,080H,000H,000H,080H
	db	080H,000H,000H,000H,000H,080H,015H,000H
	db	000H,001H,001H,005H,002H,000H,000H,000H
	db	000H,000H,000H,025H,000H,000H,000H,0A8H
	db	0A8H,0A8H,050H,000H,000H,000H,000H,000H
	db	009H,080H,080H,080H,080H,080H,080H,080H
	db	080H,080H,000H,000H,000H,016H,000H,000H
	db	062H,0A2H,0BEH,0A2H,062H,000H,000H,000H
	db	000H,000H,000H,01BH,03DH,00FH,000H,014H
	db	0ADH,000H,00BH,0A8H,0A8H,0AAH,054H,008H
	db	010H,022H,046H,08AH,002H,01FH,000H,000H
	db	01BH,03DH,032H,000H,015H,084H,000H,000H
	db	000H,000H,001H,000H,001H,000H,021H,000H
	db	023H,002H,025H,004H,06DH,008H,025H,010H
	db	034H,0A0H,024H,000H,0A4H,000H,0A4H,000H
	db	0A4H,000H,024H,000H,014H,0A0H,005H,010H
	db	04DH,008H,005H,004H,003H,002H,001H,000H
	db	001H,000H,001H,000H,000H,000H,01BH,03DH
	db	032H,000H,015H,086H,000H,000H,000H,000H
	db	000H,000H,000H,000H,030H,020H,030H,020H
	db	078H,071H,078H,071H,078H,0F9H,078H,0F9H
	db	07FH,0FFH,000H,080H,000H,080H,000H,080H
	db	000H,080H,000H,080H,07FH,0FFH,000H,081H
	db	000H,081H,000H,081H,000H,081H,000H,000H
	db	000H,000H,000H,000H,01BH,03DH,092H,000H
	db	015H,08DH,001H,000H,000H,00AH,000H,00AH
	db	000H,00AH,000H,00AH,000H,00AH,000H,00AH
	db	000H,00AH,000H,00AH,000H,00AH,000H,00AH
	db	000H,00AH,000H,00AH,000H,00AH,000H,00AH
	db	000H,00AH,000H,00AH,000H,00AH,000H,00AH
	db	000H,00AH,000H,00AH,000H,00AH,000H,00AH
	db	000H,00AH,000H,000H,000H,000H,001H,000H
	db	001H,000H,021H,000H,023H,002H,025H,004H
	db	02DH,008H,025H,010H,0B4H,020H,024H,000H
	db	024H,080H,024H,000H,064H,000H,024H,000H
	db	014H,020H,005H,010H,00DH,008H,005H,004H
	db	003H,002H,001H,000H,001H,000H,001H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,010H,030H
	db	029H,003H,000H,009H,040H,041H,024H,001H
	db	000H,081H,000H,0A5H,000H,081H,012H,080H
	db	001H,082H,000H,090H,04AH,0C0H,004H,00CH
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,01BH,03DH,062H,000H,015H,091H
	db	000H,000H,000H,000H,000H,000H,021H,000H
	db	021H,000H,021H,000H,021H,000H,03FH,03EH
	db	021H,008H,021H,008H,0A1H,008H,021H,008H
	db	021H,088H,021H,008H,061H,008H,02DH,01CH
	db	021H,000H,021H,000H,021H,000H,021H,000H
	db	021H,000H,033H,026H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,021H,000H
	db	021H,000H,021H,000H,021H,000H,03FH,03EH
	db	061H,008H,021H,008H,021H,088H,021H,008H
	db	0A1H,008H,0A1H,008H,0A1H,008H,02DH,01CH
	db	021H,080H,021H,000H,061H,000H,021H,000H
	db	021H,000H,033H,026H,000H,000H,000H,000H
	db	01BH,03DH,062H,000H,015H,094H,000H,000H
	db	000H,000H,000H,000H,021H,000H,021H,000H
	db	021H,000H,021H,000H,0BFH,0BEH,0A1H,088H
	db	0A1H,088H,021H,008H,021H,008H,021H,008H
	db	021H,008H,021H,008H,02DH,01CH,0A1H,080H
	db	0A1H,080H,0A1H,080H,021H,000H,021H,000H
	db	033H,026H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,021H,000H,0A1H,080H,0A1H,080H
	db	0A1H,080H,021H,000H,021H,000H,03FH,03EH
	db	021H,000H,021H,000H,0A1H,080H,0A1H,080H
	db	0A1H,080H,021H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,01BH,03DH
	db	062H,000H,015H,098H,000H,000H,000H,000H
	db	000H,000H,042H,000H,000H,000H,018H,054H
	db	000H,028H,024H,000H,000H,000H,000H,044H
	db	000H,044H,000H,044H,000H,044H,000H,044H
	db	000H,044H,000H,044H,000H,000H,024H,000H
	db	000H,028H,018H,054H,000H,000H,042H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,01CH,01CH
	db	002H,020H,060H,002H,000H,000H,001H,0C0H
	db	001H,040H,081H,040H,081H,040H,081H,040H
	db	001H,040H,001H,0C0H,000H,000H,060H,002H
	db	002H,020H,01CH,01CH,000H,000H,000H,000H
	db	000H,000H,000H,000H,01BH,03DH,062H,000H
	db	015H,09DH,000H,000H,000H,000H,020H,000H
	db	020H,000H,020H,000H,03CH,03CH,022H,000H
	db	020H,002H,020H,000H,081H,000H,001H,000H
	db	001H,080H,001H,000H,041H,000H,001H,000H
	db	001H,000H,020H,000H,020H,002H,022H,000H
	db	03CH,03CH,020H,000H,020H,000H,020H,000H
	db	000H,000H,000H,000H,000H,000H,020H,000H
	db	020H,000H,020H,000H,03CH,03CH,022H,000H
	db	060H,002H,020H,000H,001H,080H,001H,000H
	db	081H,000H,081H,000H,081H,000H,001H,000H
	db	001H,080H,020H,000H,060H,002H,022H,000H
	db	03CH,03CH,020H,000H,020H,000H,020H,000H
	db	000H,000H,01BH,03DH,062H,000H,015H,0A0H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	0E7H,0E7H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,040H,000H
	db	000H,000H,000H,080H,000H,000H,080H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	01BH,03DH,0F2H,000H,015H,0A4H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,080H,080H,080H,080H
	db	080H,080H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,080H,080H,080H,080H
	db	080H,080H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,080H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,001H
	db	001H,000H,000H,002H,002H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,008H,080H
	db	000H,000H,080H,008H,0A0H,008H,0A0H,008H
	db	0A0H,008H,0A0H,008H,020H,000H,008H,0A0H
	db	050H,050H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,080H,000H
	db	080H,000H,080H,000H,080H,000H,080H,000H
	db	080H,000H,080H,000H,080H,000H,080H,000H
	db	080H,000H,080H,000H,080H,000H,080H,000H
	db	080H,000H,080H,000H,080H,000H,080H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,021H,000H,061H,000H,021H,000H
	db	021H,080H,021H,000H,0A1H,000H,0BFH,03EH
	db	0A1H,000H,021H,000H,021H,080H,021H,000H
	db	061H,000H,021H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,01BH,03DH
	db	032H,000H,015H,0ADH,000H,000H,010H,080H
	db	080H,010H,080H,010H,080H,050H,081H,050H
	db	080H,052H,002H,000H,070H,0A4H,004H,000H
	db	000H,008H,008H,000H,000H,010H,010H,000H
	db	002H,022H,024H,006H,008H,04AH,040H,002H
	db	000H,082H,000H,002H,007H,007H,000H,002H
	db	000H,002H,000H,000H,001H,000H,001H,000H
	db	01DH,000H,001H,000H,00CH,000H,005H,01BH
	db	049H,000H,01BH,036H,005H,01BH,049H,004H
	db	01BH,036H,01BH,03DH,001H,000H,015H,01BH
	db	03DH,000H,000H,01BH,049H,004H,000H,001H
	db	000H,001H,000H,0B8H,004H,001H,000H,00CH
	db	000H,005H,01BH,049H,000H,01BH,036H,005H
	db	01BH,049H,004H,01BH,036H,01BH,03DH,001H
	db	000H,015H,01BH,03DH,000H,000H,01BH,049H
	db	004H,000H,01BH,03DH,029H,000H,014H,084H
	db	000H,009H,044H,00AH,08AH,0AAH,0AAH,06AH
	db	04AH,05CH,082H,000H,000H,000H,009H,004H
	db	00AH,02AH,0AAH,06AH,02AH,02AH,01CH,002H
	db	000H,000H,000H,009H,00EH,014H,024H,024H
	db	064H,0A4H,024H,014H,00EH,000H,000H,000H
	db	000H,01BH,03DH,0DFH,000H,014H,089H,000H
	db	009H,07EH,02AH,0AAH,0AAH,0AAH,0AAH,0AAH
	db	022H,062H,000H,000H,000H,009H,01CH,02AH
	db	02AH,0AAH,06AH,02AH,02AH,02AH,018H,000H
	db	000H,000H,016H,000H,000H,022H,022H,07EH
	db	0A2H,022H,000H,000H,000H,000H,000H,00BH
	db	040H,000H,09CH,0A2H,0A2H,0A2H,0A2H,0A2H
	db	09CH,000H,040H,000H,016H,000H,000H,012H
	db	092H,05EH,002H,002H,000H,000H,000H,000H
	db	000H,009H,04EH,014H,084H,0A4H,0A4H,064H
	db	044H,054H,08EH,000H,000H,000H,009H,04EH
	db	014H,084H,0A4H,0A4H,0A4H,084H,014H,04EH
	db	000H,000H,000H,009H,03EH,02AH,02AH,02AH
	db	06AH,0AAH,02AH,022H,022H,000H,000H,000H
	db	009H,00EH,014H,024H,0A4H,064H,024H,024H
	db	014H,00EH,000H,000H,000H,009H,03EH,02AH
	db	02AH,0AAH,06AH,02AH,02AH,022H,022H,000H
	db	000H,000H,008H,04CH,012H,092H,092H,092H
	db	012H,052H,00CH,000H,000H,000H,000H,008H
	db	04CH,092H,092H,092H,052H,052H,052H,08CH
	db	000H,000H,000H,000H,008H,00CH,012H,012H
	db	092H,052H,012H,012H,00CH,000H,000H,000H
	db	000H,009H,03CH,002H,002H,002H,042H,082H
	db	002H,002H,03CH,000H,000H,000H,009H,01CH
	db	002H,002H,082H,042H,002H,002H,01CH,002H
	db	000H,000H,000H,016H,000H,000H,022H,0A2H
	db	07EH,022H,022H,000H,000H,000H,000H,000H
	db	008H,04CH,092H,092H,092H,052H,052H,052H
	db	08CH,000H,000H,000H,000H,000H,01BH,03DH
	db	00FH,000H,014H,09DH,000H,009H,03CH,002H
	db	002H,082H,042H,002H,002H,002H,03CH,000H
	db	000H,000H,000H,01BH,03DH,00FH,000H,014H
	db	09FH,000H,008H,01CH,022H,022H,022H,062H
	db	0A2H,022H,01CH,000H,000H,000H,000H,000H
	db	01BH,03DH,00FH,000H,014H,0A9H,000H,008H
	db	01CH,022H,022H,0A2H,062H,022H,022H,01CH
	db	000H,000H,000H,000H,000H,01BH,03DH,032H
	db	000H,015H,084H,000H,000H,000H,000H,000H
	db	000H,000H,000H,002H,004H,044H,002H,000H
	db	0A0H,001H,028H,081H,028H,081H,028H,081H
	db	028H,001H,028H,001H,0A8H,001H,028H,041H
	db	028H,041H,028H,040H,028H,000H,00AH,010H
	db	08AH,08EH,01EH,001H,000H,001H,000H,001H
	db	000H,000H,000H,01BH,03DH,032H,000H,015H
	db	086H,000H,000H,000H,000H,001H,000H,001H
	db	000H,021H,000H,023H,002H,025H,004H,02DH
	db	008H,025H,010H,034H,020H,024H,000H,064H
	db	000H,024H,000H,024H,080H,024H,000H,094H
	db	020H,005H,010H,00DH,008H,005H,004H,003H
	db	002H,001H,000H,001H,000H,001H,000H,000H
	db	000H,01BH,03DH,032H,000H,015H,089H,000H
	db	000H,000H,000H,000H,000H,021H,000H,021H
	db	000H,021H,000H,021H,000H,03FH,03EH,061H
	db	008H,021H,008H,021H,088H,021H,008H,0A1H
	db	008H,0A1H,008H,0A1H,008H,02DH,01CH,021H
	db	080H,021H,000H,061H,000H,021H,000H,021H
	db	000H,033H,026H,000H,000H,000H,000H,01BH
	db	03DH,062H,000H,015H,08BH,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,021H,000H,021H,000H,021H,000H,021H
	db	000H,021H,000H,061H,000H,03FH,03EH,021H
	db	080H,021H,000H,0A1H,000H,021H,000H,021H
	db	000H,021H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,00CH,008H,000H,014H,012H
	db	000H,000H,000H,040H,022H,000H,000H,021H
	db	080H,021H,000H,0A1H,000H,0A1H,000H,0A1H
	db	000H,021H,000H,021H,080H,000H,000H,040H
	db	022H,000H,000H,012H,000H,000H,014H,00CH
	db	008H,000H,000H,000H,000H,01BH,03DH,062H
	db	000H,015H,08EH,000H,000H,000H,000H,001H
	db	000H,001H,000H,021H,000H,023H,082H,025H
	db	004H,0ADH,008H,0A5H,010H,0B4H,020H,0A4H
	db	000H,0A4H,000H,024H,000H,024H,080H,024H
	db	080H,014H,0A0H,005H,090H,00DH,088H,005H
	db	004H,083H,002H,001H,000H,001H,000H,001H
	db	000H,000H,000H,000H,000H,000H,000H,001H
	db	000H,001H,000H,021H,000H,023H,002H,025H
	db	004H,06DH,008H,025H,010H,034H,0A0H,024H
	db	000H,0A4H,000H,0A4H,000H,0A4H,000H,024H
	db	000H,014H,0A0H,005H,010H,04DH,008H,005H
	db	004H,003H,002H,001H,000H,001H,000H,001H
	db	000H,000H,000H,01BH,03DH,062H,000H,015H
	db	091H,000H,000H,000H,000H,001H,000H,001H
	db	000H,021H,000H,023H,002H,025H,004H,02DH
	db	008H,025H,010H,0B4H,020H,024H,000H,024H
	db	080H,024H,000H,064H,000H,024H,000H,014H
	db	020H,005H,010H,00DH,008H,005H,004H,003H
	db	002H,001H,000H,001H,000H,001H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,021H
	db	000H,021H,000H,021H,000H,021H,000H,03FH
	db	03EH,021H,008H,021H,008H,0A1H,008H,021H
	db	008H,021H,088H,021H,008H,061H,008H,02DH
	db	01CH,021H,000H,021H,000H,021H,000H,021H
	db	000H,021H,000H,033H,026H,000H,000H,000H
	db	000H,01BH,03DH,032H,000H,015H,094H,000H
	db	000H,000H,000H,000H,000H,000H,000H,00CH
	db	00CH,042H,010H,000H,080H,010H,002H,080H
	db	000H,081H,020H,081H,020H,001H,020H,001H
	db	0A0H,001H,020H,041H,020H,041H,020H,040H
	db	000H,010H,002H,000H,080H,082H,010H,00CH
	db	00CH,000H,000H,000H,000H,000H,000H,01BH
	db	03DH,032H,000H,015H,096H,000H,000H,000H
	db	000H,020H,000H,020H,000H,020H,000H,03CH
	db	03CH,022H,000H,020H,002H,020H,000H,001H
	db	000H,001H,000H,041H,000H,001H,000H,001H
	db	080H,001H,000H,081H,000H,020H,000H,020H
	db	002H,022H,000H,03CH,03CH,020H,000H,020H
	db	000H,020H,000H,000H,000H,01BH,03DH,062H
	db	000H,015H,098H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,021H
	db	000H,021H,000H,021H,000H,0A1H,000H,021H
	db	000H,021H,080H,03FH,03EH,061H,000H,021H
	db	000H,021H,000H,021H,000H,021H,000H,021H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,00CH,008H,000H,014H,012H,080H,000H
	db	000H,080H,022H,080H,000H,0A1H,000H,0A1H
	db	000H,0A1H,000H,021H,000H,021H,080H,021H
	db	080H,021H,080H,000H,080H,000H,0A2H,000H
	db	000H,092H,000H,000H,014H,00CH,008H,000H
	db	000H,000H,000H,01BH,03DH,032H,000H,015H
	db	09DH,000H,000H,000H,000H,020H,000H,020H
	db	000H,020H,000H,03CH,03CH,022H,000H,020H
	db	002H,020H,000H,081H,000H,001H,000H,001H
	db	080H,001H,000H,041H,000H,001H,000H,001H
	db	000H,020H,000H,020H,002H,022H,000H,03CH
	db	03CH,020H,000H,020H,000H,020H,000H,000H
	db	000H,01BH,03DH,032H,000H,015H,09FH,000H
	db	000H,000H,000H,000H,000H,00CH,008H,000H
	db	014H,012H,000H,000H,000H,000H,022H,000H
	db	000H,021H,000H,021H,000H,061H,000H,021H
	db	000H,021H,080H,021H,000H,0A1H,000H,000H
	db	000H,000H,022H,000H,000H,012H,000H,000H
	db	014H,00CH,008H,000H,000H,000H,000H,01BH
	db	03DH,032H,000H,015H,0A9H,000H,000H,000H
	db	000H,000H,000H,00CH,008H,000H,014H,012H
	db	000H,000H,000H,000H,022H,000H,000H,0A1H
	db	000H,021H,000H,021H,080H,021H,000H,061H
	db	000H,021H,000H,021H,000H,000H,000H,000H
	db	022H,000H,000H,012H,000H,000H,014H,00CH
	db	008H,000H,000H,000H,000H,001H,000H,001H
	db	000H,004H,001H,001H,000H,00CH,000H,005H
	db	01BH,049H,000H,01BH,036H,005H,01BH,049H
	db	004H,01BH,036H,01BH,03DH,001H,000H,015H
	db	01BH,03DH,000H,000H,01BH,049H,004H,000H
	db	01BH,03DH,029H,000H,014H,09BH,000H,009H
	db	01CH,023H,022H,026H,02AH,032H,022H,05CH
	db	000H,000H,000H,000H,009H,012H,012H,07EH
	db	092H,092H,082H,082H,082H,042H,000H,000H
	db	000H,00AH,03AH,044H,000H,08AH,092H,0A2H
	db	000H,044H,0B8H,000H,000H,000H,000H,01BH
	db	03DH,032H,000H,015H,09BH,080H,000H,000H
	db	000H,000H,000H,018H,018H,004H,020H,000H
	db	000H,021H,004H,000H,002H,002H,040H,002H
	db	044H,006H,040H,002H,048H,00AH,040H,002H
	db	050H,012H,040H,002H,060H,022H,040H,060H
	db	000H,020H,084H,000H,000H,004H,020H,018H
	db	018H,000H,000H,000H,000H,01BH,03DH,032H
	db	000H,015H,09DH,000H,000H,000H,000H,000H
	db	000H,018H,018H,024H,024H,002H,040H,000H
	db	001H,041H,002H,001H,000H,003H,080H,005H
	db	084H,001H,088H,009H,090H,011H,080H,021H
	db	0A0H,001H,0C0H,000H,080H,040H,082H,080H
	db	000H,002H,040H,024H,024H,018H,018H,000H
	db	000H,000H,000H,01BH,03DH,00FH,000H,014H
	db	0AFH,000H,009H,05DH,022H,022H,022H,022H
	db	022H,022H,05DH,000H,000H,000H,01BH,03DH
	db	032H,000H,015H,0AFH,000H,000H,000H,000H
	db	000H,000H,042H,000H,000H,000H,018H,054H
	db	000H,028H,024H,000H,000H,000H,000H,044H
	db	000H,044H,000H,044H,000H,044H,000H,044H
	db	000H,044H,000H,044H,000H,000H,024H,000H
	db	000H,028H,018H,054H,000H,000H,042H,000H
	db	000H,000H,000H,000H,000H,000H,000H,001H
	db	000H,001H,000H,0AFH,00CH,001H,000H,00CH
	db	000H,005H,01BH,049H,000H,01BH,036H,005H
	db	01BH,049H,004H,01BH,036H,01BH,03DH,001H
	db	000H,015H,01BH,03DH,000H,000H,01BH,049H
	db	004H,000H,01BH,03DH,00FH,000H,014H,086H
	db	000H,00AH,004H,00AH,06AH,0AAH,0AAH,0AAH
	db	06AH,01CH,002H,000H,000H,000H,000H,01BH
	db	03DH,036H,000H,014H,09BH,000H,009H,01DH
	db	022H,026H,02AH,02AH,032H,022H,05CH,000H
	db	000H,000H,000H,009H,012H,012H,07EH,092H
	db	092H,082H,082H,082H,042H,000H,000H,000H
	db	00AH,03AH,044H,000H,08AH,092H,0A2H,000H
	db	044H,0B8H,000H,000H,000H,019H,000H,044H
	db	000H,028H,000H,010H,000H,028H,000H,044H
	db	000H,000H,000H,01BH,03DH,00FH,000H,014H
	db	0A9H,000H,00BH,03CH,042H,081H,081H,0BDH
	db	0A9H,0A9H,095H,081H,042H,03CH,000H,000H
	db	01BH,03DH,036H,000H,014H,0B5H,000H,009H
	db	00EH,014H,024H,024H,064H,0A4H,024H,014H
	db	00EH,000H,000H,000H,009H,04EH,014H,084H
	db	0A4H,0A4H,0A4H,084H,014H,04EH,000H,000H
	db	000H,009H,00EH,014H,024H,0A4H,064H,024H
	db	024H,014H,00EH,000H,000H,000H,00BH,038H
	db	044H,000H,092H,0AAH,0AAH,0AAH,082H,000H
	db	044H,038H,000H,000H,01BH,03DH,00FH,000H
	db	014H,0BDH,000H,008H,018H,024H,024H,024H
	db	07EH,024H,024H,024H,000H,000H,000H,000H
	db	000H,01BH,03DH,01CH,000H,014H,0C6H,000H
	db	009H,044H,00AH,08AH,0AAH,0AAH,06AH,04AH
	db	05CH,082H,000H,000H,000H,009H,04EH,014H
	db	084H,0A4H,0A4H,064H,044H,054H,08EH,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,01BH,03DH,0A2H,001H,014H,0DDH,000H
	db	025H,000H,000H,000H,000H,0EEH,000H,000H
	db	000H,000H,000H,000H,000H,016H,000H,000H
	db	022H,0A2H,07EH,022H,022H,000H,000H,000H
	db	000H,001H,00BH,0FCH,0FCH,0FCH,0FCH,0FCH
	db	0FCH,0FCH,0FCH,0FCH,0FCH,0FCH,000H,008H
	db	01CH,022H,022H,022H,062H,0A2H,022H,01CH
	db	000H,000H,000H,000H,008H,01FH,020H,040H
	db	084H,092H,082H,06AH,004H,000H,000H,000H
	db	000H,00BH,040H,000H,09CH,0A2H,0A2H,0A2H
	db	0A2H,0A2H,09CH,000H,040H,000H,008H,01CH
	db	022H,022H,0A2H,062H,022H,022H,01CH,000H
	db	000H,000H,000H,008H,04CH,092H,092H,092H
	db	052H,052H,052H,08CH,000H,000H,000H,000H
	db	009H,040H,01CH,080H,0A2H,0A2H,062H,040H
	db	05CH,080H,000H,000H,080H,008H,001H,07EH
	db	008H,008H,008H,008H,078H,004H,000H,000H
	db	000H,000H,009H,081H,081H,0FFH,025H,025H
	db	025H,024H,024H,018H,000H,000H,000H,018H
	db	000H,081H,0FFH,0A5H,024H,024H,024H,024H
	db	018H,000H,000H,000H,009H,03CH,002H,002H
	db	002H,042H,082H,002H,002H,03CH,000H,000H
	db	000H,009H,05CH,002H,082H,082H,082H,082H
	db	082H,002H,05CH,000H,000H,000H,009H,03CH
	db	002H,002H,082H,042H,002H,002H,002H,03CH
	db	000H,000H,080H,008H,020H,010H,009H,002H
	db	044H,088H,010H,020H,000H,000H,000H,000H
	db	009H,040H,020H,010H,008H,046H,088H,010H
	db	020H,040H,000H,000H,000H,009H,080H,080H
	db	080H,080H,080H,080H,080H,080H,080H,000H
	db	000H,000H,025H,000H,000H,000H,000H,040H
	db	080H,000H,000H,000H,000H,000H,020H,00BH
	db	010H,010H,010H,010H,010H,010H,010H,010H
	db	010H,000H,000H,000H,009H,022H,022H,022H
	db	022H,0FAH,022H,022H,022H,022H,000H,000H
	db	000H,009H,00AH,00AH,00AH,00AH,00AH,00AH
	db	00AH,00AH,00AH,000H,000H,000H,00BH,0A8H
	db	0A8H,0AAH,054H,008H,010H,022H,046H,08AH
	db	002H,01FH,000H,009H,0C0H,0A0H,0A0H,0FEH
	db	080H,080H,080H,080H,0FEH,000H,000H,000H
	db	017H,000H,050H,0AAH,0AAH,0AAH,0AAH,0AAH
	db	014H,000H,000H,000H,000H,019H,000H,010H
	db	010H,010H,0D6H,0D6H,0D6H,010H,010H,010H
	db	000H,080H,015H,000H,000H,001H,001H,005H
	db	002H,000H,000H,000H,000H,000H,000H,016H
	db	000H,000H,060H,090H,090H,090H,060H,000H
	db	000H,000H,000H,000H,018H,000H,030H,030H
	db	030H,000H,000H,030H,030H,030H,000H,000H
	db	000H,025H,000H,000H,000H,000H,010H,010H
	db	000H,000H,000H,000H,000H,000H,016H,000H
	db	000H,048H,008H,0F8H,008H,008H,000H,000H
	db	000H,000H,000H,025H,000H,000H,000H,0A8H
	db	0A8H,0A8H,050H,000H,000H,000H,000H,000H
	db	000H,01BH,03DH,084H,000H,014H,0CFH,000H
	db	008H,05DH,022H,022H,022H,022H,022H,022H
	db	05DH,000H,000H,000H,000H,017H,000H,004H
	db	02AH,08AH,04AH,02AH,09AH,004H,000H,000H
	db	000H,000H,009H,092H,0FEH,092H,092H,082H
	db	082H,082H,044H,038H,000H,000H,000H,009H
	db	07EH,02AH,0AAH,0AAH,0AAH,0AAH,0AAH,022H
	db	062H,000H,000H,000H,009H,03EH,0AAH,0AAH
	db	02AH,02AH,02AH,0AAH,0A2H,022H,000H,000H
	db	000H,009H,03EH,02AH,02AH,0AAH,06AH,02AH
	db	02AH,022H,022H,000H,000H,000H,016H,000H
	db	000H,012H,012H,01EH,002H,002H,000H,000H
	db	000H,000H,000H,016H,000H,000H,022H,022H
	db	07EH,0A2H,022H,000H,000H,000H,000H,000H
	db	00BH,040H,000H,080H,0A2H,0A2H,0BEH,0A2H
	db	0A2H,080H,000H,040H,000H,017H,000H,000H
	db	0A2H,0A2H,03EH,022H,0A2H,080H,000H,000H
	db	000H,000H,01BH,03DH,032H,000H,015H,09BH
	db	080H,000H,000H,000H,000H,000H,018H,018H
	db	004H,020H,000H,000H,021H,004H,000H,002H
	db	002H,040H,002H,044H,006H,040H,002H,048H
	db	00AH,040H,002H,050H,012H,040H,002H,060H
	db	022H,040H,060H,000H,020H,084H,000H,000H
	db	004H,020H,018H,018H,000H,000H,000H,000H
	db	01BH,03DH,032H,000H,015H,09DH,000H,000H
	db	000H,000H,000H,000H,018H,018H,024H,024H
	db	002H,040H,000H,001H,041H,002H,001H,000H
	db	003H,080H,005H,084H,001H,088H,009H,090H
	db	011H,080H,021H,0A0H,001H,0C0H,000H,080H
	db	040H,082H,080H,000H,002H,040H,024H,024H
	db	018H,018H,000H,000H,000H,000H,01BH,03DH
	db	032H,000H,015H,086H,000H,000H,000H,000H
	db	000H,000H,000H,000H,002H,004H,004H,002H
	db	000H,020H,041H,0A8H,001H,028H,081H,068H
	db	081H,068H,081H,068H,081H,068H,081H,068H
	db	081H,068H,081H,068H,000H,028H,040H,08AH
	db	010H,00AH,00EH,01EH,001H,000H,001H,000H
	db	001H,000H,000H,000H,01BH,03DH,032H,000H
	db	015H,09EH,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	024H,000H,000H,000H,000H,028H,018H,000H
	db	000H,000H,000H,010H,000H,000H,018H,000H
	db	000H,028H,000H,000H,024H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,01BH,03DH,032H,000H,015H,0A9H
	db	000H,000H,000H,000H,01CH,018H,000H,024H
	db	022H,000H,000H,000H,000H,042H,000H,000H
	db	05DH,03CH,049H,020H,049H,020H,049H,020H
	db	049H,020H,049H,020H,049H,020H,049H,028H
	db	04DH,020H,010H,014H,000H,042H,000H,000H
	db	022H,000H,000H,024H,01CH,018H,000H,000H
	db	01BH,03DH,0C2H,000H,015H,0B5H,000H,000H
	db	000H,000H,001H,000H,001H,000H,021H,000H
	db	023H,002H,025H,004H,02DH,008H,025H,010H
	db	034H,020H,024H,000H,064H,000H,024H,000H
	db	024H,080H,024H,000H,094H,020H,005H,010H
	db	00DH,008H,005H,004H,003H,002H,001H,000H
	db	001H,000H,001H,000H,000H,000H,000H,000H
	db	000H,000H,001H,000H,001H,000H,021H,000H
	db	023H,002H,025H,004H,06DH,008H,025H,010H
	db	034H,0A0H,024H,000H,0A4H,000H,0A4H,000H
	db	0A4H,000H,024H,000H,014H,0A0H,005H,010H
	db	04DH,008H,005H,004H,003H,002H,001H,000H
	db	001H,000H,001H,000H,000H,000H,000H,000H
	db	000H,000H,001H,000H,001H,000H,021H,000H
	db	023H,002H,025H,004H,02DH,008H,025H,010H
	db	0B4H,020H,024H,000H,024H,080H,024H,000H
	db	064H,000H,024H,000H,014H,020H,005H,010H
	db	00DH,008H,005H,004H,003H,002H,001H,000H
	db	001H,000H,001H,000H,000H,000H,000H,000H
	db	000H,000H,01CH,018H,000H,024H,022H,000H
	db	000H,000H,000H,042H,008H,018H,055H,000H
	db	041H,024H,041H,024H,041H,024H,041H,024H
	db	041H,024H,041H,024H,041H,024H,041H,000H
	db	014H,000H,000H,042H,000H,000H,022H,000H
	db	000H,024H,01CH,018H,000H,000H,01BH,03DH
	db	032H,000H,015H,0BDH,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,018H,018H
	db	004H,020H,020H,004H,000H,000H,002H,040H
	db	002H,040H,002H,040H,0FFH,0FFH,002H,040H
	db	002H,040H,002H,040H,022H,000H,022H,000H
	db	030H,060H,000H,004H,000H,000H,000H,000H
	db	000H,000H,000H,000H,01BH,03DH,062H,000H
	db	015H,0C6H,000H,000H,000H,000H,000H,000H
	db	000H,000H,002H,004H,044H,002H,000H,0A0H
	db	001H,028H,081H,028H,081H,028H,081H,028H
	db	001H,028H,001H,0A8H,001H,028H,041H,028H
	db	041H,028H,040H,028H,000H,00AH,010H,08AH
	db	08EH,01EH,001H,000H,001H,000H,001H,000H
	db	000H,000H,000H,000H,000H,000H,001H,000H
	db	001H,000H,021H,000H,023H,082H,025H,004H
	db	0ADH,008H,0A5H,010H,0B4H,020H,0A4H,000H
	db	0A4H,000H,024H,000H,024H,080H,024H,080H
	db	014H,0A0H,005H,090H,00DH,088H,005H,004H
	db	083H,002H,001H,000H,001H,000H,001H,000H
	db	000H,000H,01BH,03DH,0E2H,001H,015H,0CFH
	db	000H,000H,000H,000H,000H,000H,042H,000H
	db	000H,000H,018H,054H,000H,028H,024H,000H
	db	000H,000H,000H,044H,000H,044H,000H,044H
	db	000H,044H,000H,044H,000H,044H,000H,044H
	db	000H,000H,024H,000H,000H,028H,018H,054H
	db	000H,000H,042H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	004H,00CH,0AAH,000H,000H,000H,000H,0D2H
	db	000H,000H,051H,000H,011H,000H,011H,0C0H
	db	011H,000H,0B1H,000H,001H,000H,001H,020H
	db	010H,000H,000H,002H,000H,010H,00AH,000H
	db	004H,00CH,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,010H,001H,090H
	db	001H,090H,001H,090H,07FH,0FEH,001H,090H
	db	001H,090H,001H,090H,001H,090H,001H,090H
	db	001H,090H,001H,080H,001H,080H,001H,080H
	db	000H,000H,040H,002H,000H,000H,002H,040H
	db	024H,024H,018H,018H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,021H,000H
	db	021H,000H,021H,000H,021H,000H,03FH,03EH
	db	061H,008H,021H,008H,021H,088H,021H,008H
	db	0A1H,008H,0A1H,008H,0A1H,008H,02DH,01CH
	db	021H,080H,021H,000H,061H,000H,021H,000H
	db	021H,000H,033H,026H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,021H,000H
	db	021H,000H,021H,000H,021H,000H,0BFH,0BEH
	db	0A1H,088H,0A1H,088H,021H,008H,021H,008H
	db	021H,008H,021H,008H,021H,008H,02DH,01CH
	db	0A1H,080H,0A1H,080H,0A1H,080H,021H,000H
	db	021H,000H,033H,026H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,021H,000H
	db	021H,000H,021H,000H,021H,000H,03FH,03EH
	db	021H,008H,021H,008H,0A1H,008H,021H,008H
	db	021H,088H,021H,008H,061H,008H,02DH,01CH
	db	021H,000H,021H,000H,021H,000H,021H,000H
	db	021H,000H,033H,026H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,001H,000H,001H,000H,001H,020H
	db	001H,020H,001H,020H,001H,020H,001H,020H
	db	001H,020H,01FH,03EH,001H,000H,001H,000H
	db	001H,000H,001H,000H,001H,000H,001H,000H
	db	001H,000H,001H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,021H,000H,021H,000H
	db	021H,000H,021H,000H,021H,000H,061H,000H
	db	03FH,03EH,021H,080H,021H,000H,0A1H,000H
	db	021H,000H,021H,000H,021H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,021H,000H,061H,000H
	db	021H,000H,021H,080H,021H,000H,0A1H,000H
	db	0BFH,03EH,0A1H,000H,021H,000H,021H,080H
	db	021H,000H,061H,000H,021H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,021H,000H,0A1H,080H
	db	0A1H,080H,0A1H,080H,021H,000H,021H,000H
	db	03FH,03EH,021H,000H,021H,000H,0A1H,080H
	db	0A1H,080H,0A1H,080H,021H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	01BH,03DH,062H,000H,015H,0DDH,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,0E7H,0E7H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,021H,000H,021H,000H,021H,000H
	db	0A1H,000H,021H,000H,021H,080H,03FH,03EH
	db	061H,000H,021H,000H,021H,000H,021H,000H
	db	021H,000H,021H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,01BH,03DH
	db	032H,000H,015H,0E0H,000H,000H,000H,000H
	db	000H,000H,00CH,008H,000H,014H,012H,000H
	db	000H,000H,000H,022H,000H,000H,021H,000H
	db	021H,000H,061H,000H,021H,000H,021H,080H
	db	021H,000H,0A1H,000H,000H,000H,000H,022H
	db	000H,000H,012H,000H,000H,014H,00CH,008H
	db	000H,000H,000H,000H,01BH,03DH,0C2H,000H
	db	015H,0E2H,000H,000H,000H,000H,000H,000H
	db	00CH,008H,000H,014H,012H,000H,000H,000H
	db	040H,022H,000H,000H,021H,080H,021H,000H
	db	0A1H,000H,0A1H,000H,0A1H,000H,021H,000H
	db	021H,080H,000H,000H,040H,022H,000H,000H
	db	012H,000H,000H,014H,00CH,008H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	00CH,008H,000H,014H,012H,000H,000H,000H
	db	000H,022H,000H,000H,0A1H,000H,021H,000H
	db	021H,080H,021H,000H,061H,000H,021H,000H
	db	021H,000H,000H,000H,000H,022H,000H,000H
	db	012H,000H,000H,014H,00CH,008H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,00CH,00CH,042H,010H,000H,080H
	db	010H,002H,080H,000H,081H,020H,081H,020H
	db	001H,020H,001H,0A0H,001H,020H,041H,020H
	db	041H,020H,040H,000H,010H,002H,000H,080H
	db	082H,010H,00CH,00CH,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	00CH,008H,000H,014H,012H,080H,000H,000H
	db	080H,022H,080H,000H,0A1H,000H,0A1H,000H
	db	0A1H,000H,021H,000H,021H,080H,021H,080H
	db	021H,080H,000H,080H,000H,0A2H,000H,000H
	db	092H,000H,000H,014H,00CH,008H,000H,000H
	db	000H,000H,01BH,03DH,0E2H,001H,015H,0E7H
	db	080H,000H,080H,000H,080H,001H,080H,001H
	db	080H,001H,0FFH,0FFH,024H,001H,024H,001H
	db	000H,001H,000H,045H,000H,045H,000H,044H
	db	000H,044H,000H,044H,000H,044H,000H,044H
	db	000H,044H,000H,044H,000H,000H,024H,000H
	db	000H,028H,018H,010H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,001H,080H
	db	001H,080H,001H,080H,001H,080H,07FH,0FEH
	db	021H,084H,021H,084H,021H,084H,021H,084H
	db	021H,084H,021H,084H,020H,004H,020H,004H
	db	020H,004H,020H,004H,020H,004H,020H,004H
	db	000H,000H,004H,020H,018H,018H,000H,000H
	db	000H,000H,000H,000H,020H,000H,020H,000H
	db	020H,000H,03CH,03CH,022H,000H,020H,002H
	db	020H,000H,001H,000H,001H,000H,041H,000H
	db	001H,000H,001H,080H,001H,000H,081H,000H
	db	020H,000H,020H,002H,022H,000H,03CH,03CH
	db	020H,000H,020H,000H,020H,000H,000H,000H
	db	000H,000H,000H,000H,020H,000H,020H,000H
	db	020H,000H,03CH,03CH,022H,000H,060H,002H
	db	020H,000H,001H,080H,001H,000H,081H,000H
	db	081H,000H,081H,000H,001H,000H,001H,080H
	db	020H,000H,060H,002H,022H,000H,03CH,03CH
	db	020H,000H,020H,000H,020H,000H,000H,000H
	db	000H,000H,000H,000H,020H,000H,020H,000H
	db	020H,000H,03CH,03CH,022H,000H,020H,002H
	db	020H,000H,081H,000H,001H,000H,001H,080H
	db	001H,000H,041H,000H,001H,000H,001H,000H
	db	020H,000H,020H,002H,022H,000H,03CH,03CH
	db	020H,000H,020H,000H,020H,000H,000H,000H
	db	000H,000H,000H,000H,000H,020H,000H,020H
	db	000H,020H,010H,020H,000H,031H,008H,021H
	db	000H,029H,004H,001H,000H,005H,043H,001H
	db	002H,003H,002H,081H,000H,005H,084H,000H
	db	000H,028H,008H,020H,000H,030H,010H,020H
	db	000H,020H,000H,020H,000H,020H,000H,000H
	db	000H,000H,000H,000H,020H,000H,020H,000H
	db	020H,000H,020H,000H,020H,020H,030H,000H
	db	021H,010H,009H,000H,001H,008H,005H,000H
	db	047H,006H,005H,000H,001H,088H,009H,000H
	db	0A1H,010H,030H,000H,020H,020H,020H,000H
	db	020H,000H,020H,000H,020H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	080H,000H,080H,000H,080H,000H,080H,000H
	db	080H,000H,080H,000H,080H,000H,080H,000H
	db	080H,000H,080H,000H,080H,000H,080H,000H
	db	080H,000H,080H,000H,080H,000H,080H,000H
	db	080H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,040H,000H
	db	000H,000H,000H,080H,000H,000H,080H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,008H
	db	000H,008H,000H,008H,000H,008H,000H,008H
	db	000H,008H,000H,008H,000H,008H,000H,008H
	db	000H,008H,000H,008H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	01BH,03DH,0C2H,000H,015H,0F2H,080H,000H
	db	002H,001H,002H,001H,002H,001H,002H,001H
	db	002H,001H,002H,001H,002H,001H,002H,001H
	db	002H,001H,002H,001H,002H,001H,002H,001H
	db	002H,001H,002H,001H,002H,001H,002H,001H
	db	002H,001H,002H,001H,002H,001H,002H,001H
	db	002H,001H,002H,001H,002H,001H,000H,000H
	db	010H,080H,080H,010H,080H,010H,080H,050H
	db	081H,050H,080H,052H,002H,000H,070H,0A4H
	db	004H,000H,000H,008H,008H,000H,000H,010H
	db	010H,000H,002H,022H,024H,006H,008H,04AH
	db	040H,002H,000H,082H,000H,002H,007H,007H
	db	000H,002H,000H,002H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,030H,020H
	db	030H,020H,078H,071H,078H,071H,078H,0F9H
	db	078H,0F9H,07FH,0FFH,000H,080H,000H,080H
	db	000H,080H,000H,080H,000H,080H,07FH,0FFH
	db	000H,081H,000H,081H,000H,081H,000H,081H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,010H,030H,029H,003H,000H,009H
	db	040H,041H,024H,001H,000H,081H,000H,0A5H
	db	000H,081H,012H,080H,001H,082H,000H,090H
	db	04AH,0C0H,004H,00CH,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,01BH,03DH
	db	032H,000H,015H,0F7H,080H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,001H,001H,000H
	db	000H,002H,002H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,01BH,03DH,032H,000H
	db	015H,0F9H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	080H,080H,080H,080H,080H,080H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,080H,080H,080H,080H,080H,080H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,01BH,03DH,062H,000H,015H,0FBH
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,008H
	db	040H,008H,000H,008H,000H,088H,000H,088H
	db	0F8H,0F8H,000H,008H,000H,008H,000H,008H
	db	000H,008H,000H,008H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	008H,080H,000H,000H,080H,008H,0A0H,008H
	db	0A0H,008H,0A0H,008H,0A0H,008H,020H,000H
	db	008H,0A0H,050H,050H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	01BH,03DH,00FH,000H,014H,0BEH,000H,009H
	db	080H,054H,034H,014H,01EH,014H,034H,054H
	db	080H,000H,000H,01BH,03DH,032H,000H,015H
	db	0BEH,000H,000H,000H,000H,000H,080H,000H
	db	080H,000H,094H,040H,094H,000H,0D4H,020H
	db	094H,001H,0B4H,011H,014H,001H,014H,009H
	db	004H,00FH,00EH,009H,004H,001H,014H,011H
	db	014H,001H,0B4H,020H,094H,000H,0D4H,040H
	db	094H,000H,094H,000H,080H,000H,080H,000H
	db	000H,000H,000H,000H  

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\printer\parser.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
PAGE	    ,132
TITLE	    PARSE CODE AND CONTROL BLOCKS FOR PRINTER.SYS

;****************** START OF SPECIFICATIONS **************************
;
;  MODULE NAME: PARSER.ASM
;
;  DESCRIPTIVE NAME: PARSES THE DEVICE= STATEMENT IN CONFIG.SYS FOR
;		     PRINTER.SYS
;
;  FUNCTION: THE COMMAND LINE PASSED TO PRINTER.SYS IN THE CONFIG.SYS
;	     STATEMENT IS PARSED TO CHECK FOR CORRECT SYNTAX. A TABLE
;	     IS SETUP CONTAINING THE VALUES FOUND.
;
;  ENTRY POINT: PARSER
;
;  INPUT: ES:DI POINTS TO REQUEST HEADER
;
;  AT EXIT:
;     NORMAL: TABLE SET UP WITH VALUES FOUND.
;
;     ERROR: 0 RETURNED IN FIRST WORD OF TABLE.
;
;  INTERNAL REFERENCES:
;
;     ROUTINES: SYSPARSE - PARSING CODE
;
;     DATA AREAS: PARMSx - PARSE CONTROL BLOCK FOR SYSPARSE
;
;  EXTERNAL REFERENCES:
;
;     ROUTINES: N/A
;
;     DATA AREAS: TABLE - TO CONTAIN VALUES FOUND IN DEVICE= LINE
;
;  NOTES:
;
;  REVISION HISTORY:
;	AN000; - DOS Version 4.00
;	AN001 - GHG Changes had to made for P897.  The PARSER was
;		    changed to need the '=' in the keywords.
;
;      Label: "DOS DISPLAY.SYS Device Driver"
;	      "Licensed Material - Program Property of Microsoft"
;
;
;****************** END OF SPECIFICATIONS ****************************
;*Modification history ********************************************************
;AN001; p1482 - PRINTER.SYS refused to initialize		   10/6/87 J.K.
;AN002; p2686 No range checking on n parameter for printer.sys	   12/11/87 J.K.
;******************************************************************************


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; The following is the table structure of the parser.	All fields are
; two bytes field (accept for the device and id name)
;
; TABLE HEADER :
; 
;    Ŀ
;     N = Number of devices.	  
;    Ĵ
;    	 Device  # 1  offset	 >Ŀ
;    Ĵ		  			     
;    	 Device  # 2  offset	  		  	 Table_1  (a)	     
;    Ĵ		  			     
;    	 Device  # 3  offset	  		  
;    Ĵ
;    	 Device  # 4  offset	  
;    
;
;
; N = 1,2,3 or 4.  A two bytes number indicating the number of device specified.
; DEVICE # N OFFSET : a two bytes offset address to table_1. (ie. Device #1 offset
; is a pointer to table_1 (a). Device #2 offset is a pointer to table_1
; (b)...etc.).	 If an error was detected in the command N is set to zero.
;
;
;
; TABLE_1 :
; 
;
;    Ŀ	      Ŀ
;     N = Number of Offsets.	  	       			 
;    Ĵ    ĳ      Table_2  (a)	 
;    	 Device Name  offset	        			 
;    Ĵ	      
;    	 Device  Id   offset	 Ŀ
;    Ĵ	     Ŀ
;    	 Device  HWCP offset	 Ŀ      			 
;    Ĵ     ĳ      Table_3  (a)	 
;    	 Device  Desg offset	 Ŀ        			 
;    Ĵ         
;    	    "Reserved"               
;             Ŀ
;				             			 
;				      ĳ      Table_4  (a)	 
;				     	       			 
;				     	      
;				     	      Ŀ
;				     	       			 
;				     ĳ      Table_5  (a)	 
;					       			 
;					      
;
;
;  N=Length of table_1, or the number of offsets contained in table_1.
;  The offsets are pointers (two bytes) to the parameters value of the device.
;  "Reserved" : a two byte memory reserved for future use of the "PARMS" option.
;
;
; TABLE_2 :
; 
;
;    Ŀ
;     N = Length of devices name 
;    Ĵ
;    	  Device   name 	  
;    
;
; N = Length of device name.  Device length is always 8 byte long.
; Device Name : the name of the device (eg. LPT1, CON, PRN).  The name
; is paded with spaces to make up the rest of the 8 characters.
;
;
;
; TABLE_3 :
; 
;
;    Ŀ
;     N = Length of Id name.	  
;    Ĵ
;    	   Id	Name		  
;    
;
; N = Length of id name.  Id name length is always 8 byte long.
; Id Name : the name of the id (eg. EGA, VGA).	The name
; is paded with spaces to make up the rest of the 8 character.
;
;
;
; TABLE_4 :
; 
;
;    Ŀ
;     N = Length of table.	  
;    Ĵ
;    	  HWCP	#  1		  
;    Ĵ
;    	  HWCP	#  2		  
;    Ĵ
;    		.		  
;    		.		  
;    		.		  
;    Ĵ
;    	  HWCP	#  10		  
;    
;
;
; N = Length of table in words. Or the number of HWCP's.
; HWCP # N : a hardware code page number converted to binary.  The maximum
; number of pages allowed is 10.
;
;
;
; TABLE_5 :
; 
;
;    Ŀ
;     N = Length of table.	  
;    Ĵ
;    	  Designate		  
;    Ĵ
;    	  Font			  
;    
;
; N = Lenght of table.	0 - nothing was specified
;			1 - Only a designate was specified.
;			2 - Designate and font were given.  If the Desg field
;			    was left empty in the DEVICE command then the
;			    Designate field is filled with 0FFFFH.
; Designate, Font : Are the Desg. and Font binary numbers.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


.XLIST
INCLUDE     STRUC.INC	     ; Structured macros				    ;AN000;
.LIST

INCLUDE     CPSPEQU.INC 							    ;AN000;

PUBLIC	    PARSER	     ; near procedure for parsing DEVICE= statement	    ;AN000;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Set assemble switches for parse code
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DateSW	      EQU     0 							    ;AN000;
DrvSW	      EQU     0 							    ;AN000;
SwSW	      EQU     0 							    ;AN000;
Val1SW	      EQU     1     ;;AN002;						   ;AN000;
Val2SW	      EQU     0 							    ;AN000;
Val3SW	      EQU     0 							    ;AN000;


CSEG	      SEGMENT  PARA PUBLIC 'CODE'                                           ;AN000;
	      ASSUME CS:CSEG,DS:NOTHING,ES:NOTHING				    ;AN000;


EXTRN	    TABLE:WORD	     ; table for variable storage used by INIT module.	    ;AN000;
EXTRN	    DEVICE_NUM:WORD							    ;AN000;

.XLIST
INCLUDE     VERSION.INC
INCLUDE     PARSE.ASM	    ; Parsing code					    ;AN000;
.LIST


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PARM control block for parsing PRINTER.SYS - DEVICE= command statement.
; Command line looks like:
;
;   DEVICE=[d:][path]PRINTER.SYS LPT#[:]=(type[,[hwcp][,n]])
;     or
;   DEVICE=[d:][path]PRINTER.SYS LPT#[:]=(type[,[(hwcp1,hwcp2,...)][,n]])
;
; The command line will be parsed from left to right, taking care of the
; nesting of complex lists as they occur.
;
; The first level of control blocks is shown below.
; Complex list control blocks follow.
; Null VALUE LIST and RESULT BUFFER are placed after all other PARSE control
; blocks.
;
; d:\path\PRINTER.SYS lpt#=(complex list)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PARMS1	       LABEL WORD							    ;AN000;
	       DW	PARMSX1 						    ;AN000;
	       DB	0		   ; no extra delimeters or EOLs.	    ;AN000;

PARMSX1        LABEL BYTE							    ;AN000;
	       DB	1,1		   ; min,max positional operands	    ;AN000;
	       DW	D_NAME		   ; pointer to control block		    ;AN000;
	       DB	0		   ; no switches			    ;AN000;
	       DB	1		   ; 1 or more keywords 		    ;AN000;
	       DW	PRT_LIST	   ; pointer to control block		    ;AN000;

D_NAME	       LABEL WORD							    ;AN000;
	       DW	0200H		   ; file spec				    ;AN000;
	       DW	0001H		   ; cap result by file table		    ;AN000;
	       DW	RESULT_BUF	   ; result				    ;AN000;
	       DW	NOVALS		   ; no value checking done		    ;AN000;
	       DB	0		   ; no keyword/switch synonyms 	    ;AN000;

PRT_LIST       LABEL WORD							    ;AN000;
	       DW	0402H		   ; complex list,  repeats allowed	    ;AN000;
	       DW	0002H		   ; cap result by char table		    ;AN000;
	       DW	RESULT_BUF	   ; result				    ;AN000;
	       DW	NOVALS		   ; no value checking done		    ;AN000;
	       DB	8		   ; 4 keywords 			    ;AN000;
	       DB	"PRN=",0           ;GHG Ŀ                                  ;AN001;
	       DB	"LPT1=",0          ;GHG   4 possible keywords              ;AN001;
	       DB	"LPT2=",0          ;GHG                                    ;AN001;
	       DB	"LPT3=",0          ;GHG                                   ;AN001;
	       DB	"PRN:=",0          ;GHG Ŀ                                  ;AN001;
	       DB	"LPT1:=",0         ;GHG   4 possible keywords              ;AN001;
	       DB	"LPT2:=",0         ;GHG     with colon                     ;AN001;
	       DB	"LPT3:=",0         ;GHG                                   ;AN001;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PARM control block for second level of nesting.
; ie. complex list from first level of nesting
;
; (type, hwcp or complex list, n)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PARMS2	       LABEL WORD							    ;AN000;
	       DW	PARMSX2 						    ;AN000;
	       DB	0		   ; no extra delimeters or EOLs.	    ;AN000;

PARMSX2        LABEL BYTE							    ;AN000;
	       DB	1,3		   ; min,max positional operands	    ;AN000;
	       DW	PRT_TYPE	   ; pointer to control block		    ;AN000;
	       DW	HWCP		   ; pointer to control block		    ;AN000;
	       DW	CP_PREPS	   ; pointer to control block		    ;AN000;
	       DB	0		   ; no switches			    ;AN000;
	       DB	0		   ; no keywords			    ;AN000;

PRT_TYPE       LABEL BYTE							    ;AN000;
	       DW	2000H		   ; sstring				    ;AN000;
	       DW	0002H		   ; cap by char table			    ;AN000;
	       DW	RESULT_BUF	   ; result				    ;AN000;
	       DW	NOVALS		   ; value list 			    ;AN000;
	       DB	0		   ; no keyword/switch synonyms 	    ;AN000;

HWCP	       LABEL BYTE							    ;AN000;
	       DW	8401H		   ; numeric or complex list (optional)     ;AN000;
	       DW	0		   ; no functions			    ;AN000;
	       DW	RESULT_BUF	   ; result				    ;AN000;
	       DW	NOVALS		   ; no value checking done		    ;AN000;
	       DB	0		   ; no keyword/switch synonyms 	    ;AN000;

CP_PREPS       LABEL BYTE							    ;AN000;
	       DW	8001H		   ; numeric (optional) 		    ;AN000;
	       DW	0		   ; no functions			    ;AN000;
	       DW	RESULT_BUF	   ; result				    ;AN000;
	       DW	N_Val_Range	   ;AN002; value list				  ;AN000;
	       DB	0		   ; no keyword/switch synonyms 	    ;AN000;


N_Val_Range    label   byte
	       db      1		   ;AN002; Range defintion
	       db      1		   ;AN002; Number of ranges
	       db      1		   ;AN002; item tag
               dd      0, 6                ;AN002; 0 - 12

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PARM control block for third level of nesting.
; ie. complex list from second nesting level
;
; (hwcp1,hwcp2,...)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PARMS3	       LABEL WORD							    ;AN000;
	       DW	PARMSX3 						    ;AN000;
	       DB	0		   ; no extra delimeters or EOLs.	    ;AN000;

PARMSX3        LABEL BYTE							    ;AN000;
	       DB	1,1		   ; min,max positional operands	    ;AN000;
	       DW	HWCPS		   ; pointer to control block		    ;AN000;
	       DB	0		   ; no switches			    ;AN000;
	       DB	0		   ; no keywords			    ;AN000;

HWCPS	       LABEL BYTE							    ;AN000;
	       DW	8003H		   ; numeric, repeats allowed		    ;AN000;
	       DW	0		   ; no functions			    ;AN000;
	       DW	RESULT_BUF	   ; result				    ;AN000;
	       DW	NOVALS		   ; no value checking done		    ;AN000;
	       DB	0		   ; no keyword/switch synonyms 	    ;AN000;


; Null VALUE LIST and RESULT BUFFER for all PARSE control blocks


NOVALS	       LABEL BYTE							    ;AN000;
	       DB	0		   ; no value checking done		    ;AN000;

RESULT_BUF     LABEL BYTE							    ;AN000;
RESULT_TYPE    DB	?		   ; type returned (number, string, etc.)   ;AN000;
	       DB	?		   ; matched item tag (if applicable)	    ;AN000;
SYN_PTR        DW	?		   ; synonym ptr (if applicable)	    ;AN000;
RESULT_VAL     DD	?		   ; value				    ;AN000;


OK_FLAG        DB	ON		   ; FLAG INDICATING PARSE STATUS	    ;AN000;
NUM_LOOP       DB	ZERO							    ;AN000;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: PARSER
;
; FUNCTION:
; THIS PROCEDURE PARSES THE DEVICE= PARAMETERS FROM THE INIT REQUEST
; BLOCK.
;
; AT ENTRY: ES:DI POINTS TO REQUEST HEADER
;
; AT EXIT:
;    NORMAL: TABLE SET UP WITH VALUES FOUND
;
;    ERROR: 0 LOADED IN FIRST WORD OF TABLE
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PARSER	PROC	 NEAR								    ;AN000;
	PUSH	 DX								    ;AN000;
	PUSH	 DI								    ;AN000;
	PUSH	 ES								    ;AN000;
	PUSH	 BX								    ;AN000;
	PUSH	 DS			  ;					    ;AN000;
	PUSH	 SI			  ;					    ;AN000;
	CLD				  ;					    ;AN000;
	LDS	 SI,RH.RH0_BPBA 	  ;					    ;AN000;
	PUSH	 CS			  ; establish ES ..			    ;AN000;
	POP	 ES			  ; addressability to data		    ;AN000;
	LEA	 DI,PARMS1		  ; point to PARMS control block	    ;AN000;
	XOR	 CX,CX			  ; clear both CX and DX for		    ;AN000;
	XOR	 DX,DX			  ;  SYSPARSE				    ;AN000;
	CALL	 SYSPARSE		  ; move pointer past file spec 	    ;AN000;
	CALL	 SYSPARSE		  ; do first parse			    ;AN000;
	LEA	 BX,TABLE		  ;					    ;AN000;
	.WHILE <AX NE RC_EOL> AND	  ; EOL?...then end parse...and..	    ;AN000;
	.WHILE <OK_FLAG EQ ON>		  ; make sure that flag still ok..	    ;AN000;
	  .IF <AX NE RC_NO_ERROR>	  ; parse error?			    ;AN000;
	    MOV     OK_FLAG,OFF 	  ; yes...reset flag			    ;AN000;
	  .ELSE 			  ;					    ;AN000;
	    .SELECT			  ;					    ;AN000;
	    .WHEN <RESULT_TYPE EQ COMPLEX>; complex string found?		    ;AN000;
	      INC    DEVICE_NUM 	  ; increment count			    ;AN000;
	      INC    BX 		  ; point to next device table		    ;AN000;
	      INC    BX 		  ;					    ;AN000;
	      .IF <DEVICE_NUM GT FOUR>	  ; more than one?			    ;AN000;
		MOV    OK_FLAG,OFF	  ; yes....we have an error		    ;AN000;
	      .ELSE			  ; no ..				    ;AN000;
		PUSH   BX		  ;					    ;AN000;
		MOV    BX,CS:[BX]	  ;					    ;AN000;
		CALL   COPY_NAME	  ;					    ;AN000;
		MOV    NUM_LOOP,ZERO	  ;					    ;AN000;
		CALL   PARSE_MAIN	  ; process complex string..		    ;AN000;
		POP    BX		  ;					    ;AN000;
	      .ENDIF			  ;					    ;AN000;
	    .OTHERWISE			  ; not a complex string so..		    ;AN000;
	      MOV    OK_FLAG,OFF	  ; we have a problem...reset flag	    ;AN000;
	    .ENDSELECT			  ;					    ;AN000;
	  .ENDIF			  ;					    ;AN000;
	  PUSH	 BX			  ;					    ;AN000;
	  CALL	 SYSPARSE		  ; continue parsing..			    ;AN000;
	  POP	 BX			  ;					    ;AN000;
	.ENDWHILE			  ;					    ;AN000;
	.IF <OK_FLAG EQ OFF>		  ; flag indicating error?		    ;AN000;
	  MOV	DEVICE_NUM,ZERO 	  ; yes...set device number to 0	    ;AN000;
	  STC				  ;					    ;AN000;
	.ELSE				  ;					    ;AN000;
	  CLC				  ;					    ;AN000;
	.ENDIF				  ;					    ;AN000;
	POP    SI			  ;					    ;AN000;
	POP    DS			  ;					    ;AN000;
	POP    BX			  ;					    ;AN000;
	POP    ES			  ;					    ;AN000;
	POP    DI			  ;					    ;AN000;
	POP    DX			  ;					    ;AN000;
	RET				  ;					    ;AN000;
PARSER	ENDP									    ;AN000;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: PARSE_MAIN
;
; FUNCTION:
; THIS PROCEDURE PARSES THE LPT=(    ) COMPLEX LIST DEVICE= LINE FOUND
; IN CONFIG.SYS
;
; AT ENTRY: RESULT BUFFER CONTAINS POINTER TO COMPLEX STRING
;
; AT EXIT:
;    NORMAL: TABLE SET UP WITH VALUES FOUND
;
;    ERROR: OK_FLAG = 0
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PARSE_MAIN  PROC   NEAR 							    ;AN000;
	    PUSH   BX			  ;					    ;AN000;
	    PUSH   DI			  ; setup to parse the nested.. 	    ;AN000;
	    PUSH   DS			  ; complex string...but save.. 	    ;AN000;
	    PUSH   SI			  ; current parsing status.		    ;AN000;
	    PUSH   CX			  ;					    ;AN000;
	    XOR    CX,CX		  ;					    ;AN000;
	    LEA    DI,PARMS2		  ; next control block..		    ;AN000;
	    LDS    SI,RESULT_VAL	  ; point to stored string		    ;AN000;
	    PUSH   BX			  ;					    ;AN000;
	    CALL   SYSPARSE		  ;					    ;AN000;
	    POP    BX			  ;					    ;AN000;
	    .WHILE <AX NE RC_EOL> AND	  ; not EOL?   and..			    ;AN000;
	    .WHILE <OK_FLAG EQ ON>	  ; error flag still ok?		    ;AN000;
	      INC    NUM_LOOP		  ;					    ;AN000;
	      .IF <AX NE RC_NO_ERROR>	  ; check for parse errors		    ;AN000;
		MOV    OK_FLAG,OFF	  ; yes....reset error flag		    ;AN000;
	      .ELSE			  ; no...process			    ;AN000;
		PUSH   BX		  ;					    ;AN000;
		.SELECT 		  ;					    ;AN000;
		.WHEN <RESULT_TYPE EQ STRING> ; simple string			    ;AN000;
		  MOV	 BX,CS:[BX].DI_OFFSET ; 				    ;AN000;
		  CALL	 PARSE_STR	  ; yes...process			    ;AN000;
		.WHEN <RESULT_TYPE EQ NUMBER> ; number?..			    ;AN000;
		  .IF <NUM_LOOP EQ TWO>   ;					    ;AN000;
		    MOV    BX,CS:[BX].DCP_OFFSET				    ;AN000;
		  .ELSE 		  ;					    ;AN000;
		    MOV    BX,CS:[BX].DD_OFFSET 				    ;AN000;
		  .ENDIF		  ;					    ;AN000;
		   MOV	  AX,WORD PTR RESULT_VAL ; get value into word form	    ;AN000;
		   .IF <AX NE ZERO>						    ;AN000;
		     INC    WORD PTR CS:[BX] ;					    ;AN000;
		     MOV    WORD PTR CS:[BX+2],AX ; load that value.		    ;AN000;
		   .ENDIF							    ;AN000;
		.WHEN <RESULT_TYPE EQ COMPLEX> ; complex string?		    ;AN000;
		  MOV	 BX,CS:[BX].DCP_OFFSET ;				    ;AN000;
		  CALL	 PARSE_COMP	  ; yes...process			    ;AN000;
		.OTHERWISE		  ; anything else is..			    ;AN000;
		  MOV	 OK_FLAG,OFF	  ; an error...reset flag.		    ;AN000;
		.ENDSELECT		  ;					    ;AN000;
		CALL   SYSPARSE 	  ; continue parsing			    ;AN000;
		POP    BX		  ;					    ;AN000;
	      .ENDIF			  ;					    ;AN000;
	    .ENDWHILE			  ;					    ;AN000;
	    POP    CX			  ; restore original parse..		    ;AN000;
	    POP    SI			  ; registers.				    ;AN000;
	    POP    DS			  ;					    ;AN000;
	    POP    DI			  ;					    ;AN000;
	    POP    BX			  ;					    ;AN000;
	    RET 			  ;					    ;AN000;
PARSE_MAIN  ENDP								    ;AN000;
										    ;AN000;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: PARSE_COMP
;
; FUNCTION:
; THIS PROCEDURE PARSES A COMPLEX LIST FOUND WITHIN THE LPT=(	)
; COMPLEX LIST.
;
; AT ENTRY: RESULT BUFFER CONTAINS POINTER TO COMPLEX STRING
;
; AT EXIT:
;    NORMAL: TABLE SET UP WITH VALUES FOUND
;
;    ERROR: OK_FLAG = 0
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PARSE_COMP   PROC   NEAR							    ;AN000;
	     PUSH   DI			  ; setup ro parse the nested.. 	    ;AN000;
	     PUSH   DS			  ; complex string..saving the..	    ;AN000;
	     PUSH   SI			  ; current parse status.		    ;AN000;
	     PUSH   CX			  ;					    ;AN000;
	     MOV    DI,BX		  ;					    ;AN000;
	     PUSH   DI			  ;					    ;AN000;
	     XOR    CX,CX		  ;					    ;AN000;
	     LEA    DI,PARMS3		  ; next control block			    ;AN000;
	     LDS    SI,RESULT_VAL	  ; point to stored string.		    ;AN000;
	     PUSH   BX			  ;					    ;AN000;
	     CALL   SYSPARSE		  ;					    ;AN000;
	     POP    BX			  ;					    ;AN000;
	     .WHILE <AX NE RC_EOL> AND	  ; not EOL?...and..			    ;AN000;
	     .WHILE <OK_FLAG EQ ON> AND   ; error flag still okay?		    ;AN000;
	     .WHILE <AX NE RC_OP_MISSING> ;					    ;AN000;
	       .IF <AX NE RC_NO_ERROR>	  ; parse error?...or.. 		    ;AN000;
		 MOV	OK_FLAG,OFF	  ; found?....yes..reset flag.		    ;AN000;
	       .ELSE			  ; no...process..			    ;AN000;
		 INC	WORD PTR CS:[BX]  ; increment counter			    ;AN000;
		 .IF <<WORD PTR CS:[BX]> LE TEN>				    ;AN000;
		   POP	  DI		  ;					    ;AN000;
		   MOV	  AX,WORD PTR RESULT_VAL ; get numeric value into word	    ;AN000;
		   MOV	  WORD PTR CS:[DI+2],AX ;				    ;AN000;
		   INC	  DI		  ;					    ;AN000;
		   INC	  DI		  ;					    ;AN000;
		   PUSH   DI		  ;					    ;AN000;
		   PUSH   BX		  ;					    ;AN000;
		   LEA	  DI,PARMS3	  ;					    ;AN000;
		   CALL   SYSPARSE	  ; continue parsing			    ;AN000;
		   POP	  BX		  ;					    ;AN000;
		 .ELSE			  ;					    ;AN000;
		   MOV	  OK_FLAG,OFF	  ;					    ;AN000;
		 .ENDIF 		  ;					    ;AN000;
	       .ENDIF			  ;					    ;AN000;
	     .ENDWHILE			  ;					    ;AN000;
	     POP    DI			  ;					    ;AN000;
	     POP    CX			  ; restore previous parse..		    ;AN000;
	     POP    SI			  ; registers.				    ;AN000;
	     POP    DS			  ;					    ;AN000;
	     POP    DI			  ;					    ;AN000;
	     RET			  ;					    ;AN000;
PARSE_COMP   ENDP								    ;AN000;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: PARSE_STR
;
; FUNCTION:
; THIS PROCEDURE PARSES A STRING FOUND WITHIN THE LPT=(   ) STATEMENT
;
; AT ENTRY: RESULT BUFFER POINTS TO ASCIIZ STRING
;
; AT EXIT:
;    NORMAL: TABLE SET UP WITH VALUES FOUND
;
;    ERROR: STRING > 8 - OK_FLAG SET OFF
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PARSE_STR    PROC   NEAR							    ;AN000;
	     PUSH   DI			  ; get source and..			    ;AN000;
	     PUSH   DS			  ; destination registers..		    ;AN000;
	     PUSH   SI			  ; setup.				    ;AN000;
	     PUSH   CX			  ;					    ;AN000;
	     LDS    SI,RESULT_VAL	  ;					    ;AN000;
	     MOV    DI,BX		  ;					    ;AN000;
	     MOV    CS:[DI].N_LENGTH,EIGHT ;					    ;AN000;
	     INC    DI			  ;					    ;AN000;
	     INC    DI			  ;					    ;AN000;
	     MOV    CX,EIGHT		  ;					    ;AN000;
	     LODSB			  ; load first character.		    ;AN000;
	     .WHILE <AL NE ZERO> AND	  ; while not at end of ASCIIZ do..	    ;AN000;
	     .WHILE <CX NE ZERO>	  ;					    ;AN000;
	       STOSB			  ; store..				    ;AN000;
	       LODSB			  ; load next character..		    ;AN000;
	       DEC    CX		  ;					    ;AN000;
	     .ENDWHILE			  ;					    ;AN000;
	     .IF <CX EQ ZERO>							    ;AN000;
	       MOV    OK_FLAG,OFF						    ;AN000;
	     .ENDIF								    ;AN000;
	     POP    CX			  ; value found.			    ;AN000;
	     POP    SI			  ; restore registers.			    ;AN000;
	     POP    DS			  ;					    ;AN000;
	     POP    DI			  ;					    ;AN000;
	     RET								    ;AN000;
PARSE_STR    ENDP								    ;AN000;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: COPY_NAME
;
; FUNCTION:
; THIS PROCEDURE COPIES THE FOUND STRING VALUE INTO THE TABLE.
;
; AT ENTRY: N/A
;
; AT EXIT:
;    NORMAL: TABLE UPDATED
;
;    ERROR: N/A
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

COPY_NAME    PROC   NEAR							    ;AN000;
	     PUSH   DI			  ; get source and..			    ;AN000;
	     PUSH   DS			  ; destination registers..		    ;AN000;
	     PUSH   SI			  ; setup.				    ;AN000;
	     PUSH   CS			  ;					    ;AN000;
	     POP    DS			  ;					    ;AN000;
	     MOV    SI,SYN_PTR		  ;					    ;AN000;
	     MOV    DI,CS:[BX].DN_OFFSET  ;					    ;AN000;
	     MOV    CS:[DI].N_LENGTH,EIGHT ;					    ;AN000;
	     INC    DI			  ;					    ;AN000;
	     INC    DI			  ;					    ;AN000;
	     LODSB			  ; load first character.		    ;AN000;
	     .WHILE <AL NE ZERO>	  ; while not at end of ASCIIZ do..	    ;AN000;
	       .IF <AL NE ':'> AND        ;ignore colon                             ;AN001;
	       .IF <AL NE '='>            ; or =                                    ;AN001;
		 STOSB			  ; store..				    ;AN000;
	       .ENDIF			  ;					    ;AN000;
	       LODSB			  ; load next character..		    ;AN000;
	     .ENDWHILE			  ;					    ;AN000;
	     POP    SI			  ; restore registers.			    ;AN000;
	     POP    DS			  ;					    ;AN000;
	     POP    DI			  ;					    ;AN000;
	     RET								    ;AN000;
COPY_NAME    ENDP								    ;AN000;

CSEG	      ENDS
	      END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\printer\5202\5202.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;    DESCRIPTION :  Code Page Switching 5202 Printer Font File
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ESC1	EQU	01BH			;
					;
CSEG	SEGMENT 			;
	ASSUME CS:CSEG,DS:CSEG		;
BEGIN:	ORG    0			;
					;
FNTHEAD:DB     0FFH,"FONT   "           ; FILE TAG
	DB     8 DUP(0) 		; RESERVED
	DW     1			; CNT OF POINTERS IN HEADER
	DB     1			; TYPE FOR INFO POINTER
	DW     OFFSET INFO,0		; POINTER TO INFO IN FILE
					;
info :	DW	5			; COUNT OF ENTRIES
					;
QUI437: DW     LEN_437			; SIZE OF ENTRY HEADER
	DW     QUI850,0 		; POINTER TO NEXT HEADER
	DW     2			; DEVICE TYPE
	DB     "5202    "               ; DEVICE SUBTYPE ID
	DW     437			; CODE PAGE ID
	DW     3 DUP(0) 		; RESERVED
	DW     OFFSET DATA437,0 	; POINTER TO FONTS
LEN_437 EQU    ($-QUI437)               ;
					;
QUI850: DW     LEN_850			; SIZE OF ENTRY HEADER
	DW     QUI860,0 		; POINTER TO NEXT HEADER
	DW     2			; DEVICE TYPE
	DB     "5202    "               ; DEVICE SUBTYPE ID
	DW     850			; CODE PAGE ID
	DW     3 DUP(0) 		; RESERVED
	DW     OFFSET DATA850,0 	; POINTER TO FONTS
LEN_850 EQU    ($-QUI850)               ;
					;
QUI860: DW     LEN_860			; SIZE OF ENTRY HEADER
	DW     QUI863,0 		; POINTER TO NEXT HEADER
	DW     2			; DEVICE TYPE
	DB     "5202    "               ; DEVICE SUBTYPE ID
	DW     860			; CODE PAGE ID
	DW     3 DUP(0) 		; RESERVED
	DW     OFFSET DATA860,0 	; POINTER TO FONTS
LEN_860 EQU    ($-QUI860)               ;
					;
QUI863: DW     LEN_863			; SIZE OF ENTRY HEADER
	DW     QUI865,0 		; POINTER TO NEXT HEADER
	DW     2			; DEVICE TYPE
	DB     "5202    "               ; DEVICE SUBTYPE ID
	DW     863			; CODE PAGE ID
	DW     3 DUP(0) 		; RESERVED
	DW     OFFSET DATA863,0 	; POINTER TO FONTS
LEN_863 EQU    ($-QUI863)               ;
					;
QUI865: DW     LEN_865			; SIZE OF ENTRY HEADER
	DW     0,0			; POINTER TO NEXT HEADER
	DW     2			; DEVICE TYPE
	DB     "5202    "               ; DEVICE SUBTYPE ID
	DW     865			; CODE PAGE ID
	DW     3 DUP(0) 		; RESERVED
	DW     OFFSET DATA865,0 	; POINTER TO FONTS
LEN_865 EQU    ($-QUI865)               ;
					;
DATA437:DW     1			; CART/NON-CART
	DW     1			; # OF FONTS
	DW     16			; LENGTH OF DATA
	DW     2			; SELECTION TYPE
	DW     12			; SELECTION length
	DB     ESC1,91,84,5,0,00,00,001H,0B5H,00   ; select code page ******
	dB     ESC1,"6"                  ;
					;
DATA850:DW     1			; CART/NON-CART
	DW     1			; # OF FONTS
	DW     16			; LENGTH OF DATA
	DW     2			; SELECTION TYPE
	DW     12			; SELECTION length
	DB     ESC1,91,84,5,0,00,00,003H,052H,00   ; select code page ******
	dB     ESC1,"6"                  ;
					;
DATA860:DW     1			; CART/NON-CART
	DW     1			; # OF FONTS
	DW     16			; LENGTH OF DATA
	DW     2			; SELECTION TYPE
	DW     12			; SELECTION length
	DB     ESC1,91,84,5,0,00,00,003H,05CH,00   ; select code page ******
	dB     ESC1,"6"                  ;
					;
DATA863:DW     1			; CART/NON-CART
	DW     1			; # OF FONTS
	DW     16			; LENGTH OF DATA
	DW     2			; SELECTION TYPE
	DW     12			; SELECTION length
	DB     ESC1,91,84,5,0,00,00,003H,05FH,00   ; select code page ******
	dB     ESC1,"6"                  ;
					;
DATA865:DW     1			; CART/NON-CART
	DW     1			; # OF FONTS
	DW     16			; LENGTH OF DATA
	DW     2			; SELECTION TYPE
	DW     12			; SELECTION length
	DB     ESC1,91,84,5,0,00,00,003H,061H,00   ; select code page ******
	dB     ESC1,"6"                  ;

include copyrigh.inc

CSEG	ENDS				;
	END BEGIN			;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\printer\ptrmsg.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

	PAGE	,132

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  FILENAME:	  CPS Device Driver -- Message File
;;  MODULE NAME:  PTRMSG1
;;  TYPE:	  Message External File
;;  LINK PROCEDURE:  see CPSPMNN.ASM
;;
;;  INCLUDE FILES:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;;
CSEG	SEGMENT PUBLIC 'CODE'           ;;
	ASSUME	CS:CSEG 		;;
	ASSUME	DS:NOTHING		;;
					;;
PUBLIC	msg_no_init_p			;;
PUBLIC	msg_no_init			;;
PUBLIC	msg_bad_syntax			;;
PUBLIC	msg_insuff_mem			;;
					;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  ************************************
;;  **				      **
;;  **	     Resident Code	      **
;;  **				      **
;;  ************************************
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

INCLUDE PTRMSG.INC

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CSEG	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\ramdrive\loadall.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
BREAK	<LOADALL descriptor caches>

DEF_ACCESS	EQU	92H
DEF_LIMIT	EQU	0FFFFH

SEGREG_DESCRIPTOR STRUC
SEG_BASE	DW	?
		DB	?
SEG_ACCESS	DB	DEF_ACCESS
SEG_LIMIT	DW	DEF_LIMIT
SEGREG_DESCRIPTOR ENDS

DTR_DESCRIPTOR STRUC
DTR_BASE	DW	?
		DB	?
		DB	0
DTR_LIMIT	DW	?
DTR_DESCRIPTOR ENDS
;
; 386 Descriptor template
;
desc	struc
lim_0_15	dw	0		; limit bits (0..15)
bas_0_15	dw	0		; base bits (0..15)
bas_16_23	db	0		; base bits (16..23)
access		db	0		; access byte
gran		db	0		; granularity byte
bas_24_31	db	0		; base bits (24..31)
desc	ends

gdt_descriptor	struc
gdt_limit	dw	?
gdt_base_0	dw	?
gdt_base_2	dw	?
gdt_descriptor	ends

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\ramdrive\dirent.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
Break <Directory entry>

;
;	+---------------------------+
;	|  (12 BYTE) filename/ext   |	    0	    0
;	+---------------------------+
;	|     (BYTE) attributes     |	    11	    B
;	+---------------------------+
;	|    (10 BYTE) reserved     |	    12	    C
;	+---------------------------+
;	| (WORD) time of last write |	    22	    16
;	+---------------------------+
;	| (WORD) date of last write |	    24	    18
;	+---------------------------+
;	|   (WORD) First cluster    |	    26	    1A
;	+---------------------------+
;	|     (DWORD) file size     |	    28	    1C
;	+---------------------------+
;
;   First byte of filename  = E5 -> free directory entry
;			    = 00 -> end of allocated directory
;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
;

dir_entry   STRUC
dir_name    DB	    11 DUP (?)		; file name
dir_attr    DB	    ?			; attribute bits
dir_pad     DB	    10 DUP (?)		; reserved for expansion
dir_time    DW	    ?			; time of last write
dir_date    DW	    ?			; date of last write
dir_first   DW	    ?			; first allocation unit of file
dir_size_l  DW	    ?			; low 16 bits of file size
dir_size_h  DW	    ?			; high 16 bits of file size
dir_entry   ENDS

attr_read_only	    EQU      1h
attr_hidden	    EQU      2h
attr_system	    EQU      4h
attr_volume_id	    EQU      8h
attr_directory	    EQU     10h
attr_archive	    EQU     20h
attr_device	    EQU     40h 	; This is a VERY special bit.
					;   NO directory entry on a disk EVER
					;   has this bit set. It is set non-zero
					;   when a device is found by GETPATH

attr_all	    EQU     attr_hidden+attr_system+attr_directory
					; OR of hard attributes for FINDENTRY

attr_ignore	    EQU     attr_read_only+attr_archive+attr_device
					; ignore this(ese) attribute(s) during
					; search first/next

attr_changeable     EQU     attr_read_only+attr_hidden+attr_system+attr_archive
					; changeable via CHMOD

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\ramdrive\mi.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
BREAK <Machine instruction, flag definitions and character types>

mi_INT		EQU	0CDh
mi_Long_JMP	EQU	0EAh
mi_Long_CALL	EQU	09Ah
mi_Long_RET	EQU	0CBh
mi_Near_RET	EQU	0C3h

;			xxxxoditszxaxpxc
f_Overflow	EQU	0000100000000000B
f_Direction	EQU	0000010000000000B
f_Interrupt	EQU	0000001000000000B
f_Trace 	EQU	0000000100000000B
f_Sign		EQU	0000000010000000B
f_Zero		EQU	0000000001000000B
f_Aux		EQU	0000000000010000B
f_Parity	EQU	0000000000000100B
f_Carry 	EQU	0000000000000001B

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\printer\parse4e.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;***************************************************************
;**                                                           **
;**     ********  **   **  *******                            **
;**        **     **   **  **                                 **
;**        **     *******  *****                              **
;**        **     **   **  **                                 **
;**        **     **   **  *******                            **
;**                                                           **
;**   ******      *     ******     ******  *******  ******    **
;**   **   **   ** **   **   **   **       **       **   **   **
;**   ******   *******  ******     *****   ******   ******    **
;**   **       **   **  **  **         **  **       **  **    **
;**   **       **   **  **   **   ******   *******  **   **   **
;**                                                           **
;***************************************************************
;
; File Name:   PARSE.ASM
; ----------
;
; Description: A command parser for DEVICE command in the CONFIG.SYS file.
; ------------
;
; Procedures contained in the file:
; ---------------------------------
;              PARSER:  Main routine for command processing.
;              GET_CHAR:  Gets a character from command line.
;              IS_ALPH:  Checks if character is an alpha character.
;              IS_DIGIT:  Checks if character is a digit.
;              IS_DELIM:  Checks if character is a DOS delimiter.
;              DEVICE_PARSE:  Pulls device name from command line and
;                             inserts in table.
;              ID_PARSE:  Pulls id name from command line and insers in table
;              HWCP_PARMS:  Extract HWCP number, converts it to binary and
;                           inserts it in table.
;              HWCP_PARSE:  Extracts HWCP number if only one number is given.
;              MUL_HWCP:  Extracts multiple HWCP's numbers, if they are given
;                         in a list.
;              DESG_PARMS:  Extracts designate number, converts it to binary
;                           and inserts it in table.
;              DESG_FONT:  Extracts the designate and the font if both were
;                          given in command line.
;              DESG_PARSE:  Pulls designate number if it is the only one given.
;              GET_NUMBER:  Converts a number to binary.
;              OFFSET_TABLE:  Updates the counter in table #1.
;              FIND_RIGHT_BR:  Looks for a right bracket.
;
;
; Change history:
; ---------------
;
;
;LOGIC:
;------
;        Establish addressability to parameters.
;        Skip until end of path and file name -first delimiter
;
;   Loop:
;        Isolate the first non-delimiter or non delimeter characters.
;         If End_of_Line_Delimiter then
;           return an error_code
;         Else
;           If first non-delimiter is ALPHA then
;             (assume a device name)
;             Extracts device name
;         Update offset counter
;
;        Isolate the first non-delimiter characters after id name.
;         If End_of_Line_Delimiter then
;           return an error_code
;         Else
;           If first non-delimiter is ALPHA-NUMARIC or
;            If character is '(' then
;             (assume an id name)
;             Extracts id name
;         Update offset counter
;
;         Pull out HWCP
;           If error flag is set then exit
;           Else if end of line flag is set then exit
;
;         Pull out DESG parms
;           If error_flag is set then exit.
;           Else if end of line flag is set then exit
;           Else if Number of devices is four then Exit
;        Else Loop
;
;
;Subroutines Logic:
;------------------
;
;  GET_CHAR:
;  ---------
;              Load character in AL
;              If character less than 20h then
;                turn Z-flag on
;
;  IS_ALPHA:
;  ---------
;              Save character
;              'Convert character to upper case'
;              If character >=A and <=Z then
;                turn Z-flag on
;                exit
;              Else
;                Restore character
;                exit.
;
;  IS_DIGIT:
;  ---------   If Character >=0 and <=9 then
;                turn Z-flag on
;
;  IS_DELIMITER:
;  -------------
;              If character a dos delimiter (' ','=',',',';',TAB)
;                 then turn Z-flag on
;
;  DEVICE_PARSE:
;  -------------
;              Set device name length counter.
;              Loop
;                If a dos delimiter then
;                  add spaces to name (if require)
;                Else if char is ALPHA-NUM then
;                  save in table
;                  If name >8 character thne
;                    error; exit
;                Else
;                  error; exit
;
;  ID_PARSE:
;  ---------   Set id name length counter.
;              Loop
;                If a dos delimiter then
;                  add spaces to name (if require)
;                Else if char is ALPHA-NUM then
;                  save in table
;                  If name >8 character then
;                    error; exit
;                Else if char is ')' or '(' then
;                  set flags
;                Else
;                  error; exit
;
;  HWCP_PARMS:
;  -----------
;       Loop:   Set flags off
;               If char is a DIGIT then
;                 convert number to binary
;                 update table
;               Else if char is ',' then
;                 no HWCP was given
;                 exit
;               Else if char is '(' then
;                 assume multiple HWCP
;               Else if char is ')' then
;                 end of parms, exit
;               Else if not a delimiter then
;                 error, exit set carry flag set carry flag
;               Loop
;
;  HWCP_PARSE:
;  -----------  Increment counter
;               Get number and convert to binary
;               Update the table
;               Set table_5 pointer
;
;  MUL_HWCP:
;  ---------
;      Loop:    If char is ')' then
;                 end of list, exit
;               If char is a DIGIT
;                 Get number and convert to binary
;                 Update table.
;               If char is not a delimiter then
;                 error, exit set carry flag
;               Loop
;
;  DESG_PARMS:
;  -----------
;        Loop:  If char is a DIGIT then
;                 Get number and convert to binary
;                 Update table.
;               If char is a ')' then
;                 end of parms, exit
;               If char is a '(' then
;                 assume given desg. and font
;               If char is a ',' then
;                 no desg ginven
;                 scane for ')'
;               If char is not a delimiter then
;                 error, exit set carry flag
;               Loop
;
;  DESG_FONT:
;  ----------
;       Loop:   If char is a ',' then
;                 no desg number was given
;                 update table
;               If char is a ')' then
;                 end of desg-font pair, exit
;               If char is a DIGIT then
;                 Get number and convert to binary
;                 Update table
;               If char not a delimiter then
;                 error, exit set carry flag
;               Loop
;
;  DESG_PARSE:
;  -----------  Get number and conver to binary
;               Update table
;
;  GET_NUMBER:
;  -----------  Get ASCII number from parms
;               conver to binary
;               add to total
;
;  OFFSET_TABLE:
;  -------------
;               Increment the number of parms
;
;  FIND_RIGHT_BR:
;  --------------
;         Loop: If char is ')' then
;                 found bracket exit
;               If char is not ' ' then
;                 error, exit set carry flag
;               Loop
; END
;------------------------------------------------------
;
; The following is the table structure of the parser.   All fields are
; two bytes field (accept for the device and id name)
;
; TABLE HEADER :
; 
;    Ŀ
;     N = Number of devices.     
;    Ĵ
;       Device  # 1  offset     >Ŀ
;    Ĵ                                         
;       Device  # 2  offset                           Table_1  (a)        
;    Ĵ                                         
;       Device  # 3  offset                     
;    Ĵ
;       Device  # 4  offset      
;    
;
;
; N = 1,2,3 or 4.  A two bytes number indicating the number of device specified.
; DEVICE # N OFFSET : a two bytes offset address to table_1. (ie. Device #1 offset
; is a pointer to table_1 (a). Device #2 offset is a pointer to table_1
; (b)...etc.).   If an error was detected in the command N is set to zero.
;
;
;
; TABLE_1 :
; 
;
;    Ŀ           Ŀ
;     N = Number of Offsets.                                          
;    Ĵ    ĳ      Table_2  (a)        
;       Device Name  offset                                     
;    Ĵ           
;       Device  Id   offset     Ŀ
;    Ĵ          Ŀ
;       Device  HWCP offset     Ŀ                               
;    Ĵ     ĳ      Table_3  (a)        
;       Device  Desg offset     Ŀ                                 
;    Ĵ         
;          "Reserved"               
;             Ŀ
;                                                                     
;                                     ĳ      Table_4  (a)        
;                                                                      
;                                            
;                                            Ŀ
;                                                                      
;                                    ĳ      Table_5  (a)        
;                                                                       
;                                             
;
;
;  N=Length of table_1, or the number of offsets contained in table_1.
;  The offsets are pointers (two bytes) to the parameters value of the device.
;  "Reserved" : a two byte memory reserved for future use of the "PARMS" option.
;
;
; TABLE_2 :
; 
;
;    Ŀ
;     N = Length of devices name 
;    Ĵ
;        Device   name           
;    
;
; N = Length of device name.  Device length is always 8 byte long.
; Device Name : the name of the device (eg. LPT1, CON, PRN).  The name
; is paded with spaces to make up the rest of the 8 characters.
;
;
;
; TABLE_3 :
; 
;
;    Ŀ
;     N = Length of Id name.     
;    Ĵ
;         Id   Name              
;    
;
; N = Length of id name.  Id name length is always 8 byte long.
; Id Name : the name of the id (eg. EGA, VGA, 3812).  The name
; is paded with spaces to make up the rest of the 8 character.
;
;
;
; TABLE_4 :
; 
;
;    Ŀ
;     N = Length of table.       
;    Ĵ
;        HWCP  #  1              
;    Ĵ
;        HWCP  #  2              
;    Ĵ
;              .                 
;              .                 
;              .                 
;    Ĵ
;        HWCP  #  10             
;    
;
;
; N = Length of table in words. Or the number of HWCP's.
; HWCP # N : a hardware code page number converted to binary.  The maximum
; number of pages allowed is 10.
;
;
;
; TABLE_5 :
; 
;
;    Ŀ
;     N = Length of table.       
;    Ĵ
;        Designate               
;    Ĵ
;        Font                    
;    
;
; N = Lenght of table.  0 - nothing was specified
;                       1 - Only a designate was specified.
;                       2 - Designate and font were given.  If the Desg field
;                           was left empty in the DEVICE command then the
;                           Designate field is filled with 0FFFFH.
; Designate, Font : Are the Desg. and Font binary numbers.
;
;------------------------------------------------------
;

PROGRAM         SEGMENT

                ASSUME  CS:PROGRAM
                ASSUME  DS:PROGRAM
                ASSUME  ES:PROGRAM

                ORG     100H

START:
                JMP     NOW

;RESERVED MEMORY:
TABLE_1         DW      ?                       ; Pointer at offsets.
TABLE_2         DW      ?                       ; Pointer at device name.
TABLE_3         DW      ?                       ; Pointer at id name.
TABLE_4         DW      ?                       ; Pointer at hwcp.
TABLE_5         DW      ?                       ; Pointer at desg and font.
TABLE           DB      290 DUP (?)             ; Table of parsed parms. Max 4 devices.
DEVNUM          DW      ?                       ; Counter to number of devices.
RIGHT_FLAG      DB      ?                       ; Flag to indicate a left bracket.
DEV_ERR_FLG     DB      ?                       ; Device name error flag.
ID_ERR_FLG      DB      ?                       ; Id name error flag.
ERROR_FLAG      DB      ?                       ; Error flag_terminate program if set to 1.
COMMA_FLAG      DB      ?                       ; Indicate the number of commas incounterd.
HWCP_FLAG       DB      ?                       ; Flag for multiple hwcps.
DESG_FLAG       DB      ?                       ; Flag indicates desg. and font.

;Main part of program-links different sumbroutines together
NOW:
                CALL    PARSER
                INT     20H                     ;Exit DOS.

PARSER          PROC

                PUSH    AX                      ; ;;;;;;;;;;;;;;;;;;
                PUSH    BX                      ; ;
                PUSH    CX                      ; ; SAVE
                PUSH    DX                      ; ; ALL
                PUSH    DS                      ; ; REGISTERS.
                PUSH    ES                      ; ;
                PUSH    DI                      ; ;
                PUSH    SI                      ; ;;;;;;;;;;;;;;;;;;

                ;LES     SI,RH.RH0_BPBA         ; Point at all after DEVICE=
                                                ; in the CONFIG.SYS file.

                mov     di,81h                  ; ;;;;;;;;;;;;;;;;;;;;;;;;;
                mov     cl,cs:byte ptr [di-1]   ; ;                      ;;
                xor     ch,ch                   ; ;        ERASE THIS    ;;
                add     di,cx                   ; ;;;;;;;; CODE IN       ;;
                mov     ds:word ptr[di],0a0dh   ; ; CPS                  ;;
                                                ; ;;;;;;;;               ;;
                MOV     SI,0081h                ; ;Set SI at parameters. ;;
                                                ; ;;;;;;;;;;;;;;;;;;;;;;;;;

;Skip to end of file name, to the first DOS delimiter.

                MOV     DEVNUM,02H              ; Number of devices counter.

GET_PARMS_A:    CALL    GET_CHAR                ; Get command character in AL .
                JZ      EXIT_B                  ; No parms found.
                CALL    IS_DELIM                ; If not a delimiter then.
                JNE     GET_PARMS_A             ; Check next character.

                MOV     DI,OFFSET TABLE         ; Get the table address.
                ADD     DI,02H                  ; Point at devices offsets.
                MOV     BX,DI                   ;
                ADD     BX,08H                  ; Point BX at parms offsets.
TAB2:           CALL    UPDATE_TABLE            ; Update table pointers value.

CLR_DELIM:      CALL    GET_CHAR                ; Get character into AL.
                JZ      EXIT_B                  ; No parms found.
                CALL    IS_ALPHA                ; If alpha then assume.
                JZ      DEVICE                  ; A device name.
                CALL    IS_DELIM                ; Is it a delimiter
                JNE     EXIT_A                  ; If not then error.
                JMP     CLR_DELIM               ; Get next character.

DEVICE:         MOV     DEV_ERR_FLG,00H         ; Set device error flag off;
                CALL    DEVICE_PARSE            ; Call routine to parse device name.
                CMP     DEV_ERR_FLG,01H         ; If error flag is
                JZ      EXIT_A                  ; set then exit.
                CALL    OFFSET_TABLE            ; Update table.

ID_PARMS:       CALL    GET_CHAR                ; Load a character in AL.
                JZ      EXIT_A                  ; Exit if end of line (error).
                CMP     AL,'('                  ; If AL is a '(' then
                JE      ID                      ; Parse ID name.
                CALL    IS_ALPHA                ; If an Alpha
                JE      ID                      ; Then parse ID name.
                CALL    IS_DIGIT                ; If a digit
                JE      ID                      ; Then parse ID name.
                CALL    IS_DELIM                ; If not a delimiter
                JNE     EXIT_A                  ; Then error, exit
                JMP     ID_PARMS                ; Get another number

EXIT_B:         CMP     DEVNUM,02H              ; If device number above 2 then
                JA      EXIT_C                  ; Exit parse.
                JMP     EXIT_A                  ; Else error, exit

ID:             MOV     ID_ERR_FLG,00H          ; Set id error flag off.
                CALL    ID_PARSE                ; Parse ID name.
                CMP     ID_ERR_FLG,01H          ; Was error flag set, then
                JE      EXIT_A                  ; Print error message.
                CALL    OFFSET_TABLE            ; Update table of offsets.

                CALL    HWCP_PARMS              ; Get code page number
                CMP     ERROR_FLAG,01H          ; If error, then
                JE      EXIT_A                  ; Print error message and exit
                CMP     ERROR_FLAG,02H          ; If end of string
                JE      EXIT_H                  ; Then exit.

                CALL    DESG_PARMS              ; Get designate number
                CMP     ERROR_FLAG,01H          ; If error, then
                JE      EXIT_A                  ; Print error message and exit
                JMP     EXIT_H                  ; Then exit.

EXIT_A:         MOV     DI,OFFSET TABLE         ; Load table offset
                MOV     DS:WORD PTR [DI],00H    ; Set error to on.
                STC                             ; Set carry flag
                JMP     EXIT_P                  ; Exit parse.

EXIT_H:         MOV     DI,OFFSET TABLE         ; Load table offset.
                ADD     DS:WORD PTR [DI],01H    ; Increment number of devices.
                CMP     DEVNUM,08H              ; If 4 devices loaded
                JE      EXIT_C                  ; Then exit parse.
                ADD     DEVNUM,02H              ; Increment the number of devices
                ADD     DI,DEVNUM               ; Point at next devices offset.
                MOV     BX,TABLE_5              ; BX point at
                ADD     BX,06H                  ; end of previous table.
                JMP     TAB2                    ; Get next device.

EXIT_C:         CLC

EXIT_P:         POP     SI                      ; ;;;;;;;;;;;;;;;;;;
                POP     DI                      ; ;
                POP     ES                      ; ;  RESTORE
                POP     DS                      ; ;  ALL
                POP     DX                      ; ;  REGISTERS.
                POP     CX                      ; ;
                POP     BX                      ; ;
                POP     AX                      ; ;;;;;;;;;;;;;;;;;;
                RET

PARSER          ENDP


;********************************************************
;** GET_CHAR : a routine to get next character pointed **
;** to by ES:SI into AL.                               **
;********************************************************

GET_CHAR        PROC

                MOV     AL,ES:BYTE PTR [SI]     ; Load character pointed to
                CMP     AL,09H                  ; by ES:[SI] in AL.
                JE      ZOFF                    ; If tab then O.K
                CMP     AL,20H                  ; Turn Z-flag on
                JL      TURN_Z_ON               ; if character
ZOFF:           INC     SI                      ; is below
                JMP     GET_CHAR_X              ; 20h.
                                                ; ( End of line
TURN_Z_ON:      CMP     AL,AL                   ;   delimiters ).
GET_CHAR_X:     RET

GET_CHAR        ENDP


;********************************************************
;** IS_ALPHA : a routine to check the character in     **
;** AL if it is an alpha character (a...z,A...Z).      **
;** If character is lower case, convert to upper case. **
;********************************************************

IS_ALPHA        PROC

                PUSH    AX                      ; Save value of AL
                AND     AL,0DFH                 ; Convert to upper case
                CMP     AL,'A'                  ; If <'A', then
                JB      IS_ALPHA_X              ; NZ-flag is set, exit
                CMP     AL,'Z'                  ; If >'Z', then
                JA      IS_ALPHA_X              ; NZ-flag is set, exit
                CMP     AL,AL                   ; Force Z-flag
                POP     DX                      ; Discard lower case.
                JMP     IA_X                    ; Exit.
IS_ALPHA_X:     POP     AX                      ; Restore value of AL
IA_X:           RET

IS_ALPHA        ENDP


;********************************************************
;** IS_DIGIT : a routine to check if the character in  **
;** AL register is a digit (i.e. 1..9).                **
;********************************************************

IS_DIGIT        PROC

                CMP     AL,'0'                  ; If < '0' then
                JB      IS_NUM_X                ; NZ-flag is set, exit
                CMP     AL,'9'                  ; If > '9' then
                JA      IS_NUM_X                ; NZ-flag is set, exit
                CMP     AL,AL                   ; Set Z-flag to indecate digit
IS_NUM_X:       RET

IS_DIGIT        ENDP


;********************************************************
;** IS_DELIM : This routine check if the character in  **
;** AL is a delimiter. ('+',' ',';',',','=',tab)       **
;********************************************************

IS_DELIM        PROC

                CMP     AL,' '                  ; Test for space.
                JE      IS_DELIM_X              ; Z-flag is set, exit
                CMP     AL,','                  ; Test for comma.
                JE      IS_DELIM_X              ; Z-flag is set, exit
                CMP     AL,';'                  ; Test for semicolon.
                JE      IS_DELIM_X              ; Z-flag is set, exit
                CMP     AL,'='                  ; Test for equal sign.
                JE      IS_DELIM_X              ; Z-flag is set, exit
                CMP     AL,09h                  ; Test for TAB.

IS_DELIM_X:     RET                             ; Exit

IS_DELIM        ENDP


;********************************************************
;** DEVICE_PARSE : Parse the device driver name and    **
;** store in table.  Update offset.                    **
;********************************************************

DEVICE_PARSE    PROC

                MOV     DI,TABLE_2
                MOV     DS:WORD PTR [DI],0008H  ; Save dev name size.
                ADD     DI,02H                  ; Increment DI.
                MOV     CX,9                    ; Set counter.
NEXT_C:         CALL    IS_ALPHA                ; if Check then.
                JZ      SAVE_C                  ; Save it.
                CALL    IS_DIGIT                ; if Digit then.
                JZ      SAVE_C                  ; Save it.
                CMP     AL,'-'                  ; If '-' then.
                JZ      SAVE_C                  ; Save it.
                CALL    IS_DELIM                ; If a delimiter then.
                JZ      ADD_SPACE1              ; Pad with spaces.
                CMP     AL,':'                  ; If a colon
                JE      ADD_SPACE1              ; then end device parse
                JMP     ERR_DEV_PAR             ; Else an error.

SAVE_C:         DEC     CX                      ; Decrement counter.
                CMP     CX,0                    ; If counter zero then.
                JE      ERR_DEV_PAR             ; Error.
                MOV     DS:BYTE PTR [DI],AL     ; Save char in table.
                INC     DI                      ; Increment pointer.
                CALL    GET_CHAR                ; Get another char.
                JZ      ERR_DEV_PAR
                JMP     NEXT_C                  ; Check char.

ERR_DEV_PAR:    MOV     DEV_ERR_FLG,01H         ; Set error flag.
                JMP     DEV_PAR_X               ; Exit.

ADD_SPACE1:     DEC     CX                      ; Check counter.
                CMP     CX,1
                JL      DEV_PAR_X               ; Exit if already 8.
LL1:            MOV     DS:BYTE PTR [DI],' '    ; Pad name with spaces.
                INC     DI                      ; Increment pointer.
                LOOP    LL1                     ; Loop again.
DEV_PAR_X:      RET

DEVICE_PARSE    ENDP


;********************************************************
;** ID_PARSE : Parse the id driver name and            **
;** store in table.  Update offset.                    **
;********************************************************

ID_PARSE        PROC

                MOV     DI,TABLE_3
                MOV     DS:WORD PTR [DI],0008H  ; Save dev name size.
                ADD     DI,02H                  ; Increment DI.
                MOV     RIGHT_FLAG,00H          ; Clear flag.
                MOV     CX,9                    ; Set counter.

NEXT_I:         CALL    IS_ALPHA                ; If Check then.
                JZ      SAVE_I                  ; Save it.
                CALL    IS_DIGIT                ; if Digit then.
                JZ      SAVE_I                  ; Save it.
                CMP     AL,'-'                  ; If '-' then.
                JZ      SAVE_I                  ; Save it.
                CMP     AL,'('                  ; If '(' then.
                JE      RIG_BR_FLG              ; Set flag.
                CMP     AL,')'                  ; If ')' then
                JE      BR_FLG_LEF              ; Pad with spaces.
                CALL    IS_DELIM                ; If a delimiter then.
                JZ      ADD_SPACE2              ; Pad with spaces.
                JMP     ERR_ID_PAR              ; Else an error.

SAVE_I:         DEC     CX                      ; Decrement counter.
                CMP     CX,0                    ; If counter zero then.
                JLE     ERR_ID_PAR              ; Error.
                MOV     DS:BYTE PTR [DI],AL     ; Save char in table.
                INC     DI                      ; Increment pointer.
                CALL    GET_CHAR                ; Get another char.
                JZ      ADD_SPACE2              ; Exit routine.
                JMP     NEXT_I                  ; Check char.

ERR_ID_PAR:     MOV     ID_ERR_FLG,01H          ; Set error falg on.
                JMP     ID_PAR_X                ; Exit.

BR_FLG_LEF:     CMP     RIGHT_FLAG,01H          ; If left bracket was
                JNE     ERR_ID_PAR              ; found and no previous
                JMP     ADD_SPACE2              ; Bracket found, then error

RIG_BR_FLG:     CMP     RIGHT_FLAG,01H          ; If more than one bracket
                JE      ERR_ID_PAR              ; then error.
                CMP     CX,09                   ; If '(' and already id
                JB      ERR_ID_PAR              ; then error.
                MOV     RIGHT_FLAG,01H          ; Set flag for.
                CALL    GET_CHAR                ; Left brackets.
                JZ      ERR_ID_PAR              ; If end of line,exit.
                JMP     NEXT_I                  ; Check character.

ADD_SPACE2:     DEC     CX                      ; Check counter.
                CMP     CX,1
                JL      ID_PAR_X                ; Exit if already 8.

LL2:            MOV     DS:BYTE PTR [DI],' '    ; Pad name with spaces.
                INC     DI                      ; Increment pointer.
                LOOP    LL2                     ; Loop again.

ID_PAR_X:       RET

ID_PARSE        ENDP

;********************************************************
;** HWCP_PARMS : Scane for the hardware code page, and **
;** parse it if found.  Flag  codes set to:            **
;** ERROR_FLAG = 0 - parsing completed. No error.      **
;** ERROR_FLAG = 1 - error found exit parse.           **
;** ERROR_FLAG = 2 - end of line found, exit parse.    **
;********************************************************


HWCP_PARMS      PROC

                MOV     COMMA_FLAG,00H          ; Set the comma flag off.
                MOV     ERROR_FLAG,00H          ; Set the error flag off.
                DEC     SI                      ; Point at current char in Al.
                CMP     RIGHT_FLAG,01H          ; If no left brackets then
                JNE     LEFT_BR                 ; Exit parse.

HWCP_1:         CALL    GET_CHAR                ; Load character in AL.
                JZ      LEFT_BR                 ; Exit, if end of line.
                CALL    IS_DIGIT                ; Check if digit, then
                JE      HP1                     ; Parse hwcp parms.
                CMP     AL,','                  ; If a comma
                JE      COMMA_1                 ; Jump to comma_1
                CMP     AL,')'                  ; If a ')' then
                JE      RIGHT_BR                ; end of current dev parms.
                CMP     AL,'('                  ; If a '(' then
                JE      HWCP_2                  ; There are multible hwcp.
                CALL    IS_DELIM                ; Else, if not a delimiter
                JNE     EXIT_2                  ; Then error, exit
                JMP     HWCP_1                  ; Get another character.

LEFT_BR:        CMP     RIGHT_FLAG,01H          ; If no left bracket
                JE      EXIT_2                  ; Then error, exit
                JMP     RB1                     ; Jump to rb1

COMMA_1:        CMP     COMMA_FLAG,01H          ; If comma flag set
                JE      COM_2_HC                ; Then exit hwcp parse.
                MOV     COMMA_FLAG,01H          ; Else set comma flag.
JMP HWCP_1 ; Get another character.

HWCP_2:         CMP     RIGHT_FLAG,01H          ; If left bracket not set
                JNE     EXIT_2                  ; then error.
                CALL    MUL_HWCP                ; else call multiple hwcp
                ADD     DI,02H                  ; routine.  Increment DI
                MOV     TABLE_5,DI              ; Desg. Table starts at end
                CALL    OFFSET_TABLE            ; Update table of offsets.
                JMP     HP_X                    ; Exit.

HP1:            JMP     HWCP                    ; Jump too long.

COM_2_HC:       MOV     DI,TABLE_4              ; DI points at hwcp table
                MOV     DS:WORD PTR [DI],0000H  ; Set number of pages to
                MOV     COMMA_FLAG,00H          ; Zero and reset comma flag.
                ADD     DI,02H                  ; Increment DI.
                MOV     TABLE_5,DI              ; Desg. Table starts at end
                CALL    OFFSET_TABLE            ; Update table of offsets.
                JMP     HP_X                    ; of hwcp table.  Exit.

RIGHT_BR:       CMP     RIGHT_FLAG,01H          ; If left brackets not
                JNE     EXIT_2                  ; Found then error.
RB1:            MOV     ERROR_FLAG,02H          ; Set end of line flag.
                MOV     BX,TABLE_4              ; Point at hwcp table
                ADD     BX,02H                  ; Adjust pointer to  desg
                MOV     TABLE_5,BX              ; table, and save in table_5
                MOV     DI,TABLE_1              ; Point at table of offsets
                ADD     DI,08H                  ; Set at DESG offset
                MOV     DS:WORD PTR [DI],BX     ; Update table.
                JMP     HP_X                    ; Exit



EXIT_2:         MOV     ERROR_FLAG,01H          ; Set error flag.
                JMP     HP_X                    ; and exit.

HWCP:           CMP     RIGHT_FLAG,01H          ; If left brackets not
                JNE     EXIT_2                  ; Found then error.
                CALL    HWCP_PARSE              ; Call parse one hwcp.
                CMP     ERROR_FLAG,01H          ; If error flag set
                JE      HP_X                    ; Then exit,  else
                CALL    OFFSET_TABLE            ; Update table of offsets.

HP_X:           RET

HWCP_PARMS      ENDP


;********************************************************
;** HWCP_PARSE : Parse the hardware code page page     **
;** number and change it from hex to binary.           **
;********************************************************

HWCP_PARSE      PROC

                MOV     DI,TABLE_4              ; Load address of hwcpages.
                ADD     DS:WORD PTR [DI],0001H  ; Set count to 1

                CALL    GET_NUMBER              ; Convert number to binary.
                CMP     ERROR_FLAG,01H          ; If error then
                JE      HWCP_X                  ; Exit.
                MOV     DS:WORD PTR [DI+2],BX   ; Else, save binary page number
                ADD     DI,04H                  ; Increment counter
                MOV     TABLE_5,DI              ; Set pointer of designate num

HWCP_X:         RET

HWCP_PARSE      ENDP


;********************************************************
;** MUL_HWCP : Parse multiple hardware code pages      **
;** and convert them from hex to binary numbers.       **
;********************************************************

MUL_HWCP        PROC

                MOV     DI,TABLE_4              ; Load offset of table_4
                MOV     BX,DI                   ; in DI and Bx.
                MOV     HWCP_FLAG,00H           ; Set hwcp flag off.

MH1:            CALL    GET_CHAR                ; Load character in AL.
                JZ      MH3                     ; Exit if end of line.
                CMP     AL,')'                  ; If ')' then exit
                JE      MH2                     ; end of parms.
                CALL    IS_DIGIT                ; If a digit, then
                JE      MH4                     ; Convert number to binary.
                CALL    IS_DELIM                ; If not a delimiter
                JNE     MH3                     ; then error, exit
                JMP     MH1                     ; get another character.

MH2:            CALL    GET_CHAR                ; Get next character
                JMP     MH_X                    ; and exit.

MH3:            MOV     ERROR_FLAG,01H          ; Set error flag on.
                JMP     MH_X                    ; Exit.

MH4:            ADD     HWCP_FLAG,01H           ; Set hwcp flag on (0 off)
                ADD     DI,02H                  ; Increment table pointer
                PUSH    BX                      ; Save Bx
                CALL    GET_NUMBER              ; Convert number to binary.
                MOV     DS:WORD PTR [DI],BX     ; Add number to table
                POP     BX                      ; Restore BX.
                CMP     ERROR_FLAG,01H          ; If error then
                JE      MH_X                    ; Exit.
                ADD     DS:WORD PTR [BX],01H    ; Increment hwcp count.
                DEC     SI                      ; Point at character in AL
                JMP     MH1                     ;   (delimeter or ')').
MH_X:           RET

MUL_HWCP        ENDP



;********************************************************
;** DESG_PARMS : Scane for the designate numbers, and  **
;** parse it if found.  Flag  codes set to:            **
;** ERROR_FLAG = 0 - parsing completed. No error.      **
;** ERROR_FLAG = 1 - error found exit parse.           **
;** ERROR_FLAG = 2 - end of line found, exit parse.    **
;********************************************************


DESG_PARMS      PROC

                MOV     DI,TABLE_1              ; Get offset of dev in DI
                MOV     BX,TABLE_5              ; & offset of desg. in BX.
                ADD     DI,08                   ; Location of desg offset in table.
                MOV     DS:WORD PTR [DI],BX     ; Update table.
                MOV     COMMA_FLAG,00H          ; Set comma flag off.

                cmp     al,'('
                je      df
                cmp     al,')'
                je      right_br2

                cmp     al,','
                jne     desg_parm1
                mov     comma_flag,01h

DESG_PARM1:     CALL    GET_CHAR                ; Get character in AL.
                JZ      EXIT_3                  ; Error, if end of line
                CALL    IS_DIGIT                ; If character is a digit
                JE      DESG                    ; Then convert to binary.
                CMP     AL,')'                  ; If a ')', then
                JE      RIGHT_BR2               ; end of parameters.
                CMP     AL,'('                  ; If a '(' then
                JE      DF                      ; parse desg and font.
                CMP     AL,','                  ; If a comma then
                JE      DP3                     ; set flag.
                CALL    IS_DELIM                ; If not a delimiter
                JNE     EXIT_3                  ; then error.
                JMP     DESG_PARM1              ; Get another character.

RIGHT_BR2:      CMP     RIGHT_FLAG,01H          ; IF no '(' encountered,
                JNE     EXIT_3                  ; then error, exit
                JMP     DP_x                    ; Jump to DP1.

EXIT_3:         MOV     ERROR_FLAG,01H          ; Set error flag on
                JMP     DP_X                    ; Exit.

DF:             CMP     RIGHT_FLAG,01H          ; If no '(' encountered
                JB      EXIT_3                  ; then error, exit
                CALL    DESG_FONT               ; Parse desg and font.
                JMP     DP1                     ; Jump to DP1.

DP2:            CALL    FIND_RIGHT_BR           ; Check for ')'
                JMP     DP_X                    ; Exit.

DP3:            CMP     COMMA_FLAG,01H          ; If comma flag set
                JE      DP2                     ; then error
                MOV     COMMA_FLAG,01H          ; Else set comma flag on.
                JMP     DESG_PARM1              ; Get another character.

DESG:           MOV     ERROR_FLAG,00H          ; Set error flag off.
                CALL    DESG_PARSE              ; Parse desg.
DP1:            CMP     ERROR_FLAG,01H          ; If error flag on then
                JE      DP_X                    ; Exit,
                CALL    FIND_RIGHT_BR           ; Else check for ')'
                CALL    OFFSET_TABLE            ; Update table

DP_X:           RET

DESG_PARMS      ENDP



;********************************************************
;** DESG_FONT : Parse the designate and font numbers & **
;** change them from decimal to binary.                **
;********************************************************


DESG_FONT       PROC


                MOV     DI,TABLE_5              ; Get desg font table.
                MOV     COMMA_FLAG,00H          ; Set comma flag off.
DF1:            CALL    GET_CHAR                ; Load a character in AL.
                JZ      DF3                     ; Error if end of line.
                CMP     AL,','                  ; Check if a comma.
                JE      DF2                     ; Set flag.
                CALL    IS_DIGIT                ; If a digit, then
                JE      DF5                     ; Convert number to binary.
                CMP     AL,')'                  ; If a ')' then
                JE      DF4                     ; Exit.
                CALL    IS_DELIM                ; If not a delimiter
                JNE     DF3                     ; then error, exit
                JMP     DF1                     ; Get another character.

DF2:            CMP     COMMA_FLAG,01H          ; If comma flag on
                JE      DF3                     ; then error, exit
                MOV     COMMA_FLAG,01H          ; Set comma flag on
                ADD     DS:WORD PTR [DI],01H      ; Increment desg counter.
                MOV     DS:WORD PTR [DI+2],0FFFFH ; Load ffffh for desg empty
                JMP     DF1                       ; field.

DF3:            MOV     ERROR_FLAG,01H          ; Set error flag on.
                JMP     DF_X                    ; Exit.

DF4:            CMP     DESG_FLAG,00H           ; If desg flag off
                JE      DF3                     ; then error, exit
                JMP     DF_X                    ; Else exit.

DF5:            ADD     DS:WORD PTR [DI],01H    ; Increment desg font count.
                CMP     DESG_FLAG,01H           ; If desg flag is on
                JE      DF6                     ; then get font.
                CMP     COMMA_FLAG,01H          ; if comma flag is on
                JE      DF6                     ; then get font.
                MOV     DESG_FLAG,01H           ; Set desg flag on
                JMP     DF7                     ; Get desg number.

DF6:            ADD     DI,02H                  ; adjust pointer to font.
                MOV     DESG_FLAG,02H           ; Set desg and font flag.
DF7:            CALL    GET_NUMBER              ; Get a number & convert to
                CMP     ERROR_FLAG,01H          ; binary.
                JE      DF_X                    ; If error flag set, Exit.
                MOV     DS:WORD PTR [DI+2],BX   ; Store number in table.
                CMP     DESG_FLAG,02H           ; If desg and font flag
                JNE     DF1                     ; not set, then get char.
                CALL    FIND_RIGHT_BR           ; Check for right bracket.

DF_X:           RET

DESG_FONT       ENDP


;********************************************************
;** DESG_PARSE : Parse the designate number and        **
;** change it from decimal to binary.                  **
;********************************************************

DESG_PARSE      PROC

                MOV     DI,TABLE_5              ; Load designate location
                ADD     DS:WORD PTR [DI],0001H  ; Update table count.

                CALL    GET_NUMBER              ; Get the ascii number and
                CMP     ERROR_FLAG,01H          ; conver it to binary
                JE      DESG_X                  ; If error then exit

                MOV     DS:WORD PTR [DI+2],BX   ; Else, save desg number


DESG_X:         RET

DESG_PARSE      ENDP


;********************************************************
;** GET_NUMBER : Convert the number pointed to by  SI  **
;** to a binary number and store it in BX              **
;********************************************************

GET_NUMBER      PROC

                MOV     CX,0AH                  ; Set multiplying factor
                XOR     BX,BX                   ; Clear DX

NEXT_NUM:       SUB     AL,30H                  ; Conver number to binary
                CBW                             ; Clear AH
                XCHG    AX,BX                   ; Switch ax and bx to mul
                MUL     CX                      ; already converted number by 10.
                JO      ERR_NUM                 ; On over flow jump to error.
                ADD     BX,AX                   ; Add number to total.
                JC      ERR_NUM                 ; On over flow jump to error.
                XOR     AX,AX                   ; Clear AX (clear if al=0a).
                CALL    GET_CHAR                ; Get next character
                JZ      GET_NUM_X               ; Exit, if end of line.
                CALL    IS_DIGIT                ; Call is digit.
                JNZ     GET_NUM_X               ; Exit if not a number.
                JMP     NEXT_NUM                ; Loop.

ERR_NUM:        MOV     ERROR_FLAG,01H          ; Set error code to 1.

GET_NUM_X:      RET

GET_NUMBER      ENDP


;********************************************************
;** UPDATE_TABLE : This routine set up pointers to the **
;** different offsets of the different tables          **
;********************************************************

UPDATE_TABLE    PROC

                MOV     DS:WORD PTR [DI],BX     ; Offset of offsets
                MOV     TABLE_1,BX              ; Table_1 points at offsets

                MOV     DI,BX                   ;
                ADD     BX,0CH                  ;
                MOV     DS:WORD PTR [DI+2],BX   ; Offset of DEVICE name.
                MOV     TABLE_2,BX              ; Table_2 point at device name.

                ADD     BX,0AH                  ;
                MOV     DS:WORD PTR [DI+4],BX   ; Offset of ID name.
                MOV     TABLE_3,BX              ; Table_3 point at ID name.

                ADD     BX,0AH                  ;
                MOV     DS:WORD PTR [DI+6],BX   ; Offset of HWCP pages.
                MOV     TABLE_4,BX              ; Table_4 point at HWCP pages.

                RET

UPDATE_TABLE    ENDP


;********************************************************
;** OFFSET_TABLE : This routine set up pointers of     **
;** tables number one and two.                         **
;********************************************************

OFFSET_TABLE    PROC

                MOV     DI,TABLE_1              ; Increment the number
                ADD     DS:WORD PTR [DI],01H    ; of parms foun. (ie. id,hwcp
                RET                             ; and desg)

OFFSET_TABLE    ENDP


;********************************************************
;** FIND_RIGHT_BR :This routine scane the line for a   **
;** ')' if cannot find it turns error flag on          **
;********************************************************

FIND_RIGHT_BR   PROC

FBR1:           CMP     AL,')'                  ; If a right bracket
                JE      FBR_X                   ; then exit.
                CMP     AL,' '                  ; If not a space
                JNE     FBR2                    ; Then error.
                CALL    GET_CHAR                ; Get a character
                JZ      FBR2                    ; If end of line then exit.
                JMP     FBR1                    ; Else get another character.

FBR2:           MOV     ERROR_FLAG,01H          ; Set error flag on
FBR_X:          MOV     AL,20H                  ; Erase character from AL.
                RET

FIND_RIGHT_BR   ENDP


PROGRAM         ENDS
                END     START

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\ramdrive\devsym.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
BREAK <Device table and SRH definition>

; The device table list has the form:
SYSDEV	STRUC
SDEVNEXT	DD	?	;Pointer to next device header
SDEVATT 	DW	?	;Attributes of the device
SDEVSTRAT	DW	?	;Strategy entry point
SDEVINT 	DW	?	;Interrupt entry point
SDEVNAME	DB	8 DUP (?) ;Name of device (only first byte used for block)
SYSDEV	ENDS

;
; Attribute bit masks
;
; Character devices:
;
; Bit 15 -> must be 1
;     14 -> 1 if the device understands IOCTL control strings
;     13 -> 1 if the device supports output-until-busy
;     12 -> unused
;     11 -> 1 if the device understands Open/Close
;     10 -> must be 0
;      9 -> must be 0
;      8 -> unused
;      7 -> unused
;      6 -> unused
;      5 -> unused
;      4 -> 1 if device is recipient of INT 29h
;      3 -> 1 if device is clock device
;      2 -> 1 if device is null device
;      1 -> 1 if device is console output
;      0 -> 1 if device is console input
;
; Block devices:
;
; Bit 15 -> must be 0
;     14 -> 1 if the device understands IOCTL control strings
;     13 -> 1 if the device determines media by examining the FAT ID byte.
;	    This requires the first sector of the fat to *always* reside in
;	    the same place.
;     12 -> unused
;     11 -> 1 if the device understands Open/Close/removable media
;     10 -> must be 0
;      9 -> must be 0
;      8 -> unused
;      7 -> unused
;      6 -> unused
;      5 -> unused
;      4 -> unused
;      3 -> unused
;      2 -> unused
;      1 -> unused
;      0 -> unused

DevTyp	    EQU     8000H		; Bit 15 - 1  if Char, 0 if block
CharDev     EQU     8000H
DevIOCtl    EQU     4000H		; Bit 14 - CONTROL mode bit
ISFATBYDEV  EQU     2000H		; Bit 13 - Device uses FAT ID bytes,
					;  comp media.
OutTilBusy  EQU     2000h		; Output until busy is enabled
ISNET	    EQU     1000H		; Bit 12 - 1 if a NET device, 0 if
					;  not.  Currently block only.
DEVOPCL     EQU     0800H		; Bit 11 - 1 if this device has
					;  OPEN,CLOSE and REMOVABLE MEDIA
					;  entry points, 0 if not

EXTENTBIT   EQU     0400H		; Bit 10 - Currently 0 on all devs
					;  This bit is reserved for future use
					;  to extend the device header beyond
					;  its current form.

; NOTE Bit 9 is currently used on IBM systems to indicate "drive is shared".
;    See IOCTL function 9. THIS USE IS NOT DOCUMENTED, it is used by some
;    of the utilities which are supposed to FAIL on shared drives on server
;    machines (FORMAT,CHKDSK,RECOVER,..).

ISSPEC	    EQU     0010H		      ;Bit 4 - This device is special
ISCLOCK     EQU     0008H		      ;Bit 3 - This device is the clock device.
ISNULL	    EQU     0004H		      ;Bit 2 - This device is the null device.
ISCOUT	    EQU     0002H		      ;Bit 1 - This device is the console output.
ISCIN	    EQU     0001H		      ;Bit 0 - This device is the console input.

;Static Request Header
SRHEAD	STRUC
REQLEN	DB	?		;Length in bytes of request block
REQUNIT DB	?		;Device unit number
REQFUNC DB	?		;Type of request
REQSTAT DW	?		;Status Word
	DB	8 DUP(?)	;Reserved for queue links
SRHEAD	ENDS

;Status word masks
STERR	EQU	8000H		;Bit 15 - Error
STBUI	EQU	0200H		;Bit 9 - Buisy
STDON	EQU	0100H		;Bit 8 - Done
STECODE EQU	00FFH		;Error code

;Function codes
DEVINIT EQU	0		;Initialization
DINITHL EQU	26		;Size of init header
DEVMDCH EQU	1		;Media check
DMEDHL	EQU	15		;Size of media check header
DEVBPB	EQU	2		;Get BPB
DEVRDIOCTL EQU	3		;IOCTL read
DBPBHL	EQU	22		;Size of Get BPB header
DEVRD	EQU	4		;Read
DRDWRHL EQU	22		;Size of RD/WR header
DEVRDND EQU	5		;Non destructive read no wait (character devs)
DRDNDHL EQU	14		;Size of non destructive read header
DEVIST	EQU	6		;Input status
DSTATHL EQU	13		;Size of status header
DEVIFL	EQU	7		;Input flush
DFLSHL	EQU	15		;Size of flush header
DEVWRT	EQU	8		;Write
DEVWRTV EQU	9		;Write with verify
DEVOST	EQU	10		;Output status
DEVOFL	EQU	11		;Output flush
DEVWRIOCTL EQU	12		;IOCTL write
DEVOPN	EQU	13		;Device open
DEVCLS	EQU	14		;Device close
DOPCLHL EQU	13		;Size of OPEN/CLOSE header
DEVRMD	EQU	15		;Removable media
REMHL	EQU	13		;Size of Removable media header

DevOUT	EQU	16			; output until busy.
DevOutL EQU	DevWrt			; length of output until busy

SUBTTL

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\ramdrive\emm.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
BREAK	<EMM control sector layout>

;
; The EMM control sector is a 1024 byte record which ALWAYS occupies the
; very first 1024 bytes of "extra" memory that needs to be managed. Its
; function is to provide a method to allocate available "extra" memory
; to programs which desire to use it and avoid program conflicts that
; would occur if two different programs attempted to use the same piece
; of "extra" memory.
;

;
; The EMM_CTRL structure defines the offsets into the 1024 byte control
; sector of the various fields. The EMM_REC structure defines a sub-structure
; contained within the EMM_CTRL structure which represents a particular
; piece of allocated "extra" memory (an allocation record).
;

; Layout of each EMM record.

EMM_REC 	STRUC
EMM_FLAGS	DW	0
EMM_SYSTEM	DW	0
EMM_BASE	DD	?		; 24 bit address of start of region
EMM_KSIZE	DW	?		; Size of region in kbytes
EMM_REC 	ENDS

; EMM_FLAGS Bits
EMM_ALLOC	EQU	0000000000000001B	; Zero -> record is free
EMM_ISDRIVER	EQU	0000000000000010B	; 1 -> driver is installed
						;      for this region

; EMM_SYSTEM Values
EMM_EMM 	EQU	0			; Allocated to EMM
EMM_MSDOS	EQU	1
EMM_XENIX	EQU	2
EMM_APPLICATION EQU	3

; Layout of EMM control 1024 byte record

EMM_CTRL	STRUC
EMM_VER 	DB	50 DUP(?)
EMM_TOTALK	DW	?		; EXCLUDING the 1k of this record
EMM_AVAILK	DW	?		; Amount of above NOT allocated
		DB	SIZE EMM_REC DUP(?) ; NULL (0th) RECORD
EMM_RECORD	DB	(1024 - 50 - 4 - 10 - (SIZE EMM_REC)) DUP(?)
					  ; EMM_REC structures
EMM_TAIL_SIG	DB	10 DUP(?)
EMM_CTRL	ENDS

EMM_NUMREC	EQU	(1024 - 50 - 4 - 10 - (SIZE EMM_REC)) / (SIZE EMM_REC)


;
; The current initial (no "extra" memory allocated) EMM_CTRL sector is
;
;  EMM_CONTROL	 LABEL	 BYTE
;		   DB	   "MICROSOFT EMM CTRL VERSION 1.00 CONTROL BLOCK     "
;		   DW	   EXTMEM_TOTALK - 1
;		   DW	   EXTMEM_TOTALK - 1
;	   ; NULL 0th record
;		   DW	   EMM_ALLOC + EMM_ISDRIVER
;		   DW	   EMM_EMM
;		   DW	   EXTMEM_LOW + 1024
;		   DW	   EXTMEM_HIGH
;		   DW	   0
;	   ;**
;		   DB	   950 DUP(0)
;		   DB	   "ARRARRARRA"
;
; Where EXTMEM_LOW:EXTMEM_HIGH is the 32 bit address of the first byte
; of the EMM_CTRL sector (first byte of "extra" memory) and EXTMEM_TOTALK
; is the size in K of the available "extra" memory. One is subtracted
; from EXTMEM_TOTALK because the sizes in the EMM_CTRL record DO NOT
; include the 1k taken up by the EMM_CTRL sector.
;
; The reason for the existance of the NULL 0th record is to facilitate
; the computation of EMM_BASE for the first EMM_REC allocation record
; created.
;
; The EMM_REC structures CANNOT be sparse. In other words if one sets
; up a scan of the EMM_REC structures in the EMM_CTRL sector, as soon as
; an EMM_REC structure WITHOUT the EMM_ALLOC bit set in its flag word
; is encountered it is not necessary to scan further because it IS KNOWN
; that all of the EMM_REC structures after the first one with EMM_ALLOC
; clear also have EMM_ALLOC clear. What this means is that EMM_CTRL
; memory CANNOT BE deallocated. Once an EMM_REC structure has its
; EMM_ALLOC bit set, there is NO correct program operation which
; can clear the bit UNLESS it IS KNOWN that the next EMM_REC structure
; has its EMM_ALLOC bit clear or the EMM_REC structure is the last one.
;
;
; USING THE EMM_CTRL SECTOR:
;
;    A program which wishes to use the EMM_CTRL sector to access "extra"
;    memory should work as follows:
;
;	Figure out how much memory you wish to allocate
;
;	Figure out the location and size of the "extra" memory in the system
;
;	IF (the first 1024 bytes of "extra" memory DO NOT contain a valid
;	 EMM_CTRL record determined by checking for the existence of the
;	 correct EMM_VER and EMM_TAIL_SIG strings)
;		Write a correct initial EMM_CTRL sector to the first 1024
;		 bytes of extra memory. Be sure to fill in EMM_TOTALK,
;		 EMM_AVAILK and EMM_BASE in the 0th record.
;
;	Set up a scan of the EMM_REC structures in the EMM_CTRL sector.
;	 NOTE: You can skip the NULL 0th record if you want since it has
;	       known value.
;
;	FOR (i=0;i<EMM_NUMREC;i++)
;		IF ( this EMM_REC has EMM_ALLOC clear)
;			IF ( EMM_AVAILK < amount I want to alloc)
;				ERROR insufficient memory
;			EMM_AVAILK = EMM_AVAILK - amount I want to alloc
;			EMM_FLAGS = EMM_ALLOC + EMM_ISDRIVER
;			EMM_KSIZE = amount I want to alloc
;			EMM_SYSTEM = appropriate value
;			EMM_BASE = EMM_BASE of PREVIOUS EMM_REC +
;				     (1024 * EMM_KSIZE of PREVIOUS EMM_REC)
;			break
;		ELSE
;			address next EMM_REC structure
;
;	IF (i >= EMM_NUMREC)
;		ERROR no free EMM_REC structures
;
;
; You can now see why we need that NUL 0th EMM_REC structure. In order to
; perform this step
;
;	EMM_BASE = EMM_BASE of PREVIOUS EMM_REC +
;		     (1024 * EMM_KSIZE of PREVIOUS EMM_REC)
;
; when the very first EMM_REC is allocated we must have a "previous EMM_REC"
; structure to point at.
;
; The above code is rather simplistic in that all it does is do a simple
; allocation. The EMM_ISDRIVER bit allows us to do some more sophisticated
; things. In particular in the case of a RAMDrive type of program it is
; desirable to "re-find" the same RAMDrive area in "extra" memory when the
; system is re-booted. The EMM_ISDRIVER bit is used to help us do this.
;
; The EMM_ISDRIVER bit means "there is presently a piece of code in the
; system which is using this memory". If we find an EMM_REC structure
; which has its EMM_ALLOC bit set, but the EMM_ISDRIVER bit is clear
; it means that the piece of code that originally allocated
; the memory is gone and we may want to "re-find" this memory by
; setting the EMM_ISDRIVER bit again. A RAMDrive program would have
; slightly different code than the above:
;
;	FOR (i=0;i<EMM_NUMREC;i++)
;		IF ( this EMM_REC has EMM_ALLOC clear)
;			IF ( EMM_AVAILK < amount I want to alloc)
;				ERROR insufficient memory
;			EMM_AVAILK = EMM_AVAILK - amount I want to alloc
;			EMM_FLAGS = EMM_ALLOC + EMM_ISDRIVER
;			EMM_KSIZE = amount I want to alloc
;			EMM_SYSTEM = appropriate value
;			EMM_BASE = EMM_BASE of PREVIOUS EMM_REC +
;				     (1024 * EMM_KSIZE of PREVIOUS EMM_REC)
;			break
;		ELSE
;			IF ((EMM_SYSTEM == my value for EMM_SYSTEM) &&
;			    (EMM_ISDRIVER is clear))
;				deal with differences between amount
;				 I want to allocate and EMM_KSIZE
;				Set EMM_ISDRIVER
;				EMM_BASE is the base address of this piece
;				 of memory and EMM_KSIZE is its size.
;				break
;			address next EMM_REC structure
;
; In this way we "re-find" memory that was previosly allocated (presumably
; by us, or a related program).
;
; NOTE THAT THIS USE OF EMM_ISDRIVER REQUIRES SOME MECHANISM FOR CLEARING
; EMM_ISDRIVER WHEN THE CODE OF INTEREST IS REMOVED FROM THE SYSTEM.
; In the case of a RAMDrive program the code is removed whenever the system
; is re-booted. For this reason a RAMDrive program will need code that is
; invoked whenever a system re-boot is detected. What this code does is
; scan the EMM_REC structures in the EMM_CTRL sector turning off the
; EMM_ISDRIVER bits:
;
;	FOR (i=0;i<EMM_NUMREC;i++)
;		IF ( this EMM_REC has EMM_ALLOC clear)
;			break
;		ELSE IF (EMM_SYSTEM == my value for EMM_SYSTEM)
;			clear EMM_ISDRIVER bit
;		address next EMM_REC
;
; Note that this code clears ALL of the ISDRIVER bits for EMM_SYSTEM
; values of a certain value. This means there is a GLOBAL piece of
; re-boot code for ALL of the programs using a particular EMM_SYSTEM
; value. An alternative is to have each EMM_CTRL user clear the
; EMM_ISDRIVER bits ONLY for those EMM_REC structures that it allocated.
; This requires that the program keep a record of which EMM_REC structures
; it is responsible for:
;
;	FOR each of my EMM_REC structures
;		INDEX this EMM_REC structure in the EMM_CTRL sector
;		Clear EMM_ISDRIVER
;
; NOTE about this step:
;
;	deal with differences between amount
;	 I want to allocate and EMM_KSIZE
;
; in the above code. There are a lot of options here depending on the desired
; behavior. If the NEXT EMM_REC structure has EMM_ALLOC clear, then it may
; be possible for me to grow or shrink the block I found by adjusting
; EMM_KSIZE and EMM_AVAILK. If the NEXT EMM_REC structure has EMM_ALLOC
; set, then I am forced to either adjust the amount I want to allocate
; to match EMM_KSIZE, or skip this EMM_REC without setting EMM_ISDRIVER.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; for rom 1nt15 extended memory interface
emm_int      equ    15h
emm_size     equ    88h
emm_blkm     equ    87h
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\ramdrive\ab_macro.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	MACRO definitions for expanded memory manager
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	1. MACRO to save mapping context in case somebody else has
;	   mapped the page registers.
;
save_mapping_context	macro
local	save_agn_m,save_err_m,save_ok_m,save_exit_m
;	
;	the save mapping call for the above board -->
;
;		mov	ah,47h
;		mov	dx,handle
;		int	67h
;
;	on return ax = 0 signifies success
;
;
	push	ax		; save registers
	push	dx
;
;	set up emm registers and execute call to save mapping context
;
save_agn_m:
	mov	dx,cs:[above_pid]		; get emm handle
	mov	ah,above_save_map_pid	; save map call
	int	67h			; call the manager
	or	ah,ah			; is there an error?
	jz	save_ok_m			; if not we are done
;
;	error in saving mapping context, check for error
;
	cmp	ah,above_error_busy	; if the emm manager was busy
	jz	save_agn_m		; we would like to try again
;
;	unrecoverable error, indicate error type in al
;
	pop	dx
	pop	dx			; pop the regs off the stack
;
	mov	al,02h			; drive not ready
	cmp	ah,above_error_cntxt_no_stack	;
	jz	save_err_m
	cmp	ah,above_error_second_save	;
	ja	save_err_m
	mov	al,0ch			; general failure
save_err_m:
	stc
	jmp	short save_exit_m
save_ok_m:
	clc
	pop	dx
	pop	ax			; restore registers
save_exit_m:
	endm
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	2. MACRO to restore the mapping context saved earlier
;
restore_mapping_context	macro
local	rest_agn_m, rest_ok_m, rest_exit_m
;
;	the restore above map call -->
;
;		mov	ah,48h
;		mov	dx,handle
;		int	67h
;	ah = 0 is success
;	
;
	push	ax
	pushf
;
rest_agn_m:
	mov	dx,cs:[above_pid]	; get emm handle
	mov	ah,above_restore_map_pid ; restore map call
	int	67h			; call manager
	or	ah,ah			; is there any error
	jz	rest_ok_m			; if not go to finish up
;
;	error condition, check for recoverable error
;
	cmp	ah,above_error_busy	; if manager was busy
	jz	rest_agn_m		; we sure can try again
	cmp	ah,above_error_no_cntxt	;
	jz	rest_ok_m			; ignore invalid pid error
;
;	unrecoverable error
;
	pop	dx
	pop	dx
	mov	al,0ch			; general failure
	stc
	jmp	short rest_exit_m
;
rest_ok_m:
	popf
	pop	ax
rest_exit_m:
;
	endm
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	3. MACRO to map a page in the physical page map onto a logical
;	   page.
;
;	the map above page requires
;		mov	ah,44h
;		mov	dx,handle
;		mov	al,physical_page# (0-3)
;		mov	bx,logical_page#
;		int	67H
;	ah = 0 success and this routine zaps ax,dx and bx
;
map_page	macro
local	map_agn_m,map_exit_m,map_fin_m
;
	mov	ah,above_map	; function map page
	mov	dx,cs:[above_pid]	; get emm handle
;
	push	ax
;
map_agn_m:
	pop	ax
	push	ax
	push	bx
	push	dx		; "damn call above_map zaps these registers"
;
	int	67h		; map call
	pop	dx
	pop	bx
;
	or	ah,ah		; is there an error?
	jz	map_fin_m		; if not go to finish up
;
;	error condition - check for recoverable error
;
	cmp	ah,above_error_busy	; if manager was busy
	jz	map_agn_m			; we sure can try again
;
;	unrecoverable error
;	
	pop	ax
	mov	al,02h			; device not ready error
	stc
	jmp	short map_exit_m
;
;	exit point
;
map_fin_m:
	clc
	pop	ax
map_exit_m:
;
	endm
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;			OTHER MACROS
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	1) MACRO to switch es:di with ds:si
;
src_dest_switch	macro	
;
	push	ds
	push	es
	push	si
	mov	si,di
	pop	di
	pop	ds
	pop	es
;
	endm
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\ramdrive\above.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
BREAK	<ABOVE BOARD Equates>

;
; Assorted equates for use with Intel Above Board
;

;
; EMM INT 67H Function codes
;
ABOVE_STATUS		EQU	40H
ABOVE_GET_SEG		EQU	41H
ABOVE_GET_FREE		EQU	42H
ABOVE_ALLOC		EQU	43H
ABOVE_MAP		EQU	44H
ABOVE_DEALLOC		EQU	45H
ABOVE_GET_VERSION	EQU	46H
ABOVE_SAVE_MAP_PID	EQU	47H
ABOVE_RESTORE_MAP_PID	EQU	48H

;
; NEW call not implemented in version 1.00 Above Board
;
ABOVE_GETSET_MAP	EQU	4EH
;
; 4EH AX equates for subfunctions
;
ABOVE_GETSET_GET	EQU	4E00H
ABOVE_GETSET_SET	EQU	4E01H
ABOVE_GETSET_GETSET	EQU	4E02H


;
; "Maintenance" calls
;
;;ABOVE_GET_IOPORT	EQU	49H	; reserved after EMS 3.2
;;ABOVE_GET_MAP_ARRAY	EQU	4AH	; reserved after EMS 3.2
ABOVE_GET_PIDS		EQU	4BH
ABOVE_GET_PAGES 	EQU	4CH
ABOVE_GET_ALLOC 	EQU	4DH
ABOVE_REALLOCATE_PID	EQU	51H

ABOVE_GET_ADDR_MAP	EQU	5800H	; get addresses of mappable pages


;
; EMM INT 67H AH return values
;
ABOVE_SUCCESSFUL	    EQU     0
ABOVE_ERROR_SOFTWARE	    EQU     80H
ABOVE_ERROR_HARDWARE	    EQU     81H
ABOVE_ERROR_BUSY	    EQU     82H
ABOVE_ERROR_BAD_PID	    EQU     83H
ABOVE_ERROR_BAD_FUNC	    EQU     84H
ABOVE_ERROR_OUT_OF_PIDS     EQU     85H
ABOVE_ERROR_MAP_CNTXT	    EQU     86H
ABOVE_ERROR_INSUFF_MEM	    EQU     87H
ABOVE_ERROR_INSUFF_FREE     EQU     88H
ABOVE_ERROR_ALLOC_ZERO	    EQU     89H
ABOVE_ERROR_LOG_INVALID     EQU     8AH
ABOVE_ERROR_PHYS_INVALID    EQU     8BH
ABOVE_ERROR_CNTXT_NO_STACK  EQU     8CH
ABOVE_ERROR_SECOND_SAVE     EQU     8DH
ABOVE_ERROR_NO_CNTXT	    EQU     8EH
ABOVE_ERROR_BAD_PARM	    EQU     8FH

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\ramdrive\xmm.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;******************************************************************************
;
;   Title:    EMM386 - MICROSOFT Expanded Memory Manager 386
;
;   Module:   XMM.INC - Definitions for extended memory manger (XMM)
;
;   Version:  0.02
;
;   Date:     Feb. 15, 1989
;
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   02/15/89  Original
;   02/19/89  pc	add other struct and equ
;   11/06/89  davidols  change useage note for error bit
;
;******************************************************************************

XMM_MULTIPLEX		equ	43h	; XMM multiplex number of INT 2Fh
XMM_INSTALL_CHECK	equ	00h	; install check call
XMM_FUNCTION_ADDR	equ	10h	; get control function address call
;
; XMM functions
;
XMM_GET_VERSION		equ	00h
XMM_REQUEST_HMA		equ	01h
XMM_RELEASE_HMA		equ	02h
XMM_GLOBAL_ENABLE_A20	equ	03h
XMM_GLOBAL_DISABLE_A20	equ	04h
XMM_LOCAL_ENABLE_A20	equ	05h
XMM_LOCAL_DISABLE_A20	equ	06h
XMM_QUERY_A20		equ	07h
XMM_QUERY_FREE_EXTMEM	equ	08h
XMM_ALLOC_EMB		equ	09h
XMM_FREE_EMB		equ	0Ah
XMM_MOVE_EMB		equ	0Bh
XMM_LOCK_EMB		equ	0Ch
XMM_UNLOCK_EMB		equ	0Dh
XMM_GET_EMB_INFO	equ	0Eh
XMM_REALLOC_EMB		equ	0Fh
XMM_REQUEST_UMB		equ	10h
XMM_RELEASE_UMB		equ	11h
;
; Valid error codes in BL have this bit set.
; But, only check BL if AX = 0.
;
XMM_ERROR_BIT		equ	80h

;
; struct pass to XMM_MOVE_EMB in DS:SI
;
ExtMemMoveStruct	struc
	mov_length	dd	?	; 32 bit number of bytes to transfer
	src_handle	dw	?	; handle of source block
	src_offset	dd	?	; 32 bit offset into source
	dst_handle	dw	?	; handle of destination block
	dst_offset	dd	?	; 32 bit offset into destination
ExtMemMoveStruct	ends

.list		; end of XMM.INC

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\ramdrive\syscall.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
BREAK <system call definitions>

Abort				EQU 0	;  0	  0
Std_Con_Input			EQU 1	;  1	  1
Std_Con_Output			EQU 2	;  2	  2
Std_Aux_Input			EQU 3	;  3	  3
Std_Aux_Output			EQU 4	;  4	  4
Std_Printer_Output		EQU 5	;  5	  5
Raw_Con_IO			EQU 6	;  6	  6
Raw_Con_Input			EQU 7	;  7	  7
Std_Con_Input_No_Echo		EQU 8	;  8	  8
Std_Con_String_Output		EQU 9	;  9	  9
Std_Con_String_Input		EQU 10	; 10	  A
Std_Con_Input_Status		EQU 11	; 11	  B
Std_Con_Input_Flush		EQU 12	; 12	  C
Disk_Reset			EQU 13	; 13	  D
Set_Default_Drive		EQU 14	; 14	  E
FCB_Open			EQU 15	; 15	  F
FCB_Close			EQU 16	; 16	 10
Dir_Search_First		EQU 17	; 17	 11
Dir_Search_Next 		EQU 18	; 18	 12
FCB_Delete			EQU 19	; 19	 13
FCB_Seq_Read			EQU 20	; 20	 14
FCB_Seq_Write			EQU 21	; 21	 15
FCB_Create			EQU 22	; 22	 16
FCB_Rename			EQU 23	; 23	 17
Get_Default_Drive		EQU 25	; 25	 19
Set_DMA 			EQU 26	; 26	 1A
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Get_Default_DPB 		EQU 31	; 31	 1F
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
FCB_Random_Read 		EQU 33	; 33	 21
FCB_Random_Write		EQU 34	; 34	 22
Get_FCB_File_Length		EQU 35	; 35	 23
Get_FCB_Position		EQU 36	; 36	 24
Set_Interrupt_Vector		EQU 37	; 37	 25
Create_Process_Data_Block	EQU 38	; 38	 26
FCB_Random_Read_Block		EQU 39	; 39	 27
FCB_Random_Write_Block		EQU 40	; 40	 28
Parse_File_Descriptor		EQU 41	; 41	 29
Get_Date			EQU 42	; 42	 2A
Set_Date			EQU 43	; 43	 2B
Get_Time			EQU 44	; 44	 2C
Set_Time			EQU 45	; 45	 2D
Set_Verify_On_Write		EQU 46	; 46	 2E
; Extended functionality group
Get_DMA 			EQU 47	; 47	 2F
Get_Version			EQU 48	; 48	 30
Keep_Process			EQU 49	; 49	 31
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Get_DPB 			EQU 50	; 50	 32
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
Set_CTRL_C_Trapping		EQU 51	; 51	 33
Get_InDOS_Flag			EQU 52	; 52	 34
Get_Interrupt_Vector		EQU 53	; 53	 35
Get_Drive_Freespace		EQU 54	; 54	 36
Char_Oper			EQU 55	; 55	 37
International			EQU 56	; 56	 38
;   Directory Group
MKDir				EQU 57	; 57	 39
RMDir				EQU 58	; 58	 3A
CHDir				EQU 59	; 59	 3B
;   File Group
Creat				EQU 60	; 60	 3C
Open				EQU 61	; 61	 3D
Close				EQU 62	; 62	 3E
Read				EQU 63	; 63	 3F
Write				EQU 64	; 64	 40
Unlink				EQU 65	; 65	 41
LSeek				EQU 66	; 66	 42
CHMod				EQU 67	; 67	 43
IOCtl				EQU 68	; 68	 44
XDup				EQU 69	; 69	 45
XDup2				EQU 70	; 70	 46
Current_Dir			EQU 71	; 71	 47
;    Memory Group
Alloc				EQU 72	; 72	 48
Dealloc 			EQU 73	; 73	 49
Setblock			EQU 74	; 74	 4A
;    Process Group
Exec				EQU 75	; 75	 4B
Exit				EQU 76	; 76	 4C
WaitProcedure			EQU 77	; 77	 4D
Find_First			EQU 78	; 78	 4E
;   Special Group
Find_Next			EQU 79	; 79	 4F
; SPECIAL SYSTEM GROUP
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Set_Current_PDB 		EQU 80	; 80	 50
Get_Current_PDB 		EQU 81	; 81	 51
Get_In_Vars			EQU 82	; 82	 52
SetDPB				EQU 83	; 83	 53
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
Get_Verify_On_Write		EQU 84	; 84	 54
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Dup_PDB 			EQU 85	; 85	 55
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
Rename				EQU 86	; 86	 56
File_Times			EQU 87	; 87	 57
AllocOper			EQU 88	; 88	 58
; Network extention system calls
GetExtendedError		EQU 89	; 89	 59
CreateTempFile			EQU 90	; 90	 5A
CreateNewFile			EQU 91	; 91	 5B
LockOper			EQU 92	; 92	 5C Lock and Unlock
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
					;	    CloseByName, CloseUser,
					;	    CloseUserProcess,
					;	    GetOpenFileList
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
UserOper			EQU 94	; 94	 5E Get and Set
AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
xNameTrans			EQU 96	; 96	 60
PathParse			EQU 97	; 97	 61
GetCurrentPSP			EQU 98	; 98	 62
Hongeul 			EQU 99	; 99	 63

Set_Oem_Handler 		EQU 248 ; 248	 F8
OEM_C1				EQU 249 ; 249	 F9
OEM_C2				EQU 250 ; 250	 FA
OEM_C3				EQU 251 ; 251	 FB
OEM_C4				EQU 252 ; 252	 FC
OEM_C5				EQU 253 ; 253	 FD
OEM_C6				EQU 254 ; 254	 FE
OEM_C7				EQU 255 ; 255	 FF

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\ramdrive\ramdrive.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
	TITLE	EXTENDED MEMORY RAMDRIVE

	PAGE	58,132
; ---------------------------------------------------------------------------
; NOTE:  Change volume creation date (see VOLID) for each new driver version.
; ---------------------------------------------------------------------------
;
; Will use XMS extended memory or
;      use Above Board on PC, XT, or AT or
;      use main memory on PC, XT, or AT
;
;
;	device = ramdrive.sys [bbbb] [ssss] [dddd] [/E | /A]
;
;		bbbb  First numeric argument, if present, is disk size
;			in K bytes. Default value is 64. Min is 4. Max
;			is 32767 (32M-1K). (M001, M002)
;
;		ssss  Second numeric argument, if present, is sector size
;			in bytes. Default value is 512. Allowed values are
;			128, 256, 512, 1024.
;		      NOTE: In the case of IBM PC DOS the MAX value is 512.
;			If 1024 is specified the device will not be installed.
;			This "error" is detected by DOS and is not due to
;			the code in RAMDrive.
;			The 1024 byte size is included for those MS-DOS systems
;			where it might be allowed.
;
;		dddd  Third numeric argument, if present, is the number of
;			root directory entries. Default is 64. Min is 2
;			max is 1024. The value is rounded up to the nearest
;			sector size boundary.
;		      NOTE: In the event that there is not enough memory
;			to create the RAMDrive volume, RAMDrive will try to make
;			a DOS volume with 16 directory entries. This may
;			result in a volume with a different number of directory
;			entries than the dddd parameter specifies.
;
;		/E    Specifies that XMS Extended Memory is to be used.
;			It is an error if /E is specified and an XMS driver
;			is not already installed.
;
;		/A    Specifies that Above Board memory is to be used. It
;			is an error if the above board device driver is not
;			present.
;		      NOTE: Information on RAMDrive drives in Above Board memory
;			will be lost at system re-boot (warm or cold). This is
;			due to the fact that the EMM device driver performs a
;			destructive test when it is installed which zeros all
;			of the Above Board memory.
;
;		Neither /A or /E Specifies drive is to be set up below the
;			640K boundary in main memory.
;		      The RAMDRIVE.SYS program looks for memory to assign to the RAMDrive
;			drives by looking for functioning system RAM between the
;			"end of memory" as determined by the INT 12H ROM BIOS
;			function, and the start of the video RAM (0A000:0H).
;                       [This method no longer attempted.]
;		      If RAM is found by the above scan, it is assigned to
;			RAMDrive and managed in the same way as extended memory
;			is when the /E switch is used. As with /E there is
;			1k of RAMDrive overhead. That is to say, if there are 256k
;			bytes of memory above the INT 12 memory size, there
;			will be 255k bytes available for assignment to RAMDrive
;			drives. This 1k overhead is fixed and does not depend
;			on the number of RAMDrive drives installed.
;			Information on such RAMDrive drives will NOT be lost on
;			a "warm boot" (INT 19H or Ctrl-Alt-DEL).
;                       [This method no longer attempted.]
;		      If RAM is NOT found by the above scan, RAMDrive will attempt
;			to allocate memory for the device AS PART OF THE DEVICE.
;			In other words the device starts immediately after the
;			RAMDrive resident code.
;			Information on such RAMDrive drives WILL BE lost on
;			a "warm boot" (INT 19H or Ctrl-Alt-DEL).
;
;
; MODIFICATION HISTORY
;
;	1.00	5/30/85 ARR Initial version.
;
;	1.01	6/03/85 ARR Added CSIZE home code in INIDRV. Does a better
;			    job of computing good CSIZE value.
;
;	1.10	6/05/85 ARR Changed name of program from VDISK to RAMDRIVE
;
;	1.11	6/06/85 ARR Changed BAD_AT message
;
;	1.12	6/06/85 ARR Fixed bug in /A BLKMOV code. Was forgetting
;			    to save and restore page mapping context
;
;	1.13	6/14/85 ARR Was using 32 bit shifts to do div/mul by
;			    powers of two. As it turns out, using the
;			    DIV or MUL instruction is faster. This is
;			    so even for small numbers like 16. This is
;			    due to the fact that the LOOP involved in
;			    doing a 32 bit shift is expensive.
;
;	1.14	6/14/85 ARR dddd param minimum changed from 4 to 2
;			    to be IBM compatible. Code added to round
;			    up to sector size boundaries.
;
;	1.15	6/24/85 ARR Assorted clean up, mostly in Above Board
;			    code.
;
;	1.16	7/09/85 ARR Align code more closely to the G.L.
;			    coding standard.
;
;			    Changed ITOA routine. Smaller and will print any
;			    16 bit value.
;
;			    DISK_ABORT would run through EMM_CTRL reset code
;			    on a RESMEM_SPECIAL driver. Added code
;			    to skip if this type of driver.
;
;			     Added check in CHECK_DOS_VOL in event valid BPB
;			     is found to make sure SSIZE and DIRNUM values
;			     match. If you edit DEVICE = to change these
;			     values on an existing drive and re-boot
;			     RAMDrive would ignore you and suck up old
;			     values.
;
;		11/12/85 ARR DEBUG EQU added and some RESMEM debug code
;			     stuck in to discover that the HP Vectra is
;			     not as AT compatible as HP thinks.
;
;		02/11/86 ARR Message area identified by "TRANSLATION"
;			     and translation notes added to several
;			     messages
;
;		04/03/86 ARR Changed use of SIDT to set GDT descriptor
;			     in /E init code to SGDT. Previous masm wouldn't
;			     assemble SGDT, new one works OK.
;
;	1.17	5/26/86  ARR New version for "above" insignificgant changes. And
;			     fixed major oops in /e RESET_SYSTEM code which would
;			     hang the system if an interrupt occured at the wrong
;			     time.
;
;	1.19	3/4/87	 SP  Fixed CSIZ homing oscillation bug. Shifted Ramdriv
;			     configuration display code before relocation code
;			     to facilitate creation of message module. Shifted
;			     translatable messages to message module.
;
;	2.00	8/23/87  sp  386 support ( both prot mode transfer and int15 )
;			     286 loadall kludge
;			     new int15 allocation
;			     new above_blkmov routine (to handle overlapping
;			     transfers in above board memory
;			     olivetti support
;			     removed int 9 trapping
;			     reset code different for extended memory
;
;	2.01	9/28/87  sp  Fixed bug in parsing for /u option
;
;	2.02	3/02/88  sp  Extended PS2 model 80 recognition to more than
;			     one sub-model
;	2.03	5/13/88  SP  extended version check to include dos 4.00
;
;	2.04	5/23/88  SP  reworked messages to mention expanded memory
;
;	2.10	6/13/88  CHIPA Merged in HP Vectra stuff
;		11/20/87 RCP Fixed a20 enabling/disabling problems on
;			     Vectra machines.
;
;	2.12	7/26/88  SP  Ramdrives installed between int12 and A000 are
;			     no longer attempted.
;
;	3.00	9/12/89  DBO Use XMS driver for extended memory (type 1
;			     driver).  Cut out most support for pre-XMS
;			     extended memory.  Also removed vestigial
;			     support for type 3 driver.
;			     Removed BAD_AT message.
;			     Removed INT 9, INT 15h support.
;			     Restricted INT 19h support to TYPE 2 driver.
;			     DOS version check accepts up to 4.10.
;		10/9/89  DBO DOS version check accepts up to 4.01.
;	3.00.02	10/13/89 DBO DOS version check accepts 4.x.
;
;	3.00 (debug 00)
;		12/21/89 DBO Removed /V (himem.sys version check).
;			     Hook XMS int 2f to ward off Windows/386 v2.x.
;	3.00 (debug 01)
;		12/22/89 DBO Accept DOS versions thru 5.x.
;	3.00 (debug 02)
;		1/4/90   DBO Change XMS hook to approved method, don't watch
;			      int 2F.
;	3.03	2/1/90	     Replace popf in XmmGuard to work around old
;			      80286 bug.
;			     Sense errors correctly in XMS block move.
;	3.04	2/4/90	     2M byte ramdisk screws up as file goes off
;			      end of disk and wraps around.  Is cluster
;			      # FF0 valid?  Changed initialization so
;			      maximum # clusters is 4096-18 instead of
;			      4096-10.
;	3.05	7/30/90  DBO M00:  Make sure EMS page frame really exists.
;       3.05    11/27/90 DB  M001: Extend max. RAMDrive size from 4M to 32M-1K.
;       3.05    12/14/90 DB  M002: Decrease min. RAMDrive size from 16K to 4K.
;                                  Versions >= Dos 5.X use memory limit
;                                  provided in INIT packet BREAK address,
;				   rather value returned by INT 12h.
;       3.05    08/21/91 EA  Updated Vol Creation Date for Windows 3.10 Setup, left same version.   

BREAK	MACRO	subtitle
	SUBTTL	subtitle
	PAGE
	ENDM

DEBUG	EQU	0		; enable/disable debug messages

	IF1
	IF DEBUG
	%out DEBUG VERSION!!!!!!
	ENDIF
	ENDIF

.xlist
	include devsym.inc
	include syscall.inc
	include dirent.inc
.list

; The RAMDrive device driver has 4 basic configurations.
;
;	TYPE 1 - /E configuration using XMS extended memory.
;
;	TYPE 2 - /A configuration using Above Board memory and EMM device
;		driver.
;
;	TYPE 3 - Neither /A or /E (RESMEM) configuration using main memory
;		and normal 8086 addressing, RAMDrive memory is located
;		somewhere AFTER the "end of memory" as indicated by the
;		INT 12H memory size.
;		[NOTE:  Type 3 configuration no longer attempted.]
;
;	TYPE 4 - RESMEM configuration as TYPE 3 EXCEPT that the RAMDrive
;		memory is part of the RAMDrive device driver.
;
; The TYPE 2 driver uses the Above Board EMM device driver via INT 67H
;    to control access to, and to access the available memory.
;
; The TYPE 4 driver needs no external help to control access to the available
;    memory since the RAMDrive memory is part of the device driver and
;    immediately follows the RAMDrive code in memory.
;
; The TYPE 1 configuration uses a resident XMS manager to
;    control access to the available memory

	include emm.inc

	include above.inc

	include ab_macro.inc
	
	include xmm.inc

BREAK	<I/O Packet offset declarations>

;
; Define I/O packet offsets for useful values.
;
; SEE ALSO
;	MS-DOS Technical Reference manual section on Installable Device Drivers
;

; READ/WRITE PACKET OFFSETS
RW_COUNT	EQU	WORD PTR (SIZE SRHEAD) + 5
RW_TRANS	EQU	DWORD PTR (SIZE SRHEAD) + 1
RW_START	EQU	WORD PTR (SIZE SRHEAD) + 7

; MEDIA CHECK PACKET OFFSETS
MCH_RETVAL	EQU	BYTE PTR (SIZE SRHEAD) + 1
MCH_MEDIA	EQU	BYTE PTR (SIZE SRHEAD) + 0

; BUILD BPB PACKET OFFSETS
BPB_BUFFER	EQU	DWORD PTR (SIZE SRHEAD) + 1
BPB_MEDIA	EQU	BYTE PTR (SIZE SRHEAD) + 0
BPB_BPB 	EQU	DWORD PTR (SIZE SRHEAD) + 5

; INIT PACKET OFFSETS
INIT_NUM	EQU	BYTE PTR (SIZE SRHEAD) + 0
INIT_BREAK	EQU	DWORD PTR (SIZE SRHEAD) + 1
INIT_BPB	EQU	DWORD PTR (SIZE SRHEAD) + 5
INIT_DOSDEV	EQU	BYTE PTR (SIZE SRHEAD) + 9


BREAK	<Device header>

RAMCODE SEGMENT
ASSUME	CS:RAMCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING

;**
;
;	RAMDRIVE DEVICE HEADER
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers
;
;	SEE ALSO
;	  MS-DOS Technical Reference manual section on
;	  Installable Device Drivers
;

RAMDEV	LABEL	WORD
	DW	-1,-1
DEVATS	DW	DEVOPCL
	DW	STRATEGY
	DW	RAM$IN
	DB	1			;1 RAMDRIVE


BREAK	<Command dispatch table>

;**
;
; This is the device driver command dispatch table.
;
; The first byte indicates the size of the table and therefore defines
; which device function codes are valid.
;
; The entries in the table are NEAR word addresses of the appropriate
; device routine. Thus the address of the routine to handle device function
; 3 is:
;	WORD at ((RAMTBL + 1) + (2 * 3))
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers
;
;

RAMTBL	LABEL	WORD
	DB	15			; Max allowed command code
	DW	RAM$INIT
	DW	MEDIA$CHK
	DW	GET$BPB
	DW	CMDERR
	DW	RAM$READ
	DW	DEVEXIT
	DW	DEVEXIT
	DW	DEVEXIT
	DW	RAM$WRIT
	DW	RAM$WRIT
	DW	DEVEXIT
	DW	DEVEXIT
	DW	DEVEXIT
	DW	DEVEXIT
	DW	DEVEXIT
	DW	RAM$REM


BREAK	<BPB and boot sector for installed device>

;**  RAMDRIVE BIOS PARAMETER BLOCK AND BOGUS BOOT SECTOR
;
;	This region is a valid DOS 2.X 3.X "boot sector" which contains
;	the BPB. This is used for signiture verification of a valid
;	RAMDrive as well as for storage of the relevant BPB parameters.
;
;	The BOOT_START code is a very simple stub which does nothing
;	except go into an infinite loop. THIS "CODE" SHOULD NEVER
;	BE EXECUTED BY ANYONE.
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers
;
;

BOOT_SECTOR	LABEL	BYTE
	JMP	BOOT_START	; WARNING- don't change to short jump!
	DB	"RDV 1.20"

RDRIVEBPB:
SSIZE	DW	512		; Physical sector size in bytes
CSIZE	DB	0		; Sectors/allocation unit
RESSEC	DW	1		; Reserved sectors for DOS
FATNUM	DB	1		; No. allocation tables
DIRNUM	DW	64		; Number directory entries
SECLIM	DW	0		; Number sectors
	DB	0F8H		; Media descriptor
FATSEC	DW	1		; Number of FAT sectors
	DW	1		; Number of sectors per track
	DW	1		; Number of heads
	DW	0		; Number of hidden sectors

SEC_SHFT DB	8		; Shifting number of
				;  sectors LEFT by this
				;  many bits yields #words
				;  in that many sectors.
				;  128	 6
				;  256	 7
				;  512	 8
				;  1024  9

BOOT_START:
	JMP	BOOT_START

BOOT_SIG	LABEL BYTE
	DB	(128 - (OFFSET BOOT_SIG - OFFSET BOOT_SECTOR)) DUP ("A")

;
; The following label is used to determine the size of the boot record
;		OFFSET BOOT_END - OFFSET BOOT_SECTOR
;
BOOT_END LABEL BYTE

BREAK	<Common Device code>

;	RAMDRIVE DEVICE ENTRY POINTS - STRATEGY, RAM$IN
;
;	This code is standard DOS device driver function dispatch
;	code. STRATEGY is the device driver strategy routine, RAM$IN
;	is the driver interrupt routine.
;
;	RAM$IN uses RAMTBL to dispatch to the appropriate handler
;	for each device function. It also does standard packet
;	unpacking.
;
;	SEE ALSO
;	  MS-DOS Technical Reference manual section on
;	  Installable Device Drivers
;

ASSUME	CS:RAMCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING

PTRSAV		DD	0		; Storage location for packet addr
XmmControl	dd	0		; interface to himem (XMS)
PrevXmm		dd	0		; previous installed XMS manager
ext_handle	dw	-1		; contains handle of ext. mem block
XmmMoveBuf	extmemmovestruct <>
reboot_flg	db	0		; true when reset code is being executed

;**	STRATEGY - Device strategy routine
;
;	Standard DOS 2.X 3.X device driver strategy routine. All it does
;	is save the packet address in PTRSAV.
;
;	ENTRY	ES:BX -> Device packet
;	EXIT	NONE
;	USES	NONE
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers
;
;

STRATP	PROC	FAR

STRATEGY:
	MOV	WORD PTR [PTRSAV],BX	; Save packet addr
	MOV	WORD PTR [PTRSAV+2],ES
	RET

STRATP	ENDP

;**	RAM$IN - Device interrupt routine
;
;	Standard DOS 2.X 3.X device driver interrupt routine.
;
;
;	ENTRY	PTRSAV has packet address saved by previous STRATEGY call.
;	EXIT	Dispatch to appropriate function handler
;			CX = Packet RW_COUNT
;			DX = Packet RW_START
;			ES:DI = Packet RW_TRANS
;			DS = RAMCODE
;			STACK has saved values of all regs but FLAGS
;		    All function handlers must return through one of
;			the standard exit points
;	USES	FLAGS
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers
;
;

RAM$IN:
	PUSH	SI
	PUSH	AX
	PUSH	CX
	PUSH	DX
	PUSH	DI
	PUSH	BP
	PUSH	DS
	PUSH	ES
	PUSH	BX

	LDS	BX,[PTRSAV]	       ;GET POINTER TO I/O PACKET
    ;
    ; Set up registers for READ or WRITE since this is the most common case
    ;
	MOV	CX,DS:[BX.RW_COUNT]	;CX = COUNT
	MOV	DX,DS:[BX.RW_START]	;DX = START SECTOR
	MOV	AL,DS:[BX.REQFUNC]	; Command code
	MOV	AH,BYTE PTR [RAMTBL]	; Valid range
	CMP	AL,AH
	JA	CMDERR			; Out of range command code
	MOV	SI,OFFSET RAMTBL + 1	; Table of routines
	CBW				; Make command code a word
	ADD	SI,AX			; Add it twice since one word in
	ADD	SI,AX			;  table per command.

	LES	DI,DS:[BX.RW_TRANS]	; ES:DI transfer address

	PUSH	CS
	POP	DS

ASSUME	DS:RAMCODE

	JMP	WORD PTR [SI]		; GO DO COMMAND

;**	EXIT - ALL ROUTINES RETURN THROUGH ONE OF THESE PATHS
;
;	Exit code entry points:
;
;	SEE ALSO
;	  MS-DOS Technical Reference manual section on
;	  Installable Device Drivers
;
;	GENERAL ENTRY for all entry points
;		All packet values appropriate to the specific device function
;		filled in except for the status word in the static request
;		header.
;
;	CMDERR - Used when an invalid device command is detected
;
;		ENTRY Stack has frame set up by RAM$IN
;		EXIT  Standard Device driver with error 3
;		USES  FLAGS
;
;	ERR$CNT - Used when READ or WRITE wants to return with error code.
;		   The packet RW_COUNT field is zeroed
;
;		ENTRY AL is error code for low byte of packet status word
;		      Stack has frame set up by RAM$IN
;		EXIT  Standard Device driver with error AL
;		USES  FLAGS
;
;	ERR$EXIT - Used when a function other that READ or WRITE wants to
;			return an error
;
;		ENTRY AL is error code for low byte of packet status word
;		      Stack has frame set up by RAM$IN
;		EXIT  Standard Device driver with error AL
;		USES  FLAGS
;
;	DEVEXIT - Used when a function wants to return with no error
;
;		ENTRY AL is value for low byte of packet status word
;		       NOTE: Typically there is no meaningful value
;			in the AL register when EXITing through here.
;			This is OK as the low 8 bits of the status word
;			have no meaning unless an error occured.
;		      Stack has frame set up by RAM$IN
;		EXIT  Standard Device driver with no error
;		USES  FLAGS
;
;	ERR1 - Used when a function wants to return with a value
;			for the whole status word
;
;		ENTRY AX is value for packet status word
;		      Stack has frame set up by RAM$IN
;		EXIT  Standard Device driver with or without error
;		USES  FLAGS
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers
;
;

ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

CMDERR:
	MOV	AL,3			;UNKNOWN COMMAND ERROR
	JMP	SHORT ERR$EXIT

ERR$CNT:
	LDS	BX,[PTRSAV]
	MOV	[BX.RW_COUNT],0 	; NO sectors transferred
ERR$EXIT:				; Error in AL
	MOV	AH,(STERR + STDON) SHR 8  ;MARK ERROR RETURN
	JMP	SHORT ERR1

EXITP	PROC	FAR

DEVEXIT:
	MOV    AH,STDON SHR 8
ERR1:
	LDS	BX,[PTRSAV]
	MOV	[BX.REQSTAT],AX 	; Set return status

	POP	BX
	POP	ES
	POP	DS
	POP	BP
	POP	DI
	POP	DX
	POP	CX
	POP	AX
	POP	SI
	RET				;RESTORE REGS AND RETURN
EXITP	ENDP


;**	MEDIA$CHK - Device Driver Media check routine
;
;	RAMDRIVE Media check routine. ALWAYS returns media not changed
;
;	SEE ALSO
;	  MS-DOS Technical Reference manual section on
;	  Installable Device Drivers
;
;	ENTRY from RAM$IN
;	EXIT through DEVEXIT
;	USES DS,BX
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers
;

MEDIA$CHK:
ASSUME	DS:RAMCODE,ES:NOTHING,SS:NOTHING
	LDS	BX,[PTRSAV]
ASSUME	DS:NOTHING
	MOV	[BX.MCH_RETVAL],1	; ALWAYS NOT CHANGED
	JMP	DEVEXIT

;**	GET$BPB - Device Driver Build BPB routine
;
;	RAMDRIVE Build BPB routine. Returns pointer to BPB at RDRIVEBPB
;
;	SEE ALSO
;	  MS-DOS Technical Reference manual section on
;	  Installable Device Drivers
;
;	ENTRY from RAM$IN
;	EXIT through DEVEXIT
;	USES DS,BX
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers
;

GET$BPB:
ASSUME	DS:RAMCODE,ES:NOTHING,SS:NOTHING
	LDS	BX,[PTRSAV]
ASSUME	DS:NOTHING
	MOV	WORD PTR [BX.BPB_BPB],OFFSET RDRIVEBPB
	MOV	WORD PTR [BX.BPB_BPB + 2],CS
	JMP	DEVEXIT

;**	RAM$REM - Device Driver Removable Media routine
;
;	RAMDRIVE Removable Media routine. ALWAYS returns media not removable
;	NOTE: This routine is never called if running on DOS 2.X
;
;	SEE ALSO
;	  MS-DOS Technical Reference manual section on
;	  Installable Device Drivers
;
;	ENTRY from RAM$IN
;	EXIT through ERR1
;	USES AX
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers
;

RAM$REM:
ASSUME	DS:RAMCODE,ES:NOTHING,SS:NOTHING
	MOV	AX,STBUI + STDON	; Media NOT removable
	JMP	ERR1

;**	RAM$READ - Device Driver READ routine
;
;	RAMDRIVE READ routine. Perform device READ by calling MEMIO
;
;	SEE ALSO
;	  MS-DOS Technical Reference manual section on
;	  Installable Device Drivers
;
;	DO_OP entry point used by RAM$WRITE
;
;	ENTRY from RAM$IN
;		ES:DI is transfer address
;		CX is sector transfer count
;		DX is start sector number
;	EXIT through DEVEXIT or ERR$CNT
;	USES ALL
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers
;

RAM$READ:
ASSUME	DS:RAMCODE,ES:NOTHING,SS:NOTHING
	XOR	BH,BH
DO_OP:
	CALL	MEMIO
	JC	T_ERR
	JMP	DEVEXIT

T_ERR:					; AL has error number
	JMP	ERR$CNT

;**	RAM$WRITE - Device Driver WRITE routine
;
;	RAMDRIVE WRITE routine. Perform device WRITE by calling MEMIO
;
;	SEE ALSO
;	  MS-DOS Technical Reference manual section on
;	  Installable Device Drivers
;
;	ENTRY from RAM$IN
;		ES:DI is transfer address
;		CX is sector transfer count
;		DX is start sector number
;	EXIT Jump to DO_OP to call MEMIO with BH = 1 (WRITE)
;	USES BH
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers
;

RAM$WRIT:
ASSUME	DS:RAMCODE,ES:NOTHING,SS:NOTHING
	MOV	BH,1
	JMP	DO_OP

;**	MEMIO - Perform READ or WRITE to RAMDrive
;
;	This routine performs common pre-amble code for the BLKMOV
;	routine which is the one which does the real work. It checks
;	the I/O parameters for validity and sets up the inputs to
;	BLKMOV. What it does is convert the sector count in CX to
;	the number of words in that many sectors or 8000H which ever
;	is less. It also converts the start sector number in DX into
;	a 32 bit byte offset equal to that many sectors.
;
;	NOTE that we convert the number of sectors to transfer
;	to a number of words to transfer.
;		Sector size is always a power of two, therefore a multiple
;			of two so there are no "half word" problems.
;		DOS NEVER asks for a transfer larger than 64K bytes except
;			in one case where we can ignore the extra anyway.
;
;	ENTRY:
;	    ES:DI is packet transfer address.
;	    CX is number of sectors to transfer.
;	    DX is starting sector number
;	    BH is 1 for WRITE, 0 for READ
;	EXIT:
;	    If error detected
;		Carry Set
;			Error on operation, AL is error number
;	    else
;		through BLKMOV
;		    ES:DI is packet transfer address.
;		    CX is number of words to transfer.
;		    DX:AX is 32 bit start byte offset (0 = sector 0 of RAMDrive drive)
;		    BH is 1 for WRITE, 0 for READ
;	USES:
;	    AX, DX, CX, FLAGS
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers
;

SEC_NOT_FOUND:
	MOV	AL,8			; Sector not found error
	STC
	RET

MEMIO:
ASSUME	DS:RAMCODE,ES:NOTHING,SS:NOTHING
	CMP	DX,[SECLIM]		; Check for valid I/O
	JAE	SEC_NOT_FOUND		; Start is beyond end
	MOV	AX,DX
	ADD	AX,CX
	CMP	AX,[SECLIM]
	JA	SEC_NOT_FOUND		; End is beyond end
    ;
    ; Convert sector count to word count
    ;
	MOV	AX,CX
	MOV	CL,[SEC_SHFT]
	SHL	AX,CL			; AX is # words to move
	JNC	CNT_SET 		; Overflow???
	MOV	AX,8000H		; Limit to 64K bytes
CNT_SET:
	MOV	CX,AX
    ;
    ; Now compute start offset of I/O
    ;
	MOV	AX,DX
	MUL	[SSIZE] 		; DX:AX is byte offset of start
	JMP	SHORT BLKMOV		; Perform I/O


BREAK	<Drive code for /E driver>

;
; The following label defines the start of the I/O code which is driver type
; specific.
;
; THE TYPE 2 driver must REPLACE this code with code appropriate
;	to the driver type.
;
		EVEN		; Force start of drive code to word boundary

DRIVE_CODE	LABEL	WORD

EXTMEM_LOW	EQU	0000H	; 24 bit addr of start of extended memory
EXTMEM_HIGH	EQU	0010H

;**	BASE_ADDR data element
;
; The next value defines the 24 bit address of the start of the memory for
;  the cache.
;
; NOTE THAT IT IS INITIALIZED TO THE START OF EXTENDED MEMORY.
;
; NOTE: This data element is shared by TYPE 1, 2 drivers, but
;	its meaning and correct initial value are driver type specific.
;	[Now set but NOT USED by TYPE 1 driver.]
;

BASE_ADDR	LABEL	DWORD	; 24 bit address of start of this RAMDRV
		DW	EXTMEM_LOW
		DW	EXTMEM_HIGH

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;**	BLKMOV - Perform transfer for TYPE 1 driver
;
;	ENTRY:
;	    ES:DI is packet transfer address.
;	    CX is number of words to transfer.
;	    DX:AX is 32 bit start byte offset (0 = start of cache)
;	    BH is 1 for WRITE, 0 for READ
;
;	EXIT:
;	    Carry Clear
;		    OK, operation performed successfully
;	    Carry Set
;		    Error during operation, AL is error number (INT 13 error)
;
;	USES:
;	    ALL
;
;	This routine is specific to TYPE 1 driver
;

BLKMOV:
ASSUME	DS:ramcode,ES:NOTHING,SS:NOTHING

;############################################################################
;[This is the XMS version, copied from Smartdrv.]
;
;	Function	:	blkmov
;	Inputs		:	es:di -> points to packet 
;				dx:ax -> points to cache 
;				cx - > no. of words to transfer
;				bh = 1 (WRITE) 0 (READ)		
;
;	Outputs		: 	If error CY flag is set
;				else move accomplished
;
;	Description:
;		Fills up the XmmMoveBuf structure with the correct 
; 	values supplied by the input parameters and calls the XMM Extended
;	Block Move function to perform the move. 
;
;	written: HKN 2/15/89
;
;############################################################################

;	int	3

	push	dx
	push	ax
	push	bx
	push	cx
	push	si
	
	mov	si, offset XmmMoveBuf	; cs:si points to buffer


; initialize length field

	shl	cx, 1			; cx = # of bytes to transfer
	mov	word ptr cs:[si.mov_length], cx
	mov	word ptr cs:[si.mov_length + 2], 0

	or	bh, bh
	jnz	xmm_cache_write


; initialize source handle 

	mov	bx, [ext_handle]
	mov	cs:[si.src_handle], bx

; initialize source offset 

	mov	word ptr cs:[si.src_offset], ax
	mov	word ptr cs:[si.src_offset + 2], dx


; initialize destination handle	and offset 

	mov	cs:[si.dst_handle], 0		; offset is Segment:Offset
	mov	word ptr cs:[si.dst_offset], di
	mov	word ptr cs:[si.dst_offset + 2], es

	jmp	short do_move

xmm_cache_write:
; initialize source handle and offset

	mov	cs:[si.src_handle], 0		; offset is Segment:Offset
	mov	word ptr cs:[si.src_offset], di
	mov	word ptr cs:[si.src_offset + 2], es

; initialize destination handle

	mov	bx, [ext_handle]
	mov	cs:[si.dst_handle], bx

; initialize destination offset

	mov	word ptr cs:[si.dst_offset], ax
	mov	word ptr cs:[si.dst_offset + 2], dx

; call XMM to move memory

do_move:
	mov	ah, XMM_MOVE_EMB	; move ext. mem. block function
	call	[XMMcontrol]

	shr	ax,1			; rotate 'success' bit into carry
	cmc				; make it a failure flag

	pop	si
	pop	cx
	pop	bx
	pop	ax
	pop	dx
	ret



;***	XmmGuard - XMM front for Windows/386 v2.x detection
;
;	This routine gets in front of the XMM control function, in
;	order to detect Windows/386 v2.x as it loads.  These versions
;	of Windows corrupt XMS memory.  When we spot the weird XMS
;	call that these versions of Windows make, we'll fail the
;	request, and Windows won't load.
;
;	The call that Windows makes:
;
;		AX = 0140h
;		DX = current total free XMS extended memory
;
;	If we spot these register values in an XMS call, we return
;
;		AX = 0		'HMA not assigned to caller'
;		BL = 91h	'HMA already in use'
;		other registers unchanged
;
;	Otherwise we pass the call on to the XMM.

AnIret:	iret			; used for popf workaround for 80286 bug

	assume	cs:RAMCODE,ds:NOTHING,es:NOTHING,ss:NOTHING

XmmGuard	proc	far

;	Supply a standard XMS control header (see XMS document).

	jmp	short XmmGuardEntry
	nop
	nop
	nop

XmmGuardEntry:
	pushf			; preserve flags register
	cmp	ax,0140h
	je	CouldBe		; could be Windows/386 v2.x
ToXmm:
	push	cs
	call	AnIret		; restore flags w/o popf (old 286 bug)
	jmp	PrevXmm		; xfr to previous installed XMS handler 

CouldBe:
	push	ax		; save caller's registers
	push	bx
	push	dx
	mov	ah,XMM_QUERY_FREE_EXTMEM
	call	XmmControl
	mov	ax,dx		; AX = total kbytes free extended memory
	pop	dx		; restore caller's DX
	cmp	ax,dx		; caller's DX = total free ext'd mem?
	pop	bx		; restore rest of caller's registers
	pop	ax
	jne	ToXmm		; DX doesn't match, it's not Win/386 v2.x

;*	It's Windows/386 v2.x.  Fail the Request HMA call.

	xor	ax,ax		; AX = 'HMA not assigned to caller'
	mov	bl,91h		; BL = 'HMA already in use'
	popf			; restore flags register
	ret

XmmGuard	endp




;	Toss in enough space for swapped-in code.

	db	250h dup (?)



;**	TRUE LOCATION OF ABOVE_PID
;
;	Define the TRUE (runtime TYPE 2 driver) location of ABOVE_PID.
;	This is the only piece of TYPE 2 specific data that we need
;	in the resident image. We must define it HERE rather than down
;	at ABOVE_BLKMOV so that we have its TRUE location after the
;	TYPE 2 code is swapped in at initialization. If we defined
;	it down at ABOVE_BLKMOV any instruction like:
;
;		MOV	DX,[ABOVE_PID]
;
;	Would have to be "fixed up" when we moved the ABOVE_BLKMOV
;	code into its final location.
;

ABOVE_PID	EQU	WORD PTR $ - 2		; TRUE location of ABOVE_PID

;
; The following label defines the end of the region where BLKMOV code
;   may be swapped in. BLKMOV code to be swapped in MUST fit
;   between DRIVE_CODE and DRIVE_END
;
DRIVE_END	LABEL	WORD


BREAK	<BPB POINTER ARRAY>

;**	BPB pointer array data
;
; BPB pointer array returned by INIT call. Must be part of resident image.
;
;	SEE ALSO
;	  MS-DOS Technical Reference manual section on
;	  Installable Device Drivers
;

INITAB	DW	RDRIVEBPB

;
; The following label defines the end of the RAMDrive resident code
;  for cases where no INT 9/19 code is included.
;
DEVICE_END	LABEL	BYTE

BREAK	<INT 19 Handler. Incl if /A>

;
; The drive TYPE dependant piece of code works as follows:
;
;	TYPE 2 DOES NOT use the EMM_CTRL sector but it still has
;		a handler. What this handler does is issue an
;		ABOVE_DEALLOC call to deallocate the Above Board
;		memory allocated to the RAMDrive. In current versions
;		of the EMM device driver this step is unnecessary
;		as the EMM device driver is thrown away together
;		with all of the allocation information when the system
;		is re-booted. We do it anyway because some future version
;		of the EMM device driver may be smarter and retain
;		allocation information through a warm-boot. Currently,
;		doing this doesn't hurt anything. Since this code cannot
;		do a global ABOVE_DEALLOC for all TYPE 2 drivers in the
;		system, it does an ABOVE_DEALLOC only for its memory
;		and EACH TYPE 2 driver in the system includes the INT 19/9
;		code.

;
; Storage locations for the "next" INT 19 vector, the one
;  that was in the interrupt table when the device driver was loaded.
;  It is initialized to -1 to indicate it contains no useful information.
;
OLD_19	LABEL	DWORD
	DW	-1
	DW	-1


;**	INT 19 Software re-boot handler
;
;	All this piece of code does is sit on INT 19 waiting for
;	a re-boot to be signaled by being called. It calls
;	RESET_SYSTEM to perform driver TYPE specific re-boot code,
;	resets the INT 19 and INT 9 vectors,
;	and then jumps to OLD_19 to pass on the event.
;
;	NOTE THAT UNLIKE INT 9 THIS HANDLER NEEDS TO RESET
;	THE INT 9 AND INT 19 VECTORS. This is because the INT 19
;	IBM ROM re-boot code DOES NOT reset these vectors, and we
;	don't want to leave them pointing to routines that are not
;	protected from getting stomped on by the re-boot.
;
;	SEE ALSO
;	    INT 19 IBM ROM code in ROM BIOS listing of
;	    IBM PC Technical Reference manual for any PC family member
;
;	ENTRY
;	    NONE
;	EXIT
;	    NONE, via OLD_19
;	USES
;	    FLAGS
;
;	THIS CODE IS USED BY TYPE 1,2 and 3 drivers.
;

INT_19:
ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING
	CALL	RESET_SYSTEM
	PUSH	AX
	PUSH	DS
	XOR	AX,AX
	MOV	DS,AX
    ;
    ; Since INT 19 DOES NOT reset any vectors (like INT 9 Ctrl Alt DEL does),
    ;	we must replace those vectors we have mucked with.
    ;
    ; NOTE THAT WE RESET VECTORS DIRECTLY!!!!!!!!!!!!!!!!!!
    ;	We are not sure that DOS is reliable enough to call.
    ;
	MOV	AX,WORD PTR [OLD_19]
	CLI
	MOV	WORD PTR DS:[19H * 4],AX
	MOV	AX,WORD PTR [OLD_19 + 2]
	MOV	WORD PTR DS:[(19H * 4) + 2],AX
	POP	DS
	POP	AX
	JMP	[OLD_19]

;**	RESET_SYSTEM perform TYPE 1 (/E) driver specific reboot code
;
;	NOTE: RESET_SYSTEM ALSO defines the start of ANOTHER piece of
;		driver TYPE specific code that TYPE 2, 3 and 4 drivers
;		will have to swap in a different piece of code for.
;
;	ENTRY
;	    NONE
;	EXIT
;	    NONE
;	USES
;	    NONE
;
; This code is specific to TYPE 1 drivers
;

RESET_SYSTEM:
ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING
;
;   Is this ever executed for TYPE 1 driver?
;
;   must leave space because other guys relocate
;   on top of this
;
	.286				; enable 80286 instructions

	pusha
	mov	cs:[reboot_flg], 0ffh
	mov	dx, [ext_handle]
	cmp	dx, -1
	je	reset_skip

	mov	ah, XMM_UNLOCK_EMB
	call	[XmmControl]
	mov	ah, XMM_FREE_EMB
	call	[XmmControl]

reset_skip:
	popa
	ret

	.8086				; disable 80286 instructions

;	Allow space for swapped-in code.

	db	30h dup (?)

;
; The following label performs two functions. It defines the end of the
; Driver TYPE specific RESET_SYSTEM code which will have to be replaced
; for different driver TYPEs as the code between RESET_SYSTEM and
; RESET_INCLUDE. Swapped in code MUST FIT between RESET_SYSTEM and
; RESET_INCLUDE. It also defines the end of the resident device driver
; code for a driver which wants to include the INT 19/ INT 9 code.
;
RESET_INCLUDE  LABEL   BYTE

BREAK	<COMMON INIT CODE>

;**	DISPOSABLE INIT DATA
;
; INIT data which need not be part of resident image
;

DRIVER_SEL	DB	2	; 0 if /E (TYPE 1), 1 if /A (TYPE 2),
				;    2 if resmem (TYPE 3 or 4)

DEV_SIZE	DW	64	; Size in K of this device

EXT_K		DW	?	; Size in K of Exteneded memory.

NUM_ARG 	DB	1	; Counter for order dependent numeric
				;    arguments	bbbb ssss dddd.

INIT_DRIVE	DB	1	; 0 means drive is inited
				; 1 means drive is to be inited
				;    MUST BE DEFAULT SETTING
				; 2 means drive is to be inited
				;   REGARDLESS of the existence of
				;   a valid DOS volume signature.

GOTSWITCH	DB	0	; 0 if no switch, NZ if switch seen

DIRSEC		DW	?	; Number of directory SECTORS

TERM_ADDR	LABEL	DWORD	; Address to return as break address in INIT packet
		DW	OFFSET DEVICE_END   ; INIT to NOT include INT 19 code
		DW	?		; RAMDrive CS filled in at INIT

TRUE_CS 	DW	?	; Used to store the "true" location of
				;   the driver when the relocation at
				;   RAMDrive_RELOC is performed.

DosVersion      DW      ?       ; M002: MS-DOS version # (high byte = Major,
				; low byte = Minor).

RESMEM_SPECIAL	DB	0	; 0 means NORMAL TYPE 3 RAMDrive
				; NZ means SPECIAL TYPE 4 RESMEM version
				;   see code at RAMDrive_RELOC

XmmControlBase	label	dword	; base address of XMM control headers
		dw	-1
		dw	-1

XmmControlJmpVal db	?	; offset byte of short jmp instruction

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;**	PRINT - Print a "$" terminated message on stdout
;
;	This routine prints "$" terminated messages on stdout.
;	It may be called with only the DX part of the DS:DX message
;	pointer set, the routine puts the correct value in DS to point
;	at the RAMDrive messages.
;
;	ENTRY:
;	     DX pointer to "$" terminated message (RAMCODE relative)
;	EXIT:
;	     NONE
;	USES:
;	     AX
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers
;

PRINT:
ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING
	PUSH	DS
	PUSH	CS
	POP	DS
	MOV	AH,Std_Con_String_Output
	INT	21H
	POP	DS
	RET

;**	ITOA - Print Decimal Integer on stdout
;
;	Print an unsigned 16 bit value as a decimal integer on stdout
;	with leading zero supression. Prints from 1 to 5 digits. Value
;	0 prints as "0".
;
;	Routine uses divide instruction and a recursive call. Maximum
;	recursion is four (five digit number) plus one word on stack
;	for each level.
;
;	ENTRY	AX has binary value to be printed
;	EXIT	NONE
;	USES	AX,CX,DX,FLAGS
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers
;

ITOA:
ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

	MOV	CX,10
	XOR	DX,DX
	DIV	CX			; DX is low digit, AX is higher digits
	OR	AX,AX
	JZ	PRINT_THIS_DIGIT	; No more higher digits
	PUSH	DX			; Save this digit
	CALL	ITOA			; Print higher digits first
	POP	DX			; Recover this digit
PRINT_THIS_DIGIT:
	ADD	DL,"0"			; Convert to ASCII
	MOV	AH,Std_CON_Output
	INT	21H
	RET


;**	RAM$INIT - Device Driver Initialization routine
;
;	RAMDRIVE Initialization routine. This is the COMMON initialization
;	code used by ALL driver TYPEs. Its jobs are to:
;
;	    1.	Initialize various global values
;	    2.	Check for correct DOS version and do changes to the device
;			based on the DOS version if needed.
;	    3.	Parse the command line and set values accordingly
;	    4.	Call a TYPE specific INIT routine based on the Parse
;			to set up a specific driver TYPE.
;	    5.	Initialize the DOS volume in the RAMDrive memory if appropriate
;	    6.	Print out report of RAMDrive parameters
;	    7.	Set the return INIT I/O packet values
;
;	The first two lines perform step 1. Step two starts after and
;	goes through VER_OK. Step 3 starts at VER_OK and goes through
;	ARGS_DONE. Step 4 starts at ARGS_DONE and goes through I001.
;	Step 5 starts at I001 and goes through DRIVE_SET. Step 6 starts
;	at DRIVE_SET and goes through SETBPB. Step 7 starts at SETBPB
;	and ends at the JMP DEVEXIT 10 lines later.
;
;	At any time during the above steps an error may be detected. When
;	this happens one of the error messages is printed and RAMDrive
;	"de-installs" itself by returning a unit count of 0 in the INIT
;	device I/O packet. The DOS device installation code is responsible
;	for taking care of the details of re-claiming the memory used by the
;	device driver. All RAMDrive needs to do is make sure any INT vectors
;	it changed (INT 19) get restored to what they were when RAMDrive
;	first started. A TYPE 1 driver must make sure any XMS memory it
;	allocated is deallocated and must unhook from the XMM control chain.
;	A TYPE 2 driver must ABOVE_DEALLOC any memory it allocated from the
;	EMM device. The duty of reclaiming XMS or Above Board memory,
;	re-setting vectors, and unhooking from the XMM control chain is done
;	by the DISK_ABORT routine which may be called by either this COMMON
;	INIT code, or the TYPE specific INIT code.
;
;	Step 1 initializes the segment part of TERM_ADDR to the correct
;	value for type 1, 2 and 3 drivers. A TYPE 4 driver will put a
;	different value in TERM_ADDR as it must include the space taken up
;	by the RAMDrive memory itself which is part of the device. TRUE_CS
;	is also initialized. This datum is relevant to the RESMEM_SPECIAL
;	(TYPE 4) driver which relocates the driver code at RAMDrive_RELOC.
;	This datum stores the CS of the REAL driver (the driver location
;	BEFORE the relocation took place).
;
;	Step 2 checks to make sure that we are running on a DOS in the
;	2.X or 3.X series which this driver is restricted to. If running
;	on a 2.X series the device header attribute word and device command
;	table are patched to exclude those device calls that don't exist
;	on DOS 2.X. The HEADERMES message is also patched to not include
;	the DOS drive letter part because 2.X DOS does not provide this
;	information to the device at INIT time.
;
;	Step 3 uses the "DEVICE = xxxxxxxxx" line pointer provided by
;	DOS to look for the various device parameters. NOTE: This pointer
;	IS NOT DOCUMENTED in the DOS 2.X tech ref material, but it does
;	exist in the same way as 3.X. This code is simple even though
;	it looks rather long. First it skips over the device name field
;	to get to the arguments. In then parses the arguments as they are
;	encountered. All parameter errors are detected here. NOTE THAT
;	THIS ROUTINE IS NOT RESPONSIBLE FOR SETTING DEFAULT VALUES OF
;	PARAMETER VARIABLES. This is accomplished by static initialization
;	of the parameter variables.
;
;	Step 4 calls a device TYPE specific initialization routine based
;	on the parse in step 3 (presence or absense of /E and /A switches).
;	NOTE THAT THERE IS ONE ROUTINE FOR TYPE 3 AND 4 DRIVERS. It is up
;	to this routine itself to make the distinction between TYPE 3 and
;	TYPE 4. NOTE that one of the prime jobs of these device TYPE specific
;	routines is to set all of the variables that are needed by Step
;	5 and 7 that haven't been set by the COMMON init code:
;
;			DEV_SIZE   set to TRUE size of device
;			BASE_ADDR  set to TRUE start of device so MEMIO
;					can be called
;			TERM_ADDR  set to correct end of device
;			INIT_DRIVE set to indicate if DOS volume needs to
;					be set up
;			RESMEM_SPECIAL set if TYPE 4 driver
;
;	Step 5 looks at the INIT_DRIVE variable to see if the DOS volume
;	needs to be initialized. The only time we do not need to INITialize
;	the DOS volume is when the driver TYPE specific INIT code finds
;	that there is a VALID DOS volume in the RAMDrive memory it just
;	set up. If the DOS volume does not need to be initialized, we
;	go on to step 6. Otherwise the device BPB must be set, the
;	RESERVED (boot) sector, FAT sectors, and root directory sectors
;	must be initialized and written out to the RAMDrive. The first step
;	is to initialize all of the BPB values. The code is a typical piece
;	of MS-DOS code which given BYTES/SECTOR, TOTAL DISK SIZE
;	and NUMBER OF ROOT DIRECTORY ENTRIES inputs figures out reasonable
;	values for SEC/CLUSTER and SECTORS/FAT and TOTAL NUMBER OF CLUSTERS.
;	NOTE THAT THIS CODE IS TUNED AND SPECIFIC TO 12 BIT FATS. Don't
;	expect it to work AT ALL with a 16 bit FAT. The next step is to write
;	out the BOOT record containing the BPB to sector 0, write out
;	a FAT with all of the clusters free, and write out a root directory
;	with ONE entry (the Volume ID at VOLID). Take CAREFUL note of the
;	special code and comments at RAMDrive_RELOC.
;
;	Step 6 makes the status report display of DEVICE SIZE, SECTOR SIZE,
;	CLUSTER SIZE, and DIRECTORY SIZE by simply printing out the values
;	from the BPB.
;
;	Step 7 sets the INIT I/O packet return values for # of units,
;	Break address, and BPB array pointer and returns via DEVEXIT.
;
;	SEE ALSO
;	  MS-DOS Technical Reference manual section on
;	  Installable Device Drivers
;
;	ENTRY from RAM$IN
;	EXIT Through DEVEXIT
;	USES ALL
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers
;

RAM$INIT:
ASSUME	DS:RAMCODE,ES:NOTHING,SS:NOTHING

    ;
    ; 1.  Initialize various global values
    ;
	MOV	WORD PTR [TERM_ADDR + 2],CS
	MOV	[TRUE_CS],CS
    ;
    ; 2.  Check for correct DOS version and do changes to the device
    ;	     based on the DOS version if needed.
    ;
	CLD
	MOV	AH,GET_VERSION
	INT	21H
	XCHG	AH,AL
        MOV     DosVersion,AX           ; M002: Save MS-DOS version #.
	CMP	AX,(2 SHL 8) + 00
	JB	BADVER			; Below 2.00, BAD
	CMP	AX,(3 SHL 8) + 00
	JB	VER2X			; 2.X requires some patches
	CMP	AX,(7 SHL 8) + 00
	JB	VER_OK			; thru 6.x ok

BADVER:
	MOV	DX,OFFSET BADVERMES
	JMP	DEVABORT

VER2X:
	AND	[DEVATS],NOT DEVOPCL	    ; No such bit in 2.X
	MOV	BYTE PTR [RAMTBL],11	    ; Fewer functions too
	MOV	WORD PTR [PATCH2X],0A0DH    ; Don't know DOS drive
	MOV	BYTE PTR [PATCH2X + 2],"$"
VER_OK:
;
; 3.  Parse the command line and set values accordingly
;
	LDS	SI,[PTRSAV]
ASSUME	DS:NOTHING
	MOV	AL,[SI.INIT_DOSDEV] ; DOS drive letter
	ADD	CS:[DOS_DRV],AL     ; Need explicit over, this is a forward ref
	MOV	DX,OFFSET HEADERMES
	CALL	PRINT
	LDS	SI,[SI.INIT_BPB]    ; DS:SI points to config.sys
SKIPLP1:			    ; Skip leading delims to start of name
	LODSB
	CMP	AL," "
	JZ	SKIPLP1
	CMP	AL,9
	JZ	SKIPLP1
	CMP	AL,","
	JZ	SKIPLP1
	JMP	SHORT SKIPNM

ARGS_DONEJ:
	JMP	ARGS_DONE

SWITCHJ:
	JMP	SWITCH

SKIPLP2:			; Skip over device name
	LODSB
SKIPNM:
	CMP	AL,13
	JZ	ARGS_DONEJ
	CMP	AL,10
	JZ	ARGS_DONEJ
	CMP	AL," "
	JZ	FIRST_ARG
	CMP	AL,9
	JZ	FIRST_ARG
	CMP	AL,","
	JZ	FIRST_ARG
	CMP	AL,0		; Need this for 2.0 2.1
	JNZ	SKIPLP2
SCAN_LOOP:			; PROCESS arguments
	LODSB
FIRST_ARG:
	OR	AL,AL		; Need this for 2.0 2.1
	JZ	ARGS_DONEJ
	CMP	AL,13
	JZ	ARGS_DONEJ
	CMP	AL,10
	JZ	ARGS_DONEJ
	CMP	AL," "
	JZ	SCAN_LOOP
	CMP	AL,9
	JZ	SCAN_LOOP
	CMP	AL,","
	JZ	SCAN_LOOP
	CMP	AL,"/"
	JZ	SWITCHJ
	CMP	AL,"0"
	JB	BAD_PARMJ
	CMP	AL,"9"
	JA	BAD_PARMJ
	DEC	SI
	CALL	GETNUM
	CMP	[NUM_ARG],3
	JA	BAD_PARMJ		 ; Only 3 numeric arguments
	JZ	SET_DIR
	CMP	[NUM_ARG],2
	JZ	SET_SECTOR
SET_SIZE:
        CMP     BX,4                    ;M002: 4K minimum drive size.
	JB	BAD_PARMJ
	CMP	BX,32768		;M001: Drive size must be < 32M.
	JAE	BAD_PARMJ               ;M001
	MOV	[DEV_SIZE],BX
	JMP	SHORT NUM_DONE

;M001
;Currently, the drive size must be < 32Meg. The total sectors of the drive
;must be < 64K (16-bit #). This constrains the sector size as follows:
;
;       Sector size      Drive size     Shift factor
;       -----------      ----------     ------------
;         1024             < 32M            9
;          512             < 32M            8
;          256             < 16M            7
;          128             <  8M            6

SET_SECTOR:
        mov     [SSIZE],bx              ;Temporarily store input bytes/sect.
        mov     dx,[DEV_SIZE]		;Drive size has already been parsed.
	mov	al,6                    ;Shift factor = 6.

ss128:	cmp	bx,128                  ;Bytes/sect = 128?
	jne	ss256                   ; -no, jump.
	cmp	dx,8192                 ; -yes; drive size < 8M?
	jb	ssOK                    ;        -yes, jump.
	shl	bx,1                    ;        -no, adjust sector size.

ss256:	inc	al                      ;Shift factor = 7.
	cmp	bx,256                  ;Bytes/sect = 256?
	jne	ss512                   ; -no, jump.
	cmp	dx,16384                ; -yes; drive size < 16M?
	jb	ssOK                    ;        -yes, jump.
	shl	bx,1

ss512:	inc	al                      ;Shift factor = 8.
	cmp	bx,512                  ;Bytes/sect = 512?
	je	ssOK                    ; -yes, jump: 512 always OK.

ss1024:	inc	al                      ;Shift factor = 9.
	cmp	bx,1024                 ;Bytes/sect = 1024?
	jne	BAD_PARM                ; -no, jump: invalid input parameter.
                                        ; -yes: 1024 always OK.
ssOK:	mov	[SEC_SHFT],al
        cmp     bx,[SSIZE]              ;Sector adjusted?
        je      NUM_DONE                ; -no, jump.
	mov	[SSIZE],bx
        mov     dx,OFFSET SECT_ADJ
        call    PRINT              	;Notify user of sector adjustment.
	jmp	short NUM_DONE

BAD_PARMJ:
        jmp     short BAD_PARM
;M001


SET_DIR:
	CMP	BX,2
	JB	BAD_PARM
	CMP	BX,1024
	JA	BAD_PARM
    ;
    ; NOTE: Since DIRNUM is the 3rd numeric arg and SSIZE is the first,
    ;	    we know the desired sector size has been given.
    ;
	MOV	DI,[SSIZE]
	MOV	CL,5		; 32 bytes per dir ent
	SHR	DI,CL		; DI is number of dir ents in a sector
	MOV	AX,BX
	XOR	DX,DX
	DIV	DI		; Rem in DX is partial dir sector
	OR	DX,DX
	JZ	SET_DSZ 	; User specified groovy number
	SUB	DI,DX		; Figure how much user goofed by
	ADD	BX,DI		; Round UP by DI entries
SET_DSZ:
	MOV	[DIRNUM],BX
NUM_DONE:
	INC	[NUM_ARG]		; Next numeric argument
SCAN_LOOPJ:
	JMP	SCAN_LOOP

BAD_PARM:
	MOV	DX,OFFSET ERRMSG1
DEVABORT:
	CALL	PRINT
DEVABORT_NOMES:
	XOR	AX,AX			;Indicate no devices
	JMP	SETBPB			;and return

SWITCH:
	MOV	AL,0FFH
	XCHG	AL,[GOTSWITCH]		; Switch already?
	OR	AL,AL
	JNZ	BAD_PARM		; Yes, only one allowed
	LODSB
	CMP	AL,"E"
	JZ	EXT_SET
	CMP	AL,"e"
	JNZ	ABOVE_TEST
EXT_SET:
	MOV	[DRIVER_SEL],0
	JMP	SCAN_LOOP

ABOVE_TEST:
	CMP	AL,"A"
	JZ	ABOVE_SET
	CMP	AL,"a"
	JNZ	BAD_PARM
ABOVE_SET:
	MOV	[DRIVER_SEL],1
	JMP	SCAN_LOOP

ARGS_DONE:
;
; 4.  Call a TYPE specific INIT routine based on the Parse
;	 to set up a specific driver TYPE.
;
	PUSH	CS
	POP	DS
ASSUME	DS:RAMCODE
	MOV	AL,[DRIVER_SEL] 	; Find out which init to call
	OR	AL,AL
	JNZ	NEXTV
	CALL	EXT_INIT
	JMP	SHORT INI_RET

NEXTV:
	DEC	AL
	JNZ	DORESM
	CALL	ABOVE_INIT
	JMP	SHORT INI_RET

DORESM:
	CALL	RESMEM_INIT
INI_RET:
	JNC	I001
	JMP	DEVABORT_NOMES

I001:
;
; 5.  Initialize the DOS volume in the RAMDrive memory if appropriate
;
	CMP	[INIT_DRIVE],0
	JNZ	INIDRV			; Need to initialize drive
	JMP	DRIVE_SET		; All set to go

INIDRV:
;
; We must figure out what to do.
; All values are set so we can call MEMIO to read and write disk
; SSIZE is user sector size in bytes
; DIRNUM is user directory entries
; DEV_SIZE is size of device in K bytes
;
    ; Figure out total number of sectors in logical image
	MOV	AX,[DEV_SIZE]
	MOV	CX,1024
	MUL	CX		; DX:AX is size in bytes of image
	DIV	[SSIZE] 	; AX is total sectors
				; Any remainder in DX is ignored
	MOV	[SECLIM],AX
    ; Compute # of directory sectors
	MOV	AX,[DIRNUM]
	MOV	CL,5		; Mult by 32 bytes per entry
	SHL	AX,CL		; Don't need to worry about overflow, # ents
				;     is at most 1024
	XOR	DX,DX
	DIV	[SSIZE]
	OR	DX,DX
	JZ	NOINC
	INC	AX
NOINC:				; AX is # sectors for root dir
	MOV	[DIRSEC],AX
	ADD	AX,2		; One reserved, At least one FAT sector
	CMP	AX,[SECLIM]
	JB	OK001		; we're OK
	MOV	[DIRNUM],16	; Smallest reasonable number
	XOR	DX,DX
	MOV	AX,512		; 16*32 = 512 bytes for dir
	DIV	[SSIZE]
	OR	DX,DX
	JZ	NOINC2
	INC	AX
NOINC2: 			; AX is # sectors for root dir
	MOV	[DIRSEC],AX
	ADD	AX,2		; One reserved, At least one FAT sector
	CMP	AX,[SECLIM]
	JB	OK001		; 16 directory sectors got us to OK
	CALL	DISK_ABORT	; Barf
	MOV	DX,OFFSET ERRMSG2
	JMP	DEVABORT

OK001:
	mov	si,64		; set a loop bound for the homing process
				; to avoid oscillation in homing
CLUSHOME:
    ; Figure a reasonable cluster size
	MOV	AX,[SECLIM]	; AX is total sectors on disk
	SUB	AX,[RESSEC]	; Sub off reserved sectors
	MOV	CL,[FATNUM]	; CX is number of FATs
	XOR	CH,CH
FATSUB:
	SUB	AX,[FATSEC]	; Sub off FAT sectors
	LOOP	FATSUB
	SUB	AX,[DIRSEC]	; Sub off directory sectors, AX is # data sectors

;	BUGBUG
;	Note:  The following four instances of "4096-18" were
;	"4096-10".  I've changed to this because DOS was freaked
;	out by a 2M byte drive with 64 directory entries and
;	1 sector per cluster.  Note that the last cluster # for
;	such a drive is FF0.  I've seen it stated that FF0-FF6
;	are used for "reserved" clusters.  I'm going to force
;	a 2M byte ramdisk to use 2 sectors per cluster.  It seems
;	to fix the bug, and it may even be correct.  -davidols, 2/90

	MOV	BX,1		; Start at 1 sec per alloc unit
	CMP	AX,4096-18
	JB	CSET		; 1 sector per cluster is OK
	MOV	BX,2
	CMP	AX,(4096-18) * 2
	JB	CSET		; 2 sector per cluster is OK
	MOV	BX,4
	CMP	AX,(4096-18) * 4
	JB	CSET		; 4 sector per cluster is OK
	MOV	BX,8
	CMP	AX,(4096-18) * 8
	JB	CSET		; 8 sector per cluster is OK
	MOV	BX,16
;M001
	CMP	AX,(4096-18) * 16
	JB	CSET		; 16 sector per cluster is OK
	MOV	BX,32		; 32 sector per cluster is OK
;M001

CSET:
    ; Figure FAT size. AX is reasonable approx to number of DATA sectors
    ;  BX is reasonable sec/cluster
	XOR	DX,DX
	DIV	BX		; AX is total clusters, ignore remainder
				;  can't have a "partial" cluster
	MOV	CX,AX
	SHR	CX,1
	JNC	ADDIT
	INC	CX
ADDIT:
	ADD	AX,CX		; AX is Bytes for fat (1.5 * # of clusters)
	ADD	AX,3		; Plus two reserved clusters
	XOR	DX,DX
	DIV	[SSIZE] 	; AX is # sectors for a FAT this size
	OR	DX,DX
	JZ	NOINC4
	INC	AX		; Round up
NOINC4: 			; AX is # sectors for FAT
	XCHG	AX,[FATSEC]	; Set newly computed value
	XCHG	BL,[CSIZE]	; Set newly computed value
	dec	si		; have we looped enough?
	jz	homfin		; yes, time to get out
	CMP	BL,[CSIZE]	; Did we compute a different size?
	JNZ	CLUSHOME	; Keep performing FATSEC and CSIZE computation
				;   until the values don't change.
	CMP	AX,[FATSEC]	; Did we compute a different size?
	JNZ	CLUSHOME	; Keep performing FATSEC and CSIZE computation
				;   until the values don't change.
HOMFIN:
    ;
    ; 6.  Print out report of RAMDrive parameters
    ;
	MOV	DX,OFFSET STATMES1
	CALL	PRINT
	MOV	AX,[DEV_SIZE]
	CALL	ITOA
	MOV	DX,OFFSET STATMES2
	CALL	PRINT
	MOV	AX,[SSIZE]
	CALL	ITOA
	MOV	DX,OFFSET STATMES3
	CALL	PRINT
	MOV	AL,[CSIZE]
	XOR	AH,AH
	CALL	ITOA
	MOV	DX,OFFSET STATMES4
	CALL	PRINT
	MOV	AX,[DIRNUM]
	CALL	ITOA
	MOV	DX,OFFSET STATMES5
	CALL	PRINT
	CMP	[RESMEM_SPECIAL],0
	JZ	NO_RELOC
    ;
    ; We are in a special case. The RAMDrive driver area starts at DEVICE_END.
    ;  If we left this INIT code where it is and executed it the act of
    ;  Initializing the boot sector, FAT, and root directory would overwrite
    ;  this INIT code as we are executing it. So what we do is COPY this
    ;  code into the DATA area of the RAMDrive and execute it from there.
    ;
RAMDrive_RELOC:
	MOV	AX,1			; AX is sec # of start of FAT
	ADD	AX,[FATSEC]		; AX is sec # of start of directory
	ADD	AX,[DIRSEC]		; AX is sec # of start of DATA
	MUL	[SSIZE] 		; DX:AX is byte offset of start of DATA
	ADD	AX,WORD PTR [BASE_ADDR]
	ADC	DX,WORD PTR [BASE_ADDR + 2] ; DX:AX is 32 addr of first byte of DATA
	ADD	AX,15			; PARA round up
	ADC	DX,0
	MOV	CX,16
	DIV	CX			; AX is Seg addr of DATA region
    ;
    ; At this point we need to do a little check. We need to make
    ;	sure the distance between where we are now, and where we
    ;	are relocating to is AT LEAST as much as we are moving
    ;	so that we don't modify ourselves while we're moving
    ;
	MOV	BX,AX
	MOV	DX,CS
	SUB	BX,DX			; BX is para between segs
	CMP	BX,((OFFSET RAMDrive_END - OFFSET RAMDEV) + 15) / 16 ; CMP to para moving
	JAE	OKMOV			; Distance is enough
	MOV	AX,CS			; Move far enough away
	ADD	AX,((OFFSET RAMDrive_END - OFFSET RAMDEV) + 15) / 16
OKMOV:
	MOV	ES,AX
	XOR	SI,SI
	MOV	DI,SI
	MOV	CX,OFFSET RAMDrive_END	   ; Amount to move
	CLD
	REP	MOVSB			; Reloc to data region
	PUSH	ES			; Push FAR return
	MOV	AX,OFFSET NO_RELOC
	PUSH	AX
	PUSH	ES
	POP	DS			; DS is NEW RAMCODE
RELOCR	PROC	FAR
	RET
RELOCR	ENDP

NO_RELOC:
	PUSH	CS
	POP	ES
	XOR	DX,DX		; Sector 0
	MOV	CX,1		; One sector
	MOV	DI,OFFSET BOOT_SECTOR	; Boot sector
	MOV	BH,1		; Write
	CALL	INIMEMIO
	INC	DX		; First FAT sector
	MOV	DI,OFFSET SECTOR_BUFFER
	XOR	AX,AX
	MOV	CX,512
	CLD
	REP	STOSW
	MOV	DI,OFFSET SECTOR_BUFFER
	MOV	CX,1
	MOV	WORD PTR ES:[DI],0FFF8H
	MOV	BYTE PTR ES:[DI + 2],0FFH
	CALL	INIMEMIO
	INC	DX		; Next sector
	MOV	WORD PTR ES:[DI],0
	MOV	BYTE PTR ES:[DI + 2],0
	MOV	CX,[FATSEC]
	DEC	CX
	JCXZ	FATDONE
FATZERO:
	PUSH	CX
	MOV	CX,1
	CALL	INIMEMIO
	INC	DX		; Next sector
	POP	CX
	LOOP	FATZERO
FATDONE:
	MOV	CX,1
	MOV	DI,OFFSET VOLID
	CALL	INIMEMIO	; FIRST directory sector
	INC	DX
	MOV	CX,[DIRSEC]
	DEC	CX
	JCXZ	DRIVE_SET
	MOV	DI,OFFSET SECTOR_BUFFER
DIRZERO:
	PUSH	CX
	MOV	CX,1
	CALL	INIMEMIO
	INC	DX		; Next sector
	POP	CX
	LOOP	DIRZERO
;
DRIVE_SET:
;
;	BPB IS NOW ALL SET
;
	MOV	AL,1			;Number of ramdrives
;
;	NOTE FALL THROUGH!!!!!!!
;

;**	SETBPB - Set INIT packet I/O return values
;
;	This entry is used in ERROR situations to return
;	a unit count of 0 by jumping here with AL = 0.
;	The successful code path falls through to here
;	with AL = 1
;
;	ENTRY
;	    AL = INIT packet unit count
;	EXIT
;	    through DEVEXIT
;	USES
;	    DS, BX, CX
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers
;

SETBPB:
ASSUME	DS:NOTHING
    ;
    ; 7.  Set the return INIT I/O packet values
    ;
	LDS	BX,[PTRSAV]
	MOV	[BX.INIT_NUM],AL
	MOV	CX,WORD PTR [TERM_ADDR]
	MOV	WORD PTR [BX.INIT_BREAK],CX		   ;SET BREAK ADDRESS
	MOV	CX,WORD PTR [TERM_ADDR + 2]
	MOV	WORD PTR [BX.INIT_BREAK + 2],CX
	MOV	WORD PTR [BX.INIT_BPB],OFFSET INITAB	   ;SET POINTER TO BPB ARRAY
	MOV	CX,[TRUE_CS]
	MOV	WORD PTR [BX.INIT_BPB + 2],CX
	JMP	DEVEXIT

;**	INIMEMIO call MEMIO but preserve registers
;
;	MEMIO is very register destructive, all this routine
;	does is provide a less destructive way to call MEMIO.
;
;	ENTRY
;	    Same as MEMIO
;	EXIT
;	    Same as MEMIO
;	USES
;	    AX, SI, BP
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers
;

INIMEMIO:
ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING
	PUSH	ES
	PUSH	DI
	PUSH	DS
	PUSH	CX
	PUSH	DX
	PUSH	BX
	CALL	MEMIO
	POP	BX
	POP	DX
	POP	CX
	POP	DS
	POP	DI
	POP	ES
	RET

;**	GETNUM - Read an unsigned integer
;
;	This routine looks at DS:SI for a decimal unsigned integer.
;	It is up to the caller to make sure DS:SI points to the start
;	of a number. If it is called without DS:SI pointing to a valid
;	decimal digit the routine will return 0. Any non decimal digit
;	defines the end of the number and SI is advanced over the
;	digits which composed the number. Leading "0"s are OK.
;
;	THIS ROUTINE DOES NOT CHECK FOR NUMBERS LARGER THAN WILL FIT
;	IN 16 BITS. If it is passed a pointer to a number larger than
;	16 bits it will return the low 16 bits of the number.
;
;	This routine uses the MUL instruction to multiply the running
;	number by 10 (initial value is 0) and add the numeric value
;	of the current digit. Any overflow on the MUL or ADD is ignored.
;
;	ENTRY:
;	     DS:SI -> ASCII text of number
;	EXIT:
;	     BX is binary for number
;	     SI advanced to point to char after number
;	USES:
;	     AX,BX,DX,SI
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers
;

GETNUM:
ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

	XOR	BX,BX
GETNUM1:
	LODSB
	SUB	AL,"0"
	JB	NUMRET
	CMP	AL,9
	JA	NUMRET
	CBW
	XCHG	AX,BX
	MOV	DX,10
	MUL	DX
	ADD	BX,AX
	JMP	GETNUM1

NUMRET:
	DEC	SI
	RET


BREAK	<RAMDrive COMMON INIT ROUTINES>

;**	DISK_ABORT - De-install RAMDrive after init
;
;	This routine MUST BE CALLED to de-install a RAMDrive driver
;	if the de-installation takes place:
;
;		AFTER the INT 19 vector is replaced for TYPE 2
;		AFTER ABOVE_PID is valid for TYPE 2
;		AFTER XMS memory has been allocated for TYPE 1
;
;	NOTE: Since a TYPE 4 driver does NONE of the above things it is
;		not necessary to call this routine, but the routine is
;		designed so that it is OK to call for a TYPE 4 driver.
;
;	In all cases the INT 19 vector is replaced if the
;	value of both words of OLD_19 is NOT -1. This is why the initial value
;	of this datum is -1. In the event that the INT 19 vector
;	is replaced, this datum takes on some value other than -1.
;
;	If this is a TYPE 1 driver and we have allocated XMS memory
;	(true if ext_handle is NOT -1), the XMS memory block is deallocated.
;	Also, if we have hooked into the XMM control chain (true if the
;	doubleword at XmmControlBase is not -1), we unhook.
;
;	If this is a TYPE 2 driver, an ABOVE_DEALLOC call is made on
;	ABOVE_PID.
;
;	ENTRY:
;	    NONE
;
;	    ext_handle valid or -1 if TYPE 1
;	    ABOVE_PID valid if TYPE 2
;
;	EXIT:
;	    NONE
;	USES:
;	    ALL but DS
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers
;

DISK_ABORT:
ASSUME	DS:RAMCODE,ES:NOTHING,SS:NOTHING

	CMP	[DRIVER_SEL],1
	JNZ	NOT_ABOVE
AGAIN:
    ;
    ; TYPE 2, Deallocate the Above Board memory
    ;
	MOV	DX,[ABOVE_PID]
	MOV	AH,ABOVE_DEALLOC
	INT	67H
	CMP	AH,ABOVE_ERROR_BUSY
	JZ	AGAIN
	JMP	SHORT RET002

NOT_ABOVE:
	CMP	[RESMEM_SPECIAL],0
	JNZ	RET002				; No EMM_CTRL on TYPE 4
    ;
    ; TYPE 1, Deallocate XMS memory
    ;
	mov	dx, [ext_handle]
	cmp	dx, -1
	je	xmsdealloc_skip			; XMS memory not allocated

	mov	ah, XMM_UNLOCK_EMB
	call	[XmmControl]
	mov	ah, XMM_FREE_EMB
	call	[XmmControl]
xmsdealloc_skip:
    ;
    ; Remove ourselves from the XMM control chain if XmmControlBase
    ; is not -1.
    ;
    ; We assume that no one has hooked us, since we're still in driver
    ; initialization.
    ;
	cmp	word ptr XmmControlBase,-1
	jne	UnhookXmm
	cmp	word ptr XmmControlBase+2,-1
	je	Ret002			; we didn't hook- don't unhook
UnhookXmm:
	mov	al,0EBh			; AL = opcode for short jump
	mov	ah,XmmControlJmpVal	; AH = displacement for short jump
	les	bx,XmmControlBase	; ES:BX = ptr to previous XMM header
	mov	word ptr es:[bx],ax	; restore previous XMM's short jump
	mov	word ptr es:[bx+2],9090h;  followed by nop's
	mov	byte ptr es:[bx+4],90h

RET002:
    ;
    ; Reset INT 19 if OLD_19 is not -1
    ;
	PUSH	DS
	LDS	DX,[OLD_19]
ASSUME	DS:NOTHING
	MOV	AX,DS
	CMP	AX,-1
	JNZ	RESET_VECS
	CMP	AX,DX
	JZ	NO_VECS
RESET_VECS:
	MOV	AX,(Set_Interrupt_Vector SHL 8) OR 19H
	INT	21H
NO_VECS:
	POP	DS
	RET

;**	CTRL_IO - Read/Write the first 1024 bytes at BASE_ADDR
;
;	This routine is used at INIT time to read the first 1024
;	bytes at BASE_ADDR. If TYPE 1 or TYPE 3 and BASE_ADDR points
;	to the EMM_CTRL address (initial value), the EMM_CTRL sector
;	is read/written. If TYPE 1 or TYPE 3 and BASE_ADDR has been set
;	to the start of a RAMDrive, the first 1024 bytes of the DOS volume
;	are read/written. If TYPE 2 or TYPE 4, the first 1024 bytes of
;	the DOS volume are read/written. All this routine does is
;	set inputs to BLKMOV to transfer 1024 bytes at offset 0 to/from
;	SECTOR_BUFFER.
;
;	ENTRY:
;	     BH = 0 for READ, 1 for WRITE
;	EXIT:
;	     SECTOR_BUFFER filled in with 1024 bytes at BASE_ADDR
;	USES:
;	     ALL but DS
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers
;

CTRL_IO:
ASSUME	DS:RAMCODE,ES:NOTHING,SS:NOTHING
	XOR	DX,DX
	MOV	AX,DX		; Offset 0
	MOV	CX,512		; 1024 bytes
	PUSH	CS
	POP	ES
	MOV	DI,OFFSET SECTOR_BUFFER
	PUSH	DS
	CALL	BLKMOV		; Read in EMM_CTRL
	POP	DS
	RET


;**	CHECK_DOS_VOL  examine RAMDrive region for valid DOS volume.
;
;	This routine is used by TYPE 1, 2 and 3 drivers to check and see
;	if the RAMDrive memory contains a valid DOS volume (one that lived
;	through a re-boot). Its prime job is to set INIT_DRIVE to indicate
;	whether the DOS volume needs to be initialized.
;
;	First the first 1024 bytes of the drive are read in to SECTOR_BUFFER
;	Next we check for a match of the signature areas up at BOOT_SECTOR
;	  to see if this drive contains a VALID RAMDrive boot record.
;	IF the signatures are valid AND INIT_DRIVE != 2 (ignore valid signature)
;		We check to make sure that SSIZE and DIRNUM set by the user
;		match the values in the BPB we just found.
;		IF they match
;		    we set INIT_DRIVE to 0 (don't init)
;		    and transfer the BPB out of the boot sector on the drive
;		    (in SECTOR_BUFFER) into the BPB for this driver at
;		    RDRIVEBPB.
;		ELSE
;		    Leave INIT_DRIVE set to whatever it was on input (1 or 2)
;		    indicating that the drive must be INITed.
;	ELSE
;		Leave INIT_DRIVE set to whatever it was on input (1 or 2)
;		indicating that the drive must be INITed.
;
;	WARNING! This routine DOES NOT check to make sure that the size of
;		the device as indicated in the BPB transfered in if a valid
;		DOS volume is found is consistent with the actual size
;		of the memory allocated to the device (DEV_SIZE). It
;		is up to the caller to check this if so desired.
;
;	ENTRY:
;	    BASE_ADDR set to point at START of DOS device
;	    Except for TYPE 1, which uses ext_handle
;	EXIT:
;	    CARRY SET - error, message already printed
;	    CARRY CLEAR
;		INIT_DRIVE set
;		SECTOR_BUFFER contains first 1024 bytes of device
;	USES:
;	    All but DS
;
;	Used by TYPE 1, 2 and 3 drivers
;

CHECK_DOS_VOL:
ASSUME	DS:RAMCODE,ES:NOTHING,SS:NOTHING
	XOR	BH,BH		; READ
    ;
    ; NOTE: WE CANNOT CALL MEMIO, WE MUST STILL USE CTRL_IO because the BPB
    ;	 is not set up.
    ;
	CALL	CTRL_IO 	; Since BASE_ADDR is set, reads start of DEVICE
	MOV	DX,OFFSET INIT_IO_ERR
	JC	ERR_RET2
	PUSH	CS
	POP	ES
	MOV	DI,OFFSET SECTOR_BUFFER
	MOV	SI,OFFSET BOOT_SECTOR
	MOV	CX,OFFSET RDRIVEBPB - OFFSET BOOT_SECTOR
	CLD
	REPE	CMPSB
	JNZ	OK_RET		; No DOS device
	ADD	DI,OFFSET BOOT_START - OFFSET RDRIVEBPB
	ADD	SI,OFFSET BOOT_START - OFFSET RDRIVEBPB
	MOV	CX,OFFSET BOOT_END - OFFSET BOOT_START
	REPE	CMPSB
	JNZ	OK_RET		; No DOS device
	CMP	[INIT_DRIVE],2
	JZ	NOT_VALID		; Current value 2 means we CANNOT
					; assume this BPB is valid.
    ;
    ; Check to make sure found BPB has same SSIZE and DIRNUM values
    ;
	MOV	SI,OFFSET SECTOR_BUFFER + (OFFSET SSIZE - OFFSET BOOT_SECTOR)
	LODSW
	CMP	AX,[SSIZE]
	JNZ	NOT_VALID		; Sector size different than user request
	MOV	SI,OFFSET SECTOR_BUFFER + (OFFSET DIRNUM - OFFSET BOOT_SECTOR)
	LODSW
	CMP	AX,[DIRNUM]
	JNZ	NOT_VALID		; Sector size different than user request

	MOV	[INIT_DRIVE],0		; Found a DOS drive
	MOV	DI,OFFSET RDRIVEBPB
	MOV	SI,OFFSET SECTOR_BUFFER + (OFFSET RDRIVEBPB - OFFSET BOOT_SECTOR)
	MOV	CX,OFFSET BOOT_START - OFFSET RDRIVEBPB
	REP	MOVSB			; Set correct BPB
NOT_VALID:
OK_RET:
	CLC
	RET

ERR_RET2:
	CALL	PRINT
	STC
	RET

;**	SET_RESET - Set up INT 19/INT 9 vectors
;
;	This routine will do nothing if BX is non-zero
;	otherwise it will install the INT 19
;	code by saving the current INT 19
;	vector in OLD_19 (NOTE: the change in the value of OLD_19
;	to something other than -1 indicates that the vector has been
;	replaced), setting the vector to point to INT_19,
;	and adjusting TERM_ADDR to include the code as part of the resident
;	image.
;
;	ENTRY:
;	     BX is 0 if INT 19 code to be installed
;	EXIT:
;	     NONE
;	USES:
;	     None
;
;	COMMON TO TYPE 1, 2, 3, 4 drivers (?)
;

SET_RESET:
ASSUME	DS:RAMCODE,ES:NOTHING,SS:NOTHING
	OR	BX,BX
	JNZ	RET005
	PUSH	AX
	PUSH	DX
	PUSH	BX
	PUSH	ES
	MOV	AX,(Get_Interrupt_Vector SHL 8) OR 19H
	INT	21H
	MOV	WORD PTR [OLD_19],BX
	MOV	WORD PTR [OLD_19 + 2],ES
	MOV	DX,OFFSET INT_19
	MOV	AX,(Set_Interrupt_Vector SHL 8) OR 19H
	INT	21H
	MOV	WORD PTR [TERM_ADDR],OFFSET RESET_INCLUDE
	POP	ES
	POP	BX
	POP	DX
	POP	AX
RET005:
	RET


	page
;******************************************************************************
;	check_XMM: routine to check presence of XMM driver
;
;	ENTRY:	DS = INT13CODE
;	EXIT:	carry set if error occurred
;	USED:	none
;
;******************************************************************************
check_XMM	proc	near
		assume ds:RAMCODE, es:NOTHING, ss:NOTHING
;
; determine whether or not an XMM driver is installed
;
	push	ax
	mov	ax,XMM_MULTIPLEX SHL 8 + XMM_INSTALL_CHECK
	int	2Fh
	cmp	al,80h			; Q: installed
	jne	cXMM_no_driver		;   N: set error, quit
;
; get the XMM control functions entry point, save it, we
; need to call it later.
;
	push	es
	push	bx
	mov	ax,XMM_MULTIPLEX SHL 8 + XMM_FUNCTION_ADDR
	int	2Fh
;	push	ds
;	push	seg INT13CODE
;	pop	ds
	mov	word ptr [XMMcontrol], bx
	mov	word ptr [XMMcontrol+2],es
;	pop	ds
	pop	bx
	pop	es
	pop	ax
	clc
	ret				; done
;
; flag error : XMM driver not present
;
cXMM_no_driver:
	stc
	pop	ax
	ret

check_XMM	endp



BREAK	</E INIT Code>

;**	EXT_INIT - Perform /E (TYPE 1) specific initialization
;
;	This code does the drive TYPE specific initialization for TYPE 1
;	drivers.
;
;	Determine if XMS driver is installed.
;	If no XMS driver answers, cough politely and don't install.
;	Determine extended memory available.
;	If not enough memory is available, sniff and don't install.
;	Allocate extended memory via XMS driver.
;	Place ourselves in XMM control chain to watch for Windows/386 2.x.
;	If the previous control chain is invalid, flatulate and don't install.
;
;	ENTRY:
;	    Invokation line parameter values set.
;	EXIT:
;	    CARRY SET
;		Error, message already printed. Driver not installed.
;	    CARRY CLEAR
;		DEV_SIZE set to TRUE size
;		INIT_DRIVE set appropriatly
;		TERM_ADDR set to correct device end.
;		    RESET_SYSTEM code included if this is the first
;		    TYPE 1 RAMDrive in the system.
;
;	USES:
;	    ALL but DS
;
;	Code is specific to TYPE 1 driver
;

EXT_INIT:
ASSUME	DS:RAMCODE,ES:NOTHING,SS:NOTHING

	IF DEBUG
	JMP	SHORT DEBINIT
DEBINITMES DB	"Initializing /e version",13,10,"$"
DEBINIT:
	PUSH	DX
	PUSHF
	PUSH	AX
	MOV	DX,OFFSET DEBINITMES
	CALL	PRINT
	POP	AX
	POPF
	POP	DX
	ENDIF

;	XMM init code taken from smartdrv.asm (written by Harish?) --

;
;	Check for presence of XMM driver.
;
	call	check_xmm
	jnc	xmm_ok
	mov	dx, offset noxmm
	jmp	err_ret
xmm_ok:

;
;	Get extended memory in K size into AX
;

	mov	ah, XMM_QUERY_FREE_EXTMEM
	call	[XmmControl]

	or	ax, ax 			; is there any ext. memory?
	jnz	mem_avail		; yes.
	test	bl, XMM_ERROR_BIT	; error code returned?
	jz	no_mem_avail		; no.  no memory available
	mov	dx, offset errxmm	; yes.  problem from xmm
	jmp	err_ret

no_mem_avail:
	mov	dx, offset no_mem
	jmp	err_ret

mem_avail:
	mov	dx, offset errmsg2
        cmp     ax, 4                   ; M002: available memory >= 4K?
	jnb	@F			;  -yes, jump.
	jmp	err_ret			;  -no, memory is below minimum.
@@:
	mov	[ext_k], ax
	cmp	[dev_size], ax		; is there enuff mem for cache?
	jbe	dev_size_ok		; yes.
	mov	[dev_size], ax		; no - limit dev_size to size available
dev_size_ok:


	mov	dx, [dev_size]		; dx = amt. of mem requested in K
	mov	ah, XMM_ALLOC_EMB	; allocate dx K of extended mem.
	call	[XmmControl]
	or	ax, ax
	jnz	alloc_ok
	mov	dx, offset errxmm
	jmp	short err_ret
alloc_ok:

;	dx has handle for extended memory block.

	mov	[ext_handle], dx

;	Get in XMM control chain to watch for Windows/386 v2.x.

	mov	bx,word ptr XmmControl
	mov	es,word ptr XmmControl+2  ; ES:BX = ptr to 1st XMM header
NextXmmHeader:
	mov	word ptr PrevXmm+2,es		; save seg of prev control adr
	mov	word ptr XmmControlBase+2,es
	mov	word ptr XmmControlBase,bx
	mov	cx,word ptr es:[bx]
	cmp	cl,0EBh				; compare short jmp opcode
	je	ShortJmp
	cmp	cl,0EAh				; compare far jmp opcode
	jne	XmmChainHosed			; bad XMM control chain
FarJmp:
	mov	si,word ptr es:[bx+1]		; SI = offset of jmp
	mov	es,word ptr es:[bx+1+2]		; ES = segment of jmp
	mov	bx,si
	jmp	NextXmmHeader			; continue down control chain
ShortJmp:
	cmp	word ptr es:[bx+2],9090h	; check NOPs
	jne	XmmChainHosed			; bad XMM control chain
	cmp	byte ptr es:[bx+4],90h
	jne	XmmChainHosed			; bad XMM control chain
	mov	di,bx				; DI = ptr to XMM header
	xor	ax,ax
	mov	al,ch				; AX = offset of short jmp
	mov	XmmControlJmpVal,al		; save offset of short jmp
	add	ax,2				; add length of jmp instr
	add	bx,ax				; BX = target of jmp
	mov	word ptr PrevXmm,bx		; save previous control addr

;	Install ourselves in XMM control chain.

	mov	byte ptr es:[di],0EAh		; far immediate jmp opcode
	mov	word ptr es:[di+1],offset XmmGuard
	mov	word ptr es:[di+3],cs

	jmp	short ext_init_done

XmmChainHosed:
	mov	dx,offset XmmChain	; DX = ptr to bad chain msg

err_ret:
	call	print
	stc

ext_init_done:
	ret



BREAK	</A INIT Code>

;**	EMM device driver name
;
;	The following datum defines the Above Board EMM 8 character
;	device driver name that is looked for as part of TYPE 2
;	specific initialization.
;
;	This datum is specific to TYPE 2 drivers
;

ABOVE_DEV_NAME	DB	"EMMXXXX0"

;**	ABOVE_INIT - Perform /A (TYPE 2) specific initialization
;
;	This code performes the driver specific initialization for
;	type 2 drivers.
;
;	Swap ABOVE_BLKMOV code in for TYPE 1 code at BLKMOV
;	Swap ABOVE_RESET code in for TYPE 1 code at RESET_SYSTEM
;	Check to make sure EMM Above Board device driver is installed
;		by looking for device name relative to INT 67H segment
;		address. This is method 2 described on page 36 and 37
;		of the Expanded Memory Manager Programming Specification.
;
;		WARNING! If run on a version of DOS where all INT vectors
;		are managed by the kernel, or on a system where some
;		foreign program (not EMM.SYS) is also using INT 67H, this
;		method will fail to find the EMM device driver.
;		The reason this method was used rather than the more portable
;		method 1 described on pages 33 and 34 of the EMM Programming
;		Specification is that the DOS Installable Device Driver
;		document makes a statement about which DOS system calls
;		may be made in a device initialization routine, and
;		OPEN, IOCTL, and CLOSE are not included in the allowed
;		set. Adherance to the Installable Device Driver document,
;		therefore, excludes the use of method 1.
;
;	Check the EMM device status
;	Make sure the page frame really exists.  The first four EMS 
;		physical pages must be contiguous.  (M00)
;	Get the EMM map window address and set BASE_ADDR
;	Get the available Above Board memory
;	Adjust DEV_SIZE to be consistent with the available memory if needed,
;		and also round DEV_SIZE up so that it is a multiple of the 16K
;		granularity of the Above Board memory.
;	Allocate DEV_SIZE worth of Above Board memory and set ABOVE_PID.
;		After this point we can use CTRL_IO and/or BLKMOV to
;		read/write the memory we have allocated.
;	Install the INT 9 and INT 19 code by calling SET_RESET with BX = 0.
;	Adjust the TERM_ADDR set by SET_RESET to a more appropriate size.
;	Call CHECK_DOS_VOL to look for a DOS volume and set INIT_DRIVE.
;	IF INIT_DRIVE indicates that a DOS volume was found
;		Check to make sure that the size of the found DOS
;		volume is consistent with DEV_SIZE.
;		IF it is not
;			Set INIT_DRIVE to 2 to indicate that the found volume
;				is invalid and needs to be re-initialized.
;
;	SEE ALSO
;	    INTEL Expanded Memory Manager Programming Specification
;
;	ENTRY:
;	    Invokation line parameter values set.
;	EXIT:
;	    ABOVE_BLKMOV code swapped in at BLKMOV
;	    ABOVE_RESET code swapped in at RESET_SYSTEM
;	    CARRY SET
;		Error, message already printed. Driver not installed.
;			No Above Board memory allocated.
;	    CARRY CLEAR
;		BASE_ADDR set to segment address of Above Board map window
;		ABOVE_PID contains PID of allocated above board memory
;		DEV_SIZE set to TRUE size
;		INIT_DRIVE set appropriatly
;		TERM_ADDR set to correct device end.
;		    RESET_SYSTEM code and INT 9/INT 19 code included.
;
;	USES:
;	    ALL but DS
;
;	Code is specific to TYPE 2 driver
;

ABOVE_INIT:
ASSUME	DS:RAMCODE,ES:NOTHING,SS:NOTHING
    ;
    ; Swap above code into place
    ;
	PUSH	CS
	POP	ES
	MOV	SI,OFFSET ABOVE_CODE
	MOV	DI,OFFSET DRIVE_CODE
	MOV	CX,OFFSET DRIVE_END - OFFSET DRIVE_CODE
	REP	MOVSB
	MOV	SI,OFFSET ABOVE_RESET
	MOV	DI,OFFSET RESET_SYSTEM
	MOV	CX,OFFSET RESET_INCLUDE - OFFSET RESET_SYSTEM
	REP	MOVSB
    ;
    ; Check for presence of Above board memory manager
    ;
	MOV	AX,(Get_Interrupt_Vector SHL 8) OR 67H
	INT	21H
	MOV	DI,SDEVNAME
	MOV	SI,OFFSET ABOVE_DEV_NAME
	MOV	CX,8
	REPE	CMPSB
	JZ	GOT_MANAGER
	MOV	DX,OFFSET NO_ABOVE
ABOVE_ERR:
	CALL	PRINT
	STC
	RET

GOT_MANAGER:
    ;
    ; Check memory status
    ;
	MOV	CX,8000H
STLOOP:
	MOV	AH,ABOVE_STATUS
	INT	67H
	CMP	AH,ABOVE_SUCCESSFUL
	JZ	CHECK_PAGEFRAME		;M00
	CMP	AH,ABOVE_ERROR_BUSY
	LOOPZ	STLOOP
ST_ERR:
	MOV	DX,OFFSET BAD_ABOVE
	JMP	ABOVE_ERR

;	BEGIN M00 CODE

CHECK_PAGEFRAME:
    ;
    ; Make sure page frame really exists
    ;
GET_EMSVER:
	MOV	AH,ABOVE_GET_VERSION
	INT	67H
	CMP	AH,ABOVE_ERROR_BUSY
	JZ	GET_EMSVER
	CMP	AH,ABOVE_SUCCESSFUL
	JNZ	ST_ERR
	CMP	AL,40H
	JB	MEM_OK			; version < 4.0, page frame is ok

GET_PAGEMAP:
    ;
    ; Get addresses of mappable pages
    ;
	MOV	AX,ABOVE_GET_ADDR_MAP
	PUSH	DS
	POP	ES
	MOV	DI,OFFSET SECTOR_BUFFER	; ES:DI = ptr to buffer
	MOV	SI,DI			; DS:SI = ptr to buffer, too
	INT	67H
	CMP	AH,ABOVE_SUCCESSFUL
	JNZ	ST_ERR
	CLD

SCAN_PAGEMAP:
    ;
    ; Look for page 0
    ;
	LODSW				; AX = page segment address
	LODSW				; AX = physical page number
	OR	AX,AX
	JZ	CHECK_CONTIG		; found page 0, check pages 0-3
	LOOP	SCAN_PAGEMAP		; keep looking

CHECK_CONTIG:
    ;
    ; Make sure pages 0-3 are contiguous
    ;
	MOV	DX,AX			; DX = page # = 0
	MOV	BX,[SI-4]		; BX = page 0 segment address
	MOV	CX,3			; CX = # pages to check

NEXT_CONTIG:
    ;
    ; Note page address array is in order by segment address
    ;
	INC	DX			; DX = next expected page #
	ADD	BX,0400H		; BX = next expected seg addr
	LODSW				; AX = next segment address
	CMP	AX,BX
	JNE	ST_ERR			; segment address not contiguous
	LODSW				; AX = next page #
	CMP	AX,DX
	JNE	ST_ERR			; page # not contiguous
	LOOP	NEXT_CONTIG		; check rest of page frame pages

;	END M00 CODE

MEM_OK:
    ;
    ; Get base address of map region and set BASE_ADDR
    ;
	MOV	AH,ABOVE_GET_SEG
	INT	67H
	CMP	AH,ABOVE_ERROR_BUSY
	JZ	MEM_OK
	CMP	AH,ABOVE_SUCCESSFUL
	JNZ	ST_ERR
	MOV	WORD PTR [BASE_ADDR],0
	MOV	WORD PTR [BASE_ADDR + 2],BX
    ;
    ; Allocate drive memory
    ;
GET_AVAIL:
	MOV	AH,ABOVE_GET_FREE
	INT	67H
	CMP	AH,ABOVE_ERROR_BUSY
	JZ	GET_AVAIL
	CMP	AH,ABOVE_SUCCESSFUL
	JNZ	ST_ERR
	MOV	AX,DX		; AX is total 16K pages
				; BX is un-allocated 16K pages
	MOV	DX,OFFSET NO_MEM
	OR	AX,AX
	JNZ	@F
	JMP	ABOVE_ERR
@@:	MOV	DX,OFFSET ERRMSG2
	OR	BX,BX		; 16k is min. (expanded mem.) Ramdrive
	JNZ	@F
	JMP	ABOVE_ERR
@@:	TEST	BX,0F000H
	JNZ	AB001		; Avialable K is REAL big
	MOV	CX,4
	SHL	BX,CL		; BX is un-allocated K
	CMP	[DEV_SIZE],BX
	JBE	AB001		; DEV_SIZE OK
	MOV	[DEV_SIZE],BX	; Limit DEV_SIZE to available
AB001:
	MOV	BX,[DEV_SIZE]

; M002 (updated comment only)
    ;
    ; BX = drive size (Kbytes) requested (adjusted to be no greater than
    ;      available expanded memory).
    ; The drive size is now rounded up to the next multiple of 16K (since the
    ; granularity of expanded memory is 16K).
    ;
	MOV	AX,BX
	MOV	CX,4		; Convert back to # of 16K pages
	SHR	BX,CL
	TEST	AX,0FH		; Even????
	JZ	OKAYU		; Yes
	INC	BX		; Gotta round up
	PUSH	BX
	MOV	CX,4
	SHL	BX,CL
	MOV	[DEV_SIZE],BX	; Correct dev size too by rounding it up to
				;   next multiple of 16K, no sense wasting
				;   part of a page.
	POP	BX
OKAYU:
	MOV	AH,ABOVE_ALLOC
	INT	67H
	CMP	AH,ABOVE_ERROR_BUSY
	JZ	OKAYU
	CMP	AH,ABOVE_SUCCESSFUL
	JZ	GOT_ID
	CMP	AH,ABOVE_ERROR_MAP_CNTXT
	JZ	ST_ERRJ
	CMP	AH,ABOVE_ERROR_OUT_OF_PIDS
	JB	ST_ERRJ
	MOV	DX,OFFSET ERRMSG2
	JMP	ABOVE_ERR

ST_ERRJ:
	JMP	ST_ERR

GOT_ID:
	MOV	[ABOVE_PID],DX
    ;
    ; INSTALL ABOVE RESET handler
    ;
	XOR	BX,BX
	CALL	SET_RESET
    ;
    ; The above RESET_SYSTEM handler is real small, and since we include it in
    ;	EACH driver, we make sure the size is minimal
    ;
	MOV	WORD PTR [TERM_ADDR],OFFSET RESET_SYSTEM + (OFFSET ABOVE_RESET_END - OFFSET ABOVE_RESET)
    ;
    ; We are now in good shape. Can call BLKMOV to read drive
    ;
	CALL	CHECK_DOS_VOL		; Snoop for DOS volume
	JNC	DOUBLE_CHECK
	CALL	DISK_ABORT
	STC
	RET

DOUBLE_CHECK:
	CMP	[INIT_DRIVE],0
	JNZ	RETAB			; No DOS volume found
    ;
    ; We MUST check to see if the FOUND DOS volume is consistent
    ;	with DEV_SIZE.
    ;
	MOV	AX,[SECLIM]
	MUL	[SSIZE] 		; DX:AX is size of volume in bytes
	MOV	CX,1024
	DIV	CX			; AX is size in K
	CMP	AX,[DEV_SIZE]
	JE	RETAB			; Volume is OK
RE_INIT:
	MOV	[INIT_DRIVE],2		; Force re-compute of volume
RETAB:
	CLC
	RET

BREAK	<Drive code for /A driver. Swapped in at BLKMOV>

;
; This label defines the start of the code swapped in at DRIVE_CODE
;
ABOVE_CODE	LABEL	WORD

;
; WARNING DANGER!!!!!!!
;
; This code is tranfered over the /E driver code at DRIVE_CODE
;
; ALL jmps etc. must be IP relative.
; ALL data references must be to cells at the FINAL, TRUE location
;	(no data cells may be named HERE, must be named up at BLKMOV).
; OFFSET of ABOVE_BLKMOV relative to ABOVE_CODE MUST be the same as
;	the OFFSET of BLKMOV relative to DRIVE_CODE.
; SIZE of stuff between ABOVE_CODE and ABOVE_END MUST be less than
;	or equal to size of stuff between DRIVE_CODE and DRIVE_END.

IF2
  IF((OFFSET ABOVE_BLKMOV - OFFSET ABOVE_CODE) NE (OFFSET BLKMOV - OFFSET DRIVE_CODE))
	  %out ERROR BLKMOV, ABOVE_BLKMOV NOT ALIGNED
  ENDIF
  IF((OFFSET ABOVE_END - OFFSET ABOVE_CODE) GT (OFFSET DRIVE_END - OFFSET DRIVE_CODE))
	  %out ERROR ABOVE CODE TOO BIG
  ENDIF
ENDIF

		DD	?	; 24 bit address of start of this RAMDRV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;**	ABOVE_BLKMOV - Perform transfer for TYPE 2 driver
;
;	This routine is the transfer routine for moving bytes
;	to and from the Above Board memory containing the cache.
;
;	The Above Board is implemented as 4 16K windows into the Above
;	Board memory, giving a total window of 64K wich starts on some
;	16K boundary of the Above Board memory. Given that a DOS I/O
;	request is up to 64K bytes starting on some sector boundary,
;	the most general I/O picture is:
;
;	|------------|------------|------------|------------|------------|
;	| Above Brd  | Above Brd  | Above Brd  | Above Brd  | Above Brd  |
;	|Log page n  |Log page n+1|Log page n+2|log page n+3|Log page n+4|
;	|------------|------------|------------|------------|------------|
;	|---|---|					    |	    |
;	|   |	|---------------- 64K bytes of sectors -------------|
;	   Byte |					    |	    |
;	  offset|------------------|------------------------|	    |
;	of first|	       Number of words in	    |	    |
;	byte of |	       first part of I/O that	    |---|---|
;	I/O in	|	       can be performed once	      Number
;	first	|	       logical pages n - n+3	      of words
;	Log page|	       are mapped into physical       in tail
;		|	       pages 0 - 3		      part of I/O
;	     Location of				      that have
;	     first byte 				      to be done
;	     of sector M,				      once logical
;	     the start sector				      page n+4 is
;	     of the I/O 				      mapped into
;							      physical page
;							      0
;
; One or both of "Byte offset of first byte of I/O in first page" and
; "Number of words in tail part of I/O" may be zero depending on the
; size of the I/O and its start offset in the first logical page it is
; possible to map.
;
; WARNING: IF A PRE-EMPTIVE MULTITASKING SYSTEM SCHEDULES A TASK WHICH
;	IS USING THE ABOVE BOARD DURING THE TIME THIS DRIVER IS IN THE
;	MIDDLE OF PERFORMING AN I/O, THE SYSTEM HAD BETTER MANAGE THE A
;	BOARD MAPPING CONTEXT CORRECTLY OR ALL SORTS OF STRANGE UNPLEASANT
;	THINGS WILL OCCUR.
;
;	SEE ALSO
;	    INTEL Expanded Memory Manager Programming Specification
;
;	ENTRY:
;	    ES:DI is packet transfer address.
;	    CX is number of words to transfer.
;	    DX:AX is 32 bit start byte offset (0 = start of cache)
;	    BH is 1 for WRITE, 0 for READ
;
;	    BASE_ADDR set to point to Above Board mapping window in main memory
;		This "input" is not the responsibility of the caller. It
;		is up to the initialization code to set it up when the
;		device is installed
;
;	EXIT:
;	    Carry Clear
;		    OK, operation performed successfully
;	    Carry Set
;		    Error during operation, AL is error number
;
;	USES:
;	    ALL
;
;	This routine is specific to TYPE 2 driver
;
;	sunilp - note that this has one limitation. in the case where
;		 one is using the above board for ramdrive and for
;		 the buffer then one is limited to 32k byte transfers
;
;	tonyg	- above limitation removed - now handles 64kb transfers
;		  which can overlap the page frame
;
above_blkmov:
assume ds:ramcode,es:nothing,ss:nothing
;
;	save mapping context and return with error if save fails
;
	save_mapping_context
	jnc	ab_blk$1
	ret
;
;	find logical page number, offset of i/o in first page
;
ab_blk$1:
	push	cx
	mov	cx,1024*16	; 16k bytes / page
	div	cx		; dx:ax / 16k --> log page numb in ax
				; 	      --> offset of i/o in dx
	mov	si,dx		; transfer offset to si
	mov	dx,ax		; store the page number in dx
	pop	cx
;
;	find case and dispatch accordingly
;
;	case 0 : user buffer below page map, can use aaron's code
;	case 1 : user buffer above page map, can use aaron's code
;	case 2 : user buffer partly/totally in page map, use pai's code
;
	push	bx
	push	cx
;
;	if( final_user_off < pm_base_addr ) then case 0
;
	mov	ax,di		; get user buffer initial offset into ax
	add	ax,1		; round up (add to get carry)
	rcr	ax,1		; convert to word offset
	dec	cx		; convert word count to 0 based number
	add	ax,cx		; user buffer final word offset
	shr	ax,1		; convert to segment
	shr	ax,1		;
	shr	ax,1		;
	mov	bx,es		; get segment of buffer
	add	ax,bx		; now we have the last segment of the user buffer
				; with offset < 16
	sub	ax,word ptr [base_addr+2] ; compare against page map
	jc	aar_cd		; if end below page map then execute old code
;
;	if( initial_user_off < pm_base_addr ) then case 2
;	
	mov	cx,4
	mov	bp,di		; get initial segment in bp
	shr	bp,cl		;
	add	bp,bx		;
	sub	bp,word ptr [base_addr +2]
	jc	within_pm	; case 2
;
;	if ( initial_user_off >= pm_end_addr ) then case1
;
	cmp	bp,4*1024	;
	jae	aar_cd		; case 1
;
;	case 2
;
within_pm:	jmp	new_code	; user buffer in page map
					; so we need to execute new code
aar_cd:
	pop	cx
	pop	bx
;	
; Referring back to the diagram given above the following routine is
; to take care of transfer of the most general case.
; What this routine does is break every I/O down into the above parts.
; The first or main part of the I/O is performed by mapping 1 to 4
; sequential logical pages into the 4 physical pages and executing one
; REP MOVSW. If the tail word count is non-zero then the fith sequential
; logical page is mapped into physical page 0 and another REP MOVSW is
; executed.
;
;	METHOD:
;	    Break I/O down as described above into main piece and tail piece
;	    Map the appropriate number of sequential pages (up to 4)
;	      into the page window at BASE_ADDR to set up the main piece
;	      of the I/O.
;	   Set appropriate seg and index registers and CX to perform the
;	      main piece of the I/O into the page window
;	   REP MOVSW
;	   IF there is a tail piece
;		Map the next logical page into physical page 0
;		Reset the appropriate index register to point at phsical page 0
;		Move tail piece word count into CX
;		REP MOVSW
;	   Restore Above Board page mapping context
;
	XOR	BP,BP		; No tail page
	PUSH	BX
    ;
    ; DX is first page #, SI is byte offset of start of I/O in first page
    ;
	MOV	AX,DX
	MOV	BX,SI
	SHR	BX,1		; # Words in first 16k page which are not part
				;	of I/O
	PUSH	CX
	ADD	BX,CX		; # of words we need to map to perform I/O
	MOV	DX,BX
	AND	DX,1FFFH	; DX is number of words to transfer last page
				;    remainder of div by words in 16K bytes
	MOV	CL,13		; Div by # words in 16K
	SHR	BX,CL		; BX is number of pages to map (may need round up)
	OR	DX,DX		; Remainder?
	JZ	NO_REM
	INC	BX		; Need one more page
NO_REM:
	MOV	CX,BX		; CX is total pages we need to map
	MOV	BX,AX		; BX is first logical page
	CMP	CX,4		; We can map up to 4 pages
	JBE	NO_TAIL
	MOV	BP,DX		; Words to move in tail page saved in BP
	DEC	CX		; Need second map for the 5th page
	POP	AX
	SUB	AX,DX		; Words to move in first 4 pages is input
				;   word count minus words in tail page
	PUSH	AX		; Count for first mapping back on stack
NO_TAIL:
    ; Map CX pages
	MOV	DX,[ABOVE_PID]
	MOV	AX,ABOVE_MAP SHL 8 ; Physical page 0
	PUSH	AX
MAP_NEXT:
	POP	AX		; Recover correct AX register
	PUSH	AX
	PUSH	BX
	PUSH	DX
	INT	67H		; Damn call ABOVE_MAP zaps BX,DX,AX
	POP	DX
	POP	BX
	OR	AH,AH
	JNZ	MAP_ERR1	; error
IF2
	IF (ABOVE_SUCCESSFUL)
		%out ASSUMPTION IN CODE THAT ABOVE_SUCCESSFUL = 0 IS INVALID
	ENDIF
ENDIF
NEXT_PAGE:
	INC	BX		; Next logical page
	POP	AX
	INC	AL		; Next physical page
	PUSH	AX
	LOOP	MAP_NEXT
	POP	AX		; Clean stack
	POP	CX		; Word count for first page mapping
	POP	AX		; Operation in AH
    ;
    ; BX has # of next logical page (Tail page if BP is non-zero)
    ; BP has # of words to move in tail page (0 if no tail)
    ; CX has # of words to move in current mapping
    ; SI is offset into current mapping of start of I/O
    ; AH indicates READ or WRITE
    ;
	PUSH	AX		; Save op for possible second I/O
	OR	AH,AH
	JZ	READ_A
    ;
    ; WRITE
    ;
	PUSH	ES
	PUSH	DI
	MOV	DI,SI		; Start page offset to DI
	POP	SI		; DS:SI is transfer addr
	POP	DS
ASSUME	DS:NOTHING
	MOV	ES,WORD PTR [BASE_ADDR + 2] ; ES:DI -> start
	JMP	SHORT FIRST_MOVE

READ_A:
ASSUME	DS:ramcode
	MOV	DS,WORD PTR [BASE_ADDR + 2]	; DS:SI -> start
ASSUME	DS:NOTHING
FIRST_MOVE:
	REP	MOVSW
	OR	BP,BP		; Tail?
	JNZ	TAIL_IO 	; Yup
ALL_DONE:
	POP	AX
	CLC
REST_CONT:
    ; Restore page mapping context
	PUSH	AX		; Save possible error code
	PUSHF			; And carry state
REST_AGN:
	MOV	DX,[ABOVE_PID]
	MOV	AH,ABOVE_RESTORE_MAP_PID
	INT	67H
	OR	AH,AH
	JZ	ROK
IF2
	IF (ABOVE_SUCCESSFUL)
		%out ASSUMPTION IN CODE THAT ABOVE_SUCCESSFUL = 0 IS INVALID
	ENDIF
ENDIF
	CMP	AH,ABOVE_ERROR_BUSY
	JZ	REST_AGN
	CMP	AH,ABOVE_ERROR_NO_CNTXT
	JZ	ROK		; Ignore the invalid PID error
	POP	DX
	POP	DX		; Clean stack
	MOV	AL,0cH	       ; General failure
	STC
	RET

ROK:
	POPF			; Recover carry state
	POP	AX		; and possible error code
	RET

TAIL_IO:
	MOV	DX,[ABOVE_PID]
MAP_AGN:
	MOV	AX,ABOVE_MAP SHL 8 ; map logical page BX to phys page 0
	PUSH	BX
	PUSH	DX
	INT	67H		; Damn call ABOVE_MAP zaps BX,DX,AX
	POP	DX
	POP	BX
	OR	AH,AH
	JNZ	MAP_ERR2	; Error
IF2
	IF (ABOVE_SUCCESSFUL)
		%out ASSUMPTION IN CODE THAT ABOVE_SUCCESSFUL = 0 IS INVALID
	ENDIF
ENDIF
SECOND_MOVE:
	POP	AX		; Recover Op type
	PUSH	AX
	OR	AH,AH
	JZ	READ_SEC
    ;
    ; WRITE
    ;
	XOR	DI,DI		; ES:DI -> start of tail
	JMP	SHORT SMOVE

READ_SEC:
	XOR	SI,SI		; DS:SI -> start of tail
SMOVE:
	MOV	CX,BP
	REP	MOVSW
	JMP	ALL_DONE

MAP_ERR1:
	CMP	AH,ABOVE_ERROR_BUSY ; Busy?
	JZ	MAP_NEXT	; Yes, wait till not busy (INTs are ON)
	ADD	SP,6		; Clean stack
	JMP	SHORT DNR_ERR

MAP_ERR2:
	CMP	AH,ABOVE_ERROR_BUSY
	JZ	MAP_AGN
	ADD	SP,2
DNR_ERR:
	MOV	AL,02H	       ; Drive not ready
	STC
	JMP	REST_CONT
;
;
;   this code has been written to handle te cases of overlapping usage
;   of the above board page frame segment by the cache and user buffer
;   assumption: in dos tracks cannot be more than 64 sectors long so
;   in the worst case we shall have the user buffer occupying three
;   pages is the page frame. we attempt to find the page that is
;   available for the cache and use it repeatedly to access the cache
;
;   above comment was for smartdrv. 128 sector reads are possible here
;   see the kludge in step 2 and step 4 to handle this


;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
;   the algorithm is:
;   ******************************************************
;   [STEP1: determine the page we can use for the cache]
;
;   if (initial_para_offset_user in page 1, 2 or 3 ) then  {
;	    physical_cache_page = 0;
;	    cache_segment	= above board segment;
;		}
;						      else  {
;	    physical_cache_page = 3;
;	    cache_segment	= above_board_segment + 3*1024;
;		}
;
;   ******************************************************
;   [STEP2: initial setup]
;
;   count = user_count_requested;
;   number_to_be_transferred = min ( count, (16K - si) >> 2 );
;   exchange source and destination if necessary;
;
;   *******************************************************
;   [STEP3: set up transfer and do it]
;
;   count = count - number_to_be_transferred;
;   map_page cache_handle,physical_cache_page,logical_cache_page
;   mov data
;
;   *******************************************************
;   [STEP4: determine if another transfer needed and setup if so]
;
;   if ( count == 0 ) then exit;
;   if ( operation == read ) then source_offset = 0;
;			     else dest_offset	= 0;
;   number_to_be_transferred = min ( count, 8*1024 );
;   logical_page_number++ ;
;
;   *******************************************************
;   [STEP5: go to do next block]
;
;   goto [STEP3]
;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
;
new_code:
	assume	ds:ramcode,es:nothing,ss:nothing
;
;	input parameters:
;
;	bp : start para offset of user buffer from start of physical page frame
;	ax : end para offset of user buffer in physical page frame
;	di : transfer offset of user buffer
;	es : transfer segment of user buffer
;	dx : logical page number in cache
;	si : offset from start in logical page number
;
;	on stack { cx,bx } where cx = number of words, bx = read / write status
;
;   [STEP1: finding physical cache page and page frame]
;
    ;
    ; assume is physical page 0
    ;
	xor	al, al		; use page 0 for cache
	mov	bx,word ptr [base_addr+2]
    ;
    ; see if this assumption valid
    ;
	cmp	bp, 4*1024	; base is below start of page frame
	jae	ab$300
	cmp	bp,1024 	; is initial in page 1 or above
	jae	ab$30		; if so or assumption is valid
    ;
    ; else we have to correct our assumption
    ;
ab$300:
	mov	al, 3		; use page 3 for cache
	add	bx, 3*1024	; segment of page 3
    ;
    ; initialise page frame segment
    ;
ab$30:
	add	bp, 2*1024	; base of second transfer
	mov	cx, bp
	mov	ds,bx
    ;
assume	ds:nothing
;
;   [STEP2: initialising transfer parameters]
;
    ;
	pop	bp		; bp will have count of words left to be transferred
	pop	bx		; read / write status
;
; kludged to handle 64k byte transfers
;
	push	cx		; base of second transfer
    ;
    ; initialise the number of words needed for a second transfer to 0
    ;
	xor	cx,cx		;
    ;
    ; compare the number to be transferred to 16k words. any more than this
    ; will have to be done in the second transfer
    ;
	cmp	bp,16*1024	; more than 16k word transfers
	jbe	ab$301		; if not cx is fine
	mov	cx,bp		; else cx = number of words - 16*1024
	mov	bp,16*1024	; and bp = 16*1024
	sub	cx,bp		;
ab$301:
    ;
    ; store this on stack
    ;
	push	cx
;
; end of kludge in step 2
;
	push	bx		; save it back again
	push	dx		; save this too
    ;
    ; initially si offset into logical page, so we can only do 16*1024 - si
    ; byte transfer
    ;
	mov	cx,16*1024
	sub	cx,si
	shr	cx,1		; convert to word count
    ;
    ;	number to be transferred is the minimum of this and the user requested
    ;	count
    ;
	cmp	cx,bp
	jb	ab$31
	mov	cx,bp
    ;
ab$31:
    ;
    ;	see if write, then we have to switch source with destination
    ;
	or	bh,bh
	je	ab$32		; if read we don't have to do anything
				; else we have to switch
	src_dest_switch
ab$32:
    ;
    ;	set direction flag so that we don't have to do it repeatedly
    ;
	cld
;
;   [STEP3: set up transfer and do it]
;
ab$33:
    ;
    ;	update count of words still left to be transferred after this
    ;
	sub	bp,cx
    ;
    ;	map the logical page in cache to the physical page  selected
    ;
	mov	bx,dx		; get logical page into bx
				; al already holds the physical page #
	map_page
	jnc	ab$34		; suceeded ?
    ;
    ; else report error
    ;
	add	sp,6
	stc
	jmp	      restore_mp ; and go to restore page map
ab$34:
    ;
    ; succeeded, do the transfer
    ;
rep	movsw
    ;
;
;   [STEP4: check if transfer done, if not set up for next block]
;   [STEP5: go back to STEP3]
    ;
    ; check if done
    ;
	or	bp,bp		; count 0
	je	ab$40		; yes, go to finish up
    ;
    ;	recover original dx and bx, increment dx and then save both again
    ;
	pop	dx
	pop	bx
	inc	dx
	push	bx
	push	dx
    ;
    ; words to be transferred minimum of count and 8*1024 words
    ;
	mov	cx,8*1024	; 8k words in a page
	cmp	cx,bp		;
	jbe	ab$35		; if below or equal this is what we want
    ;
	mov	cx,bp		; else we can transfer the whole count
ab$35:
    ;
    ; see whether cache src or dest and accordingly reset either si or di
    ;
	or	bh,bh		; read?
	jne	ab$36		; if write go to modify
    ;
    ; read, zero si and go back to step3
    ;
	xor	si,si
	jmp	short ab$33	; to step 3
ab$36:
    ;
    ; write, zero di and go back to step3
    ;
	xor	di,di
	jmp	short ab$33	; to step 3
;
; finishing up we have to restore the page map
;
ab$40:
;
; also kludged to handle 64k byte transfers
;
	pop	dx
	pop	bx
	pop	bp		; number of words for second transfer
	pop	ax		; base of second transfer
	or	bp,bp		; are we done?
	jne	ab$407		; no, we have to do another transfer
	jmp	ab$405		; yes we can go to finish up
ab$407: 			; apologies for such abominations
	push	ax		; dummy transfer base
	xor	cx, cx
	push	cx		; zero count for next time
;
; restore the mapping context
;
	clc
	push	dx		; dx is destroyed by restore mapping context
	restore_mapping_context
	pop	dx		;
	jnc	ab$401
;
; error we should quit here
;
	add	sp, 4		; throw base & count
	ret
;
; we need to save the mapping context again
;
ab$401:
	save_mapping_context
	jnc	ab$406		; if we couldn't save it then error
	add	sp, 4
	ret
;
; reset physical page to be mapped to 0 and ds or es to page map base
; and increment logical page if we have si = 0 (read) or di=0 (write)
;
ab$406:
	mov	cx, word ptr [base_addr+2]
	cmp	ax, 1024	; new base in page 0?
	jb	ab$4060
	cmp	ax, 4*1024
	jae	ab$4060
	xor	ax, ax
	jmp	short ab$4061
ab$4060:
	mov	al, 3
	add	cx, 3*1024
ab$4061:
	or	bh,bh		; read or write?
	jne	ab$402		; if write branch
;
    ;
    ; read, reset ds to base address
    ;
	mov	ds,cx
	mov	cx,16*1024	;
	cmp	si, cx		; at end of page?
	jbe	ab$4030
	inc	dx
	xor	si, si
ab$4030:
	sub	cx,si
	shr	cx,1

ab$403:
	push	bx		; save these
	push	dx
;
	cmp	cx,bp		; is the cx appropriate
	jbe	ab$404		; if yes go to do transfer
	mov	cx,bp		; else cx <--- bp
ab$404:
	jmp	ab$33	  ; and go to do transfer
;
ab$402:
    ;
    ; write, reset es to base address
    ;
	mov	es,cx
	mov	cx,16*1024
	cmp	di, cx
	jb	ab$4020
	xor	di, di
	inc	dx
ab$4020:
	sub	cx,di
	shr	cx,1
	jmp	short ab$403
;
;	add	sp,4
ab$405:
	clc
restore_mp:
	restore_mapping_context
	ret

		DW	?		; SPACE for ABOVE_PID

;
; This label defines the end of the code swapped in at DRIVE_CODE
;
ABOVE_END	LABEL	WORD

BREAK	<Drive code for /A driver. Swapped in at RESET_SYSTEM>


;
; WARNING DANGER!!!!!!!
;
; This code is tranfered over the /E driver code at RESET_SYSTEM
;
; ALL jmps etc. must be IP relative.
; ALL data references must be to cells at the FINAL, TRUE location
;	(no data cells may be named HERE, must be named up at RESET_SYSTEM).
; SIZE of stuff between ABOVE_RESET and ABOVE_RESET_END MUST be less than
;	or equal to size of stuff between RESET_SYSTEM and RESET_INCLUDE.
;
; NOTE: EACH ABOVE BOARD driver has an INT 19 and 9 handler. This is
;	different from /E and RESMEM in which only the first
;	driver has an INT 19 and 9 handler.
;

IF2
  IF((OFFSET ABOVE_RESET_END - OFFSET ABOVE_RESET) GT (OFFSET RESET_INCLUDE - OFFSET RESET_SYSTEM))
	  %out ERROR ABOVE_RESET CODE TOO BIG
  ENDIF
ENDIF

;**	ABOVE_RESET perform TYPE 2 (/A) driver specific reboot code
;
;	This code issues an ABOVE_DEALLOC call for the memory
;	associated with this particular TYPE 2 RAMDrive since the
;	system is being re-booted and the driver is "gone".
;
;	ENTRY
;	    NONE
;	EXIT
;	    NONE
;	USES
;	    NONE
;
; This code is specific to TYPE 2 drivers
;

ABOVE_RESET:
ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING
	PUSH	AX
	PUSH	DX
AGAIN_RESET:
	MOV	DX,[ABOVE_PID]
	MOV	AH,ABOVE_DEALLOC	; Close PID
	INT	67H
	CMP	AH,ABOVE_ERROR_BUSY
	JZ	AGAIN_RESET
	POP	DX
	POP	AX
	RET

;
; This label defines the end of the code swapped in at RESET_SYSTEM
;
ABOVE_RESET_END    LABEL   BYTE

BREAK	<RESMEM INIT Code>

;**	RESMEM specific data
;
;	The following datums are specific to the RESMEM (TYPE 3
;	or 4) drivers
;
;	Specific to TYPE 3 or TYPE 4 drivers
;

HIGH_SEG DW	?		; Segment addr of "end of memory" from INT 12
                                ; or from INIT packet BREAK address (M002).

RAMSEG	DW	0		; Segment addr of the start of RAMDrive memory.
				;   Basically a segment register version of
				;   BASE_ADDR

CRTSEG	EQU	0A000H		; Memory past this segment value is RESERVED
				;   Memory scan must stop here.


;**	RESMEM_INIT - Perform RESMEM (TYPE 3 or 4) specific initialization
;
;	This code performs the driver TYPE specific initialization for
;	TYPE 3 and TYPE 4 drivers.  [Type 3 no longer supported.]
;
;       M002: The size of memory is obtained from 1 of 2 sources; for DOS
;       versions prior to DOS 5.X, this size is obtained from INT 12h.  For
;       DOS version 5.X and beyond, this size is taken from the INIT packet
;       BREAK address.
;
;	Memory scan (No longer attempted)
;	    The method used by this code to "find" valid RAM between
;	    the "end of memory" as determined from the INT 12 memory
;	    size and CRTSEG is to look for memory which will correctly
;	    store data. It looks on 1K boundaries. If the first 2 words
;	    of a 1k block are good, it is assumed that the rest of the
;	    1K block is good without explicitly checking it. The scan
;	    is interested only in the FIRST block it finds. If two
;	    separated (by invalid RAM) blocks of RAM exist in the
;	    above range, the second block WILL NOT be found.
;	    NOTE that this can be fooled by a bad memory chip in
;	    a block of RAM. In this case RAMDrive will use the
;	    memory up to the bad spot and ignore the rest.
;	    Also note that since 16K is the minimum RAMDrive
;	    size, and the EMM_CTRL sector takes 1k, a block
;	    of size < 17K results in an insufficient memory error.
;           [M002: Minimum RAMDrive is now 4K, but this is irrelevant
;           since the described memory scan no longer takes place.]
;
;	    Since access to invalid RAM (RAM that isn't present)
;	    results in a parity error, the above scan must be done
;	    with parity checking disabled.
;
;	    Since the ROM BIOS memory initialization code and tests
;	    is only run on the memory indicated by INT 12, one of
;	    the things this code must do when it finds memory "above
;	    INT 12" is make sure all of the parity bits are set correctly.
;	    This is accomplished easily by just copying the memory to
;	    itself.
;
;	    The scan is NON-DESTRUCTIVE so that any data contained in
;	    the memory will not be destroyed.
;
;	    The result of this scan also makes the determination between
;	    a TYPE 3 and TYPE 4 RAMDrive. If memory is found, then we're
;	    TYPE 3. If no memory is found, then we're TYPE 4.
;
;
;	RESMEM_BLKMOV code swapped in at BLKMOV
;	RESMEM_RESET code swapped in at RESET_SYSTEM
;	    NOTE: This step is not needed for a TYPE 4 driver
;		    since TYPE 4 NEVER has an INT 9 or INT 19 handler,
;		    but it isn't harmful either, so we do it always.
;       IF Dos version < 5.X
;		Issue INT 12 to get size of memory
;       ELSE
;               Get memory size from INIT packet BREAK address
;	Convert INT 12 result to segment address of first byte after system
;	    memory.
;	IF this segment address is equal to or grater than CRTSEG
;	    There cannot be any memory "above INT 12" so we are TYPE 4.
;	    Skip the memory scan since there is no memory to scan and
;	    go to the TYPE 4 init code at CASE1.
;	Disable parity checking so access to non-existent RAM won't crash
;	    the system.
;	Perform the memory scan. This starts at FOO and ends at HAVE_MEM
;	    if we find some valid memory, or at CASE1 if we don't.
;	  A word about the scan.
;	    There are two cases for valid RAM.
;		1.) Valid memory starts at the INT 12 address
;		2.) There is invalid RAM for a while, then valid RAM starts.
;	    The DX register is used to tell us what is going on. It is
;	    non-zero if we are skipping over invalid RAM looking for
;	    some valid RAM (case 2), or 0 is we have found some valid RAM
;	    (case 1, or case 2 after skipping invalid RAM) and are scanning
;	    to set parity and find the end of the valid RAM.
;	    RAMSEG is given the initial value of 0 to indicate we have not
;	    found the start of a valid block.
;	    When the scan is finished ENABLE_PARITY is called to turn parity
;	    checking back on.
;	IF we have valid RAM and end at HAVE_MEM
;	    We are TYPE 3.
;	    RAMSEG contains the segment address of the start of the block
;	    BX is the segment address of the end of the block
;	    Subtract RAMSEG from BX to get size of region in paragraphs
;	    Convert size in Paragraphs to size in K
;	    Check that size is AT LEAST 17k (minimum size)
;	    Jump to GOT_RESMEM if OK else error
;	    Set EXT_K to size of block
;	    Adjust DEV_SIZE if bigger than EXT_K - 1 (-1 for EMM_CTRL)
;	    Convert RAMSEG to 32 bit address and set it into BASE_ADDR
;		This sets BASE_ADDR to point to EMM_CTRL sector.
;	    Set BASE_RESET to BASE_ADDR plus 1024
;	    Call MM_SETDRIVE to complete TYPE 3 specific initialization
;	ELSE we end up at CASE1
;	    We are TYPE 4.
;	    Set RESMEM_SPECIAL to indicate TYPE 4
;	    Set INIT_DRIVE to 2 (DOS volume MUST be initialized)
;	    Set BASE_ADDR to be the first para boundary after the resident
;		code (which DOES NOT include INT 19/INT 9 code).
;	    Compute TERM_ADDR based on DEV_SIZE Kbytes of device starting at
;		BASE_ADDR.
;	    NOTE: We must make sure the specified DEV_SIZE is reasonable:
;		It must not be bigger than 10 bits (1 Meg)
;			as this is the memory limit of the 8086.
;		It must not be so big that there is less than 48k of system
;			memory after the device is installed.
;			This is checked by computing the segment address
;			of the end of the device and comparing it to the
;			INT 12 memory end address minus 48k worth of paragraphs
;
;	ENTRY:
;	    Invokation line parameter values set.
;	EXIT:
;	    RESMEM_BLKMOV code swapped in at BLKMOV
;	    RESMEM_RESET code swapped in at RESET_SYSTEM
;	    Determination of TYPE 3 or TYPE 4 made by setting RESMEM_SPECIAL
;		if TYPE 4.
;	    CARRY SET
;		Error, message already printed. Driver not installed.
;		    If TYPE 3
;			EMM_CTRL not marked (but MAY be initialized if
;			a valid one was not found).
;	    CARRY CLEAR
;		DEV_SIZE set to TRUE size
;		INIT_DRIVE set appropriatly
;		IF TYPE 3
;		    BASE_ADDR set for this drive from EMM_BASE of EMM_REC
;		    BASE_RESET set from BASE_ADDR
;		    EMM_REC is marked EMM_ISDRIVER
;		    TERM_ADDR set to correct device end.
;			RESET_SYSTEM code and INT 9/INT 19 code included,
;			INT 19 and 9 vector patched if this is the first
;			TYPE 3 RAMDrive in the system.
;		IF TYPE 4
;		    BASE_ADDR set for this drive by computing address of
;			start of memory after RAMDrive code.
;		    BASE_RESET set from BASE_ADDR
;		    TERM_ADDR set to correct device end which includes
;			the memory taken up by the RAMDrive itself.
;
;	USES:
;	    ALL but DS
;
;	Code is specific to TYPE 3 and TYPE 4 drivers
;

RESMEM_INIT:
ASSUME	DS:RAMCODE,ES:NOTHING,SS:NOTHING
    ;
    ; Swap RESMEM code into place
    ;
	PUSH	CS
	POP	ES
	MOV	SI,OFFSET RESMEM_CODE
	MOV	DI,OFFSET DRIVE_CODE
	MOV	CX,OFFSET DRIVE_END - OFFSET DRIVE_CODE
	REP	MOVSB
	MOV	SI,OFFSET RESMEM_RESET
	MOV	DI,OFFSET RESET_SYSTEM
	MOV	CX,OFFSET RESET_INCLUDE - OFFSET RESET_SYSTEM
	REP	MOVSB
    ;
    ; We have THREE cases to contend with:
    ; [M002: For Dos versions >= 5.X, the memory limit passed to RAMDrive in
    ; the INIT packet BREAK address is used instead of the INT 12h value.]
    ;
    ;  1. There is NO memory above the INT 12H switch setting.
    ;	     In this case we will use the user specified device
    ;	     size (within limits) to allocate some memory as part
    ;	     of the RAMDRIVE.SYS resident image.
    ;	  NOTE: This type of a RAMDrive will not live through a warm boot
    ;
    ;  2. There is memory immediately after the INT 12H memory size.
    ;	     We will check for a EMM_CTRL there etc.
    ;
    ;  3. There is memory after the INT 12H memory size, but not
    ;	     Immediately after.
    ;	     We will check for a EMM_CTRL there etc.
    ;

;M002
        cmp     DosVersion,(5 shl 8)+00 ; DOS version < 5.X ?
        jb      rmi20                   ;  -yes, jump.
                                        ;  -no, get memory size from INIT
                                        ;    packet BREAK address.

        push    es
ASSUME ES:NOTHING
        les     bx,[PTRSAV]

IF DEBUG
     	jmp	short deb0

Deb0MesA DB      " Init Break SEG = $"
Deb0MesB DB      " Init Break OFFSET = $"

deb0:	push	cx
        push    dx
        mov	dx,offset Deb0MesA
	call	PRINT
        mov     ax,word ptr es:[bx].INIT_BREAK+2
        call    ITOA

	mov	dx,offset Deb0MesB
	call	PRINT
        mov	ax,word ptr es:[bx].INIT_BREAK
        call    ITOA
        pop	dx
        pop     cx
ENDIF

        mov     ax,WORD PTR es:[bx].INIT_BREAK+2
        pop     es
        jmp     short rmi40             ; AX = Segment # of top of available
        				;      memory.


rmi20:	INT	12H			; Get size of memory set on switches

;M002

IF DEBUG

	JMP	SHORT DEB1

DEB1MES DB	13,10,"INT 12 returned $"

DEB1:
	PUSH	CX
	PUSH	DX
	PUSHF
	PUSH	AX
	MOV	DX,OFFSET DEB1MES
	CALL	PRINT
	POP	AX
	PUSH	AX
	CALL	ITOA
	POP	AX
	POPF
	POP	DX
	POP	CX
ENDIF

	MOV	CL,6
	SHL	AX,CL			; Convert to Segment register value
rmi40:	MOV	BX,AX			; M002: BX = [HIGH_SEG] = end Segment
	MOV	[HIGH_SEG],AX		;       of available memory.

;
;*****************************************************************************
; Ramdrives installed between int12 reported memory and crtseg (A000h) are
; no longer allowed because on several machines including the model 50/60
; and the Tandy AT clone this area is used for something else.	The idea to
; install a ramdrive in system memory is bad anyway but we shall still support
; the installation of a ramdrive in low memory as part of the driver. isp
;
; [Some code was commented out here.  In other places, uncalled routines
; still supported type 3 driver.  I deleted it.  -dbo]

CASE1:
    ;
    ; Have CASE 1.
    ; Driver is TYPE 4
    ;

IF DEBUG

	JMP	SHORT DEB4

DEB4MES DB	13,10,"CASE 1$"

DEB4:
	PUSH	CX
	PUSH	DX
	PUSHF
	PUSH	AX
	MOV	DX,OFFSET DEB4MES
	CALL	PRINT
	POP	AX
	POPF
	POP	DX
	POP	CX
ENDIF

	PUSH	CS
	POP	DS
ASSUME	DS:RAMCODE
	INC	[RESMEM_SPECIAL]	; Flag SPECIAL case for INIDRV
	MOV	[INIT_DRIVE],2		; This type must ALWAYS be inited
    ;
    ; Compute BASE_ADDR to be right after DEVICE_END, NO INT 19/9 handler
    ;
	MOV	AX,OFFSET DEVICE_END
	ADD	AX,15			; Para round up
	MOV	CL,4
	SHR	AX,CL			; # of para in RAMDrive resident code
	MOV	DX,CS
	ADD	AX,DX			; AX is seg addr of start of RAMDrive
	PUSH	AX
	MOV	CX,16
	MUL	CX			; DX:AX is byte offset of that many paras
	MOV	WORD PTR [BASE_ADDR],AX
	MOV	WORD PTR [BASE_ADDR + 2],DX
	POP	AX
    ;
    ; Compute correct ending address and set TERM_ADDR
    ; Check that there is at least 48k of system memory after device end
    ; AX is the segment address of the start of the device
    ;
	MOV	DX,[DEV_SIZE]		; Get size in K
    ;
    ; DEV_SIZE can be at most a 10 bit number as that is 1 Meg, the memory
    ;	 limit on the 8086
    ;
	TEST	DX,0FC00H		; If any of high 6 bits set, too big
        JNZ     rmi60                   ; M002
	MOV	CL,6
	SHL	DX,CL			; DX is # of PARA in that many k
	ADD	AX,DX			; AX is end seg addr

;M002
	jnc	rmi70			; No overflow
rmi60:	jmp	short RES_NOMEM         ; Overflow.
rmi70:
    ;
    ; Dos versions < 5.X:  Leave at least 48K after RAMDrive for COMMAND.COM;
    ;                      This is really only a guess, and may be
    ;			   insufficient if other less considerate devices
    ;			   are loaded after RAMDrive.
    ; Dos versions >= 5.X: Since RAMDrive could be loaded into UMBs (which
    ;                      wouldn't contain COMMAND.COM), leaving space for
    ;                      COMMAND.COM would not be valid in all situations.
    ;                      Thus, in this case, we do not make any attempt to
    ;                      leave extra memory.
    ; Note that in all cases, the system will die gracefully if insufficient
    ; memory is left to run COMMAND.COM. (This is a characteristic of MS-DOS,
    ; and is independent of RAMDrive.)
    ;
	mov	dx,[HIGH_SEG]           ; DX = end Segment of available mem.
        cmp     DosVersion,(5 shl 8)+00 ; DOS version >= 5.X ?
        jae     rmi80                   ;  -yes, jump: don't leave extra.
	sub	dx,0C00H		;  -no: leave 48K (in PARAs) for
					;       COMMAND.COM.
rmi80:                                  ; DX = adjusted ending Segment of
                                        ;      available memory.
;M002

IF DEBUG

	JMP	SHORT DEB5

DEB5MESA DB	 " Max end is $"
DEB5MESB DB	 " end is $"

DEB5:
	PUSH	CX
	PUSHF
	PUSH	DX
	PUSH	AX
	MOV	DX,OFFSET DEB5MESA
	CALL	PRINT
	POP	DX
	POP	AX
	PUSH	AX
	PUSH	DX
	CALL	ITOA
	MOV	DX,OFFSET DEB5MESB
	CALL	PRINT
	POP	AX
	PUSH	AX
	CALL	ITOA
	POP	AX
	POP	DX
	POPF
	POP	CX
ENDIF

	JC	RES_NOMEM
	CMP	AX,DX
	JA	RES_NOMEM		; Too big
	MOV	WORD PTR [TERM_ADDR],0
	MOV	WORD PTR [TERM_ADDR + 2],AX

IF DEBUG

	JMP	SHORT DEB6

DEB6MES DB	" OK term $"

DEB6:
	PUSH	CX
	PUSHF
	PUSH	DX
	PUSH	AX
	MOV	DX,OFFSET DEB6MES
	CALL	PRINT
	POP	AX
	PUSH	AX
	CALL	ITOA
	POP	AX
	POP	DX
	POPF
	POP	CX
ENDIF
	CLC
	RET

RES_NOMEM:
ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING
	MOV	DX,OFFSET ERRMSG2
	CALL	PRINT
	PUSH	CS
	POP	DS
	STC
	RET


BREAK	<Drive code for resmem driver. Swapped in at BLKMOV>

;
; This label defines the start of the TYPE 3 and 4 code swapped
;  in at BLKMOV
;
RESMEM_CODE	 LABEL	 WORD

;
; WARNING DANGER!!!!!!!
;
; This code is tranfered over the /E driver code at DRIVE_CODE
;
; ALL jmps etc. must be IP relative.
; ALL data references must be to cells at the FINAL, TRUE location
;	(no data cells may be named HERE, must be named up at BLKMOV).
; OFFSET of RESMEM_BLKMOV relative to RESMEM_CODE MUST be the same as
;	the OFFSET of BLKMOV relative to DRIVE_CODE.
; SIZE of stuff between RESMEM_CODE and RESMEM_END MUST be less than
;	or equal to size of stuff between DRIVE_CODE and DRIVE_END.

IF2
  IF((OFFSET RESMEM_BLKMOV - OFFSET RESMEM_CODE) NE (OFFSET BLKMOV - OFFSET DRIVE_CODE))
	  %out ERROR BLKMOV, RESMEM_BLKMOV NOT ALIGNED
  ENDIF
  IF((OFFSET RESMEM_END - OFFSET RESMEM_CODE) GT (OFFSET DRIVE_END - OFFSET DRIVE_CODE))
	  %out ERROR RESMEM CODE TOO BIG
  ENDIF
ENDIF

		DD	?	; 24 bit address of start of this RAMDRV

;**	RESMEM_BLKMOV - Perform transfer for TYPE 3 and 4 driver
;
;	This routine is the transfer routine for moving bytes
;	to and from a RAMDrive located in main memory.
;
;	METHOD:
;	    Convert start address into segreg index reg pair
;	    Mov computed segreg index reg pairs into correct registers
;	    Execute REP MOVSW to perform transfer
;
;	ENTRY:
;	    ES:DI is packet transfer address.
;	    CX is number of words to transfer.
;	    DX:AX is 32 bit start byte offset (0 = sector 0 of RAMDrive drive)
;	    BH is 1 for WRITE, 0 for READ
;
;	    BASE_ADDR set to point to start of RAMDrive memory
;		This "input" is not the responsibility of the caller. It
;		is up to the initialization code to set it up when the
;		device is installed
;
;	EXIT:
;	    Carry Clear
;		    OK, operation performed successfully
;	    Carry Set
;		    Error during operation, AL is error number
;
;	USES:
;	    ALL
;
;	This routine is specific to TYPE 3 and 4 drivers
;

RESMEM_BLKMOV:
ASSUME	DS:RAMCODE,ES:NOTHING,SS:NOTHING

	ADD	AX,WORD PTR [BASE_ADDR]
	ADC	DX,WORD PTR [BASE_ADDR + 2]
	PUSH	CX
	MOV	CX,16
	DIV	CX		; AX is seg reg value, DX is index register
	POP	CX
	OR	BH,BH
	JZ	READ_ITR
    ;
    ; WRITE
    ;
	PUSH	ES
	POP	DS
ASSUME	DS:NOTHING
	MOV	SI,DI
	MOV	ES,AX
	MOV	DI,DX
TRANS:
	REP	MOVSW
	CLC
	RET

READ_ITR:
	MOV	DS,AX
ASSUME	DS:NOTHING
	MOV	SI,DX
	JMP	TRANS

;
; This label defines the end of the RESMEM code swapped in at BLKMOV
;
RESMEM_END	 LABEL	 WORD

BREAK	<Drive code for resmem driver. Swapped in at RESET_SYSTEM>


;
; WARNING DANGER!!!!!!!
;
; This code is tranfered over the /E driver code at RESET_SYSTEM
;
; ALL jmps etc. must be IP relative.
; ALL data references must be to cells at the FINAL, TRUE location
;	(no data cells may be named HERE, must be named up at RESET_SYSTEM).
; SIZE of stuff between RESMEM_RESET and RESMEM_RESET_END MUST be less than
;	or equal to size of stuff between RESET_SYSTEM and RESET_INCLUDE.

IF2
  IF((OFFSET RESMEM_RESET_END - OFFSET RESMEM_RESET) GT (OFFSET RESET_INCLUDE - OFFSET RESET_SYSTEM))
	  %out ERROR RESMEM_RESET CODE TOO BIG
  ENDIF
ENDIF

;**	RESMEM_RESET perform TYPE 3 (RESMEM) driver specific reboot code
;
;	This code performs the EMM_ISDRIVER reset function as described
;	in EMM.ASM for all EMM_REC structures which are EMM_ALLOC and
;	EMM_ISDRIVER and of type EMM_MSDOS.
;
;	ENTRY
;	    NONE
;	EXIT
;	    NONE
;	USES
;	    NONE
;
; This code is specific to TYPE 3 drivers
;

RESMEM_RESET:
ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING
	PUSH	SI
	PUSH	DI
	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DX
	PUSH	DS
	PUSH	ES
	PUSH	CS
	POP	DS
ASSUME	DS:RAMCODE
	MOV	AX,WORD PTR [BASE_ADDR]
	MOV	DX,WORD PTR [BASE_ADDR + 2]
	SUB	AX,1024 		; Point back to EMM block
	SBB	DX,0
;
; NOTE: We can address the EMM block by just backing up
;	by 1024 bytes from BASE_ADDR because the RESET_SYSTEM handler
;	is in the FIRST RAMDrive driver
;
	MOV	CX,16
	DIV	CX			; AX is seg reg, DX is index reg
	MOV	DS,AX
ASSUME	DS:NOTHING
	MOV	SI,DX			; DS:SI -> EMM_CTRL
	MOV	DI,SI
	ADD	DI,EMM_RECORD
	MOV	CX,EMM_NUMREC
LOOK_RECRY:
    ;
    ; Scan EMM_CTRL for all ISDRIVER MS-DOS regions and turn off ISDRIVER
    ;
	TEST	[DI.EMM_FLAGS],EMM_ALLOC
	JZ	DONERY
	TEST	[DI.EMM_FLAGS],EMM_ISDRIVER
	JZ	NEXTRECRY		 ; No Driver
	CMP	[DI.EMM_SYSTEM],EMM_MSDOS
	JNZ	NEXTRECRY
	AND	[DI.EMM_FLAGS],NOT EMM_ISDRIVER
NEXTRECRY:
	ADD	DI,SIZE EMM_REC
	LOOP	LOOK_RECRY
DONERY:
	POP	ES
	POP	DS
ASSUME	DS:NOTHING
	POP	DX
	POP	CX
	POP	BX
	POP	AX
	POP	DI
	POP	SI
	RET

;
; This label defines the end of the RESMEM code swapped in at RESET_SYSTEM
;
RESMEM_RESET_END    LABEL   BYTE

BREAK <messages and common data>

;**	Message texts and common data
;
;	Init data. This data is disposed of after initialization.
;	it is mostly texts of all of the messages
;
;	COMMON to TYPE 1,2,3 and 4 drivers
;
;
;	translatable messages moved to message module (SP)

	EXTRN	NO_ABOVE:BYTE,BAD_ABOVE:BYTE,NO_MEM:BYTE
	EXTRN	NOXMM:BYTE,ERRXMM:BYTE,XMMCHAIN:BYTE
	EXTRN	ERRMSG1:BYTE,ERRMSG2:BYTE,INIT_IO_ERR:BYTE,BADVERMES:BYTE
	EXTRN	HEADERMES:BYTE,PATCH2X:BYTE,DOS_DRV:BYTE
	EXTRN	STATMES1:BYTE,STATMES2:BYTE,STATMES3:BYTE
	EXTRN	STATMES4:BYTE,STATMES5:BYTE
        EXTRN   SECT_ADJ:BYTE           	;M001
	db	"RAMDrive is a trademark of Microsoft Corporation."
	db	"This program is the property of Microsoft Corporation."

VOLID	DB	'MS-RAMDRIVE',ATTR_VOLUME_ID
	DB	10 DUP (0)
;
; Volume creation date = driver release date
;
	DW	0				;time=midnight
	DW	((1992-1980)*512)+(7*32)+21	;date=1992 Jul 21
	DW	0,0,0

SECTOR_BUFFER	DB	1024 DUP(0)
;
; Note (M00):  SECTOR_BUFFER is used during ABOVE_INIT to hold
; the addresses of mappable EMS pages.  Max size required is
; 1024K / 16K * 4 = 256 bytes.
;

RAMDrive_END	   LABEL   BYTE

RAMCODE ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\bambi.asm ===
page    58,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;debug  =       1       ; enables some debug code
;tracker        =       0ffffh  ; enables special TRACKER events
debug = 0
tracker = 0

;    BAMBI global register conventions:
;
;       The machine registers are generally considered extremely
;       volatile in this program and should not generally be
;       considered to be preserved when calling a subroutine,
;       unless specifically stated otherwise.
;
;       DS: generally points to CS: in order to access the data
;       stored there without overrides.
;
;    BAMBI design assumptions:
;
;       The number of sectors per cache block CANNOT be > 16.
;
;       Write caching of a given drive implies that it is read cached.
;
;    Purpose of this module:
;
;       This is the main resident device driver interface for Bambi.
;       It contains the main caching logic flow and utilizes external
;       modules for keeping track of caching data structure and accessing
;       secondary RAM storage.
;
;       This module provides one main entry point, which is our_strat/
;       our_int.  This is what DOS calls through to access the block
;       device drivers.  It also contains entry points which are used
;       by the dirty_write function in a companion module.

	.xlist
	include msequ.inc       ; get device request packet definitions
	include devsym.inc      ; get device driver structure definitions
	include bambi.inc
	include bootform.inc
	include bpb.inc
	.list

public  our_int                 ; DOS branches here for ALL block
public  our_strat               ;  device driver calls for devices which
				;  are present when we're first initialized

;       We publish a few special entry points and variables for use
;       by the dirtywrt.asm module.

public  lookup_device
public  read_full_cache_block
public  set_start_sector
public  call_dd_common

public  loc_req_seg             ; allow bambinit to initialize our pointers
public  lb_seg

public  our_count
public  our_trans_off
public  our_trans_seg
public  our_starth
public  our_startl
public  our_start

public  loc_reqblk
public  num_valid_buffers
public  rblk_op
public  media_id
public  media_ids 

public  packet_size
public  packet_sizes

public  next_bad_entry_ptr 
public  num_bad_blocks  

zseg    segment public 'code'
	assume  cs:zseg,ds:nothing,es:nothing

;
;       data from rdata.asm
;
extrn   last_buffer             :word
extrn   max_valid_buffers       :word

extrn   dos_3x                  :word
extrn   hit_l                   :word
extrn   hit_h                   :word
extrn   nohit_l                 :word
extrn   nohit_h                 :word
extrn   in_bambi                :byte

extrn   selected_drive          :byte

extrn   real_dd_headers         :dword
extrn   real_cache_units        :byte
extrn   secsize_and_align_info  :word
extrn   cache_block_bytes       :word

extrn   cache_block_words       :word

;
;       routines from queueman.asm
;
extrn   flush_queue             :near
extrn   set_dirtyindex          :near
extrn   fast_lookup             :near
extrn   invalidate_element      :near
extrn   queue_element           :near

;
;       routines from cacheman.asm
;
extrn   cache_to_buffer         :near
extrn   buffer_to_cache         :near
extrn   commit_all_dirty        :near
;
;       data from int2f.asm
;
extrn   accessing_swap_file_ptr :dword
;
;       data from queueman.asm
;
extrn   queuelength             :word
;
;       data from hooks.asm
;
extrn   resident_stack          :word
extrn   temp_res_stack          :word
extrn   save_stack_ss           :word
extrn   save_stack_sp           :word
extrn   commit_all_when_ok      :byte
extrn   write_behind_cache      :near

;
;       routines from popup.asm
;
extrn   warning_pop_up          :near

;
;       data from bambinit.asm
;
extrn   ending_address          :word
extrn   number_of_cache_elements:word   ;WARNING transient!
extrn   initqueue               :near

;       local variables
;
;       Please note:  Many of these variables are only valid for
;                     the operation being performed by the mainline
;                     routine.  dirty_write must handle its own
;                     configuration constants on the fly.
;
;       put our dword pointers first so they're all
;       aligned without wasting space

far_call_address        dd      0
d_trans                 dd      0
dd_header               dd      0
user_reqblk             dd      0
MAXRENTER       equ     5               ;arbitrary number of reentracy allowed
user_save_reqblk        dd      MAXRENTER       dup(0)

;       quick reference points for our block buffer and request block
;          the segments fields are declared external so bambinit.asm
;          can initialize them.

loc_reqblk              label   dword
			dw      our_reqblk
loc_req_seg             dw      0       ; init'd by bambinit, always == cs

local_buf               label   dword
			dw      0
lb_seg                  dw      0       ; this will generally be a
					;  different segment from cs

;       put word variables next

blockids                dw      16 dup (?)
d_count                 dw      0
curblk_l                dw      0
curblk_h                db      0,0     ; may be accessed as word

lastblk_l               dw      0
lastblk_h               db      0,0     ; may be accessed as word

curblk_index            dw      0       ; high byte may be assumed to be zero
cache_element_index     dw      0

num_valid_buffers       dw      0       ; num. valid buffers in 'super-cache'
bufferblk_l             dw      0       ; low word of base block of super-cache
bufferblk_h             dw      0       ; high word + drive number

cache_align_factor      dw      0       ; must be < cache_block_sectors
cache_block_shift       dw      2       ; log2(blocksize/sectorsize)

sector_size_bytes       dw      512
cache_block_sectors     dw      4

dirty_mask              dw      0       ; mask for last looked up element
	ifdef   USE_VALID
valid_mask              dw      0       ; mask for last looked up element
	endif
cache_mask              dw      0       ; this is the full mask
;                                       ; for the selected block/sector size

;       the following data structure is used when we wish to
;       wish to issue a device driver call other than the one
;       originally passed to us from DOS.  It can benefit from
;       word alignment.

our_reqblk      label   byte
packet_size     db      30      ; length
rblk_cache_unit db      2       ; cache unit
rblk_op         db      devrd   ; read command
devstatus       dw      0       ; status
		db      13-5 dup (0) ; other stuff (???)
media_id        db      0f0h    ; media id byte
our_trans_off   dw      0       ; transfer offset
our_trans_seg   dw      0       ; transfer segment
our_count       dw      0       ; count
our_start       dw      0ffffh  ; start (ignored)
		dw      0,0
our_startl      dw      0       ; start low
our_starth      dw      0

in_device_call  dw      -1
media_ids       db      26      dup(0f0h) ;save media_id for dirty writes

packet_sizes    db      26      dup(30h)  ;save packet sizes for dirty writes

MAXBADS         equ     32
next_bad_entry_ptr dw   0       ; first entry will be 0
num_bad_blocks  dw      0
bad_blocks      dw      MAXBADS dup(0)
bad_drives      dw      MAXBADS dup(-1)

;       now the byte variables

original_unit           db      -1
flags_and_unit          db      0
cache_unit              db      0


;       enter a BAMBI record in TRACKER, subtype as argument to macro
;         this macro is defined to be a null macro of TRACKER is set
;         false, so that every single LOG event needn't have IF TRACKER
;         conditionals on it.

log_it  macro   rectype
	if      tracker
	push    ax
	mov     al,rectype
	call    tracker_log
	pop     ax
	endif
	endm

	if      tracker

;       We may want to save some special BAMBI events in
;       the TRACKER log.  If this feature is enabled, we'll
;       call through a FAR variable into TRACKER.

	public  save_it_off     ; allow external initialization for
	public  save_it_seg     ;  TRACKER save entry point

save_it         label   dword
save_it_off     dw      offset far_ret
save_it_seg     dw      0       ; will be init'd to cs if tracker not present

far_ret:
	retf

code_bambi      =       6       ; this is our special TRACKER record type

event           struc           ; this is the TRACKER event structure
rectype         db      ?
level           db      ?
regax           dw      ?
regbx           dw      ?
regcx           dw      ?
regdx           dw      ?
reges           dw      ?
time            dd      ?       ; time stamp
event           ends

xbuf    event   <code_bambi,0>  ; this is our local event structure

;-----------------------------------------------------------------------
;
;       enter a bambi-type tracker log
;
;       entry: al == event subtype
;              ds == cs
;
;       exit:  no registers affected

tracker_log     proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	push    si
	mov     si,offset xbuf
	mov     ds:[si].regax,ax
	call    save_it
	pop     si
	ret

tracker_log     endp

	endif

;-----------------------------------------------------------------------
;
;       call into the device driver using the user's original
;         request packet.
;
;       Entry: ds == cs
;
;       Trashed: es, bx, ax, si, far_call_addr
;                (plus anything affected by bad d.d.'s)

call_dd_ureqblk proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	les     bx,user_reqblk          ;es:bx points to request packet

call_dd_ureqblk endp                    ; note:  fall through to call_dd

;-----------------------------------------------------------------------
;
;       call through to the device driver
;         plug in the mapped unit code to the request block
;
;       Entry: ds == cs, es:[bx] -> request block
;
;       Trashed: ax, si, far_call_addr
;                (plus anything affected by bad d.d.'s)

call_dd proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	mov     al,cache_unit           ; get remapped cache unit
	mov     es:byte ptr [bx].requnit,al
	push    ds                      ; save caller's ds
	lds     si,dd_header            ; get actual device's header
	assume  ds:nothing
					; fall into call_dd_common
call_dd endp

;-----------------------------------------------------------------------
;
;       This is a special entry point used by dirtywrt for calling
;       out to the device driver.  When this routine is JMP'd to,
;       the original ds is already saved on the stack after the
;       actual return address.
;
;       Entry:  ds:[si] -> device driver header
;               es:[bx] -> request packet
;
;       Exit:   ds restored from stack
;
;       Trashed: ax, "far_call_address", and anything munched by
;                 bad device drivers.

call_dd_common  proc    near
	assume  cs:zseg,ds:nothing,es:nothing

	mov     devstatus,0
	mov     ax,word ptr [si].SDEVSTRAT ; get strategy entry
	mov     word ptr far_call_address[2],ds
	mov     word ptr far_call_address[0],ax

	push    es                      ; save packet for unit restore
	push    bx

	call    DWORD PTR[far_call_address]

	mov     ax,word ptr [si].SDEVINT ; get interrupt entry
	mov     word ptr far_call_address[0],ax

	call    DWORD PTR[far_call_address]

	pop     bx                      ; get packet
	pop     es

;       We have to make sure the UNIT code is returned to the
;         caller unchanged if we're calling through on DOS's
;         packet.  In the case of our own packet, original_unit
;         may not have any meaning, but in this case, we're sure
;         we're not going to care about what's left in that
;         field in the packet.
;
;       This is made more complicated by the fact that the SET_LOGICAL
;         device function returns a value in that field, so in this
;         particular case, we can't restore the original field.

	
	cmp     es:[bx].reqfunc,19
	jae     no_restore_unit         ; skip unit restore if so

	mov     al,cs:original_unit
	mov     byte ptr es:[bx].requnit,al

no_restore_unit:
	pop     ds
	ret                             

call_dd_common  endp

;-----------------------------------------------------------------------
;
;       our strategy entry point

our_strat       proc    far
	assume  cs:zseg,ds:nothing,es:nothing

	inc     cs:in_device_call               ;keep track of reentrancy
	jnz     reentering                      ;zero means first entry
finish_strategy:
	mov     cs:word ptr user_reqblk,bx
	mov     cs:word ptr user_reqblk+2,es
	ret

reentering:
	;
	; we need to save off the packet pointer for the re-entered
	; call so it will still be valid when its execution continues.
	; we use our semaphore as an index into a table which will 
	; hold the saved packet
	
	push    di                              ;must preserve all regs
	push    es
	push    bx

	mov     di,cs:in_device_call            ;treat as index into table
	shl     di,1                            ;dword table
	shl     di,1
	les     bx,user_reqblk                  ;get re-entered packed
	mov     word ptr cs:user_save_reqblk[di],bx     ;save it in our table
	mov     word ptr cs:user_save_reqblk[di+2],es

	pop     bx
	pop     es
	pop     di
	jmp     short finish_strategy   

our_strat       endp


handle_reentrancy_exit:
	pop     word ptr far_call_address[2]
	pop     word ptr far_call_address
	pop     word ptr dd_header[2]
	pop     word ptr dd_header
	pop     word ptr cache_unit
	pop     word ptr flags_and_unit
	pop     word ptr original_unit

	;
	; we need to save off the packet pointer for the re-entered
	; call so it will still be valid when its execution continues.
	; we use our semaphore as an index into a table which will 
	; hold the saved packet
	
	push    di                              ;must preserve all regs
	push    es
	push    bx

	mov     di,cs:in_device_call            ;treat as index into table
	shl     di,1                            ;dword table
	shl     di,1

	mov     bx,word ptr user_save_reqblk[di]
	mov     es,word ptr user_save_reqblk[di+2]
	mov     word ptr user_reqblk,bx
	mov     word ptr user_reqblk[2],es

	pop     bx
	pop     es
	pop     di

	jmp     dont_restore_stack

handle_reentrancy_enter:
	push    word ptr original_unit
	push    word ptr flags_and_unit
	push    word ptr cache_unit
	push    word ptr dd_header
	push    word ptr dd_header[2]
	push    word ptr far_call_address
	push    word ptr far_call_address[2]
	jmp     short skip_stack_swap


;-----------------------------------------------------------------------
;
;       This is it!  This is when DOS is trying to call a device
;         driver.  We intercept the call, and decide if it is something
;         that can be:
;
;               A) saved away into the cache
;            or B) gotten from the cache
;            or C) some combination of A & B
;
;       Entry:  our parameter block was saved in user_reqblk by
;               a call to the previous routine
;
;       Exit:   We'll try to satisfy the request and make sure we
;               fill in the status word of the request block before returning.
;
;       Trashed: We should preserve ALL registers, but we trash ax, bx & es
;                BUGBUG -- will ANYBODY ever care about ax, bx & es here?
;                          we leave es:[bx] pointing at the original req pkt.
;                Flags including direction

our_int proc    far
	assume  cs:zseg,ds:nothing,es:nothing

	push    ds              ; save caller's ds
	push    cs
	pop     ds
	assume  ds:zseg         ; make our data quickly addressable

	inc     in_bambi        ; make sure we aren't reentered

;       if there are no hw stacks, we may be the straw that breaks
;       the stack, so we have to switch to our own stack to ensure
;       no stack overflow problems

	cmp     in_device_call,0
	jne     handle_reentrancy_enter

	mov     save_stack_ss,ss        ;save the current stack 
	mov     save_stack_sp,sp        ;context
	
	push    cs                      ;and switch to our own
	pop     ss                      ;internal stack
	mov     sp,offset resident_stack

skip_stack_swap:

	push    bp                      ; we ALWAYS need these registers saved
	push    dx
	push    cx
	push    es
	push    bx
	push    di
	push    si


;       We must find the device header and unit number for the
;       drive number in the request block.  The unit number code
;       also has a couple of flag bits in it which indicate what
;       level of caching is enabled for this drive.

	les     bx,user_reqblk          ;es:bx points to request packet
	mov     al,byte ptr es:[bx].requnit 

	mov     original_unit,al        ; save original unit code
	call    lookup_device           ; remap unit code, get dev header
	xor     al,0c0h                 ; flip the 'active' bits
	mov     flags_and_unit,al       ; save flags and unit
	and     al,3fh                  ; mask off high bits 
	mov     cache_unit,al

	mov     word ptr dd_header,dx   ; save actual device header
	mov     word ptr dd_header[2],bp

;       done setting up packet structure, its off to the races!
						
	cmp     queuelength,0   ;even if caching is enabled for a drive
	je      just_pass_thru  ;the queue size could be zero, so
				;be sure there is a non-zero cache present

	test    flags_and_unit,0c0h     ; any caching enabled?
	jnz     this_drive_is_cached    ; if any caching, enter main module

just_pass_thru:
	push    si
	call    call_dd                 ; call through to device driver
	pop     si

return_to_caller:
	jmp     go_back_to_dos


;       The code below will branch back up here if the operation is
;         a media check for a cached drive.  We must note the return
;         code before returning in this case so that we can invalidate
;         the cache on a media change.

do_media_check:
	push    si
	call    call_dd
	pop     si
	cmp     BYTE PTR es:[bx].14,1
	je      return_to_caller

;;;the following code notifies windows that the media for
;;;this drive has changed.  While mutlitasking dos boxes,
;;;windows has to maintain the CDS state but can get 
;;;confused when the media changes. This notification will
;;;ensure that windows keeps track of disk changes correctly
;;;code courtesy of aaronr
	xor     di,di
	mov     es,di
	mov     bx,15h                  ;dosmgr device id
	mov     ax,1684h                ;get device api entry point
	int     2fh
	mov     ax,es
	or      ax,di
	jz      nobodytonotify
	push    bp
	mov     bp,sp
	push    es
	push    di
	mov     ax,5h                   ;media change detected
	mov     bl,original_unit        ;zero based drive number
	call    dword ptr [bp-4]        ;change detected on a=0,b=1...
	;
	;Carry is clear if media change processed. Carry set if invalid
	;  drive passed in BL (drive is not in use, is out of range, is
	;  a network drive).
	;
	pop     ax                      
	pop     ax
	pop     bp
nobodytonotify:

	call    reset_drive_stuff

	xor     bh,bh                   ;cause the bpb to be re-read next access
	mov     bl,original_unit
	shl     bx,1
	mov     word ptr secsize_and_align_info[bx],0ffffh
	mov     selected_drive,-1

	jmp     go_back_to_dos

handle_get_bpb:
	call    reset_drive_stuff
	jmp     short not_get_bpb       

;       We now know we're operating on a cached drive.  We have to
;       look at the function number to decide what to do next.

this_drive_is_cached:
	cmp     es:[bx].reqfunc,devrd   ; read, write, writev == go do it
	je      cache_this_readwrite
	cmp     es:[bx].reqfunc,devwrt
	je      cache_this_readwrite
	cmp     es:[bx].reqfunc,devwrtv
	je      cache_this_readwrite
	cmp     es:[bx].reqfunc,1
	je      do_media_check          ; watch return code from media check
	cmp     es:[bx].reqfunc,2
	je      handle_get_bpb
not_get_bpb:

	cmp     es:[bx].reqfunc,genioctl ; certain genioctls require
	jnz     just_pass_thru          ; that we invalidate our cache

	mov     ax,word ptr es:[bx].majorfunction
	cmp     ax,6008h                ;dont trap get bpb
	je      just_pass_thru_short
	cmp     ax,6608h                
	jae     just_pass_thru_short
	call    reset_drive_stuff
just_pass_thru_short:
	jmp     just_pass_thru  

;       We've now qualified this operation substantially.  We know that
;       the request was a read, write, or write w/verify on a drive that
;       we are caching.  Furthermore, the cache is not zero-length and
;       it isn't a Win 3.1 swap file access.

cache_this_readwrite:

	mov     al,es:[bx].0dh                  ; use correct media id
	mov     media_id,al

	mov     al,es:[bx]                      ; use correct packet size
	mov     packet_size,al

	cld                     ; allow our internals to assume direction

;       have we changed drives from last time?

	mov     al,original_unit        ; no need to recalculate constants
	cmp     al,selected_drive       ; on repeated accesses to the same
	jz      constants_already_valid ; drive

;       setup the relevant constants for this drive

	mov     selected_drive,al
	call    get_drive_info

	mov     byte ptr cache_align_factor,ch  ; save cache align factor
	mov     byte ptr cache_block_shift,cl   ; save shift factor

	push    bx
	xor     bh,bh
	mov     bl,original_unit
	mov     al,media_id
	mov     byte ptr media_ids[bx],al
	mov     al,packet_size
	mov     byte ptr packet_sizes[bx],al
	pop     bx

	mov     ax,cache_block_bytes            ; get sector size
	shr     ax,cl
	mov     sector_size_bytes,ax

	mov     al,1
	shl     al,cl
	mov     byte ptr cache_block_sectors,al ; get number of secs / cache block

;       Now we have to generate a mask with one bit per sectors/blk

	mov     cl,al
	mov     ax,1
	shl     ax,cl
	dec     ax                      ; get one bit per sector in this block
	mov     cache_mask,ax           ; and save the mask

constants_already_valid:
;
;       When we come here, we know that variables like sector_size_bytes
;       and cache_block_sectors are set correctly to their values for the
;       drive for this operation.  The caller's registers have mostly been
;       saved on the stack.  It is time to go to work.

	mov     ax,es:[bx.count]        ; copy count & transfer address to
	mov     d_count,ax              ; local temporary variables

	mov     ax,es:word ptr [bx.trans]
	mov     word ptr d_trans,ax
	mov     ax,es:word ptr [bx.trans+2]
	mov     word ptr d_trans+2,ax

	mov     ax,es:[bx.start]        ; get 16-bit block number
	xor     dx,dx

;       We must look at our device header (original copy) to see
;         if we should support 32 bit sector numbers.

	push    es
	push    bx
	les     bx,dd_header
	test    es:byte ptr [bx.4],2    ; 32-bit capable device?
	pop     bx
	pop     es
	jz      use_16_bit_blocknum

	cmp     dos_3x,0
	je      notdos3x
	cmp     byte ptr es:[bx],24     ;compaq's 24 byte packet?
	jne     use_16_bit_blocknum

	mov     dx,es:[bx.start.2]      ;get second part of 32-bit offset
	jmp     short use_16_bit_blocknum

notdos3x:

	cmp     ax,-1                   ; for 32 bit block numbers, the
	jnz     use_16_bit_blocknum     ;  low 16 should be -1

	mov     dx,es:[bx.start_h]      ; get high part
	mov     ax,es:[bx.start_l]      ; get 32-bit block number

use_16_bit_blocknum:
;       We now have dx:ax == the starting sector for this I/O.  Let's
;       figure out which cache block contains that sector, and what the
;       sector offset within that cache block is

;       cmp     es:byte ptr [bx.1],1            ; drive b:
;       jnz     no_bkpt
;       cmp     ax,0b10h
;       jb      no_bkpt
;
;       int     3
;
;no_bkpt:
	add     ax,cache_align_factor   ; adjustment factor attempts to align
	adc     dx,0                    ;  cache blocks with FAT clusters

	mov     cx,cache_block_shift
	push    ax                      ; save the low bits

;       The following is a fast 32-bit shift right.     It will be used
;       elsewhere in this program without the timing documentation.
;       WARNING: assumes CL <=16!

	mov     di,0FFFFh ;2 clks 3bytes   set up to make a mask
	ror     dx,cl   ;3,       2bytes   low bits of dx set to final bit position
	shr     ax,cl   ;3,       2bytes   low bits of ax set to final bit position
	shr     di,cl   ;3,       2bytes   the mask should just cover low bits in dx
	mov     cx,dx   ;2,       2bytes   save off dx (we still need high bits)
	and     dx,di   ;2,       2bytes   mask off the high bits of dx--dx is is done
	not     di      ;2,       2bytes   invert mask so we can get high bits for ax
	and     cx,di   ;2,       2bytes   mask just covers the high bits
	or      ax,cx   ;2        2bytes   or the high bits into ax--ax is done
			;= 21 clocks total (386),19 bytes

	mov     curblk_l,ax             ; store the cache block number of
	mov     curblk_h,dl             ;  the 1st sector in a temp. variable

	pop     ax                      ; get low bits (modulo)
	mov     ah,byte ptr cache_block_sectors
	dec     ah                      ; generate a mask for secs/blk
	and     al,ah                   ; extract the partial block size
	mov     byte ptr curblk_index,al ; save index within cache block

	cmp     es:[bx.reqfunc],devrd   ; reading?
	jnz     do_writes               ; assume all other functions are writes

	call    cache_reads             ; use a subroutine for the read loop
	jmp     short common_exit

do_writes:
	call    cache_write_data        ;  write it, cache if appropriate

common_exit:
go_back_to_dos:

	pop     si
	pop     di
	pop     bx
	pop     es
	pop     cx                      ; restore 1st tier of saved regs
	pop     dx
	pop     bp

	cmp     in_device_call,0
	jne     handle_reentrancy_exit_near

	mov     ss,save_stack_ss        ;restore stack
	mov     sp,save_stack_sp

dont_restore_stack:
	dec     in_bambi                ; free device_driver resource

	dec     in_device_call          ;keep track of reentrancy

	cmp     commit_all_when_ok,0    ;now is a good time to determine if
	jne     must_commit_all         ;some asynch event (ctrl+alt+delete)
					;requires us to commit all 
continue_returntodos:

	pop     ds                      ; restore caller's ds
	assume  ds:nothing

	ret                             ; back to DOS (or last hooker)
must_commit_all:
	call    write_behind_cache
	jmp     short continue_returntodos

handle_reentrancy_exit_near:
	jmp     handle_reentrancy_exit
our_int endp

;-----------------------------------------------------------------------
;
;       This routine is used when a media_change or an IOCTL forces
;       us to invalidate our information about a given drive so that
;       we are forced to re-read it.
;
reset_drive_stuff       proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	mov     num_valid_buffers,0     ; invalidate supercache
	push    ax                      ;flush the cache and invalidate
	push    bx
	push    cx
	push    dx
	push    bp
	push    si
	push    di
	push    es

	call    commit_all_dirty
	call    flush_queue

	pop     es
	pop     di
	pop     si
	pop     bp
	pop     dx
	pop     cx
	pop     bx
	pop     ax

	ret

reset_drive_stuff       endp

;-----------------------------------------------------------------------
;
;       Come here when we have a read operation on a cached drive.
;       The block number and index within the first block have already
;       been setup by the common entry code.
;
;       The basic idea is that we break the read down into:
;
;          First partial (non-cache-block aligned sectors on front)
;          Full cache blocks
;          Last partial (cache-block aligned, but we don't need it all)

xno_partial_on_front: jmp no_partial_on_front   ; make short branch reach

cache_reads     proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	cmp     byte ptr curblk_index,0 ; partial block at the front?
	jz      xno_partial_on_front    ;  skip if not

	call    check_supercache_match  ; if we're lucky, the data we want
					;  is already in our RAM buffer and
					;  we won't even have to hit XMS

	jnc     no_supercache_in_partial ; Skip if we weren't lucky

;       the block we need part of is already in the cache, copy to
;         user's buffer.  Note:  si has already been setup (pointing
;         to the target block in the supercache) and must not be trashed.

	call    first_partial_setup     ; get sector count, set es:di for move
	push    ax                      ; save # sectors
	mov     ax,curblk_index         ; get offset within block
	mul     sector_size_bytes
	add     si,ax                   ; point to correct source in supercache
	pop     ax
	mul     sector_size_bytes
	mov     cx,ax
	shr     cx,1                    ; convert to words

	mov     ds,lb_seg
	assume  ds:nothing

;       ds:si -> desired sector in supercache (our local RAM buffer)
;       es:di -> user's transfer address
;       cx    =  length of this transfer in words
;       ax    =  length of this transfer in bytes

	rep     movsw                   ; move to user's buffer
	push    cs
	pop     ds
	assume  ds:zseg                 ; restore addressability

	jmp     short next_read_block   ; update transfer, curblk, and continue

;       We're still trying to satisfy our first partial, but it wasn't
;       in the supercache.  Our next best bet is our REAL cache.

no_supercache_in_partial:

	call    check_hit               ; see if we hit on curblk
	jnz     partial_was_a_hit       ;  skip if that block is present

;       the block we need isn't in cache!  We've got to hit the disk,
;         and while we're at it, we'll stick it into the cache for
;         future use.

	mov     cx,1                    ; just get one block
	call    get_curblks_into_cache  ; get the curblk into local buf
;                                       ;  and cache it!
	jnc     frst_prt_rdok           ; done if no disk read error

;       we couldn't read the whole block.  Now we'd better try to
;         read just the part the user wanted directly into his buffer
;         before we decide to bomb out and report an error.

	call    first_partial_setup     ; get es:di -> dma addr, ax=count

	push    ax                      ; save count
	mov     ah,al                   ; get count into ah
	mov     al,byte ptr curblk_index ; get sector within block
	call    read_part_curblk_from_disk
	pop     dx                      ; restore count into dx to preserve
					; error code in ax

	jc      xgot_fatal_error        ; bomb out if fatal disk error

;       lucky us!  the read error was in another part of the
;       block, or, the retry was sufficient to get the data.

	mov     ax,dx                   ; get count just xferred
	mul     sector_size_bytes       ; get amount to bump xfer addr by
	jmp     short next_read_block

xgot_fatal_pop2:                        ; BUG1 - adjust stack & exit if error
	add     sp,4                    ; BUG1 - pop 2 entries off stack
xgot_fatal_error:       jmp     got_fatal_error ; make short branch reach

;       We've got the first partial read and cached.  Now pass it
;       back to the caller.

frst_prt_rdok:

	call    first_partial_setup     ; setup for partial block

	mul     sector_size_bytes       ; get byte count for transfer
	mov     cx,ax
	shr     cx,1                    ; convert to words

	push    ax                      ; preserve the byte count in ax
	mov     ax,curblk_index         ; get starting index
	mul     sector_size_bytes
	lds     si,local_buf
	assume  ds:nothing
	add     si,ax
	rep     movsw                   ; move the sectors
	pop     ax

	push    cs
	pop     ds
	assume  ds:zseg                 ; restore addressability

	jmp     short next_read_block

x_do_last_partial:      jmp     do_last_partial ; bridge for short jumps

;       the block we need part of is already in the cache, copy to
;         user's buffer.

partial_was_a_hit:
	call    first_partial_setup

	push    ax                      ; save # sectors
	mov     ah,byte ptr curblk_index ; get al blocks, starting here

	ifdef   USE_VALID
	push    ax
	call    make_sure_sectors_are_valid     ; if valid_bits not set,
;                                               ;  this routine will read the
;                                               ;  whole block and make sure
;                                               ;  it's all valid.
	jc      xgot_fatal_pop2                 ; BUG1 exit if error reading
	pop     ax

	endif

	mov     bp,cache_element_index
	les     di,d_trans
	call    read_part_cache_block   ; read from cache into user buffer
	pop     ax                      ; restore sector count
	mul     sector_size_bytes

;//////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\///////////////////////////////

;       This is the main READ loop.  We come back here after successfully
;       completing the first partial or any full blocks.  AX has the number
;       of bytes just transferred, and will be added to the transfer address.
;       curblk is also incremented.

next_read_block:
	add     word ptr d_trans,ax     ; update transfer address
	add     curblk_l,1              ; move to next block
	adc     curblk_h,0

;       Now we're block aligned.  Complete any remaining full blocks first.

no_partial_on_front:
	mov     ax,cache_block_sectors
	cmp     ax,d_count              ; do we need a full block?
	ja      x_do_last_partial

	sub     d_count,ax              ; count it down

	call    check_supercache_match  ; did we match in supercache?
	jnc     no_full_block_supercache_hit

;       copy the block from supercache

	les     di,d_trans              ; get user buffer
	mov     cx,cache_block_words    ; move one full cache block
	mov     ds,lb_seg               ; si set by check_supercache_match
	assume  ds:nothing
	rep     movsw                   ; move from supercache
	push    cs
	pop     ds
	assume  ds:zseg                 ; restore addressability

	mov     ax,cache_block_bytes    ; size for updating pointer
	jmp     short next_read_block

no_full_block_supercache_hit:

;       No supercache match on full cache block.  Our next best bet
;       is the REAL cache.

	call    check_hit               ; is curblk in cache?
	jz      full_nohit              ; brif not

	ifdef   USE_VALID
	mov     ax,cache_mask           ; make sure it is valid
	call    make_sure_sectors_are_valid_mask
	jc      zgot_fatal_error        ; BUG1 -- exit if read error!
	endif

	les     di,d_trans              ; get user buffer
	mov     bp,cache_element_index
	call    read_full_cache_block   ;  read the whole cached block
	mov     ax,cache_block_bytes    ; size for updating pointer
	jmp     next_read_block

zgot_fatal_error:                       ; BUG1 -- error exit bridge
	jmp     got_fatal_error         ; BUG1

;       block not in cache.  Figure out how many contiguous nohits
;         there are in the data we need, and read them all, then
;         transfer them all into the cache at once.

full_nohit:
	mov     ax,curblk_l
	mov     dl,curblk_h             ; get last block number

	xor     cx,cx                   ; init block needed count
	mov     bx,d_count              ; we need this many more sectors

count_nohit_loop:
	inc     cx                      ; count blocks needed
	sub     bx,cache_block_sectors  ;  do we need another full block?
	jb      we_know_how_many_nohits

	add     ax,1                    ; point to next block
	adc     dl,0

	push    ax
	push    bx
	push    cx
	push    dx
	call    check_hit_in_regs       ; do we need to read next block?
	pop     dx
	pop     cx
	pop     bx
	pop     ax
	jz      count_nohit_loop        ; just keep looping while no hits


we_know_how_many_nohits:

;       now cx tells us how many blocks we need to read from disk
;           bx is the number of remaining sectors after the contig nohits

;       Okay, then.  Let's jam directly on the user's buffer.

cant_fit_more_in_localbuf:
	les     di,d_trans              ; get user buffer
	push    cx                      ; save number of blks for caching loop
	mov     ax,cx                   ; get count of blocks
	call    read_curblks_from_disk  ; read that sucker
	pop     cx
	jc      got_fatal_error         ; error out!  We NEED those blocks
;                                       ;  to succeed this call!

;       adjust d_count to reflect multiple blocks transferred

	mov     ax,cx                   ; we know this is at least one
	dec     ax
	mul     cache_block_sectors
	sub     d_count,ax

;       Now we've got to copy all of that shit into the cache

	les     di,d_trans              ; point to buffer

	push    es                              ;check if this is a 
	les     si,accessing_swap_file_ptr      ;swapfile access, if so
	cmp     byte ptr es:[si],0              ;dont cache it
	pop     es
	jne     skip_cache_em

cache_em:
	push    cx
	push    di
	xor     cx,cx                   ; none of it is dirty!!!
	ifdef   USE_VALID
	mov     bx,cache_mask           ; all valid
	endif
	call    create_cache_block      ; **** create the block^
	pop     di
	push    di
	call    write_full_cache_block
	add     curblk_l,1
	adc     curblk_h,0
	pop     di
	pop     cx
	add     di,cache_block_bytes
	loop    cache_em

done_cache_em:
	mov     word ptr d_trans,di     ; update d_trans

;       **** Note:  We're branching all of the way back here so
;            we can test for the case where we've done with all
;            of the full blocks.  A potential speed optimization
;            would be to duplicate the test here, and not bother
;            looking up the next block if there is another one.
;            In that case, we already know it is a hit.  The
;            block number would have to be saved above in this
;            case.

	jmp     no_partial_on_front
skip_cache_em:
	add     curblk_l,1
	adc     curblk_h,0
	add     di,cache_block_bytes
	loop    skip_cache_em
	jmp     short   done_cache_em


;       pass read error condition back to caller.

got_fatal_error:
	les     bx,user_reqblk
	mov     es:[bx.reqstat],ax       ; pass error code back to caller
	mov     es:word ptr [bx.count],0 ; no sectors complete
	ret

;       d_count is now less than a full cache block
;         we are cache block aligned

do_last_partial:
	cmp     d_count,0               ; *IS* there a partial?
	jz      reading_done            ;  skip if not

	call    check_supercache_match
	jc      last_partial_moveit     ; just move it from supercache if so

;       last partial not in supercache.  Try regular cache next.

	call    check_hit               ; is last block in cache?
	jz      need_to_read_last_partial

;       Got it in regular cache!

	ifdef   USE_VALID
	mov     ax,d_count              ; ah=0, al=sectors we need
	call    make_sure_sectors_are_valid ; make sure they're valid
	jc      got_fatal_error         ; BUG1 fatal exit if read error
	endif

	mov     ax,d_count              ; starting with zero, read d_count
	les     di,d_trans
	mov     bp,cache_element_index
	call    read_part_cache_block   ; read it from cache
	jmp     short reading_done      ;  done!  exit okay!

;       We've gotta hit the disk.  Maybe we'll do a readahead too.

need_to_read_last_partial:

	call    readahead_check         ; should we readahead?
	mov     cx,1                    ; just read this one block if we're
;                                       ;  not sequential from last time
	jnz     last_partial_no_readahead

	mov     cx,max_valid_buffers    ; read/cache this many blocks if seq.

last_partial_no_readahead:

	call    get_curblks_into_cache  ; get those suckers into cache
	jnc     last_partial_readok     ; done if no read error

;       read error.  We'd better try reading just exactly what the
;         user requested.

	mov     ah,byte ptr d_count     ; get count
	xor     al,al                   ; start reading from front of block
	les     di,d_trans
	call    read_part_curblk_from_disk
	jnc     reading_done            ; done if read ok!!!
	jmp     got_fatal_error         ; fatal error if disk read error

last_partial_readok:
	mov     si,word ptr local_buf   ; we know the data is in the
					;  front of the local_buf

;       We will enter here when we're moving the data out of the
;       supercache.

last_partial_moveit:

	mov     ax,d_count
	mul     sector_size_bytes
	mov     cx,ax                   ; copy this many
	shr     cx,1                    ; convert to words

	les     di,d_trans
	mov     ds,lb_seg
	assume  ds:nothing
	rep     movsw

	push    cs
	pop     ds                      ; restore addressability
	assume  ds:zseg

reading_done:
	mov     ax,curblk_l
	mov     lastblk_l,ax            ; copy curblk to lastblk
	mov     al,curblk_h
	mov     lastblk_h,al

readwrite_done:
	les     bx,user_reqblk
	mov     es:[bx.reqstat],100h    ; normal completion
	ret                             ; no error checking for now


cache_reads     endp

;-----------------------------------------------------------------------
;
;       subroutine to check to see if curblk is just past lastblk;
;         this condition is used during a read of anything besides
;         a first partial, to trigger readahead.  Zero is set
;         when (curblk-1) == lastblk
;
;       ****Note:  For now, we'll also return zero when curblk==lastblk.
;           Depending on the exact exit path taken, lastblk may or may not
;           be updated to point past the end of the previous read.
;
;       trashes ax, cl

readahead_check proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	mov     ax,curblk_l
	mov     cl,curblk_h
	sub     ax,lastblk_l
	sbb     cl,lastblk_h
	and     al,0feh         ; was result 0 or 1?
	or      al,ah
	or      al,cl           ; set zero flag if so
	ret

readahead_check endp

	ifdef   USE_VALID

;-----------------------------------------------------------------------
;
;       make sure that the currently needed sectors of the current
;         block are indeed valid.  If not, we've gotta read the
;         whole block and mark it valid.
;
;       Entry:  ah=first sector we need, al=number of sectors we need
;       Exit:   carry set if we had a read error
;               ax == error code if carry set   BUG1
;
;       Trashes:  all

make_sure_sectors_are_valid     proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	mov     cx,ax                   ; get our counts into cx
	mov     ax,1
	shl     ax,cl                   ; get one bits for each of ours
	dec     ax
	mov     cl,ch                   ; now shift that for starting place
	shl     ax,cl

make_sure_sectors_are_valid     endp    ; fall into similar routine w/ mask

;-----------------------------------------------------------------------
;
;       make sure that the sectors in the currently looked-up cache
;        block whose mask is in ax are valid.  Otherwise, we've got
;        to force the whole damn cache block to be valid.
;
;       Entry:  ax == mask of sectors required from this block
;       Exit:   carry set if we had a read error
;               ax == error code if carry set BUG1
;
;       Trashes:  all

make_sure_sectors_are_valid_mask        proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	log_it  0               ; tracker:  bambi type zero

	mov     cx,valid_mask           ; here is what's valid
	not     cx
	and     cx,ax                   ; were any of our 1 bits zero bits?
	jnz     make_cache_block_valid

	clc                             ; return with no error
	ret

make_cache_block_valid:

	log_it  1               ; tracker:  bambi type one

	mov     num_valid_buffers,0     ; invalidate supercache

	les     di,local_buf
	mov     ax,1                    ; block count
	push    cx                      ; BUG1 -- save mask of needed sectors
	call    read_curblks_from_disk  ; read it into buffer
	pop     cx                      ; BUG1 -- restore mask of needed secs
	jc      make_cache_readerror    ; skip if read error!!!!

	log_it  2               ; tracker:  time stamp reading done

;       Now we've got to copy only the NON-DIRTY sectors into
;       the cache, so that we don't replace data that hasn't yet
;       made it onto the disk.

	mov     cx,dirty_mask
	not     cx                      ; get NON-DIRTY bits
	and     cx,cache_mask

	xor     ah,ah                   ; ah=0 (sector zero)

;       Here we will assume CX != 0.  If all of the bits in
;       that block were DIRTY, they would also have to be VALID
;       and we'd never be here in the first place.

find_one_to_copy:
	inc     ah                      ; count it
	shr     cx,1
	jnc     find_one_to_copy        ; bypass clean block

	dec     ah                      ; this is the sector number
	xor     al,al                   ; count=1+number of contig ones in cl

find_number_to_copy:
	inc     al
	shr     cx,1
	jc      find_number_to_copy     ; loop while we find more ones

	shl     cx,1                    ; put a zero bit back
	push    cx                      ; save mask

	push    ax                      ; save count
	mov     al,ah                   ; get starting sector
	xor     ah,ah
	mul     sector_size_bytes
	les     di,local_buf            ; find location in disk buffer
	add     di,ax
	pop     ax                      ; restore count

	push    ax                      ; save count again
	mov     bp,cache_element_index
	call    write_part_cache_block  ; write into cache
	pop     ax
	pop     cx                      ; restore continuing mask

	log_it  3               ; tracker: xms written

	add     ah,al                   ; update sector number
	or      cx,cx
	jnz     find_one_to_copy

	mov     bx,cache_mask           ; valid == all
	mov     valid_mask,bx
	mov     cx,dirty_mask
	mov     bp,cache_element_index
	call    set_dirtyindex          ; mark it all valid
	clc
	ret                             ; return with carry set if error

;       BUG1 -- BEGIN NEW CODE!!!!!

;        -- the following error exit was totally messed up
;               in the Win 3.1 version of this code, causing
;               potential data loss in this case of bad adjacent blocks.
;       
;        the block we need is only partially valid, but trying
;        the usual technique of making the whole thing valid
;        won't work because there are bad sectors in the block.
;        We must try to read exactly the missing sectors we
;        need.  If this succeeds, we'll stick them in the
;        cache, otherwise, we'll bomb out with a fatal error.

make_cache_readerror:

;       Here is the old, wrong code.

;BUG1   mov     bp,cache_element_index
;BUG1   call    invalidate_element
;BUG1   stc                             ; return error condition, ax == code
;BUG1   ret

	push    cx                      ; save mask of new sectors to read
	xor     ah,ah                   ; ah=0 (sector zero)

;       Here we will assume cx != 0, because it is the mask of
;       sectors we need which are not valid in the cache.

find_one_to_read:
	inc     ah                      ; count it
	shr     cx,1
	jnc     find_one_to_read        ; bypass unneeded block

	dec     ah                      ; this is the sector number
	xor     al,al                   ; count=1+number of contig ones in cx

find_number_to_read:
	inc     al
	shr     cx,1
	jc      find_number_to_read     ; loop while we find more ones

	shl     cx,1                    ; put a zero bit back
	push    cx                      ; save mask

	push    ax                      ; save count
	mov     al,ah                   ; get starting sector
	xor     ah,ah
	mul     sector_size_bytes
	les     di,local_buf            ; find location in disk buffer
	add     di,ax
	pop     ax                      ; restore count

;       Now we have to read those sectors into the buffer.


	push    ax
	xchg    ah,al                           ; swap count and start
	push    es
	push    di
	call    read_part_curblk_from_disk      ; read the sectors we need
	pop     di
	pop     es
	jc      make_sure_fatal_read_error      ; abort if error
	pop     ax                      ; restore start sector and count

	push    ax                      ; save count again
	mov     bp,cache_element_index
	call    write_part_cache_block  ; write into cache
	pop     ax

	pop     cx                      ; restore continuing mask

	log_it  3                       ; tracker: xms written

	add     ah,al                   ; update sector number
	or      cx,cx
	jnz     find_one_to_read

	pop     ax                      ; get mask of sectors we just cached

	or      valid_mask,ax
	mov     bx,valid_mask
	mov     cx,dirty_mask
	mov     bp,cache_element_index
	call    set_dirtyindex          ; mark new sectors valid
	clc
	ret                             ; return no carry, no error

make_sure_fatal_read_error:
	add     sp,6                    ; get rid of count, running mask, and
;                                       ;  overall mask of missing sectors
	stc                             ; set error condition
	ret                             ; and return with error code in ax

;       BUG1 -- end of new code

make_sure_sectors_are_valid_mask        endp

	endif                           ; ifdef USE_VALID

;-----------------------------------------------------------------------
;
;       Now let's do a write function, caching any data that's
;         appropriate.

cache_write_data        proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	test    flags_and_unit,40h      ; should we delay writes?
	jz      write_without_delay
if 1
	push    es                              ;check if this is a 
	les     si,accessing_swap_file_ptr      ;swapfile access, if so
	cmp     byte ptr es:[si],0              ;dont cache it
	pop     es
	jne     write_without_delay
endif
	jmp     short do_delayed_writes

;       Writes are not delayed.  Just make sure it's all in the
;         cache (except for first partial block with no hit), then
;         pass it through to the driver and return the error.

write_without_delay:
	mov     num_valid_buffers,0     ; invalidate supercache
	cmp     byte ptr curblk_index,0 ; partial block at the front?
	jz      wnodel_no_first_partial

;       count is min (cache_block_sectors - curblk_index, d_count)

	mov     ax,cache_block_sectors
	sub     ax,curblk_index         ; how many left in block?
	cmp     ax,d_count              ; do we want that many?
	jb      wnodel_need_em_all      ; skip if so

	mov     ax,d_count              ; only transfer what we need

wnodel_need_em_all:
	push    ax                      ; save the count
	call    check_hit               ; see if we hit on curblk
	pop     ax                      ; restore count into ax!!!!

	jz      wnodel_first_partial_common

;       the partial block is in the cache.  Better copy in our data.

	push    ax                      ; save sector count
	les     di,d_trans              ; get disk transfer address
	mov     ah,byte ptr curblk_index ; get first sector #

;       Note:  al == transfer count

	call    write_part_cache_block  ; copy partial block into cache

	pop     ax                      ; restore sector count

;       come here to update pointers after dealing with first partial
;          block.  al == number of sectors in first partial

wnodel_first_partial_common:
	sub     d_count,ax              ; keep track of count

	mul     sector_size_bytes       ; bump transfer addr by this much

wnodel_write_next_block:
	add     word ptr d_trans,ax     ; update transfer address
	add     curblk_l,1              ; let's move to next block
	adc     curblk_h,0

;       Now we're block aligned.  Complete any full blocks first.

wnodel_no_first_partial:
	mov     ax,cache_block_sectors
	cmp     ax,d_count              ; do we need a full block?
	ja      wnodel_last_partial     ; skip if no more full blocks

	sub     d_count,ax              ; count it down

	call    check_hit               ; is curblk in cache?
	jz      wnodel_full_common

;       We got a hit!  Must update cache!

	les     di,d_trans              ; get user buffer
	call    write_full_cache_block  ; write the whole block

wnodel_full_common:
	mov     ax,cache_block_bytes    ; update pointer
	jmp     wnodel_write_next_block

;       d_count is now less than a full cache block
;         we are cache block aligned

wnodel_last_partial:
	cmp     d_count,0               ; *IS* there a partial?
	jz      wnodel_done             ;  skip if not

	call    check_hit               ; is last partial in cache?
	jz      wnodel_done             ;  skip if not

	les     di,d_trans

	mov     ax,d_count              ; ah=0, al=count
	call    write_part_cache_block  ;  copy that data into cache

;       Now we've updated the cache to reflect our pending write.
;         Go ahead and do the write, and let the device driver
;         return the error code to the caller.

wnodel_done:
	jmp     call_dd_ureqblk         ;  let dd set return code

;       The writes are being delayed.  Just put everything into
;         the cache with dirty bits set.

do_delayed_writes:
	mov     num_valid_buffers,0     ;data may have been dupped in supercache
					;so invalidate supercache 
					;PARADOX BUG FIX 8/4/92 Scottq

	cmp     byte ptr curblk_index,0 ; partial block at the front?

	ifdef   USE_VALID
	jz      no_partial_to_write
	else
	jnz     must_write_partial
	jmp     no_partial_to_write
	endif

;       we need a mask with curblk_index (known non-zero) low bits
;         clear, and 'count' bits set after that, counting from bit zero.
;         This mask gives the bits which we'll have to set in dirty_bits.

must_write_partial:

;       count is min (cache_block_sectors - curblk_index, d_count)

	mov     cx,cache_block_sectors
	sub     cx,curblk_index         ; how many left in block?
	cmp     cx,d_count              ; do we want that many?
	jb      xbsetup_need_em_all     ; skip if so

	mov     cx,d_count              ; only transfer what we need

xbsetup_need_em_all:

	mov     ax,1
	shl     ax,cl                   ; now put in that many one bits
	dec     ax                      ; convert to mask

	push    cx                      ; save the count
	mov     cl,byte ptr curblk_index
	shl     ax,cl                   ; that many zero bits

	push    ax                      ; save the mask

	call    check_hit               ; see if we hit on curblk

	pop     cx                      ; restore mask into cx!!!!
	pop     ax                      ; restore count into ax!!!!
	push    ax                      ; re-save sector count

;       *****************************************************
;       The following big chunk of code varies greatly between
;       the USE_VALID version and otherwise, so it exists in
;       two separate versions rather than riddling the code
;       with ifdefs
;       *****************************************************

	ifdef   USE_VALID       ; for debugging, use other code
	jnz     wr_partial_was_a_hit    ; brif we hit partial

;                                       ; seed mask is in cx

	mov     bx,cx                   ; only the ones we're writing will
;                                       ;  be valid
	call    create_cache_block
	jmp     short wr_partial_common


wr_partial_was_a_hit:
	or      cx,dirty_mask           ; or with previous mask
	ifdef   USE_VALID
	mov     bx,cx                   ; set all dirty_bits valid
	or      bx,valid_mask
	endif
	call    set_dirtyindex

wr_partial_common:

;       Note!  We've set the dirty_bits before we filled up the
;              buffer.  Good thing we know the commit_cache function
;              can't be running concurrently with this mainline code.

;       copy from cache to local_buf

;       ***  Note:  We really only have to copy the part of the block
;                    that we're not replacing.

	mov     bp,cache_element_index  ;setup cache block index
	les     di,d_trans              ;get pointer to user data
	pop     ax                      ;ax is now actual count
	push    ax                      ;must restore later

	sub     d_count,ax              ;update global sector count
	mov     ah,byte ptr curblk_index;setup for next call

	call    write_part_cache_block  ;write data to xms

	mov     num_valid_buffers,0     ;data may have been dupped in supercache
					;so invalidate supercache
	pop     ax                      ;restore count
	mul     sector_size_bytes       ;adjust to bytes


;       go write next block

	else                    ; ndef USE_VALID

	jnz     wr_partial_was_a_hit    ; brif we hit partial

;                                       ; seed mask is in cx

;       This non-USE_VALID code path may still be used during
;       debugging, so it still has some USE_VALID logic in it

	ifdef   USE_VALID
	mov     bx,cache_mask           ; all valid for now
	endif
	call    create_cache_block      ;  filling up local_buf

;       NOTE:  We really only need to read the first part of the block

	les     di,local_buf
	mov     ax,1
	mov     num_valid_buffers,0     ; invalidate local_buf
	call    read_curblks_from_disk  ; read it into buffer
	jnc     wr_first_partial_common

;       Shit!  read error.  Better invalidate block & bomb!

	call    invalidate_cache_block
	pop     ax                      ; get sector count to write

	push    ax                      ; resave count
	mov     ah,al                   ; count into ah
	mov     al,byte ptr curblk_index        ; get starting sector
	les     di,d_trans
	call    write_part_curblk_to_disk
	pop     dx                      ; restore sector count
	jnc     write_first_partial_recover_ok

	jmp     got_fatal_error

write_first_partial_recover_ok:
	mov     ax,dx                   ; get number of sectors just written
	mul     sector_size_bytes       ; get amount to increase d_trans by
	jmp     short write_next_block

wr_partial_was_a_hit:
	or      cx,dirty_mask           ; or with previous mask
	ifdef   USE_VALID
	mov     bx,cx                   ; set all dirty_bits valid
	or      bx,valid_mask
	endif
	call    set_dirtyindex

;       Note!  We've set the dirty_bits before we filled up the
;              buffer.  Good thing we know the commit_cache function
;              can't be running concurrently with this mainline code.

;       copy from cache to local_buf

;       ***  Note:  We really only have to copy the part of the block
;                    that we're not replacing.

	mov     bp,cache_element_index  ;setup cache block index
	les     di,d_trans              ;get pointer to user data
	pop     ax                      ;ax is now actual count
	push    ax                      ;must restore later

	sub     d_count,ax              ;update global sector count
	mov     ah,byte ptr curblk_index;setup for next call

	call    write_part_cache_block  ;write data to xms

	mov     num_valid_buffers,0     ;data may have been dupped in supercache
					;so invalidate supercache
	pop     ax                      ;restore count
	mul     sector_size_bytes       ;adjust to bytes

	ifdef   USE_VALID
	jmp     write_next_block        ;continue...
	else
	jmp     short write_next_block
	endif

wr_first_partial_common:

	mov     ax,curblk_index         ; get starting index
	mul     sector_size_bytes
	les     di,local_buf
	add     di,ax                   ; point to destination in buffer
	pop     ax                      ; get the actual transfer count
	sub     d_count,ax              ; keep track of count
	mul     sector_size_bytes
	mov     cx,ax
	shr     cx,1                    ; convert count to words

	lds     si,d_trans              ; get disk transfer address
	assume  ds:nothing
	rep     movsw                   ; move the data

	push    cs
	pop     ds
	assume  ds:zseg                 ; restore addressability

	push    ax                      ; save byte count for update

	mov     ax,1                    ; make supercache valid
	call    set_supercache_valid    ;  with one block (curblk)

	les     di,local_buf
	call    write_full_cache_block  ; write that pig thru the cache
	pop     ax                      ; restore byte count

;       go write next block

	endif                           ; ifdef USE_VALID

write_next_block:
	add     word ptr d_trans,ax     ; update transfer address

	add     curblk_l,1              ; let's move to next block
	adc     curblk_h,0

;       Now we're block aligned.  Complete any full blocks first.

no_partial_to_write:
	mov     ax,cache_block_sectors
	cmp     ax,d_count              ; do we need a full block?
	ja      write_last_partial      ; skip if no more full blocks

	sub     d_count,ax              ; count it down

	call    check_hit               ; is curblk in cache?
	jnz     wr_full_was_a_hit       ;  skip if that block is present

	mov     cx,cache_mask           ; fully dirty
	ifdef   USE_VALID
	mov     bx,cx                   ;  and fully valid
	endif
	call    create_cache_block      ;  filling up local_buf
	jmp     short wr_full_common

wr_full_was_a_hit:
	mov     cx,cache_mask           ; mark it fully dirty
	ifdef   USE_VALID
	mov     bx,cx                   ;  and fully valid
	or      bx,valid_mask
	endif
	call    set_dirtyindex

;       okay.  copy that puppy into cache.

wr_full_common:
	les     di,d_trans              ; get user buffer
	call    write_full_cache_block  ; write the whole block
	mov     ax,cache_block_bytes    ; update pointer
	jmp     write_next_block

;       d_count is now less than a full cache block
;         we are cache block aligned

write_last_partial:
	cmp     d_count,0               ; *IS* there a partial?
	jnz     write_last_partial_not_done

	jmp     short writing_done      ;  skip if not

write_last_partial_not_done:

;       figure out our mask bits

	mov     cl,byte ptr d_count
	mov     ax,1
	shl     ax,cl
	dec     ax                      ; convert to mask

	push    ax
	call    check_hit               ; is last partial in cache?
	pop     cx                      ; get new mask bits into cx

;       *********************************************
;       Here is another big block which is different for USE_VALID
;       *********************************************

	ifdef   USE_VALID

	jnz     wr_last_partial_was_a_hit ;  skip if that block is present

	mov     bx,cx                   ; only our writing bits are valid
	call    create_cache_block      ;  filling up local_buf
	jmp     short wr_last_partial_common

wr_last_partial_was_a_hit:
	or      cx,dirty_mask           ; or with previous
	mov     bx,cx                   ; valid=dirty
	or      bx,valid_mask
	call    set_dirtyindex

wr_last_partial_common:

	mov     num_valid_buffers,0     ; invalidate super-cache just in case
	mov     bp,cache_element_index  ;get block index
	les     di,d_trans              ;get pointer to user data

	mov     ax,d_count              ;get final count of last write
	call    write_part_cache_block  ;write data to cache in xms



	else                            ;  ndef USE_VALID

	jnz     wr_last_partial_was_a_hit ;  skip if that block is present

;       ifdef   USE_VALID
;       mov     bx,cache_mask           ; the whole thing is valid
;       endif
	call    create_cache_block      ;  filling up local_buf

;       Note:  We really don't need to read the whole block, only the
;               last part of it.

	les     di,local_buf
	mov     ax,1
	mov     num_valid_buffers,0     ; invalidate supercache
	call    read_curblks_from_disk  ; read it into buffer
	jnc     wr_last_partial_common
	call    invalidate_cache_block

;       Now we should attempt to write the sectors directly to the disk.
;         Only if this fails will we actually report an error.

	les     di,d_trans
	mov     ah,byte ptr d_count     ; count of sectors to write
	xor     al,al                   ; start from front of block
	call    write_part_curblk_to_disk

;       Note:  this may have to be split between the two different
;               places that enter this code path.

	jnc     writing_done            ; done if no error writing

	jmp     got_fatal_error

wr_last_partial_was_a_hit:
	or      cx,dirty_mask           ; or with previous
;       ifdef   USE_VALID
;       mov     bx,cx                   ; valid=dirty
;       or      bx,valid_mask
;       endif
	call    set_dirtyindex

;       copy from cache to local_buf

;           Note:  we really only need to copy the part we aren't filling in.

	mov     bp,cache_element_index  ;get block index
	les     di,d_trans              ;get pointer to user data

	mov     ax,d_count              ;get final count of last write
	;;;     ah=0!
	call    write_part_cache_block  ;write data to cache in xms

	mov     num_valid_buffers,0     ;be sure super-cache is consitent

	ifdef   USE_VALID
	jmp     writing_done            ;outtahere
	else
	jmp     short writing_done      ;outtahere
	endif

wr_last_partial_common:
	les     di,local_buf

	mov     ax,d_count              ; get sectors in last partial
	mul     sector_size_bytes
	mov     cx,ax
	shr     cx,1                    ; convert count to words

	lds     si,d_trans
	assume  ds:nothing
	rep     movsw                   ; move the data
	push    cs
	pop     ds
	assume  ds:zseg                 ; restore addressability

	mov     ax,1
	call    set_supercache_valid    ; mark the supercache as valid

	les     di,local_buf
	call    write_full_cache_block  ; write that pig thru the cache

	endif                           ; ifdef USE_VALID

writing_done:
	jmp     readwrite_done          ; no errors

cache_write_data        endp

;-----------------------------------------------------------------------
;
;       the partial block we need isn't in the cache.  Read the block,
;          and possibly the blocks after it into the cache.  Return
;          as many blocks as can be read successfully (not marked bad,
;          not hits, not read error) in the supercache.  Return carry
;          if we couldn't even read the first block.
;
;       entry:  cx == number of blocks to read & cache.  Those blocks
;               will be left in local_buf on return.
;
;       returns carry set if error on first block
;
;       If count > 1, that means we're doing a readahead.  We haven't
;         actually checked to see if any of that is in the cache.

get_curblks_into_cache  proc    near
	assume  cs:zseg,ds:zseg,es:nothing


	push    cx                      ; save original count
	mov     ax,curblk_l

	mov     dl,curblk_h             ; get last curblk into dl:ax
	mov     dh,original_unit        ; and original_unit into dh
	jmp     short skip_hitcheck_on_1st      ; we already know first block
;                                               ; is a nohit or we couldn't be
;                                               ; here now.


get_curblk_ckhit_loop:
	push    ax
	push    cx
	push    dx                      ; save blocknum & count

	call    check_hit_in_regs       ; is it a hit?

	pop     dx
	pop     cx
	pop     ax
	jnz     get_curblk_ckhit_exit   ; we got a readahead stopper!

skip_hitcheck_on_1st:

	push    cx
	mov     cx,num_bad_blocks
	jcxz    not_bad_block           ; skip if no bads exist

	push    cs
	pop     es      
	mov     di,offset bad_blocks    ; point to list of known baddies
continue_bad_check:
	repnz   scasw                   ; see if this is one.
	jz      might_be_bad            ; OOOPS.  might be bad.  go check rest

;       this block is a candidate for caching.  Loop.

not_bad_block:
	pop     cx
	add     ax,1
	adc     dl,0                    ; adjust block number

	loop    get_curblk_ckhit_loop
	pop     cx                      ; restore the original count

	jmp     short get_curblks_no_rdahead ; go ahead and read the whole thing

;       the low 16 bits matched that of a known bad block.  Let's
;       see if the high 16 do, too.

might_be_bad:
       ;        int 1
	cmp     dx,[di].bad_drives-bad_blocks-2
	jnz     continue_bad_check

	pop     cx                      ; get our loop count from stack

;       fall into the same logic that deals with cache hits.  Stop
;         the read before we get here!

;       we got a hit.  Now we have to figure out how many blocks we
;         can read safely before the hit.

get_curblk_ckhit_exit:
	pop     ax                      ; get original block count
	sub     ax,cx                   ; truncate number past first nohit
	mov     cx,ax
	jcxz    cant_read_any_blocks    ; done if first block marked bad

get_curblks_no_rdahead:
	mov     num_valid_buffers,0     ; invalidate old supercache

	mov     di,offset blockids
	push    cx                      ; save count

	mov     ax,curblk_l
	mov     dl,curblk_h
	mov     dh,original_unit        ; merge unit code into cookie

if 1
	push    es                              ;check if this is a 
	les     si,accessing_swap_file_ptr      ;swapfile access, if so
	cmp     byte ptr es:[si],0              ;dont cache it
	pop     es
	jne     dont_add_to_cache
endif

;       now loop through and create cache blocks for everything we're
;          reading.

get_curblks_00:
	push    cx
	push    dx
	push    ax
	push    di
	xor     cx,cx                   ; create clean cache block before
	ifdef   USE_VALID
	mov     bx,cache_mask           ; all valid, please
	mov     valid_mask,bx           ; set existing valid mask
	endif
	call    queue_element
	pop     di
	pop     ax
	pop     dx
	pop     cx

	add     ax,1
	adc     dl,0                    ; update block number

	mov     word ptr [di],bp        ; save cache block number
	add     di,2
	loop    get_curblks_00


	les     di,local_buf
	pop     ax                      ; get block count
	push    ax                      ;  and re-save on stack
	call    read_curblks_from_disk  ; read them into buffer
	pop     cx                      ; restore block count
	jc      get_curblks_readerror   ; skip if read error!!!!

	mov     ax,cx                   ; get the block count
	call    set_supercache_valid    ;  and mark it valid
	les     di,local_buf
	mov     si,offset blockids
copy_localbuf_into_cache:
	push    si
	push    di
	push    cx
	mov     cx,cache_block_words
	mov     bp,word ptr [si]        ; get cache block number
	xor     si,si                   ; do entire block


	call    buffer_to_cache
	pop     cx
	pop     di
	pop     si

	add     si,2
	add     di,cache_block_bytes    ; update dma pointer
	loop    copy_localbuf_into_cache

	clc
	ret                             ; no errors

cant_read_any_blocks:
	stc                             ; first block was marked bad
	ret

dont_add_to_cache:
	pop     ax
	push    ax
	les     di,local_buf
	call    read_curblks_from_disk  ; read them into buffer
	pop     ax
	jc      mark_curblk_bad

	call    set_supercache_valid    ;  and mark it valid
	clc
	ret                             ; no errors

get_curblks_readerror:
	mov     di,offset blockids

get_curblks_invalidate:
	mov     bp,word ptr [di]
	add     di,2
	push    di
	push    cx
	call    invalidate_element
	pop     cx
	pop     di
	loop    get_curblks_invalidate


;       exit through here if we got a read error.  Actually, we should
;       try to figure out which block was bad, but for now, we'll just
;       assume it was the first one.  Eventually, the problem block
;       will be marked.

mark_curblk_bad:
       ;        int 1
	mov     di,next_bad_entry_ptr
	mov     dx,curblk_l
	mov     bad_blocks[di],dx
	mov     dl,curblk_h
	mov     dh,original_unit
	mov     bad_drives[di],dx

	add     di,2                    ; point to next entry
	cmp     di,MAXBADS*2
	jb      mark_curblk_bad_1
	xor     di,di                   ; next one back to zero
mark_curblk_bad_1:

	mov     next_bad_entry_ptr,di   ; update pointer for next bad sector

	cmp     num_bad_blocks,MAXBADS
	jae     no_incr_numbads
	inc     num_bad_blocks
no_incr_numbads:

	stc                             ; return error condition, ax == code
	ret

get_curblks_into_cache  endp

;-----------------------------------------------------------------------
;
;       this routine is called when we can guarantee that the information
;         in the local_buf is one or more valid cache blocks.  This may
;         save us an XMS transaction if we need that data again soon.
;
;       call with ax == number of valid blocks in local_buf
;                       curblk_l, curblk_h == cache block of first block
;                       original_unit         == the drive it is from

set_supercache_valid    proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	mov     num_valid_buffers,ax
	mov     ax,curblk_l
	mov     bufferblk_l,ax
	mov     al,curblk_h
	mov     ah,original_unit
	mov     bufferblk_h,ax
	ret

set_supercache_valid    endp

;-----------------------------------------------------------------------
;
;       check to see if curblk is in the supercache.  If so, return
;          lb_seg:si pointing to it, ax == number of subsequent blocks present.
;          if not in supercache, return carry false.

check_supercache_match  proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	mov     al,curblk_h
	mov     ah,original_unit
	sub     ax,bufferblk_h
	clc
	jnz     check_supercache_exit   ; exit w/ carry false if no high match

	mov     ax,curblk_l
	sub     ax,bufferblk_l          ; see if we are present
	cmp     ax,num_valid_buffers
	jnc     check_supercache_exit

	push    ax                      ; save number we need to skip
	mul     cache_block_bytes
	mov     si,word ptr local_buf
	add     si,ax                   ; point to curblk in local_buf
	pop     ax
	sub     ax,num_valid_buffers
	neg     ax                      ; get ax == number of blocks present
;                                       ;  at and past curblk
	stc                             ; set carry to indicate success!
check_supercache_exit:
	ret

check_supercache_match  endp

;-----------------------------------------------------------------------
;
;       this routine calculates the number of blocks which can be
;         transferred in the starting partial block.  This count
;         is returned in ax, and is automatically subtracted
;         from d_count.  Also, es:di is pre-loaded to point to
;         the transfer address.
;
;       Preserves:  MUST PRESERVE SI!!

first_partial_setup     proc    near
	assume  cs:zseg,ds:zseg,es:nothing

;       count is min (cache_block_sectors - curblk_index, d_count)

	mov     ax,cache_block_sectors
	sub     ax,curblk_index         ; how many left in block?
	cmp     ax,d_count              ; do we want that many?
	jb      pbsetup_need_em_all     ; skip if so

	mov     ax,d_count              ; only transfer what we need

pbsetup_need_em_all:
	sub     d_count,ax              ; keep track of count
	les     di,d_trans              ; get disk transfer address
	ret

first_partial_setup     endp

;-----------------------------------------------------------------------
;
;       see if the block at curblk is in the cache.
;         alternate entry has block number in dl:ax.
;
;       If found, return:  BP == cache block number
;                          Zero flag clear
;
;       If not found, return: BP == 0ffffh
;                             zero flag true
check_hit       proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	mov     ax,curblk_l
	mov     dl,curblk_h

check_hit_in_regs:
	mov     dh,original_unit        ; merge unit code into cookie

	call    fast_lookup
	mov     dirty_mask,cx           ; save mask of hit element
	ifdef   USE_VALID
	mov     valid_mask,ax           ; save valid mask of hit element
	endif
	cmp     bp,0ffffh
	jz      nohit_count

	add     hit_l,1
	adc     hit_h,0

;       Move that queue entry to head of chain

	;call   bring_queue_entry_to_head
	mov     cache_element_index,bp

	cmp     bp,0ffffh               ; adjust zero flag again
	ret

nohit_count:

	add     nohit_l,1
	adc     nohit_h,0
	mov     cache_element_index,bp
	cmp     bp,0ffffh
	ret

check_hit       endp

;-----------------------------------------------------------------------
;
;       NOTE:  We may get called back at dirty_write here!  This
;               will trash our local_buf!!!!  Be aware!
;
;       Regs:  Input -- CX == initial dirty_bits value
;                       BX == initial valid_bits value (if enabled)

create_cache_block      proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	mov     ax,curblk_l
	mov     dl,curblk_h
	mov     dh,original_unit        ; merge unit code into cookie
	ifdef   USE_VALID
	mov     valid_mask,bx
	endif
	mov     dirty_mask,cx
	call    queue_element
	mov     cache_element_index,bp
	ret

create_cache_block      endp

;-----------------------------------------------------------------------
;
;       this entry is called when we created a cache block and
;         were then unable to fill it completely.

invalidate_cache_block  proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	mov     bp,cache_element_index
	jmp     invalidate_element

invalidate_cache_block  endp

;-----------------------------------------------------------------------
;
;       This puppy reads the cache block (from bp) into memory
;         at es:di.

read_full_cache_block   proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	mov     cx,cache_block_words
	xor     si,si           ; do entire block
	jmp     short read_cache_common

read_full_cache_block   endp

;-----------------------------------------------------------------------
;
;       call with ah=index, al=count

read_part_cache_block   proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	call    mash_for_xms

read_cache_common:
	jmp     cache_to_buffer

read_part_cache_block   endp

;-----------------------------------------------------------------------
;

;       This is similar to read_*_cache_block above except that
;         it uses the block number in cache_element_index instead
;         of bp.

write_full_cache_block  proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	mov     cx,cache_block_words
	xor     si,si           ; do entire block
	jmp     short write_cache_common

write_full_cache_block  endp

;-----------------------------------------------------------------------
;
;       called with al = count to write, ah = starting index

write_part_cache_block  proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	call    mash_for_xms

write_cache_common:
	mov     bp,cache_element_index
	jmp     buffer_to_cache

write_part_cache_block  endp

;-----------------------------------------------------------------------
;
;       call this for partial cache reads/writes.  Calculates
;         cx (word count) and si (index into block) based on
;         ah=sector index, al=sector count

mash_for_xms    proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	push    ax              ; save first sector
	xor     ah,ah
	mul     sector_size_bytes
	mov     cx,ax           ; count for transfer
	shr     cx,1            ; convert to words

	pop     ax              ; restore first sector
	mov     al,ah
	xor     ah,ah
	mul     sector_size_bytes       ; in dx:ax
	mov     si,ax           ; pass to cache manager in dx:si
	ret

mash_for_xms    endp

;-----------------------------------------------------------------------
;
;       this function reads blocks at curblk into memory at
;         es:di.  curblk == 0 is a special case where only
;         a partial read may be needed, depending on the
;         cache_align_factor.
;
;       number of blocks to read is in ax
;
;       returns ax= device driver's return code.
;         carry set if error condition occurred.

read_curblks_from_disk  proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	mul     cache_block_sectors
	mov     our_trans_off,di
	mov     our_trans_seg,es
	mov     our_count,ax

	mov     ax,curblk_l
	mov     dx,word ptr curblk_h
	mov     cx,cache_block_shift

	;The following is a fast 32-bit shift left.  
	;WARNING: assumes CL <=16! 
	;BUG BUG: duped below!

	mov di,0FFFFh           ;      set up to make a mask
	rol ax,cl               ;      
	shl dx,cl               ;      
	shl di,cl               ;      
	mov cx,ax               ;      
	and ax,di               ;      
	not di                  ;      
	and cx,di               ;      
	or  dx,cx               ;      

	sub     ax,cache_align_factor
	sbb     dx,0
	jnb     read_curblk_go

;       we're doing block zero and have to do a partial read

	mov     ax,cache_align_factor
	sub     our_count,ax

	mul     sector_size_bytes
	add     our_trans_off,ax

;       *****  Alternate entry point from lookup_device
;               routine.  Notice that it has already set up the
;               count and transfer address fields.

read_sector_zero:
	xor     ax,ax
	xor     dx,dx
read_curblk_go:

	les     bx,dd_header            ; point to device header
	call    set_start_sector        ; store dx:ax as start sector

	mov     byte ptr rblk_op,devrd
	les     bx,loc_reqblk

	call    call_dd                 ; call device driver

	les     bx,loc_reqblk           ; be sure packet is int es:bx
	mov     ax,es:[bx].reqstat      ; fetch up error code
	rol     ah,1                    ; get ax bit 15 into carry
	ror     ah,1                    ; without trashing ax
	ret

read_curblks_from_disk  endp

;-----------------------------------------------------------------------
;
;       this function reads a fraction of a block at curblk
;         into memory at es:di.  AL=first sector, AH=number of secs.
;         Return carry if disk read error, ax=error code from dev. drvr.

read_part_curblk_from_disk      proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	mov     byte ptr rblk_op,devrd
	jmp     short read_write_part_curblk

read_part_curblk_from_disk      endp

;-----------------------------------------------------------------------
;
;       this function writes a fraction of a block at curblk from
;         memory at es:di.  AL=first sector, AH=number of secs.
;         Return carry if disk write error, ax=error code from dev. drvr.

write_part_curblk_to_disk       proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	mov     byte ptr rblk_op,devwrt

read_write_part_curblk:
	mov     our_trans_off,di
	mov     our_trans_seg,es
	mov     byte ptr our_count,ah
	mov     byte ptr our_count+1,0

	push    ax                      ; save first sector to read

	mov     ax,curblk_l
	mov     dx,word ptr curblk_h
	mov     cx,cache_block_shift

	;The following is a fast 32-bit shift left.  
	;WARNING: assumes CL <=16! 
	;BUG BUG: dupped above!

	mov di,0FFFFh           ;      set up to make a mask
	rol ax,cl               ;      
	shl dx,cl               ;      
	shl di,cl               ;      
	mov cx,ax               ;      
	and ax,di               ;      
	not di                  ;      
	and cx,di               ;      
	or  dx,cx               ;      

	sub     ax,cache_align_factor
	sbb     dx,0

;       We don't actually have to deal with block zero here, because
;         even if our dx:ax sector number goes negative here, the sector
;         within the block will get added back in.  Since that reflects
;         an actual calling program read/write request, we can assume
;         that it will yield a valid sector number (ie: >= 0)

	pop     cx                      ; get the starting sector number
	xor     ch,ch                   ;  within curblk
	add     ax,cx
	adc     dx,0

	les     bx,dd_header            ; point to device header
	call    set_start_sector        ; store dx:ax as starting sector

	les     bx,loc_reqblk
	call    call_dd                 ; call device driver

	les     bx,loc_reqblk           ; be sure packet is int es:bx
	mov     ax,es:[bx].reqstat      ; fetch up error code
	rol     ah,1                    ; get ax bit 15 into carry
	ror     ah,1                    ; without trashing ax
	ret

write_part_curblk_to_disk       endp


;-----------------------------------------------------------------------
;
;       This function stores dx:ax into our local DD request packet
;       as the starting sector.  This is more complicated than it
;       sounds, because we have to take into account the DOS version
;       and whether or not said device supports 32-bit block numbers.

set_start_sector        proc    near
	assume  cs:zseg,ds:zseg,es:nothing

;       ALWAYS store the block into start_l and start_h, in case
;       some errant device driver picks them up there.

	mov     our_startl,ax
	mov     our_starth,dx

	cmp     dos_3x,0        ; are we running on dos 3.x?
	jnz     ss_dos30        ; brif so

;       If we're running DOS 4.0 or later, we'll always try to pass
;       block numbers in 32-bit mode if the driver supports it, since
;       this is (??) the way those versions of DOS work.  Compaq 3.31,
;       on the other hand, will CHOKE if you send it a 32-bit block
;       number for a sector which could otherwise be handled with 16 bits.

	test    es:byte ptr [bx.4],2    ; see if it is 32-bit capable
	jz      ss_use_16

ss_use_32:
	mov     our_start,-1

	ret

ss_dos30:
ss_use_16:
	mov     our_start+2,dx

	mov     our_start,ax

	ret

	
	
set_start_sector        endp

;-----------------------------------------------------------------------
;
;       get actual unit code and physical device header for logical
;         unit in al
;
;       return remapped unit code in al, device header in bp:dx
;         return cx = align factor and sector size code, for use
;          only by dirty_write since it is potentially invalid
;          at mainline entry.

lookup_device   proc    near
	assume  cs:zseg,ds:zseg,es:nothing
	push    bx                      ;note: we use bx instead of
					;bp since bp will need to have
					;a DS override 4 times=8 clocks,4 bytes
					;but push/pop bx = 4 clocks,2 bytes

	xor     ah,ah                   ; extend to 16 bits
	mov     bx,ax                   ; snag the byte field
	mov     al,byte ptr real_cache_units[bx]

	shl     bx,1                    ; index word field
	mov     cx,secsize_and_align_info[bx]
	shl     bx,1                    ; snag dword field
	mov     dx,word ptr real_dd_headers[bx]
	mov     bp,word ptr real_dd_headers[bx+2]       
	pop     bx

	ret

lookup_device   endp

;-----------------------------------------------------------------------
;-----------------------------------------------------------------------
;
;       get the sector size and align factor for the drive in al.
;
;       Must preserve es:bx

get_drive_info  proc    near
	assume  cs:zseg,ds:zseg,es:nothing

	xor     ah,ah                   ; extend to 16 bits
	mov     bp,ax
	shl     bp,1                    ; index word field

	mov     cx,secsize_and_align_info[bp]
	cmp     ch,0ffh
	jz      gotta_set_secsize_and_align

	ret

;       Now we've got to go hit the disk to get sector zero.
;         We can safely assume we're not called from dirty_write
;         because no sector should ever become dirty other than
;         through the main bambi code, which guarantees that said
;         drive has been accessed (logged in).

gotta_set_secsize_and_align:
	push    es
	push    bx

	push    bp                      ; save the word index

;       to calculate the align factor, find the sector address of a
;         cluster -- (123h for my 130Mb hard drive, 21h for 1.44M flop).
;         mask off low bits under cluster mask, subtract from cluster
;         size.  This means 15 for 1.44M, 13 for my 130M drive c:
;
;       My 110M system has a data field starting at sector 1bfh, so the
;         tuning constant is 1.

	mov     num_valid_buffers,0     ; invalidate super-cache
	les     di,local_buf            ; get address of temp buffer
	mov     our_trans_off,di
	mov     our_trans_seg,es
	mov     our_count,1
	
	call    read_sector_zero        ; read bpb
	les     bx,local_buf            ; point back to block we read
	jc      use_defaults

	push    es
	push    bx
	call    verify_bpb
	pop     bx
	pop     es
	jc      use_defaults

continue_info:
	mov     ax,cache_block_bytes
	xor     dx,dx
	div     es:word ptr [bx].0bh    ; get secs/cache block
	push    ax                      ; and save on stack

	mov     al,es:byte ptr [bx].10h ; get nfats
	xor     ah,ah
	mul     word ptr es:[bx].16h    ; times fatsize
	add     ax,es:[bx].0eh          ; add in reserved sectors

;       now we have to add in the number of directory sectors

	mov     bx,es:[bx].11h          ; get number of directory entries
	mov     cl,4                    ; divide by 16 (512 bytepersec/32)
	shr     bx,cl
	add     ax,bx                   ; this is address of first cluster

	neg     ax                      ; get negative of that

	pop     cx                      ; get cache block sectors
	dec     cl                      ; convert count to mask
	and     al,cl                   ; al == align factor
	inc     cl

;       we still need the log2(secs/block) value for the configuration array.

	mov     ah,al
	mov     al,-1

calc_log2_secs_per_block:
	inc     al
	shr     cl,1
	jnz     calc_log2_secs_per_block

	mov     cx,ax

	pop     bx                      ; get index for storing drive config
	mov     secsize_and_align_info[bx],cx

	pop     bx
	pop     es
	ret
use_defaults:
	mov     word ptr es:[di].0bh,200h
	mov     byte ptr es:[di].10h,2
	mov     word ptr es:[di].16,9
	mov     word ptr es:[di].0eh,1
	mov     word ptr es:[di].11h,0
	jmp     short continue_info


get_drive_info  endp

validate_secsize:
	mov     ax,es:word ptr [bx].0bh ; get sector size
	cmp     ax,64                   ; cannot be valid if sector size 
	jb      invalidbootsec          ;  is <64 bytes
vs1:
	shl     ax,1
	jnc     vs1
	jz      check_bpb_mediabyte
	jmp     short   invalidbootsec  

verify_bpb proc near

		; put a sanity check for the boot sector in here to detect
		; boot sectors that do not have valid bpbs. we examine the
		; first two bytes - they must contain a long jump (69h) or a
		; short jump (ebh) followed by a nop (90h), or a short jump
		; (e9h). if this test is passed, we further check by examining
		; the signature at the end of the boot sector for the word
		; aa55h. if the signature is not present, we examine the media
		; descriptor byte to see if it is valid. for dos 3.3, this
		; logic is modified a little bit. we are not going to check
		; signature. instead we are going to sanity check the media
		; byte in bpb regardless of the validity of signature. this is
		; to save the already developed commercial products that have
		; good jump instruction and signature but with the false bpb
		; informations
; that will crash the diskette drive operation. (for example, symphony diskette).

	 cmp    byte ptr es:[bx],0      ; might be bogus Corel and Cronies?
	 je     validate_secsize

	 cmp    byte ptr es:[bx],069h   ; is it a direct jump?
	 je     check_bpb_mediabyte             ; don't need to find a nop
	 cmp    byte ptr es:[bx],0e9h   ; dos 2.0 jump?
	 je     check_bpb_mediabyte             ; no need for nop
	 cmp    byte ptr es:[bx],0ebh   ; how about a short jump.
	 jne    invalidbootsec
	 cmp    byte ptr es:[bx]+2,090h ; is next one a nop?
	 jne    invalidbootsec

; check for non-ibm disks which do not have the signature aa55 at the
; end of the boot sector, but still have a valid boot sector. this is done
; by examining the media descriptor in the boot sector.

check_bpb_mediabyte:

	mov     al,es:[bx].EXT_BOOT_BPB.BPB_MEDIADESCRIPTOR
	 and     al,0f0h
	 cmp     al,0f0h                ; allow for strange media
	 jnz     invalidbootsec

; there were some (apparently a lot of them) diskettes that had been formatted
; under dos 3.1 and earlier versions which have invalid bpbs in their boot
; sectors. these are specifically diskettes that were formatted in drives
; with one head, or whose side 0 was bad. these contain bpbs in the boot
; sector that have the sec/clus field set to 2 instead of 1, as is standard
; in dos. in order to support them, we have to introduce a "hack" that will
; help our build bpb routine to recognise these specific cases, and to
; set up out copy of the bpb accordingly.
; we do this by checking to see if the boot sector is off a diskette that
; is single-sided and is a pre-dos 3.20 diskette. if it is, we set the
; sec/clus field to 1. if not, we carry on as normal.

checksinglesided:
	mov     al,es:[bx].EXT_BOOT_BPB.BPB_MEDIADESCRIPTOR
	cmp     al, 0f0h        ; is it one of the new diskette type?
	je      gooddsk         ; new disks are supported only after 3.2

	test    al,0001h        ; is low bit set? - indicates double sided
	jnz     gooddsk

	cmp     word ptr es:[bx+8],"." shl 8 + "3"
	jnz     mustbeearlier
	cmp     byte ptr es:[bx+10],"2"
	jae     gooddsk

; we must have a pre-3.20 diskette. set the sec/clus field to 1

mustbeearlier:
	mov     es:[bx].EXT_BOOT_BPB.BPB_SECTORSPERCLUSTER,1
	jmp     short gooddsk


	 inc     bx                         ; indicate that boot sector invalid
gooddsk:                                    ; carry already reset
	 clc
	 ret

invalidbootsec:
	 stc
	 ret

verify_bpb endp

if 0
hard_error_hang:
	mov     ax,' '-'A'      ;just leave drive letter blank
	call    warning_pop_up
	jmp short hard_error_hang
endif

PUBLIC resident_initialization
resident_initialization:
	
	push    cs                      ;transient data (stack) gets blown
	pop     ss                      ;away in initqueue, so we have to
;;;hack hack!!
;;;386max's Qcache does an int 13 on TSR, so our resident stack will be
;;;swapped.  We set the temp stack here to the middle of the stack
;;;assuming that the int13 will not use too much stack. We do this
;;;since the stack must be resident, but we dont want to wast space.

	mov     sp,offset cs:temp_res_stack     ;make sure our stack is safe

	mov     cx,cs:number_of_cache_elements
	mov     bx,cs:cache_block_bytes
	mov     dx,cs:ending_address    
	push    dx                      ;save this now, since transient data dies
					;in initqueue
	call    InitQueue
	pop     dx

	add     dx,10h                  ; adjust for PSP size
	mov     ax,3100h                ; terminate, stay resident
	int     21h
	;;;no fall through!


;-----------------------------------------------------------------------

zseg    ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\setmedia\setmedia.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

; 
;This device driver will hook onto interrupt 13 if there is a 1.44Meg
;floppy drive in the system.  Any call to Set Media Type (function ah=18h)
;with ch=80,cl=09 (720k) on a 1.44Meg drive will be monitored.  
;If the real int 13 call fails, the hook code will
;return appropriate return values (including a pointer to a default
;disk parameter table) and set no carry (no error)
;
;


_TEXT segment byte public 'CODE'
	assume cs:_TEXT,ds:_TEXT,es:NOTHING

	org     0

Header:
	dd      -1                      ;device chain link--filled in by dos
DevAttr dw      0C840h                  ;character device attribute word
	dw      Strategy                ;Strategy entry point
	dw      Interrupt               ;Interrupt entry point
	db      '_stmedia'              ;logical device name

RHPtr   dd      ?                       ;Request Header pointer filled in by 
					;Strategy routing

Strategy        proc    far

	mov     WORD PTR cs:[RHPtr],bx
	mov     WORD PTR cs:[RHPTR+2],es
	ret

Strategy        endp

Interrupt       proc    far
	push    ds
	push    es
	push    di
	push    bx
	push    dx

	push    cs
	pop     ds

	les     di,DWORD PTR cs:[RHPtr] ;load Request Header pointer into es:di
	mov     bl,es:[di+2]            ;get command code from RHPtr into bl

	or      bl,bl                   ;We only handle command zero (Init)
	jnz     error_out

	;;;Initialize Driver does all driver initialization. It is 
	;;;located in the transient Code/Data
	;;;Returns driver tail in es:di
	
	mov     word ptr es:[di+3],0100h ;Completed code passed in packet
	call    Initialize_Driver

Return_To_Dos:
	pop     dx
	pop     bx
	pop     di
	pop     es
	pop     ds
	ret

error_out:
	mov     word ptr es:[di+3],8003h ;bad command code in request header
	jmp     short Return_To_Dos

Interrupt       endp

;;; RESIDENT DATA AREA anything here is not freed after initialization

Int_13_Chain    dd      ?


MAX_FLOPPY_DRIVES equ   5               ;maximum number of floppys we support

;;; The following is a default drive parameter for a 720k floppy
Parameter_Table_For_720k_Floppy:
	Specify1        db      0DFh
	Specify2        db      002h
	MotorWait       db      025h
	SecSize         db      002h      
	EOT             db      009h
	RWGap           db      01Bh
	DTL             db      0FFh
	FmtGap          db      050h
	Fill            db      0F6h
	HdSettle        db      00Fh
	MotorStrt       db      004h
	Res1            db      000h
	Res2            db      000h

Floppy_Drive_Info db (MAX_FLOPPY_DRIVES+1) dup (0FFh)


;;;
;;; Int_13_Hook monitors int 13 calls for Set Media Type and
;;; ensures success of that call
;;;
Int_13_Hook     proc    far

	cmp     ah,18h                          ;Set Media Type?
	je      Catch_Set_Media_Type            ;If so, monitor call
Call_Int_13_Chain:                              ;else
	jmp     DWORD PTR cs:[Int_13_Chain]     ;chain to next handler

Catch_Set_Media_Type:
	cmp     ch,79                           ;Are we setting media
	jne     Call_Int_13_Chain               ;to 720k floppy?
	cmp     cl,09h
	jne     Call_Int_13_Chain
	test    dl,80h                          ;ensure it is a floppy..
	jnz     Call_Int_13_Chain

	push bx                                 ;See if this is a 1.44M drive
	xor bx,bx                               ;by walking the table we
Check_Next_Table_Info:                          ;build at startup
	cmp cs:Floppy_Drive_Info[bx],dl         ;drive in table?
	je  Is_In_Table                         ;if so, monitor call
	inc bl        
	cmp bx,MAX_FLOPPY_DRIVES                ;don't pass end of table!
	jb  Check_Next_Table_Info       
	;;; if we get here, the drive was not in our table
Not_In_Table:
	pop bx                                  ;restore stack 

	jmp     short   Call_Int_13_Chain       ;chain on to handler

Is_In_Table:                                    ;Monitor the call...
	pop bx

	pushf                                   ;by setting iret frame
	call    DWORD PTR cs:[Int_13_Chain]     ;and calling next handler

	jnc     CLC_IRET                        ;don't hack if no error!

Use_Our_Table:                                  ;"real" didn't work, so fake it
	xor     ah,ah                           ;set no error 
	push    cs                              ;set return in es:di
	pop     es                              ;to point to valid dp table
	mov     di,OFFSET cs:Parameter_Table_For_720k_Floppy

CLC_IRET:
	push    bp                              ;be sure caller gets no carry
	mov     bp,sp                           ;by modifying the flag
	and     WORD PTR ss:[bp+6],0FFFEh       ;on the stack
	pop     bp                              ;thanks to bp
	iret                                    ;return no carry to caller
Int_13_Hook     endp


;
;       WARNING!        Transient Code/Data begins here
;                       All code and data after this point
;                       is freed after initialization call zero
;
SignOn:  
;        db      0Dh,0Ah
;        db      'Int 13 Set Media Type Fix Driver'
;        db      0Dh,0Ah,'$'

Initialize_Driver proc near

	push    es                      ;save pointer to Request Header
	push    di                      ;

	;;;Don't put up a sign-on banner, as it just clutters up the screen.
	;mov     ah,09h                  ;Print out a the sign on message
	;mov     dx,offset       SignOn
	;int     21h

	;;;Now we determine what drives need our fix. Return value
	;;;in BX is number of drives needing the fix. Zero means
	;;;there are no drives that need monitoring, so we don't need to load
	call    Setup_Floppy_Drive_Info_Table 
	or      bx,bx                   ; don't load if table is empty
	jz      Dont_load

	;;;     If we get here, we do need to monitor some floppy drive

	call    Hook_ISR_13             ;Hook int 13 interrrupt routine
	pop     di                      ;restore Request Header pointer
	pop     es                      ;into es:di

	mov     WORD PTR es:[di+0Eh],offset SignOn ;resident up to Signon
	mov     WORD PTR es:[di+10h],cs            ;the rest is free'd
	
	xor     ax,ax                   ;return no error
	jmp     short   return_resident_init
Dont_Load:
	;;;     If we get here, we don't need to load at all

	pop     di                      ;restore Request Header pointer
	pop     es

	mov     WORD PTR es:[di+0Eh],offset Header ;return pointer to header
	mov     WORD PTR es:[di+10h],cs            ;to indicate don't load

	mov     ax,7FFFh                           ;also clear high bit
	and     WORD PTR cs:DevAttr,ax             ;of attribute word
						   ;so next driver will load
						   ;on top of us

	xor     ax,ax                              ;return no error
return_resident_init:
	ret
Initialize_Driver endp

;;;     Returns zero in BX if table is empty
;;;
Setup_Floppy_Drive_Info_Table proc near

	push    es              ;save necessary but smashed registers
	push    bp
	push    di
	push    si
	push    cx

	xor     dx,dx           ;dx is drive id starting at zero
	mov     bx,dx           ;bx is table index starting at zero
	
Check_Next_Floppy_Id:
	mov     bp,bx           ;save off table index into bp
	mov     si,dx           ;save off current drive id into si

	mov     ah,08h          ;Get Drive Parameters
	int     13h             ;
	jc      Not_A_144MFloppy_Drive
	;;; Mohanraj says don't trust bl return,check actual size
	; cmp     bl,04h
	cmp     cx,4f12h
	jne     Not_A_144MFloppy_Drive

	mov     bx,bp           ;restore table index
	mov     dx,si           ;restore drive id
	mov     BYTE PTR Floppy_Drive_Info[bx],dl  ; save drive id in table
	

	inc     bx              ;set up for next table index

	cmp     dl,7Fh          ;7F is last possible floppy drive id
	jae     Done_Setting_Up

	inc     dl              ;set up for next drive id
	 
	cmp     bx,MAX_FLOPPY_DRIVES   ;don't go past the end of the table!                          
	jae     Done_Setting_Up

	jmp     short Check_Next_Floppy_Id

Not_A_144MFloppy_drive:
	mov     bx,bp           ;restore table index
	mov     dx,si           ;restore drive id

	cmp     dl,7Fh          ;7F is last floppy id, dont go further!
	jae     Done_Setting_Up
	inc     dl              
	jmp     short Check_Next_Floppy_Id

Done_Setting_Up:
	pop     cx              ;restore registers we smashed
	pop     si
	pop     di
	pop     bp
	pop     es
	ret
Setup_Floppy_Drive_Info_Table endp


Hook_ISR_13     proc    near

	    push es
	    push di
	    
	    mov ax,3513h                 ; save interrupt 13 vector
	    int 21h                      ; returns in es:bx

	    mov WORD PTR cs:Int_13_Chain,bx
	    mov ax,es
	    mov WORD PTR cs:Int_13_Chain[2],ax

	    mov dx,offset Int_13_Hook    ;patch interrupt 13 vector with
	    mov ax,2513h                 ;our own routine
					 ;assumes ds already holds code segment
	    int 21h

	    pop di
	    pop es
	    ret

Hook_ISR_13     endp
_TEXT ends

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\bambi.inc ===
MULT_BAMBI              equ     04a10h          ;int 2f multiplex interface
BAMBI_SIGNATURE         equ     0BABEh
BAMBI_GET_STATS         equ     0               
BAMBI_COMMIT_ALL        equ     1
BAMBI_REINITIALIZE      equ     2
BAMBI_CACHE_DRIVE       equ     3
BAMBI_GET_INFO          equ     4
BAMBI_GET_BUFFER_INFO   equ     5
BAMBI_DONT_CACHE_DRIVE  equ     6
BAMBI_GET_ORIGINAL_DD_HEADER equ 7

CACHE_DRIVE_GET         equ     0
CACHE_DRIVE_READ_ENABLE equ     1
CACHE_DRIVE_READ_DISABLE equ    2
CACHE_DRIVE_WRITE_ENABLE equ    3
CACHE_DRIVE_WRITE_DISABLE equ   4


ERROR_NO_XMS_DRIVER     equ     1       ;errors returned by xms.asm
ERROR_ALLOCATION_FAILEd equ     2


COMMAND_LINE_OFFSET     equ     80h     ;offset from starting segment of command line
COMMAND_LINE_TERMINATOR equ     0Dh     ;carriage return ends command line
MAX_COMMAND_LINE_LENGTH equ     80h     ;maximum length of command line is 128 chars
COMMAND_SWITCH_CHAR     equ     '/'     ;the switch indicator
ELEMENTS_FLAG           equ     'n'
ELEMENT_SIZE_FLAG       equ     'e'
FLUSH_FLAG              equ     'c'
STATUS_FLAG             equ     's'
DRIVE_FLAG              equ     'd'
BUFFER_FLAG             equ     'b'
RESET_FLAG              equ     'r'
VERBOSE_FLAG		equ	'v'
QUIET_FLAG		equ	'q'
BEEP_FLAG               equ     '!'     ;bug bug debugging
LOAD_LOW_FLAG           equ     'l'
COMMIT_FLAG             equ     'y'


SCANCODE_RETRY          equ     13h
ASCIICODE_RETRY         equ     'R'
SCANCODE_IGNORE         equ     17h
ASCIICODE_IGNORE        equ     'I'



READ_CACHE              equ     1
WRITE_CACHE             equ     2
NO_CACHE                equ     0

;constants for drvtype.asm
INVALID_TYPE    EQU 0
FLOPPY_TYPE     EQU 1
REMOTE_TYPE     EQU 2
HARDDISK_TYPE   EQU 3
RAMDRIVE_TYPE   EQU 4 
CDROM_TYPE      EQU 5
MEMORY_TYPE     EQU 6
MAGIC_TYPE      EQU 7


;constants for detect processor
CPU086088       equ     0
CPU186          equ     1       ;not detected here
CPU286          equ     2
CPU386          equ     4
CPU486ORABV     equ     8



MINIMUM_CACHE_SIZE      equ     16      ;minimum legal cache size in K (must be >= 16)


smart_win_access        struc                   ;meaning (maintained by)
	accessing_swap_file     db      ?       ;current access swap file? (windows)
	enhanced_mode_flags     db      ?       ;current write is lazy? (smartdrv,windows)
	delay_write_drive_unit  db      ?       ;unit of lazy write (smartdrv)
	max_delayed_write_size  dw      ?       ;maximum lazy write size (smartdrv)
smart_win_access        ends

THIS_WRITE_IS_LAZY      equ     1
WRITE_IS_PENDING        equ     2
ENHANCED_MODE_WIN       equ     4



Win386_Startup_Info_Struc STRUC
	SIS_Version_High        db      ?
	SIS_Version_Low         db      ?
	SIS_Next_Dev_Ptr        dd      ?
	SIS_Virt_Dev_File_Ptr   dd      ?
	SIS_Reference_Data      dd      ?
	SIS_Instance_Data_Ptr   dd      ?
Win386_Startup_Info_Struc ENDS


;BAMBI_VERSION_BCD      equ     0400h           
;BAMBI_VERSION_BCD      equ     0401h           ;7/30/92 scottq
BAMBI_VERSION_BCD       equ     0410h           ;11/11/92 scottq

;;;MAGIC DRIVE INTERFACE added 7/30/92 Scottq
MD_STAMP                equ "DM"        
MAGICDRV_2F             equ 4a11h
MAGICDRV_DETECT         equ    0
MAGICDRV_MAP            equ    1
MAGICDRV_SWAP           equ    2
MAGICDRV_SMART1         equ    3
MAGICDRV_SMART2         equ    4
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\bambinit.asm ===
page	,132

;
;	Cache initialization module
;

;tracker	=	0ffffh
tracker = 0

include devsym.inc	; get device driver structure definitions
include dpb.inc
include bambi.inc
PUBLIC	initialize

;extrn	 ismsdos			 :far
zseg	segment	public 'code'

	assume	cs:zseg

;
;	data from umbload.asm
;
extrn	myPSP				:word
extrn	savestrategy			:word
extrn	saveumblink			:word

extrn	warning_pop_up			:near
;
;	data from rdata.asm
;
extrn	dos_3x				:word
extrn	last_buffer			:word
extrn	max_valid_buffers		:word
extrn	block_buffer			:byte
extrn	ending_address			:word
extrn	processor_type			:byte

extrn	real_dd_headers			:dword
extrn	real_cache_units		:byte
extrn	secsize_and_align_info		:word
extrn	cache_block_bytes		:word
extrn	driver_hooks			:byte

extrn	loc_req_seg			:word
extrn	lb_seg				:word

extrn	first_instance			:byte
extrn	number_of_cache_elements	:word
extrn	number_of_cache_elements_win	:word
extrn	drives_to_cache			:byte

extrn	queuelength			:word

extrn	elementidentifierhiwordoffset	:word
extrn	elementidentifierlowordoffset	:word
extrn	dirtyindexoffset		:word
extrn	word_masks			:byte
	ifdef	USE_VALID
extrn	validindexoffset		:word
	endif
;
;	data from text.asm
;
extrn	msg_xms_memory_error		:byte
extrn	msg_no_himem			:byte 
extrn	msg_version_fail		:byte
extrn	msg_installed			:byte
extrn	msg_in_dos_box			:byte
extrn	msg_too_large			:byte
;
;	routines from bambi.asm
;
extrn	our_int				:far
extrn	our_strat			:far
extrn	resident_initialization		:near
;
;	routines from int2f.asm
;
extrn	call_bambi			:near
extrn	initialize_int2f		:near

;
;	routines from cmdline.asm
;
extrn	parse_command_line		:near
extrn	display_status			:near
extrn	be_quiet			:word
extrn	load_low			:byte
;
;	routines from cacheman.asm
;
extrn	initialize_cache		:near
extrn	halt_cache			:near
;
;	routines from hooksini.asm
;
extrn	init_bambi_io			:near
extrn	hook_ints			:near
;
;	routines from drvtype.asm
;
extrn	setup_default_drive_list	:near

;
;	routines from indosbox.asm
;
extrn	in_dos_box			:near
;
;	routines from get_dbp.asm
;
extrn	get_dpb				:near
;
;	routines from xms.asm
;
extrn	query_free_xms_memory		:near
extrn	initialize_xms			:near
;
;	data from queueman.asm
;
extrn	queue_nextoffset		:word
extrn	queue_prevoffset		:word
;
;	routines from pdetect.asm	
;
extrn	detect_processor		:near
;
;	routines from dec_out.asm
;
extrn	set_thousands_separator		:near
;
;	routines from logphys.asm
;
extrn	compute_logical_to_physical 	:near


extrn	msg_dos_access			:byte
extrn	msg_dos_access2			:byte
extrn	shutupmsdosflag			:byte
extrn	warnmsdosmessage		:byte
extrn	display_dec_dword		:near

ENVSEGOFFSETINPSP equ 02Ch

PUBLIC dos_size
PUBLIC win_size

dos_size	dw	512		;default size--here if query fails
win_size	dw	512		;default size--here if query fails

dosinfo		dw	?
actual_buffer_size	dw	?
target_buffer_size	dw	16384		; use 16K buffer by default
PUBLIC target_buffer_size
PUBLIC msg_and_fail
PUBLIC dosinfo
PUBLIC display_message

display_message:
	mov	ah,9
	int	21h
	stc
	ret

initialize:
;	int 3
;	mov	ax,1234h
;	call	call_bambi

	cld
	push	cs
	pop	ds
	assume	ds:zseg

	mov	loc_req_seg,cs		; set up a quick reference constant

;	set up the save_it vector for tracker

	if	tracker

tracker_mux	=	0c500h		; tracker's int2f mux number

	extrn	save_it_off:word,save_it_seg:word

	mov	save_it_seg,cs		; just in case, set up the far return

	push	es
	mov	ax,tracker_mux
	int	2fh
	or	ax,ax
	jnz	no_tracker

	mov	save_it_off,bx
	mov	save_it_seg,es		; save entry point to log routine

no_tracker:
	pop	es

	endif

	xor	ax,ax
;	call	ismsdos dont do this, instead do next line...
	or	ax,2000h	

	push	ax
	push	bx

	mov	ah,30h			; get DOS version
	int	21h
	cmp	al,3			; 3.x is special case, earlier fails
	ja	version_ok

	jb	version_fail
	cmp	ah,10			; must be 3.1 or greater
	jae	version_3_ok

version_fail:
	add	sp,4
	mov	dx,offset cs:msg_version_fail
msg_and_fail:
	call	display_message
	jmp	dont_load_exit

version_3_ok:
	mov	dos_3x,-1		; set flag for DOS 3.x

version_ok:

	mov	ax,dos_3x
	add	dosinfo,ax

	call	set_thousands_separator

	mov	ax,BAMBI_GET_STATS	; get stats also used for detection
	call	call_bambi
	cmp	ax,BAMBI_SIGNATURE	; ax = signature if bambi is loaded
	jne	bambi_already_resident
	mov	cs:first_instance,0	; bambi is already resident

	mov	be_quiet, 0		; don't be quiet if already resident


bambi_already_resident:
	pop	bx
	pop	dosinfo

	call	setup_default_size
	call	setup_default_drive_list ; select default drives to cache
					; list may be modifed by parsing

	call	compute_logical_to_physical 

	call	parse_command_line
	jc	just_exit

warnmsdos:
	cmp	shutupmsdosflag,1
	je	dontwarn
	cmp	warnmsdosmessage,1
	jne	dontwarn

	push	bp
	mov	dx,offset msg_dos_access
	call	display_message
	pop	ax
	xor	dx,dx
	call	display_dec_dword	
	mov	dx,offset msg_dos_access2
	call	display_message

dontwarn:
	
	cmp	cs:first_instance,0
	jne	short_jump_around

just_status:
	call	display_status
just_exit:
	jmp	dont_load_exit
short_jump_around:
	call	in_dos_box			;are we in a dos box (zero flag set)
	jnz	not_in_dos_box
	mov	dx,offset cs:msg_in_dos_box
	call	display_message			
	jmp	dont_load_exit	


not_in_dos_box:

	call	detect_stacker_volume

;	calculate quick reference constants


;	initialize secsize_and_align_info to 'unknown'

	push	cs
	pop	es
	mov	di,offset secsize_and_align_info
	mov	ax,0ffffh		; align factors & secsize unknown
	mov	cx,26
	cld
	rep	stosw


;;;	calculate memory locations of data structures

;	see how big our buffer should be.  We'll use target_buffer_size
;	  as an attempt, but we'll round it up to our block size.

	mov	ax,target_buffer_size
	cmp	ax,cache_block_bytes
	jae	target_ok
	mov	ax,cache_block_bytes	;target buffer must be at least 1 block
target_ok:
	xor	dx,dx
	div	cache_block_bytes	; get number of full buffers
	add	dx,-1			; force carry if any remainder
	adc	ax,0			;  and round up
	mov	max_valid_buffers,ax	; save it
	dec	ax			; get one less for last buffer
	mul	cache_block_bytes	; find start of last buffer
	;add	ax,offset block_buffer
	mov	last_buffer,ax		;  and save pointer for dirty_write

	add	ax,cache_block_bytes	; allocate last buffer, too
	mov	actual_buffer_size,ax

;;;
	mov	dx,offset block_buffer	
;;;
	;mov	dx,ax

;	See if masks are words or bytes and set variable accordingly.

	mov	ax,cache_block_bytes	; get cache block size
	add	ax,-8192		; set carry if >= 8192
	sbb	al,al			; propogate carry across al
	mov	word_masks,al		; set word_masks value

;	mov	word_masks,0		; continue using word_masks=0 for
;					;  now until word masks are better
;					;  tested.

;	now allocate cache data arrays at cs:dx

	mov	cs:dirtyindexoffset,dx

	mov	ax,number_of_cache_elements

	cmp	cs:word_masks,0		; are we using word masks?
	jz	init_with_byte_masks	; brif so
	shl	ax,1			; allocate 1word per array element
init_with_byte_masks:
	add	dx,ax
	jc	too_large_for_memory
	ifdef	USE_VALID
	mov	cs:validindexoffset,dx
	add	dx,ax
	jc	too_large_for_memory
	endif

	cmp	cs:word_masks,0		; if we just allocated byte masks,
;					;  now we've got to adjust our
;					;  array size value for word arrays.
	jnz	init_with_word_masks
	shl	ax,1			; following arrays are words
init_with_word_masks:

	mov	cs:ElementIdentifierHiwordOffset,dx
	add	dx,ax
	jc	too_large_for_memory
	mov	cs:ElementIdentifierLowordOffset,dx
	add	dx,ax
	jc	too_large_for_memory
	mov	cs:queue_nextoffset,dx
	add	dx,ax
	jc	too_large_for_memory
	mov	cs:queue_prevoffset,dx
	add	dx,ax
	jc	too_large_for_memory
	add	dx,0fh
	jc	too_large_for_memory
	mov	cl,4
	shr	dx,cl			; calculate ending address
	mov	cs:ending_address,dx


	mov	cx,cs:number_of_cache_elements

	cmp	cx,2
	jb	allocation_error		;must be at least 2 cache blocks

	mov	cs:queuelength,cx
	mov	bx,cs:cache_block_bytes

	push	dx
	call	initialize_cache
	pop	dx
	jnc	no_xms_error

error_allocating_XMSmemory:
	cmp	ax,ERROR_NO_XMS_DRIVER
	jne	allocation_error
	mov	dx,offset cs:msg_no_himem
	jmp	short xmserrormessage
allocation_error:
	mov	dx,offset cs:msg_XMS_memory_error
xmserrormessage:
	call	display_message
	jmp	short	dont_load_exit
too_large_for_memory:
	mov	dx,offset cs:msg_too_large
	call	display_message
	jmp	short dont_load_exit



	;;; called from below if we could not allocate our buffer
	;;; in a UMB
no_umb:		      	

	;;;	we were unable to allocate our buffer into umb, however
	;;;	it may fit in the code's block. 
	mov	ax,cs
	add	ax,cs:ending_address
	mov	cs:lb_seg,ax
	mov	ax,cs:actual_buffer_size
	mov	cl,4
	shr	ax,cl
	add	cs:ending_address,ax	;add buffersize onto TSR chop off point

	mov	bx,cs:ending_address	;save for use with memory size check
	add	bx,10h			;adjust for PSP
	push	es
	mov     es,cs:myPSP		;es = segment to shrink
	
	mov	ax,cs
	add	bx,ax
	cmp	word ptr es:[2],bx
	

	;mov     ah,4ah          	;AH = modify memory block
	;int     21h             	;free excess memory
	pop	es
	;;;	if carry is set, we dont fit into this memory block
	;;;	with code and data
	;;;	BUG BUG assume that means we are in a too small UMB
	;;;	so exit back to umbload to load code low 
	jc	dont_load_exit
	
	jmp	short allocate_computed

explicitely_disable_umbs:
	;;;	here, we disable umb allocation, but continue with the
	;;; 	allocation.  We do this so the user can use
	;;;	loadhi to get the CODE to load high, but the /L
	;;;	switch will force the buffer low.

	mov     ax,5803h        ;link/unlink UMBs bx = 0 is unlink,bx =1 is link
	mov     bx,0		;enable umb links
	int     21h
	jmp	short	continue_alloc


dont_load_exit:
	call	Halt_Cache
	mov	ax,4c01h		; error code must be 1 for umbload.asm
	int	21h

no_xms_error:

	;;;	now allocate the big buffer
	;;;	first we try to allocate it in a UMB. If this fails,
	;;;	we tack it on to the code and chop off with TSR.
	;;;	The reason we do it like this is so we can be sure
	;;;	our initialization code is not tromped before we
	;;;	are done initializing.

	cmp	load_low,1
	je	explicitely_disable_umbs

        mov     ax,cs
        cmp     ax,0a000h
        ja      no_umb          ; we are already in a umb, so append
                                ; we know there is space since we loaded

	mov     ax,5803h        ;link/unlink UMBs bx = 0 is unlink,bx =1 is link
	mov     bx,1		;enable umb links
	int     21h
	jc	no_umb

      	mov	ax,5801h
      	mov	bl,40h		;(assume bh zero) first-fit high only
      	int	21h

continue_alloc:
	mov	ah,48h
	mov	bx,actual_buffer_size	;size of block buffer
	mov	cx,4
	shr	bx,cl			;paragraphs
	int	21h			;segment in AX if no error
	jc	no_umb
	
	mov	cs:lb_seg,ax
	;;;
allocate_computed:
			       
	call	detect_processor
	mov	processor_type,al

;WARNING--POINT OF NO RETURN--device drivers will be hooked and
;intterrupts too, so after this point TSR is the only way to exit!
;
;	int	3
	call	init_drive_info		

	;;;	drives_to_cache is setup in command line parsing
	mov	cx,26
loop_drive:
	mov	bp,cx
	mov	al,drives_to_cache[bp-1]
	cmp	al,NO_CACHE
	je	dontcachethisdrive
	cmp	al,READ_CACHE
	mov	al,3Fh		;assume read/write
	jne	read_write
	mov	al,7fh		;read only
read_write:
	push	cx
	dec	cx
	call	cache_drive
	pop	cx
dontcachethisdrive:
	loop	loop_drive


	call	initialize_int2f
	call	init_bambi_io

	call	hook_ints


	call	display_status

	cmp	be_quiet,0
	jne	no_display
	mov	dx,offset cs:msg_installed
	call	display_message
no_display:

	call 	hook_drives

	mov     ax,5803h        ;link/unlink UMBs bx = 0 is unlink,bx =1 is link
	mov     bx,saveumblink	;disable umb links
	int     21h

	mov	ax,5801h
	mov	bx,cs:savestrategy	
	int	21h

	;;; free the environment
	mov	es,cs:myPSP
	mov 	es,es:ENVSEGOFFSETINPSP
	mov	ah,49h
	int	21h

	jmp	resident_initialization	;initialize dynamic data, TSR

;
;INPUT
;	cx = drive letter to cache (one based)
;	ah = C0h if no cacheing is done, 0h if caching is done
;OUTPUT
;	none
info_drive proc near
	push	es
	push	ds
	push	bp
	push	bx
	push	dx

	mov	dl,cl
	call	get_DPB
	jc	info_drive_done

	mov	bp,cx
	dec	bp

	;;; save off the unit codes (byte fields)

	mov	al,byte ptr ds:[bx].DPB_UNIT ; get unit code for this logical drive
	or	al,ah			; set high bits (C0h) if no cacheing
	mov	byte ptr cs:real_cache_units[bp],al
	mov	dx,bp
	mov	byte ptr ds:[bx].DPB_UNIT,dl
	
	shl	bp,1
	shl	bp,1	

	add	bx,cs:dos_3x			; adjust for DOS 3.x dpb

	mov	ax,ds:word ptr [bx].DPB_DRIVER_ADDR ; get original driver address
	mov	word ptr cs:real_dd_headers[bp],ax	; and save it
	mov	ax,ds:word ptr [bx].DPB_DRIVER_ADDR+2
	mov	word ptr cs:real_dd_headers[bp+2],ax
	
info_drive_done:
	pop	dx
	pop	bx
	pop	bp
	pop	ds
	pop	es
	ret
info_drive endp

init_drive_info proc near
	mov	cx,26

init_this_drive:
	mov	ah,0C0h  ; initalize all drives to no-cacheing
	call	info_drive
	loop	init_this_drive
	ret
init_drive_info endp

;
;INPUT
; 	cx = drive to cache (0 based)
;	al = read/write mask =
;		3F -> read/write
;		7F -> read only
;OUTPUT
;	none
cache_drive proc near
	push 	bx
	mov  	bx,cx
	and  	byte ptr cs:real_cache_units[bx],al ;mask off high bits
	;;bug bug read/write both set!
	pop  	bx
	ret	
cache_drive endp

hook_drives proc near
	;int 3

	push	ds
	push	es


	;jmp	rope
	push	ds
	push	es
	push	bp
	push	si
	push	di

	mov	ah,52h
	int	21h
	add	bx,34
	;;;	es:bx->device header chain
	push	es
	pop	ds
	mov	bp,bx
	;;;	ds:bp->device header chain

	xor	di,di			; di is index into new header table
next_chain:
	les	bx,es:[bx]
	cmp	bx,-1
	je	done_walking_device_chain
	test	word ptr es:[bx].sdevatt,8000h		;block device?
	jnz	next_chain
	;;;	copy device header into our table

	mov	ax,es:[bx].sdevatt
	mov	cs:driver_hooks[di].sdevatt,ax


	mov	ax,word ptr es:[bx].sdevname[0]
	mov	word ptr cs:driver_hooks[di].sdevname[0],ax
	mov	ax,word ptr es:[bx].sdevname[2]
	mov	word ptr cs:driver_hooks[di].sdevname[2],ax
	mov	ax,word ptr es:[bx].sdevname[4]
	mov	word ptr cs:driver_hooks[di].sdevname[4],ax
	mov	ax,word ptr es:[bx].sdevname[6]
	mov	word ptr cs:driver_hooks[di].sdevname[6],ax

	;;;	point new header to our entry points

	mov	ax,offset cs:our_int
	mov	cs:driver_hooks[di].sdevint,ax
	mov	ax,offset cs:our_strat
	mov	cs:driver_hooks[di].sdevstrat,ax

	
	;;;	hook into front of device chain

	cli     ; better safe than sorry..
	mov	si,word ptr ds:[bp]
	mov	dx,word ptr ds:[bp+2]
	mov	ax,offset cs:driver_hooks
	add	ax,di
	mov	word ptr ds:[bp],ax
	mov	word ptr ds:[bp+2],cs
	mov	word ptr cs:driver_hooks[di].sdevnext[0],si
	mov	word ptr cs:driver_hooks[di].sdevnext[2],dx
	sti

	push	cs
	pop	ds
	mov	bp,ax


	;;;	update any DPB that points to the replaced driver header
	;;;	to point to the new driver header
	;;;	right now, es:bx points to old driver,
	;;;	ds:bp points new new header
	;;;
	call	update_dpbs

	add	di,size sysdev

	jmp	next_chain
done_walking_device_chain:
	
	pop	di
	pop	si
	pop	bp
	pop	es
	pop	ds

rope:

	pop	es
	pop	ds
	clc
	ret

hook_drives endp


STACKER_DD struc
dv_strategy	dd	1 dup(?)	;physical device driver strategy addr
dv_interrupt	dd	1 dup(?)	;physical device driver interrupt addr
dv_att		dw	1 dup(?)	;device driver header attributes
dv_cluster0	dw	1 dup(?)	;first file cluster of
dv_log2		db	1 dup(?)	;LOG base 2 of physical bytes/sector
dv_unit		db	1 dup(?)	;physical device driver unit number
STACKER_DD ends


extrn	detect_stacker		:near
extrn	detect_stacker_volume	:near
extrn	stacker_dd_pointer	:near

;;;	right now, es:bx points to old driver,
;;;	ds:bp points new new header
;;;
update_dpbs proc near
	push	cx
	push	ds
	push	es
	push	bx
	push	si
	push	di
	push	dx
	push	bp

	mov	di,ds
	mov	si,bp

	mov	bp,bx
	mov	cx,es
	;;;	now cx:bp points to old driver, di:si points to new
	mov	dx,1

loop_dpb:
	
	push	ax
	push	bx
	push	cx
	push	dx
	push	bp
	push	es
	push	ds
	push	si
	push	di
;;;
;;; New code added in Astro to detect magic drives 7/30/92 scottq
;;;

        push    bx
        push    dx
        mov     ax,MAGICDRV_2F          ;is magicdrv installed?
        mov     bx,MAGICDRV_DETECT      
        push    cx
        int     2fh
        pop     cx
        cmp     bx,MD_STAMP
        pop     dx
        pop     bx
        jne     not_magicdrive

        push    bx
        mov     ax,MAGICDRV_2F          ;get magicdrv's host unit 
        mov     bx,MAGICDRV_SMART1
        mov     cx,dx
        dec     cx
        int     2fh
        pop     bx
        cmp     cl,0FFh                 ;FF means this is not a magicdrv unit
        je      not_magicdrive

        ;;;right now, cl holds the host driver unit number for the magicdrv
        ;;;es:di->interrupt,es:si->strategy

        ;;;here, we scan smartdrv's list to find the re-mapped unit number
        ;;;this is the unit number magicdrv should use to call the smartdrv
        ;;;entry points for this drive.
        ;;;NOTE smartdrv's unit numbers are always 1 to 1 with the
        ;;;drive letter, but this code does not assume this
        ;;;
        mov     bx,di
        mov     bp,si

	xor	si,si		; start with drive a:
mlup:

	mov	al,cs:real_cache_units[si]	; get our unit code
	and	al,3fh				; get rid of cache enable bits
	cmp	al,cl           		; match magicdrv's unit?
	jnz	mexit_nomatch

	push	si
	add	si,si				; index dword array
	add	si,si
	lds	si,cs:real_dd_headers[si]	; get dd_header
	mov	ax,ds
        push    bx
        mov     bx,es				; check segment
	cmp	ax,bx
        pop     bx
	jnz	mpopsi_nomatch

        cmp     ds:[si].sdevstrat,bp
	jnz	mpopsi_nomatch

        cmp     ds:[si].sdevint,bx
	jz	mpopsi_match

mpopsi_nomatch:
	pop	si

mexit_nomatch:
	inc	si			; next drive
	cmp	si,26
	jb	mlup

	jmp	short not_magicdrive	; if we can't match, just
mpopsi_match:
	pop	ax
        
        ;;;     We have found this drive in smartdrv's list
        ;;;     now tell magicdrv to call smartdrv with the correct
        ;;;     remapped unit number instead of the dos device driver
        ;;;
        mov     cl,dl
        dec     cl
        mov     dl,al                   ; tell magicdrv new unit number
        mov     ax,MAGICDRV_2F
        mov     bx,MAGICDRV_SMART2
	mov	di, offset cs:our_int
	mov	si, offset cs:our_strat
        push    cs
        pop     es

        int     2fh                     ;magicdrv will switch pointers...

        jmp     stacker_not_present     ;magicdrvs cannot be stacker drives!
        
not_magicdrive:
;;;first detect stacker drives...
	push	dx
	call	detect_stacker		;output is stacker version * 100(dec)
					;in ax (1.00 -> 64h)
	pop	dx
	or	ax,ax
	jnz	stacker_maybe_present
stacker_not_present_short:
	jmp	stacker_not_present
stacker_maybe_present:
	cmp	ax,200			;bug bug only handles version 2 
	jb	stacker_not_present_short

	dec	dx			;unit is zero based for check

	push	cx
	push	dx
	call	detect_stacker_volume
	pop	dx
	pop	cx
	cmp	ax,1
	jne	stacker_not_present_short

	push	cx
	call	stacker_dd_pointer
	pop	cx
	mov	bx,ax
	or	bx,dx
	jz	stacker_not_present_short	;error means ignore
	;;; if we get here, dx:ax -> stacker_dd struc for this unit

	mov	es,dx
	mov	bx,ax	;es:bx -> stacker's structure


	;;; now, es:bx -> stacker

;	***Now we have to figure out what SmartDrv remapped unit number
;	   is for the STAC host drive.  We do that by scanning our
;	   device header and unit code tables to find the drive/unit.

	xor	si,si		; start with drive a:
zlup:

	mov	al,cs:real_cache_units[si]	; get our unit code
	and	al,3fh				; get rid of cache enable bits
	cmp	al,es:[bx].dv_unit		; match stacker's unit code?
	jnz	zexit_nomatch

	push	si
	add	si,si				; index dword array
	add	si,si
	lds	si,cs:real_dd_headers[si]	; get dd_header
	mov	ax,ds				; check segment
	cmp	ax,es:word ptr [bx].dv_strategy.2
	jnz	popsi_nomatch

	mov	ax,ds:[si].sdevstrat
	cmp	ax,word ptr es:[bx].dv_strategy
	jnz	popsi_nomatch

	mov	ax,ds:[si].sdevint
	cmp	ax,word ptr es:[bx].dv_interrupt
	jz	popsi_match

popsi_nomatch:
	pop	si

zexit_nomatch:
	inc	si			; next drive
	cmp	si,26
	jb	zlup

	jmp	short not_stacker_volume	; if we can't match, just
;						;  don't cache this one.

popsi_match:
	pop	ax
	mov	es:[bx].dv_unit,al		; this is new unit code

	mov	word ptr es:[bx].dv_interrupt[0],offset cs:our_int
	mov	word ptr es:[bx].dv_interrupt[2],cs
	mov	word ptr es:[bx].dv_strategy[0],offset cs:our_strat
	mov	word ptr es:[bx].dv_strategy[2],cs

not_stacker_volume:		
stacker_not_present:
	pop	di
	pop	si

	pop	ds
	pop	es
	pop	bp
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	call	get_DPB

assume ds:nothing

	jc	done_dpb_update

	add	bx,cs:dos_3x			; adjust pointer for DOS 3.x dpb

	cmp	word ptr ds:[bx].dpb_driver_addr[0],bp
	jne	do_next_dpb
	cmp	word ptr ds:[bx].dpb_driver_addr[2],cx
	jne	do_next_dpb
	;;;	update dbp to point to new driver
	mov	word ptr ds:[bx].dpb_driver_addr[0],si
	mov	word ptr ds:[bx].dpb_driver_addr[2],di	

do_next_dpb:
	inc	dl
	jmp	loop_dpb
done_dpb_update:
	pop	bp
	pop	dx
	pop	di	
	pop	si
	pop	bx
	pop	es
	pop	ds	
	pop	cx		
assume ds:zseg
	ret
update_dpbs endp

setup_default_size proc near
	call	initialize_xms
	jc	near_fail
	call	query_free_xms_memory
	or	ax,ax
	jz	near_fail
	cmp	ax,512
	jbe	all_dos
	cmp	ax,1024
	jbe	one_meg
	cmp	ax,2048
	jbe	two_meg
	cmp	ax,4096
	jbe	four_meg
	cmp	ax,6144
	jbe	six_meg
big_memory:
	mov	dos_size,2048
	mov	win_size,2048
	jmp	short	exit_default_size
near_fail:
	jmp	short error_query_failed
one_meg:
	mov	dos_size,ax
	mov	win_size,0
	jmp	short exit_default_size
two_meg:
	mov	dos_size,1024
	mov	win_size,256
	jmp	short exit_default_size
four_meg:
	mov	dos_size,1024
	mov	win_size,512
	jmp	short exit_default_size

six_meg:
	mov	dos_size,2048
	mov	win_size,1024
	jmp	short exit_default_size

all_dos:
	mov	dos_size,ax
	mov	win_size,0	

exit_default_size:
	mov	ax,1024			;size is in Kilobytes
	mul	win_size		;dx:ax = #K cache size
	div	cache_block_bytes	;ax = number of cache elements needed
	mov	number_of_cache_elements_win,ax

	mov	ax,1024			;size is in Kilobytes
	mul	dos_size		;dx:ax = #K cache size
	div	cache_block_bytes	;ax = number of cache elements needed
	mov	number_of_cache_elements,ax

error_query_failed:

	ret	
setup_default_size endp

zseg	ends
	end	

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\beep.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

include bambi.inc


BEEP = 0


zseg    segment public 'CODE'

	assume  cs:zseg
	assume	ds:nothing

if BEEP
if 0
PUBLIC	flush_beep
PUBLIC  invalidate_beep

Test_Procs PROC NEAR

	call	Flush_Beep

	mov	cx, 9
	call	Wait_Ticks

	call	Invalidate_Beep


	mov	ax, 4c00h
	int	21h

Test_Procs ENDP

endif
;******************************************************************************
;
;   Flush_Beep
;
;   DESCRIPTION:
;	Produces a standard beep to indicate a cache flush.
;
;   ENTRY:
;	None
;
;   EXIT:
;	None
;
;   USES:
;	Flags
;
;==============================================================================

Flush_Beep PROC NEAR

	push	ax
	push	cx

	mov	cx, 1336			; Standard beep tone
	call	Set_Sound_Freq
	mov	cx, 9				; Standard beep length
	call	Wait_Ticks
	call	Set_Sound_Freq			; Turn off sound (CX = 0)

	pop	cx
	pop	ax
	ret

Flush_Beep ENDP


;******************************************************************************
;
;   Invalidate_Beep
;
;   DESCRIPTION:
;	Generates a long, high-to-low beep to indicate a cache invalidation.
;
;   ENTRY:
;	None
;
;   EXIT:
;	None
;
;   USES:
;	Flags
;
;==============================================================================

Invalidate_Beep PROC NEAR

	push	ax
	push	cx
	push	dx

	mov	dx, 1336
IB_Loop:
	mov	cx, dx
	call	Set_Sound_Freq
	mov	cx, 1
	call	Wait_Ticks
	add	dx, 100
	cmp	dx, 5000
	jb	IB_Loop

	call	Set_Sound_Freq

	pop	dx
	pop	cx
	pop	ax
	ret

Invalidate_Beep ENDP




;******************************************************************************
;
;   Set_Sound_Freq
;
;   DESCRIPTION:
;	Sets the sound to the desired frequency or turns sound off if
;	input of 0
;
;   ENTRY:
;	CX = Frequency to program counter to or 0 to turn sound off
;
;   EXIT:
;	None
;
;   USES:
;	AX, CX, Flags
;
;==============================================================================

Set_Sound_Freq PROC NEAR

	in	al, 61h
	jcxz	SSF_Turn_Sound_Off

	xchg	ax, cx

	jmp	$+2
	jmp	$+2

	out	42h, al

	jmp	$+2
	jmp	$+2

	mov	al, ah
	out	42h, al

	mov	ax, cx				; AL = Old port 61h value
	or	al, 11b 			; Turn on sound bits
	jmp	SHORT SSF_Set_Sound_Bits

SSF_Turn_Sound_Off:
	and	al, NOT 11b
SSF_Set_Sound_Bits:
	jmp	$+2
	out	61h, al

	ret

Set_Sound_Freq ENDP


;******************************************************************************
;
;   Wait_Ticks
;
;   DESCRIPTION:
;
;   ENTRY:
;	CX = # ticks to delay before returning
;
;   EXIT:
;	CX = 0
;
;   USES:
;	AX, CX, Flags
;
;==============================================================================

Wait_Ticks PROC NEAR

	sti					; Paranoia...

	push	ds
	xor	ax, ax
	mov	ds, ax

Wait_Reset_Base:
	mov	al, BYTE PTR ds:[46Ch]		; AL = Current tick counter
Wait_Loop:
	cmp	al, BYTE PTR ds:[46Ch]		; Q: Has counter changed?
	je	Wait_Loop			;    N: Wait some more
	loop	Wait_Reset_Base 		;    Y: One more tick gone!

	pop	ds
	ret

Wait_Ticks ENDP

endif

zseg ends

end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\bpb.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;

;**	BIOS PARAMETER BLOCK DEFINITION
;
;	The BPB contains information about the disk structure.  It dates
;	back to the earliest FAT systems and so FAT information is
;	intermingled with physical driver information.
;
;	A boot sector contains a BPB for its device; for other disks
;	the driver creates a BPB.  DOS keeps copies of some of this
;	information in the DPB.
;
;	The BDS structure contains a BPB within it.
;



A_BPB			STRUC
BPB_BYTESPERSECTOR	DW	?
BPB_SECTORSPERCLUSTER	DB	?
BPB_RESERVEDSECTORS	DW	?
BPB_NUMBEROFFATS	DB	?
BPB_ROOTENTRIES 	DW	?
BPB_TOTALSECTORS	DW	?
BPB_MEDIADESCRIPTOR	DB	?
BPB_SECTORSPERFAT	DW	?
BPB_SECTORSPERTRACK	DW	?
BPB_HEADS		DW	?
BPB_HIDDENSECTORS	DW	?
			DW	?
BPB_BIGTOTALSECTORS	DW	?
			DW	?
			DB	6 DUP(?)	; NOTE:  many times these
;						; 	 6 bytes are omitted
;						;	 when BPB manipulations
;						;	 are performed!
A_BPB			ENDS
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\cacheini.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

include	bambi.inc

public	initialize_cache
public	halt_cache

;
;	data from rdata.asm
;
extrn	XMShandlevalid		:byte
extrn	XMShandle		:word
extrn	cache_block_bytes	:word
;
;	routines from xms.asm
;
extrn	initialize_xms		:near
extrn	allocate_xms_memory	:near
extrn	free_xms_memory		:near
;
;	routines fro queueman.asm
;
extrn	initqueue		:near


zseg    segment public 'CODE'

	assume  cs:zseg
	assume  ds:zseg


;
;	INPUT
;		CX number of cache elements

Initialize_Cache proc near

	or	cx,cx
	jz	no_xms

	mov	cs:XMShandlevalid,0
	call	Initialize_XMS
	jc	MemoryError1
	
	mov	ax,cx
	mul	cs:cache_block_bytes
	
	mov	si,1024
	div	si
	mov	dx,ax
	;dx = K to allocate
	call	Allocate_XMS_Memory
	or	ax,ax
	jz	MemoryError2 
	mov	cs:XMShandle,dx
	mov	cs:XMShandlevalid,1
no_xms:
	clc
	ret		

MemoryError1:
	mov	ax,ERROR_NO_XMS_DRIVER
errorout:
	stc
	ret	
MemoryError2:
	mov	ax,ERROR_ALLOCATION_FAILED
	jmp	short errorout
Initialize_Cache endp

;
; INPUT none
; OUTPUT none
Halt_Cache proc near

	cmp	cs:XMShandlevalid,1
	jne	donehalt
	mov 	dx,cs:XMShandle
	call 	Free_XMS_Memory
donehalt:
 	ret
Halt_Cache endp

zseg ends

end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\bamchk.asm ===
;
;	This little program takes a snapshot of the SmartDrv 4.0
;	cache data structures and dumps it, crudely formatted, to
;	STDOUT for further processing.
;
;masm bamchk;
;link bamchk;
;exe2bin bamchk.exe bamchk.com
;del bamchk.exe
;
zseg	segment
	assume	cs:zseg

	org	100h

com_entry:
	jmp	short com_entry_1

;	local variables

queuelength	dw	0

com_entry_1:
	mov	ax,4a10h	; bambi multiplex interrupt
	mov	bx,10		; get internals
	int	2fh
	cmp	bx,10
	mov	dx,offset no_bambi
	jz	msg_exit	; bomb out if no int2f service

	push	es
	pop	ds		; get bambi internals pointer into ds:bx

	push	cs
	pop	es		; point es:di to our local snapshot buffer
	mov	di,offset our_buffer

;	Take a quick snapshot without doing disk i/o.  If we wanted
;	  to be pure here, we could assure interrupts disabled, but
;	  it is a fairly unlikely case and would simply result in
;	  slightly bad diagnostic data.

	mov	si,word ptr 8[bx] ; get queuelength pointer
	mov	cx,[si]		; get queuelength into cx
	mov	queuelength,cx
	xor	bp,bp		; point to first element

;	**** We're going to assume that our buffer is big enough
;	     to hold all of the data structures.  We know that they
;	     all fit in Bambi, so they should fit in our buffer.

snapshot_loop:
	mov	si,word ptr 6[bx] ; get hiword pointer
	mov	si,word ptr [si]
	mov	ax,ds:[bp+si]	; get hiword data
	stosw			; into snapshot buffer

	mov	si,word ptr 4[bx] ; get loword pointer
	mov	si,word ptr [si]
	mov	ax,ds:[bp+si]	; get loword data
	stosw			; stick it into our snapshot buffer

;	***** ASSUME USING WORD MASKS!!!!  (8K blocks) *****

	mov	si,word ptr 2[bx] ; get dirtyindexoffset
	mov	si,word ptr [si]
	mov	ax,ds:[bp+si]
	stosw

	mov	si,word ptr [bx] ; get validindexoffset
	mov	si,word ptr [si]
	mov	ax,ds:[bp+si]
	stosw

	add	bp,2
	loop	snapshot_loop	; loop queuelength times

;	Now it's time to dump the buffer to STDOUT!!!!

	push	cs
	pop	ds		; point to our_buffer
	mov	si,offset our_buffer ; with ds:si
	mov	cx,queuelength

output_loop:
	lodsw			; get indentifierhiword
	push	ax		; save high part of sector number
	mov	al,ah		; get drive ID (or 0ffh if undefined)
	add	al,'A'		; convert to letter, or @ if undefined
	call	cofa
	pop	ax
	call	hex8
	lodsw
	call	hex16		; dump loword
	lodsw			; get dirtymask
	call	hex16
	lodsw			; get validmask
	call	hex16
	mov	al,13
	call	cofa
	mov	al,10
	call	cofa
	loop	output_loop

	mov	ax,4c00h
	int	21h

msg_exit:
	push	cs
	pop	ds
	mov	ah,9
	int	21h		; display message
	mov	ax,4c01h
	int	21h

hex16:
	push	ax
	mov	al,ah
	call	hex8
	pop	ax
hex8:
	push	ax
	shr	al,1
	shr	al,1
	shr	al,1
	shr	al,1
	call	hexnib
	pop	ax
hexnib:
	and	al,0fh
	add	al,90h
	daa
	adc	al,3ah
	daa
cofa:
	mov	dl,al
	mov	ah,2
	int	21h		; slow output through int21
	ret

no_bambi:
	db	'Bambi not responding!$'

our_buffer:

zseg	ends
	end	com_entry

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\bootform.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;        %OUT BOOTFORM.INC...
;****************************************************************************
;AN000; - Structure of the Extended IBMBOOT record for DOS -. J.K.
;AN001; - D304 Include PHYDRV, CURHD to the header structure	 11/09/87 J.K.
;****************************************************************************
;
;	****** Warning!  You must include bpb.inc BEFORE you include
;		this file or you will get some wrong offsets but
;		the assembler WILL NOT give you any warning message!!!!!
;

BOOT_SIZE		 EQU	 512
EXT_BOOT_SIGNATURE	 EQU	 41		;Extended boot signature
;
EXT_BPB_INFO		STRUC
EBPB_BYTESPERSECTOR	 DW	 ?
EBPB_SECTORSPERCLUSTER	 DB	 ?
EBPB_RESERVEDSECTORS	 DW	 ?
EBPB_NUMBEROFFATS	 DB	 ?
EBPB_ROOTENTRIES	 DW	 ?
EBPB_TOTALSECTORS	 DW	 ?
EBPB_MEDIADESCRIPTOR	 DB	 ?
EBPB_SECTORSPERFAT	 DW	 ?
EBPB_SECTORSPERTRACK	 DW	 ?
EBPB_HEADS		 DW	 ?
EBPB_HIDDENSECTOR	 DD	 ?
EBPB_BIGTOTALSECTORS	 DD	 ?
EXT_BPB_INFO		ENDS
;
;AN001; EXT_PHYDRV, EXT_CURHD included in the header for OS2.
EXT_IBMBOOT_HEADER	STRUC
EXT_BOOT_JUMP		DB	3 DUP (?)
EXT_BOOT_OEM		DB	8 DUP (?)
EXT_BOOT_BPB		DB	size EXT_BPB_INFO dup (?)
EXT_PHYDRV		DB	80h
EXT_CURHD		DB	0
EXT_BOOT_SIG		DB	EXT_BOOT_SIGNATURE
EXT_BOOT_SERIAL 	DD	?
EXT_BOOT_VOL_LABEL	DB	11 DUP (?)
EXT_SYSTEM_ID		DB	8  DUP (?)
EXT_IBMBOOT_HEADER	ENDS
;
BOOT_SIGNATURE	=     word ptr (BOOT_SIZE-2)

;
;J.K. This is the number of sectors (of size 512 bytes) that will cover
;the size of IBMLOAD program.  IBMBOOT program has to at least read this
;many sectors, and these sectors should be the first cluster and consecutive.
;Make sure IBMBOOT program uses the same value as this.
IBMLOADSIZE	equ	3	;Number of sectors IBMBOOT program should read in.


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\cmdline.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

include bambi.inc

public  parse_command_line
public  display_status

zseg    segment public 'CODE'

	assume  cs:zseg
;
;       data from text.asm
;
extrn   help_text               :byte
extrn   statistics1             :byte
extrn   statistics2             :byte
extrn   statistics3             :byte
extrn   statistics4             :byte
extrn   statistics5             :byte
extrn   drivestring1            :byte
extrn   drivestring2            :byte
extrn   drivestring3            :byte
extrn   msg_cannot_cache        :byte
extrn   bufferstring1           :byte
extrn   bufferstring2           :byte
extrn   bufferstring3           :byte
extrn   extrastatus1            :byte
extrn   extrastatus2            :byte
extrn   extrastatus3            :byte
extrn   extrastatus4            :byte
extrn   extrastatus5            :byte
extrn   magicdrvstring          :byte
extrn   whatsanasterisk         :byte
;
;       data from rdata.asm
;
extrn   cache_block_bytes       :word
extrn   cache_block_words       :word
extrn   commitflag              :byte
extrn   dosinfo                 :word
;
;       data from tdata.asm
;
extrn   drives_to_cache         :byte
extrn   first_instance          :byte

extrn   number_of_cache_elements:word
extrn   number_of_cache_elements_win:word
;
;       routines from int2fini.asm
;
extrn   call_bambi              :near
extrn   init_bambi_io           :near
;
;       routines from queueman.asm
;
extrn   commit_all_dirty        :near
;
;       routines from bambi.asm
;
;
;       data from bambinit.asm
;
extrn   target_buffer_size      :word
;
;       routine from dec_out.asm
;
extrn   display_dec_dword               :near
;
;       data from bambinit.asm
;
extrn   dos_size                :word
extrn   win_size                :word
;
;       routines from drvtype.asm
;
extrn   IsMagicDrive            :near

extrn   get_drive_type          :near
;
;       routines from logphys.asm
;
extrn   logical_to_physical             :near
extrn   log_phys_list                   :byte
;
;       routines from xms.asm
;
extrn   query_free_xms_memory           :near
extrn   initialize_xms                  :near
;       
;       routines from stacker.asm
;
extrn   detect_stacker          :near
extrn   detect_stacker_volume   :near
extrn   stacker_dd_pointer      :near

	display_asterisk_message db 0
	be_quiet	dw	1	;default to quiet start up
	load_low        db      0
PUBLIC  load_low
PUBLIC  be_quiet
;locals
	dos_size_done   dw      0
	extra_status    db      0

init_command_line_parsing proc near
	mov     bx,COMMAND_LINE_OFFSET  
	clc
	ret
init_command_line_parsing endp

at_eol proc near
	cmp     bx,COMMAND_LINE_OFFSET+MAX_COMMAND_LINE_LENGTH
	jae     is_at_eol
	mov     al,BYTE PTR es:[bx]
	cmp     al,COMMAND_LINE_TERMINATOR
	je      is_at_eol
	clc
	ret
is_at_eol:
	;be sure future calls always return carry
	mov     bx,COMMAND_LINE_OFFSET+MAX_COMMAND_LINE_LENGTH
	stc
	ret     
at_eol endp

get_next_char proc near
	inc     bx
	call    at_eol
	jc      eol
	mov     al,BYTE PTR es:[bx]
	cmp     al,COMMAND_LINE_TERMINATOR
	je      eol
	clc
	ret
eol:
	stc
	ret
get_next_char endp

ascii_to_hex proc near
	cmp     al,'9'
	ja      letter
	cmp     al,'0'
	jb      not_hex_char
	sub     al,'0'
	clc
	ret
letter:
	cmp     al,'F'
	ja      not_hex_char
	cmp     al,'A'
	jb      not_hex_char
   sub  al,'A'-10
	clc
	ret
not_hex_char:
	stc
	ret
ascii_to_hex endp             

ascii_to_dec proc near
	cmp     al,'9'
	ja      not_dec
	cmp     al,'0'
	jb      not_dec
	sub     al,'0'
	xor     ah,ah
	clc
	ret
not_dec:
	stc
	ret
	
ascii_to_dec endp

;
; INPUT
;       al = binary number
; OUTPUT
;       ax = two ascci chars
;
hex_to_ascii proc near
    push cx
    mov ah,al
    and al,0Fh
    add al,90h                
    daa                       
    adc al,40h                
    daa                       
    xchg al,ah
    mov cl,4
    shr al,cl
    add al,90h                
    daa                       
    adc al,40h                
    daa                          
    pop cx
    ret
hex_to_ascii endp

;
; INPUT
;    al = char to output
;
output_char proc near
     push dx
     push ax
     mov dl,al
     mov ah,2
     int 21h
     pop ax
     pop dx
     ret
output_char endp

parse_number    proc near
	xor     cx,cx
	call    get_next_char           ;get next digit in number
	jc      not_a_number    
		
get_number:
	call    ascii_to_dec            ;turn into binary number
	jc      get_number_done         ;error means this is not a hex digit
			; multiply accumlated value by 10
	push    dx
	add     cx,cx
	mov     dx,cx
	add     cx,cx
	add     cx,cx
	add     cx,dx                   
	pop     dx

	add     cx,ax                   ;add in this digit
	call    get_next_char           ;get next digit in number
	jc      get_number_done 
	jmp     short get_number
	
get_number_done:        
	clc
	ret
not_a_number:
	;stc
	ret
parse_number    endp

;
; INPUT
;       DX:BX 
; USES
;       AX
display_hex_dword       proc near
	mov     al,dh
	call    hex_to_ascii
	call    output_char
	xchg    al,ah
	call    output_char     
	mov     al,dl
	call    hex_to_ascii
	call    output_char
	xchg    al,ah
	call    output_char     
	mov     al,bh
	call    hex_to_ascii
	call    output_char
	xchg    al,ah
	call    output_char     
	mov     al,bl
	call    hex_to_ascii
	call    output_char
	xchg    al,ah
	call    output_char     
	ret     
display_hex_dword       endp

display_status:
	mov     ax,BAMBI_GET_STATS
	call    call_bambi
	cmp     ax,BAMBI_SIGNATURE
	je      do_display_status
	jmp     display_help_text ;bug bug
do_display_status:
	cmp     be_quiet,0
	je      not_quiet
	jmp     done_stats
not_quiet:
	

	push    dx
	mov     dx,offset statistics1
	mov     ah,09h
	int     21h
	pop     dx

	cmp     extra_status,0
	je      no_extra_status

	push    dx
	mov     dx,offset extrastatus1
	mov     ah,09h
	int     21h
	pop     dx

	mov     ax,BAMBI_GET_INFO
	call    call_bambi

	push    cx

	xor     dx,dx
	call    display_dec_dword
	
	push    dx
	mov     dx,offset extrastatus2
	mov     ah,09h
	int     21h
	pop     dx

	pop     cx

	mov     bx,cx
	xor     dx,dx
	call    display_dec_dword

	push    dx
	mov     dx,offset extrastatus3
	mov     ah,09h
	int     21h
	pop     dx

	mov     ax,BAMBI_GET_STATS
	call    call_bambi

	push    di
	push    si

	call    display_dec_dword

	mov     dx,offset extrastatus4
	mov     ah,09h
	int     21h

	pop     bx
	pop     dx

	call    display_dec_dword

	push    dx
	mov     dx,offset extrastatus5
	mov     ah,09h
	int     21h
	pop     dx
	
no_extra_status:

	push    dx
	mov     dx,offset statistics2
	mov     ah,09h
	int     21h
	pop     dx

	mov     ax,BAMBI_GET_INFO
	call    call_bambi

	push    cx
	push    dx
	;calculate actual cache size by multiplying number*size
	mov     ax,cx
	mul     bx
	mov     bx,ax
	call    display_dec_dword

	mov     dx,offset statistics3
	mov     ah,09h
	int     21h

	pop     dx
	pop     cx

	mov     ax,cx
	mov     bx,dx
	mul     bx
	mov     bx,ax
	call    display_dec_dword


	push    dx
	mov     dx,offset statistics4
	mov     ah,09h
	int     21h
	pop     dx


	push    bp
	push    bx
	push    dx

	mov     bp,-1                   ; start at unit zero,-1 for next inc
	push    bp                      
drive_loop:
	pop     bp
	inc     bp
	push    bp

	cmp     bp,26                   ;bug bug
	jb      not_done_drives
	jmp     done_drives

not_done_drives:

	push    bp
	mov     dx,bp
	call    IsMagicDrive
	pop     bp
	jz      NotMagicDriveReadout

	and     bx,7Fh  ;mask off all but host drive letter
	push    bx
	mov     dx,bx
	call    isMagicDrive
	pop     ax
	jz      notswappedhost
	and     bx,7Fh
	jmp     short isswappedhost
notswappedhost:
	mov     bx,ax
isswappedhost:
	mov     bp,bx

NotMagicDriveReadout:

	mov     ax,BAMBI_CACHE_DRIVE
	xor     dl,dl                   ; get cache state
	call    call_bambi
	jnc     not_done_drives2             ; bug bug
	jmp     done_drives
not_done_drives2:
	test    dl,80h                  ; read caching enabled?
	jnz     drive_loop

	mov     bx,offset drivestring2  ;yes,no

	test    dl,40h                  ; write caching enabled?
	jnz     read_cache_only         
	
	mov     bx,offset drivestring1  ;yes,yes

read_cache_only:

	pop     dx                      ;get actual drive letter
	push    dx

	mov     byte ptr [bx+04],dl
	add     byte ptr [bx+04],'A'
	mov     byte ptr [bx+06],' '
	cmp     dx,bp                   ;remapped dblspace drive?
	je      noasterisk
	mov     cs:display_asterisk_message,1
	mov     byte ptr [bx+06],'*'
noasterisk:

	push    dx
	mov     dx,bx
	mov     ah,09h
	int     21h
	pop     dx

	push    es
	push    di
	push    dx
	mov     dx,bp
;       call    logical_to_physical 
	push    bx
	mov     bl,dl
	xor     bh,bh   
	mov     dl,log_phys_list[bx]
	pop     bx
	test    dl,80h                  ;harddisk?
	jz      print_no


	mov     ax,MULT_BAMBI
	mov     bx,BAMBI_GET_BUFFER_INFO
	int     2fh                     ;get pointer to safedsk's drive list
	cmp     ax,BAMBI_SIGNATURE
	jne     print_no

	and     dl,NOT 80h              ;mask off high bit to get array index
	xor     bh,bh
	mov     bl,dl

	;;;es:di points to safedsk table
	cmp     byte ptr es:[bx+di],-1
	jne     do_we_know

	push    dx
	mov     dx,offset bufferstring1
	mov     ah,09h
	int     21h
	pop     dx

	jmp     short print_done
do_we_know:
	cmp     byte ptr es:[bx+di],0
	je      print_dont_know
print_no:
	push    dx
	mov     dx,offset bufferstring2
	mov     ah,09h
	int     21h
	pop     dx
	jmp     short print_done

print_dont_know:

	push    dx
	mov     dx,offset bufferstring3
	mov     ah,09h
	int     21h
	pop     dx

print_done:
	pop     dx
	pop     di
	pop     es

	jmp     drive_loop      
done_drives:
	pop     bp      ;pop off extra bp on stack from drive loop entry
	pop     dx
	pop     bx
	pop     bp

	cmp     cs:display_asterisk_message,1
	jne     no_asterisks

	push    dx
	mov     dx,offset whatsanasterisk
	mov     ah,09h
	int     21h
	pop     dx

no_asterisks:
	push    dx
	mov     dx,offset statistics5
	mov     ah,09h
	int     21h
	pop     dx


if 0
	push    dx
	mov     dx,offset statistics2
	mov     ah,09h
	int     21h
	pop     dx

	push    bx
	push    dx
	push    cx
	push    di
	push    si

	mov     ax,BAMBI_GET_INFO
	call    call_bambi

	;display block size
	push    bx
	mov     bx,cx
	xor     dx,dx
	call    display_dec_dword
	pop     bx

	mov     dx,offset number_elements
	mov     ah,09h
	int     21h

	;display queuelength
	xor     dx,dx
	call    display_dec_dword

	mov     dx,offset actual_size
	mov     ah,09h
	int     21h

	;calculate actual cache size by multiplying number*size
	mov     ax,cx
	mul     bx
	mov     bx,ax
	call    display_dec_dword
	

	mov     dx,offset actual_break
	mov     ah,09h
	int     21h

	pop     si
	pop     di
	pop     cx
	pop     dx
	pop     bx
   
	push    dx
	mov     dx,offset cache_hits
	mov     ah,09h
	int     21h
	pop     dx
	;display hits
	call    display_dec_dword

	mov     dx,offset cache_misses
	mov     ah,09h
	int     21h

	;display nohits 

	mov     dx,di
	mov     bx,si
	call    display_dec_dword

	mov     dx,offset dirty_blocks
	mov     ah,09h
	int     21h

	;display dirty
	mov     bx,cx
	xor     dx,dx
	call    display_dec_dword

	mov     dx,offset stats_end
	mov     ah,09h
	int     21h

endif
done_stats:     
	stc
	ret
parse_command_line proc near

	call    init_command_line_parsing

scan_parse:     
	call    get_next_char           ;get next char on command line
	jc      done_scanning_jmp       ;carry set if not more chars
	cmp     al,COMMAND_SWITCH_CHAR  ;is it a switch char?
	jne     not_switch              
	jmp     handle_switch
	
not_switch:

	cmp     al,' '                  ;skip white spaces
	je      scan_parse
	cmp     al,09h;tab              ;...tabs
	je      scan_parse

	;;;     check for number (dossize,winsize)
	cmp     al,'0'
	jae     mightbeanumber
	jmp     not_number
mightbeanumber:
	cmp     al,'9'
	jbe     isanumber
	jmp     not_number
isanumber:

	xor     cx,cx                   ;zero count for get_number!
	call    get_number      ; get value of number->cx
	jc      done_scanning_jmp       ;something went wrong BUG BUG necessary?

	;;; minimum size for cache!
	cmp     cx,MINIMUM_CACHE_SIZE
	ja      user_is_big_enough
	mov     cx,MINIMUM_CACHE_SIZE
user_is_big_enough:

	push    cx
	push    bx
	call    initialize_xms          ;be sure its ok to call xms
	pop     bx
	pop     cx
	jc      forget_it
	push    cx
	push    bx
	call    query_free_xms_memory   ;find out how much xms memory is free
	pop     bx
	pop     cx
	or      ax,ax
	jz      forget_it
	cmp     cx,ax
	jbe     user_is_small_enough
	mov     cx,ax
user_is_small_enough:
forget_it:

	cmp     dos_size_done,0         ;have we parsed the dos size already?
	jne     get_windows_size        ;if so, we are at the window's size
	mov     dos_size_done,1         ;next time through will be for windows

winsize_bigger:                         ;BUG BUG if win size is bigger
					;we set dossize==winsize!
	mov     dos_size,cx             ;save number in global

	mov     ax,1024                 ;size is in Kilobytes
	mul     dos_size                ;dx:ax = #K cache size
	div     cache_block_bytes       ;ax = number of cache elements needed

	mov     number_of_cache_elements,ax     ;remember how many elements
	mov     number_of_cache_elements_win,ax ;win size must be set so
						;defaults won't be used!
	jmp     scan_parse      
done_scanning_jmp:
	jmp     done_scanning

get_windows_size:
	cmp     cx,dos_size
	ja      winsize_bigger


	mov     win_size,cx
	mov     ax,1024                 ;size is in Kilobytes
	mul     win_size                ;dx:ax = #K cache size
	div     cache_block_bytes       ;ax = number of cache elements needed

	mov     number_of_cache_elements_win,ax

	jmp     scan_parse      
magicspecial:
	pop     bx
	pop     ax
	push    dx
	mov     dx,offset magicdrvstring
	mov     ah,09h
	int     21h
	pop     dx
	jmp     short notcached
cannot_cache_drive:

	push    dx
	mov     dx,offset msg_cannot_cache
	mov     ah,09h
	int     21h
	pop     dx
notcached:
	;;; we have detected a drive we cannot cache, but
	;;; if the user added a '+' or '-' after it, we have
	;;; "eat" it since it will be a syntax error when we
	;;; attempt to continue parsing
	call    get_next_char
	jc      nopluslast
	cmp     al,'+'
	je      eatit
	cmp     al,'-'
	je      eatit
	dec     bx                      ;unget the char
eatit:
	clc                             ;dont error out
nopluslast:
	jmp     scan_parse
not_number:

	;;;     check for drive letter and modifier + or -

	and     al,NOT 20h              ;mask off shift bit
	cmp     al,'A'                  ;valid drive letter?
	jb      done_scanning_jmp       ;not recognized
	cmp     al,'Z'
	ja      done_scanning_jmp       ;not recognized
	sub     al,'A'                  ;A=0,B=1,...

	push    ax
	push    bx
	push    cx
	push    dx
	push    ds
	push    es
	xor     dx,dx
	mov     dl,al
	push    dx
	call    detect_stacker
	pop     dx

	or      ax,ax
	jz      no_stacker
	cmp     ax,200                  ;version 2?
	jb      no_stacker              ;version 1 ok to cache
	call    detect_stacker_volume
	cmp     ax,1
	jne     no_stacker
	pop     es
	pop     ds
	pop     dx
	pop     cx
       ;        pop     bx
       ;        pop     ax
	jmp     short dont_cache        
no_stacker:
	pop     es
	pop     ds
	pop     dx
	pop     cx
	pop     bx
	pop     ax
		  
	push    ax                      ;save drive letter      
	push    bx
	mov     dl,al                   ;check if drive is a valid
	xor     dh,dh                   ;cachable drive (not network)
	call    get_drive_type
	sub     ax,dosinfo
	
	cmp     ax,REMOTE_TYPE
	je      dont_cache
	cmp     ax,CDROM_TYPE
	je      dont_cache
	cmp     ax,INVALID_TYPE
	je      dont_cache
	cmp     ax,MAGIC_TYPE
	jne     popbxax
	jmp     magicspecial
popbxax:
dont_cache:                             ;leave 'e' set for test after pops
	pop     bx
	pop     ax                      ;restore drive letter
	je      cannot_cache_drive

	mov     cl,al                   ;al holds drive unit
	mov     dx,bx                   ;save parameter cursor
	call    get_next_char           ;checking for + or -
	jc      read_cache_enable       ;no more to read, no modifier there!
	cmp     al,'+'                  ;+ sign?
	je      write_cache_enable      ;means to enable write cache too
	cmp     al,'-'                  ;- sign?
	je      disable_all             ;meands to disable read/write cache
	mov     bx,dx                   ;restore parameter cursor
read_cache_enable:
	;;;     if resident already, we need to call resident guy
	cmp     cs:first_instance,0
	je      notify_resident_read_cache
	
	push    bx                      ;preserve text ptr offset
	mov     bl,cl                   ;cl is the unit number
	xor     bh,bh                   ;bx is unit number
	mov     drives_to_cache[bx],READ_CACHE ; set read cache only for unit
	pop     bx      
	clc
	jmp     scan_parse

notify_resident_read_cache:
	push    bp
	push    bx
	xor     ch,ch
	mov     bp,cx
	mov     dl,CACHE_DRIVE_READ_ENABLE
	mov     ax,BAMBI_CACHE_DRIVE
	push    ax
	push    bx      
	push    bp
	call    call_bambi
	pop     bp
	pop     bx
	pop     ax
	mov     dl,CACHE_DRIVE_WRITE_DISABLE
	call    call_bambi
	pop     bx 
	pop     bp
	clc
	jmp     scan_parse

write_cache_enable:
		;;;     if resident already, we need to call resident guy
	cmp     cs:first_instance,0
	je      notify_resident_write_cache
	
	push    bx                      ;preserve text ptr offset
	mov     bl,cl                   ;cl is the unit number
	xor     bh,bh                   ;bx is unit number
	mov     drives_to_cache[bx],WRITE_CACHE ; set read cache only for unit
	pop     bx      
	clc
	jmp     scan_parse

notify_resident_write_cache:
	push    bp
	push    bx
	xor     ch,ch
	mov     bp,cx
	mov     dl,CACHE_DRIVE_READ_ENABLE
	mov     ax,BAMBI_CACHE_DRIVE
	push    ax
	push    bx      
	push    bp
	call    call_bambi
	pop     bp
	pop     bx
	pop     ax
	mov     dl,CACHE_DRIVE_WRITE_ENABLE
	call    call_bambi
	pop     bx 
	pop     bp
	clc
	jmp     scan_parse


disable_all:
			;;;     if resident already, we need to call resident guy
	cmp     cs:first_instance,0
	je      notify_resident_no_cache
	
	push    bx                      ;preserve text ptr offset
	mov     bl,cl                   ;cl is the unit number
	xor     bh,bh                   ;bx is unit number
	mov     drives_to_cache[bx],NO_CACHE ; set read cache only for unit
	pop     bx      
	clc
	jmp     scan_parse

notify_resident_no_cache:
	push    bp
	push    bx
	xor     ch,ch
	mov     bp,cx
	mov     dl,CACHE_DRIVE_READ_DISABLE
	mov     ax,BAMBI_CACHE_DRIVE
	push    ax
	push    bx      
	push    bp
	call    call_bambi
	pop     bp
	pop     bx
	pop     ax
	mov     dl,CACHE_DRIVE_WRITE_DISABLE
	call    call_bambi
	pop     bx 
	pop     bp
	clc
	jmp     scan_parse



done_scanning:
	call    at_eol
	cmc
	jnc     nodisp
	jmp     display_help_text
nodisp:
	ret

reset_cache:
	push    bx
	call    init_bambi_io
	mov     ax,BAMBI_REINITIALIZE
	call    call_bambi
	pop     bx

	jmp     scan_parse

handle_switch:
	call    get_next_char
	jc      done_scanning
	or      al,32                   ;lower case
	cmp     al,FLUSH_FLAG
	je      no_colon
	cmp     al,RESET_FLAG
	je      reset_cache
	cmp	al,QUIET_FLAG
	je	set_quiet_flag
	cmp	al,VERBOSE_FLAG
	je	clr_quiet_flag
	cmp     al,LOAD_LOW_FLAG
	je      check_loadlow_flag
	cmp     al,COMMIT_FLAG
	jne     notwarning
	jmp     setcommitflag
notwarning:
	cmp     al,STATUS_FLAG
	jne     cont_swtch
	mov     extra_status,1
	jmp     display_status
check_loadlow_flag:
	mov     load_low,1
	jmp     scan_parse

set_quiet_flag:
	mov	be_quiet,1
	jmp	short cont_quiet_flag
clr_quiet_flag:
	mov	be_quiet, 0
cont_quiet_flag:
	call	get_next_char  ;;no characters allowed after /q or /v
	jc      done_scanning
	cmp	al,' '	       ;;must be a space after /q or /v, if anything
	jne     display_help_text
	jmp     scan_parse
cont_swtch:
	mov     dl,al

	call    get_next_char           ;get the ':' 
	jc      display_help_text
	cmp     al,':'

	mov     al,dl
	cmp     al,ELEMENTS_FLAG        ;is it the #elements flag?
	jne     check_size_flag         ;no--continue parsing

	;
	;       if bambi is already resident, we need
	;       to re-initialize resident bambi
	push    ax
	push    bx
	mov     ax,BAMBI_GET_STATS      ;getstatus also used for detection
	call    call_bambi
	cmp     ax,BAMBI_SIGNATURE
	pop     bx
	pop     ax
	jne     not_reinitialize
	jmp     reinitialize
not_reinitialize:

	call    parse_number
	jc      display_help_text
	mov     number_of_cache_elements,cx
	jmp     scan_parse
no_colon:
	call    init_bambi_io
	mov     ax,BAMBI_COMMIT_ALL
	call    call_bambi
	stc
	ret
display_help_text:
	mov     dx,offset cs:help_text
	mov     ah,9
	int     21h
	stc
	ret
check_size_flag:
	cmp     al,ELEMENT_SIZE_FLAG
	jne     check_buffer_flag
	call    parse_number
	jc      display_help_text

	;;;     we should ensure the element size is
	;;;     1024 <= >= 8192 and is a power of 2
	;;;     ie, 1024,2048,4096,8192
	;;;     
	cmp     cx,1024
	jbe     eis1024
	cmp     cx,2048
	jbe     eis2048
	cmp     cx,4096
	jbe     eis4096
	mov     cx,8192
	jmp     short eisset
eis1024:
	mov     cx,1024
	jmp     short eisset
eis2048:
	mov     cx,2048
	jmp     short eisset
eis4096:
	mov     cx,4096
eisset:
	
	mov     cs:cache_block_bytes,cx
	shr     cx,1
	mov     cs:cache_block_words,cx
	jmp     scan_parse

check_buffer_flag:
	cmp     al,BUFFER_FLAG
	jne     check_drive_flag
	call    parse_number
	jc      display_help_text

	mov     cs:target_buffer_size,cx
	jmp     scan_parse

check_drive_flag:
	cmp     al,DRIVE_FLAG
	jne     display_help_text
	jmp     display_help_text
	call    get_next_char
	jc      display_help_text       
	cmp     al,'a'
	jb      display_help_text ;bug bug correct error message
	cmp     al,'z'
	ja      display_help_text ;bug bug correct error message
	sub     al,'a'          ; a = 0, b=1

	;;;     if resident already, we need to call resident guy
	cmp     cs:first_instance,0
	je      notify_resident
	
	push    bx
	mov     bl,al
	xor     bh,bh
	mov     drives_to_cache[bx],1
	pop     bx      
	clc
	jmp     scan_parse

notify_resident:
	push    bp
	push    bx
	xor     ah,ah
	mov     bp,ax
	mov     dl,1
	mov     ax,BAMBI_CACHE_DRIVE
	call    call_bambi
	pop     bx 
	pop     bp
	clc
	jmp     scan_parse

reinitialize:
		
	call    parse_number
	jnc     number_ok
	jmp     display_help_text
number_ok:
	;;note CX holds new number of cache elements    
	push    cx
	call    init_bambi_io
	mov     ax,BAMBI_COMMIT_ALL
	call    call_bambi
	pop     cx

	mov     dx,0800h        ;BUG BUG this is hardcoded
	mov     ax,BAMBI_REINITIALIZE
	call    call_bambi
	stc
	ret
				
parse_command_line endp

setcommitflag:
	mov     cs:commitflag,0
	jmp     scan_parse

zseg ends

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\dec_out.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


;
;OVERVIEW
;       This module contains an asm callable function for
;displaying a dword value in decimal, right justifed with commas
;The primary entry point is display_dec_dword
;


zseg    segment public 'CODE'

	assume  cs:zseg,ds:zseg,es:zseg

PUBLIC  display_dec_dword
PUBLIC  set_thousands_separator


separator_char  db      ','

;Routines to output 32-bit decimal numbers, space justified, w/commas

radix   dw      10              ; number base for output

obuf    db      10 dup (?)      ; buffer


;FUNCION
;       display 32-bit value to stdout in pretty-display decimal
;       (see display_dec_dword below)
;INPUT
;       DX:BX = value to be displayed
;OUTPUT
;       none
;USES
;       ALL
dec_output proc near

	push    cs              ; point ds/es -> our code segment
	pop     es
	push    cs
	pop     ds
	mov     di,offset obuf
	mov     si,di           ; si/di -> buffer
	mov     cx,length obuf
	mov     al,' '          ; space fill
	cld
	rep     stosb

;       Leave di -> end of output buffer + 1

	mov     ax,dx           ; get number into ax:bx

div_loop:
	xor     dx,dx
	div     radix           ; divide high 16 bits by radix
	xchg    ax,bx           ; high 16 -> bx, low 16 -> ax
	div     radix           ; divide low 16 bits by radix
	xchg    ax,bx           ; low 16 -> bx, high 16 -> ax
	add     dl,'0'          ; convert remainder to ASCII
	dec     di
	mov     byte ptr [di],dl        ; save remainder
	or      ax,ax           ; loop until result of divide is zero
	jnz     div_loop
	or      bx,bx
	jnz     div_loop

;       Now our number is in the buffer.  Output it with comma insertion.

	call    o1dig
	call    comma3
	call    comma3
comma3:
	cmp     al,' '          ; was last character a space?
	jz      comma3_no       ;  no comma if not
	mov     al,separator_char       ; insert comma once we hit real digits
comma3_no:
	call    cofa
	call    o1dig
	call    o1dig
o1dig:
	lodsb
	cmp     al,' '
	je      dont_pad

cofa:
	push    ax
	mov     dl,al
	mov     ah,2
	int     21h             ; output char through DOS
	pop     ax
dont_pad:
	ret
dec_output endp

;
;FUNCION
;       display 32-bit value to stdout in pretty-display decimal
;       (see display_dec_dword below)
;INPUT
;       DX:BX = value to be displayed
;OUTPUT
;       none
;USES
;       none
display_dec_dword proc near
	push    ax
	push    bx
	push    cx
	push    dx
	push    si
	push    di
	push    es
	push    ds
	call    dec_output
	pop     ds
	pop     es
	pop     di
	pop     si
	pop     dx
	pop     cx
	pop     bx
	pop     ax
	ret
display_dec_dword endp



CountryBuffer struc
			Date_Format     db  2 dup(?)
			Currency_Symbol db  5 dup(?)
			Thousands_Sep   db  2 dup(?)
			Decimal_Sep     db  2 dup(?)
			Date_Sep        db  2 dup(?)
			Time_Sep        db  2 dup(?)
			Currency_Pos    db  ?
			Num_Decimals    db  ?
			Time_Format     db  ?
			Case_Mapping    dd  ?
			Data_Sep        db  2 dup(2)
			Reserved        db 10 dup(?)
			;;;;size of structure must be at least 34 bytes!!
CountryBuffer ends

nationdata      CountryBuffer <>

set_thousands_separator proc near
	lea     dx, nationdata          ; DS:DX points to NationBuffer
	mov     ax,3800h                        ; Get Current Country info
	int     21h                             ; If success, Carry clear and BX = country code
	jc      use_default_separator
	mov     al,nationdata.thousands_sep
	mov     separator_char,al

use_default_separator:
	ret

set_thousands_separator endp

zseg    ends
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\dev.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;
;OVERVIEW
;	
;	This module contains the first bytes of the .exe file.  The
;first bytes indicate that the .exe is a DEVICE DRIVER.  Thus, this is
;a device driver header.  See devini.asm for how device driver calls
;are handled.  (basically just prints a message that the cache cannot
;be loaded as a device driver)

zseg    segment	public 'CODE'

	assume  cs:zseg
	assume	ds:nothing

PUBLIC  header
PUBLIC  devattr

extrn	tempstrategy		:far
extrn	tempinterrupt		:far

	org     0

header:
	dd      -1                      ;device chain link--filled in by dos
devattr dw      0C840h                  ;character device attribute word
	dw      tempstrategy            ;Strategy entry point
	dw      tempinterrupt           ;Interrupt entry point
	db      'bambino'	        ;logical device name

zseg ends

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\cacheman.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

include	bambi.inc

public	buffer_to_cache
public	cache_to_buffer
public	reinitialize_cache

;
;	data from rdata.asm
;
extrn	cache_block_bytes	:word
extrn	cache_block_words	:word
extrn	in_bambi		:byte
extrn	XMShandlevalid		:byte
extrn	XMShandle		:word

;
;	routines from xms.asm
;
extrn	block_write		:near
extrn	block_read		:near
extrn	reallocate_xms_memory	:near
;
;	routines from queueman.asm
;
extrn	initqueue		:near



zseg    segment public 'CODE'

	assume  cs:zseg
	assume  ds:zseg



; BUG BUG assumes ptr+size does not wrap segment
; INPUT
;	ES:DI = Near Buffer 
;       CX = number of words to copy
;	BP = Cache entry index	
;	SI = offset into cache buffer

Buffer_To_Cache proc near

	push	bp	
	mov	ax,cs:cache_block_words
	mul	bp			; use word index, multiply by words
	add	ax,si			; note that on 386 mul will be 9 clocks
	adc	dx,0	

	mov	bx,cs:XMShandle
	call	Block_Write
	pop	bp

;	push bp
;	push ax
;	call data_check_sum
;	shl bp,1
;	mov WORD PTR cs:buffer_sum[bp],ax
;	pop ax
;	pop bp
	ret

Buffer_To_Cache endp

; INPUT
;	ES:DI = Near Buffer 
;       CX = number of words to copy
;	BP = Cache entry index	
;	SI = offset into cache buffer
Cache_To_Buffer proc near


;	push ax
;	push bp
;	call data_check_sum
;	shl bp,1
;	cmp WORD PTR cs:buffer_sum[bp],ax
;	pop bp
;	pop ax

cache_to_buffer_no_check_sum:

	mov	ax,cs:cache_block_words
	mul	bp

	add	ax,si
	adc	dx,0

	mov	bx,cs:XMShandle
	jmp	Block_Read	

Cache_To_Buffer endp


;
;	INPUT
;		CX number of cache elements
;	OUTPUT
;		none
reinitialize_cache proc near

	inc	cs:in_bambi

	push	cx

	mov	ax,cx
	mul	cs:cache_block_bytes
	
	mov	si,1024
	div	si
	mov	bx,ax
	;bx = K to allocate
	;dx = handle
	mov	dx,cs:XMShandle
	call	ReAllocate_XMS_Memory
	or	ax,ax
	pop	cx
	jz	realloc_error1

	call	InitQueue
	
	dec	cs:in_bambi
	clc
	ret		

realloc_error1:
	mov	ax,ERROR_ALLOCATION_FAILED	
	dec	cs:in_bambi
	stc
	ret	
reinitialize_cache endp

zseg ends

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\checksum.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */



PUBLIC  data_check_sum
PUBLIC  buffer_sum

extrn	QueueLength:WORD
extrn	cache_block_words:WORD
extrn	cache_to_buffer_no_check_sum:near


zseg    segment public 'CODE'

	assume  cs:zseg

CHECKSUMBUFFERSIZE 	equ	1000h
check_sum_buffer	db	CHECKSUMBUFFERSIZE dup(?)
buffer_sum		dw	CHECKSUMBUFFERSIZE dup(?)

;
; INPUT
;	BP = buffer to checksum
; OUTPUT
;	AX = checksum for this buffer
;
data_check_sum proc near
	int	3

	push	es
	push	bp
	push	di
	push	si
	push	bx
	push 	cx
	push	dx

	push	cs
	pop	es

	mov	di,offset cs:check_sum_buffer

	push	cx
	mov	cx,cs:cache_block_words
	xor	si,si
	call	Cache_To_Buffer_no_check_sum
	pop	cx

	xor	ax,ax
	mov	cx,cs:cache_block_words
buffer_sum_loop:
	mov	bx,cx
	dec	bx
	add	bx,bx
	add	ax,WORD PTR cs:check_sum_buffer[bx]
	loop	buffer_sum_loop
	pop	dx
	pop	cx
	pop	bx
	pop	si
	pop	di
	pop	bp
	pop	es
	ret		
data_check_sum endp

zseg ends

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\devini.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;
;OVERVIEW
;
;	This module contains the strategy and interrupt entry points for
;the cache's dummy device driver.  This copies the safedsk device driver
;on top of the cache segment so the safedsk.sys will be loaded.
;

vseg segment para public 'CODE'
vseg ends

zseg    segment public 'CODE'

	assume  cs:zseg
	assume	ds:nothing

extrn	header			:near
extrn	devattr			:word
extrn	last_safe_byte		:byte
extrn	interrupt		:near
extrn	strategy		:near

PUBLIC	tempstrategy
PUBLIC	tempinterrupt
PUBLIC	RHPtr

RHPtr   dd      ?                       ;Request Header pointer filled in by 
					;Strategy routing



tempstrategy        proc    far

	mov     WORD PTR cs:[RHPtr],bx
	mov     WORD PTR cs:[RHPTR+2],es
	ret

tempstrategy        endp

tempinterrupt       proc    far

	push	es
	push	ds
	push	cx
	push	di
	push	si

	;;;copy the safedsk on top of the current device header.
	;;;We do this so the device driver will not be part of the
	;;;TSR when it is loaded.
	;;;We have put the safedsk into its own 0 org'd segment
	;;; named "vseg" so we can just copy right on top of the 
	;;;0 org'd temp driver.
	;;;
	;;;Once loaded, we need to call the safedsk interrupt routine
	;;;since init won't be called by DOS since we are in the
	;;;init call right now!
	;;;
	push	cs			
	pop	es			;destinatain = cs:0
	xor	di,di

	mov	ax,vseg		;src = vseg:0
	mov	ds,ax
	xor	si,si

	mov	cx,offset vseg:last_safe_byte 	;get offet of last label in safedsk
	inc	cx			      	;round up
	shr	cx,1			      	;movsw does two bytes at a time
	rep	movsw	

	pop	si
	pop	di
	pop	cx
	pop	ds
	pop	es

	push	cs				;simulate far call to safedsk 
	call	strategy			;strategy point
	push	cs				;simulate far call to safedsk
	call	interrupt			;interrupt (init call)

	ret					;return to dos--future calls
						;will go to the safedsk
						;interrupt point because we
						;overwrote the device header

tempinterrupt       endp


zseg ends

end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\devsym.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	DevSym.inc - Device Symbols
;
; 	Revision History: 
;
;	M018 - defined bit 11 of DOS34_FLAG. See M041 in dos.tag for 
;	       explanation.
;


;	THE DEVICE TABLE LIST HAS THE FORM:

SYSDEV	       STRUC
SDEVNEXT       DD    ?		    ;POINTER TO NEXT DEVICE HEADER
SDEVATT        DW    ?		    ;ATTRIBUTES OF THE DEVICE
SDEVSTRAT      DW    ?		    ;STRATEGY ENTRY POINT
SDEVINT        DW    ?		    ;INTERRUPT ENTRY POINT
SDEVNAME       DB    '        '	    ;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
SYSDEV	       ENDS

;
; ATTRIBUTE BIT MASKS
;
; CHARACTER DEVICES:
;
; BIT 15 -> MUST BE 1
;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
;     13 -> 1 IF THE DEVICE SUPPORTS OUTPUT-UNTIL-BUSY
;     12 -> UNUSED
;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE
;     10 -> MUST BE 0
;      9 -> MUST BE 0
;      8 -> UNUSED - Must be 0 to support current versions of Mace Utilities
;      7 -> SUPPORTS DEVICE QUERY
;      6 -> UNUSED
;      5 -> UNUSED
;      4 -> 1 IF DEVICE IS RECIPIENT OF INT 29H
;      3 -> 1 IF DEVICE IS CLOCK DEVICE
;      2 -> 1 IF DEVICE IS NULL DEVICE
;      1 -> 1 IF DEVICE IS CONSOLE OUTPUT
;      0 -> 1 IF DEVICE IS CONSOLE INPUT
;
; BLOCK DEVICES:
;
; BIT 15 -> MUST BE 0
;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
;     13 -> 1 IF THE DEVICE DETERMINES MEDIA BY EXAMINING THE FAT ID BYTE.
;	    THIS REQUIRES THE FIRST SECTOR OF THE FAT TO *ALWAYS* RESIDE IN
;	    THE SAME PLACE.
;     12 -> UNUSED
;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE/REMOVABLE MEDIA
;     10 -> MUST BE 0
;      9 -> MUST BE 0
;      8 -> UNUSED - Must be 0 to support current versionso of Mace Utilities
;      7 -> SUPPORTS DEVICE QUERY
;      6 -> IF DEVICE HAS SUPPORT FOR GETMAP/SETMAP OF LOGICAL DRIVES.
;	    IF THE DEVICE UNDERSTANDS GENERIC IOCTL FUNCTION CALLS.
;      5 -> UNUSED
;      4 -> UNUSED
;      3 -> UNUSED
;      2 -> UNUSED
;      1 -> UNUSED
;      0 -> UNUSED
;

DEVTYP	       EQU   8000H	    ; BIT 15 - 1  IF CHAR, 0 IF BLOCK
CHARDEV        EQU   8000H
DEVIOCTL       EQU   4000H	    ; BIT 14 - CONTROL MODE BIT
ISFATBYDEV     EQU   2000H	    ; BIT 13 - DEVICE USES FAT ID BYTES,
				    ;  COMP MEDIA.
OUTTILBUSY     EQU   2000H	    ; OUTPUT UNTIL BUSY IS ENABLED
ISNET	       EQU   1000H	    ; BIT 12 - 1 IF A NET DEVICE, 0 IF
				    ;  NOT.  CURRENTLY BLOCK ONLY.
DEVOPCL        EQU   0800H	    ; BIT 11 - 1 IF THIS DEVICE HAS
				    ;  OPEN,CLOSE AND REMOVABLE MEDIA
				    ;  ENTRY POINTS, 0 IF NOT

EXTENTBIT      EQU   0400H	    ; BIT 10 - CURRENTLY 0 ON ALL DEVS
				    ;  THIS BIT IS RESERVED FOR FUTURE USE
				    ;  TO EXTEND THE DEVICE HEADER BEYOND
				    ;  ITS CURRENT FORM.

; NOTE BIT 9 IS CURRENTLY USED ON IBM SYSTEMS TO INDICATE "DRIVE IS SHARED".
;    SEE IOCTL FUNCTION 9. THIS USE IS NOT DOCUMENTED, IT IS USED BY SOME
;    OF THE UTILITIES WHICH ARE SUPPOSED TO FAIL ON SHARED DRIVES ON SERVER
;    MACHINES (FORMAT,CHKDSK,RECOVER,..).

; M017 IOQUERY	       EQU   0100H	    ;Bit 8 - Supports generic IOCtl query
IOQUERY	       EQU   080H	    ;Bit 7 - Supports generic IOCtl query M017


DEV320	       EQU   0040H	    ;BIT 6 - FOR BLOCK DEVICES, THIS
				    ;DEVICE SUPPORTS SET/GET MAP OF
				    ;LOGICAL DRIVES, AND SUPPORTS
				    ;GENERIC IOCTL CALLS.
				    ;FOR CHARACTER DEVICES, THIS
				    ;DEVICE SUPPORTS GENERIC IOCTL.
				    ;THIS IS A DOS 3.2 DEVICE DRIVER.
ISSPEC	       EQU   0010H	    ;BIT 4 - THIS DEVICE IS SPECIAL
ISCLOCK        EQU   0008H	    ;BIT 3 - THIS DEVICE IS THE CLOCK DEVICE.
ISNULL	       EQU   0004H	    ;BIT 2 - THIS DEVICE IS THE NULL DEVICE.
ISCOUT	       EQU   0002H	    ;BIT 1 - THIS DEVICE IS THE CONSOLE OUTPUT.
ISCIN	       EQU   0001H	    ;BIT 0 - THIS DEVICE IS THE CONSOLE INPUT.
EXTDRVR        EQU   0002H	    ;BIT 1 - BLOCK DEVICE EXTNDED DRIVER



;STATIC REQUEST HEADER
SRHEAD	       STRUC
REQLEN	       DB    ?		    ;LENGTH IN BYTES OF REQUEST BLOCK
REQUNIT        DB    ?		    ;DEVICE UNIT NUMBER
REQFUNC        DB    ?		    ;TYPE OF REQUEST
REQSTAT        DW    ?		    ;STATUS WORD
	       DB    8 DUP(?)	    ;RESERVED FOR QUEUE LINKS
SRHEAD	       ENDS

;STATUS WORD MASKS
STERR	       EQU   8000H	    ;BIT 15 - ERROR
STBUI	       EQU   0200H	    ;BIT 9 - BUISY
STDON	       EQU   0100H	    ;BIT 8 - DONE
STECODE        EQU   00FFH	    ;ERROR CODE
;						  2/12/KK
; Interim  character identifier 		  2/12/KK
Ddkey		EQU	0000010000000000B	; 2/12/KK

;FUNCTION CODES
DINITHL        EQU   26 	    ;SIZE OF INIT HEADER
DMEDHL	       EQU   15 	    ;SIZE OF MEDIA CHECK HEADER
DBPBHL	       EQU   22 	    ;SIZE OF GET BPB HEADER
DRDWRHL        EQU   22 	    ;SIZE OF RD/WR HEADER
DRDNDHL        EQU   14 	    ;SIZE OF NON DESTRUCTIVE READ HEADER
DSTATHL        EQU   13 	    ;SIZE OF STATUS HEADER
DFLSHL	       EQU   15 	    ;SIZE OF FLUSH HEADER

DEVINIT        EQU   0		    ;INITIALIZATION
DEVMDCH        EQU   1		    ;MEDIA CHECK
DEVBPB	       EQU   2		    ;GET BPB
DEVRDIOCTL     EQU   3		    ;IOCTL READ
DEVRD	       EQU   4		    ;READ
DEVRDND        EQU   5		    ;NON DESTRUCTIVE READ NO WAIT (CHARACTER DEVS)
DEVIST	       EQU   6		    ;INPUT STATUS
DEVIFL	       EQU   7		    ;INPUT FLUSH
DEVWRT	       EQU   8		    ;WRITE
DEVWRTV        EQU   9		    ;WRITE WITH VERIFY
DEVOST	       EQU   10 	    ;OUTPUT STATUS
DEVOFL	       EQU   11 	    ;OUTPUT FLUSH
DEVWRIOCTL     EQU   12 	    ;IOCTL WRITE
DEVOPN	       EQU   13 	    ;DEVICE OPEN
DEVCLS	       EQU   14 	    ;DEVICE CLOSE
DOPCLHL        EQU   13 	    ;SIZE OF OPEN/CLOSE HEADER
DEVRMD	       EQU   15 	    ;REMOVABLE MEDIA
REMHL	       EQU   13 	    ;SIZE OF REMOVABLE MEDIA HEADER
GENIOCTL       EQU   19

; THE NEXT THREE ARE USED IN DOS 4.0
;		     20
;		     21
;		     22

DEVGETOWN      EQU   23 	    ;GET DEVICE OWNER
DEVSETOWN      EQU   24 	    ;SET DEVICE OWNER
IOCTL_QUERY    EQU   25		    ;Query generic ioctl support

OWNHL	       EQU   13 	    ;SIZE OF DEVICE OWNER HEADER

DEVOUT	       EQU   16 	    ; OUTPUT UNTIL BUSY.

DEVOUTL        EQU   DEVWRT	    ; LENGTH OF OUTPUT UNTIL BUSY

; ADDED FOR DOS 5.00
;


; GENERIC IOCTL REQUEST STRUCTURE
;	SEE THE DOS 4.0 DEVICE DRIVER SPEC FOR FURTHER ELABORATION.
;
IOCTL_REQ      STRUC
	       DB    (SIZE SRHEAD) DUP(?)
				    ; GENERIC IOCTL ADDITION.
MAJORFUNCTION  DB    ?		    ;FUNCTION CODE
MINORFUNCTION  DB    ?		    ;FUNCTION CATEGORY
REG_SI	       DW    ?
REG_DI	       DW    ?
GENERICIOCTL_PACKET DD ?	    ; POINTER TO DATA BUFFER
IOCTL_REQ      ENDS

;	DEFINITIONS FOR IOCTL_REQ.MINORFUNCTION
GEN_IOCTL_WRT_TRK   EQU   40H
GEN_IOCTL_RD_TRK    EQU   60H
GEN_IOCTL_FN_TST    EQU   20H	    ; USED TO DIFF. BET READS AND WRTS

;; 32-bit absolute read/write input list structure

ABS_32RW	 STRUC
SECTOR_RBA	 DD	 ?	    ; relative block address
ABS_RW_COUNT	 DW	 ?	    ; number of sectors to be transferred
BUFFER_ADDR	 DD	 ?	    ; data addrress
ABS_32RW	 ENDS

;; media ID info

MEDIA_ID_INFO	 STRUC
MEDIA_level	 DW	 0	    ; info level
MEDIA_Serial	 DD	 0	    ; serial #
MEDIA_Label	 DB	 11 dup (' ') ;volume label
MEDIA_System	 DB	 8  dup (' ') ;system type
MEDIA_ID_INFO	 ENDS

;; equates for DOS34_FLAG
;
; BUGBUG: why are bits 0,1,3 and 4 not defined.
;

FROM_DISK_RESET       EQU   000000000100b   ;from disk reset
Force_I24_Fail	      EQU   000000100000b   ;form IFS CALL BACK
Disable_EOF_I24       EQU   000001000000b   ;disable EOF int24 for input status
DBCS_VOLID	      EQU   000010000000b   ;indicate from volume id
DBCS_VOLID2	      EQU   000100000000b   ;indicate 8th char is DBCS
CTRL_BREAK_FLAG       EQU   001000000000b   ;indicate control break is input
SEARCH_FASTOPEN       EQU   010000000000b   ;set fastopen flag for search
EXEC_AWARE_REDIR      EQU   100000000000b   ;M018: this bit is set by a redir 
					    ;M018: that knows how to handle 
					    ;M018: open for exec

NO_FROM_DISK_RESET    EQU   NOT FROM_DISK_RESET	;not from disk reset
NO_Force_I24_Fail     EQU   NOT Force_I24_Fail	;not form IFS CALL BACK
NO_Disable_EOF_I24    EQU   NOT Disable_EOF_I24

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\dirtywrt.asm ===
page	,132
debug	=	1
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;	This is the module which provides the interface for Queueman
;	to call back into Bambi.asm when it wants to commit dirty
;	cache elements to the disk.  It is very intimately tied to
;	Bambi.asm, as it uses several entry points into Bambi.asm's
;	utility subroutines, and also uses many of its variables.
;
;	The interface from this module to Queueman is much cleaner,
;	consisting of a single call to our public label, dirty_write.
;
;	This module also calls warning_pop_up when it detects a
;	fatal disk problem during a write-behind.


	.xlist
	include	bambi.inc
	include	devsym.inc
	.list

public	dirty_write		; this is our entry point from queueman.asm

zseg	segment	dword public 'code'
	assume	cs:zseg
	assume	ds:nothing

;	define entry points to bambi.asm

	extrn	set_start_sector:near
	extrn	call_dd_common:near
	extrn	read_full_cache_block:near
	extrn	lookup_device:near

;	Define entry points to popup.asm

	extrn	warning_pop_up:near

;	some of our extrn data is actually located in bambi.asm

	extrn	our_count:word
	extrn	our_trans_off:word
	extrn	our_trans_seg:word
	extrn	our_starth:word
	extrn	our_startl:word
	extrn	our_start:word
	extrn	loc_reqblk:dword
	extrn	last_buffer:word
	extrn	lb_seg:word

	extrn	dirty_h:word
	extrn	dirty_l:word

	extrn	max_valid_buffers:word
	extrn	num_valid_buffers:word

	extrn	cache_block_bytes:word
	extrn	rblk_op:byte
	extrn	media_id:byte
	extrn	media_ids:byte
	extrn	packet_size:byte
	extrn	packet_sizes:byte

	extrn	accessing_swap_file_ptr	:dword

;	Here are our own local variables

wrt_dd_header		dd	0
wrt_align_factor	dw	0	; written as byte, read as word
wrt_secsize_bytes	dw	0
wrt_cache_unit		db	0
wrt_unmapped_unit	db	0

;-----------------------------------------------------------------------
;
;	Here's where Queueman calls us back for disk writes
;
;	parameters:
;	  ax == 16 bit dirtyindex
;	  di/si == block number to write
;	  bp == element identifier of block in cache

	if	debug
in_dirty	db 0	
	endif

dirty_write	proc	near
	assume	cs:zseg,ds:nothing,es:nothing

	push	ax
	push	bx
	push	cx
	push	dx
	push	bp
	push	si
	push	di
	push	ds

	push	cs
	pop	ds
	assume	ds:zseg			; assure addressability

	push	es

	if	debug
	inc	in_dirty
	cmp	in_dirty,1
	je	not_bogus

bogus_bogus:
	int	1
	mov	al,'!'-'A'
	call	warning_pop_up
	jmp	bogus_bogus

not_bogus:
	endif

	add	dirty_l,1
	adc	dirty_h,0

;
;	First we've got to load that block out of the cache into
;	  our local buffer, then write it out to disk.
;
;	the mask code in ax tells us exactly which of the blocks
;	  are dirty.


	push	ax			; save dirty mask
	push	di			; save write block number
	push	si

	mov	ax,di
	mov	al,ah

	mov	wrt_unmapped_unit,al	; save for error reporting

	;;; setup the drive unit so enhanced mode windows
	;;; can know the drive letter if it gets an error
	push	es
	push	di
	les	di,cs:accessing_swap_file_ptr
	mov	es:[di].delay_write_drive_unit,al
	pop	di
	pop	es

;	******  Get logical unit code to write to into al

	push	bp			; save handle
	call	lookup_device
	and	al,3fh			; ignore status bits
	mov	wrt_cache_unit,al	; save unit code
	mov	byte ptr wrt_align_factor,ch
	mov	word ptr wrt_dd_header,dx	; save dd header
	mov	word ptr wrt_dd_header[2],bp
	mov	ax,cache_block_bytes	; calculate sector size in bytes
	shr	ax,cl
	mov	wrt_secsize_bytes,ax

	pop	bp			; restore handle

	mov	ax,max_valid_buffers	; is super-cache full?
	cmp	ax,num_valid_buffers
	jnz	no_truncate_super_cache
	dec	num_valid_buffers	; trash last block
no_truncate_super_cache:

	mov	di,last_buffer		; point to last buffer
	mov	es,lb_seg

	push	di
	push	cx			; save cache block shift factor
	call	read_full_cache_block	; read into our local buffer
	pop	cx			; restore cache block shift
	pop	di

;	There's a block at lb_seg:di which needs to get written to
;	  disk at wrtblk.  The cl register (on stack) contains a mask which
;	  says which sectors are actually dirty.

	pop	ax			; get block number low
	pop	dx			; get block number high
	xor	dh,dh			;mask off unit code


	mov	bx,0ffffh	; use bx as scratch register in 32-bit left
;				;  shift by cl.  This is for converting a
;				;  block number to its base sector address.

	rol	ax,cl
	shl	dx,cl
    	shl	bx,cl
    	mov	cx,ax
    	and	ax,bx
	not	bx
	and	cx,bx
	or	dx,cx

	pop	cx			; restore mask word into cx
	jcxz	dirtywrt_done		; this shouldn't happen
;					; but if it did, we'd hang without it

	xor	bx,bx			; zero the count of blocks written
;					;  in a previous I/O.

	sub	ax,wrt_align_factor
	sbb	dx,bx			; **** ASSUME BX == 0 ****

;	Now, we have to skip through our mask register to find what
;	  needs to be written and write it.  Notice that we'll loop
;	  back to here after writing if there are non-adjacent blocks,
;	  so that we may update the transfer pointer and sector number
;	  for the next I/O.  In this case, BX will have the number of
;	  sectors just written, which must be added to the number of
;	  intervening clean sectors.


clean_sector_count_loop:
	inc	bx			; count clean sectors
	shr	cx,1			; and shift the mask right one bit
	jnc	clean_sector_count_loop	; loop until we find a dirty one

	dec	bx			; okay, we went one too far.

	push	ax
	push	dx			; damn!  MUL needs these registers
	mov	ax,wrt_secsize_bytes
	mul	bx
	add	di,ax			; update transfer pointer to next dirty
	pop	dx
	pop	ax
	add	ax,bx		; update sector number
	adc	dx,0

;	SCORE!  We found a dirty sector!  Now decide how many consecutive
;	dirty_bits there are to write.  For every contiguous one-bit we
;	find starting from the low-end of cl, we'll add one to the number
;	of sectors we're going to write out in the next I/O.

	xor	bx,bx			; init count to 0

count_consecutive_dirtys:
	inc	bx
	shr	cx,1			; shift out while bits are dirty
	jc	count_consecutive_dirtys

	shl	cx,1			; put the zero bit back into bit zero

;	Now bx has sector count to write, cx has the remaining mask.

;	  BUGBUG:  An optimization exists here, which would have
;	  to take valid_bits into consideration -- It may be more
;	  efficient to go ahead and write the non-dirty sectors
;	  in between the first and last dirty ones, provided they are
;	  indeed VALID.  This might be desirable if the amount of
;	  overhead in sending write commands to the disk controller
;	  is too large for the subsequent command to be fully issued
;	  during the passage of the intervening sectors.
;
;	  The downside of this optimization is that it actually
;	  causes excess writing to be done, ie:  Sectors are theoretically
;	  written with their existing content.  There is some chance that
;	  a data transfer error, most likely on the disk controller or
;	  in XMS storage, will cause corruption of the hard disk during
;	  any given write operation, so writing data redundantly
;	  exposes the user's data to a small risk.

	push	cx			; retain mask for later
	call	write_sectors		; write bx blocks from sector dx:ax
	pop	cx			; restore mask accumulator

	or	cx,cx
	jnz	clean_sector_count_loop

dirtywrt_done:

	if	debug
	dec	in_dirty
	endif

	pop	es
	pop	ds
	pop	di
	pop	si
	pop	bp
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret

dirty_write	endp

;-----------------------------------------------------------------------
;
;	write bx sectors to disk, starting at sector dx:ax, from
;	  lb_seg:di.  Must preserve bx, ax, dx, and di.

write_sectors	proc	near
	assume	cs:zseg,ds:zseg,es:nothing

;	save parameter registers for retries and restoring upon exit

	push	ax			; save start sector
	push	dx
	push	bx			; save sector count
	push	di			; save transfer address

;	stick parameter registers into request block as appropriate.

	mov	our_trans_off,di	; save for actual disk write
	mov	our_count,bx

	;;;maintain packetsize and mediaid across dirty write!
	mov	bh,packet_size
	mov	bl,media_id
	push	bx

	les	bx,wrt_dd_header	; point to device header
	call	set_start_sector	; set the startint sector from ax:dx

	mov	ax,lb_seg
	mov	our_trans_seg,ax	; set transfer segment

	xor	bh,bh
	mov	bl,wrt_unmapped_unit
	mov	al,byte ptr media_ids[bx]
	mov	byte ptr media_id,al

	mov	al,byte ptr packet_sizes[bx]
	mov	byte ptr packet_size,al

	or	dx,dx			;access above 32 meg must
	jz	ss16done		;have larger packet size,
					;note that packet is 
					;always correct for < 32 meg
					;since we set both fields
	cmp	packet_size,18h
	ja	ss16done
	mov	packet_size,18h	
ss16done:


	les	bx,loc_reqblk
	mov	byte ptr rblk_op,devwrt

	mov	al,wrt_cache_unit	; get remapped cache unit
	mov	es:byte ptr [bx].requnit,al

	call	call_wrt_dd		; call into selected device driver

	pop	bx			;restore mediaid and packet size
	mov	packet_size,bh	
	mov	media_id,bl

	les	bx,loc_reqblk
	test	es:[bx].reqstat,8000h
	jnz	handle_fatal_write_error ; go prompt user if error

;	restore registers and exit

ignore_fatal_write_error:
	pop	di			; restore transfer address
	pop	bx			; restore count
	pop	dx			; restore start sector
	pop	ax
	ret				; and back to caller

;	Shit!  Fatal error on write-behind!  Ask user what to do with
;	  sleazy popup.

handle_fatal_write_error:
	mov	al,wrt_unmapped_unit	; get drive code
	call	warning_pop_up
	cmp	al,ASCIICODE_RETRY
	jnz	ignore_fatal_write_error

	pop	di			; restore transfer address
	pop	bx			; restore count
	pop	dx			; restore start sector
	pop	ax
	jmp	write_sectors		; and back to front of this routine
;					;  to retry


write_sectors	endp

;-----------------------------------------------------------------------
;
;	call through to the write behind device driver

call_wrt_dd	proc	near
	assume	cs:zseg,ds:zseg,es:nothing

	push	ds			; save caller's ds
	lds	si,wrt_dd_header 	; get actual device's header
	assume	ds:nothing
	jmp	call_dd_common		; and join regular dd calling code

call_wrt_dd	endp

;-----------------------------------------------------------------------

zseg	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\int2f.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;
;
;Bambi cache interface multiplex:
;
;       MULT_BAMBI(ax)                                  equ     4a10h
;            BAMBI_GET_STATS(bx)                        equ        0
;            BAMBI_COMMIT_ALL(bx)                       equ        1
;            BAMBI_REINITIALIZE(bx)                     equ        2
;            BAMBI_CACHE_DRIVE(bx)                      equ        3
;                  CACHE_DRIVE_GET(dl)                  equ        0
;                  CACHE_DRIVE_READ_ENABLE(dl)          equ        1
;                  CACHE_DRIVE_READ_DISABLE(dl)         equ        2
;                  CACHE_DRIVE_WRITE_ENABLE(dl)         equ        3
;                  CACHE_DRIVE_WRITE_DISABLE(dl)        equ        4
;            BAMBI_GET_INFO(bx)                         equ        4    
;            BAMBI_GET_ORIGINAL_DD_HEADER(bx)           equ     7
;
;       the following is a temporary function for a debug version

	     BAMBI_INTERNAL_POINTERS                    equ        10
;       BAMBI_SIGNATURE                                 equ     BABEh
;
;BAMBI_GET_STATS:
;FUNCTION:
;       Gets cache hit/miss statistics as well as detects presense of cache.
;
;       INPUT:
;               AX=MULT_BAMBI
;               BX=BAMBI_GET_STATS
;       OUTPUT:
;               AX=BAMBI_SIGNATURE
;               DI=cache misses (hiword)
;               SI=cache misses (loword)
;               DX=cache hits (hiword)
;               BX=cache hits (loword)
;               CX=number of uncommitted (dirty) blocks
;               BP=version number in binary (0400h)
;       USED:
;               All except DS,ES
;
;BAMBI_COMMIT_ALL:
;FUNCTION:
;       Commits all uncommitted blocks (dirty blocks) to disk.
;
;       INPUT:
;               AX=MULT_BAMBI
;               BX=BAMBI_COMMIT_ALL
;       OUTPUT:
;               NONE
;       USED:   
;               NONE
;
;BAMBI_REINITIALIZE:
;FUNCTION:
;       Commits all uncommitted blocks to disk and invalidates the cache.
;Re-sizes the cache with input parameters.
;       INPUT:
;               AX=MULT_BAMBI
;               BX=BAMBI_REINITIALIZE
;               CX=number of cache elements
;               DX=size of cache elments
;       OUTPUT:
;               carry set if procedure unable to complete via XMS errors
;       USED:
;               ALL except DS,ES
;
;BAMBI_CACHE_DRIVE:
;FUNCTION:
;       Enables and disables read or write caching for a particular drive unit.
;Returns the cache state of the drive in DL. Get takes no action, but simply
;returns cache state for drive unit in DL.
;       INPUT:
;               AX=MULT_BAMBI
;               BX=BAMBI_CACHE_DRIVE
;               DL=CACHE_DRIVE_<get,read|write enable|disable>
;               BP=unit number of drive 
;       OUTPUT:
;               DL=cache state of unit:
;                       Bit 8 set -> no caching enabled for this unit
;                       Bit 8 not set -> read caching enabled for this unit
;                       Bit 7 set -> write caching not enabled for this unit
;                       Bit 7 not set -> write caching enabled for this unit
;                       -1 -> not a cachable drive
;       USES:
;               ALL except DS,ES
;
;BAMBI_GET_INFO:
;FUNCTION:
;       Get the current size of the cache.
;       INPUT:
;               AX=MULT_BAMBI
;               BX=BAMBI_GET_INFO
;       OUTPUT:
;               CX=size of cache block in bytes
;               AX=number of cache blocks while in dos
;               BX=number of cache blocks in cache
;       USES:
;               ALL except DS,ES
;
;BAMBI_GET_ORIGINAL_DD_HEADER:
;FUNCTION:
;       Returns a pointer to the original device header for a given
;       drive, along with the unit number which represents it on
;       the original device.
;       INPUT:
;               AX=MULT_BAMBI
;               BX=BAMBI_GET_ORIGINAL_DD_HEADER
;               BP=unit number of drive 
;       OUTPUT:
;               DL=original unit number
;            ES:DI=original device header
;       USES:
;               ALL except DS
;
;BAMBI_INTERNAL_POINTERS:
;FUNCTION:
;       return a pointer to a structure which describes the main cache
;       data structures.  This is intended to be used by a program which
;       takes a snapshot of the contents, for analyzing what is contained
;       in the cache at any given moment.
;       INPUT:
;               AX=MULT_BAMBI
;               BX=BAMBI_INTERNAL_POINTERS
;       OUTPUT:
;               ES:BX -> data structure:
;                  *validindexoffset word,
;                  *DirtyIndexOffset word,
;                  *ElementIdentifierLowordOffset word,
;                  *ElementIdentifierHiwordOffset word,
;                  *Queuelength word.

;
include bambi.inc

public  int2fhook

;
;       data from rdata.asm
;
extrn   real_dd_headers         :dword
extrn   real_cache_units        :byte
extrn   in_bambi                :byte
extrn   in_win                  :byte
extrn   nohit_h                 :word
extrn   nohit_l                 :word
extrn   hit_h                   :word
extrn   hit_l                   :word
extrn   number_of_dirty_elements:word
extrn   int2fchain              :dword
extrn   queuelength             :word
extrn   cache_block_bytes       :word
extrn   number_of_cache_elements:word
extrn   number_of_cache_elements_win:word
;
;       routines from queueman.asm
;
extrn   commit_all_dirty        :near
extrn   initqueue               :near
;
;       routines from cacheman.asm
;
extrn   reinitialize_cache:near

extrn   warning_pop_up          :near
extrn   warning_pop_up_DOS      :near
;
;       routine from hooks.asm
;
extrn   safety_flush            :near
extrn   commit_all_when_ok      :byte
extrn   write_behind_cache      :near
extrn   invalidate_when_ok      :byte
;
; from umbload.asm
;
;extrn  startup_name_off        :word
;extrn  startup_name_seg        :word
extrn   vxd_name                :byte

zseg    segment public 'CODE'

	assume  cs:zseg
	assume  ds:nothing

dblmaptable     db      0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17
		db      18,19,20,21,22,23,24,25


;see bambi.inc for data structure definitions
smart_win_data  db size smart_win_access dup(0) ;data struction *must* be zerod
startup_info    db size Win386_Startup_Info_Struc dup(0) ;packet for vxd load
reference_ptr   dd      ?

accessing_swap_file_ptr         dd      ?

public accessing_swap_file_ptr
public smart_win_data
public startup_info
public reference_ptr

chain2fnodec:
	jmp     DWORD PTR cs:int2fchain

swappeddrv  db  ?
far_handle_dblspace:
	cmp     bx,MAGICDRV_SWAP        ;drive swap?
	jne     chain2fnodec
	
; dl = 0-based drive letter
;
	push    ax
	push    bx
	mov     ax,MAGICDRV_2F          
	mov     bx,MAGICDRV_MAP         ;get drive map from magicdrv
	pushf
	cli
	call    DWORD PTR cs:int2fchain ;by call chaining
	and     bl,7Fh
	mov     cs:swappeddrv,bl
	pop     bx
	pop     ax

	pushf                           ;let dblspace do the swap/unswap
	cli
	call    DWORD PTR cs:int2fchain
	or      al,al                   ;error means no swap occured
	jnz     not_swapped
	
	push    ax                      ;save error code (al==0)
	mov     ax,MAGICDRV_2F          
	mov     bx,MAGICDRV_MAP         ;get drive map from magicdrv
	pushf
	cli
	call    DWORD PTR cs:int2fchain ;by call chaining
	push    bp                      ;preserve registers we toast
	push    bx
	and     bx,7fh                  ;mask off high-bit, we want unit
	cmp     bl,dl                   ;if the same, we just did an unswap
	je      unswap

continueswap:
	;;;dl   holds src drive
	;;;bl   holds dest drive
	xor     dh,dh                   ;need register for index
	mov     bp,dx                   ;so use bp
	
	mov     al,cs:dblmaptable[bx]   ;swap table entries
	xchg    al,cs:dblmaptable[bp]
	mov     cs:dblmaptable[bx],al
	
	pop     bx                      ;restore regs
	pop     bp
	pop     ax                      ;and error code 

not_swapped:
	iret                            ;back to caller
unswap:
	mov     bh,cs:dblmaptable[bx]   ;get drive to unswap with
	cmp     bh,bl                   ;do we think its already swapped?
	je      handleunswapbeforeswap
	mov     bl,bh
contunswap:
	xor     bh,bh
	jmp     short continueswap
handleunswapbeforeswap:
	mov     bl,cs:swappeddrv
	jmp     short contunswap


checkidle:
	cmp     bx,18h
	jne     chain2fshort
	cmp     cx,0
	jne     chain2fshort
	cmp     cs:number_of_dirty_elements,0
	je      chain2fshort
	dec     cs:in_bambi
	call    write_behind_cache
	xor     ax,ax
	iret

chain2fshort:
	jmp     chain2f

get_page_file_access:
	cmp     bx,0021h                ;pagefile device id?
	jne     checkidle
	or      cx,cx
	jnz     chain2f

	;;; first call down the chain to see if anyone else has 
	;;; a pointer to the pagefile access byte. If not, we must
	;;; supply one!
	pushf
	cli
	call    dword ptr cs:int2fchain
	or      ax,ax
	jz      byte_in_es_di
	
	xor     ax,ax
	push    cs
	pop     es
	mov     di,offset smart_win_data
byte_in_es_di:
	push    ax
	mov     ax,cs:cache_block_bytes
	mov     es:[di].max_delayed_write_size,ax
	pop     ax
	mov     word ptr cs:accessing_swap_file_ptr[0],di       ;fill in our access pointer
	mov     word ptr cs:accessing_swap_file_ptr[2],es       ;fill in our access pointer
	dec     cs:in_bambi
	iret

handle_apm:
	cmp     bl,2                    ;standby or suspend?
	ja      chain2f                 ;chain on if not
	
;       call    flush_in_int2f          ;flush cache

	dec     cs:in_bambi             ;unset semaphore since
	mov     cs:commit_all_when_ok,1
	call    write_behind_cache      ;write_behind looks at it,
	inc     cs:in_bambi             ;its ok to re-enter here anyway

	cmp     cs:number_of_dirty_elements,0;all dirty data flushed?
	je	chain2f

;	fail the apm request

	mov     bh,80h                  ;fail code for apm
	jmp     short chain2f
		
handle_dblspace:
	jmp    far_handle_dblspace

int2fhook proc far
	cmp     ax,MAGICDRV_2F          ;dblspace ?
	je      handle_dblspace

	inc     cs:in_bambi
	cmp     ax,530Bh                ;APM call? (suspend/resume?)
	je      handle_apm

	cmp     ax,MULT_BAMBI           ;is it the bambi interface multiplex?
	je      handle_bambi_api        
	cmp     ah, 16h                 ;or the windows' 
	jne     short chain2f
	cmp     al, 05h                 ;starting up code
	je      short windows_broadcast
	cmp     al, 06h                 ;or shutting down code?
	je      short windows_broadcast
	cmp     al, 07h                 ;win386 device broadcast?
	jne     chain2f
	jmp     get_page_file_access


chain2f:
	dec     cs:in_bambi
	jmp     DWORD PTR cs:int2fchain ;chain on down if not
windows_broadcast:
	push    ax
	push    bx
	push    cx
	push    dx
	push    si
	push    di
	push    bp
	push    es
	push    ds

	call    flush_in_int2f
	cmp     al,06h
	je      winshutdown
winstartup:     
	mov     cx,cs:number_of_cache_elements_win
	mov     cs:in_win,1             ; set in windows flag


	jmp     short complete_windows_broadcast
handle_bambi_api:
	jmp     handle_bambi_api_toofar
winshutdown:

	mov     cx,cs:number_of_cache_elements
	mov     cs:in_win,0             ; reset in windows flag
complete_windows_broadcast:
	call    reinitialize_cache
	jnc     noxmserror
	call    handle_reallocfailure
noxmserror:
	pop     ds
	pop     es
	pop     bp
	pop     di
	pop     si
	pop     dx
	pop     cx
	pop     bx
	pop     ax
;;;     now handle vxd load
	pushf                                   ;chain down to get packet in es:bx
	cli                                     ;safety first
	call    DWORD PTR cs:int2fchain
	mov     cs:startup_info.SIS_Version_High,3 ;windows 3.0 compatible
	mov     cs:startup_info.SIS_Version_Low,0
	mov     word ptr cs:startup_info.SIS_Next_Dev_Ptr[0],bx ;set packet chain
	mov     word ptr cs:startup_info.SIS_Next_Dev_Ptr[2],es
	mov     word ptr cs:startup_info.SIS_Instance_Data_Ptr[0],0     ;no instance data
	mov     word ptr cs:startup_info.SIS_Instance_Data_Ptr[2],0
	push    cs
	pop     es
	mov     bx,offset cs:vxd_name
;       mov     es,cs:startup_name_seg 
;       mov     bx,cs:startup_name_off
	mov     word ptr cs:startup_info.SIS_Virt_Dev_File_Ptr[0],bx
	mov     word ptr cs:startup_info.SIS_Virt_Dev_File_Ptr[2],es
	push    cs
	pop     es
	mov     bx,offset cs:startup_info
	jmp     exit_no_chain

handle_reallocfailure:
	mov     cx,cs:number_of_cache_elements_win ;guaranteed to be <=
	call    initqueue
	retn

get_original_dd_header:
	dec     bp              ; make unit zero relative
	push    bx
	xor     bh,bh
	mov     bl,cs:dblmaptable[bp]
	mov     dl,cs:real_cache_units[bx]
	and     dl,3fh          ; get rid of extra bits
	add     bx,bx
	add     bx,bx
	les     di,cs:real_dd_headers[bx]
	pop     bx
	jmp     exit_no_chain

handle_bambi_api_toofar:
	cmp     bx,BAMBI_GET_STATS      ;detect bambi/get bambi status?
	je      get_stats
	cmp     bx,BAMBI_COMMIT_ALL     ;commit the cache synchronously?
	je      commit_all
	cmp     bx,BAMBI_REINITIALIZE   ;reset bambi's cache?
	je      reinitialize
	cmp     bx,BAMBI_CACHE_DRIVE
	je      cache_drive
	cmp     bx,BAMBI_GET_INFO       ;cache size,etc
	je      get_info
	cmp     bx,BAMBI_GET_ORIGINAL_DD_HEADER ; get pointer to orig dd, etc.
	je      get_original_dd_header
	if      1                       ;  ***Chuck's debug stuff!!!
	cmp     bx,BAMBI_INTERNAL_POINTERS
	je      return_internals
	endif
	cmp     bx,1234h
	je      display_the_message
	jmp     chain2f

	if      1                       ; *** Chuck's debug stuff!!!!
return_internals:
	push    cs
	pop     es
	mov     bx,offset internals_struct
	jmp     exit_no_chain

	extrn   validindexoffset:word
	extrn   DirtyIndexOffset:word
	extrn   ElementIdentifierLowordOffset:word
	extrn   ElementIdentifierHiwordOffset:word
	extrn   Queuelength:word

internals_struct:
	dw      offset validindexoffset
	dw      offset DirtyIndexOffset
	dw      ElementIdentifierLowordOffset
	dw      ElementIdentifierHiwordOffset
	dw      Queuelength

	endif

	;iret
get_stats:
	mov     ax,BAMBI_SIGNATURE
	mov     di,cs:nohit_h
	mov     si,cs:nohit_l
	mov     dx,cs:hit_h
	mov     bx,cs:hit_l
	mov     cx,cs:number_of_dirty_elements  
	mov     bp,BAMBI_VERSION_BCD
	jmp     exit_no_chain

get_info:
	mov     cx,cs:cache_block_bytes
	mov     bx,cs:queuelength
	mov     dx,cs:number_of_cache_elements_win
	mov     ax,cs:number_of_cache_elements
	jmp     exit_no_chain

commit_all:
	call    flush_in_int2f

	jmp     exit_no_chain

reinitialize:
;QEMM in a dos box will toast the handle, dont know why
;but we don't want to eat the disk, and sincethe resize
;part of this api is removed, we just do the dorky way
;       mov     cx,cs:number_of_cache_elements
;       call    reinitialize_cache
;       jnc     reinitsucceeded
;       call    handle_reallocfailure   
;reinitsucceeded:
	mov     cs:invalidate_when_ok,1
	call    flush_in_int2f
	jmp     exit_no_chain

display_the_message:
	mov     al,3
	call    warning_pop_up
	jmp     exit_no_chain

cache_drive:
	;input 
	;       bp = unit number to examine cache state 
	;       dl = 0 get state of this units cacheing
	;       dl = 1 enable read cacheing for this drive
	;       dl = 2 disable read cacheing for this drive
	;       dl = 3 enable write cacheing for this drive
	;       dl = 4 disable write cacheing for this drive
	;output
	;       dl = un-mapped unit or'd with 80h if not cacheing
	;       dl == -1 indicates this drive does not exist
	;       
	or      dl,dl
	jz      return_cache_state_bridge

;	Now we must verify that this is not a MagicDrv drive.
;	Our main command line will never ask us to do it, but
;	SmartMon might, and it is disastrous.

	push	ax
	push	bx
	push	cx
	push	dx

	mov	ax,MAGICDRV_2F
	xor	bx,bx				; install check, get version
	pushf					; chain down to MagicDrv
	cli                                     ;safety first
	call    DWORD PTR cs:int2fchain
	or	ax,ax				; is MD present, no error?
	jnz	not_magic

	mov	dx,bp
	mov	ax,MAGICDRV_2F
	mov	bx,MAGICDRV_MAP			; see if it is compressed
	pushf
	cli
	call	DWORD PTR cs:int2fchain		; call through
	not	bl				; invert the "compressed" bit
	and	bl,80h				; zero true if compressed

;	When we get here with zero true, the drive is compressed

not_magic:
	pop	dx
	pop	cx
	pop	bx
	pop	ax

	jz	return_cache_state_bridge	; ignore it and return status


	cmp     dl,1
	je      read_cache_this_drive
	cmp     dl,2
	je      disable_read_cacheing_for_this_drive
	cmp     dl,3
	je      write_cache_this_drive
	cmp     dl,4 
	jne	exit_no_chain		; exit if illegal value

;	disable write cacheing for this drive

	push    bp
	call    flush_in_int2f

	pop     bp
	push    bx
	xor     bh,bh
	mov     bl,cs:dblmaptable[bp];
	or      cs:byte ptr cs:real_cache_units[bx],40h
	pop     bx
	jmp     short common_disable
disable_read_cacheing_for_this_drive:
	push    bp
	call    flush_in_int2f

	pop     bp
	
	push    bx
	xor     bh,bh
	mov     bl,cs:dblmaptable[bp];
	or      cs:byte ptr cs:real_cache_units[bx],80h
	pop     bx

common_disable:
	mov     cx,cs:queuelength
	push    bp
	call    initqueue
	pop     bp
return_cache_state_bridge:
	jmp     short return_cache_state
write_cache_this_drive:
	push    bx
	xor     bh,bh
	mov     bl,cs:dblmaptable[bp]
	and     cs:real_cache_units[bx],0bfh
	pop     bx

	jmp     short return_cache_state
read_cache_this_drive:
	push    bx
	xor     bh,bh
	mov     bl,cs:dblmaptable[bp]
	and     cs:real_cache_units[bx],7fh
	pop     bx

return_cache_state:
	push    bx
	xor     bh,bh
	mov     bl,cs:dblmaptable[bp]
	mov     dl,byte ptr cs:real_cache_units[bx]     
	pop     bx

	mov     ax,BAMBI_SIGNATURE
;	jmp     exit_no_chain
	;iret
int2fhook endp

exit_no_chain:
	dec     cs:in_bambi
	iret


flush_in_int2f proc near
	dec     cs:in_bambi             ;unset semaphore since
	mov     cs:commit_all_when_ok,1
	call    safety_flush            ;safety_flush looks at it,
	inc     cs:in_bambi             ;its ok to re-enter here anyway
	ret
flush_in_int2f endp

zseg ends

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\get_dpb.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

include dpb.inc

;
;OVERVIEW
;	The module contains an asm callable function for
;getting a pointer to a drive's DPB.
;	This function is similar to the DOS call with the same name,
;but does not access the drive.
;	The primary entry point is get_dpb


zseg    segment public 'CODE'

	assume  cs:zseg,ds:nothing,es:nothing

PUBLIC	get_dpb
extrn	dos_3x:word

;
;INPUT
;	dl = drive number
;OUTPUT
;	no carry
;	  ds:bx -> DPB for this drive
;	carry
;	  drive not found
;
;USED
;	ax
get_DPB proc near
	push	ax				;preserve registers
	push	cx
	push	es
	mov	ah,52h				;get dpb chain
	int	21h
	;;;	es:bx->DPB chain
	push	es
	pop	ds
	assume	ds:nothing
	lds	bx,ds:[bx]
	xor	ch,ch
	mov	cl,dl
	dec	cl
	jz	found_DPB	
next_DPB:
	add	bx,dos_3x		; adjust for DOS 3.x DPB
	cmp	WORD PTR ds:[bx].dpb_next_dpb,-1	
	je	error_drive_not_found
	lds	bx,ds:[bx].dpb_next_dpb
	loop	next_DPB
found_DPB:
	pop	es
	pop	cx
	pop	ax
	clc
	ret
error_drive_not_found:
	pop	es
	pop	cx
	pop	ax
	stc
	ret	
get_DPB endp

zseg	ends
end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\indosbox.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;OVERVIEW
;
;	This module contains an asm callable routine for detecting
;if the program is running under a windows VM or dosshell task
;The primary entry point is in_dos_box


zseg    segment word public 'CODE'

	assume  cs:zseg
	assume  ds:zseg

public	in_dos_box

;
;FUNCTION
;	zero flag set if program was run from within a dosshell or
;	window's dos box or desqview
;USES
;	none
in_dos_box proc near
	push	ax
	push	bx
	push	cx
	push	dx
	push	bp
	push	si
	push	di
	push	es
	push	ds

	mov     ax,4B02h        ; Detect_Switcher
	xor     bx,bx           ; bx is defined to be zero in spec DTS API
	mov     es,bx           ; es:di = 0
	mov     di,bx
	int     2fh
	or      ax,ax
	jnz     no_DTS_Responder
	jmp	short	exit_zero_flag_setup
no_DTS_Responder:
	;;;detection code for older MS taskers (<=W3.0)
	mov     ax,4680h ;switcher call out
	int     2fh
	or      ax,ax
	jz      exit_zero_flag_setup
	mov     ax,1600h ;enhanced mode callout
	int     2fh
	test    al,7fh   ;if not low bits set 
			 ;there is a random himem which might set hi bit
	jnz 	multi_tasking

;	int 1
	;;; now check for desqview
	mov	cx,'DE'
	mov	dx,'SQ'
	mov	ax,2B01h
	int	21h
	cmp	al,0ffh
	jne	multi_tasking
	
	or 	al,1	 ; zero flag was set, so unset it
	jmp	short	exit_zero_flag_setup
	ret
multi_tasking:
	xor	ax,ax	 ; zero flag not set, so set it
	;;;	fall through

exit_zero_flag_setup:
	pop	ds
	pop	es
	pop	di
	pop	si
	pop	bp
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret
in_dos_box endp


zseg ends

end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\drvtype.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

include bambi.inc
include devsym.inc      ; get device driver structure definitions
include dpb.inc

public  IsMagicDrive
public  get_drive_type
public  setup_default_drive_list

;
;       routines from bambinit.asm
;
extrn   get_DPB                         :near
extrn   dos_3x                          :word
;
;       data from cmdline.asm
;
extrn   drives_to_cache                 :byte
extrn   msg_and_fail                    :near
extrn   dosinfo                         :word
extrn   display_message                 :near

extrn   first_instance                  :byte
extrn   shutupmsdosflag                 :byte
extrn   warnmsdosmessage                :byte

zseg    segment public 'CODE'

	assume  cs:zseg
	assume  ds:zseg
;
; locals
;

ioctl_buffer    db      64 dup(?)       ;buffer for ioctl 73h
thisdrivetype   dw      ?

DIRSTRLEN       EQU     64+3            ; Max length in bytes of directory strings
TEMPLEN         EQU     DIRSTRLEN*2


CURDIR_LIST     STRUC
CURDIR_TEXT     DB      DIRSTRLEN DUP (?)   ; text of assignment and curdir
CURDIR_FLAGS    DW      ?               ; various flags
CURDIR_DEVPTR   DD      ?               ; local pointer to DPB or net device
CURDIR_ID       DW      2 dup (?)       ; cluster of current dir (net ID)
CURDIR_USER_WORD DW     ?
CURDIR_END      DW      ?               ; index to ".." backup limit - see above
CURDIR_TYPE     DB      ?               ; IFS drive (2=ifs, 4=netuse)
CURDIR_IFS_HDR  DD      ?               ; Ptr to File System Header
CURDIR_FSDA     DB      2 DUP (?)       ; File System Dependent Data Area
CURDIR_LIST     ENDS

curdirLen       EQU     Size CURDIR_list        ; Needed for screwed up
						; ASM87 which doesn't allow
						; Size directive as a macro
						; argument
CURDIR_netID    EQU     DWORD PTR CURDIR_ID


;**     Flag values for CURDIR_FLAGS

CURDIR_isnet    EQU     1000000000000000B
CURDIR_isifs    EQU     1000000000000000B
CURDIR_inuse    EQU     0100000000000000B
CURDIR_splice   EQU     0010000000000000B
CURDIR_local    EQU     0001000000000000B



SysInitVars STRUC
SYSI_DPB            DD      ?           ; DPB chain
SYSI_SFT            DD      ?           ; SFT chain
SYSI_CLOCK          DD      ?           ; CLOCK device
SYSI_CON            DD      ?           ; CON device
SYSI_MAXSEC         DW      ?           ; maximum sector size
SYSI_BUF            DD      ?           ; points to Hashinitvar
SYSI_CDS            DD      ?           ; CDS list
SYSI_FCB            DD      ?           ; FCB chain
SYSI_Keep           DW      ?           ; keep count
SYSI_NUMIO          DB      ?           ; Number of block devices
SYSI_NCDS           DB      ?           ; number of CDS's
SYSI_DEV            DD      ?           ; device list
SYSI_ATTR           DW      ?           ; null device attribute word
SYSI_STRAT          DW      ?           ; null device strategy entry point
SYSI_INTER          DW      ?           ; null device interrupt entry point
SYSI_NAME           DB   8 DUP(?)       ; null device name
SYSI_SPLICE         DB      0           ; TRUE -> splicees being done
SYSI_IBMDOS_SIZE    DW      ?           ; DOS size in paragraphs
SYSI_IFS_DOSCALL@   DD      ?           ; IFS DOS service rountine entry
SYSI_IFS            DD      ?           ; IFS header chain
SYSI_BUFFERS        DW      ?,0         ; BUFFERS= values (m,n)
SYSI_BOOT_DRIVE     DB      ?           ; boot drive A=1 B=2,..
SYSI_DWMOVE         DB      0           ; 1 if 386 machine
SYSI_EXT_MEM        DW      0           ; Extended memory size in KB.
SysInitVars ENDS

NET_MAP         EQU    1000000000000b ; Mask for net drive bits
;
; code taken from DOS 5 setup to determine if drive is a network.
; There is a bug in dos 4.0 that requires us to slime around
;
;RETURNS

NON_LOCAL_DRIVE         equ     0
LOCAL_DRIVE             equ     1
NOTSUPP_DRIVE           equ     2

drive   db 0
IsLocalDrive proc near
	push    es
	push    dx
	mov     drive,dl

	mov     AX,3000h
	int     21h
	
	cmp     AL,04
	je      LookInCDS

	mov     AX,4409h                ; IOCTL is redirected? function 
	mov     BL,Drive                ; BL = drive number
	int     21h
	jc      Notsupp                 ; If not supported then can't be net

	mov     AX,LOCAL_DRIVE          ; Assume it is a local drive


	test    DX,NET_MAP              ; See if any funny bits are set
	jz      IsLocalExit             ; No funny bits so must be local

	mov     ax,NON_LOCAL_DRIVE
	jmp     short IsLocalExit

LookInCDS:
	mov     AH,52h                  ; Get internal DOS DATA Segment
	int     21h                     ; ES:BX --> DOS interal varibles

	mov     CL,Drive                ; First make sure that this drive
	dec     CL                      ; is not greater than last drive
					; If CL is zero it will fail the
	cmp     CL,ES:[BX].SYSI_NCDS    ; compare by doing  unsigned cmp
	mov     AX,LOCAL_DRIVE
	jae     Notsupp

	les     BX,ES:[BX].SYSI_CDS     ; ES:BX --> First CDS entry

	mov     AX,SIZE CURDIR_LIST     ; Find offset of the entry indexed
	mul     CL                      ; by drive in CL
	add     BX,AX                   ; ES:BX --> CDS entry for drive
	test    es:[bx].CURDIR_FLAGS,CURDIR_inuse
	jz      Notsupp
	test    ES:[BX].CURDIR_FLAGS,CURDIR_isnet ; Test is net bit

	mov     ax,NON_LOCAL_DRIVE
	jnz     IsLocalExit             ; If true then jmp to exit
	mov     ax,LOCAL_DRIVE
	
IsLocalExit:
	pop     dx
	pop     es
	ret
Notsupp:
	mov     ax,NOTSUPP_DRIVE
	jmp     short islocalexit

IsLocalDrive ENDP

;                       
;input dl == drive letter,zero based
;
;output NZ -> magicdrv, BX & !80h = host drive letter
;       Z ->  not magicdrv
IsMagicDrive proc near
	push    dx
	push    es
	push    di
	push    si

	push    dx
	mov     ax,MAGICDRV_2F          ;is magicdrv installed?
	mov     bx,MAGICDRV_DETECT      
	int     2fh
	pop     dx
	cmp     bx,MD_STAMP
	jne     no_magic_drv_installed
	
	mov     ax,MAGICDRV_2F
	mov     bx,MAGICDRV_MAP
	int     2fh
	;;; bit 7 set means its a compressed drive
	;;; dl == bl without bit 7 means its a regular drive
	;;; dl != bl without bit 7 means its a swapped host drive
	test    bl,80h                  ;compressed drive?
return_magictest:
	pop     si
	pop     di
	pop     es
	pop     dx
	ret
no_magic_drv_installed:
	xor     ax,ax   ;zet zero
	jmp     short return_magictest
IsMagicDrive endp

;
;FUNCTION
;       detect drive type
;INPUT
;       dx = drive unit
;OUTPUT
;       ax = drive type
;               INVALID_TYPE    = 0
;               FLOPPY_TYPE     = 1
;               REMOTE_TYPE     = 2
;               HARDDISK_TYPE   = 3
;               RAMDRIVE_TYPE   = 4 
;               CDROM_TYPE      = 5
;               MEMORY_TYPE     = 6
;               MAGIC_TYPE      = 7
;
;USES
;       ALL except ES,DS
;
get_drive_type proc near
    call        IsMagicDrive
    jnz         dt_magic
    ;;;; first check is for CDROM
    inc dx              ;really want drive letter
    mov ax,0150bh
    xor bx,bx
    mov cx,dx
    dec cx
    int 2fh
    cmp bx,0ADADh
    jne notCDROM
    cmp ax,0
    je notCDROM
    mov ax,CDROM_TYPE
    jmp short dt_end
notCDROM:
    ;;;;
;    push dx
;    mov ax,440dh       ;generic ioctl get_system_info
;    mov cx,0873h
;    mov bx,dx
;    mov dx,offset ioctl_buffer
;    int 21h
;    pop dx
;    jc  not_memory_device
;    mov ax,MEMORY_TYPE
;    jmp dt_end
;not_memory_device:     

    call islocaldrive
    cmp  ax,LOCAL_DRIVE
    je   dt_local_check
    cmp  ax,NOTSUPP_DRIVE
    je   dt_not_found

    mov ax, REMOTE_TYPE
    jmp short dt_end

dt_local_check:
    mov bl,dl
    mov ax, 4408h
    int 21h
    ; ZZZZ
    ; WARNING!! assuming that drive is non-removable as call 1 succeeded!
    ; WINDOWS FM seems to do the same!
    ; jc        dt_not_found
    jc  dt_nonremovable
    or  ax, ax
    jz  dt_removable

dt_nonremovable:
					;WARNING dl is UNIT now
    push dx
    push ds                             ;
    push bx                             ;result of get_dpb in ds:bx
    mov  dx,bx
    call get_DPB
   jc   dt_inv1 ; if not a local drive, bail out w/ INVALID code
    cmp  ds:[bx].dpb_fat_count,1        ;only one fat means RAMDRIVE
    pop  bx
    pop  ds
    pop  dx     

    je  dt_ramdrive
    mov ax, HARDDISK_TYPE
    jmp short   dt_end

dt_ramdrive:
	
    mov ax,RAMDRIVE_TYPE
    jmp short dt_end

dt_removable:
    mov ax, FLOPPY_TYPE
    jmp short dt_end

dt_magic:
    mov ax, MAGIC_TYPE
    jmp short dt_end
dt_inv1:
	pop     bx
	pop     ds              ; restore stack
	pop     dx
dt_not_found:
    xor ax, ax

dt_end:
    add         ax,dosinfo
    ret
get_drive_type endp

;
;FUNCTION
;       initialize array which determines what drives to cache
;       to include all hard disks with read+write caching enabled
;
setup_default_drive_list proc near

	mov     cx,26
loop_units:
	mov     ax,MULT_BAMBI
	mov     bx,BAMBI_DONT_CACHE_DRIVE
	int     2fh
	cmp     ax,BAMBI_DONT_CACHE_DRIVE
	je      continue_loop_units
;;;
;;;New code added for Astro to detect magic drive 7/30/92 scottq
;;;
	push    cx
	push    es
	push    di
	push    si

	push    dx
	mov     ax,MAGICDRV_2F          ;is magicdrv installed?
	mov     bx,MAGICDRV_DETECT      
	push    cx
	int     2fh
	pop     cx
	pop     dx
	cmp     bx,MD_STAMP
	jne     no_magic_drv
	
	dec     cx

	mov     ax,MAGICDRV_2F
	mov     bx,MAGICDRV_MAP
	mov     dl,cl
	int     2fh
	;;; bit 7 set means its a compressed drive
	;;; dl == bl without bit 7 means its a regular drive
	;;; dl != bl without bit 7 means its a swapped host drive
	test    bl,80h                  ;compressed drive
	pop     si
	pop     di
	pop     es
	pop     cx
	jz      mightbehostdrv        
	jmp     short continue_loop_units
no_magic_drv:
	pop     si
	pop     di
	pop     es
	pop     cx
	jmp     short continue_drivecheck
mightbehostdrv:
	cmp     dl,bl
	jne     default_cache_hd        ;;bug bug scottq 7/30/92 write cache on mounted floppies
continue_drivecheck:
	push    cx                              ;check each drive
	mov     dx,cx                           ;to see if it is a hard disk
	dec     dx
	call    get_drive_type                  ;if so, settup global list
	mov     thisdrivetype,ax
	pop     cx
	sub     ax,dosinfo
	cmp     ax,HARDDISK_TYPE
	je      default_cache_hd
	cmp     ax,FLOPPY_TYPE
	je      default_cache_floppy
continue_loop_units:
	loop    loop_units
	
	call    detect_dont_cache_drives

	cmp     thisdrivetype,MEMORY_TYPE
	jna     baddisk
contbad:        

	ret
default_cache_hd:
	mov     bp,cx
	mov     drives_to_cache[bp-1],READ_CACHE or WRITE_CACHE ;read/write cache
	jmp     short   continue_loop_units
baddisk:

	cmp     first_instance,1
	jne     contbad

	mov     warnmsdosmessage,1      ;cant do it yet, since command line
	jmp     short contbad           ;has to be parsed.

default_cache_floppy:
	mov     bp,cx
	mov     drives_to_cache[bp-1],READ_CACHE        ;read cache only
	jmp     short   continue_loop_units

setup_default_drive_list endp

detect_dont_cache_drives proc near

 ;      int 1
	push    ds
	push    es
	push    bp
	push    si
	push    di

	mov     ah,52h
	int     21h
	add     bx,34
	;;;     es:bx->device header chain
	push    es
	pop     ds
assume ds:nothing
	mov     bp,bx
	;;;     ds:bp->device header chain

	xor     di,di                   ; di is index into new header table
next_chain:
	les     bx,es:[bx]
	cmp     bx,-1
	je      done_walking_device_chain
	test    word ptr es:[bx].sdevatt,8000h          ;block device?
	jnz     next_chain

;;
;; is it a squished drive? if so, do not cache.  We can detect
;; squish drive by checking to see if the devicename field is "SQUISH+"

	cmp     word ptr es:[bx].sdevname[1],'QS'
	jne     next_name
	cmp     word ptr es:[bx].sdevname[3],'IU'       
	jne     next_name
	cmp     word ptr es:[bx].sdevname[5],'HS'
	jne     next_name
	cmp     byte ptr es:[bx].sdevname[7],'+'
	jne     next_name
	jmp     short   dontcachethisdrive
next_name:

	cmp     word ptr es:[bx].sdevname[1],'TS'
	jne     next_chain
	cmp     word ptr es:[bx].sdevname[3],'CA'       
	jne     next_chain
	cmp     word ptr es:[bx].sdevname[5],'C-'
	jne     next_chain
	cmp     byte ptr es:[bx].sdevname[7],'D'
	jne     next_chain

dontcachethisdrive:


	push    es
	push    bx

	mov     si,bx                           ;di:si->driver header
	mov     di,es

	mov     dx,1                            ;find unit for driver
loop_dpb:
	call    get_DPB                         ;ds:bx -> dpb or unit dl
	jc      nodpb                           ;skip if error

	add     bx,cs:dos_3x                    ; adjust pointer for DOS 3.x dpb

	cmp     word ptr ds:[bx].dpb_driver_addr[0],si
	jne     do_next_dpb
	cmp     word ptr ds:[bx].dpb_driver_addr[2],di
	jne     do_next_dpb

	push    bp
	mov     bp,dx
	mov     drives_to_cache[bp-1],NO_CACHE  
	pop     bp
	jmp     short do_next_dpb
nodpb:
	pop     bx
	pop     es
	jmp     next_chain

do_next_dpb:
	inc     dl
	jmp     short loop_dpb

done_walking_device_chain:
	pop     di
	pop     si
	pop     bp
	pop     es
	pop     ds
	ret

detect_dont_cache_drives endp

zseg ends

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\int2fini.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

include bambi.inc

public	call_bambi
public	initialize_int2f
extrn	accessing_swap_file_ptr	:dword
extrn	smart_win_data		:byte
extrn	warning_pop_up		:near
extrn	warning_pop_up_DOS	:near
extrn	find_startup_name	:near
extrn	startup_info		:byte
extrn	myPSP			:word
extrn	reference_ptr		:dword

zseg    segment public 'CODE'

	assume  cs:zseg
	assume	ds:nothing

;
; INPUT
;	AX = offset of bambi call
;
call_bambi proc near
	mov	bx,MULT_BAMBI
	xchg	ax,bx
	int	2fh
	ret
call_bambi endp

initialize_int2f proc near
;be sure swap file point is pointing to
;valid (0) byte!
	push	es
	mov	word ptr cs:accessing_swap_file_ptr[2],cs
	mov	word ptr cs:accessing_swap_file_ptr[0],offset cs:smart_win_data

	mov	word ptr cs:reference_ptr[0],offset cs:warning_pop_up_DOS
	mov	word ptr cs:reference_ptr[2],cs

	mov	word ptr cs:startup_info.SIS_Reference_Data[0],offset cs:reference_ptr
	mov	word ptr cs:startup_info.SIS_Reference_Data[2],cs

	mov	es,cs:myPSP	
	call	find_startup_name    ;ensure that global name ptr is accurate
	pop	es

	ret
initialize_int2f endp
zseg ends

end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\dpb.inc ===
;
;       Microsoft Confidential
;       Copyright (C) Microsoft Corporation 1991
;       All Rights Reserved.
;

;**     DPB - Drive Parameter Block
;
;       BUGBUG - this isn't authorative - it's my probably incomplete and
;       possibly inaccurate deductions from code study... - jgl
;
;       The DPB is DOS's main structure for describing block devices.
;       It contains info about the "Drive" intermingled with info about
;       the FAT file system which is presumably on the drive.  I don't know
;       how those fields are used if it's not the FAT file system - BUGBUG
;
;       The DPBs are statically allocated and chained off of DPBHead.
;       Users scan this chain looking for a match on DPB_DRIVE.
;       The DPBs are built at init time from info in the SYSDEV structure.


DPB     STRUC

DPB_DRIVE           DB  ?       ; Logical drive # assoc with DPB (A=0,B=1,...)
DPB_UNIT            DB  ?       ; Driver unit number of DPB
DPB_SECTOR_SIZE     DW  ?       ; Size of physical sector in bytes
DPB_CLUSTER_MASK    DB  ?       ; Sectors/cluster - 1
DPB_CLUSTER_SHIFT   DB  ?       ; Log2 of sectors/cluster
DPB_FIRST_FAT       DW  ?       ; Starting record of FATs
DPB_FAT_COUNT       DB  ?       ; Number of FATs for this drive
DPB_ROOT_ENTRIES    DW  ?       ; Number of directory entries
DPB_FIRST_SECTOR    DW  ?       ; First sector of first cluster
DPB_MAX_CLUSTER     DW  ?       ; Number of clusters on drive + 1

DPB_FAT_SIZE        DW  ?       ; Number of records occupied by FAT

DPB_DIR_SECTOR      DW  ?       ; Starting record of directory
DPB_DRIVER_ADDR     DD  ?       ; Pointer to driver
DPB_MEDIA           DB  ?       ; Media byte
DPB_FIRST_ACCESS    DB  ?       ; This is initialized to -1 to force a media
				;   check the first time this DPB is used
DPB_NEXT_DPB        DD  ?       ; Pointer to next Drive parameter block
DPB_NEXT_FREE       DW  ?       ; Cluster # of last allocated cluster
DPB_FREE_CNT        DW  ?       ; Count of free clusters, -1 if unknown

DPB     ENDS

DPBSIZ  EQU     SIZE DPB        ; Size of the structure in bytes

DSKSIZ  =       DPB_max_CLUSTER ; Size of disk (temp used during init only)

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\hooksini.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

include	bambi.inc

public	hook_ints
public	init_bambi_io

;
;	data from rdata.asm
;
extrn	indosaddr		:dword
extrn	in_08			:byte
extrn	in_09			:byte
extrn	in_10			:byte
extrn	in_13			:byte
extrn	in_16			:byte
extrn	int08chain		:dword
extrn	int10chain		:dword
extrn	int09chain		:dword
extrn	int13chain		:dword
extrn	int28chain		:dword
extrn	int16chain		:dword
extrn	int19chain		:dword
extrn	int2fchain		:dword
extrn	int15chain		:dword
extrn	int21chain		:dword
extrn	int25chain		:dword
extrn	int26chain		:dword
;
;	routines from hooks.asm
;
extrn	int08hook		:far
extrn	int09hook		:far
extrn	int10hook		:far
extrn	int13hook		:far
;extrn	int16hook		:far
extrn	int28hook		:far
extrn	int19hook		:far
extrn	int15hook		:far
extrn	int21hook		:far
extrn	int25hook		:far
extrn	int26hook		:far
;
;	routines from int2f.asm
;
extrn	int2fhook		:far

zseg    segment public 'CODE'

	assume  cs:zseg
	assume	ds:nothing



init_bambi_io proc near

	push	es
	mov	ah,34h	
	int	21h	;es:bx->indos
	mov	WORD PTR cs:indosaddr[0],bx
	mov	WORD PTR cs:indosaddr[2],es
	pop	es	
	clc
no_bambi:
	ret
init_bambi_io endp


hook_ints proc near
	push	es
	push	ds
	push	cs
	pop	ds
;;;	int 15 reboot vector

	mov	ax,3515h	
	int	21h
	
	mov	WORD PTR cs:int15chain,bx
	mov	WORD PTR cs:int15chain[2],es

	mov	dx,offset cs:int15hook
	mov	ax,2515h
	int	21h

;;;	int 19 reboot vector

	mov	ax,3519h	
	int	21h
	
	mov	WORD PTR cs:int19chain,bx
	mov	WORD PTR cs:int19chain[2],es

	mov	dx,offset cs:int19hook
	mov	ax,2519h
	int	21h

;;; int 10
	mov	ax,3510h	
	int	21h
	
	mov	WORD PTR cs:int10chain,bx
	mov	WORD PTR cs:int10chain[2],es

	mov	dx,offset cs:int10hook
	mov	ax,2510h
	int	21h

;;; int 9
	mov	ax,3509h	
	int	21h
	
	mov	WORD PTR cs:int09chain,bx
	mov	WORD PTR cs:int09chain[2],es

	mov	dx,offset cs:int09hook
	mov	ax,2509h
	int	21h

;;; int 13
	mov	ax,3513h	
	int	21h
	
	mov	WORD PTR cs:int13chain,bx
	mov	WORD PTR cs:int13chain[2],es

	mov	dx,offset cs:int13hook
	mov	ax,2513h
	int	21h

;;; int 2f
	mov	ax,352fh	
	int	21h
	
	mov	WORD PTR cs:int2fchain,bx
	mov	WORD PTR cs:int2fchain[2],es

	mov	dx,offset cs:int2fhook
	mov	ax,252fh
	int	21h

;;;	int 21 dos 

	mov	ax,3521h	
	int	21h
	
	mov	WORD PTR cs:int21chain,bx
	mov	WORD PTR cs:int21chain[2],es

	mov	dx,offset cs:int21hook
	mov	ax,2521h
	int	21h

;;;	int 25 absolute disk read 

	mov	ax,3525h	
	int	21h
	
	mov	WORD PTR cs:int25chain,bx
	mov	WORD PTR cs:int25chain[2],es

	mov	dx,offset cs:int25hook
	mov	ax,2525h
	int	21h

;;;	int 26 absolute disk write

	mov	ax,3526h
	int	21h
	
	mov	WORD PTR cs:int26chain,bx
	mov	WORD PTR cs:int26chain[2],es

	mov	dx,offset cs:int26hook
	mov	ax,2526h
	int	21h


;;;	int 28 idle 

	mov	ax,3528h	
	int	21h
	
	mov	WORD PTR cs:int28chain,bx
	mov	WORD PTR cs:int28chain[2],es

	mov	dx,offset cs:int28hook
	mov	ax,2528h
	int	21h

;;;	int 16 keyboard poll/etc

;	mov	ax,3516h	
;	int	21h
;	
;	mov	WORD PTR cs:int16chain,bx
;	mov	WORD PTR cs:int16chain[2],es
;
;	mov	dx,offset cs:int16hook
;	mov	ax,2516h
;	int	21h
;;;	hook timer last
	mov	ax,3508h	
	int	21h
	
	mov	WORD PTR cs:int08chain,bx
	mov	WORD PTR cs:int08chain[2],es

	mov	dx,offset cs:int08hook
	mov	ax,2508h
	int	21h

	pop	ds
	pop	es
	ret
hook_ints endp



zseg ends

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\msequ.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981-1991
; *                      All Rights Reserved.
; */

ftoobig 	equ	80h
fbig		equ	40h
romstatus	equ	1
romread 	equ	2
romwrite	equ	3
romverify	equ	4
romformat	equ	5


rsinit	=	0a3h	;rs232 initialization
			;9600 baud:no parity:1 stop:8 bit word

lf	=	10	;line feed
cr	=	13	;carriage return
backsp	=	8	;backspace
brkadr	=	1bh * 4	;006c	1bh break vector address
timadr	=	1ch * 4	;0070	1ch timer interrupt
dskadr	=	1eh * 4	;address of ptr to disk parameters
sec9	=	522h	;address of disk parameters
headsettle=	sec9+9	;address of head settle time
normsettle=	15	;normal head settle
speedsettle=	0	;speed up settle time
initspot=	534h	;ibm wants 4 zeros here
akport	=	20h
eoi	=	20h

cmdlen	=	0	;length of this command
unit	=	1	;sub unit specifier
cmd	=	2	;command code
status	=	3	;status
media	=	13	;media descriptor
trans	=	14	;transfer address
count	=	18	;count of blocks or characters
start	=	20	;first block to transfer
extra	=	22	;usually a pointer to vol id for error 15
start_l =	26	; extended start sector (low)
start_h =	28	; extended start sector (high)


chrout	=	29h
maxerr	=	5
lstdrv	=	504h

bootbias	=	200h
notbusystatus	=	10000000b	; not busy
ackstatus	=	01000000b	; acknowledge (for what?)
nopaperstatus	=	00100000b	; no more paper
selectedstatus	=	00010000b	; the printer said it was selected
ioerrstatus	=	00001000b	; some kinda error
reserved	=	00000110b	; nops
timeoutstatus	=	00000001b	; time out.
error_unknown_media = 7			; for use in build bpb call


; Boot options flags for ROMDOS

ifdef ROMDOS

BF_NoConfig	=	00000001b	; No config.sys processing
BF_DefaultMask	=	00000110b	; Bits to indicate default drive:
BF_DefFloppy	=	00000000b	; 	First floppy drive (00)
BF_DefHard	=	00000010b 	;	First hard drive   (80)
BF_DefROM	=	00000100b	;	ROM drive          (7F)

endif



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\hooks.asm ===
;/*                                   
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;OVERVIEW
;
;       This module contains the interrupt hooks for
;int 8 (timer interrupt), int 10 (video BIOS), int13 (disk BIOS)        
;int 19 (reboot vector), int 15 (keyboard intercept),int 9 (keyboard)
;and int 28 (idle interrupt)
;       Also, it contains the main entry point for write behind.
;       See hooksini.asm for the code which inserts these hooks into
;the interrupt chains.
;
;       Int 8 is hooked so write behind can occur.  Every timer tick
;the handler determines if it is appropriate to attempt write behind, and
;if so call the write behind entry point.  Note that previous int 8 
;handlers are allowed to process before write behind since the EOI must
;be done quickly.
;
;       Int 10 is hooked to prevent write behind from occuring during
;video BIOS interaction.  Write behind could mess with video timing and
;cause video problems.  
;
;       Int 13 is hooked to keep external int 13 callers from 
;breaking cache consistency,and to keep those cases from allowing a
;re-entrancy to occur on the int 13 vector.
;
;       Int 19 is hooked to catch those programs which use int 19
;to soft-reboot the machine.  This is done so the cache can be commited
;to disk if necessary.
;
;       Int 15 is hooked so that on those machines which support the
;keyboard intercept we can catch the ctrl+alt+delete sequence. Since
;this does not work on all machines, we also hook int 9.  However, this
;hook is not redunant because some programs use the int 15 intercept to
;reboot the machine.
;
;       Int 9 is hooked to catch ctrl+alt+delete and allow the cache
;to commit dirty buffers before reboot occures.  Also, we prevent 
;write behind during int 9 processing since this is a timing dependant
;interrupt on some machines.
;
;       Int 28 is hooked to allow the cache to write behind during idle
;cycles at an accelerated pace (compared to int 8).
;
;       Note that int 16 is no longer hooked for write behind acceleration
;because the hook encounters problems with windows (esp idle detection)
;the hook was redundant for the most part since most software uses int 28
;for idle.  Those software that do not do int 28s will have a slower
;write-behind since write behind will only occur on timer ticks.
;
;
;       Write_behind_cache is the main entry point for the write behind.
;The code determines if it is OK to access the disk, and if so will
;commit one cache element to disk.  Also, if the reboot hooks have been
;triggered, it will commit all uncommited data and reboot the machine.
	

public  commit_all_when_ok
public  invalidate_when_ok
public  reboot_when_ok
public  write_behind_cache
public  safety_flush

public  int08hook                               ;vector for timer interrupt
public  int09hook                               ;vector for keyboard interrupt
public  int10hook                               ;vector for video bios
public  int13hook                               ;vector for disk bios
public  int19hook                               ;vector for reboot
public  int15hook                               ;vector for reboot keys
;public int16hook                               ;vector for keyboard bios
public  int28hook                               ;vector for software idle
public  int21hook
public  int25hook
public  int26hook
;
;       data from rdata.asm
;
extrn   indosaddr               :dword
extrn   in_win                  :byte           ; in windows flag
extrn   in_08                   :byte           ;re-entry count for int 08
extrn   in_09                   :byte           ;re-entry count for int 09
extrn   in_10                   :byte           ;re-entry flag(?) for int 10
extrn   in_13                   :byte           ;re-entry flag(?) for int 13
extrn   in_16                   :byte           ;re-entry flag(?) for int 16
extrn   in_bambi                :byte           ;re-entry count for bambi
extrn   int08chain              :dword
extrn   int09chain              :dword
extrn   int10chain              :dword
extrn   int13chain              :dword
extrn   int15chain              :dword
extrn   int16chain              :dword
extrn   int19chain              :dword
extrn   int28chain              :dword
extrn   int21chain              :dword
extrn   int2fchain              :dword
extrn   int25chain              :dword
extrn   int26chain              :dword
extrn   processor_type          :byte

extrn   number_of_dirty_elements:word
;
;       routines from queueman.asm
;
extrn   commit_lru_dirty_element:near
extrn   commit_all_dirty:near
;
;       routines from reboot.asm
;
extrn   rebootsystem            :near
;
;       routines from queueman.asm
;
extrn   flush_queue             :near
;
;       routines from popup.asm
;
extrn   shut_down_pop_up        :near
;
;       data from bambi.asm
;
extrn   num_valid_buffers       :word
extrn   next_bad_entry_ptr      :word   ; first entry will be 0
extrn   num_bad_blocks          :word

extrn   accessing_swap_file_ptr :dword  

extrn   commitflag              :byte

;       align to word for stack save variables

zseg    segment word public 'CODE'

	assume  cs:zseg
	assume  ds:nothing

include bambi.inc

;
;       local data
;
save_stack_ss           dw      ?       ;tempory stack pointer saves
save_stack_sp           dw      ?
public save_stack_ss
public save_stack_sp

num_ticks_to_timeout    db      18      ;1 sec, WARNING must be non-zero!
commit_all_when_ok      db      0       ;non zero means commit all dirty
invalidate_when_ok      db      0       ;non zero means invalidate after commit
reboot_when_ok          db      0       ;non zero means reboot after commit

num_ticks_to_int28      db      0
ignore_intenter_checks  db      0       ;somebody else is doing bad things,
					;lets hope they know what they're doing
;=============================================================================
;==  Scan Code
;=============================================================================
SC_DEL          equ     0053h           ; Delete
SC_INS          equ     0052h           ; Insert
;=============================================================================
;==  Keyboard Control Byte Bit Positions (ROM Data Area)
;=============================================================================
KP_ALT          equ     00001000b
KP_CTRL         equ     00000100b
KP_LSHIFT       equ     00000010b
KP_RSHIFT       equ     00000001b

interrupt_status_ok proc near
	push    ax
	mov     ax,00001011b
	out     20h,al
	jmp     short sometime
sometime:
	in      al,20h
	cmp     ah,al
	pop     ax
	ret
interrupt_status_ok endp

;int28hook
;FUNCTION
;       idle interrupt handler--write behind on idle
;USES
;       none
;
int28hook proc far
	pushf                                   ;setup iret fraim
	cli                                     ;safety first
	call    DWORD PTR cs:int28chain         ;call down idle chain

	cmp     cs:num_ticks_to_int28,5         ;bug bug hard coded
	jae     write_behind_on_int28
	push    es
	push    di

	les     di,cs:accessing_swap_file_ptr
	test    byte ptr es:[di].enhanced_mode_flags,ENHANCED_MODE_WIN
	pop     di
	pop     es
	jnz     no_write_behind_on_int28
write_behind_on_int28:
	mov     cs:num_ticks_to_int28,0
	call    write_behind_cache              ;write behind a block
no_write_behind_on_int28:
	iret
int28hook endp

;
;safety flush is consolidate code from i21 and i13 handlers
;for flushing the cache.
;set commit_all_when_ok and/or invalidate_when ok and
;call this function to properly flush the cache
;
safety_flush    proc    near
	jmp     short be_sure_to_invalidate     ;invalidate even if no dirty
continue_write_reset:
	cmp     cs:invalidate_when_ok,0
	jne     be_sure_to_invalidate
	cmp     cs:number_of_dirty_elements,0
	je      done_reset
be_sure_to_invalidate:
	sti                                     ;enable interrupts so
						;concurrent entry to
						;write behind can complete

	;if we get here, we must allow writes to go through
	;even if we are "in" int 10, 9, or int 13.
	;This will only happen is some other app (not smartdrv)
	;is already breaking one of the re-entrancy rules.
	;this should be dangerous, but heck, we just have to
	;hope they know what they're doing

	inc     cs:ignore_intenter_checks
	call    write_behind_cache              ;write behind a block
	dec     cs:ignore_intenter_checks
	jmp     short continue_write_reset
done_reset:
	ret
safety_flush    endp

;int21hook
;FUNCTION
;USES
int21hook proc far
	cmp     ah,3fh                          ; file read?
	je      handle_file_read                ;  check for read of STDIN
	cmp     ah,0dh                          ;disk reset?
	je      handle_reset
	cmp     ax,2513h                        ;see below
	je      flush_for_pctools
	cmp     ah,68h                          ;commit_file?
	je      handle_reset_flag
chainondown21:
	jmp     DWORD PTR cs:int21chain

handle_file_read:
	or      bx,bx
	jnz     chainondown21                   ; only commit if handle == STDIN
	cmp     cs:in_win,1                     ;  and not in windows
	jz      chainondown21
	mov     cs:commit_all_when_ok,1
	call    safety_flush                    ; commit before blocking read
	jmp     chainondown21                   ;  of console makes it
;                                               ;  impossible.


handle_reset:
	pushf                                   ;setup iret fraim
	cli                                     ;safety first
	call    DWORD PTR cs:int21chain         ;call down idle chain
	;;;Set carry flag appropriately in iret frame
	push    ax
	push    bp                              
	mov     bp,sp                           
	lahf
	mov     byte ptr ss:[bp+8],ah           
	pop     bp
	pop     ax                              

	mov     cs:commit_all_when_ok,1
	cmp     ah,0dh
	jne     commit_no_invalidate
	mov     cs:invalidate_when_ok,1
commit_no_invalidate:
	call    safety_flush
	iret

handle_reset_flag:
	cmp     cs:commitflag,1
	je      handle_reset
	jmp     short chainondown21

;
;PCtools hooks int13 and succeeds the call with carry clear, but does
;not reflect down the int 13 chain for the actual read.  They do this
;on int 25s for disk detection.  Here, we detect that someone is hooking
;int 13h and flush the cache so when the int 25 happens,
;the commit will have nothing to do.  It cannot, since the next int13
;will not go through!
flush_for_pctools:   


	cmp     cs:in_bambi,0                   ;if we get call while in_bambi
	jne     chainondown21                   ;we arent in pctools--safetyflush
	mov     cs:commit_all_when_ok,1         ;will hang if in_bambi is set
	call    safety_flush    
	jmp     short chainondown21     
int21hook endp


IF 0
messes with windows idle detection
;int16hook
;FUNCTION
;       software keyboard handler
;       write behind on keyboard poll
;
int16hook proc far
	pushf
	inc     cs:in_16
	cmp     cs:in_16,1
	jne     dont_reenter16
	call    write_behind_cache
dont_reenter16:
	dec     cs:in_16
	popf
	jmp     DWORD PTR cs:int16chain         ;call down int 16 chain
int16hook endp
endif

;
;quick out exit for short jmps in write_behind_cache
;
quick_out_writebehind:
	dec     cs:in_bambi
	push    ds                              ;set the indos flag
	push    di                              ;so TSRS wont try to
	lds     di,cs:indosaddr                 ;pop up while we are
	dec     byte ptr ds:[di]                ;doing write behind
	pop     di                              ;re-enter us via int 21
	pop     ds

	ret

;
;write_behind_cache
;FUNCTION
;       Determine that it is safe to access the disk (via the device drivers)
;to write behind cached data.  If it is, commit the "least recently used"
;block to disk.
;       This function is called at (asynchronous) interrupt time.
;In particular, interrupt 08 (the timer tick).
;
;USES   
;       none
;EFFECTS
;       stack change
;       critical section entered
;
write_behind_cache proc near
write_behind_on_idle:

	push    ds                              ;set the indos flag
	push    di                              ;so TSRS wont try to
	lds     di,cs:indosaddr                 ;pop up while we are
	inc     byte ptr ds:[di]                ;doing write behind
	pop     di                              ;re-enter us via int 21
	pop     ds


	inc     cs:in_bambi
	cmp     cs:in_bambi,1                   ;do not re-enter any part
	jne     quick_out_writebehind           ;of the caching mechanism

	cmp     cs:invalidate_when_ok,0         ;invalidate even if no dirty
	jne     dont_check_dirty_count

	cmp     cs:number_of_dirty_elements,0   ;if there are no dirty blocks
	je      quick_out_writebehind           ;don't do anything
dont_check_dirty_count:
	cmp     cs:ignore_intenter_checks,0     ;see safety_flush above
	jne     dont_do_int_checks

	cmp     cs:in_10,0                      ;do not re-enter the ROM
	jne     short_jne_exit_08_no_crit                       ;BIOS if already in video
						;functions--could lead to
						;crash and odd video (timing,
						;snow) problems. Device drivers
						;called by cache call the
						;ROM BIOS
	
	cmp     cs:in_09,0                      ;do no process during
	jne     short_jne_exit_08_no_crit                       ;keyboard interrupt--timing
						;dependent on some machines
	cmp     cs:in_13,0                      ;do not process (reenter)

	je      noexit
						;during ROM BIOS disk 
						;functions non-dos programs can
						;use int13 directly without
						;going through DOS
short_jne_exit_08_no_crit:
	jmp     exit_08_no_crit
noexit:

dont_do_int_checks:

	push    ax                              ;At this point, we need to
	mov     ax,8001h                        ;enter a critical disk
	int     2ah                             ;section so a context 
	pop     ax                              ;switch will not interrupt
						;(therefore re-enter) the
						;disk drivers (and our own
						;code!)

	cmp     cs:in_bambi,1                   ;we need to re-check this
	jne     critical_section_out            ;within the critical section
						;to verify that window's
						;hasn't swapped to another
						;task since our first check
						;we do it this way to
						;prevent critical sections
						;on every timer tick


	mov     cs:save_stack_ss,ss             ;save the current stack 
	mov     cs:save_stack_sp,sp             ;contexed
	
	push    cs                              ;and switch to our own
	pop     ss                              ;internal stack
	mov     sp,offset cs:resident_stack

	cmp     cs:processor_type,CPU386
	jae     save386regs

	push    ds                              ;we cannot corrupt any
	push    ax                              ;registers on a timer tick!
	push    bx      

	push    cx                              ;finish saving all the 
	push    dx                              ;registers for write-behind
	push    es
	push    bp
	push    si
	push    di

done_save_regs:

	cmp     cs:ignore_intenter_checks,0     ;see safety_flush above
	jne     dont_check_istatus

	call    interrupt_status_ok             ;got this from MSDOS
	jc      commit_done                     ;excyclopedia,ralphl
dont_check_istatus:             

	cld                                     ;clear direction for all
						;the guys in commit!
	cmp     cs:commit_all_when_ok,0
	jnz     commit_all_behind

	les     di,cs:accessing_swap_file_ptr
	test    es:[di].enhanced_mode_flags,WRITE_IS_PENDING
	jnz     commit_done
	or      es:[di].enhanced_mode_flags,THIS_WRITE_IS_LAZY
	call    Commit_LRU_Dirty_Element        ;write out a dirty block!
	les     di,cs:accessing_swap_file_ptr
	and     es:[di].enhanced_mode_flags,NOT THIS_WRITE_IS_LAZY

commit_done:
	cmp     cs:processor_type,CPU386
	jae     restore386regs
	pop     di                              ;restore registers...
	pop     si
	pop     bp
	pop     es
	pop     dx
	pop     cx
	pop     bx
	pop     ax
	pop     ds
done_restore_regs:
	
	mov     ss,cs:save_stack_ss             ;restore stack
	mov     sp,cs:save_stack_sp

critical_section_out:
	push    ax                              ;turn off the disk critical             
	mov     ax,8101h                        ;section--ok to context
	int     2ah                             ;switch now
	pop     ax
exit_08_no_crit:
	dec     cs:in_bambi
	push    ds                              ;set the indos flag
	push    di                              ;so TSRS wont try to
	lds     di,cs:indosaddr                 ;pop up while we are
	dec     byte ptr ds:[di]                ;doing write behind
	pop     di                              ;re-enter us via int 21
	pop     ds

	ret
save386regs:
;WARNING 386 code only runs on a 386!
.386
	pushad
	push    fs
	push    gs
	push    ds
	push    es
	jmp     short done_save_regs
restore386regs:
	pop     es
	pop     ds
	pop     gs
	pop     fs
	popad
	jmp     short done_restore_regs
.8086

commit_all_behind:
	cmp     cs:reboot_when_ok,0
	je      not_reboot
	call    shut_down_pop_up
not_reboot:
	call    commit_all_dirty
	cmp     cs:invalidate_when_ok,0
	je      do_not_invalidate
	mov     cs:num_valid_buffers,0  ; invalidate supercache
	call    flush_queue
	mov     cs:invalidate_when_ok,0 
do_not_invalidate:
	cmp     cs:reboot_when_ok,0
	je     just_commit
	call    rebootsystem
	;;no fall through!
just_commit:
	mov     cs:commit_all_when_ok,0         
						
	jmp     short   commit_done

write_behind_cache endp

;
;int08hook
;FUNCTION
;       hardware timer interrupt 08h handler.  
;       processes the timer interrupt by calling older handlers (one will
;       do the EOI)
;       
;       If a while has passes since the last try, do some write-behind
;USES
;       none
;
int08hook proc far

	pushf                                   ;set up iret frame
	cli                                     ;in case of bad software
	call    DWORD PTR cs:int08chain         ;call int 08 handler chain

	inc     cs:num_ticks_to_int28
	dec     cs:num_ticks_to_timeout         ;'nuf time passed to do
	jz      check_dump                      ;write behind?

no_action:
	iret                                    ;if not, just exit
check_dump:
	cmp     cs:number_of_dirty_elements,0   ;timeout period begins when
	jz      restart_timeout                 ;dirty blocks exist


	;;; we should't re-enter the DOS bios on timer ticks
	;;; so we need to check that here.  We don't put the check
	;;; in write_behind since there are times we will want to
	;;; write behind when indos is set.
	push    ds                              ;set the indos flag
	push    di                              ;so TSRS wont try to
	lds     di,cs:indosaddr                 ;pop up while we are
	cmp     byte ptr ds:[di],0
	pop     di                              ;re-enter us via int 21
	pop     ds
	jne     no_action


	sti                                     ;allow interrupts through
						;during write behind

						;dirty blocks are timed out
	call    write_behind_cache              ;so do a write-behind
	mov     cs:num_ticks_to_timeout,1       ;1 so next tick decs to zero
						;so write-behind will continue
						;until there are no more
						;dirty blocks
	jmp     short no_action                 ;exit
restart_timeout:
						;no dirty blocks so restart
						;timeout period
	mov     cs:num_ticks_to_timeout,5*18    ;BUG BUG hard coded
	jmp     short no_action
int08hook endp
	 

;int10hook
;FUNCTION
;       keep track of entry count on ROM BIOS video functions
;       flag used to prevent write-behind during video bios operations
;USES
;       none
int10hook proc far

	pushf                                   ;set up iret frame
	inc     cs:in_10                        ;entering int10h
	cli                                     ;safetyfirst
	call    cs:int10chain                   ;allow call through chain
	dec     cs:in_10                        ;exiting int10h
	iret                                    ;exit to caller
int10hook endp


;int13hook
;FUNCTION
;       keep track of entry count on ROM BIOS disk functions
;       handle special case where applications do disk IO directly
;       by comming cache before operations
;       via int 13 (quite rare, but case must be handled)
;USES
;       none
;
int13hook proc far

	;;;the next 8 instructions are basically a PUSHF
	;;;that maintains the input flags (interrupt flag) 

	push    ax                              ;reserve area for flags
	push    bp                              ;preserve bp
	push    ax                              ;preserve ax
	mov     bp,sp                           ;get base pointer to stack
	mov     ax,ss:[bp+10]                   ;get user input flags->ax
	mov     ss:[bp+4],ax                    ;put user input flags into
						;reserved area
	pop     ax                              ;restore ax
	pop     bp                              ;restore bp

;       pushf                                   ;iret frame with input flags
	cmp     cs:in_bambi,0                   ;bambi called device driver?
	je      flush_before_13                 ;get all data to disk!
continue_13:
	inc     cs:in_13                        ;normal entry of int13
	cli                                     ;safety first
	call    cs:int13chain                   ;call int13 chain
	pushf                                   ;preserve flags on return!
	dec     cs:in_13                        ;normal exit of int13
	popf                                    ;restore int13 return flags
	retf    2                               ;exit with current flags
	;iret
flush_before_13:
	push    es
	push    di

	les     di,cs:accessing_swap_file_ptr
	cmp     byte ptr es:[di],0
	pop     di
	pop     es
	jne     continue_13

	push    ax
	push    bx
	push    cx
	push    dx
	push    si
	push    di
	push    bp
	push    ds
	push    es
continue_write_int13:
	mov     cs:commit_all_when_ok,1
	mov     cs:invalidate_when_ok,1
	call    safety_flush
	pop     es
	pop     ds
	pop     bp
	pop     di
	pop     si
	pop     dx
	pop     cx
	pop     bx
	pop     ax

	jmp     short continue_13               ;go do the int 13 request
int13hook endp


biosdataoffset  dw      40h

;int09hook
;FUNCTION
;       keyboard interrupt handler keeps track of entry and exit to
;       keyboard handling routines
;
int09hook proc far
	pushf                                   ;iret frame with input flags
	cli
	cmp     cs:number_of_dirty_elements,0
	jne     check_ctrlaltdel
continue_09:
	inc     cs:in_09                        ;entry to int09h
	call    cs:int09chain                   ;do the int09 chaing
	dec     cs:in_09                        ;exit of int09h
	iret
check_ctrlaltdel:
	push    ax
	push    es
	mov     es, word ptr cs:biosdataoffset
	mov     al, byte ptr es:[17h]   ; bios location of keyboard state and status flags
	test    al, KP_ALT 
	jz      not_alted_in9
	test    al, KP_CTRL
not_alted_in9:
	jnz     ctrl_alt_down
popesaxandcontinue_09:
	pop     es
	pop     ax
;;;zero flag not set if ctrl+alt are down
	jmp     short   continue_09
ctrl_alt_down:

	push    ax
	in      al,60h                          ; put scan code into al
	cmp     al,SC_DEL                       ;delete key?
	pop     ax
	jne     popesaxandcontinue_09


	and     byte ptr es:[17h],NOT KP_CTRL

	pop     es
	pop     ax
	inc     cs:in_09                        ;entry to int09h
	call    cs:int09chain                   ;do the int09 chain
	dec     cs:in_09                        ;exit of int09h
	mov     cs:commit_all_when_ok,1
	mov     cs:reboot_when_ok,1

	push    es
	mov     es,word ptr cs:biosdataoffset
	or      byte ptr es:[17h],KP_CTRL
	pop     es

;the following may finish off the write behind and reboot the system,
;however it will not if in_bambi is set 
;the next timer tick will do this too however
	call    write_behind_cache

	iret
	
	
int09hook endp

;int19hook
;FUNCTION
;       flush the cache before rebooting machine!
;
int19hook proc far
	cmp     cs:in_bambi,0
	jne     dont_commit19
	call    commit_all_dirty
dont_commit19:
	jmp     dword ptr cs:int19chain
int19hook endp

;int15hook
;FUNCTION
;       flush the cache before rebooting machine!
;       based on code from emm386
int15hook proc far
	cmp     ah,4fh                  ;keyboard intercept?
	je      check_keys
chain15:
	jmp     dword ptr cs:int15chain
check_keys:
	cmp     al,SC_DEL
	jne     chain15

	push    ax
	push    es
	mov     ax, 40h
	mov     es, ax
	mov     al, byte ptr es:[17h]   ; bios location of keyboard state and status flags
	test    al, KP_ALT 
	jz      not_alted
	test    al, KP_CTRL
not_alted:
	pop     es
	pop     ax
	jz      chain15
	cmp     cs:reboot_when_ok,0
	jne     already_shutting_down           ;don't race when we reboot!
	mov     cs:reboot_when_ok,1
	mov     cs:commit_all_when_ok,1
	call    write_behind_cache
already_shutting_down:
	jmp     short chain15
int15hook endp


int25isstupid   dw      ?
;int25hook
;FUNCTION
;       flush and invalidate the cache before and after absolute
;       disk read.  This is for BONEHEADED Central Point Software's
;       brain-damaged disk detection code from hell.  Also, it
;       makes disk de-fragmenters safe.
;
int25hook proc far

	;;;the next 8 instructions are basically a PUSHF
	;;;that maintains the input flags (interrupt flag) 

	push    ax                              ;reserve area for flags
	push    bp                              ;preserve bp
	push    ax                              ;preserve ax
	mov     bp,sp                           ;get base pointer to stack
	mov     ax,ss:[bp+10]                   ;get user input flags->ax
	mov     ss:[bp+4],ax                    ;put user input flags into
						;reserved area
	pop     ax                              ;restore ax
	pop     bp                              ;restore bp

;       pushf                                   ;iret frame with input flags

	mov     cs:commit_all_when_ok,1
	mov     cs:invalidate_when_ok,1
	call    safety_flush
	cli
	call    dword ptr cs:int25chain
	pop     cs:int25isstupid
	pushf
	jnc     noresetbads
	mov     cs:next_bad_entry_ptr,0         ;nortons will return error correctly
	mov     cs:num_bad_blocks,0             ;but we don't want to think first block
						;is bad when its ok
noresetbads:
	mov     cs:commit_all_when_ok,1
	mov     cs:invalidate_when_ok,1
	call    safety_flush
	popf
	retf    ;no 2 since this is int 25
int25hook endp

;int26hook
;FUNCTION
;       flush and invalidate the cache before and after absolute
;       disk write.  This is for BONEHEADED Central Point Software's
;       brain-damaged disk detection code from hell.  Also, it
;       makes disk de-fragmenters safe.
;
int26hook proc far

	;;;the next 8 instructions are basically a PUSHF
	;;;that maintains the input flags (interrupt flag) 

	push    ax                              ;reserve area for flags
	push    bp                              ;preserve bp
	push    ax                              ;preserve ax
	mov     bp,sp                           ;get base pointer to stack
	mov     ax,ss:[bp+10]                   ;get user input flags->ax
	mov     ss:[bp+4],ax                    ;put user input flags into
						;reserved area
	pop     ax                              ;restore ax
	pop     bp                              ;restore bp

;       pushf                                   ;iret frame with input flags
	mov     cs:commit_all_when_ok,1
	mov     cs:invalidate_when_ok,1
	call    safety_flush
	cli
	call    dword ptr cs:int26chain
	pop     cs:int25isstupid
	pushf
	mov     cs:commit_all_when_ok,1
	mov     cs:invalidate_when_ok,1
	call    safety_flush
	popf
	retf    ;no 2 since this is int 26
int26hook endp

align 2
		dw      64      dup ('!')               ;11-11-92 scottq
		dw      128     dup ('!')               ;stack for write-behind
temp_res_stack  dw      128     dup ('!')
resident_stack  dw      0
public resident_stack
public temp_res_stack
zseg ends

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\pdetect.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

include bambi.inc

zseg    segment public 'CODE'

	assume  cs:zseg
	assume	ds:nothing


public detect_processor

.386
;******************************************************************************
;   DetectProcessor - return type of processor (386/486 vs. 8088/86/286).
;       This routine relies on Intel-approved code that takes advantage
;       of the documented behavior of the high nibble of the flag word
;       in the REAL MODE of the various processors.  The MSB (bit 15)
;       is always a one on the 8086 and 8088 and a zero on the 286 and
;       386/486.  Bit 14 (NT flag) and bits 13/12 (IOPL bit field) are
;       always zero on the 286, but can be set on the 386.
;
;       For future compatibility of this test, it is strongly recommended
;       that this specific instruction sequence be used.  The exit codes
;       can of course be changed to fit a particular need.
;
;       CALLABLE FROM REAL MODE ONLY 
;
;       this routine was stolen from EMM/386 source code
;
;   ENTRY:  (none)
;
;   EXIT:   0 = 8086/8088
;           2 = 286
;           3 = 386
;          -4 = >=486
;------------------------------------------------------------------------------
;CPU086088       equ     0
;CPU186          equ     1       ;not detected here
;CPU286          equ     2
;CPU386          equ     4
;CPU486ORABV     equ     8

detect_processor proc near
	push si
	push di
	push ds
	push es

	pushf                           ; save entry flags

	xor     ax, ax                  ; 0000 into AX
	push    ax
	popf                            ; try to put that in the flags
	pushf
	pop     ax                      ; look at what really went into flags
	test    ax, 08000h              ;Q: was high bit set ?
	jnz     short cpu_is_8086       ;  Y: 8086/8088
	mov     ax, 07000h              ;  N: try to set the NT/IOPL bits
	push    ax
	popf                            ;      ... in the flags
	sti                             ; (for VDMM/IOPL0)
	pushf
	pop     ax                      ; look at actual flags
	popf                            ; restore entry flags
	test    ax, 07000h              ; Q: any high bits set ?
	jz      short cpu_is_286        ; N: 80286
    ;
    ; 386 or 486? See if we can set the AC (Alignment check) bit in Eflags
    ;   Need to insure stack is DWORD aligned for this to work properly
    ;
	push    cx
	xor     cx,cx                   ; Assume stack aligned
	mov     ax,sp
	and     ax,000011B
	jz      short NoStkAdj          ; Stack is aligned
	mov     cx,ax                   ; set "pop" count
	sub     sp,ax                   ; Move to DWORD aligned
NoStkAdj:
	pushfd                          ; save entry flags (DWORD)
	push    dword ptr 40000h        ; AC bit
	popfd
	pushfd
	pop     eax
	popfd                           ; Recover entry flags (DWORD)
	test    eax,40000h              ; Did AC bit set?
	jnz     short cpu_is_486        ; Yes, 486
	inc     ax                      ; Make AX non-zero
	add     sp,cx                   ; pop off alignment bytes
	pop     cx                      ; Entry cx
	mov     ax,CPU386               ; 386 detected
	jmp     short donedetection

cpu_is_486:
	add     sp,cx                   ; pop off alignment bytes
	pop     cx                      ; Entry cx
	mov     ax,CPU486ORABV          ; 486 detected
	jmp short donedetection

cpu_is_8086:
	popf                            ; restore flags
	mov ax,CPU086088                ; 8086/8088 detected
	jmp short donedetection
cpu_is_286:
	mov ax,CPU286                   ; 286 detected
	;;jmp short donedetection fall through
donedetection:
	pop	es
	pop	ds
	pop	di
	pop	si

	ret
detect_processor endp

zseg ends

end






















=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\logphys.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

include bambi.inc
include msbds.inc

PUBLIC  logical_to_physical
public	log_phys_list
public	compute_logical_to_physical 	

zseg    segment public 'CODE'

	assume  cs:zseg
	assume	ds:zseg

extrn	get_drive_type			:near
extrn	dos_3x				:word
extrn	dosinfo			:word

log_phys_list	db	26	dup(?)

compute_logical_to_physical proc near
;	int 1
	mov	cx,26			;do each drive
next_drive:
	push	cx   			;keep track of count
	mov	dl,cl			;unit goes in dl..
	dec	dl			;zero based from 1 based count
	xor	dh,dh			;turn into index
	mov	bx,dx			;so we can access array 
	push	bx			;later...
	call	logical_to_physical	;map this logical unit to physical
	pop	bx			;get array index
	mov	log_phys_list[bx],dl	;remember logphys mapping
	pop	cx			;get back count
	loop	next_drive		;loop for all possible drives

	ret
compute_logical_to_physical endp
;
;given a logical drive unit, get the int13 drive number
;
;INPUT 
;	dl = logical unit
;OUTPUT
;	dl = physical unit, -1 if no mapping exists
logical_to_physical proc near

	push	ds
	push	di
	push	si

	cmp	cs:dos_3x,0	;bug bug int2f doesnt work on older dos
	jne	old_way		;so use old way on dos 3.x


	xor	di,di
	mov	ds,di

	push	dx
	mov	ax,0803h		;get bds chain
	int	2fh			;output in ds:di
	assume ds:nothing
	pop	dx
	
	mov	si,ds	  		;did function return a pointer?
	or	si,di
	jz	old_way

walk_bds:
	cmp	ds:[di].bds_drivelet,dl
	je	found_it
	cmp	word ptr ds:[di].bds_link,-1
	je	no_mapping
	lds	di,ds:[di].bds_link
	jmp	short walk_bds

logtophysout:
	pop	si
	pop	di	
	pop	ds
	ret

found_it:
	mov	dl,ds:[di].bds_drivenum
	jmp	short logtophysout
no_mapping:
	mov	dl,-1
	jmp	short logtophysout
	
old_way:
	call	old_logical_to_physical
	jmp	short logtophysout
	
logical_to_physical endp



temp13chain 	dd	0
physdrive	db	-1

temp13hook proc far
	mov	cs:physdrive,dl
	jmp	dword ptr cs:[temp13chain]
temp13hook endp

;logbuf	db	512	dup(?)
extrn	logbuf	:byte	;see rdtata.asm

old_logical_to_physical proc near

	push	ds
	push	es
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	bp

	mov	cs:physdrive,-1			;default to no mapping

	push	dx
	call	get_drive_type
	pop	dx
	sub	ax,dosinfo
	cmp	ax,HARDDISK_TYPE
	jne	quick_out


	push	dx
	mov	ax,3513h	
	int	21h
	
	mov	WORD PTR cs:temp13chain,bx
	mov	WORD PTR cs:temp13chain[2],es

	mov	dx,offset cs:temp13hook
	mov	ax,2513h
	int	21h

	mov	WORD PTR cs:temp13chain,bx
	mov	WORD PTR cs:temp13chain[2],es


	pop	dx
	mov	al,dl

	push	AX			
	mov	AH,0dh			; DOS disk reset function
	int	21h
	pop	AX

	
	push	cs
	pop	ds

	mov	CX,1			; read one sector
	mov	DX,1			; read sector one
        mov	bx,offset logbuf	; point to our buffer

	int	25h			; DOS absolute sector read
	pop	BX			; Adjust the stack (see MS Prog Ref)

	mov	dx,word ptr cs:temp13chain
	mov	ds,word ptr cs:temp13chain[2]
	mov	ax,2513h
	int	21h

	pop	bp
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	pop	es
	pop	ds

	mov	dl,cs:physdrive
	ret

quick_out:
	pop	bp
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	pop	es
	pop	ds
	ret
old_logical_to_physical endp



zseg ends

end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\rdata.asm ===
page	,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

	.xlist
include	devsym.inc
	.list

PUBLIC	hit_l
PUBLIC	hit_h
PUBLIC	nohit_l
PUBLIC	nohit_h
PUBLIC	dirty_l
PUBLIC	dirty_h
PUBLIC	in_bambi
PUBLIC	in_win
PUBLIC	real_dd_headers
PUBLIC	real_cache_units
PUBLIC	driver_hooks
PUBLIC	secsize_and_align_info
PUBLIC	cache_block_bytes
PUBLIC	cache_block_words

PUBLIC	selected_drive
PUBLIC	max_valid_buffers
PUBLIC	last_buffer

PUBLIC	number_of_cache_elements
PUBLIC	number_of_cache_elements_win


PUBLIC	queueheadptr
PUBLIC	queuelength
PUBLIC	elementidentifierlowordoffset
PUBLIC	elementidentifierhiwordoffset
PUBLIC	word_masks
	ifdef	USE_VALID
PUBLIC	validindexoffset
	endif
PUBLIC	dirtyindexoffset
PUBLIC	Number_Of_Dirty_Elements
PUBLIC	dos_3x


PUBLIC	farptrsav
PUBLIC	save_ax
PUBLIC	in_08
PUBLIC	in_10
PUBLIC	in_09
PUBLIC	in_13
PUBLIC  in_16
PUBLIC	int08chain
PUBLIC	int10chain
PUBLIC	int09chain
PUBLIC	int13chain
PUBLIC	int28chain
PUBLIC	int16chain
PUBLIC	int2fchain
PUBLIC	int19chain
PUBLIC	int15chain
PUBLIC  int21chain
PUBLIC  int25chain
PUBLIC  int26chain

PUBLIC	processor_type

PUBLIC	indosaddr

PUBLIC	XMShandlevalid
PUBLIC	XMShandle
PUBLIC  vxd_name

PUBLIC  commitflag

PUBLIC	block_buffer
	

;	We need to keep this module dword aligned so that we can
;	  align our big buffer to a DWORD.

zseg    segment dword public 'CODE'

	assume  cs:zseg
	assume	ds:nothing

dos_3x			dw	0
hit_l			dw	0
hit_h			dw	0
nohit_l			dw	0
nohit_h			dw	0
dirty_l 		dw	0
dirty_h 		dw	0

in_bambi		db	0
word_masks		db	0		; flag indicates word masks in use

selected_drive		db	-1

in_win			db	0		; not in windows when we load

	align	4

real_dd_headers		dd	26 	dup(?)
real_cache_units 	db	26	dup(-1)

driver_hooks		db size sysdev * 26 dup ('$')

secsize_and_align_info	dw	26 dup (0ff02h)	; align unknown, 512 byte secs

;	The cache block size is a primary global value which can only
;	  be changed by completely committing and reinitializing the
;	  cache data structures.

cache_block_bytes	dw	8192

;	The following global value should always be one-half cache_block_bytes

cache_block_words	dw	4096

last_buffer		dw	0	; offset of dirty_write buffer
max_valid_buffers	dw	0	; number of buffers allocated

;from queueman
queueheadptr	dd	?
queuelength	dw	0		;must be zero at startup so
					;caching will not occur until
					;data is initialized
ElementIdentifierLowordOffset   dw      ?
ElementIdentifierHiwordOffset   dw      ?
DirtyIndexOffset                dw      ?
	ifdef	USE_VALID
validindexoffset		dw	?
	endif
Number_Of_Dirty_Elements	dw	?


farptrsav	dd	?
save_ax		dw	?

in_08		db	0
in_10		db	0
in_09		db	0
in_13		db	0
in_16		db	0	

	align	4
int08chain	dd	?
int10chain	dd	?
int09chain	dd	?
int13chain	dd	?
int28chain	dd	?
int16chain	dd	?
int2fchain	dd	?
int19chain	dd	?
int15chain	dd	?
int21chain	dd	?
int25chain	dd	?
int26chain	dd	?

processor_type	db	?

indosaddr	dd	?


;from cacheman.asm
XMShandlevalid	db	0
	align	2
XMShandle	dw	?

startup_name_seg dw 	?
startup_name_off dw	?

PUBLIC startup_name_seg	     ;used for vxd load
PUBLIC startup_name_off	     ;used for vxd load

;bug bug these were transient, need to get new number ?when?
number_of_cache_elements 	dw	100h	;# elements for DOS
number_of_cache_elements_win	dw	100h	;# elements for WIN
commitflag	db	1

vxd_name	db	69	dup('@')
align	4

block_buffer:	

if 1
;;;BUG BUG this is now used in logphys to ensure our buffer is large
;;;enough for the sector size
public logbuf
logbuf	db	16192	dup(?)	;BUG BUG this is here to keep umb case from
				;trashing itself during init_cache etc
				;BUG BUG this also ensures that the cache
				;is larger than the safedsk driver so
				;it will not tromp the init code in devini.asm
				;when devicestarts up
endif

zseg ends

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\queueini.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


zseg    segment public 'CODE'

	assume  cs:zseg
	assume  ds:nothing
public	initqueue

;
;	data from rdata.asm
;

	ifdef	USE_VALID
extrn	validindexoffset		:word
	endif
extrn	dirtyindexoffset		:word
extrn	word_masks			:byte
extrn	elementidentifierlowordoffset	:word
extrn	elementidentifierhiwordoffset	:word
extrn	number_of_dirty_elements	:word
extrn	queueheadptr			:dword
extrn	queuelength			:word


extrn	initialize_lru_queue		:near

;
; INPUT
;       CX    number of elements in the cache   
;
InitQueue proc near
	push	ds
	push    cs
	pop     ds


	mov     WORD PTR cs:QueueHeadPtr[0],0
	mov	WORD PTR cs:Number_Of_Dirty_Elements,0
	mov     WORD PTR cs:QueueLength,cx

	or	cx,cx
	jz	quick_out
	
	xor	bp,bp			; initialize loop pointer

init_cache_loop:
	mov     si,cs:ElementIdentifierLowordOffset
	mov     WORD PTR cs:[bp+si],-1
	mov     si,cs:ElementIdentifierHiwordOffset
	mov     WORD PTR cs:[bp+si],-1
	mov     si,cs:DirtyIndexOffset

;	Note:  There are two different options for the remainder of
;		this loop, depending on whether we're using byte or
;		words for our mask arrays.  The final loop termination
;		is duplicated in both parts for speed.

	cmp	word_masks,0		; are mask array(s) words or bytes?
	jz	init_cache_bytes

	mov     WORD PTR cs:[bp+si],0	; init dirty_bits
	ifdef	USE_VALID
	mov	si,cs:validindexoffset
	mov	word ptr cs:[bp+si],0	; init valid_bits
	endif
init_cache_common:
	add	bp,2			; next element
	loop    init_cache_loop

	call	initialize_lru_queue
quick_out:
	pop	ds
	ret

init_cache_bytes:
	shr	bp,1			; convert to byte mask
	mov	byte ptr cs:[bp+si],0	; set dirty_bits
	ifdef	USE_VALID
	mov	si,cs:validindexoffset
	mov	byte ptr cs:[bp+si],0	; init valid_bits
	endif
	shl	bp,1			; back to word mask domain
	jmp	init_cache_common

InitQueue endp

zseg ends

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\reboot.asm ===
; ========================================================

PUBLIC rebootsystem

COMMENT #

	REBOOT.ASM

	Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential

	johnhe - 12/01/89

END COMMENT #

;
;OVERVIEW
;
;	This module contains a routine for rebooting the machine.  The
;code was take from the DOS 5.0 setup program.  Reboot is called when
;the user has requested that the machine be rebooted (ctrl+alt+delete),
;but the cache was not commited at that time so the reboot was delayed 
;until all dirty buffers are commited

;-----------------------------------------------------------------------------;
;	K E Y B O A R D   S C A N   C O D E S				      ;
;-----------------------------------------------------------------------------;

KB_INTERCEPT	EQU	4fh

DEL_KEY		EQU	53h
ALT_SHIFT	EQU	08h
CTL_SHIFT	EQU	04h

WARM_BOOT_CODE	EQU	1234h	

;-----------------------------------------------------------------------------;
;	BIOS DATA AREA LOCATED AT 40:00
;-----------------------------------------------------------------------------;

ROM_DATA SEGMENT AT 040h

	org	17h
KB_FLAG		LABEL BYTE


	org	072h
WarmBootFlag	LABEL WORD

ROM_DATA ENDS

;-----------------------------------------------------------------------------;
;	CPU POWER-ON STARTUP LOCATION AT ffff:00
;-----------------------------------------------------------------------------;

ROM_BIOS SEGMENT AT 0ffffh
	org	0

PowerOnReset	LABEL FAR

ROM_BIOS ENDS

;-----------------------------------------------------------------------------;

;include	MODEL.INC

;-----------------------------------------------------------------------------;

;.CODE
zseg    segment public 'CODE'

	assume  cs:zseg
	assume	ds:nothing


RebootSystem PROC

	mov	AX,3515h
	int	21h			; Get int 15h vector in ES:BX
	mov	AX,ES			; AX == Segment
	or	AX,BX			; Is this a NULL ptr
	jz	WarmBoot		; If zero we can't do an int 15h

DoInt15:
	mov	ax, seg WarmBootFlag
	mov	ds, ax
	assume	DS:ROM_DATA

	mov	KB_FLAG,ALT_SHIFT OR CTL_SHIFT
	mov	AX,(KB_INTERCEPT SHL 8) OR DEL_KEY
	int	15h			; Put Ctrl/Alt/Del into key buffer

WarmBoot:
	cli
	cld

	mov	ax, seg WarmBootFlag
	mov	ds, ax
	assume	DS:ROM_DATA
	mov	WarmBootFlag, WARM_BOOT_CODE
	jmp	PowerOnReset
		; Jump to the processor power-on address FFFF:0000h

RebootSystem	ENDP


zseg ends

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\popup.asm ===
;/*				      
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

include bambi.inc

PUBLIC	warning_pop_up
PUBLIC  warning_pop_up_DOS
PUBLIC  shut_down_pop_up

extrn	popup1			:byte
extrn	popup2			:byte
extrn	reboot_when_ok		:byte
extrn	startup_info		:byte

WARNING_DIALOG_ATTRIBUTES equ	7	;white on black (usually!)

ROM_SET_CURSOR 		equ	2
ROM_GET_CURSOR		equ	3
ROM_WRITE_ACHAR		equ	09h
ROM_WRITE_CHAR		equ	0ah
ROM_TELETYPE		equ	0eh
ROM_GET_VIDEO_MODE	equ	0fh

zseg    segment public 'CODE'

	assume  cs:zseg
	assume	ds:nothing

lastscancode	db	0		;scancode of last keypress
popupsaveint9 	dd	?
user_response	db	?

popupint9handler proc near
	push	ax
	in	al,60h			;get the scancode
	mov	byte ptr cs:lastscancode,al

	;;; The following code was taken from the swapper
	;;; it EOIs the int9 effectively "swallowing" the keys

	in      al,61h                  ;read in code
	mov     ah,al                   ;save it
	or      al,80h
	out     61h,al                  
	xchg    ah,al
	out     61h,al
	cli                             
	mov     al,20h                  ;need to output the eoi
	out     20h,al
	sti
	pop     ax                      ;restore

	iret
popupint9handler endp

grab_the_keyboard proc near

	push 	es
	push	bx

	xor	ax,ax
	mov	es,ax

	cli
	mov	ax,es:[4*9]
	mov	bx,es:[4*9+2]

	mov	word ptr popupsaveint9[0],ax
	mov	word ptr popupsaveint9[2],bx
	mov	ax,offset cs:popupint9handler
	mov	es:[4*9],ax
	mov	es:[4*9+2],cs
	sti
	
	pop	bx
	pop	es
	ret
grab_the_keyboard endp

restore_the_keyboard proc near

	push	ax
	push	bx
	push	es
	xor 	ax,ax
	mov	es,ax

	mov	ax,word ptr popupsaveint9[0]
	mov	bx,word ptr popupsaveint9[2]

	cli
	mov	es:[4*9],ax
	mov	es:[4*9+2],bx
	sti

	mov	cs:lastscancode,0
	pop	es
	pop	bx
	pop	ax
	ret

restore_the_keyboard endp


;
; INPUT
;	CS:BP -> dialog template
;	dh:dl -> y,x
;	bh  = display page
;	bl = color attributes
;	al  = drive letter replaceable parameter
; OUTPUT
;	none
; USES 
;	ALL except DS,ES
;	BP is modified!
; NOTES
;	Text wraps at single NULL, ends at '$'
;
save_al			db	0
query_cursor_locx	db 	0
query_cursor_locy	db	0

draw_dialog proc near
	mov	cs:save_al,al
display_loop:

	mov	ah,ROM_SET_CURSOR
 	int	10h			
	inc	dl


	mov	al,cs:[bp]
	cmp	al,'$'
	jz	done_displaying
	cmp	al,'&'
	jne	check_replace
	mov	cs:query_cursor_locx,dl
	mov	cs:query_cursor_locy,dh
	mov	al,' '
	jmp	short continue_line
check_replace:
	cmp	al,'@'
	jne	check_wrap
	mov	al,cs:save_al
	add	al,'A'
	jmp	short continue_line
check_wrap:
	cmp	al,0
	jne	continue_line
	inc	dh   			;wrap to new line
	xor	dl,dl
continue_line:
	mov	cx,1
	mov	ah,ROM_WRITE_ACHAR 	;display a message
	int	10h
	inc	bp
	jmp	short display_loop
		
done_displaying:	
	mov	dl,cs:query_cursor_locx
	mov	dh,cs:query_cursor_locy
	mov	ah,ROM_SET_CURSOR
 	int	10h			

	ret
draw_dialog endp

setup_video_access proc near
	push	ax
	mov	ah,ROM_GET_VIDEO_MODE	; get video page into bh
	int	10h
	mov	ah,ROM_GET_CURSOR	; get cursor location
	int	10h
	mov	cs:save_starting_cursorx,dl
	mov	cs:save_starting_cursory,dh
	pop	ax
	ret
setup_video_access endp

finish_video_access proc near
	mov	dl,cs:save_starting_cursorx ; put the cursor back 
	mov	dh,cs:save_starting_cursory
	mov	ah,ROM_SET_CURSOR
 	int	10h			
	ret
finish_video_access endp


;
; INPUT
;	al = drive letter which has error
; OUTPUT
;	al = ASCIICODE_RETRY => retry the operation
;	al = ASCIICODE_IGNORE => ignore the error
;		
save_starting_cursorx	db	0
save_starting_cursory	db	0

warning_pop_up proc near

;the int2f initialization will point this to warning_pop_up_DOS below,
;vxd load will change this to the vxd's windows handler
	push	es
	push	di
	
	les	di,cs:startup_info.SIS_Reference_Data
	call	DWORD PTR es:[di]
	pop	di
	pop	es
	mov	al,ASCIICODE_RETRY		;retry is only real option
	ret
warning_pop_up endp

warning_pop_up_DOS proc far
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	bp
	push	es

	push	ax
	call	set_windows_focus
	pop	ax

	;;; before we can display to the screen
	;;; we need to get the active display page
	;;; which is retuned in bh from get_video_mode

	call	setup_video_access
	
	xor	dx,dx
	mov	bl,WARNING_DIALOG_ATTRIBUTES ;color of dialog
	mov	bp,offset cs:popup1
	;al still has drive letter
	push	bx			; save display page for later
	call	draw_dialog


	;;; BUG BUG BUG BUG BUG BUG BUG 
	;;; this code continually scans the keyboard port waiting for
	;;; the retry or ignore scan codes. This is evil and satanic, but
	;;; we MUST get user input, and this is the only way that works
	;;; in diverse environments like windows.  It is concievable that
	;;; this could break and cause a hang. But it will DEFINITELY
	;;; cause a hang if we don't do it in many cases. So, we stomp
	;;; on eggs! CODE REVIEW ME
	;;; NOTE that the int 9 handler is still eating the keys,
	;;; and is also polling the port so we won't miss the key
	;;;
	call	grab_the_keyboard
waitforkey:
;	in	al,60h			;get the scancode
; 	cmp	al,SCANCODE_RETRY
;	je	key_valid
;;;bug bug took out check for ignore
       ;	cmp	al,SCANCODE_IGNORE
       ;	je	key_valid
	mov	al,cs:lastscancode
	cmp	al,SCANCODE_RETRY
	jne	waitforkey
       ;	cmp	al,SCANCODE_IGNORE
       ;	jne	waitforkey

key_valid:
	call	restore_the_keyboard
	mov	ah,ROM_WRITE_CHAR
	cmp	al,SCANCODE_RETRY
	jne	was_ignore
	mov	al,ASCIICODE_RETRY
	jmp	short was_retry
was_ignore:
	mov	al,ASCIICODE_IGNORE
was_retry:
	mov	cs:user_response,al
	pop	bx	 		; restore display page
	push    bx			; but still save till later
	mov	cx,1			; just display one character
	int	10h
	
	pop	bx		      	; restore display page
	mov	bl,0			; display out same dialog,
	mov	bp,offset cs:popup1	; only use black-on-black
	xor	dx,dx
	call	draw_dialog

	call	finish_video_access

	pop	es
	pop	bp
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	cmp	cs:reboot_when_ok,0
	je	not_reboot		;hack--if the shut-down popup is up
	call	shut_down_pop_up	;we should put it back up so
					;the user won't be confused if he
					;hits ctrl+alt+delete, then
					;pops out the floppy, gets this 
					;message, replaces the floppy
					;but the message is erased
not_reboot:
	mov	al,cs:user_response
	ret
	
warning_pop_up_DOS endp

shut_down_pop_up proc near

	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	bp
	push	es

	call	setup_video_access
	
	xor	dx,dx
	mov	bl,WARNING_DIALOG_ATTRIBUTES ;color of dialog
	mov	bp,offset cs:popup2
	call	draw_dialog
	call	finish_video_access

	pop	es
	pop	bp
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax

	ret

shut_down_pop_up endp

set_windows_focus proc near
if 0
;;;superceded by code from msbio1. This code suggested by ralphl,
;;;msbio code suggested by aaronr

	mov	ax,1600h
	int	2fh		; get win386 version
	cmp	ax,3		; Q: is it 3.00?
	jne	use_31way	; N: Do 3.1 call

	mov	ax,1681h
	int	2fh		; enter a critical section

;
;	point int 24 vector at an IRET instruction
;
	push	ds
	xor	ax,ax
	mov	ds,ax
	push	word ptr ds:[24h*4]
	push	word ptr ds:[24h*4+2]
	mov	word ptr ds:[24h*4],offset iretinstruction
	mov	word ptr ds:[24h*4+2],cs

	int 	24h
	pop	word ptr ds:[24h*4+2]
	pop	word ptr ds:[24h*4]
	pop	ds

	mov	ax,1682h
	int	2fh		;exit critical section

	ret
use_31way:
	
	mov	ax,168Bh
	xor	bx,bx
	int	2fh
endif

	push	di
	push	es
	push	bx
	push	ax

	xor	di,di
	mov	es,di
	mov	bx,0015h	;Device ID of DOSMGR device
	mov	ax,1684h	;Get API entry point
	int	2fh
	mov	ax,es
	or	ax,di		
	jz	Skip
;
;Here, es:di is address of API routine. Set up stack frame to simulate a call
;
	push	cs		;push return segment
	mov	ax,OFFSET Skip
	push	ax		;push return offset
	push	es
	push	di		;API far call address
	mov	ax,1		;SetFocus function number
	retf			;do the call
Skip:
	pop	ax
	pop	bx
	pop	es
	pop	di
	ret

	ret

iretinstruction:
	iret
set_windows_focus endp

zseg ends

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\queueman.asm ===
;/*
; *                      Microsoft confidential
; *                      Copyright (c) Microsoft Corporation 1991
; *                      All rights reserved.
; */
 
;	This module handles the main cache data structures.  Its
;	functions include lookup, create element, and commit element.

BEEP = 0
 
public  flush_queue
public  set_dirtyindex
public  fast_lookup
public  queue_element
public  commit_all_dirty
public  commit_lru_dirty_element
public  invalidate_element
 
zseg    segment public 'code'
 
	assume  cs:zseg
	assume  ds:nothing
 
;
;       data from rdata.asm
;
extrn   dirtyindexoffset                :word
extrn	word_masks			:byte
	ifdef	USE_VALID
extrn	validindexoffset		:word
	endif
extrn   elementidentifierlowordoffset   :word
extrn   elementidentifierhiwordoffset   :word
extrn   number_of_dirty_elements        :word
extrn   queueheadptr                    :dword
extrn   queuelength                     :word
;extrn	rbeep_flag			:byte
 
;
;       routines from bambi.asm
;
extrn   dirty_write                     :near
extrn	in_bambi			:byte
;
;	routines from beep.asm
;
if beep
extrn	flush_beep			:near
extrn	invalidate_beep			:near
endif
 
;
;       local data
;
queue_nextoffset dw	?
queue_prevoffset dw	?
PUBLIC queue_nextoffset
PUBLIC queue_prevoffset
queue_head	dw	0
queue_tail	dw	0
 
PUBLIC queue_head
PUBLIC queue_tail
PUBLIC initialize_lru_queue
 
 
;
;INPUT
;	none
;OUTPUT
;       none
;USES
;	ALL except DS,ES
;NOTES
;	Initializes the LRU queue by linking all the links together
;	and setting the head and tail pointers

initialize_lru_queue proc near

	push	es
	push	cs
	pop	es

	mov	di,cs:queue_nextoffset	; init NEXT fields
	xor	ax,ax			; start links at 0
	mov	cs:queue_head,ax	; head starts at zero

	mov	cx,cs:queuelength
	dec	cx			; don't store last element

initialize_queue_next:
	add	ax,2			; pre-increment
	stosw
	loop	initialize_queue_next

	xor	ax,ax
	stosw				; point last one to front

	mov	cx,cs:queuelength
	dec	cx			; get number of last element
	mov	di,cs:queue_prevoffset	; init PREV fields
	mov	ax,cx
	add	ax,ax
	mov	cs:queue_tail,ax	; the number of elements
	stosw				; point first back to last
	xor	ax,ax			; all rest point to themselves - 1

initialize_queue_prev:
	stosw
	add	ax,2
	loop	initialize_queue_prev
 
	pop	es
	ret

initialize_lru_queue endp
 
;
;INPUT
;	BP = element to insert at front of LRU chain
;OUTPUT
;       none
;USES
;	none
;NOTES
;	inserts the BP element at the front of the LRU chain
;WARNING! the BPth element *must* be deleted before it is re-inserted
;	otherwise a loop in the chain will form
 
insert_mru_queue proc near
 
	push	bx				;preserve regs
	push	di
	mov	bx,cs:queue_head		;insert at front of queue
	mov	di,cs:queue_prevoffset		;point next prev to new item
	mov	cs:[bx+di],bp			;set prev pointer
	mov	di,cs:queue_nextoffset		;point new next to former head
	mov	cs:[bp+di],bx			;set next field
	mov	cs:queue_head,bp		;set header pointer
	pop	di				;restore regs
	pop	bx
	ret
 
insert_mru_queue endp
 
 
;
;INPUT
;	none
;OUTPUT
;       BP = index of deleted element
;USES
;	none
;NOTES
;	removes the LRU element from the linked list
;
delete_lru_queue proc near
 
	push	bx				;preserve regs
	push	di
	mov	bp,cs:queue_tail   		;get the tail element
	mov	di,cs:queue_prevoffset		;get tails prev element
	mov	bx,cs:[bp+di]			;get prev
	mov	cs:queue_tail,bx		;set tail to prev
	pop	di
	pop	bx
	ret
 
delete_lru_queue endp
 
;
;INPUT
;	none
;OUTPUT
;       BP = item to bring to the front of the LRU chain
;USES
;	none
;NOTES
;	removes the LRU element from the linked list
;
bring_to_front proc near
 
	cmp	bp,cs:queue_tail		;tail is special case
	je	do_tail				;
	cmp	bp,cs:queue_head		;dont need to do head!
	je	alreadydone
 
	push	si				;preserve regs
	push	di
	mov	si,queue_prevoffset		;get the previous guy
	mov	di,cs:[bp+si]			;into di
	mov	si,queue_nextoffset		;get the next guy
	mov	si,cs:[bp+si]			;into si
 
	push	bp
	mov	bp,cs:queue_nextoffset		;set previous next to next
	mov	cs:[di+bp],si			;set field
	mov	bp,cs:queue_prevoffset		;set next previous to previous
	mov	cs:[si+bp],di			;set filed
	pop	bp
 
	pop	di
	pop	si
	call	insert_mru_queue		;insert just deleted item
 
alreadydone:
	ret
 
do_tail:
	push	bp
	call	delete_lru_queue		;delete tail item
	call	insert_mru_queue		;insert at head
	pop	bp
	ret
 
bring_to_front endp
 
 
;
; input
;       bp      =       elementidentifier index
;       cx      =       new dirty bits
;	bx	=	new valid_bits (if enabled)
;
; used
;	cx, ax
; notes
;	not only does set_dirtyindex set the dirty bits, but
;       it also keeps track of the number of dirty elements in
;	number_of_dirty_elements
;
 
set_dirtyindex proc near
 
	push	bp			;preserve index
	mov	ax,cx			; remember new dirty_bits
 
	cmp	word_masks,0		; using 16-bit masks?
	jz	set_dirty_bytemasks	;  brif not
 
	add	bp,cs:dirtyindexoffset	;get bucket for dirty bits
	xchg	ax,cs:[bp]		;fill bucket with new bits,
					;old dirty bits into ax

	ifdef	USE_VALID
	sub	bp,cs:dirtyindexoffset
	add	bp,cs:validindexoffset
	mov	word ptr cs:[bp],bx
	endif

	jmp	short set_dirty_common
 
set_dirty_bytemasks:
	shr	bp,1			; convert to byte mask
	add	bp,cs:dirtyindexoffset	; get byte dirty array
	xchg	al,cs:[bp]		; store new value, get old
	xor	ah,ah

	ifdef	USE_VALID
	sub	bp,cs:dirtyindexoffset
	add	bp,cs:validindexoffset
	mov	byte ptr cs:[bp],bl	; set valid_bits, too
	endif
 
set_dirty_common:
	sub	cx,1				;set carry if new bits=0
						;if new bits=0 then
	sbb	cs:number_of_dirty_elements,0	;subtract 1 from count
	sub	ax,1				;set carry if old bits=0
						;if old bits=0 then
	adc	cs:number_of_dirty_elements,0	;add 1 to count
 
	pop	bp				;restore index
	ret
 
set_dirtyindex endp
 
 
; invalidates the block's data
; input
;       bp      =       elementidentifier index
; notes
;       sets element identifier to -1,-1
;
invalidate_element proc near
	push	cx
 
	push	bp				;preserve index
	add	bp,cs:elementidentifierlowordoffset;get low bucket
	mov	word ptr cs:[bp],-1		;set low identifier
	sub	bp,cs:elementidentifierlowordoffset;back to word array index
	add	bp,cs:elementidentifierhiwordoffset;get high bucket
	mov	word ptr cs:[bp],-1		;set high identifier
	pop	bp				;restore index
 
	xor	cx,cx				;set not dirty!
	ifdef	USE_VALID
	push	bx
	xor	bx,bx				; set not valid
	endif
	call	set_dirtyindex
	ifdef	USE_VALID
	pop	bx
	endif
	pop	cx
	ret
invalidate_element endp
 
;
; input
;       bp = elementidentifier index
; uses
;	ax,di,si,cx
; notes
;	calls dirty_write function to commit a block to disk.
;
commit_dirty_element proc near
 
	mov	si,cs:dirtyindexoffset
	cmp	word_masks,0
	jnz	commit_dirty_wordmask

	xor	ch,ch
	shr	bp,1				; convert to byte index
	mov	cl,cs:byte ptr [si+bp]		; get byte dirtyindex
	ifdef	USE_VALID
	mov	si,cs:validindexoffset
	mov	al,cs:byte ptr [si+bp]		; fetch valid info, too.
	endif
	shl	bp,1
	jmp	short commit_dirty_common

commit_dirty_wordmask:
	mov	cx,cs:word ptr [si+bp]		; fetch word dirtymask
	ifdef	USE_VALID
	mov	si,cs:validindexoffset
	mov	ax,cs:word ptr [si+bp]
	endif

commit_dirty_common:
	mov	si,cs:elementidentifierlowordoffset
	mov	si,word ptr cs:[bp+si]
	mov	di,cs:elementidentifierhiwordoffset
	mov	di,word ptr cs:[bp+di]
 
	ifdef	USE_VALID
	push	bx		; save original bx now
	push	ax		; save the old valid mask
	endif
 
	;input parameters to dirty_write
	;are di:si = 32-bit elementidentifier
	;    al = 8-bit dirtyindex
	;    bp = cache_element_index
 
	mov	ax,cx				;dirty bits into ax
	push	bp
	call	dirty_write			;call out to write data
	pop	bp				;restore index
 
	ifdef	USE_VALID
	pop	bx				; restore old valid mask
	endif

	push	cx ;bugbug is this necessary
	xor	cx,cx				;zero dirty bits
	call	set_dirtyindex			; retain original valid bits

	pop	cx

	ifdef	USE_VALID
	pop	bx
	endif
	ret
commit_dirty_element endp
 
 
;
;input
;	none
;output
;       bp-> new cache element
;uses
;	cx, (from commit_dirty) ax,si,di
;notes
;	allocates a new element from the queue by discarding the
;	first-in element. if the element contains "dirty" data,
;	the data must first be commited to disk via commit_dirty_element
;
get_new_cache_element proc near
	call	delete_lru_queue
	call	insert_mru_queue
	push	bp					;preserve index
 
	cmp	word_masks,0				; using word masks?
	jz	get_new_cache_el_bytemask

	add	bp,cs:dirtyindexoffset
	mov	cx,word ptr cs:[bp]	; get word dirtymask
	jmp	short get_new_cache_el_common
 
get_new_cache_el_bytemask:
	shr	bp,1				; convert to byte index
	add	bp,cs:dirtyindexoffset		;get bucket for dirty bits
	mov	cl,byte ptr cs:[bp]		;put dirty bits into cl
	xor	ch,ch
 
get_new_cache_el_common:
	pop	bp					;restore index
	or	cx,cx
	jz	lrunotdirty
	call	commit_dirty_element
lrunotdirty:
	ret
 
get_new_cache_element endp
 
;
; INPUT
;       none
; OUTPUT
;	none
; USES
;	ALL except DS,ES
; NOTES
;	this function is called at interrupt time to
;	commit the least recently used==first-in dirty data
;	element to disk
;
commit_lru_dirty_element proc near
 
	cmp	cs:Number_Of_Dirty_Elements,0	;quick out
	je	done_commit_lru
 
	mov	bp,cs:queue_tail
	mov	di,cs:dirtyindexoffset		;get dirty bits
	mov	si,cs:queue_prevoffset
 
	cmp	word_masks,0		; using byte masks?
 	jnz	start_word_walk
	jmp	short	start_byte_walk

walk_for_lru:
	shl	bp,1
	mov	bp,cs:[si+bp]
start_byte_walk:
	
	shr	bp,1			; index byte array
	cmp	byte ptr cs:[bp+di],0
	je	walk_for_lru
 
	shl	bp,1			; convert to word index
	jmp	short word_commit_lru

word_walk_for_lru:
	mov	bp,cs:[si+bp]
start_word_walk:
	cmp	word ptr cs:[bp+di],0
	je	word_walk_for_lru

word_commit_lru:
	call	commit_dirty_element
done_commit_lru:
	ret
 
commit_lru_dirty_element endp
IF 0
;BUGBUG!!!!!!  This routine HAS NOT been adapted for word-index bps.
;old no-lru code
;
; input
;       none
; output
;	none
; uses
;	all except ds,es
; notes
;	this function is called at interrupt time to
;	commit the least recently used==first-in dirty data
;	element to disk
;
commit_lru_dirty_element proc near
	push	es				;preserve segments!
	push	cs				;"data" segment=cs->es
	pop	es
 
						;bug bug redundant?
	cmp	cs:number_of_dirty_elements,0	;quick out
	je	lrudone_commiting
 
	mov	bp,word ptr cs:queueheadptr[0]	;get queue head
	inc	bp				;get first-in-first-out
	cmp	bp,cs:queuelength		;array wrap must goes to zero
	jb	lruno_wrap
 
	xor	bp,bp				;array wrapped, so fifo=zero
lruno_wrap:
	mov	di,cs:dirtyindexoffset		;get dirty bits for fifo
	add	di,bp				;need di for rep scasb
 
	cmp	word_mask,0			; byte masks?
	jz	commit_lru_bytemask
 
	add	di,bp				; point into word array
 
	mov	cx,cs:queuelength		;cx = rep scasb count
	sub	cx,bp				;starting at bp element
	inc	cx	;go one past since we test for cxz bug bug dumb?
	cld					;good programmer
 
w_lrucontinue_commit:
	xor	ax,ax  				;searching for non-zero
	repe	scasw     			;scan until non-zero
	jcxz	w_lrufirst_done			;cx=0 means nothing found bug bug
	jmp	short w_lru_commit_it
 
 
w_lrufirst_done:
	mov	di,cs:dirtyindexoffset		;nothing was found in first
						;half of queue scan, so
						; start at array head to
						;complete scan
 
	mov	cx,word ptr cs:queueheadptr[0]	;count -> cx
	inc	cx 				;one cause cx is a count
	inc	cx 				;one more since we check cxz
 
	xor	ax,ax
	repe	scasw
	jcxz	lrudone_commiting
 
w_lru_commit_it:
	dec	di    				;one past, go back
	dec	di
 
	sub	di,cs:dirtyindexoffset
	shr	di,1
	jmp	short commit_lru_di
 
commit_lru_bytemask:
 
	mov	cx,cs:queuelength		;cx = rep scasb count
	sub	cx,bp				;starting at bp element
	inc	cx	;go one past since we test for cxz bug bug dumb?
	cld					;good programmer
 
lrucontinue_commit:
	xor	al,al  				;searching for non-zero
	repe	scasb     			;scan until non-zero
	jcxz	lrufirst_done			;cx=0 means nothing found bug bug
	jmp	short lru_commit_byte
 
 
lrufirst_done:
	mov	di,cs:dirtyindexoffset		;nothing was found in first
						;half of queue scan, so
						; start at array head to
						;complete scan
 
	mov	cx,word ptr cs:queueheadptr[0]	;count -> cx
	inc	cx 				;one cause cx is a count
	inc	cx 				;one more since we check cxz
 
	xor	al,al
	repe	scasb
	jcxz	lrudone_commiting
 
lru_commit_byte:
	dec	di    				;one past, go back
 
	sub	di,cs:dirtyindexoffset
 
commit_lru_di:
	mov	bp,di
 
	call	commit_dirty_element
 
lrudone_commiting:
	pop	es
	ret
 
commit_lru_dirty_element endp
 
endif
;
; input
; 	none
; output
;       none
; note
;	commits all dirty blocks
; uses
;	none
;
commit_all_dirty proc near
	push	ax				;preserve registers
	push	bx				;trashed by commit_lru_dirty
	push	cx
	push	dx
	push	si
	push	di
	push	bp
if BEEP
	cmp	rbeep_flag,1
	jne	nobeep
	call	flush_beep
nobeep:
endif
 
	inc	cs:in_bambi
continue_commit:
	call	commit_lru_dirty_element	;get all dirty blocks to disk
	cmp	cs:number_of_dirty_elements,0	;until there are no more
	jnz	continue_commit
	dec	cs:in_bambi
 
	pop	bp				;restore registers
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret
commit_all_dirty endp
 
;
;input
;       ax:dx = 32-bit cookie
;       cx    = 16-bit dirty index; 0 means not dirty
;	bx     = 16-bit valid mask, if enabled
;output
;       bp = element index
;used
;	cx
;notes
;
;	allocates a new element in the cache; possibly commits
;	dirty block to disk to free slot
;
queue_element proc near
 
	ifdef	USE_VALID
	push	bx
	endif

	push	cx				;preserve input registers
	push	ax
	push	dx
	call	get_new_cache_element		;get handle to element->bp
	pop	dx				;restore input registers
	pop	ax
	pop	cx

	ifdef	USE_VALID
	pop	bx
	endif
 
 
	push	bp				;preserve index
	add	bp,cs:elementidentifierlowordoffset;get low bucket
	mov	word ptr cs:[bp],ax		;set low identifier
	sub	bp,cs:elementidentifierlowordoffset;back to word array index
	add	bp,cs:elementidentifierhiwordoffset;get high bucket
	mov	word ptr cs:[bp],dx		;set high identifier
	pop	bp				;restore index	
 
	jmp	set_dirtyindex			;set dirty bits
 
queue_element endp
 
;
;input
;	dx:ax == 32-bit cookie
;output
;       bp = element index if found, -1 if not
;	cx = dirty_bits for that element
;	ax = valid_bits for that element, (if USE_VALID is defined)
;uses
;	all except ds,si,bx
;WARNING TRASHES ES
;notes
;	looks up the cookie in the cache and returns handle to it
;	if found
;
fast_lookup proc near
	push	cs
	pop	es
 
	mov	di,cs:elementidentifierlowordoffset
	mov	cx,cs:queuelength
 
;	precompute the distance between di after a match and
;	  the corresponding word in the highword array.
 
	mov	bp,cs:elementidentifierhiwordoffset
	sub	bp,di
	sub	bp,2		; di will already be incremented when we use it
	cld			;BUG BUG not really necessary since
			        ;this is done at entry point, but safety
				;is paramount and the cost is low
 
continue_scan:
	repne	scasw
	jnz	no_match
 
	cmp	dx,cs:[bp+di]
	jne	continue_scan
 
	lea	bp,[di].-2		; point bp back to matched loword
 
	sub	bp,cs:elementidentifierlowordoffset
 
;	now bp is a word index of the correct element
 
	mov	di,cs:dirtyindexoffset
 
	cmp	word_masks,0		; is dirtyindex a word array?
	jz	lookup_dirty_is_bytes
 
	mov	cx,word ptr cs:[bp+di]	; get dirtyindex

	ifdef	USE_VALID
	mov	di,cs:validindexoffset
	mov	ax,word ptr cs:[bp+di]	; get validindex
	endif

;	**** Note:  Assume bring_to_front doesn't trash our return registers.

	jmp	bring_to_front
 
lookup_dirty_is_bytes:
	shr	bp,1			; convert to byte index
	mov	cl,byte ptr cs:[bp+di]
	xor	ch,ch

	ifdef	USE_VALID
	mov	di,cs:validindexoffset
	mov	al,byte ptr cs:[bp+di]
	xor	ah,ah
	endif

	shl	bp,1			; back to word index
	jmp	bring_to_front
 
no_match:
	mov	bp,-1
	ret
 
fast_lookup endp
 
;
;input
;	none
;output
;       none
;uses
;	all except ds,es
;notes
;	marks all elements as not allocated, not dirty
;warning
;	dirty elements are *not* commited--this must be done
;	before calls to flush_queue!
;
flush_queue proc near
if BEEP
	cmp	rbeep_flag,1
	jne	nobeep2
	call	invalidate_beep
nobeep2:
endif
 
	mov	word ptr cs:queueheadptr[0],0
 
	push	es
	push	di
	mov	si,cs:queuelength
	push	cs
	pop	es
 
	mov	di,cs:elementidentifierlowordoffset
	mov	cx,si
	mov	ax,-1
	rep	stosw
 
	mov	di,cs:elementidentifierhiwordoffset
	mov	cx,si
	rep	stosw
 
	mov	di,cs:dirtyindexoffset
	mov	cx,si
	xor	ax,ax
	cmp	word_masks,0
	jz	flush_byte_masks
	add	cx,cx			; just double the count
;					;  for word masks
flush_byte_masks:
	rep	stosb
 
	pop	di
	pop	es
	mov	word ptr cs:number_of_dirty_elements,0
	ret
 
flush_queue endp
 
zseg ends
 
end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\msbds.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;


; values for various flags in bds_flags.

fnon_removable	    equ     01h 	;for non-removable media
fchangeline	    equ     02h 	;if changeline supported on drive
return_fake_bpb     equ     04h 	; when set, don't do a build bpb
					; just return the fake one
good_tracklayout    equ     08h 	; the track layout has no funny sectors
fi_am_mult	    equ     10h 	;if more than one logical for this physical
fi_own_physical     equ     20h 	;signify logical owner of this physical
fchanged	    equ     40h 	;indicates media changed
set_dasd_true	    equ     80h 	; set dasd before next format
fchanged_by_format  equ    100h 	;media changed by format
unformatted_media   equ    200h 	;an001; fixed disk only

;
; various form factors to describe media
;
ff48tpi 	    equ     0
ff96tpi 	    equ     1
ffsmall 	    equ     2
ffhardfile	    equ     5
ffother 	    equ     7
ff288		    equ     9		; 2.88 MB drive

bds_struc	struc
bds_link	dd		0ffffh	; link to next bds
bds_drivenum	db		80	; int 13 drive number
bds_drivelet	db		3	; dos drive number

;	We want to embed a BPB declaration here, but we can't initialize
;	it properly if we do, so we duplicate the byte/word/dword architecture
;	of the BPB declaration.

;BDS_BPB	db	size BPBSTRUC dup (?)	; actual BPB
BDS_BPB		dw	512		; BPB_BYTESPERSECTOR
		db	1		; BPB_SECTORSPERCLUSTER
		dw	1		; BPB_RESERVEDSECTORS
		db	2		; BPB_NUMBEROFFATS
		dw	16		; BPB_ROOTENTRIES
		dw	0		; BPB_TOTALSECTORS
		db	0f8h		; BPB_MEDIADESCRIPTOR
		dw	1		; BPB_SECTORSPERFAT
		dw	0		; BPB_SECTORSPERTRACK
		dw	0		; BPB_HEADS
		dd	0		; BPB_HIDDENSECTORS
		dd	0		; BPB_BIGTOTALSECTORS

bds_fatsiz	db		0	; flags...
bds_opcnt	dw		0	; open ref. count
bds_formfactor	db		3	; form factor index
bds_flags	dw		0020h	; various flags
bds_ccyln	dw		40	; max number of cylinders

if 0
BDS_RBPB	db size A_BPB dup (0)	; recommended BPB

endif 
bds_track	db		-1	; last track accessed on drive
bds_tim_lo	dw		1	; time of last access. keep
bds_tim_hi	dw		0	; these contiguous.
bds_volid	db "NO NAME    ",0	; volume id of medium
bds_vol_serial	dd	0	  ;current volume serial number from boot record
bds_filesys_id	db	"FAT12   ",0 ; current file system id from boot record
bds_struc	ends

;	The assembler will generate bad data for "size bds_volid", so we'll
;	  define an equate here.

VOLID_SIZ	equ	12

bdsm_ismini	equ	bds_tim_lo	; overlapping bds_tim_lo
bdsm_hidden_trks equ	bds_tim_hi	; overlapping bds_tim_hi

max_mini_dsk_num = 23	      ; max # of mini disk ibmbio can support


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\version.inc ===
;/****************************************************************************
; *                                                                          *
; *      VERSION.H       -- Local Bambi version number                       *
; *                                                                          *
; ****************************************************************************/

	db   '4.1'
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\stacker.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

include bambi.inc

public	detect_stacker
public  detect_stacker_volume
public  stacker_dd_pointer

zseg    segment public 'CODE'

	assume  cs:zseg
	assume	ds:nothing

st_ptr	DD	0			;pointer to Stacker (0-->not there)
stacker_tested	db	0		;havent tested for stacker yet
stacker_version dw	0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
; Input: None
; Output:AX=0  --> Stacker not installed
;	 AX<>0 --> Stacker version*100  (e.g.  1.00 --> 0064H)
;	
;	Stacker is detected by making an INT 25H call with invalid
;	parameters.
;
detect_stacker proc
	cmp	cs:stacker_tested,0
	je	do_stacker_test
	mov	ax,cs:stacker_version
	ret
do_stacker_test:
	push	bp
	push	si
	push	di

	sub	sp,1024			;use the stack as a temp buffer

	mov	ax,0cdcdh		;invalid drive #
	mov	bx,sp			;DS:BX --> buffer for INT 25H
	mov	cx,1
	xor	dx,dx			;read boot sector of invalid drive
	mov	word ptr [bx],dx	;clear the "return" value
	push	ds			;(set ES:BP to fix DOS 3 INT 25H bug)
	pop	es			
	mov	bp,bx
	int	25H
	pop	cx			;get rid of flags

	xor	ax,ax			;default is No stacker
	mov	bx,sp			;point at result
	cmp	word ptr [bx],0CDCDH	;Stacker INT 25 fills in some fields.
	jnz	gotres			;Make sure they all match
	cmp	word ptr 2[bx],1
	jnz	gotres
	les	di,4[bx]		;pointer into Stacker
	cmp	word ptr es:[di],0A55AH	;must find signature
	jnz	gotres
	mov	word ptr st_ptr  ,di	;save pointer to show it's found
	mov	word ptr st_ptr+2,es
	mov	ax,es:[di+2]		;stacker version * 100
gotres:
	add	sp,1024
	pop	di			;restore regs
	pop	si
	pop	bp
	mov	stacker_tested,1
	mov	stacker_version,ax
	ret
detect_stacker	endp


;
; Input: dx->driveno: 0=A, 1=B, 2=C, etc.
;
; Output:AX=1 --> Is a Stacker volume
;	 AX=0 --> Is not a Stacker volume
;	 BL = Stacker unit number if AX=1
;	
; Notes: If a multitasking environment is present (such as Windows), you 
;	 must make this a critical section of code!
;
;	 This method uses the removeable media ioctl call to detect 
;	 Stacker volumes.  It does NOT work under DR DOS 5.0, since that
;	 version of DOS does NOT pass these calls through to the Stacker
;	 device driver.
;

UNIT_OFFS equ	3EH			;offset with Stacker of 

driveno dw ?
detect_stacker_volume proc 
	mov	cs:driveno,dx
	cmp	word ptr st_ptr+2,0	;already found Stacker?
	jnz	stacker_fnd
	call	detect_stacker		;is not, try again
	xor	ax,ax			;return 0 if not found
	cmp	ax,word ptr st_ptr+2	;is it ther
	jz	retOp
	; Here if Stacker IS installed.
stacker_fnd:
	mov	ah,30h			;treat DR DOS special
	int	21h			;(it doesn't pass 4408H through)
	cmp	ax,1F03H
	mov	ax,4408H		;do an ioctl call 
	jnz	use08
	mov	al,0EH			;(DR DOS, Compaq 3.31: 440EH)

use08:	les	di,st_ptr
	mov	byte ptr es:UNIT_OFFS[di],0FFH	;set Stacker unit #
	mov	bx,driveno
	inc	bx			;adjust for default

	int	21h			;if Stacker drive, will return
	mov	ax,0
	jc	retOp			;no ioctl support --> not Stacker

	les	di,st_ptr		;see if unit # changed
	mov	bl,byte ptr es:UNIT_OFFS[di]
	cmp	bl,0FFH
	jz	retOp

	inc	ax			;if so, we have a Stacker volume
retOp:	ret
detect_stacker_volume endp



;
; This data structure is part of the Stacker internal data structure 
; maintained for each Stacker drive.  A pointer to this structure can be
; obtained from the routine stacker_dd_pointer() below.  See ST.C for
; an example.  Assuming that nothing else has "stolen" the DPB for a drive,
; you can perform a sanity check by comparing the strategy and interrupt
; pointers found here with those found in another DPB (or in the device
; chain).  As a quick check, you could also make sure that the segment
; part of dv_strategy is the same as that for dv_interrupt.
;
; To force Stacker to call a different device driver, the following
; fields must be modified:  dv_strategy, dv_interrupt, and dv_unit.
;
;
STACKER_DD struc
dv_strategy	dd	1 dup(?)	;physical device driver strategy addr
dv_interrupt	dd	1 dup(?)	;physical device driver interrupt addr
dv_att		dw	1 dup(?)	;device driver header attributes
dv_cluster0	dw	1 dup(?)	;first file cluster of
dv_log2		db	1 dup(?)	;LOG base 2 of physical bytes/sector
dv_unit		db	1 dup(?)	;physical device driver unit number
STACKER_DD ends

STACKER_UNIT_DD_OFFSET	equ	015CH

;
; C declaration:  STACKER_DD far *stacker_dd_pointer(int driveno);
;
; Input: dx->driveno: 0=A, 1=B, 2=C, etc.
;
; Output:DX:AX = far pointer to the STACKER_DD struc (0:0 if error)
;	
; Notes: If a multitasking environment is present (such as Windows), you 
;	 must make this a critical section of code!

stacker_dd_pointer proc 
	mov	cs:driveno,dx
	push	driveno
	call	detect_stacker_volume
	pop	cx			;get rid of driveNo on stack
	cwd
	or	ax,ax
	jnz	isStacker
	ret
isStacker:	
	les	di,st_ptr
	mov	di,es:4[di]		;get unit table pointer
	xor	bh,bh
	add	bx,bx			;multiply unit # by two
	mov	ax,es:[di+bx]		;dx:ax = per unit pointer
	add	ax,STACKER_UNIT_DD_OFFSET
	mov	dx,es			;return pointer
	ret
stacker_dd_pointer endp

zseg ends

end




































=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\umbload.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;OVERVIEW
;	
;	This module actually contains the initial entry point for the
;program.  It detemines if the program has been loaded in a UMB, and
;if not, it re-execs itself in an attempt to load into a UMB. If the new
;load fails, it continues to load the TSR low. If the load succeeds,
;it exits and thus leaves a zero low memory footprint.
;


include bambi.inc

;
;	routines from int2f.asm
;
extrn	call_bambi			:near

extrn	initialize	:near
extrn 	transient_stack :word
extrn	vxd_name	:byte

PUBLIC	myPSP
PUBLIC  savestrategy
PUBLIC	saveumblink
PUBLIC	find_startup_name	;used later too for vxd load

zseg	segment	public 'code'

	assume	cs:zseg,ds:zseg
start   :
;;;     PROGRAM EXECUTION BEGINS HERE
;;;     ES:0 is the PSP

;;;	first set up a stack!
	mov	ax,cs
	mov	ss,ax
	mov	sp,offset cs:transient_stack
	
;;;     Get my PSP to look at command line

	mov	cs:myPSP,es

	push	cs
	pop	ds

	mov     ax,es
	mov     cmd_seg,ax

	mov ax,5800h    ; Get allocation Strategy ;output in ax
	int 21h
	mov 	savestrategy,ax


	mov ax,5802h    	; Get link state; output in al
	int 21h
	xor	ah,ah		;be sure ah = 0!
	mov	saveumblink,ax

	call	check_loadlow_switch	;note es:80h points to command line
	jc	go_with_what_we_have_short
	
	mov	ax,BAMBI_GET_STATS	; get stats also used for detection
	call	call_bambi
	cmp	ax,BAMBI_SIGNATURE	; ax = signature if bambi is loaded
	jne	try_to_load
go_with_what_we_have_short:
	jmp	go_with_what_we_have
	
try_to_load:

	cmp	saveumblink,1
	jne	not_already_high
	jmp	already_high
not_already_high:
	mov     ax,5803h        ;link/unlink UMBs bx = 0 is unlink,bx =1 is link
	mov     bx,1		;enable umb links
	int     21h
	jc	cant_set_link

	mov	ax,5801h
	mov	bx,40h		;first-fit high only
	int	21h

	call find_startup_name

 	mov     ax,cs
	mov     es,ax

	mov     fcb1_seg,ds     ; parameter block for EXEC
	mov     fcb2_seg,ds


	mov     bx,offset zseg:par_blk
	mov	ax,offset dummy_environ
	mov	cl,4
	shr	ax,cl
	mov	dx,cs
	add	ax,dx
	mov	[bx],ax

	push	ds
	mov     dx,startup_name_off
	mov     ds,startup_name_seg
	

	mov     ax,4b00h        ; AX = EXEC/run program
	int     21h             ; carry = EXEC failed
	pop	ds
	jc	go_with_what_we_have

	push	ax		;save return code from exec

	mov     ax,5803h        ;link/unlink UMBs bx = 0 is unlink,bx =1 is link
	mov     bx,cs:saveumblink	;disable umb links
	int     21h

	mov	ax,5801h
	mov	bx,cs:savestrategy	
	int	21h

	pop	ax		;restore exec return code
	cmp	al,1		;error code from bambinit.asm
	je	really_exit

	mov	ax,BAMBI_GET_STATS	; get stats also used for detection
	call	call_bambi
	cmp	ax,BAMBI_SIGNATURE	; ax = signature if bambi is loaded
	jne	go_with_what_we_have
really_exit:

	mov	ax,4c00h		; no error code
	int	21h
	int	3

go_with_what_we_have:
cant_set_link:
	mov     ax,5803h        ;link/unlink UMBs bx = 0 is unlink,bx =1 is link
	mov     bx,cs:saveumblink	;disable umb links
	int     21h

	mov	ax,5801h
	mov	bx,cs:savestrategy	
	int	21h

already_high:
	mov	es,cs:myPSP		;restore input PSP 
	jmp	initialize


;;; es is segment of psp on entry,
;;; sets globals startup_name_seg and startup_name_off
;;; kills ax,cx,di
find_startup_name proc near
	push es
	cld
	;;; we get the segment of the environment...
	mov ax,es:ENVSEGOFFSETINPSP
	mov es,ax
	;;; whose offset is 0...
	xor ax,ax
	mov di,ax
	mov cx,-1
keep_looking:
	;;; and scan to the end of it to find the start-up name
	repnz scasb
	;;;repnz scasw puts di one farther than first non-match
	;;;also a zero here?
	cmp es:[di],al
	jz  found
	loop keep_looking
found:
	add di,3 ;;;1 for zero,2 for initial word in front of name
	;;;es:di points to startup name
	;;;save it
	mov cs:startup_name_seg,es
	mov cs:startup_name_off,di

	push	ds
	push	si
	push	di
	;;; save off the name here since it is need by the resident
	;;; code when it tells win386 what file the sdvxd is in.
	;;;
	push	es
	pop	ds
	mov	si,di
	;;;ds:si-> source string
	push	cs
	pop	es
	mov	di,offset cs:vxd_name
	;;;es:di-> destination string
	mov cx,67	
	rep movsw		

	pop	di
	pop	si
	pop	ds

	pop es
	ret
find_startup_name endp

;
; INPUT
;	es:80h points to command line
; OUTPUT
;	carry set means dont loadhi
;
check_loadlow_switch proc near
	push	es
	push	di
	mov	di,COMMAND_LINE_OFFSET+1 ;skip length byte
	mov	cx,MAX_COMMAND_LINE_LENGTH	
	mov	al,COMMAND_LINE_TERMINATOR
	repnz	scasb
	jnz	not_loadlow
	mov	ax,MAX_COMMAND_LINE_LENGTH
	sub	ax,cx
	xchg	ax,cx			;cx = actual commandline length

	mov	di,COMMAND_LINE_OFFSET	;start back at beginning
	mov	al,COMMAND_SWITCH_CHAR
scanning_for_switch:
	repnz	scasb
	jnz	not_loadlow
	mov	bl,byte ptr es:[di]
	or	bl,32			;lower case it
	cmp	bl,LOAD_LOW_FLAG
	je	load_low
	jmp	short	scanning_for_switch
not_loadlow:
	clc
	jmp	short checkout
load_low:
	stc
checkout:
	pop	di
	pop	es
	ret
check_loadlow_switch endp

ENVSEGOFFSETINPSP equ 02Ch
COMMANDLINEIN equ 80h        ; offset of command line passed in (PSP)

savestrategy	 	dw 	?
saveumblink		dw	?
extrn 	startup_name_seg 	:word
extrn	startup_name_off 	:word
myPSP		 	dw	?

par_blk  dw     0
cmd_loc  dw     COMMANDLINEIN   ; command-line address
cmd_seg  dw     0               ; fill in at initialization
	 dw     offset fcb1     ; default FCB #1
fcb1_seg dw     0               ; fill in at initialization
	 dw     offset fcb2     ; default FCB #2
fcb2_seg dw     0               ; fill in at initialization

fcb1     db     0
	 db     11 dup (' ')
	 db     25 dup ( 0 )
fcb2     db     0
	 db     11 dup (' ')
	 db     25 dup ( 0 )

align 16
dummy_environ	dd	0
zseg	ends
	end	start



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\xms.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;OVERVIEW
;	This moduel contains asm callable routines for manipulating
;XMS memory. This module depends on being initialzed by the
;initialize_xms call from xmsini.asm.
;	The XMS routines are divide into xmsini.asm and xms.asm
;so initialization code can be separated from resident code.
;	The expected use of these function is		
;		initialze XMS via initialize_xms
;		allocate some XMS memory via allocate_xms_memory
;		read/write from XMS memory via block_read and block_write
;		resize a memory block via reallocate_xms_memory
;		free XMS memory via free_xms_memory (warning: in xmsini.asm)

include xms.inc

public	block_write
public	block_read
public	reallocate_xms_memory
public	XMSControl

;	align the XMS packet to a word boundary

zseg    segment word public 'CODE'

	assume  cs:zseg
	assume  ds:zseg

;
;	local data
;

XMSMovePacket	extmemmovestruct <0>
XMSControl 	dd	0

;
; INPUT
;	BX == new Kbytes to re-allocate
;	DX == handle to XMS Memory
; OUTPUT
;	AX == 0 on error
;	error code in BX
;
ReAllocate_XMS_Memory proc near
	mov	ah, XMS_REALLOC_EMB	; allocate dx K of extended mem.
	call	DWORD PTR cs:[XMSControl]
	ret
ReAllocate_XMS_Memory endp


;
; INPUT
;
;	BX = XMS Handle
;	DX:AX = offset into XMS block referred to by AX
;	ES:DI = Near Memory Source
;	CX = Number of words to transfer
; OUTPUT
Block_Read proc near
	push	dx
	push	ax
	push	bx
	push	cx
	push	si
	
	mov	si, offset cs:XMSMovePacket	; cs:si points to buffer


; initialize length field

	shl	cx, 1			; cx = # of bytes to transfer
	mov	word ptr cs:[si.mov_length], cx
;redundant	mov	word ptr cs:[si.mov_length + 2], 0

; initialize source handle 

	mov	cs:[si.src_handle], bx

; initialize source offset 

	mov	word ptr cs:[si.src_offset], ax
	mov	word ptr cs:[si.src_offset + 2], dx


; initialize destination handle	and offset 

	mov	cs:[si.dst_handle], 0		; offset is Segment:Offset
	mov	word ptr cs:[si.dst_offset], di
	mov	word ptr cs:[si.dst_offset + 2], es

do_move:
	mov	ah, XMS_MOVE_EMB	; move ext. mem. block function
	call	DWORD PTR cs:[XMScontrol]

	shr	ax,1			; rotate 'success' bit into carry
	cmc				; make it a failure flag

	pop	si
	pop	cx
	pop	bx
	pop	ax
	pop	dx
	ret
Block_Read endp


;
; INPUT
;
;	BX = XMS Handle
;	DX:AX = offset into XMS block referred to by AX
;	ES:DI = Near Memory Source
;	CX = Number of words to transfer
;	
; OUTPUT
Block_Write proc near
	push	dx
	push	ax
	push	bx
	push	cx
	push	si
	
	mov	si, offset cs:XMSMovePacket	; cs:si points to buffer


; initialize length field
	shl	cx, 1			; cx = # of bytes to transfer
	mov	word ptr cs:[si.mov_length], cx
;redundant	mov	word ptr cs:[si.mov_length + 2], 0

; initialize source handle and offset

	mov	cs:[si.src_handle], 0		; offset is Segment:Offset
	mov	word ptr cs:[si.src_offset], di
	mov	word ptr cs:[si.src_offset + 2], es

; initialize destination handle
	mov	cs:[si.dst_handle], bx

; initialize destination offset

	mov	word ptr cs:[si.dst_offset], ax
	mov	word ptr cs:[si.dst_offset + 2], dx

; call XMS to move memory
	jmp	do_move	;in block read above

Block_Write endp


zseg ends

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\tdata.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

PUBLIC	drives_to_cache
PUBLIC	first_instance
PUBLIC	ending_address
PUBLIC  shutupmsdosflag
PUBLIC  warnmsdosmessage

zseg    segment public 'CODE'

	assume  cs:zseg
	assume	ds:nothing

ending_address	dw	?

;default to a 2 meg cache with 8k elements
warnmsdosmessage		db	0
drives_to_cache			db	26	dup(0)
first_instance			db	1	;0 if bambi is already resident
shutupmsdosflag			db	0

sseg	segment para stack 'STACK'
		dw	768	dup ('!')		;stack for write-behind
transient_stack	dw	0
public transient_stack
sseg	ends
zseg ends

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\xmsini.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;OVERVIEW
;	This module contains the initialization portion for xms.asm.
;Please see xms.asm for more info
;

include xms.inc

public	allocate_xms_memory
public	free_xms_memory
public  initialize_xms
public	query_free_xms_memory

extrn	XMSControl		:dword

zseg    segment public 'CODE'

	assume  cs:zseg
	assume  ds:zseg

;
;	local data
;

;
; INPUT 
;	none
; OUTPUT
;	carry if no XMS driver found
;
Initialize_XMS	proc	near
	push	ax
	mov	ax,XMS_MULTIPLEX SHL 8 + XMS_INSTALL_CHECK
	int	2Fh
	cmp	al,80h			; Q: installed
	jne	cXMS_no_driver		; N: set error, quit
;
; get the XMS control functions entry point, save it, we
; need to call it later.
;
	push	es
	push	bx
	mov	ax,XMS_MULTIPLEX SHL 8 + XMS_FUNCTION_ADDR
	int	2Fh
	mov	word ptr cs:[XMScontrol], bx
	mov	word ptr cs:[XMScontrol+2],es
	pop	bx
	pop	es
	pop	ax
	clc
	ret				; done
;
; flag error : XMS driver not present
;
cXMS_no_driver:
	stc
	pop	ax
	ret

Initialize_XMS	endp


;
; INPUT
;	DX == Kbytes to allocate
; OUTPUT
;	AX == 0 on error
;	DX == handle to XMS Memory
;
Allocate_XMS_Memory proc near
	mov	ah, XMS_ALLOC_EMB	; allocate dx K of extended mem.
	call	DWORD PTR cs:[XMSControl]
	ret
Allocate_XMS_Memory endp

;
; INPUT
;	none
; OUTPUT
;	AX = largest free block	
;	DX = total free extended memory
;
query_free_XMS_Memory proc near
	mov	ah, XMS_QUERY_FREE_EXTMEM  ;returns total kb free in dx
	call	DWORD PTR cs:[XMSControl]
	ret
query_free_XMS_Memory endp

;
; INPUT
;	DX == handle to Memory
; OUTPUT
;	none
;
Free_XMS_Memory proc near
	mov	ah, XMS_FREE_EMB	; allocate dx K of extended mem.
	call DWORD PTR cs:[XMSControl]
	ret
Free_XMS_Memory endp

zseg ends

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\xms.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

XMS_MULTIPLEX		equ	43h	; XMS multiplex number of INT 2Fh
XMS_INSTALL_CHECK	equ	00h	; install check call
XMS_FUNCTION_ADDR	equ	10h	; get control function address call
;
; XMS functions
;
XMS_GET_VERSION		equ	00h
XMS_REQUEST_HMA		equ	01h
XMS_RELEASE_HMA		equ	02h
XMS_GLOBAL_ENABLE_A20	equ	03h
XMS_GLOBAL_DISABLE_A20	equ	04h
XMS_LOCAL_ENABLE_A20	equ	05h
XMS_LOCAL_DISABLE_A20	equ	06h
XMS_QUERY_A20		equ	07h
XMS_QUERY_FREE_EXTMEM	equ	08h
XMS_ALLOC_EMB		equ	09h
XMS_FREE_EMB		equ	0Ah
XMS_MOVE_EMB		equ	0Bh
XMS_LOCK_EMB		equ	0Ch
XMS_UNLOCK_EMB		equ	0Dh
XMS_GET_EMB_INFO	equ	0Eh
XMS_REALLOC_EMB		equ	0Fh
XMS_REQUEST_UMB		equ	10h
XMS_RELEASE_UMB		equ	11h
;
; Valid error codes in BL have this bit set.
; But, only check BL if AX = 0.
;
XMS_ERROR_BIT		equ	80h

;
; struct pass to XMS_MOVE_EMB in DS:SI
;
ExtMemMoveStruct	struc
	mov_length	dd	?	; 32 bit number of bytes to transfer
	src_handle	dw	?	; handle of source block
	src_offset	dd	?	; 32 bit offset into source
	dst_handle	dw	?	; handle of destination block
	dst_offset	dd	?	; 32 bit offset into destination
ExtMemMoveStruct	ends




=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\messages\usa\sdvxdtxt.asm ===
PAGE 58,132
;******************************************************************************
TITLE SDTEXT.ASM -- Text messages for SmartDrv VxD
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1991
;
;   Title:	SDTEXT.ASM -- Text messages for SmartDrv VxD
;
;   Version:	1.00
;
;   Date:	22-Nov-1991
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   22-Nov-1991 RAL Text messages for SmartDrv VxD
;
;==============================================================================


	.386p

	.XLIST
	INCLUDE VMM.INC
	.LIST


	PUBLIC	SDVxD_Error_Title_Msg
	PUBLIC	SDVxD_Write_Error_Msg
	PUBLIC	SDVxD_Write_Drive_Letter

VxD_DATA_SEG

SDVxD_Error_Title_Msg db "SERIOUS DISK ERROR", 0

SDVxD_Write_Error_Msg LABEL BYTE
		db 'A serious disk error has occurred while writing to drive '
SDVxD_Write_Drive_Letter db "?"
		db '.  Continue will retry the operation.', 0

VxD_DATA_ENDS

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\sdvxd\debug.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1989-1990
;
;******************************************************************************

;******************************************************************************
;
;   Assumes_Fall_Through
;
;   DESCRIPTION:
;	Used for debugging purposes only.  It will generate an error if
;	the IP <> the specified label.
;
;   PARAMETERS:
;	Label_Name = Name of label to fall-through to
;
;------------------------------------------------------------------------------

Assumes_Fall_Through MACRO L
IF2
IF (L - $) GT 3
%OUT ERROR:  Fall through to &L invalid
.ERR
ENDIF
ENDIF
		     ENDM


;******************************************************************************
;
;   Assert_VM_Handle
;
;   PARAMETERS:
;	Handle_Register = Register that contains a VM handle
;
;   ASSUMES:
;	Debug_Test_Valid_Handle does not destroy any registers or flags
;
;   EXIT:
;	NOTHING MODIFIED (not even flags)
;
;------------------------------------------------------------------------------

Assert_VM_Handle MACRO R
IFDEF DEBUG
	push	ebx
	mov	ebx, R
	VMMcall Debug_Test_Valid_Handle
	pop	ebx
ENDIF
	ENDM




;******************************************************************************
;
;   Trace_Out
;
;------------------------------------------------------------------------------

Trace_Out MACRO S, nocrlf
	LOCAL	Str_Off
IFDEF DEBUG
_LDATA SEGMENT
Str_Off db	S
IFB <nocrlf>
	db	0Ah,0Dh
ENDIF
	db	0
_LDATA ENDS

	pushfd
	pushad
	mov	esi, OFFSET32 Str_Off
	VMMcall Out_Debug_String
	popad
	popfd
ENDIF
	ENDM


;******************************************************************************
;
;   Debug_Out
;
;------------------------------------------------------------------------------

Debug_Out MACRO S
	LOCAL	Skip_Int1
IFDEF DEBUG
	pushfd
	Trace_Out   <S>
	VMMcall Test_Debug_Installed
	jz	SHORT Skip_Int1
	int	1
Skip_Int1:
	popfd
ENDIF
	ENDM


;******************************************************************************
;
;   Queue_Out
;
;------------------------------------------------------------------------------

Queue_Out MACRO S, V1, V2
	LOCAL	Str_Off
IFDEF DEBUG

_LDATA SEGMENT
Str_Off db S, 0Ah,0Dh, 0
_LDATA ENDS

	pushfd
	push	esi
IFNB <V1>
    IF	TYPE V1 GT 0
	push	dword ptr V1
    ELSE
	push	V1
    ENDIF
ELSE
	push	eax		; dummy value1
ENDIF
IFNB <V2>
    IF	TYPE V2 GT 0
	push	dword ptr V2
    ELSE
	push	V2
    ENDIF
ELSE
	push	ebx		; dummy value2
ENDIF
	mov	esi, OFFSET32 Str_Off
	VMMcall Queue_Debug_String
	pop	esi
	popfd
ENDIF
	ENDM






;******************************************************************************
;
;   Assert_Ints_Disabled
;
;------------------------------------------------------------------------------

Assert_Ints_Disabled MACRO
	LOCAL	OK

IFDEF DEBUG
	pushfd
	test	WORD PTR [esp], IF_Mask
	jz	SHORT OK
	Debug_Out "ERROR:  Ints enabled at Assert_Ints_Disabled"
	Fatal_Error
OK:
	popfd
ENDIF

	ENDM


;******************************************************************************
;
;   Assert_Ints_Enabled
;
;------------------------------------------------------------------------------

Assert_Ints_Enabled MACRO
	LOCAL	OK

IFDEF DEBUG
	pushfd
	test	WORD PTR [esp], IF_Mask
	jnz	SHORT OK
	Debug_Out "ERROR:  Ints disabled at Assert_Ints_Enabled"
	Fatal_Error
OK:
	popfd
ENDIF

	ENDM


;******************************************************************************
;
;   Assert_Cur_VM_Handle (Register)
;
;   DESCRIPTION:
;
;   ENTRY:
;
;   EXIT:
;
;   USES:
;
;==============================================================================

Assert_Cur_VM_Handle MACRO R
	LOCAL	OK
IFDEF DEBUG
	push	ebx
	mov	ebx, R
	VMMcall Debug_Test_Cur_VM
	pop	ebx
ENDIF
	ENDM




Assert_Client_Ptr MACRO Reg

IFDEF DEBUG
	push	ebp
	mov	ebp, Reg
	VMMcall Validate_Client_Ptr
	pop	ebp
ENDIF

	ENDM




;******************************************************************************


Dump_Struc_Head MACRO
IFDEF DEBUG
	Trace_Out "  Base    Address   Offs     Value  Field name"
ENDIF
	ENDM

Dump_Struc MACRO Base, X
IFDEF DEBUG
	pushfd
	pushad
	lea	esi, [Base]
	mov	ecx, X
	lea	edx, [esi+ecx]

IF SIZE X EQ 6
	mov	bx, WORD PTR [edx+4]
	mov	eax, DWORD PTR [edx]
	Trace_Out "#ESI  #EDX  #CX  #BX:#EAX  &X"
ELSE
IF SIZE X EQ 4
	mov	eax, DWORD PTR [edx]
	Trace_Out "#ESI  #EDX  #CX  #EAX  &X"
ELSE
IF SIZE X EQ 2
	mov	ax, WORD PTR [edx]
	Trace_Out "#ESI  #EDX  #CX      #AX  &X"
ELSE
	mov	al, BYTE PTR [edx]
	Trace_Out "#ESI  #EDX  #CX        #AL  &X"
ENDIF
ENDIF
ENDIF

	popad
	popfd
ENDIF
	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\doubleb\transbuf.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;extrn	 ismsdos		 :far

vseg segment byte public 'CODE'
	assume cs:vseg,ds:vseg,es:NOTHING


include ..\bambi.inc

PUBLIC 	initialize_double_buffering
PUBLIC 	init_safedsk

extrn	safe_13_handler		:far
extrn	int_2f_handler		:far
extrn	track_buffer		:near
extrn	int_2f_chain		:dword
extrn  	int_13_chain		:dword
extrn  	sectrack		:word
extrn	track_buffer_ptr	:dword
extrn	buffer_size		:word
extrn	check_for_dangerous_disk_partitions:near
extrn	check_dma_services	:byte
extrn	double_buffering_required:byte

extrn	SignOn			:byte  
extrn	SignOff			:byte
extrn	Warning1		:byte
extrn	Warning2		:byte
extrn	Noloadumb		:byte


SWITCH_CHAR equ '/'
BUFFER_CHAR equ 'D'
PLUS_CHAR   equ '+'

MAX_CONFIG_LINE equ 128
MAXDRIVES 	equ 	16

	assume	ds:nothing

dontload	db	0

parse_config_line proc near
	push	es
	push	bx
	push	di
	push	ax

	mov	bx,es:[di].12h
	mov	es,es:[di].14h

	mov	di,bx
	mov	cx,MAX_CONFIG_LINE		;maximum length
	mov	al,0dh
	repne	scasb
	cmp	cx,0
	jne	found_terminator

	mov	di,bx
	mov	cx,MAX_CONFIG_LINE
	mov	al,0ah
	repne	scasb

found_terminator:
	sub	cx,MAX_CONFIG_LINE
	neg	cx

	mov	di,bx
continue_scan:
	mov	al,SWITCH_CHAR
	repne	scasb

	jne	no_switch_found
	;;;es:di points right after the switch
	mov	al,es:[di]
	and	al,not 20h	;mask off shift bit
	cmp	al,BUFFER_CHAR
	jne	continue_scan

	;;;/d switch found

	mov	al,PLUS_CHAR
	repne	scasb
	jne	no_plus_found

	mov	cs:check_dma_services,0

	;;; we have to set table to -1 so smardrv.exe will print proper status
	mov	cx,MAXDRIVES
continue_force_buffering:
	mov	bx,cx
	dec	bx
	mov	cs:double_buffering_required[bx],-1		
	loop	continue_force_buffering

no_plus_found:

	pop	ax	
	pop	di
	pop	bx
	pop	es
	ret
no_switch_found:
;	mov	cs:dontload,1 ;now we load even if no switch was given
	jmp 	short no_plus_found

parse_config_line endp

init_safedsk proc near

	;;; refuse to load above a000 since this is a umb.
	;;;
	mov	ax,cs
	cmp	ax,0A000h
	jb	probablynotumb
	mov	dx,offset cs:Noloadumb
	jmp	dontloadumb
probablynotumb:

	mov	ax,MULT_BAMBI			;device already loaded?
	mov	bx,BAMBI_GET_BUFFER_INFO	;try to get info
	int	2fh				;using int 2f api
	cmp	ax,BAMBI_SIGNATURE		;if we get an answer
	je	dontloadnowarning			;we are already loaded

	xor	ax,ax
;	call	ismsdos	philba says not to do this here
	mov	ax,2000h 
	call	parse_config_line
	cmp	cs:dontload,1
	je	dontloadnowarning
	cmp	ah,0
	je	dont_load
loadanyway:
	
	cmp	cs:check_dma_services,0
	je	dont_check_partition

	push	ds
	push	es
	push	si
	push	di
	push	bx

	call	check_for_dangerous_disk_partitions

	pop	bx
	pop	di
	pop	si
	pop	es
	pop	ds
	jc	dontloadnowarning
dont_check_partition:       	

	mov     word ptr es:[di+3],0100h ;Completed code passed in packet
	mov	cx,2
	call    initialize_double_buffering

	mov     ah,09h                  ;Print out a the sign on message
	mov     dx,offset       SignOn
	int     21h

	mov	dx,cs:buffer_size
	mov	cl,4
	shl	dx,cl
	add	dx,offset cs:track_buffer

	mov     WORD PTR es:[di+0Eh],dx  	;resident up to track buffer
	mov     WORD PTR es:[di+10h],cs        	;the rest is free'd
	stc
	ret
dont_load:

	mov     ah,09h                  ;Print out a warning message
	mov     dx,offset       Warning1
	int     21h

	mov	ah,dontload
	and	ah,7
	add	ah,'0'
	mov	bx,dx
	mov	[bx],ah
	mov	byte ptr [bx+1],'$'
	mov     ah,09h                  
	int     21h

	mov     ah,09h                  
	mov     dx,offset       Warning2
	int     21h
	jmp	loadanyway
dontloadnowarning:
	mov     dx,offset       SignOff
dontloadumb:
	mov     ah,09h                  ;Print out a the sign off message
	int     21h

	clc
	ret
init_safedsk endp


;
;INPUT
;	cx = number of 512 byte sectors in double buffer
;	     if cx = 0, code uses default track size
;
initialize_double_buffering proc near

	push	ds
	push	cs
	pop	ds

assume	ds:vseg
	
	or	cx,cx		;size specified
	jnz	buffer_size_input
    ;
    ; First figure out sec/track of any hardfiles
    ;
	MOV	DL,80H
	MOV	AH,8
	INT	13H
	JC	NO_HARDFILES
	OR	DL,DL
	JZ	NO_HARDFILES
	xor	ch,ch
	AND	CL,00111111B
buffer_size_input:
	MOV	[SECTRACK],CX


	mov	bx,cx
	mov	cl,5
	add	bx,1
	shl	bx,cl

if 0
device drivers cannot alloc memory
	push	bx

	mov     ax,5803h        ;link/unlink UMBs bx = 0 is unlink,bx =1 is link
	mov     bx,0		;enable umb links
	int     21h
	pop	bx

	mov	ah,48h
	push	bx
	int	21h			;segment in AX if no error
	pop	bx
	jnc	allocation_complete
endif

	mov	cs:buffer_size,bx
	mov	word ptr Track_buffer_ptr[2],cs
	mov	word ptr track_buffer_ptr[0],offset cs:track_buffer
	jmp	append_alloc

allocation_complete:
	mov	word ptr Track_buffer_ptr[2],ax
	mov	word ptr track_buffer_ptr[0],0
append_alloc:
    ;
    ; Figure out if we have a DMA boundary problem
    ;
	mov	dx,word ptr Track_buffer_ptr[2]
	shl	DX,1
	shl	DX,1
	shl	DX,1
	shl	DX,1			; Segment converted to absolute address
	add	DX,word ptr TRACK_BUFFER_PTR[0]	; Combine with offset
	add	DX,511			; simulate a one sector transfer
					; And set next divide for round up
;
; If carry is set, then we are within 512 bytes of the end of the DMA segment.
; Adjust TRACK_BUFFER_PTR UP by 512 bytes.
;
	jnc	NotWithin512
	add	word ptr TRACK_BUFFER_PTR[0],512	; adjust


notwithin512:
	call	Hook_ISR_13
	call	Hook_ISR_2f
	clc
FINISHED:
	pop	ds
	ret
NO_HARDFILES:
	pop	ds
	stc
	ret
initialize_double_buffering endp

Hook_ISR_13     proc    near

	    push es
	    push di
	    
	    mov ax,3513h                 ; save interrupt 13 vector
	    int 21h                      ; returns in es:bx

	    mov WORD PTR cs:Int_13_Chain,bx
	    mov ax,es
	    mov WORD PTR cs:Int_13_Chain[2],ax

	    mov dx,offset safe_13_handler    ;patch interrupt 13 vector with
	    mov ax,2513h                 ;our own routine
					 ;assumes ds already holds code segment
	    int 21h

	    pop di
	    pop es
	    ret

Hook_ISR_13     endp

Hook_ISR_2f     proc    near

	    push es
	    push di
	    
	    mov ax,352fh                 ; save interrupt 2f vector
	    int 21h                      ; returns in es:bx

	    mov WORD PTR cs:Int_2f_Chain,bx
	    mov ax,es
	    mov WORD PTR cs:Int_2f_Chain[2],ax

	    mov dx,offset int_2f_handler    ;patch interrupt 2f vector with
	    mov ax,252fh                 	;our own routine
					 ;assumes ds already holds code segment
	    int 21h

	    pop di
	    pop es
	    ret

Hook_ISR_2f     endp



vseg ends

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\doubleb\badpart.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

vseg segment byte public 'CODE'
	assume cs:vseg,ds:vseg,es:NOTHING

PUBLIC check_for_dangerous_disk_partitions
PUBLIC last_safe_byte


_PartitionEntry struc

 PartBoot	db	?			; Boot indicator
 PartBeginHead	db	?			; Beginning Head
 PartBeginSect	db	?			; Beginning Sector
 PartBeginCyl	db	?			; Beginning Cylinder
						; Above two bytes are in
						; INT 13h format bits 8 & 9
						; of Cylinder in high 2 bits
						; of PartBeginSect
 PartSystemID	db	?			; Partition ID
 PartEndHead	db	?			; Ending Head
 PartEndSect	db	?			; Ending Sector
 PartEndCyl	db	?			; Ending Cylinder
						; See Comment for PartStartCyl
 PartRelStart	dd	?			; Starting Sector (Relative to
						; beginning of Disk
 PartNumSects	dd	?			; Number of sectors in
						; Partition

_PartitionEntry	ends

PARTENTRY_SIZE	equ	(SIZE _PartitionEntry)

MBR_SIGNATURE	equ	0aa55h
MBR_SIGLENGTH	equ	2

ONTRACK_SIG	equ	055aah			; M013
ONTRACK_SIGLEN	equ	2
ONTRACK_NUMPARTS equ	16
ONTRACK_PARTSIZE equ	(ONTRACK_NUMPARTS * PARTENTRY_SIZE)
SSTOR_NUMPARTS	equ	8
DOS_NUMPARTS	equ	4

MAXMBRCODESIZE	equ	(512-ONTRACK_PARTSIZE-MBR_SIGLENGTH-ONTRACK_SIGLEN)

__MBR		struc
 MBR_Code	db	MAXMBRCODESIZE dup (?)
 MBR_OnTrkSig	dw	?
 MBR_OnTrkPart	db	((ONTRACK_NUMPARTS-SSTOR_NUMPARTS)*(PARTENTRY_SIZE)) dup (?)
 MBR_SStorPart	db	((SSTOR_NUMPARTS-DOS_NUMPARTS)*(PARTENTRY_SIZE)) dup (?)
 MBR_DOSPart	db	(DOS_NUMPARTS * (PARTENTRY_SIZE)) dup (?)
 MBR_Sign	dw	?
__MBR		ends


; Partition system indicators for disk partitions which we may
; not work with:

RiskyPartitions		label	byte

		db	50h,51h		; Ontrack's Disk Manager
		db	56h		; Golden Bow's Vfeature
		db	61h,63h,64h,66h,71h,73h,74h,76h

SSTORParts	label	byte					; M10
		db	0E1h,0E3h,0E4h,0E6h,0F1h,0F3h,0F4h,0F6h
			     ;M07 ;M03	; Storage Dimensions' SpeedStor
NUMSSPARTIDS	equ	$-SSTORParts				; M10

		db	21h,23h,24h,26h,31h,33h,34h,36h
		db	0A1h,0A3h,0A4h,0A6h,0B1h,0B3h,0B4h,0B6h
			     ;M07 ; HP Volume Expansion (SpeedStor derivative)
		db	45h	  ;M03	; Priam

NUM_RISKYPARTITIONS	equ	$-RiskyPartitions

		db	05		; Extended DOS partition; M10

EXTNUM_RISKYPARTS	equ	$-RiskyPartitions		; M10


VfeatureStr	db	"Vfeature"	; string to identify Vfeature

LEN_VFEATURESTR	equ	$-VfeatureStr

PartitionCheck	db	1		; check for incompatible disk
					;  partitions = true

; M10 - BEGIN

ExtPartCheck	db	1		; scan extended master boot record
					; for incompatible disk partitions
; M10 - END

UMBCheck	db	1	      ;M06  ; check that we can read all disks
UMBCheckSig	db	"DOlSMRDO"    ;M06  ; signature	M10
CHECKSIGLEN	equ	$-UMBCheckSig ;M06  ; signature length

check_for_dangerous_disk_partitions proc near

;
; 3.5  Check for dangerous disk partitions.
;
	mov	bp,sp			; BP = saved stack pointer

	push	cs
	pop	es
	assume	es:vseg

;	Determine number of drives through BIOS GetParams call.
;
;	This may not work correctly with some systems (some Compaq's?)
;	that return only the number of drives attached to the corresponding
;	controller.  MS-DOS has decided to support the IBM approach,
;	which returns the total number of hard drives for any GetParams call.

	mov	dl,80h			; DL = physical drive number
	mov	ah,8			; AH = 'Get Drive Parameters'
	int	13h			; call BIOS
	jc	PartitionCheckDone	; no hard drives? - give up

;	DL = number of drives

	xor	dh,dh			; DX = number of drives
	mov	cx,dx			; CX = number of drives

	mov	dl,80h			; DL = physical drive number

GetPartitionTable:
	push	cx			; save number of drives remaining

	mov	bx,offset temp_buffer	; ES:BX = ptr to buffer
	mov	dh,0			; DH = head = 0
	mov	cx,1			; CX = cylinder/sector = 0/1
	mov	ax,0201h		; AX = function/#secs = READ/1
;	push	dx			; save drive number
	stc
	int	13h			; call BIOS disk services
;	pop	dx			; DL = drive number
	jc	PartitionCheckDone	; BIOS is fucking with us - give up

	mov	bx,MBR_DOSPart		; BX = offset of partition table
	mov	cx,DOS_NUMPARTS		; CX = # partition entries in table

NextPartitionEntry:
	push	cx			; save partition entry count
	mov	al,temp_buffer[bx].PartSystemID
					; AL = partition system indicator
	mov	di,offset RiskyPartitions
					; ES:DI = ptr to list of risky
					;  partition system indicators
	mov	cx,NUM_RISKYPARTITIONS	; CX = length of list
	cld
	repne	scasb			; scan list for match
	pop	cx			; CX = partition entry count again
;	je	RiskyPartition		; found a risky partition

 	jne	@f
	jmp	RiskyPartition
@@:
	add	bx,PARTENTRY_SIZE	; BX = offset of next partition entry
	loop	NextPartitionEntry

; M10 - BEGIN
;
;	Look for Extended MBR partition entries SPEEDSTOR has 4 more
;	entries but no signature in the MBR. Ontrack has 12 more entries
;	but will have signature AA55 at offset FC.
;
;	Speedstor uses system indicator 05 (DOS extended partition ID) also.
;	So if we find a 05 partition system indicator in partition entries
;	5 thru 8 we assume that it is a Speeed Stor MBR.
;

	cmp	ExtPartCheck, 0		; do we want to scan extended MBR ?
	je	NoExtPartCheck		; no

	mov	bx, MBR_OnTrkPart	; Setup regs for Ontrack disk scan
	mov	cx, (ONTRACK_NUMPARTS-DOS_NUMPARTS)
	mov	si, NUM_RISKYPARTITIONS

	cmp	word ptr temp_buffer[MBR_OnTrkSig], ONTRACK_SIG
					; Is it an OnTrack Master boot record ?
	je	NextExtPartEntry	; yes

	mov	bx, MBR_SStorPart	; setup regs for SSTOR disk type
	mov	cx, (SSTOR_NUMPARTS-DOS_NUMPARTS)
	mov	si, EXTNUM_RISKYPARTS	; This includes DOS extended partition
					; system indicator 5 also, since
					; SppedStor uses this ID also.

NextExtPartEntry:
;
; M12 - BEGIN
;
	mov	al, temp_buffer[bx].PartBoot
	and	al, 7fh
	or	al, al			; partition boot indicator should
					;  be either 0 or 80h
					;  else we assume that it is an
					;  invalid partition entry
	jnz	next_entry
;
; M12 - END
;
	mov	di, offset RiskyPartitions
	mov	al, temp_buffer[bx].PartSystemID
					; AL = partition system indicator
					; ES:DI = ptr to list of risky
					;  partition system indicators

	push	cx			; save partition entry count
	mov	cx, si			; CX = length of list

	cld
	repne	scasb			; scan list for match
	pop	cx			; CX = partition entry count again
	jne	next_entry
	jmp	RiskyPartition		; found a risky partition
next_entry:
	add	bx,PARTENTRY_SIZE	; BX = offset of next partition entry
	loop	NextExtPartEntry

NoExtPartCheck:
;
; M10 - END
;
	inc	dl			; DL = next drive number
	pop	cx			; CX = number of drives remaining
	loop	GetPartitionTable	; go check partitions on next drive
;
; M10 - BEGIN
;
PartitionCheckDone:
;
;	Chain thru the Extended partitions (id == 05) and make sure that
;	there are no Speedstor partitions within them.
;
	cmp	ExtPartCheck, 0		; do we want to scan extended partns ?
	je	ExtPartitionCheckDone	; no

	mov	dl,80h			; DL = physical drive number
	mov	ah,8			; AH = 'Get Drive Parameters'
	int	13h			; call BIOS
	jc	ExtPartitionCheckDone	; no hard drives? - give up

;	DL = number of drives

	xor	dh,dh			; DX = number of drives
	mov	cx,dx			; CX = number of drives

	mov	dl,80h			; DL = physical drive number

ExtGetPartitionTable:
	push	cx			; save number of drives remaining

	mov	bx,offset temp_buffer	; ES:BX = ptr to buffer
	mov	dh,0			; DH = head = 0
	mov	cx,1			; CX = cylinder/sector = 0/1
	mov	ax,0201h		; AX = function/#secs = READ/1
	push	dx			; save drive number
	stc
	int	13h			; call BIOS disk services
	pop	dx			; DL = drive number
	jc	ExtPartitionCheckDone	; BIOS is fucking with us - give up

NextExtMBR:
	mov	bx,MBR_DOSPart		; BX = offset of partition table
	mov	cx,DOS_NUMPARTS		; CX = # partition entries in table
NextExtPart:
	push	cx			; save partition entry count
	mov	al,temp_buffer[bx].PartSystemID
					; AL = partition system indicator
	mov	di,offset SSTORParts	; point to Speedstor partn IDs
					; ES:DI = ptr to list of risky
					;  partition system indicators
	mov	cx,NUMSSPARTIDS		; CX = number of SpeedStor partn IDs
	cld
	repne	scasb			; scan list for match
	pop	cx			; CX = partition entry count again
	je	RiskyPartition		; found a risky partition

	add	bx,PARTENTRY_SIZE	; BX = offset of next partition entry
	loop	NextExtPart

;
;	scan and find the extended partition entry (if there is one)
;
	mov	bx, MBR_DOSPart
	mov	cx, DOS_NUMPARTS
Next05:
	cmp	temp_buffer[bx]+4, 05	; Extended partition ?
	je	ReadExtendedMBR
	add	bx, PARTENTRY_SIZE
	loop	Next05

;
;	no more extended partition, try the next drive
;
	jmp	short NextExtMBRDrv
;
;	found one extended partition entry
;	temp_buffer[bx] : pointer to the extended partition entry
;
ReadExtendedMBR:

	mov	ax, 201h		; read one sector
	mov	cx, word ptr temp_buffer[bx].PartBeginSect
					; CX = cylinder/sector number
	mov	dh, temp_buffer[bx].PartBeginHead
					; DH = head number
	mov	bx, offset temp_buffer	; into temp_buffer
	stc
	int	13h
	jc	NextExtMBRDrv		; give up on this drive in case of err
	cmp	word ptr temp_buffer[MBR_Sign], MBR_SIGNATURE
					; valid boot ?
	je	NextExtMBR		; start scanning for Speedstor
					; partitions in the newly read in MBR

NextExtMBRDrv:
	inc	dl
	pop	cx
	loop	ExtGetPartitionTable

	jmp	short ExtPartitionCheckDone
;
; M10 - END
;
RiskyPartition:

;	We found a partition that is on our list of at-risk systems.  
;	Complain about it and abort our load.

	mov	sp,bp			; restore stack pointer
	stc	
	ret

ExtPartitionCheckDone:
	mov	sp,bp			; restore stack pointer

	assume	es:NOTHING

;	All the partition system indicators looked ok.
;	Vfeature Deluxe (Golden Bow Systems) could still be out there.
;	Scan the device chain for their device driver.
;	Look at offset 0Bh from each device header for the string "Vfeature".

	mov	ah,52h			; AH = 'Get Sysinit Variables'
	int	21h

;	ES:BX = ptr to sysinit variables

	add	bx,22h			; ES:BX = ptr to NUL device header

NextVfeatureCheck:
	mov	di,bx			; ES:DI = ptr to device header
	add	di,0Bh			; ES:DI = ptr to possible "Vfeature"
	mov	si,offset VfeatureStr	; DS:SI = ptr to "Vfeature" constant
	mov	cx,LEN_VFEATURESTR	; CX = string length
	cld
	repe	cmpsb			; compare the strings
	je	RiskyPartition		; they're the same - go abort

	les	bx,es:[bx]		; ES:BX = ptr to next device header
	cmp	bx,0FFFFh		; check for end of device chain
	jne	NextVfeatureCheck	; not last device - check the next one


NoRisk:
	clc
	ret

check_for_dangerous_disk_partitions endp


last_safe_byte	db	?

temp_buffer 	db 	1 
vseg ends

end 


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\doubleb\resbuf.asm ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

vseg segment byte public 'CODE'
	assume cs:vseg,ds:vseg,es:NOTHING

include ..\bambi.inc

PUBLIC  int_2f_chain
PUBLIC 	int_13_chain
PUBLIC 	sectrack	
PUBLIC 	track_buffer_ptr
PUBLIC	buffer_size
PUBLIC  track_buffer
PUBLIC  int_2f_handler
PUBLIC	safe_13_handler
PUBLIC  check_dma_services
PUBLIC  double_buffering_required

;;; RESIDENT DATA AREA anything here is not freed after initialization

Int_2f_Chain	dd	?
Int_13_Chain    dd      ?

SafeDrv		db	0	; drive (80-FF) for following info
SafeSecTrk	db	?	; sectors per track
SafeHds		db	?	; # heads



BiosDataSeg	dw	40h		; BIOS data area seg addr
DMASERVOFFSET	equ	7Bh		; offset in BIOS data area of byte
					;  containing DMA Services bit
DMASERVBIT	equ	20h		; mask for DMA Services bit

CHECK_DMA_SERVICES DB 1	;1 means check dynamically
VIA_TRACK_BUFFER DB   1 ;1 means double buffer
SECTRACK	DW	?	; Sectors per track (size of track buffer)
TRACK_BUFFER_PTR DD	0
buffer_size	dw	0

MAXDRIVES 	equ 	16

double_buffering_required	db	MAXDRIVES dup(0)

dma_descriptor_structure	struc
	dmasize		dd	?
	dmaoffset 	dd	?
	dmaseg		dw	?
	dmaid		dw	?

	dmaphysaddr	dd	?
dma_descriptor_structure	ends

dma_descriptor_struc db size dma_descriptor_structure dup(0)

mysig	dw	?


;
;return pointer to double buffer table in es:di
;
int_2f_handler proc far
	cmp	ax,MULT_BAMBI
	je	handle_bambi_api
chainint2f:
	jmp	dword ptr cs:int_2f_chain
handle_bambi_api:
	cmp	bx,BAMBI_GET_BUFFER_INFO
	jne	chainint2f
	mov	ax,BAMBI_SIGNATURE
	push	cs
	pop	es
	mov	di,offset cs:double_buffering_required

	iret
int_2f_handler endp


single_check:

	;first, set buffer to unlikely data
	push	ax
	push	dx

	push	ax
	push	di
	push	cx
	mov	cx,256	;256 words per sector
	mov	ax,cs:mysig
	mov	di,bx
	rep	stosw
	pop	cx
	pop	di
	pop	ax

	mov	al,1		;1 sector

	push	ax


	pushf
	cli
	call	dword ptr cs:int_13_chain

	pop	ax

	push	ax
	push	di
	push	cx
	mov	cx,256	;256 words per sector
	mov	ax,cs:mysig
	mov	di,bx
	repe	scasw
	cmp	cx,0	;all same?
	pop	cx
	pop	di
	pop	ax
	je	need_double_buffering

	mov	al,1		;1 sector

	push	ds
	push	si
	push	es
	push	bx
	push	ax
	push	cx

	push	es		;ds:si -> user buffer
	pop	ds
	mov	si,bx

	mov	es,word ptr cs:Track_buffer_ptr[2]
	mov	bx,word ptr cs:Track_Buffer_Ptr[0]	; es:bx = ptr to track buffer

	push	ax
	pushf
	cli
	call	dword ptr cs:int_13_chain
	pop	ax

	mov	di,bx

	mov	cx,256	;256 words per sector
	cld
	repe	cmpsw

	pop	cx
	pop	ax
	pop	bx
	pop	es
	pop	si
	pop	ds
	jnz	need_double_buffering

	clc
	pop	dx
	pop	ax
	retn


need_double_buffering:

	stc
	pop	dx
	pop	ax
	retn

;***	Safe_13_Handler - safe (double-buffered, when required) int 13 handler
;
;	Double-buffer disk i/o through track buffer, when required.

;	Input:	int 13 registers
;
;	Output:	int 13 return regs
;
;	Note:	We are an interrupt handler.
;		We use the track buffer for double-buffering.  Meaning
;		 nobody can count on the contents of the track buffer
;		 *across* a Safe_13 call.  If we use the track buffer,
;		 we will invalidate the contents.  (Valid track buffer
;		 contents are assumed to be in the cache as well, 
;		 which is out of our control.)
;
;	Note:	This code is not reentrant.

	assume	cs:vseg,ds:nothing,es:nothing,ss:nothing

Safe_13_Handler	proc	far

	sti				; allow interrupts

;*	Find out if this is really a hard disk read or write request.

	test	dl,80h
	jz	s13$Pass		; not hard drive - pass to old int 13
	cmp	ah,2
	je	s13$Ours		; read request - pay attention
	cmp	ah,3
	je	s13$Ours		; write request - pay attention

s13$Pass:

;*	Pass request to old int 13 handler.

	jmp	dword ptr int_13_chain

s13$Ours:

;*	Find out if double-buffering is required.

	cmp	Check_DMA_Services,1
	je	s13$Dyn		; no dynamic checking of DMA Services
	jmp	do_double_buffer

s13$Dyn:
;	Check if Lim/Win/EMM386 DMA Services are active.

	push	ax
	push	es
	mov	es,BiosDataSeg		; es = BIOS data area seg addr
	mov	al,es:DMASERVOFFSET	; AL contains DMA Services Active bit
	and	al,DMASERVBIT		; isolate bit
	mov	Via_Track_Buffer,al	; set double-buffering flag
	pop	es
	pop	ax



;	Via_Track_Buffer is nonzero if double-buffering is required.

	cmp	Via_Track_Buffer,0
	je	s13$Pass		; double-buffering not required
if 1

	push	bx
	mov	bx,dx
	xor	bh,bh
	sub	bx,80h
	cmp	double_buffering_required[bx],-1
	pop	bx
	jne	continue_check
	jmp	do_double_buffer
continue_check:

    	push	bx
   	mov	bx,dx
    	xor	bh,bh
    	sub	bx,80h
    	cmp	double_buffering_required[bx],4
    	pop	bx
    	jae	s13$Pass
else
	jmp	do_double_buffer
endif
check_vds:

;
;	use vds to check to see if the destination buffer is ok
;
;	int 1
	push	ax
	push	es
	push	di
	push	dx
	push	cx

if 1
	mov	cx,es	

	push	cs
	pop	es
	mov	di,offset cs:dma_descriptor_struc

	mov	es:[di].dmaseg,cx
	mov	word ptr es:[di].dmaoffset,bx

	xor	ah,ah
	xchg	al,ah
	shl	ax,1		;total multiply by 512 (sector size)
				;note, we do this correctly since this
				;lock will cause win386 to mark the 
				;buffer dirty--the ROM BIOS may not
				;know about VDS and do it itself
	mov	word ptr es:[di].dmasize,ax

	mov	dx,4		;do not attempt auto-remap
	mov	ax,8103h
	int	4bh

	pop	cx
	pop	dx
	pop	di
	pop	es
	pop	ax
	jnc	no_regionerror
	jmp	region_lock_error
no_regionerror:

	push	ax
	push	es
	push	di
	push	dx
	push	cx

	mov	dx,0		;do not copy data
	push	cs
	pop	es
	mov	di,offset cs:dma_descriptor_struc
	mov	ax,8104h
	int	4bh


	push	di
	mov	ax,es:[di].dmaseg
	xor	dx,dx
	mov	cl,4

	mov di,0FFFFh        	;      set up to make a mask
	rol ax,cl	     	;      
    	shl dx,cl	     	;      
    	shl di,cl	     	;      
    	mov cx,ax		;      
    	and ax,di	     	;      
    	not di	     		;      
    	and cx,di	     	;      
    	or  dx,cx	     	;      
	pop	di
	
	add	ax, word ptr es:[di].dmaoffset
	adc	dx,0

	cmp	ax,word ptr es:[di].dmaphysaddr[0]
	jne	phys_no_equ
	cmp	dx,word ptr es:[di].dmaphysaddr[2]
	jne	phys_no_equ

	pop	cx
	pop	dx
	pop	di
	pop	es
	pop	ax

	jmp	s13$Pass		; double-buffering not required

endif 

phys_no_equ:
	pop	cx
	pop	dx
	pop	di
	pop	es
	pop	ax

;
;Only do checking for addresses above a000 ie umbs
;
;
	push	ax
	push	bx
	shr	bx,1
	shr	bx,1
	shr	bx,1
	shr	bx,1
	inc	bx
	mov	ax,es
	add	ax,bx
	cmp	ax,0A000h
	pop	bx
	pop	ax
	jb	do_double_buffer

;	int 1

;;
;; If we get here, we can see if double buffering is really required
;; by attempting to read into the physical (!=linear) address.
;;
;; for now, only check on reads
if 1
	cmp	ah,2
	je	check_read
endif
	jmp	do_double_buffer


check_read:

	push	ax
	push	bx
	push	cx
	push	dx
	push	bp
	push	si
	push 	di
	push	es
	push	ds

	mov	cs:mysig,'SQ'
	call	single_check

	jc	double_buffering_needed
	
	mov	bx,dx
	xor	bh,bh
	sub	bx,80h	;turn drive id into index into our table
        inc	double_buffering_required[bx]

double_buffering_not_needed:
	pop	ds
	pop	es
	pop	di
	pop	si
	pop	bp
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	jmp	s13$Pass		; double-buffering not required

double_buffering_needed:

	mov	bx,dx
	xor	bh,bh
	sub	bx,80h	;turn drive id into index into our table
        mov	double_buffering_required[bx],-1

	
	pop	ds
	pop	es
	pop	di
	pop	si
	pop	bp
	pop	dx
	pop	cx
	pop	bx
	pop	ax

region_lock_error:

do_double_buffer:

;*	Double-buffer the request.

	push	si			; save registers
	push	di
	push	ds

	push	cs
	pop	ds			; ds = vseg seg addr
	assume	ds:vseg

	cmp	al,byte ptr SecTrack	; will xfr fit in track buffer?
	ja	s13$Split		; it won't fit
	call	SafeXfr			; transfer it via track buffer
	jmp	short s13$Done

s13$Split:
	call	SafeSplit		; split transfer to fit in track buf

s13$Done:

	pop	ds			; restore registers
	pop	di
	pop	si
	ret	2

Safe_13_Handler	endp




;***	SafeSplit - split disk transfer up and double-buffer via track buffer
;
;	Input:	int 13 regs
;		ah = 2 or 3
;		al > SecTrack (size of track buffer)
;		ds = vseg seg addr
;
;	Output:	int 13 return
;
;	Used:	si,di
;
;	Note:	That's right, al is greater than, NOT equal to
;		the size of the track buffer in sectors.

SafeSplit	proc

	push	bx			; save registers
	push	cx
	push	dx
	push	bp
	push	ax

ss$Next:
	mov	bp,ax			; bp = saved ax
	mov	al,byte ptr SecTrack	; al = # sectors in track buffer
	call	SafeXfr			; transfer one track buffer's worth
	jc	ss$Done			; return int 13 error
	mov	ax,bp			; ax restored
	call	SafeAdjNext		; adjust reg's to next piece
	jc	ss$Done			; return int 13 error
	cmp	al,byte ptr SecTrack
	jbe	ss$Last			; last xfr coming up
	jmp	ss$Next			; go do next track buffer's worth

ss$Last:
	call	SafeXfr			; xfr last piece

ss$Done:
	pop	bx			; bx = original ax
	mov	al,bl			; restore original sector count
	pop	bp			; restore regs
	pop	dx
	pop	cx
	pop	bx
	ret
	
SafeSplit	endp




;***	SafeAdjNext - adjust int 13 reg's to next xfr piece
;
;	Assuming we just transferred a track buffer's worth,
;	adjust the int 13 registers to point to the rest.
;
;	We'll obtain sec/track and #heads info via int 13,
;	returning any error from that call.  Not relying
;	on SMARTDrive's internal drive tables will help
;	make us bulletproof.
;
;	Input:	int 13 input reg's
;		ah = 2 or 3
;		al > SecTrack (size of track buffer)
;		ds = vseg seg addr
;
;	Output:	int 13 reg's for rest of transfer
;		or possible carry set if drive info int 13 call failed
;		 in which case ah = error code
;
;	Used:	si
;
;	Note:	That's right, al is greater than, NOT equal to
;		the size of the track buffer in sectors.

SafeAdjNext	proc

	push	ax			; save ax
	cmp	dl,SafeDrv		; same drive as last time thru?
	je	sa$Adj			; yes, don't update drive info
	call	SafeDrvInfo		; update drive info
	jnc	sa$Adj			; no error, continue
	pop	si			; discard saved ax
	ret				; return int 13 error
sa$Adj:
	xor	ax,ax
	mov	ah,byte ptr SecTrack	; ax = # words transferred
	shl	ax,1			; ax = # bytes transferred
	add	bx,ax			; bx = new offset in user buffer

	mov	ax,cx			; ax = cyl,sector
	and	ax,00111111b		; ax = sector
	dec	ax			; ax = 0-based sector #
	add	ax,SecTrack		; ax = next sector before adjustment
	div	SafeSecTrk		; al = tracks passed
	inc	ah			; ah = next sector
	and	cl,11000000b		; cx = cyl,
	or	cl,ah			; cx = cyl,next sector
	add	dh,al			; dh = next head before adjustment
sa$Hd:	cmp	dh,SafeHds
	jb	sa$Done			; head is legal
	sub	dh,SafeHds		; dh = head decr'd by # heads
	inc	ch			; bump cylinder
	jnz	sa$Hd
	add	cl,40h			; bump upper two bits of cylinder
	jmp	sa$Hd			; and check head again
sa$Done:
	pop	ax			; restore ax
	sub	al,byte ptr SecTrack	; al = # sectors left in xfr

;	Carry is clear.

	ret	

SafeAdjNext	endp




;***	SafeDrvInfo - get info for drive we're dealing with
;
;	Input:	int 13 regs
;		dl = drv (80-FF)
;
;	Output:	regs unchanged except ax
;		if error returned from int 13 get drive info,
;		  carry = set
;		  ah = error code
;
;	Used:	ax
;
;	Effect:	SafeDrv, SafeSecTrk, SafeHds updated

SafeDrvInfo	proc

	push	bx		; save registers
	push	cx
	push	dx
	push	di
	push	es

	mov	ah,8		; al = Int 13 "Get drive parameters" function

	pushf
	cli
	call	dword ptr cs:int_13_chain

	jc	sd$Ret		; return int 13 error

	and	cl,00111111b	; cl = sectors per track
	mov	SafeSecTrk,cl	; record sectors per track
	inc	dh		; dh = # heads
	mov	SafeHds,dh	; record # heads

;	The above instructions leave CY clear.

sd$Ret:
	pop	es		; restore registers
	pop	di
	pop	dx
	pop	cx
	pop	bx
	jc	@F		; if error, don't update drive number
	mov	SafeDrv,dl	; update drive number for recorded info
@@:	ret

SafeDrvInfo	endp




;***	SafeXfr - double-buffer disk transfer via track buffer
;
;	Input:	int 13 regs
;		ah = 2 or 3
;		al <= SecTrack  (size of track buffer)
;		ds = vseg seg addr
;
;	Output:	int 13 returns
;
;	Used:	si,di

Int13AX		label	word
Int13Sectors	db	?
Int13Function	db	?

SafeXfr	proc

	mov	Int13AX,ax		; save function code, sector count

	cmp	ah,2
	je	sx$Read			; read request

	call	SafeXfrBuf		; write request
	call	SafeXfrDisk
	jmp	short sx$Ret

sx$Read:
	call	SafeXfrDisk
	jc	sx$Ret			; return int 13 error
	call	SafeXfrBuf

sx$Ret:	ret

SafeXfr	endp




;***	SafeXfrDisk - transfer between track buffer and disk for SafeXfr
;
;	Input:	int 13 regs
;		ah = 2 or 3
;		al <= SecTrack (size of track buffer)
;		es:bx = ptr to original buffer, not track buffer
;		ds = vseg seg addr
;
;	Output:	int 13 returns
;		es:bx = still ptr to original buffer (which is untouched)

SafeXfrDisk	proc

	push	es			; save ptr to dest buffer
	push	bx

	mov	es,word ptr Track_buffer_ptr[2]
	mov	bx,word ptr Track_Buffer_Ptr[0]	; es:bx = ptr to track buffer

	pushf
	cli
	call	dword ptr cs:int_13_chain

	pop	bx			; bx = offset of dest buffer
	pop	es			; es = seg addr of dest buffer
	ret

SafeXfrDisk	endp




;***	SafeXfrBuf - transfer between track buf and original buf for SafeXfr
;
;	Input:	int 13 regs (may be before or after call)
;		Int13AX = ax before int 13 call
;		ds = vseg seg addr
;
;	Output:	same regs
;
;	Used:	si,di, but NOT flags

SafeXfrBuf	proc
	assume	ds:nothing

	pushf				; save flags
	push	ds			; save seg regs
	push	es

	mov	ds,word ptr Track_buffer_ptr[2]
	mov	si,word ptr track_buffer_ptr[0]	; ds:si = ptr to track buffer
	mov	di,bx			; es:di = ptr to original buffer

	cmp	si,di
	jne	sb$Move			; track buf & original buf not same
	push	ax
	mov	ax,ds
	mov	bx,es
	cmp	ax,bx
	mov	bx,di			; bx = ptr to original buffer again
	pop	ax
	je	sb$Ret			; buffers are same, we're done
sb$Move:
	cmp	Int13Function,2
	je	sb$Read			; read request, track buf -> orig buf
	xchg	si,di			; write request, orig buf -> track buf
	push	es
	pop	ds			; ds:si = ptr to original buffer
	assume	ds:nothing
	mov	es,word ptr Track_buffer_ptr[2]
sb$Read:
	push	cx			; save cx
	xor	cl,cl
	mov	ch,Int13Sectors		; cx = # words in transfer
	cld

;	Check for odd-boundary segment wrap in buffer.  ;M02

	test	bx,1		   ;M02 ; bx = 1 if buffer offset is odd
	jnz	sb$Odd		   ;M02	; odd offset - check for address wrap

sb$MoveWords:
	rep	movsw			; move data one way or t' other
	pop	cx			; restore cx

sb$Ret:
	pop	es			; restore seg regs
	pop	ds
	popf				; restore flags
	ret

	;M02	begin

;*	Buffer is at an odd address offset.  If the transfer will
;	wrap past the end of the segment address, we'd better do
;	a byte move to avoid GP faulting.

sb$Odd:
	shl	cx,1			; cx = # bytes in transfer
	dec	bx			; bx = buffer address minus 1
	add	bx,cx
	sub	bx,cx			; bx unchanged, but CY set for wrap
	inc	bx
	jc	sb$MoveBytes		; address wrap - move bytes

;	No address wrap, go back and do word move.

	shr	cx,1			; cx = # words in transfer
	jmp	sb$MoveWords

sb$MoveBytes:
	rep	movsb			; move data one way or t' other
	pop	cx			; restore cx
	jmp	sb$Ret

	;M02	end

	assume	ds:vseg

SafeXfrBuf	endp

TRACK_BUFFER:

vseg ends

end 

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\doubleb\safedsk.asm ===
;
;       Microsoft Confidential
;       Copyright (C) Microsoft Corporation 1991
;       All Rights Reserved.
;


vseg segment para public 'CODE'
	assume cs:vseg,ds:vseg,es:NOTHING

	org     0

PUBLIC  Interrupt
PUBLIC  Strategy

extrn   init_safedsk:near
extrn   buffer_size:word
extrn   track_buffer:byte

Header:
	dd      -1                      ;device chain link--filled in by dos
DevAttr dw      0C840h                  ;character device attribute word
	dw      Strategy                ;Strategy entry point
	dw      Interrupt               ;Interrupt entry point
	db      '_doubleB'              ;logical device name

RHPtr   dd      ?                       ;Request Header pointer filled in by 
					;Strategy routing

Strategy        proc    far

	mov     WORD PTR cs:[RHPtr],bx
	mov     WORD PTR cs:[RHPTR+2],es
	ret

Strategy        endp

Interrupt       proc    far
	push    ds
	push    es
	push    di
	push    bx
	push    dx

	push    cs
	pop     ds

	l